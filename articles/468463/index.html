<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèæ ü§πüèª üë®‚Äçüëß‚Äçüëß Mejora del rendimiento de Zabbix + PostgreSQL con particionamiento e indexaci√≥n üëÖ üë®‚Äçüéì üëÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace aproximadamente un a√±o, mis colegas y yo tuvimos la tarea de resolver el uso del popular sistema de monitoreo de infraestructura de red: Zabbix. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mejora del rendimiento de Zabbix + PostgreSQL con particionamiento e indexaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468463/"> Hace aproximadamente un a√±o, mis colegas y yo tuvimos la tarea de resolver el uso del popular sistema de monitoreo de infraestructura de red: Zabbix.  Despu√©s de estudiar la documentaci√≥n, inmediatamente procedimos a las pruebas de carga: quer√≠amos evaluar cu√°ntos par√°metros puede trabajar Zabbix sin ca√≠das de rendimiento notables.  Solo PostgreSQL se us√≥ como DBMS. <br><br>  Durante las pruebas, se identificaron algunas caracter√≠sticas arquitect√≥nicas del dise√±o de la base de datos y el comportamiento del sistema de monitoreo en s√≠, que por defecto no permiten que el sistema de monitoreo alcance su m√°xima potencia.  Como resultado, se desarrollaron, realizaron y probaron algunas medidas de optimizaci√≥n principalmente en t√©rminos de ajuste de la base de datos. <br><br>  Quiero compartir los resultados del trabajo realizado en este art√≠culo.  Este art√≠culo ser√° √∫til tanto para los administradores de DBA de Zabbix como para PostgreSQL, as√≠ como para todos los que quieran comprender y comprender mejor el popular DBMS de PosgreSQL. <br><br>  Un peque√±o spoiler: en una m√°quina d√©bil con una carga de 200 mil par√°metros por minuto, logramos reducir el iowait de la CPU del 20% al 2%, reducir el tiempo de grabaci√≥n en porciones a las tablas de datos primarios en 250 veces y a las tablas de datos agregados en 32 veces, reducir el tama√±o de los √≠ndices 5-10 veces y acelerar la recepci√≥n de muestras hist√≥ricas en algunos casos hasta 18 veces. <br><a name="habracut"></a><br><h4>  Prueba de carga </h4><br>  La prueba de carga se realiz√≥ de acuerdo con el esquema: un servidor Zabbix, un proxy Zabbix activo, dos agentes.  Cada agente se configur√≥ para dar 50 toneladas de n√∫mero entero y 50 toneladas de par√°metros de cadena por minuto (un total de 200 toneladas de par√°metros por minuto o 3333 par√°metros por segundo).  Para generar los par√°metros del agente, utilizamos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento para Zabbix.</a> Para verificar cu√°ntos par√°metros puede generar un agente, debe usar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">script especial del mismo autor del complemento zabbix_module_stress</a> .  El administrador web de Zabbix tiene dificultades para registrar plantillas grandes, por lo que dividimos los par√°metros en 20 plantillas con 5 toneladas de par√°metros (2500 num√©ricos y 2500 cadenas). <br><br><div class="spoiler">  <b class="spoiler_title">Plantilla de generador de scripts para pruebas de carga en python</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-string"><span class="hljs-string">"""     .   20   5000    ( 2500  :  echo,  ;  ping,  ) """</span></span> TEMP_HEAD = <span class="hljs-string"><span class="hljs-string">""" &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;zabbix_export&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;date&gt;2015-08-17T23:15:01Z&lt;/date&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;templates&gt; &lt;template&gt; &lt;template&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/template&gt; &lt;name&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/name&gt; &lt;description/&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;applications/&gt; &lt;items&gt; """</span></span> TEMP_END = <span class="hljs-string"><span class="hljs-string">"""&lt;/items&gt; &lt;discovery_rules/&gt; &lt;macros/&gt; &lt;templates/&gt; &lt;screens/&gt; &lt;/template&gt; &lt;/templates&gt; &lt;/zabbix_export&gt; """</span></span> TEMP_ITEM = <span class="hljs-string"><span class="hljs-string">"""&lt;item&gt; &lt;name&gt;{k}&lt;/name&gt; &lt;type&gt;0&lt;/type&gt; &lt;snmp_community/&gt; &lt;multiplier&gt;0&lt;/multiplier&gt; &lt;snmp_oid/&gt; &lt;key&gt;{k}&lt;/key&gt; &lt;delay&gt;1m&lt;/delay&gt; &lt;history&gt;3&lt;/history&gt; &lt;trends&gt;365&lt;/trends&gt; &lt;status&gt;0&lt;/status&gt; &lt;value_type&gt;{t}&lt;/value_type&gt; &lt;allowed_hosts/&gt; &lt;units/&gt; &lt;delta&gt;0&lt;/delta&gt; &lt;snmpv3_contextname/&gt; &lt;snmpv3_securityname/&gt; &lt;snmpv3_securitylevel&gt;0&lt;/snmpv3_securitylevel&gt; &lt;snmpv3_authprotocol&gt;0&lt;/snmpv3_authprotocol&gt; &lt;snmpv3_authpassphrase/&gt; &lt;snmpv3_privprotocol&gt;0&lt;/snmpv3_privprotocol&gt; &lt;snmpv3_privpassphrase/&gt; &lt;formula&gt;1&lt;/formula&gt; &lt;delay_flex/&gt; &lt;params/&gt; &lt;ipmi_sensor/&gt; &lt;data_type&gt;0&lt;/data_type&gt; &lt;authtype&gt;0&lt;/authtype&gt; &lt;username/&gt; &lt;password/&gt; &lt;publickey/&gt; &lt;privatekey/&gt; &lt;port/&gt; &lt;description/&gt; &lt;inventory_link&gt;0&lt;/inventory_link&gt; &lt;applications/&gt; &lt;valuemap/&gt; &lt;logtimefmt/&gt; &lt;/item&gt; """</span></span> TMP_FNAME_DEFAULT = <span class="hljs-string"><span class="hljs-string">"Template_App_Zabbix_Server_Stress_{count}_passive_{char}.xml"</span></span> chars = <span class="hljs-string"><span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: parser = argparse.ArgumentParser( description=<span class="hljs-string"><span class="hljs-string">'     zabbix'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--items'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'items'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1000</span></span>, help=<span class="hljs-string"><span class="hljs-string">'-   (default: 1000)'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--templates'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'templates'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1</span></span>, help=<span class="hljs-string"><span class="hljs-string">f'-  [1-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">] (default: 1)'</span></span>) args = parser.parse_args() items_count = args.items tmps_count = args.templates <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (tmps_count &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tmps_count &lt;= len(chars)): sys.exit(<span class="hljs-string"><span class="hljs-string">f"Templates must be in range 1 - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(tmps_count): fname = TMP_FNAME_DEFAULT.format(count=items_count, char=chars[i]) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(fname, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> output: output.write(TEMP_HEAD.format(count=items_count, char=chars[i])) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [(<span class="hljs-string"><span class="hljs-string">'stress.ping[{}-I-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-string"><span class="hljs-string">'stress.echo[{}-S-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)]: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(items_count/<span class="hljs-number"><span class="hljs-number">2</span></span>)): output.write(TEMP_ITEM.format(k=k.format(chars[i],j),t=t)) output.write(TEMP_END)</code> </pre> <br></div></div><br>  La m√©trica del iostat de la CPU es un buen indicador del rendimiento de Zabbix: refleja la fracci√≥n de la unidad de tiempo durante la cual el procesador espera el acceso al disco.  Cuanto m√°s alto es, m√°s se ocupa el disco con las operaciones de lectura y escritura, lo que afecta indirectamente la degradaci√≥n del rendimiento del sistema de monitoreo en su conjunto.  Es decir  Esta es una se√±al segura de que algo est√° mal con el monitoreo.  Por cierto, en los espacios abiertos de la red, la pregunta m√°s popular es "c√≥mo quitar el activador de iostat en Zabbix", por lo que este es un punto doloroso, porque hay muchas razones para aumentar el valor de la m√©trica iowait. <br><br>  Aqu√≠ est√° la imagen de la m√©trica de CPU Iowait que obtuvimos tres d√≠as despu√©s inicialmente: <br><br><img src="https://habrastorage.org/webt/dc/md/yo/dcmdyote_ghzxca-o9sft88ptxq.png"><br><br>  Pero, ¬øqu√© imagen para la misma m√©trica tambi√©n obtuvimos dentro de tres d√≠as al final despu√©s de todas las medidas de optimizaci√≥n que se han hecho, que se discutir√°n a continuaci√≥n: <br><br><img src="https://habrastorage.org/webt/do/cs/fc/docsfcjjczkhgxoubjayslrohuw.png"><br><br>  Como se puede ver en los gr√°ficos, el indicador de CPU Iowait cay√≥ de casi 20% a 2%, lo que aceler√≥ indirectamente el tiempo de ejecuci√≥n de todas las solicitudes para agregar y leer datos.  Ahora veamos por qu√©, con la configuraci√≥n est√°ndar de la base de datos, el rendimiento general del sistema de monitoreo disminuye y c√≥mo solucionarlo. <br><br><h4>  Razones para la ca√≠da de rendimiento de Zabbix </h4><br>  Con la acumulaci√≥n de m√°s de 10 millones de valores de par√°metros en cada tabla de datos primarios, se not√≥ que el rendimiento del sistema de monitoreo cae bruscamente, debido a las siguientes razones: <br><br><ul><li>  la m√©trica iowait para la CPU del servidor se incrementa en m√°s del 20%, lo que indica un aumento en el tiempo durante el cual la CPU espera acceder a las operaciones de lectura y escritura del disco </li><li>  √≠ndices de tablas en los que los datos de monitoreo est√°n muy inflados </li><li>  la m√©trica de utilizaci√≥n aumenta al 100% para un disco con datos de monitoreo, lo que indica la carga completa del disco con operaciones de lectura y escritura </li><li>  los valores obsoletos no tienen tiempo para eliminarse de las tablas del historial cuando se limpia de acuerdo con el cronograma del ama de llaves </li></ul><br>  La situaci√≥n se agrava al comienzo de cada hora, cuando adem√°s de esto, se calculan estad√≠sticas agregadas por hora, mientras se leen y escriben activamente p√°ginas de √≠ndice del disco, se eliminan datos obsoletos del historial, lo que conduce al mismo resultado: una ca√≠da en el rendimiento de la base de datos y un aumento en el tiempo de ejecuci√≥n solicitudes (en el l√≠mite, se observ√≥ una solicitud que dur√≥ hasta 5 minutos). <br><br>  Un poco de ayuda para organizar un almac√©n de datos de monitoreo en Zabbix.  Almacena datos primarios y datos agregados en diferentes tablas, adem√°s, con la separaci√≥n de los tipos de par√°metros.  Cada tabla almacena un campo itemid (una referencia impl√≠cita a un elemento de datos registrado en el sistema), una marca de tiempo para registrar el valor del reloj en formato de marca de tiempo unix (milisegundos en una columna separada) y un valor en una columna separada (la excepci√≥n es la tabla de registro, tiene m√°s campos, similar al registro de eventos ): <br><div class="scrollable-table"><table><tbody><tr><th>  Nombre de la tabla </th><th>  Cita </th><th>  Tipo de datos </th></tr><tr><td>  historia </td><td>  Datos de monitoreo primario </td><td>  num√©rico (16.4) </td></tr><tr><td>  historia_un </td><td>  Datos de monitoreo primario </td><td>  num√©rico (20.0) </td></tr><tr><td>  history_str </td><td>  Datos de monitoreo primario </td><td>  varchar (255) </td></tr><tr><td>  texto_historia </td><td>  Datos de monitoreo primario </td><td>  texto </td></tr><tr><td>  registros_hist√≥ricos </td><td>  Datos de monitoreo primario </td><td>  campos de texto e int </td></tr><tr><td>  tendencias </td><td>  Datos de monitoreo agregados </td><td>  num√©rico (16.4) </td></tr><tr><td>  tendencias_un </td><td>  Datos de monitoreo agregados </td><td>  num√©rico (20.0) </td></tr></tbody></table></div><h4>  Actividades de optimizaci√≥n </h4><br>  Para mejorar el rendimiento de la base de datos PostgreSQL, se llevaron a cabo varias medidas de optimizaci√≥n, la principal de las cuales es la partici√≥n y el cambio de √≠ndices.  Sin embargo, vale la pena mencionar algunas palabras sobre algunas medidas importantes y √∫tiles que pueden acelerar el trabajo de cualquier base de datos bajo el sistema de administraci√≥n de bases de datos PostgreSQL. <br><br>  <b>Nota importante.</b>  En el momento de recopilar el material del art√≠culo, utilizamos Zabbix versi√≥n 4.0, aunque la versi√≥n 4.2 ya se ha lanzado y la versi√≥n 4.4 se est√° preparando para su lanzamiento.  ¬øPor qu√© es importante mencionar esto?  Debido a que a partir de la versi√≥n 4.2, Zabbix comenz√≥ a admitir una extensi√≥n poderosa especial para trabajar con series temporales de TimescaleDB, pero hasta ahora en modo experimental: por todas las ventajas de usar esta extensi√≥n, se cree que algunas solicitudes comenzaron a funcionar m√°s lentamente y todav√≠a hay problemas de rendimiento sin resolver ( resuelto en la versi√≥n 4.4) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lea este art√≠culo</a> .  <i>En el pr√≥ximo art√≠culo, planeo escribir sobre los resultados de las pruebas de carga que ya usan la extensi√≥n TimescaleDB en comparaci√≥n con este caso de soluci√≥n.</i>  La versi√≥n PostgreSQL se us√≥ 10, pero toda la informaci√≥n dada es relevante para las versiones 11 y 12 (¬°estamos esperando!). <br><br>  Por lo tanto, lo primero es lo primero: <br><br><ul><li>  configurar un archivo de configuraci√≥n usando la utilidad pgtune </li><li>  poner la base de datos en un disco f√≠sico separado </li><li>  particionando tablas de historial con pg_pathman </li><li>  cambio de tipos de √≠ndice de tablas de historial a brin (reloj) y btree-gin (itemid) </li><li>  recopilaci√≥n y an√°lisis de estad√≠sticas de ejecuci√≥n de consultas pg_stat_statements </li><li>  establecer par√°metros de monitoreo de disco f√≠sico </li><li>  mejora del rendimiento del hardware </li><li>  creaci√≥n de un cl√∫ster distribuido (material m√°s all√° del alcance de este art√≠culo) </li></ul><br><br><h4>  Configurar un archivo de configuraci√≥n usando la utilidad pgtune </h4><br>  De hecho, PostgreSQL es un DBMS bastante ligero.  Su archivo de configuraci√≥n predeterminado est√° configurado para que, como dice mi colega, "incluso trabaje en la m√°quina de caf√©", es decir  en un hierro muy modesto  Por lo tanto, es necesario configurar PostgreSQL para la configuraci√≥n del servidor, teniendo en cuenta la cantidad de memoria, la cantidad de procesadores, el tipo de uso previsto de la base de datos, el tipo de disco (HDD o SSD) y la cantidad de conexiones. <br><br>  Por desgracia, no existe una f√≥rmula √∫nica para ajustar todos los DBMS, pero hay ciertas reglas y patrones que son adecuados para la mayor√≠a de las configuraciones (un ajuste m√°s fino ya es el trabajo de un experto).  Para simplificar la vida de DBA, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribi√≥ la</a> utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgtune</a> , que fue complementada por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n web</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">le0pard</a> , autor de un libro interesante y √∫til sobre la administraci√≥n de PostgreSQL. <br><br>  Un ejemplo de ejecuci√≥n de la utilidad en la consola con 100 conexiones (Zabbix tiene un administrador web exigente) para el tipo de aplicaci√≥n "Almacenes de datos": <br><br><pre>  pgtune -i postgresql.conf -o new_postgresql.conf -T DW -c 100 </pre><br><div class="spoiler">  <b class="spoiler_title">Los par√°metros de configuraci√≥n que la utilidad pgtune cambia con una descripci√≥n del prop√≥sito (los valores se dan como ejemplo)</b> <div class="spoiler_text"><pre> # Versi√≥n DB: 11
 # Tipo de sistema operativo: linux
 # Tipo de base de datos: web
 # Memoria total (RAM): 8 GB
 # N√∫mero de CPU: 1
 # Conexiones num .: 100
 # Almacenamiento de datos: disco duro<font></font>
<font></font>
 max_connections = 100 # n√∫mero m√°ximo de conexiones de bases de datos concurrentes
 shared_buffers = 2GB # tama√±o de memoria para varios buffers (principalmente cach√© de bloques de tabla y bloques de √≠ndice) en memoria compartida
 eficaz_cach√©_tama√±o = 6 GB # tama√±o m√°ximo de memoria requerida para la ejecuci√≥n de consultas mediante √≠ndices
 maintenance_work_mem = 512MB # afecta la velocidad de las operaciones VAC√çO, ANALIZAR, CREAR √çNDICE
 checkpoint_completion_target = 0.7 # tiempo objetivo para completar el procedimiento de punto de control
 wal_buffers = 16MB # cantidad de memoria utilizada por la memoria compartida para mantener registros de transacciones
 default_statistics_target = 100 # cantidad de estad√≠sticas recopiladas por el comando ANALYZE: al aumentar, el optimizador crea consultas m√°s lentamente, pero mejor
 random_page_cost = 4 # costo condicional del acceso al √≠ndice a p√°ginas de datos - afecta la decisi√≥n de usar el √≠ndice
 efectivos_io_concurrencia = 2 # n√∫mero de operaciones de E / S as√≠ncronas que el DBMS intentar√° realizar en una sesi√≥n separada
 work_mem = 10485kB # la cantidad de memoria utilizada para ordenar y tablas hash antes de usar archivos temporales en el disco
 min_wal_size = 1GB # l√≠mites por debajo del n√∫mero de archivos WAL que se reciclar√°n para uso futuro
 max_wal_size = 2GB # limita la cantidad de archivos WAL que se reciclar√°n para uso futuro </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Algunas opciones √∫tiles de configuraci√≥n postgresql</b> <div class="spoiler_text"><pre> # gesti√≥n de manejadores de solicitudes concurrentes
 max_worker_processes = 8 # el n√∫mero m√°ximo de procesos en segundo plano, al menos uno por base de datos
 max_parallel_workers_per_gather = 4 # n√∫mero m√°ximo de procesos paralelos dentro de una sola solicitud
 max_parallel_workers = 8 # el n√∫mero m√°ximo de procesos de trabajo que el sistema puede soportar para operaciones paralelas<font></font>
<font></font>
 # configuraci√≥n de registro (una manera f√°cil de conocer el tiempo de ejecuci√≥n de las solicitudes sin usar la extensi√≥n pg_stat_statements)
 log_min_duration_statement = 3000 # escribe en los registros la duraci√≥n de la ejecuci√≥n de todos los comandos cuyo tiempo de operaci√≥n&gt; = del valor especificado en ms
 log_duration = off # registra la duraci√≥n de cada comando completado
 log_statement = 'none' # qu√© comandos SQL escribir en el registro, valores: none (deshabilitado), ddl, mod y all (todos los comandos)
 debug_print_plan = off # salida del √°rbol del plan de consulta para su posterior an√°lisis<font></font>
<font></font>
 # exprima el m√°ximo de la base de datos y est√© listo para obtenerlo ante cualquier falla (para los m√°s reprimidos, que ignoran la existencia de SSD y un cl√∫ster distribuido)
 #fsync = off # escritura f√≠sica en el disco de cambios, deshabilitar fsync proporciona una ganancia de velocidad, pero puede provocar fallas permanentes
 #synchronous_commit = off # le permite responder al cliente incluso antes de que la informaci√≥n de la transacci√≥n est√© en el WAL, una alternativa casi segura para deshabilitar fsync
 #full_page_writes = off # shutdown acelera las operaciones normales, pero puede provocar corrupci√≥n o corrupci√≥n de datos si el sistema falla </pre></div></div><br><h4>  Listado de una base de datos en un disco f√≠sico separado </h4><br>  <i>Este elemento es opcional y, m√°s bien, es una soluci√≥n de transici√≥n para un cl√∫ster distribuido completo, pero ser√° √∫til saber acerca de esta posibilidad.</i>  Para acelerar la base de datos, puede ponerla en un disco separado.  Montamos todo el disco en el directorio base, donde se almacenan todas las bases de datos PostgreSQL, pero en general se puede hacer de manera diferente: crear una nueva base de tabla y transferir la base de datos (o incluso solo una parte de ella, las tablas de datos de monitoreo primario y agregado) a esta base de tabla en un disco separado. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de montaje</b> <div class="spoiler_text">  Primero debe formatear el disco con el sistema de archivos ext4 y conectarlo al servidor.  Monte el disco para la base de datos con la etiqueta noatime: <br><br><pre>  mount / dev / sdc1 / var / lib / pgsql / 10 / data / base -o noatime </pre><br>  Para el montaje permanente, agregue la l√≠nea al archivo / etc / fstab: <br><br><pre> # donde UUID es el identificador del disco, puede verlo usando la utilidad blkid
 UUID = 121efe29-70bf-410b-bc71-90704568ce3b / var / lib / pgsql / 10 / data / base ext4 por defecto, noatime 0 0 </pre><br></div></div><br><h4>  Particionar tablas de historial con pg_pathman </h4><br>  Uno de los problemas que encontramos durante las pruebas de resistencia de Zabbix: PostgreSQL no logra eliminar datos obsoletos de la base de datos.  Usando la partici√≥n, puede dividir la tabla en sus partes constituyentes, reduciendo as√≠ el tama√±o de los √≠ndices y las partes constituyentes de la supertabla, lo que afecta positivamente la velocidad de la base de datos en su conjunto. <br><br>  La partici√≥n resuelve dos problemas a la vez: <br><br>  1. acelerar la eliminaci√≥n de datos obsoletos eliminando tablas enteras <br><br>  2. divisi√≥n de √≠ndices para cada tabla compuesta <br><br>  Hay cuatro mecanismos para particionar en PostgreSQL: <br><br>  1. restricci√≥n est√°ndar_exclusi√≥n <br><br>  2. extensi√≥n pg_partman ( <i>no confunda con pg_pathman</i> ) <br><br>  3. extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_pathman</a> <br><br>  4. crear y mantener particiones manualmente por nosotros mismos <br><br>  La soluci√≥n de particionamiento m√°s conveniente, confiable y optimizada, en nuestra opini√≥n, es la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_pathman</a> .  Con este m√©todo de partici√≥n, el planificador de consultas determina de manera flexible en qu√© particiones buscar datos.  <i>Se rumorea que en la versi√≥n 12 de PostgreSQL habr√° una excelente partici√≥n ya lista para usar.</i> <br><br>  Por lo tanto, comenzamos a escribir datos de monitoreo para cada d√≠a en una tabla heredada separada de la supertable y la eliminaci√≥n de valores de par√°metros obsoletos comenz√≥ a ocurrir mediante la eliminaci√≥n de todas las tablas obsoletas a la vez, lo que es mucho m√°s f√°cil para un DBMS por los costos laborales.  La eliminaci√≥n se realiz√≥ llamando a la funci√≥n de usuario de la base de datos como un par√°metro de monitoreo del servidor Zabbix a las 2 a.m. con una indicaci√≥n del rango aceptable de almacenamiento de estad√≠sticas. <br><br><div class="spoiler">  <b class="spoiler_title">Instalar y configurar particiones para PostgreSQL 10</b> <div class="spoiler_text">  Instale y configure la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_pathman</a> desde el repositorio est√°ndar del sistema operativo (para obtener instrucciones sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo</a> construir la √∫ltima versi√≥n de la extensi√≥n desde las fuentes, busque en el mismo repositorio en github): <br><br><pre> yum install pg_pathman10
 nano /var/pgsqldb/postgresql.conf
 shared_preload_libraries = 'pg_pathman' # importante: aqu√≠ escriba pg_pathman √∫ltimo en la lista
</pre><br>  Reiniciamos el DBMS, creamos una extensi√≥n para la base de datos y configuramos la partici√≥n (1 d√≠a para los datos de monitoreo primarios y 3 d√≠as para los datos de monitoreo agregados; podr√≠a hacerse durante 1 d√≠a): <br><br><pre> systemctl restart postgresql-10.service
 psql -d zabbix -U postgres
 CREAR EXTENSI√ìN pg_pathman;
 # configurar un d√≠a para las tablas de datos de monitoreo primario
 # 1552424400 - cuenta regresiva como marca de tiempo Unix, 86400 - segundos en d√≠as
 seleccione create_range_partitions ('historial', 'reloj', 1552424400, 86400);
 seleccione create_range_partitions ('history_uint', 'clock', 1552424400, 86400);
 seleccione create_range_partitions ('history_text', 'clock', 1552424400, 86400);
 seleccione create_range_partitions ('history_str', 'clock', 1552424400, 86400);
 seleccione create_range_partitions ('history_log', 'clock', 1552424400, 86400);
 # configurar durante tres d√≠as para tablas de datos de monitoreo agregados
 # 1552424400 - cuenta regresiva como marca de tiempo Unix, 259200 - segundos en tres d√≠as
 seleccione create_range_partitions ('tendencias', 'reloj', 1545771600, 259200);  
 seleccione create_range_partitions ('trends_uint', 'clock', 1545771600, 259200); 
</pre><br>  <i>Si todav√≠a no hay datos en ninguna de las tablas, al llamar a la funci√≥n create_range_partitions, se debe pasar un argumento adicional p_count = 0_.</i> <br><br>  Consultas √∫tiles para monitorear y administrar particiones: <br><br><pre> # lista general de tablas particionadas, almacenamiento de configuraci√≥n principal:
 seleccione * de pathman_config;
 # representaci√≥n con todas las secciones existentes, as√≠ como sus padres y l√≠mites de rango:
 seleccione * de pathman_partition_list;
 # par√°metros adicionales que anulan el comportamiento est√°ndar de pg_pathman:
 seleccione * de pathman_config_params;
 # copie el contenido nuevamente en la tabla principal y elimine las particiones:
 seleccione drop_partitions ('nombre_tabla' :: regclass, falso);
</pre><br>  Script √∫til para ver estad√≠sticas sobre el n√∫mero y el tama√±o de las particiones: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> schemaname, relname, relkind, <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span> (reltuples <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>), pg_size_pretty(pg_relation_size(C.oid)) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"size"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class C <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace N <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (N.oid = C.relnamespace) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'pg_catalog'</span></span>, <span class="hljs-string"><span class="hljs-string">'information_schema'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'history%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'trends%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-comment"><span class="hljs-comment">-- and reltuples &gt; 0 -- and pg_relation_size(C.oid) &gt;= 0 ORDER BY schemaname, relname</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Autoajuste para eliminar particiones obsoletas (ahtung - una gran funci√≥n SQL)</b> <div class="spoiler_text">  Para configurar la eliminaci√≥n autom√°tica de particiones, debe crear una funci√≥n en la base de datos <br>  (texto ancho, as√≠ que tuve que eliminar el resaltado de sintaxis): <br><br><pre> CREAR O REEMPLAZAR LA FUNCI√ìN public.delete_old_partitions (history_days integer, trends_days integer, str_days integer)
  Texto de DEVOLUCIONES
  IDIOMA plpgsql
 AS $ funci√≥n $
 / *
 La funci√≥n elimina todas las particiones anteriores al n√∫mero de d√≠as especificado:
 history_days: para particiones history_x, history_uint_x
 trends_days - para particiones trends_x, trends_uint_x
 str_days: para particiones history_str_x, history_text_x, history_log_x
 * /
 declarar clock_today_start int;
 declarar clock_delete_less_history int = 0;
 declarar clock_delete_less_trends int = 0;
 declarar clock_delete_less_strings int = 0;
 clock_delete_less int = 0;
 declarar iterador int = 0;
 declare result_str text = '';
 declarar texto buf_table_size;
 declarar texto buf_table_len;
 declarar texto de nombre de partici√≥n;
 declarar texto clock_max;
 declarar err_detail text;
 declarar t_start timestamp = clock_timestamp ();
 declarar t_end marca de tiempo;
 comenzar
     si $ 1 &lt;= 0, entonces devuelve 'ups, algo mal: el argumento history_days debe ser un valor entero positivo';  terminar si;
     si $ 2 &lt;= 0, entonces devuelve 'ups, algo mal: el argumento trends_days debe ser un valor entero positivo';  terminar si;
     si $ 3 &lt;= 0, entonces devuelve 'ups, algo mal: el argumento str_days debe ser un valor entero positivo';  terminar si;
     clock_today_start = extract (epoch from date_trunc ('day', now ())) :: int;
     clock_delete_less_history = extract (√©poca de date_trunc ('d√≠a', ahora ()) - ($ 1 :: texto || 'd√≠as') :: intervalo) :: int;
     clock_delete_less_trends = extract (√©poca de date_trunc ('d√≠a', ahora ()) - ($ 2 :: texto || 'd√≠as') :: intervalo) :: int;
     clock_delete_less_strings = extract (√©poca de date_trunc ('d√≠a', ahora ()) - ($ 3 :: texto || 'd√≠as') :: intervalo) :: int;
     clock_delete_less = least (clock_delete_less_history, clock_delete_less_trends, clock_delete_less_strings);
     - aviso de subida 'clock_today_start% (%)', to_timestamp (clock_today_start), clock_today_start;
     --seguir aviso 'clock_delete_less_history% (%)% days', to_timestamp (clock_delete_less_history), clock_delete_less_history, $ 1;
     - aviso de subida 'clock_delete_less_trends% (%)% days', to_timestamp (clock_delete_less_trends), clock_delete_less_trends, $ 2;
     - elevar el aviso 'clock_delete_less_strings% (%)% days', to_timestamp (clock_delete_less_strings), clock_delete_less_strings, $ 3;
     para nombre_partici√≥n, clock_max en la partici√≥n seleccionada, range_max de pathman_partition_list donde 
     range_max :: int &lt;= greatest (clock_delete_less_history, clock_delete_less_trends, clock_delete_less_strings) y 
     (partici√≥n :: texto como 'historial%' o partici√≥n :: texto como 'tendencias%') ordenar por partici√≥n asc
     bucle
         if (nombre_partici√≥n ~ 'history_uint_ \ d' y clock_max :: int &lt;= clock_delete_less_history)
         o (nombre_partici√≥n ~ 'history_ \ d' y clock_max :: int &lt;= clock_delete_less_history)
         o (nombre_partici√≥n ~ 'trends_ \ d' y clock_max :: int &lt;= clock_delete_less_trends)
         o (nombre_partici√≥n ~ 'history_log_ \ d' y clock_max :: int &lt;= clock_delete_less_strings)
         o (nombre_de_partici√≥n ~ 'history_str_ \ d' y clock_max :: int &lt;= clock_delete_less_strings)
         o (nombre_partici√≥n ~ 'history_text_ \ d' y clock_max :: int &lt;= clock_delete_less_strings)
         entonces 
             iterador = iterador + 1;
             elevar el aviso '%', formato ('!!! eliminar% s% s', nombre_partici√≥n, reloj_max);
             seleccione max (reltuples :: int), pg_size_pretty (sum (pg_relation_size (pg_class.oid)))) como "tama√±o" de pg_class donde renombre como partici√≥n_nombre ||  '%' en estricto buf_table_len, buf_table_size;
             if result_str! = '' entonces result_str = result_str ||  ',';  terminar si;
             result_str = result_str ||  formato ('% s (dt &lt;% s, len% s,% s)', nombre_partici√≥n, to_char (to_timestamp (clock_max :: int), 'YYYY-MM-DD'), buf_table_len, buf_table_size);
             ejecutar formato ('eliminar tabla si existe% s', nombre_partici√≥n);
         terminar si;
     bucle final
     if iterator = 0 then result_str = format ('no hay particiones para eliminar anteriores, entonces% s date', to_char (to_timestamp (clock_delete_less), 'YYYY-MM-DD')); 
     de lo contrario result_str = format ('particiones% s eliminadas en% s segundos:', iterador, trunc (extract (segundos de (clock_timestamp () - t_start)) :: numeric, 3)) ||  result_str;
     terminar si;
     --avisar aviso '%', result_str;
     return result_str;
 excepci√≥n cuando otros entonces
    obtener diagn√≥sticos apilados err_detail = PG_EXCEPTION_CONTEXT;
    formato de retorno ('ups, algo mal:% s [c√≥digo de error% s],% s', sqlerrm, sqlstate, err_detail);
 fin 
 $ funci√≥n $;
</pre><br>  Para llamar autom√°ticamente a la funci√≥n de partici√≥n de limpieza autom√°tica, debe crear un elemento de datos para el host del servidor zabbix del tipo "Monitor de base de datos" con la siguiente configuraci√≥n: <br><br><pre> - tipo: monitor de base de datos
 - nombre: delete_old_history_partitions
 - clave: db.odbc.select [delete_old_history_partitions, zabbix]
 - expresi√≥n sql: seleccione delete_old_partitions (3, 30, 30);
 # aqu√≠, los par√°metros de la llamada a la funci√≥n delete_old_partitions indican el tiempo de almacenamiento en d√≠as 
 # para valores num√©ricos, valores num√©ricos agregados y valores de cadena
 - tipo de datos: texto
 - intervalo de actualizaci√≥n: 0
 - intervalo de usuario: programado en h2
 - per√≠odo de almacenamiento del historial: 90 d√≠as
 - grupo de elementos de datos: base de datos
</pre><br>  Como resultado, obtendremos estad√≠sticas sobre la limpieza de particiones de aproximadamente este tipo: <br><br><pre>  2019-09-16 02:00:00, borrado 3 particiones en 0.024 segundos: trends_78 (dt &lt;2019-08-17, len 1, 48 kB), history_193 (dt &lt;2019-09-13, len 85343, 9448 kB ), history_uint_186 (dt &lt;2019-09-13, len 27969, 3480 kB)
</pre><br>  <b>Importante!</b>  Despu√©s de configurar la eliminaci√≥n autom√°tica de particiones a trav√©s del elemento de datos y la funci√≥n del usuario, debe desactivar el historial y la limpieza de tendencias en el programador de tareas de ama de llaves Zabbix: a <i>trav√©s del elemento del men√∫ zabbix, seleccione "Administraci√≥n" -&gt; "General" -&gt; seleccione "Borrar historial" de la lista en la esquina -&gt; deshabilitar todas las casillas de verificaci√≥n en las secciones "Historial" y "Din√°mica de los cambios".</i> <br></div></div><br><h4>  Cambiar los tipos de √≠ndice de las tablas de historial a brin (clock) y btree-gin (itemid) </h4><br>  Un agradecimiento especial a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">erogov</a> por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente serie de art√≠culos de resumen sobre los √≠ndices PostgreSQL</a> .  <i>Y de hecho todo el equipo de PostgresPRO.</i>                            . <br><br>  ,            btree(itemid, clock) ‚Äî    ,     ,   ¬´¬ª  ,    ‚Äî  10 . <br><br> <i>          ,              ,       .</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante la prueba de varios √≠ndices, se revel√≥ la combinaci√≥n m√°s exitosa de √≠ndices: el √≠ndice brin en el campo del reloj y el √≠ndice btree-gin en el campo itemid para todas las tablas de datos de monitoreo. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √≠ndice brin es ideal para datos que aumentan monot√≥nicamente, como la marca de tiempo del hecho de un evento, es decir </font><font style="vertical-align: inherit;">para series de tiempo. </font><font style="vertical-align: inherit;">Y el √≠ndice btree-gin es esencialmente un √≠ndice gin sobre los tipos de datos est√°ndar, que generalmente es mucho m√°s r√°pido que el √≠ndice btree cl√°sico porque </font><font style="vertical-align: inherit;">El √≠ndice de ginebra no se reconstruye durante la adici√≥n de nuevos valores, sino que solo se complementa con ellos. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √≠ndice btree-gin se coloca como una extensi√≥n de PostgreSQL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n se ofrece una comparaci√≥n de la velocidad de muestreo para esta estrategia de indexaci√≥n y para los √≠ndices en la base de datos Zabbix de manera predeterminada. </font><font style="vertical-align: inherit;">Durante las pruebas de carga, acumulamos datos durante tres d√≠as para tres particiones:</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre de partici√≥n </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El n√∫mero de filas en el MLN </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tama√±o en MB </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 81,3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4119 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 74,9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4426 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5387 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para evaluar los resultados, se realizaron tres tipos de consultas: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para un par√°metro espec√≠fico itemid, datos del √∫ltimo mes, de hecho, los √∫ltimos tres d√≠as (total 1660 registros) </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar analizar select * from history_uint donde itemid = 313300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y reloj&gt; = extracto (√©poca de '2019-03-09 00:00:00' :: marca de tiempo) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y clock &lt;= extract (√©poca de '2019-04-09 12:00:00' :: marca de tiempo) :: int;</font></font><font></font>
</pre></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para datos de un par√°metro espec√≠fico durante 12 horas de un d√≠a (649 entradas en total) </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar analizar seleccionar * del historial_texto donde itemid = 310650</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y reloj&gt; = extracto (√©poca de '2019-04-09 00:00:00' :: marca de tiempo) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y clock &lt;= extract (√©poca de '2019-04-09 12:00:00' :: marca de tiempo) :: int;</font></font><font></font>
</pre></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para datos de un par√°metro espec√≠fico durante una hora (61 registros en total): </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar analizar seleccionar recuento (*) de history_text donde itemid = 336540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y reloj&gt; = extracto (√©poca de '2019-04-08 11:00:00' :: marca de tiempo) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y clock &lt;= extract (√©poca de '2019-04-08 12:00:00' :: marca de tiempo) :: int;</font></font><font></font>
</pre></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los resultados de la prueba se tabularon a continuaci√≥n: </font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo de √≠ndice </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tama√±o en MB * </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solicitud 1 ** en ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solicitar 2 ** en ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solicitud 3 ** en ms </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btree (reloj, itemid) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14741 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7154,3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2205.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1860,4 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brin (reloj), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btree-gin (itemid)</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.42 y 1329 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2958,2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1820,4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 102,1 </font></font></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* el tama√±o en MB se indica en total para tres particiones </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">** solicitud de tipo 1 - datos durante 3 d√≠as, solicitud de tipo 2 - datos durante 12 horas, solicitud de tipo 3 - datos durante una hora </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la tabla de comparaci√≥n se puede ver que para tablas de datos grandes con el n√∫mero de registros m√°s de 100 millones muestran claramente que cambiar el √≠ndice compuesto est√°ndar btree a dos √≠ndices brin y btree-gin tiene un efecto beneficioso para reducir el tama√±o de los √≠ndices y acelerar el tiempo de ejecuci√≥n de consultas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La eficiencia de la indexaci√≥n y la partici√≥n se muestra a continuaci√≥n en el ejemplo de una solicitud para agregar nuevos registros a las tablas history_uint y trends_uint (las adiciones ocurren en promedio 2000 valores por consulta).</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesa </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiempo promedio de solicitud de mejoras, ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiempo promedio de solicitud despu√©s de mejoras, ms </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tendencias_un </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2201.48 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.72 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tendencias_un </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1997.27 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 62,16 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumiendo los resultados de las pruebas de varias configuraciones de √≠ndices para las tablas de datos de monitoreo del sistema zabbix, podemos decir que un cambio similar en el √≠ndice est√°ndar para las tablas de datos de monitoreo zabbix afecta positivamente el rendimiento general del sistema, lo que se siente m√°s cuando se acumulan vol√∫menes de datos de m√°s de 10 millones. debe olvidarse del efecto indirecto de la "hinchaz√≥n" del √≠ndice btree est√°ndar de forma predeterminada: las reconstrucciones frecuentes del √≠ndice de varios gigabytes provocan una gran carga del disco duro (m√©trica de uso aci√≥n), que en √∫ltima instancia aumenta el tiempo de las operaciones del disco y el tiempo de espera para acceder al disco desde la CPU (m√©trica iowait). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que el √≠ndice btree-gin pueda funcionar con el tipo de datos bigint (in8), que es la columna itemid, debe registrar una familia de operadores bigint para el √≠ndice btree-gin. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registrar una familia de operadores bigint para el √≠ndice btree-gin</font></font></b> <div class="spoiler_text"><pre>/*<font></font>
     gin    biginteger  integer    .<font></font>
 -   gin     int2, int4, int8,<font></font>
       bigint     ,     bigint (&lt;= 2147483647)<font></font>
        intger_ops,  :<font></font>
create index on tablename using gin(columnname int8_family_ops) with (fastupdate = false);<font></font>
*/<font></font>
<font></font>
--       btree_gin<font></font>
CREATE EXTENSION btree_gin;<font></font>
<font></font>
CREATE OPERATOR FAMILY integer_ops using gin;<font></font>
<font></font>
CREATE OPERATOR CLASS int4_family_ops<font></font>
FOR TYPE int4 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint4cmp(int4,int4),<font></font>
    FUNCTION 2 gin_extract_value_int4(int4, internal),<font></font>
    FUNCTION 3 gin_extract_query_int4(int4, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int4(int4,int4,int2, internal),<font></font>
STORAGE int4;<font></font>
<font></font>
CREATE OPERATOR CLASS int8_family_ops<font></font>
FOR TYPE int8 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint8cmp(int8,int8),<font></font>
    FUNCTION 2 gin_extract_value_int8(int8, internal),<font></font>
    FUNCTION 3 gin_extract_query_int8(int8, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int8(int8,int8,int2, internal),<font></font>
STORAGE int8;<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int4,int8),<font></font>
  OPERATOR 2 &lt;=(int4,int8),<font></font>
  OPERATOR 3 =(int4,int8),<font></font>
  OPERATOR 4 &gt;=(int4,int8),<font></font>
  OPERATOR 5 &gt;(int4,int8);<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int8,int4),<font></font>
  OPERATOR 2 &lt;=(int8,int4),<font></font>
  OPERATOR 3 =(int8,int4),<font></font>
  OPERATOR 4 &gt;=(int8,int4),<font></font>
  OPERATOR 5 &gt;(int8,int4);<font></font>
</pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este script redistribuye todos los √≠ndices en la base de datos PostgreSQL para Zabbix desde la configuraci√≥n predeterminada a la configuraci√≥n √≥ptima descrita anteriormente.</font></font></b> <div class="spoiler_text"><pre>/*<font></font>
        <font></font>
*/<font></font>
<font></font>
--   <font></font>
drop index history_1;<font></font>
drop index history_uint_1;<font></font>
drop index history_str_1;<font></font>
drop index history_text_1;<font></font>
drop index history_log_1;<font></font>
--          PK <font></font>
-- (   ,         )<font></font>
alter table trends drop constraint trends_pk;<font></font>
alter table trends_uint drop constraint trends_uint_pk;<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--   btree-gin  bigint       <font></font>
-- https://habr.com/ru/company/postgrespro/blog/340978/#comment_10545932<font></font>
--    create extension btree_gin;<font></font>
create index on history using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_str using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_text using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_log using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--     brin    128 ,    <font></font>
--           ,<font></font>
--      https://habr.com/ru/company/postgrespro/blog/346460/<font></font>
create index on history using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_uint using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_str using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_text using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_log using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends_uint using brin(clock) with (pages_per_range = 128);<font></font>
</pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para el √≠ndice de brin para nuestro volumen de datos a una intensidad de 100 toneladas de par√°metros por minuto (100 toneladas en el historial y 100 toneladas en el historial), se not√≥ que el √≠ndice funciona en las tablas de datos de monitoreo primario con un tama√±o de zona de 512 p√°ginas dos veces m√°s r√°pido que con el tama√±o est√°ndar de 128 p√°ginas, pero esto es individual y depende del tama√±o de las tablas y la configuraci√≥n del servidor. En cualquier caso, el √≠ndice brin ocupa muy poco espacio, pero su velocidad puede aumentarse ligeramente ajustando el tama√±o de la zona, pero siempre que la velocidad de flujo de datos no cambie mucho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, vale la pena se√±alar que hay una limitaci√≥n asociada con la arquitectura de Zabbix: en la pesta√±a "Datos recientes", los √∫ltimos dos valores para cada par√°metro se recopilan teniendo en cuenta el filtrado. Para cada par√°metro, los valores se solicitan en la base de datos por separado. Por lo tanto, cuanto m√°s par√°metros se seleccionen, m√°s tiempo se ejecutar√° la consulta. Se buscan los datos m√°s recientes cuando el √≠ndice btree (itemid, clock desc) se establece en las tablas de historial con una ordenaci√≥n inversa por tiempo, pero el √≠ndice en s√≠ mismo "se hincha" en el disco y generalmente disminuye la base de datos indirectamente, lo que causa un problema, descrito anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, hay tres salidas:</font></font><br><br><ol><li>             ¬´ ¬ª      100  (..   ,     ¬´ ¬ª    ) </li><li>     Zabbix ,                  ,          ¬´ ¬ª </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deje los √≠ndices como est√°n por defecto y lim√≠tese a particionar solo para obtener selecciones bastante grandes en la pesta√±a Datos recientes al mismo tiempo para una variedad de par√°metros (sin embargo, se not√≥ que el servidor web Zabbix todav√≠a tiene un l√≠mite en la cantidad de valores de par√°metros mostrados simult√°neamente en la pesta√±a "Datos recientes", por lo tanto, cuando intento mostrar 5000 valores, la base de datos calcul√≥ el resultado, pero el servidor no pudo preparar la p√°gina web y mostrar una cantidad de datos tan grande). </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recopilaci√≥n y an√°lisis de estad√≠sticas de ejecuci√≥n de consultas pg_stat_statements </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pg_stat_statements es una extensi√≥n para recopilar estad√≠sticas sobre el rendimiento de las consultas en todo el servidor. </font><font style="vertical-align: inherit;">La ventaja de esta extensi√≥n es que no necesita recopilar y analizar registros de PostgreSQL.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de la extensi√≥n pg_stat_statements</font></font></b> <div class="spoiler_text">    psql: <br><br><pre> CREATE EXTENSION pg_stat_statements; </pre><br>       postgresql.conf: <br><br><pre>shared_preload_libraries = 'pg_stat_statements'<font></font>
pg_stat_statements.max = 10000 #   sql ,     (     );<font></font>
pg_stat_statements.track = all # all -   (    ), top -   /, none -  <font></font>
pg_stat_statements.save = true #     <font></font>
</pre><br>  : <br><br><pre> SELECT pg_stat_statements_reset(); </pre><br>          : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> query_sub, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(calls) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> calls, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(mean_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mean_time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'insert into'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'update trends'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> calls <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span></code> </pre> </div></div><br><h4>      </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para monitorear los discos duros en Zabbix, solo se proporcionan los par√°metros vfs.dev.read y vfs.dev.write listos para usar. Estas opciones no proporcionan informaci√≥n sobre la utilizaci√≥n del disco. Los criterios √∫tiles para encontrar problemas con el rendimiento de sus discos duros son el factor de utilizaci√≥n, el tiempo de espera y la carga de la cola de carga del disco. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como regla general, una alta carga de disco se correlaciona con un alto iowait de CPU en s√≠ y con un aumento en el tiempo de ejecuci√≥n de consultas sql, que se encontr√≥ durante la prueba de esfuerzo de un servidor zabbix con una configuraci√≥n est√°ndar sin particiones y sin configurar √≠ndices alternativos. Puede agregar estos par√°metros para monitorear los discos duros usando los siguientes pasos, que se vieron en un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de un amigo</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y mejorado: ahora los par√°metros de iostat se recopilan por separado para cada disco en el par√°metro de tiempo json, desde donde, de acuerdo con la configuraci√≥n de procesamiento posterior, ya se descomponen en los par√°metros de monitoreo final. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras la solicitud de extracci√≥n est√° pendiente, puede intentar expandir la supervisi√≥n de los par√°metros del disco de acuerdo con las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones detalladas a trav√©s de mi tenedor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de todos los pasos descritos, puede agregar un gr√°fico personalizado con CPU iowait y par√°metros de utilizaci√≥n para el disco del sistema y el disco de la base de datos (si son diferentes) al panel de monitoreo del servidor Zabbix principal. </font><font style="vertical-align: inherit;">El resultado puede verse as√≠ (sda es el disco principal, sdc es el disco con la base de datos):</font></font><br><br><img src="https://habrastorage.org/webt/oa/nj/fa/oanjfa3hajssftbq22dk8njiwj0.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mejora de rendimiento de hardware </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de configurar el DBMS, la indexaci√≥n y la partici√≥n, puede continuar con el escalado vertical para mejorar las caracter√≠sticas de hardware del servidor: agregue RAM, cambie las unidades a estado s√≥lido y agregue n√∫cleos de procesador. </font><font style="vertical-align: inherit;">Este es un aumento de rendimiento garantizado, pero es mejor hacerlo solo despu√©s de la optimizaci√≥n del software.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear un cl√∫ster distribuido </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de una escala vertical moderada, debe comenzar horizontalmente: crear un cl√∫ster distribuido: fragmente o replique el esclavo maestro. </font><font style="vertical-align: inherit;">Pero este es un tema separado y material de un art√≠culo separado </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(c√≥mo moldear un grupo de mierda y palos)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como una comparaci√≥n de la t√©cnica de optimizaci√≥n de la base de datos Zabbix descrita anteriormente usando pg_pathman e indexando con el m√©todo de aplicaci√≥n de la extensi√≥n TimescaleDB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras tanto, ¬°uno solo puede esperar que el material de este art√≠culo sea √∫til e informativo!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468463/">https://habr.com/ru/post/468463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468445/index.html">Firefox y Chrome cifrar√°n las consultas DNS y eludir√°n la censura</a></li>
<li><a href="../468453/index.html">MBLT19 :: informes, batalla de productos y prueba</a></li>
<li><a href="../468455/index.html">Gran GPS y su lado oscuro</a></li>
<li><a href="../468457/index.html">El generador de ejemplos aritm√©ticos simples para tontos y no solo</a></li>
<li><a href="../468459/index.html">Descripci√≥n general del detector de radar de firma: nuestro buque insignia Playme Silent 2</a></li>
<li><a href="../468465/index.html">Opini√≥n del abogado: c√≥mo pueden las empresas de TI rescindir un contrato con un cliente gubernamental t√≥xico</a></li>
<li><a href="../468471/index.html">Descripci√≥n general de AngularConnect 2019. Parte 1</a></li>
<li><a href="../468479/index.html">‚ÄúLa gente piensa que lo gratuito no vale nada. Me pareci√≥ que pod√≠a convencerlos "- Yuri Yartsev sobre la escuela Russol</a></li>
<li><a href="../468485/index.html">Cuando quieres una GUI hermosa, pero gpu no es</a></li>
<li><a href="../468487/index.html">Qu√© puede suceder (vectores de ataque t√≠picos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>