<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘Œ ğŸ›´ ğŸ‘©ğŸ¿â€ğŸ« Struktur Data dari Status Blockchain Cash Plasma ğŸ“£ ğŸ‘ˆğŸ¿ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, pengguna Habr sayang! Artikel ini adalah tentang Web 3.0 - Internet terdesentralisasi. Web 3.0 memperkenalkan konsep desentralisasi sebagai dasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struktur Data dari Status Blockchain Cash Plasma</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455988/"><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><br>  Halo, pengguna Habr sayang!  Artikel ini adalah tentang Web 3.0 - Internet terdesentralisasi.  Web 3.0 memperkenalkan konsep desentralisasi sebagai dasar Internet modern.  Banyak sistem dan jaringan komputer memerlukan fitur keamanan dan desentralisasi untuk memenuhi kebutuhan mereka.  Registri terdistribusi menggunakan teknologi blockchain memberikan solusi efisien untuk desentralisasi. <br><a name="habracut"></a><br>  Blockchain adalah registri terdistribusi.  Anda dapat menganggapnya sebagai basis data besar yang hidup selamanya, tidak pernah berubah sepanjang waktu.  Blockchain menyediakan dasar untuk aplikasi dan layanan web terdesentralisasi. <br><br>  Namun, blockchain lebih dari sekadar basis data.  Ini berfungsi untuk meningkatkan keamanan dan kepercayaan di antara anggota jaringan, meningkatkan transaksi bisnis online. <br><br>  Konsensus Bizantium meningkatkan keandalan jaringan dan memecahkan masalah konsistensi. <br><br>  Skalabilitas yang diberikan oleh DLT mengubah jaringan bisnis yang ada. <br><br>  Blockchain menawarkan manfaat baru yang sangat penting: <br><br><ol><li>  Mencegah kesalahan mahal. </li><li>  Memastikan transaksi transparan. </li><li>  Mendigitalkan barang nyata. </li><li>  Menegakkan kontrak yang cerdas. </li><li>  Meningkatkan kecepatan dan keamanan pembayaran. </li></ol><br>  Kami telah mengembangkan PoE khusus untuk meneliti protokol kriptografi dan meningkatkan solusi DLT dan blockchain yang ada. <br><br>  Sebagian besar sistem registri publik tidak memiliki sifat skalabilitas, membuat throughputnya agak rendah.  Misalnya, proses Ethereum hanya ~ 20 tx / s. <br><br>  Banyak solusi dikembangkan untuk meningkatkan skalabilitas sambil mempertahankan desentralisasi.  Namun, hanya 2 dari 3 keuntungan - skalabilitas, keamanan, dan desentralisasi - dapat dicapai secara bersamaan. <br><br>  Penggunaan sidechains menyediakan salah satu solusi paling efektif. <br><br><h2>  Konsep plasma </h2><br>  Konsep Plasma bermuara pada gagasan bahwa rantai akar memproses sejumlah kecil komitmen dari rantai anak, dengan demikian bertindak sebagai lapisan paling aman dan terakhir untuk menyimpan semua kondisi perantara.  Setiap rantai anak berfungsi sebagai blockchainnya sendiri dengan algoritma konsensusnya sendiri, tetapi ada beberapa peringatan penting. <br><br><ul><li>  Kontrak pintar dibuat dalam rantai root dan bertindak sebagai pos pemeriksaan untuk rantai anak dalam rantai root. </li><li>  Rantai anak dibuat dan berfungsi sebagai blockchainnya sendiri dengan konsensusnya sendiri.  Semua negara bagian dalam rantai anak dilindungi oleh bukti penipuan yang memastikan semua transisi antar negara berlaku dan menerapkan protokol penarikan. </li><li>  Kontrak pintar khusus untuk DApp atau logika aplikasi rantai anak dapat digunakan dalam rantai anak. </li><li>  Dana dapat ditransfer dari rantai akar ke rantai anak. </li></ul><br>  Validator diberikan insentif ekonomi untuk bertindak jujur â€‹â€‹dan mengirim komitmen ke rantai akar - lapisan penyelesaian transaksi akhir. <br><br>  Akibatnya, pengguna DApp yang bekerja di rantai anak tidak harus berinteraksi dengan rantai root sama sekali.  Selain itu, mereka dapat menempatkan uang mereka di rantai root kapan pun mereka mau, bahkan jika rantai anak diretas.  Ini keluar dari rantai anak memungkinkan pengguna untuk menyimpan dana mereka dengan aman dengan bukti Merkle, mengkonfirmasi kepemilikan sejumlah dana tertentu. <br><br>  Keuntungan utama plasma terkait dengan kemampuannya untuk secara signifikan memfasilitasi perhitungan yang membebani rantai utama.  Selain itu, blockchain Ethereum dapat menangani set data yang lebih luas dan paralel.  Waktu yang dihapus dari rantai root juga ditransfer ke node Ethereum, yang memiliki persyaratan pemrosesan dan penyimpanan yang lebih rendah. <br><br>  <b>Plasma Cash</b> memberikan nomor seri unik untuk token online.  Keuntungan dari skema ini termasuk tidak perlu konfirmasi, dukungan yang lebih sederhana untuk semua jenis token (termasuk token yang tidak dapat dipertukarkan), dan mitigasi terhadap keluar massa dari rantai anak. <br><br>  Konsep "keluar massal" dari rantai anak adalah masalah yang dihadapi oleh Plasma.  Dalam skenario ini, penarikan secara simultan terkoordinasi dari rantai anak berpotensi menyebabkan daya komputasi tidak memadai untuk menarik semua dana.  Akibatnya, pengguna dapat kehilangan dana. <br><br><h2>  Opsi untuk menerapkan Plasma </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Basic Plasma memiliki banyak opsi implementasi. <br><br>  Perbedaan utama mengacu pada: <br><br><ul><li>  pengarsipan informasi tentang penyimpanan negara dan metode presentasi; </li><li>  jenis token (habis dibagi, tidak dapat dibagi); </li><li>  keamanan transaksi; </li><li>  jenis algoritma konsensus. </li></ul><br>  Variasi utama Plasma meliputi: <br><br><ul><li>  Plasma berbasis UTXO - setiap transaksi terdiri dari input dan output.  Suatu transaksi dapat dilakukan dan dibelanjakan.  Daftar transaksi yang tidak digunakan adalah status rantai anak itu sendiri. </li><li>  Plasma Berbasis Akun - struktur ini berisi refleksi dan saldo masing-masing akun.  Ini digunakan dalam Ethereum, karena setiap akun dapat terdiri dari dua jenis: akun pengguna dan akun kontrak pintar.  Kesederhanaan adalah keuntungan penting dari Plasma berbasis akun.  Pada saat yang sama, kurangnya skalabilitas merupakan kerugian.  Properti khusus, "nonce," digunakan untuk mencegah eksekusi transaksi dua kali. </li></ul><br>  Untuk memahami struktur data yang digunakan dalam rantai kas Plasma Cash dan bagaimana komitmen bekerja, perlu untuk mengklarifikasi konsep Merkle Tree. <br><br><h2>  Merkle Trees dan penggunaannya dalam Plasma </h2><br>  Merkle Tree adalah struktur data yang sangat penting di dunia blockchain.  Ini memungkinkan kita untuk menangkap kumpulan data tertentu dan menyembunyikan data, namun membuktikan bahwa beberapa informasi ada di dalam kumpulan.  Misalnya, jika kita memiliki sepuluh angka, kita dapat membuat bukti untuk angka-angka ini dan kemudian membuktikan bahwa beberapa angka tertentu ada di set ini.  Bukti ini akan memiliki ukuran konstan kecil, yang membuatnya tidak mahal untuk dipublikasikan di Ethereum. <br><br>  Anda dapat menggunakan prinsip ini untuk satu set transaksi, dan membuktikan bahwa transaksi tertentu ada di set ini.  Inilah yang dilakukan oleh operator.  Setiap blok terdiri dari set transaksi yang berubah menjadi Merkle Tree.  Akar pohon ini adalah bukti yang diterbitkan dalam Ethereum bersama dengan setiap blok Plasma. <br><br>  Pengguna harus dapat menarik dana mereka dari rantai Plasma.  Untuk ini, mereka mengirim transaksi "keluar" ke Ethereum. <br><br>  Plasma Cash menggunakan Pohon Merkle khusus yang menghilangkan kebutuhan untuk memvalidasi seluruh blok.  Cukup untuk memvalidasi hanya cabang-cabang yang sesuai dengan token pengguna. <br><br>  Untuk mentransfer token, perlu untuk menganalisis riwayatnya dan memindai hanya token yang dibutuhkan pengguna tertentu.  Saat mentransfer token, pengguna cukup mengirimkan seluruh riwayat ke pengguna lain, yang kemudian dapat mengotentikasi seluruh riwayat dan, yang paling penting, melakukannya dengan sangat cepat. <br><br><img src="https://habrastorage.org/webt/l7/tg/iw/l7tgiwwibxyks4m-tv6lmw3cs_a.png"><br><br><h2>  Struktur data Plasma Cash untuk penyimpanan status dan riwayat </h2><br>  Dianjurkan untuk hanya menggunakan Merkle Trees yang dipilih, karena itu perlu untuk mendapatkan bukti inklusi dan non-inklusi untuk transaksi dalam satu blok.  Sebagai contoh: <br><br><ul><li>  Pohon merkle jarang </li><li>  Pohon patricia </li></ul><br>  Kami telah mengembangkan implementasi Sparse Merkle Tree dan Patricia Tree kami sendiri untuk klien kami. <br><br>  Pohon Merkle Jarang mirip dengan Pohon Merkle standar, kecuali bahwa datanya diindeks, dan setiap titik data ditempatkan pada daun yang sesuai dengan indeks titik data ini. <br><br>  Misalkan kita memiliki Pohon Merkle empat daun.  Mari kita isi pohon ini dengan huruf A dan D, untuk demonstrasi.  Huruf A adalah huruf alfabet pertama, jadi kita akan meletakkannya di daun pertama.  Demikian pula, kita akan menempatkan D pada daun keempat. <br><br>  Jadi apa yang terjadi pada daun kedua dan ketiga?  Mereka harus dibiarkan kosong.  Lebih tepatnya, nilai khusus (misalnya, nol) digunakan sebagai pengganti surat. <br><br>  Pohon itu akhirnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  Bukti inklusi bekerja dengan cara yang sama seperti pada Pohon Merkle biasa.  Apa yang terjadi jika kita ingin membuktikan bahwa C bukan bagian dari Merkle Tree ini?  SD!  Kita tahu bahwa jika C adalah bagian dari pohon, itu akan berada di daun ketiga.  Jika C bukan bagian dari pohon, maka daun ketiga harus nol. <br><br>  Semua yang diperlukan adalah bukti inklusi Merkle standar yang menunjukkan bahwa daun ketiga adalah nol. <br><br>  Fitur terbaik dari Sparse Merkle Tree adalah ia menyediakan repositori untuk nilai-nilai kunci di dalam Merkle Tree! <br><br>  Bagian dari kode protokol PoE membangun Sparse Merkle Tree: <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  Kode ini cukup sepele.  Kami memiliki repositori kunci-nilai dengan bukti inklusi / non-inklusi. <br><br>  Di setiap iterasi, level spesifik dari pohon final diisi, dimulai dengan yang terakhir.  Bergantung pada apakah kunci daun saat ini genap atau ganjil, kami mengambil dua daun yang berdekatan dan menghitung hash tingkat saat ini.  Jika kita mencapai akhir, kita akan menuliskan satu merkleRoot - hash umum. <br><br>  Anda harus memahami bahwa pohon ini diisi dengan nilai yang awalnya kosong.  Jika kami menyimpan sejumlah besar token ID, kami akan memiliki ukuran pohon yang besar, dan itu akan lama! <br><br>  Ada banyak solusi untuk non-optimasi ini, tetapi kami telah memutuskan untuk mengubah pohon ini menjadi Pohon Patricia. <br><br>  Patricia Tree adalah kombinasi Radix Tree dan Merkle Tree. <br><br>  Kunci data Radix Tree menyimpan jalur ke data itu sendiri, yang memungkinkan kami untuk membuat struktur data yang dioptimalkan untuk memori. <br><br><img src="https://habrastorage.org/webt/ox/cz/gc/oxczgcwvxvl2jas44sbtbqophda.png"><br><br>  Berikut adalah implementasi yang dikembangkan untuk klien kami: <br><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre> <br>  Kami bergerak secara rekursif dan membangun sub pohon yang terpisah kiri dan kanan.  Kunci dibangun sebagai jalur di pohon ini. <br><br>  Solusi ini bahkan lebih sepele.  Ini dioptimalkan dengan baik dan bekerja lebih cepat.  Bahkan, Pohon Patricia dapat lebih dioptimalkan dengan memperkenalkan tipe simpul baru - simpul ekstensi, simpul cabang, dan sebagainya, seperti yang dilakukan dalam protokol Ethereum.  Tetapi implementasi saat ini memenuhi semua persyaratan kami - kami memiliki struktur data yang cepat dan dioptimalkan memori. <br><br>  Dengan menerapkan struktur data ini dalam proyek klien kami, kami telah memungkinkan penskalaan Plasma Cash.  Ini memungkinkan kami untuk memeriksa riwayat token dan inklusi / non-inklusi token di pohon, sangat mempercepat validasi blok dan Rantai Anak Plasma itu sendiri. <br><br><h3>  Tautan: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plasma kertas putih</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Git hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gunakan case dan deskripsi arsitektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kertas jaringan petir</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455988/">https://habr.com/ru/post/id455988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455978/index.html">Lambdas: dari C ++ 11 ke C ++ 20. Bagian 2</a></li>
<li><a href="../id455980/index.html">iOS Digest No. 7 (31 Mei - 13 Juni)</a></li>
<li><a href="../id455982/index.html">Sudah waktunya untuk mengganti GIF dengan video AV1</a></li>
<li><a href="../id455984/index.html">Cara memahami bahwa tautan berfungsi: metrik dan pembuatan tautan KPI</a></li>
<li><a href="../id455986/index.html">Mengapa teknisi TI harus mengambil otak?</a></li>
<li><a href="../id455990/index.html">CTT dalam solusi server - seperti apa bentuknya?</a></li>
<li><a href="../id455994/index.html">Evolusi alat paling populer dari pengembang mana pun (di Visual Studio)</a></li>
<li><a href="../id455996/index.html">Transformasi digital periklanan di jaringan ritel. Mengikuti jejak Video Analytics di Retail</a></li>
<li><a href="../id456000/index.html">Membuat game Tic-Tac-Toe dengan TypeScript, React, dan Mocha</a></li>
<li><a href="../id456004/index.html">Kami mengundang Anda ke pertemuan pengembangan front-end di layanan yang sarat muatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>