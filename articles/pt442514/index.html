<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📟 👩🏼‍🤝‍👨🏽 🙅🏽 Sistemas distribuídos. Padrões de design. Resenha 🦃 😙 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá colegas. Hoje publicamos uma tradução da próxima resenha no site de Ben Neidel - este site certamente lhe interessará no original. Desta vez, fala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas distribuídos. Padrões de design. Resenha</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/442514/"> Olá colegas.  Hoje publicamos uma tradução da próxima resenha no site de Ben Neidel - este site certamente lhe interessará no original.  Desta vez, falaremos sobre o livro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Distributed Systems. Design Patterns</a> ", que complementa o livro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Master Kubernetes</a> ", publicado no início deste ano e, em essência, é um análogo do GoF para o design de sistemas distribuídos. <br><br><img src="https://habrastorage.org/webt/kv/we/4c/kvwe4cf94jbziiik3j87ywbjgyi.png"><br><br>  Boa leitura. <br><a name="habracut"></a><br>  No fim de semana, li o livro Sistemas Distribuídos.  Design Patterns, de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brendan Burns</a> .  Gostei muito do livro, embora, devo admitir, esperava encontrar um pouco de material diferente nele.  Assim, na descrição do livro, os contêineres são mencionados apenas de passagem.  Ao mesmo tempo, embora os padrões descritos no livro sejam aplicáveis ​​não apenas à conteinerização, quase todos os padrões descritos aqui são fornecidos no contexto do contêiner e, depois disso, são considerados no pipeline de implantação do Kubernetes.  Descobriu-se pelo caminho.  Estou começando a me familiarizar com o desenvolvimento e a implantação orientados a contêineres, e discutir padrões arquiteturais desse ponto de vista do "contêiner" foi uma revelação para mim.  Essa abordagem me ajudou a entender como, no cenário dos microsserviços, os pequenos serviços são distinguidos corretamente, cada um dos quais com uma oportunidade específica. <br><br>  O autor do livro, Brendan Burns, é o co-fundador do projeto de código aberto Kubernetes.  Portanto, não é de surpreender que todos os seus exemplos de aplicativos sejam criados em torno da implantação de contêineres com base nos arquivos de configuração do Kubernetes.  Na hora de ler o livro, eu era um pouco versado em Docker e não sabia nada sobre Kubernetes.  Assim, tentei descobrir o "objetivo" dos arquivos de configuração do Kubernetes simplesmente lendo-os.  No entanto, acredito que o livro será mais útil se o leitor tiver pelo menos alguma experiência com o Kubernetes. <br><br>  Ao ler o livro, não consegui me livrar das associações com o trabalho “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelos de Integração para Aplicativos Corporativos</a> ”, de Gregor Hope e Bobby Wolf.  Muitos dos padrões discutidos por Burns são muito semelhantes aos padrões da fila de mensagens discutidos por Hope e Wolfe.  De fato, devo dizer que muitos padrões são mencionados nos dois livros da mesma maneira (por exemplo, Scatter / Gather).  Isso é lógico, uma vez que o tema de ambos os livros é a partição de sistemas monolíticos complexos em um conjunto de pequenos serviços reutilizáveis ​​e bem ajustados.  Acho que pode até argumentar-se que Burns descreve abordagens específicas que serão úteis na implementação de Fabricantes de Serviços e Consumidores de Serviços que participam do funcionamento de fluxos de trabalho baseados em mensagens, os mesmos descritos no livro "Modelos de Integração de Aplicativos Corporativos". <br><br>  Mais uma vez, acredito que os paralelos traçados entre esses dois livros testemunham o poder dos padrões de design.  Tanto quanto eles nos levam a soluções comprovadas, e no fato de que os padrões de design facilitam a comunicação técnica, pois nos permitem raciocinar em um idioma comum. <br><br>  Ao mesmo tempo, uma das abordagens que mais gostei é descrita no livro “Sistemas Distribuídos.  Padrões de design ”está precisamente relacionado ao consumo da fila de mensagens.  Burns aconselha não forçar o contêiner de trabalho a receber mensagens diretamente do sistema (semelhante à maneira como isso é feito no sistema Simple Queue Service (SQS) da Amazon), mas a criar um "embaixador" (padrão Ambassador).  Esse contêiner de "embaixador" será implantado junto com o contêiner de trabalho e fornecerá uma API generalizada para manipulação de filas.  O contêiner Ambassador permite abstrair detalhes da implementação relacionados ao armazenamento permanente de elementos na fila de mensagens, para que o contêiner de trabalho seja completamente independente de qualquer solução tecnológica específica. <br><br>  “O embaixador da fonte do contêiner da fila de trabalho” é apenas um exemplo de um tópico transversal que percorre o livro como um fio vermelho: use conjuntos de pequenos contêineres para que cada contêiner individual possa se concentrar o máximo possível em uma tarefa específica e se tornar o mais reutilizável possível.  Burns explora esse conceito no nível de contêiner individual, falando sobre como parametrizar contêineres usando argumentos de linha de comando e variáveis ​​de ambiente.  Então ele sobe um nível, fala sobre os padrões de carros laterais e embaixadores de contêineres múltiplos em um contexto de nó único.  Por fim, ele mostra como criar uma arquitetura de microsserviço poderosa usando padrões de vários contêineres. <br><br>  Eu acho que Burns conseguiu articular perfeitamente o "sonho" de todo o cenário dos microsserviços: <br><br><blockquote>  A abordagem de microsserviço tem muitas vantagens, muitas das quais relacionadas à confiabilidade e flexibilidade.  Os microsserviços dividem o aplicativo em pequenas partes, cada uma das quais é responsável pela prestação de um serviço específico.  Ao restringir o escopo dos serviços, cada serviço é capaz de desenvolver e manter uma equipe que pode ser alimentada com duas pizzas. <br><br>  Reduzir o tamanho da equipe também reduz o custo de manutenção de suas atividades. <br><br>  Além disso, o surgimento de uma interface formal entre microsserviços enfraquece a interdependência das equipes e estabelece um contrato confiável entre os serviços.  Esse contrato formal reduz a necessidade de uma sincronização rígida da equipe, porque a equipe que fornece a API entende até que ponto é necessário garantir a compatibilidade e a equipe que consome a API pode contar com um serviço estável sem se preocupar com os detalhes da implementação do serviço consumido.  Essa decomposição permite que as equipes controlem independentemente o ritmo do desenvolvimento e o cronograma para o lançamento de novas versões, o que lhes dá a oportunidade de iterar, melhorando assim o código de serviço. <br><br>  Por fim, dividir em microsserviços aumenta a escalabilidade.  Como cada componente é alocado para um serviço separado, ele pode ser escalado independentemente dos outros </blockquote><br>  (p. 79-80 em tradução russa) <br><br>  Estou falando do "sonho" porque, como o próprio Burns admite, é difícil projetar um sistema de microsserviço e sua arquitetura.  E monitorar e depurar esse sistema é muito mais complicado do que monitorar e depurar um análogo monolítico.  Só com isso eu posso concordar facilmente.  De acordo com minha experiência limitada em trabalhar com microsserviços, confirmo que os serviços compartilhados rapidamente se tornam altamente conectados e os "contratos confiáveis" entre os serviços rapidamente se tornam um alvo em movimento, passando por mais e mais novas mudanças. <br><br>  Concluindo, gostaria de abordar o conceito do FaaS - "funciona como serviços".  Sistemas como o Serviço Lambda da Amazon me fazem sentir confuso.  Em um sentido extremamente abstrato, gosto de tais sistemas, mas não tenho idéia de como eles se manifestam em uma aplicação específica.  Burns toca no FaaS na Parte II, em "Padrões de design de sistemas de serviço", mas infelizmente não esclarece completamente o problema do Faas para mim. <br><br>  Gostei muito do fato de o Burns recomendar o uso do FaaS para resolver apenas um subconjunto dos problemas conhecidos: <br><br><blockquote>  Como em outras ferramentas para o desenvolvimento de sistemas distribuídos, convém usar uma solução específica (por exemplo, processamento orientado a eventos) como uma ferramenta universal.  A verdade é que uma solução específica geralmente resolve problemas específicos.  Em um determinado contexto, ele provará ser uma ferramenta poderosa, mas puxá-lo pelos ouvidos para resolver problemas comuns cria arquiteturas complexas e frágeis. </blockquote><br>  (p. 135 em tradução russa) <br><br>  Além disso, muito obrigado a ele por mencionar as dificuldades que surgem ao usar o FaaS: <br><br><blockquote>  Conforme mencionado na seção anterior, o desenvolvimento do sistema usando a abordagem FaaS obriga você a tornar os componentes do sistema fracamente acoplados.  Cada função é independente por definição.  Toda a interação é realizada através da rede.  As instâncias de função não possuem memória própria e, portanto, requerem armazenamento compartilhado para armazenar o estado.  O enfraquecimento forçado da conectividade dos elementos do sistema pode aumentar a flexibilidade e a velocidade do desenvolvimento de serviços, mas ao mesmo tempo pode complicar significativamente seu suporte. <br>  Em particular, é bastante difícil ver a estrutura abrangente do serviço, determinar como as funções são integradas entre si, entender o que e por que deu errado no caso de uma falha.  Além disso, a natureza das funções orientadas a consulta e sem servidor significa que alguns problemas serão difíceis de detectar. </blockquote><br>  (p. 136-137 em tradução para o russo) <br><br>  Mais uma vez, fiquei surpreso com o fato de a maioria dos sistemas FaaS não ser boa demais para resolver tarefas que exigem processamento ativo: <br><br><blockquote>  ... além disso, devido à implementação de serviços sem servidor, o tempo de execução de uma instância de função geralmente é limitado.  Isso significa que a abordagem FaaS geralmente não é adequada para aplicativos que exigem um longo processamento de dados em segundo plano.  (P. 138 em tradução russa) <br>  Por fim, fiquei satisfeito com a observação de que o FaaS está se tornando economicamente inconveniente se for impossível garantir uma operação ininterrupta e prolongada do processador: <br>  Mas se você tiver tantas solicitações que a função esteja constantemente ativa, é provável que pague demais pelo número de solicitações processadas. <br><br>  ... à medida que o serviço cresce, o número de solicitações processadas aumenta a um nível tal que o processador está constantemente ocupado processando-as.  Nesse ponto, a taxa pelo número de solicitações começa a se tornar inútil.  O custo por unidade de tempo de CPU das máquinas virtuais em nuvem diminui à medida que os núcleos são adicionados, além de reservar recursos e descontos para uso a longo prazo.  O custo do pagamento pelo número de solicitações geralmente aumenta com o número de solicitações. </blockquote><br>  (p. 139-140 em tradução russa) <br><br>  Como resultado, ainda não entendi: quando é melhor usar "funções como serviços"?  Observo que Burns descreve brevemente o trabalho com tarefas de curto prazo orientadas a eventos que não carregam muito o processador, como autenticação de dois fatores (2FA).  No entanto, considerando que estamos falando de pequenas tarefas de curto prazo e com baixos custos, surge a pergunta: por que elas deveriam ser escaladas de forma independente?  Por que não incluir esses recursos em outro serviço de contêiner estreitamente relacionado ao primeiro? <br><br>  Espero lidar melhor com esses problemas quando usar as tecnologias FaaS na prática. <br><br>  Além de alguma confusão com o FaaS, gostei muito do livro.  É lido rapidamente, facilmente percebido.  Mais uma vez, ele nos lembra o enorme potencial de enfraquecer a conexão entre componentes em todos os níveis de desenvolvimento de aplicativos.  Finalmente, agora será muito mais fácil manter uma conversa com meus colegas sobre tópicos como "contêineres laterais". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442514/">https://habr.com/ru/post/pt442514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442502/index.html">Transformamos o local de trabalho em um reclinável por US $ 200</a></li>
<li><a href="../pt442504/index.html">Proxy PHP Xdebug: quando os recursos padrão do Xdebug não são suficientes</a></li>
<li><a href="../pt442506/index.html">A Rússia é punida pelo comércio ilegal de dados pessoais?</a></li>
<li><a href="../pt442508/index.html">Como o udalenka acelera a inovação no GitLab</a></li>
<li><a href="../pt442512/index.html">Customização do Django ORM no exemplo do ZomboDB</a></li>
<li><a href="../pt442516/index.html">Guia do Pandas para análise de big data</a></li>
<li><a href="../pt442518/index.html">As 10 melhores técnicas de hackers na Web em 2018</a></li>
<li><a href="../pt442520/index.html">Case. Economizando 300 000 p. por mês em publicidade contextual</a></li>
<li><a href="../pt442522/index.html">RL Intuitivo (Aprendizagem por Reforço): Introdução ao Critério de Atores de Vantagem (A2C)</a></li>
<li><a href="../pt442524/index.html">Como aumentar a segurança nos sistemas de identificação pessoal e controle de acesso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>