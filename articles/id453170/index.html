<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 ✔️ 🐭 Brainstorm: cara melihat tugas dari sudut yang berbeda ⛓️ 🕘 🙂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Brainstorming dengan transposisi 
 Terkadang saya macet dan harus mencari cara untuk memikirkan tugas dari sudut yang berbeda. Ada tugas yang bisa dit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Brainstorm: cara melihat tugas dari sudut yang berbeda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453170/"><h2>  Brainstorming dengan transposisi </h2><br>  Terkadang saya macet dan harus mencari cara untuk memikirkan tugas dari sudut yang berbeda.  Ada tugas yang bisa ditampilkan dalam bentuk matriks atau tabel.  Struktur mereka terlihat seperti ini: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  A </th><th>  B </th><th>  C </th><th>  D </th><th>  E </th></tr></thead><tbody><tr><th>  1 </th><td>  A1 </td><td>  B1 </td><td>  C1 </td><td>  D1 </td><td>  E1 </td></tr><tr><th>  2 </th><td>  A2 </td><td>  B2 </td><td>  C2 </td><td>  D2 </td><td>  E2 </td></tr><tr><th>  3 </th><td>  A3 </td><td>  B3 </td><td>  C3 </td><td>  D3 </td><td>  E3 </td></tr><tr><th>  4 </th><td>  A4 </td><td>  B4 </td><td>  C4 </td><td>  D4 </td><td>  E4 </td></tr><tr><th>  5 </th><td>  A5 </td><td>  B5 </td><td>  C5 </td><td>  D5 </td><td>  E5 </td></tr></tbody></table></div><br>  Sel yang saya kerjakan disusun dalam kolom dan baris.  Mari kita ambil contoh dari gim sederhana: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Serang </th><th>  Pertahankan </th><th>  Spesial </th></tr></thead><tbody><tr><th>  Petarung </th><td>  pedang </td><td>  baju besi </td><td>  banting </td></tr><tr><th>  Mage </th><td>  bola api </td><td>  mencerminkan </td><td>  membeku </td></tr><tr><th>  Pencuri </th><td>  belati </td><td>  menghindar </td><td>  melucuti senjata </td></tr></tbody></table></div><br>  <em>Garis</em> adalah kelas karakter: prajurit, penyihir, pencuri. <br><br>  <em>Kolom</em> adalah jenis tindakan: serangan, pertahanan, tindakan khusus. <br><br>  <em>Matriks</em> berisi semua kode untuk memproses setiap jenis tindakan untuk setiap jenis karakter. <br><br>  Seperti apa kode itu?  Biasanya, struktur seperti itu disusun dalam modul-modul tersebut: <br><br><ol><li> <code>Fighter</code> akan berisi kode untuk menangani serangan pedang, mengurangi kerusakan dengan baju besi dan pukulan kuat khusus. </li><li>  <code>Mage</code> akan berisi kode penanganan bola api, refleksi kerusakan dan serangan pembekuan khusus. </li><li>  <code>Thief</code> akan berisi kode untuk menangani serangan belati, menghindari kerusakan menghindar, dan serangan melucuti senjata khusus. </li></ol><br>  Terkadang berguna untuk mengubah posisi matriks.  Kita bisa mengaturnya di sumbu lain <a name="habracut"></a>  : <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Petarung </th><th>  Mage </th><th>  Pencuri </th></tr></thead><tbody><tr><th>  Serang </th><td>  pedang </td><td>  bola api </td><td>  belati </td></tr><tr><th>  Pertahankan </th><td>  baju besi </td><td>  mencerminkan </td><td>  menghindar </td></tr><tr><th>  Spesial </th><td>  banting </td><td>  membeku </td><td>  melucuti senjata </td></tr></tbody></table></div><br><ol><li>  <code>Attack</code> akan berisi kode untuk menangani serangan ayunan, bola api, dan belati. </li><li>  <code>Defend</code> akan berisi kode untuk menangani pengurangan kerusakan, mencerminkan kerusakan dan menghindari kerusakan. </li><li>  <code>Special</code> akan berisi serangan yang kuat, membekukan dan melucuti kode penanganan. </li></ol><br>  Saya diajari bahwa satu gaya "baik" dan yang lain "buruk".  Tetapi tidak jelas bagi saya mengapa semuanya harus seperti itu.  Alasannya adalah <em>asumsi</em> bahwa kita akan sering menambahkan kelas karakter baru (kata benda), dan jarang menambahkan jenis tindakan baru (kata kerja).  Dengan cara ini saya dapat menambahkan kode menggunakan modul baru tanpa menyentuh <em>semua yang</em> tersedia.  Dalam gim Anda, semuanya bisa berbeda.  Melihat matriks transposisi, saya sadar akan adanya asumsi dan dapat meragukannya.  Kemudian saya akan memikirkan jenis fleksibilitas yang saya butuhkan, dan hanya kemudian saya akan memilih struktur kode. <br><br>  Mari kita lihat contoh lain. <br><br>  Interpretasi bahasa pemrograman memiliki berbagai jenis node yang sesuai dengan primitif: konstanta, operator, loop, percabangan, fungsi, jenis, dll.  Kita perlu menghasilkan kode untuk semuanya. <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Buat kode </th></tr></thead><tbody><tr><th>  Konstan </th><td></td></tr><tr><th>  Operator </th><td></td></tr><tr><th>  Loop </th><td></td></tr><tr><th>  Cabang </th><td></td></tr><tr><th>  Fungsi </th><td></td></tr><tr><th>  Jenis </th><td></td></tr></tbody></table></div><br>  Hebat!  Anda bisa membuat satu kelas untuk setiap jenis node, dan mereka semua bisa mewarisi dari kelas dasar <code>Node</code> .  Tetapi kami mengandalkan asumsi bahwa kami akan menambahkan baris dan kolom yang lebih jarang.  Apa yang terjadi dalam kompilator pengoptimalan?  Kami menambahkan pass optimasi baru.  Dan masing-masing dari mereka adalah kolom baru. <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Buat kode </th><th>  Aliran data </th><th>  Lipat konstan </th><th>  Loop fusion </th><th>  ... </th></tr></thead><tbody><tr><th>  Konstan </th><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Operator </th><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Loop </th><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Cabang </th><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Fungsi </th><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Jenis </th><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br>  Jika saya ingin menambahkan pass optimisasi baru, maka saya perlu menambahkan metode baru untuk setiap kelas, dan semua kode pass optimisasi akan didistribusikan ke modul yang berbeda.  Saya ingin menghindari situasi seperti itu!  Oleh karena itu, dalam beberapa sistem, lapisan lain ditambahkan di atas ini.  Menggunakan pola pengunjung, saya dapat menyimpan semua kode untuk menggabungkan loop dalam satu modul, daripada memecahnya menjadi beberapa file. <br><br>  Jika Anda melihat matriks transposisi, kami akan membuka pendekatan lain: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Konstan </th><th>  Operator </th><th>  Loop </th><th>  Cabang </th><th>  Fungsi </th><th>  Jenis </th></tr></thead><tbody><tr><th>  Buat kode </th><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Aliran data </th><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Lipat konstan </th><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  SSA </th><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>  Loop fusion </th><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br>  Sekarang, alih-alih <em>kelas</em> dengan <em>metode,</em> saya dapat menggunakan <em>gabungan tag</em> dan <em>pencocokan pola</em> (mereka tidak didukung dalam semua bahasa pemrograman).  Karena ini, seluruh kode dari setiap pass optimasi akan disimpan bersama-sama dan dapat dilakukan tanpa tidak langsung dari pola pengunjung. <br><br>  Seringkali berguna untuk melihat masalah dari sudut pandang matriks.  Jika Anda menerapkannya pada struktur berorientasi objek yang dipikirkan semua orang, itu dapat mengarahkan saya ke sesuatu yang lain, misalnya, ke pola "entitas-komponen-sistem", database relasional, atau pemrograman reaktif. <br><br>  Dan ini tidak hanya berlaku untuk kode.  Ini adalah contoh penerapan ide ini pada produk.  Misalkan ada orang dengan minat berbeda: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Nick </th><th>  Feng </th><th>  Sayid </th><th>  Alice </th></tr></thead><tbody><tr><th>  mobil </th><td>  X </td><td></td><td></td><td>  X </td></tr><tr><th>  politik </th><td></td><td>  X </td><td>  X </td><td></td></tr><tr><th>  matematika </th><td></td><td></td><td>  X </td><td>  X </td></tr><tr><th>  bepergian </th><td>  X </td><td>  X </td><td></td><td></td></tr></tbody></table></div><br>  Jika saya mengembangkan situs jejaring sosial, saya dapat memungkinkan orang untuk mengikuti berita <em>orang</em> lain.  Nick dapat mendaftar untuk Alice, karena mereka berdua tertarik pada mobil, dan pada Fenya, karena mereka berdua tertarik bepergian.  Tapi Nick juga akan menerima posting Alice tentang matematika dan posting Fenya tentang politik.  Jika saya mempertimbangkan matriks yang diubah, saya dapat memungkinkan orang untuk berlangganan <em>topik</em> .  Nick bisa bergabung dengan sekelompok pecinta mobil, serta sekelompok pelancong.  Facebook dan Reddit dimulai sekitar waktu yang sama, tetapi mereka mengubah matriks satu sama lain.  Facebook memungkinkan Anda untuk mengikuti orang;  Reddit memungkinkan Anda untuk berlangganan topik. <br><br>  Ketika saya berhenti atau ketika saya ingin mempertimbangkan alternatif, saya melihat masalah dan mencari kapak pemesanan yang berbeda di dalamnya.  Terkadang melihat masalah dari sudut yang berbeda dapat memberikan solusi yang lebih baik. <br><br><h2>  Brainstorming Dekomposisi </h2><br>  Saya menggunakan teknik lain yang disebut dekomposisi. <br><br>  Dalam aljabar, operasi <em>dekomposisi</em> mengubah polinomial dari bentuk 5x² + 8x - 21 menjadi (x + 3) · (5x - 7).  Untuk menyelesaikan persamaan 5x² + 8x - 21 = 0, pertama-tama kita dapat memasukkannya menjadi (x + 3) · (5x - 7) = 0. Kemudian kita dapat mengatakan bahwa x + 3 = 0 <em>atau</em> 5x - 7 = 0. Ekspansi mengubah tugas yang sulit menjadi beberapa tugas yang lebih mudah. <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  x </th><th>  3 </th></tr></thead><tbody><tr><th>  5x </th><td>  5x² </td><td>  15x </td></tr><tr><th>  -7 </th><td>  -7x </td><td>  -21 </td></tr></tbody></table></div><br>  Mari kita lihat sebuah contoh: Saya memiliki enam kelas: <code>File</code> , <code>EncryptedFile</code> , <code>GzipFile</code> , <code>EncryptedGzipFile</code> , <code>BzipFile</code> , <code>EncryptedBzipFile</code> .  Saya bisa menguraikannya menjadi sebuah matriks: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Tidak terkompresi </th><th>  Gzip </th><th>  Bzip </th></tr></thead><tbody><tr><th>  Tidak terenkripsi </th><td>  File </td><td>  Gzip (file) </td><td>  Bzip (file) </td></tr><tr><th>  Dienkripsi </th><td>  Enkripsi (File) </td><td>  Enkripsi (Gzip (File)) </td><td>  Enkripsi (Bzip (File)) </td></tr></tbody></table></div><br>  Menggunakan pola "dekorator" (atau pengotor), saya mengubah enam jenis file menjadi empat komponen: polos, gzip, bzip, terenkripsi.  Ini sepertinya tidak banyak menghemat, tetapi jika saya menambahkan lebih banyak variasi, penghematan akan meningkat.  Dekomposisi mengubah komponen O (M * N) menjadi komponen O (M + N). <br><br>  Contoh lain: kadang-kadang orang bertanya kepada saya pertanyaan seperti <em>"bagaimana cara menulis interpolasi linier dalam C #?"</em>  .  Saya dapat menulis banyak tutorial potensial: <br><br><div class="scrollable-table"><table><thead><tr><th></th><th>  C ++ </th><th>  Python </th><th>  Jawa </th><th>  C # </th><th>  Javascript </th><th>  Karat </th><th>  Idris </th><th>  ... </th></tr></thead><tbody><tr><th>  Interpolasi </th></tr><tr><th>  Tetangga </th></tr><tr><th>  Merintis jalan </th></tr><tr><th>  Jarak </th></tr><tr><th>  Peta sungai </th></tr><tr><th>  Isometrik </th></tr><tr><th>  Voronoi </th></tr><tr><th>  Transformasi </th></tr><tr><th>  ... </th></tr></tbody></table></div><br>  Jika ada topik M dan bahasa N, maka saya bisa menulis tutorial M * N.  Namun, ini <em>banyak</em> pekerjaan.  Sebagai gantinya, saya akan menulis tutorial tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interpolasi</a> , orang lain akan menulis tutorial tentang C #, dan kemudian pembaca akan menggabungkan pengetahuan C # dengan pengetahuan interpolasi, dan menulis versinya tentang interpolasi di C #. <br><br>  Seperti transposisi, dekomposisi tidak selalu membantu, tetapi jika berlaku, itu bisa sangat berguna. <br><br><h2>  Brainstorming mundur </h2><br>  Dalam dua bagian sebelumnya, saya berbicara tentang bagaimana saya kadang-kadang mendekati tugas, mencoba mengaturnya menjadi sebuah matriks.  Terkadang ini tidak membantu dan kemudian saya mencoba melihat tugas dengan arah yang berlawanan.  Mari kita lihat pembuatan peta prosedural, misalnya.  Seringkali saya mulai dengan fungsi noise, kemudian menambahkan oktaf, menyesuaikan parameter, dan menambahkan layer.  Saya melakukan ini karena saya memerlukan kartu yang memiliki properti tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/4b0/dec/fbc4b0decc5a714f115515a82050b9be.png"></div><br>  Sangat mungkin untuk memulai dengan percobaan dengan parameter, tetapi ruang parameternya cukup besar, dan tidak diketahui apakah saya akan menemukan parameter yang paling cocok untuk kebutuhan saya.  Karena itu, setelah bereksperimen sedikit, saya berhenti dan mulai berpikir dalam urutan terbalik: jika saya bisa menggambarkan apa yang saya butuhkan, maka ini dapat membantu dalam menemukan parameter. <br><br>  Motivasi inilah yang membuat saya belajar aljabar.  Jika kita memiliki persamaan bentuk <em>5x² + 8x - 21 = 0</em> , lalu apa yang akan menjadi <em>x</em> ?  Ketika saya tidak tahu aljabar, saya akan menyelesaikan persamaan ini, mencoba untuk mengganti nilai-nilai berbeda dari <em>x</em> , pertama-tama memilihnya secara acak, dan kemudian menyesuaikannya ketika saya merasa bahwa saya sudah dekat dengan solusi.  Aljabar memberi kita alat untuk pergi ke arah yang berbeda.  Alih-alih menebak jawabannya, dia memberi saya alat (dekomposisi, atau persamaan kuadrat, atau metode Newton untuk pencarian iteratif untuk root), yang saya dapat lebih sadar gunakan untuk mencari nilai <em>x</em> (-3 atau 7/5). <br><br>  Saya merasa seperti saya sering masuk ke dalam situasi pemrograman semacam ini.  Saat mengerjakan pembuatan peta prosedural, setelah bereksperimen dengan parameter untuk beberapa waktu, saya berhenti dan menyusun daftar apa yang seharusnya ada di dunia game dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu proyek</a> : <br><br><ol><li>  Pemain harus memulai permainan jauh dari pantai. </li><li>  Saat naik level, pemain harus naik ke atas bukit. </li><li>  Pemain seharusnya tidak dapat mencapai tepi peta. </li><li>  Ketika level bertambah, pemain harus bergabung dalam grup. </li><li>  Seharusnya ada monster sederhana di pantai tanpa banyak variasi. </li><li>  Di dataran harus ada berbagai monster dengan kesulitan sedang. </li><li>  Di daerah pegunungan pasti ada bos monster yang kompleks. </li><li>  Pasti ada semacam tengara yang memungkinkan pemain tetap pada tingkat kesulitan yang sama, dan tengara lain yang memungkinkan Anda naik atau turun di tingkat kesulitan. </li></ol><br>  Kompilasi daftar ini mengarah pada pembuatan pembatasan berikut: <br><br><ol><li>  Dunia permainan haruslah pulau-pulau dengan banyak pantai dan puncak kecil di tengahnya. </li><li>  Ketinggian harus sesuai dengan kompleksitas monster. </li><li>  Pada ketinggian rendah dan tinggi, seharusnya ada lebih sedikit variabilitas bioma daripada di ketinggian sedang. </li><li>  Jalan harus tetap pada tingkat kesulitan yang sama. </li><li>  Sungai harus mengalir dari ketinggian besar ke kecil, dan memberi pemain kemampuan untuk naik / turun. </li></ol><br>  Keterbatasan ini membuat saya merancang generator peta.  Dan dia menghasilkan kartu yang <em>jauh</em> lebih baik daripada yang saya terima dengan menyesuaikan parameter, seperti yang biasa saya lakukan.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang dihasilkan</a> menarik banyak orang untuk membuat peta berdasarkan diagram Voronoi. <br><br>  Tes unit adalah contoh lain.  Disarankan agar saya membuat daftar contoh untuk diuji.  Sebagai contoh, untuk kisi-kisi segi enam, saya mungkin berpikir bahwa saya perlu memeriksa kondisi <code>add(Hex(1, 2), Hex(3, 4)) == Hex(4, 6)</code> .  Maka saya dapat mengingat bahwa Anda perlu memeriksa nol: <code>add(Hex(0, 1), Hex(7, 9)) == Hex(7, 10)</code> .  Maka saya dapat mengingat bahwa Anda perlu memeriksa nilai negatif: <code>add(Hex(-3, 4) + Hex(7, -8)) == Hex(4, -4)</code> .  Bagus, bagus, saya punya beberapa unit test. <br><br>  Tetapi jika Anda berpikir sedikit lebih jauh, maka <em>sebenarnya</em> saya periksa <code>add(Hex(A, B), Hex(C, D)) == Hex(A+C, B+D)</code> .  Saya datang dengan tiga contoh yang ditunjukkan di atas berdasarkan aturan umum ini.  Saya akan ke arah yang berlawanan dari aturan ini untuk datang ke unit test.  Jika saya bisa langsung menyandikan aturan ini ke dalam sistem pengujian, maka sistem itu sendiri akan dapat bekerja dalam urutan terbalik untuk membuat contoh untuk pengujian.  Ini disebut pengujian berbasis properti.  (Lihat juga: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian metamorf</a> ) <br><br>  Contoh lain: pemecah kendala.  Dalam sistem seperti itu, pengguna menggambarkan apa yang ingin dilihat dalam output, dan sistem menemukan cara untuk memenuhi kendala ini.  Kutipan dari Buku Generasi Konten Prosedural, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab 8</a> : <br><br><blockquote>  Dengan menggunakan metode konstruktif dari Bab 3, serta metode fraktal dan noise dari Bab 4, kita dapat membuat berbagai jenis data keluaran dengan menyetel algoritme hingga kami puas dengan data keluarannya.  Tetapi jika kita tahu properti apa yang seharusnya dimiliki oleh konten yang dihasilkan, akan lebih mudah untuk menunjukkan secara langsung apa yang kita inginkan dari algoritma umum untuk menemukan konten yang memenuhi kriteria kita. </blockquote><br>  Buku ini menjelaskan pemrograman set jawaban (ASP), di mana kami menggambarkan struktur dari apa yang kami kerjakan (ubin adalah lantai dan dinding, ubin saling membatasi), struktur solusi yang kami cari (ruang bawah tanah adalah grup ubin terhubung dengan awal dan akhir) dan sifat-sifat solusi (lorong samping harus berisi tidak lebih dari 5 kamar, harus ada 1-2 loop di labirin, tiga asisten harus dikalahkan sebelum mencapai bos).  Setelah itu, sistem menciptakan solusi yang memungkinkan dan memungkinkan Anda memutuskan apa yang harus dilakukan dengannya. <br><br>  Baru-baru ini, pemecah kendala dikembangkan, yang menyebabkan minat besar karena namanya yang keren dan demo yang menarik: Wave Function Collapse.  <i>[Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang pemecah masalah ini pada Habr.]</i> Jika Anda memberinya contoh gambar untuk menunjukkan batasan apa yang dikenakan pada ubin tetangga, ia akan membuat contoh baru yang sesuai dengan pola yang diberikan.  Karyanya dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WaveFunctionCollapse adalah Constraint Solving in the Wild</a> : <br><br><blockquote>  WFC mengimplementasikan metode pencarian yang serakah tanpa kembali.  Artikel ini mengeksplorasi WFC sebagai contoh metode keputusan berbasis kendala. </blockquote><br>  Saya telah mencapai banyak hal dengan bantuan pemecah kendala.  Seperti halnya aljabar, sebelum saya belajar cara menggunakannya secara efektif, saya perlu belajar banyak. <br><br>  Contoh lain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesawat ruang angkasa yang saya buat</a> .  Pemain dapat menyeret mesin ke mana saja, dan sistem akan menentukan mesin mana yang perlu diaktifkan ketika Anda mengklik W, A, S, D, Q, E. Misalnya, di kapal ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/aee/87d/7d5aee87d57fe506d7bbc1fe4a6fdc5e.jpg"></div><br>  Jika Anda ingin terbang ke depan, maka sertakan dua mesin belakang.  Jika Anda ingin berbelok ke kiri, maka hidupkan mesin kanan belakang dan kiri depan.  Saya mencoba mencari solusi, memaksa sistem untuk <em>beralih pada banyak parameter</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bab/69e/65c/bab69e65cda458ba9809e4bff4afc27b.png"></div><br>  Sistem bekerja, tetapi tidak sempurna.  Kemudian saya menyadari bahwa ini adalah contoh lain di mana solusi dalam arah yang berlawanan dapat membantu.  Ternyata pergerakan pesawat ruang angkasa dapat digambarkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem pembatasan linear</a> .  Jika saya memahami hal ini, saya bisa menggunakan pustaka siap pakai yang secara akurat menyelesaikan kendala, dan bukan metode coba-coba saya, yang mengembalikan perkiraan. <br><br>  Dan contoh lain: proyek G9.js, di mana Anda dapat menyeret <em>output</em> fungsi tertentu di layar, dan menentukan bagaimana mengubah <em>data input</em> agar sesuai dengan data output yang diinginkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demo G9.js</a> tampak hebat!  Pastikan untuk menghapus tanda komentar pada baris "hapus komentar baris berikut" di demo Rings. <br><br>  Terkadang berguna untuk memikirkan tugas dalam urutan terbalik.  Sering kali ternyata ini memberi saya solusi yang <em>lebih baik</em> daripada dengan alasan langsung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453170/">https://habr.com/ru/post/id453170/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453158/index.html">Saya tidak tahu cara kerja prosesor, jadi saya menulis simulator perangkat lunak</a></li>
<li><a href="../id453162/index.html">Barang Antik: ThinkPad 380E, Kelas Ekonomi 90-an dan Windows 95</a></li>
<li><a href="../id453164/index.html">Token Kriptografi PKCS # 11. Utilitas grafis "dengan fungsi menandatangani dan menambahkan cap waktu." Bagian 1</a></li>
<li><a href="../id453166/index.html">Mengubah ViewPager menjadi manajer fragmen dengan animasi gaya iOS</a></li>
<li><a href="../id453168/index.html">Penelitian: membuat layanan proxy pemblokiran menggunakan teori permainan</a></li>
<li><a href="../id453174/index.html">Delapan alasan untuk beralih ke Yandex. Cashier API baru</a></li>
<li><a href="../id453178/index.html">Keahlian utama pengembang yang akan membuat kode Anda lebih baik</a></li>
<li><a href="../id453180/index.html">Bagaimana melakukan perencanaan triwulanan Paperless Terdistribusi dan tidak mengacaukannya?</a></li>
<li><a href="../id453182/index.html">Seluruh dunia di saku Anda atau cara membuat kartu seluler dalam beberapa hari</a></li>
<li><a href="../id453188/index.html">Bagaimana menjelaskan kepada manajer non-IT prinsip-prinsip membangun infrastruktur TI yang toleran terhadap kesalahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>