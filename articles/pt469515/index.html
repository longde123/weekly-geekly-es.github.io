<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💾 🐄 🐆 Preparando o Aplicativo para Istio 🙇🏼 👂🏽 🚴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Istio é uma ferramenta conveniente para conectar, proteger e monitorar aplicativos distribuídos. O Istio usa uma variedade de tecnologias para inici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preparando o Aplicativo para Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/469515/"><p><img src="https://habrastorage.org/webt/qy/yw/v1/qyywv1qmzphh1svbblasrxjc6ym.jpeg"></p><br><p>  O Istio é uma ferramenta conveniente para conectar, proteger e monitorar aplicativos distribuídos.  O Istio usa uma variedade de tecnologias para iniciar e gerenciar software em larga escala, incluindo contêineres para empacotar código de aplicativo e dependências para implantação e o Kubernetes para gerenciar esses contêineres.  Portanto, para trabalhar com o Istio, você deve saber como um aplicativo com vários serviços baseados nessas tecnologias funciona <em>sem o</em> Istio.  Se você já conhece essas ferramentas e conceitos, sinta-se à vontade para pular este guia e ir direto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instalação do Istio no Google Kubernetes Engine (GKE)</a> ou instalação da extensão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Istio on GKE</a> . </p><br><p>  Este é um guia passo a passo, onde examinaremos todo o processo, do código-fonte até um contêiner no GKE, para que você tenha uma idéia básica dessas tecnologias usando um exemplo.  Você também verá como o Istio tira proveito dessas tecnologias.  Supõe-se que você não saiba nada sobre contêineres, Kubernetes, malha de serviço ou Istio. </p><a name="habracut"></a><br><h3 id="zadachi">  As tarefas </h3><br><p>  Neste guia, você concluirá as seguintes tarefas: </p><br><ol><li>  Explorando um aplicativo simples olá mundo com vários serviços. </li><li>  Executando o aplicativo a partir do código fonte. </li><li>  Empacotar o aplicativo em recipientes. </li><li>  Criando um cluster Kubernetes </li><li>  Implante contêineres em um cluster. </li></ol><br><h3 id="prezhde-chem-nachat">  Antes de começar </h3><br><p>  Siga as instruções para ativar a API do Kubernetes Engine: </p><br><ol><li>  Vá para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a página do Kubernetes Engine</a> no console do Google Cloud Platform. </li><li>  Crie ou selecione um projeto. </li><li>  Aguarde a API e os serviços relacionados serem ativados.  Isso pode levar alguns minutos. </li><li>  Verifique se o faturamento está configurado para o projeto do Google Cloud Platform.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saiba como ativar o faturamento</a> . </li></ol><br><p>  Neste guia, você pode usar o Cloud Shell, que prepara a máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">g1-small no Google Compute Engine</a> com Linux baseado no Debian ou em um computador Linux ou macOS. </p><br><h3 id="variant-a-ispolzovanie-cloud-shell">  Opção A: Usando o Cloud Shell </h3><br><p>  Benefícios do uso do Cloud Shell: </p><br><ul><li>  Os ambientes de desenvolvimento Python 2 e Python 3 (incluindo <strong>virtualenv</strong> ) são totalmente personalizados. </li><li>  As <strong>ferramentas de</strong> linha de comando <strong>gcloud</strong> , <strong>docker</strong> , <strong>git</strong> e <strong>kubectl</strong> que usaremos já estão instaladas. </li><li>  Você tem vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">editores de texto</a> para escolher: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O editor de código</a> que é aberto com o ícone de edição na parte superior da janela do Cloud Shell. </li><li>  Emacs, Vim ou Nano que são abertos na linha de comando no Cloud Shell. </li></ol></li></ul><br><p>  Para usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cloud Shell</a> : </p><br><ol><li>  Vá para o console do GCP. </li><li>  Clique no botão <strong>Ativar Shell da Nuvem</strong> na parte superior da janela do console do GCP. </li></ol><br><p><img src="https://habrastorage.org/webt/yu/sh/9x/yush9xie9_peummad02lgu2n5x8.png"></p><br><p>  Na parte inferior do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">console do GCP,</a> em uma nova janela, uma sessão do Cloud Shell é aberta com uma linha de comando. </p><br><p><img src="https://habrastorage.org/webt/yi/no/-q/yino-qj5bwaluwxlo3xtf0yr7ty.png"></p><br><h3 id="variant-b-ispolzovanie-instrumentov-komandnoy-stroki-lokalno">  Opção B: usando ferramentas de linha de comando localmente </h3><br><p>  Se você estiver trabalhando em um computador com Linux ou macOS, precisará configurar e instalar os seguintes componentes: </p><br><ol><li><p>  Configure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu ambiente de desenvolvimento Python 3 e Python 2</a> . </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instale o Cloud SDK</a> com a <strong>ferramenta de</strong> linha de comando <strong>gcloud</strong> . </p><br></li><li><p>  Instale o <strong>kubectl</strong> , uma ferramenta de linha de comando para trabalhar com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> . </p><br><pre><code class="plaintext hljs">gcloud components install kubectl</code> </pre> <br></li><li><p>  Instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker Community Edition (CE)</a> .  Você usará a ferramenta de linha de comando do <strong>docker</strong> para criar imagens de contêiner para um aplicativo de amostra. </p><br></li><li><p>  Instale a ferramenta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controle de versão</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Git</a> para obter um aplicativo de amostra com o GitHub. </p><br></li></ol><br><h3 id="zagruzka-primera-koda">  Faça o download do código de exemplo </h3><br><ol><li><p>  Faça o download do código fonte do <strong>helloserver</strong> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/GoogleCloudPlatform/istio-samples</code> </pre> <br></li><li><p>  Vá para o diretório de código de amostra: </p><br><pre> <code class="plaintext hljs">cd istio-samples/sample-apps/helloserver</code> </pre> <br></li></ol><br><h3 id="izuchenie-prilozheniya-s-neskolkimi-servisami">  Explorando um Aplicativo Multisserviço </h3><br><p>  O aplicativo de amostra é escrito em Python e consiste em dois componentes que interagem com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">REST</a> : </p><br><ul><li>  <strong>servidor</strong> : um servidor simples com um ponto de extremidade <strong>GET, /</strong> , que exibe "hello world" no console. </li><li>  <strong>loadgen</strong> : um script que envia tráfego para o <strong>servidor</strong> , com um número configurável de solicitações por segundo. </li></ul><br><p><img src="https://habrastorage.org/webt/b1/ky/lj/b1kyljxdkjdci12qtle2w3dmtjw.png"></p><br><h3 id="zapusk-prilozheniya-iz-ishodnogo-koda">  Executando um Aplicativo da Origem </h3><br><p>  Para aprender um aplicativo de exemplo, execute-o no Cloud Shell ou em um computador. <br>  1) No <strong>diretório istio-samples / sample-apps / helloserver</strong> , execute o <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">python3 server/server.py</code> </pre> <br><p>  Quando o <strong>servidor</strong> inicia, o seguinte é exibido: </p><br><pre> <code class="plaintext hljs">INFO:root:Starting server...</code> </pre> <br><p>  2) Abra outra janela do terminal para enviar solicitações ao <strong>servidor</strong> .  Se você estiver usando o Cloud Shell, clique no ícone Adicionar para abrir outra sessão. <br>  3) Envie uma solicitação ao <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">curl http://localhost:8080</code> </pre> <br><p>  respostas do servidor: </p><br><pre> <code class="plaintext hljs">Hello World!</code> </pre> <br><p>  4) No diretório em que você baixou o código de amostra, acesse o diretório que contém <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/loadgen</code> </pre> <br><p>  5) Crie as seguintes variáveis ​​de ambiente: </p><br><pre> <code class="plaintext hljs">export SERVER_ADDR=http://localhost:8080 export REQUESTS_PER_SECOND=5</code> </pre> <br><p>  6) Execute <strong>virtualenv</strong> : </p><br><pre> <code class="plaintext hljs">virtualenv --python python3 env</code> </pre> <br><p>  7) Ative o ambiente virtual: </p><br><pre> <code class="plaintext hljs">source env/bin/activate</code> </pre> <br><p>  8) Defina os requisitos para o <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">pip3 install -r requirements.txt</code> </pre> <br><p>  9) Execute o <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">python3 loadgen.py</code> </pre> <br><p>  Quando iniciado, o <strong>loadgen</strong> exibe a seguinte mensagem: </p><br><pre> <code class="plaintext hljs">Starting loadgen: 2019-05-20 10:44:12.448415 5 request(s) complete to http://localhost:8080</code> </pre> <br><p>  Em outra janela do terminal, o <strong>servidor</strong> exibe as seguintes mensagens no console: </p><br><pre> <code class="plaintext hljs">127.0.0.1 - - [21/Jun/2019 14:22:01] "GET / HTTP/1.1" 200 - INFO:root:GET request, Path: / Headers: Host: localhost:8080 User-Agent: python-requests/2.22.0 Accept-Encoding: gzip, deflate Accept: */*</code> </pre> <br><p>  Do ponto de vista da rede, o aplicativo inteiro é executado no mesmo host (computador local ou máquina virtual do Cloud Shell).  Portanto, você pode usar o <strong>host local</strong> para enviar solicitações ao <strong>servidor</strong> . <br>  10) Para parar o <strong>loadgen</strong> e o <strong>servidor</strong> , digite <strong>Ctrl-c</strong> em cada janela do terminal. <br>  11) Na <strong>janela do</strong> terminal <strong>loadgen,</strong> desative o ambiente virtual: </p><br><pre> <code class="plaintext hljs">deactivate</code> </pre> <br><h3 id="upakovka-prilozheniya-v-konteynery">  Empacotando o aplicativo em contêineres </h3><br><p>  Para executar o aplicativo no GKE, você precisa empacotar o aplicativo de amostra - <strong>server</strong> e <strong>loadgen</strong> - em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contêineres</a> .  Um contêiner é uma maneira de compactar um aplicativo para isolá-lo do ambiente. </p><br><p>  Para compactar o aplicativo em um contêiner, você precisa de um <strong>Dockerfile</strong> .  <strong>Um Dockerfile</strong> é um arquivo de texto que define comandos para criar o código-fonte de um aplicativo e suas dependências em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma imagem do Docker.</a>  Após a compilação, você carrega a imagem no registro de contêiner, por exemplo, no Docker Hub ou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registro de Contêiner</a> . </p><br><p>  O exemplo já possui um <strong>Dockerfile</strong> para <strong>servidor</strong> e <strong>loadgen</strong> com todos os comandos necessários para montar as imagens.  Abaixo está o <strong>Dockerfile</strong> para <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">FROM python:3-slim as base FROM base as builder RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ g++ \ &amp;&amp; rm -rf /var/lib/apt/lists/* # Enable unbuffered logging FROM base as final ENV PYTHONUNBUFFERED=1 RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ wget WORKDIR /helloserver # Grab packages from builder COPY --from=builder /usr/local/lib/python3.7/ /usr/local/lib/python3.7/ # Add the application COPY . . EXPOSE 8080 ENTRYPOINT [ "python", "server.py" ]</code> </pre> <br><ul><li>  O comando <strong>FROM python: 3-slim as base</strong> informa ao Docker para usar a imagem mais recente do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python 3</a> como base. </li><li>  Equipe de <strong>cópia.</strong>  <strong>.</strong>  copia os arquivos de origem para o diretório de trabalho atual (no nosso caso, apenas <strong>server.py</strong> ) no sistema de arquivos do contêiner. </li><li>  <strong>ENTRYPOINT</strong> define o comando usado para iniciar o contêiner.  No nosso caso, esse comando é quase o mesmo que você usou para executar o <strong>server.py a</strong> partir do código fonte. </li><li>  O comando <strong>EXPOSE</strong> indica que o <strong>servidor</strong> está escutando na porta <strong>8080</strong> .  Este comando não <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fornece portas</a> .  Esse é algum tipo de documentação necessária para abrir a porta <strong>8080</strong> quando o contêiner é iniciado. </li></ul><br><h3 id="podgotovka-k-konteynerizacii-prilozheniya">  Preparando para Contêiner de Aplicativos </h3><br><p>  1) Defina as seguintes variáveis ​​de ambiente.  Substitua <strong>PROJECT_ID</strong> pelo seu identificador de projeto do GCP. </p><br><pre> <code class="plaintext hljs">export PROJECT_ID="PROJECT_ID"</code> </pre> <br><pre> <code class="plaintext hljs">export GCR_REPO="preparing-istio"</code> </pre> <br><p>  Usando os <strong>valores</strong> <strong>PROJECT_ID</strong> e <strong>GCR_REPO,</strong> você marca a imagem do Docker quando a coleta e envia para o Registro de Contêiner privado. </p><br><p>  2) Defina o projeto GCP padrão para a <strong>ferramenta de</strong> linha de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set project $PROJECT_ID</code> </pre> <br><p>  3) Defina a zona padrão para a <strong>ferramenta de</strong> linha de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set compute/zone us-central1-b</code> </pre> <br><p>  4) Verifique se o serviço Registro de Contêiner está incluído no projeto GCP. </p><br><pre> <code class="plaintext hljs">gcloud services enable containerregistry.googleapis.com</code> </pre> <br><h3 id="konteynerizaciya-server">  Servidor de conteinerização </h3><br><ol><li><p>  Mude para o diretório em que o exemplo do <strong>servidor</strong> está localizado: </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br></li><li><p>  Crie a imagem usando o <strong>Dockerfile</strong> e as variáveis ​​de ambiente que você definiu anteriormente: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1 .</code> </pre> <br></li></ol><br><p>  A <strong>opção -t</strong> representa a marca do Docker.  Este é o nome da imagem que você usa ao implantar o contêiner. </p><br><ol><li>  Envie a imagem para o Registro do Contêiner: <br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1</code> </pre> </li></ol><br><h3 id="konteynerizaciya-loadgen">  Containergen loadgen </h3><br><p>  1) Vá para o diretório em que o exemplo <strong>loadgen</strong> está <strong>localizado</strong> : </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  2) Monte a imagem: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1 .</code> </pre> <br><p>  3) Envie a imagem para o Registro de Contêiner: </p><br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1</code> </pre> <br><h3 id="prosmotr-spiska-obrazov">  Ver uma lista de imagens </h3><br><p>  Navegue na lista de imagens no repositório e verifique se as imagens foram enviadas: </p><br><pre> <code class="plaintext hljs">gcloud container images list --repository gcr.io/$PROJECT_ID/preparing-istio</code> </pre> <br><p>  O comando exibe os nomes das imagens recém-enviadas: </p><br><pre> <code class="plaintext hljs">NAME gcr.io/PROJECT_ID/preparing-istio/helloserver gcr.io/PROJECT_ID/preparing-istio/loadgen</code> </pre> <br><h3 id="sozdanie-klastera-gke">  Criando um cluster GKE </h3><br><p>  Esses contêineres podem ser executados na máquina virtual do Cloud Shell ou no computador com o <strong>comando docker run</strong> .  Mas em um ambiente de produção, você precisa de uma maneira de orquestrar centralmente os contêineres.  Por exemplo, precisamos de um sistema que garanta que os contêineres sempre funcionem e precisamos de uma maneira de aumentar o zoom e lançar instâncias adicionais de contêineres se o tráfego aumentar. </p><br><p>  Você pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GKE</a> para executar aplicativos de contêiner.  O GKE é uma plataforma de orquestração de contêineres que agrupa máquinas virtuais.  Cada máquina virtual é chamada de host.  Os clusters GKE são baseados no sistema de gerenciamento de cluster de código aberto Kubernetes.  O Kubernetes fornece mecanismos para interagir com o cluster. </p><br><p>  Criando um cluster GKE: </p><br><p>  1) Crie um cluster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters create istioready \ --cluster-version latest \ --machine-type=n1-standard-2 \ --num-nodes 4</code> </pre> <br><p>  O comando <strong>gcloud</strong> cria um cluster <strong>istioready</strong> no projeto GCP e a zona padrão que você especificou.  Para iniciar o Istio, recomendamos que você tenha pelo menos 4 nós e uma máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n1-standard-2</a> . </p><br><p>  A equipe cria um cluster por vários minutos.  Quando o cluster está pronto, o comando emite uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mensagem</a> semelhante. </p><br><p>  2) Especifique as credenciais na <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta de</a></strong> linha de comando <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kubectl</a></strong> para usá-la para gerenciar o cluster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters get-credentials istioready</code> </pre> <br><p>  3) Agora você pode se comunicar com o Kubernetes através do <strong>kubectl</strong> .  Por exemplo, com o seguinte comando, você pode descobrir o status dos nós: </p><br><pre> <code class="plaintext hljs">kubectl get nodes</code> </pre> <br><p>  O comando exibe uma lista de nós: </p><br><pre> <code class="plaintext hljs">NAME STATUS ROLES AGE VERSION gke-istoready-default-pool-dbeb23dc-1vg0 Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-36z5 Ready &lt;none&gt; 100s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-fj7s Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-wbjw Ready &lt;none&gt; 99s v1.13.6-gke.13</code> </pre> <br><h3 id="klyuchevye-ponyatiya-kubernetes">  Principais conceitos do Kubernetes </h3><br><p>  O diagrama mostra a aplicação no GKE: </p><br><p><img src="https://habrastorage.org/webt/-s/x2/uj/-sx2ujtlifvzdtixzdqpnr9jzva.png"></p><br><p>  Antes de implantar contêineres no GKE, observe os principais conceitos do Kubernetes.  Existem links no final, se você quiser saber mais. </p><br><ul><li>  <strong>Nós e clusters</strong> .  No GKE, um nó é uma máquina virtual.  Em outras plataformas Kubernetes, o host pode ser um computador ou máquina virtual.  Um cluster é uma coleção de nós que podem ser considerados como um todo e onde você implementa um aplicativo em contêiner. </li><li>  <strong>Pods</strong> .  No Kubernetes, os contêineres são executados em cápsulas.  Um pod em Kubernetes é uma unidade indivisível.  Um pod contém um ou mais contêineres.  Você implanta o servidor e <strong>carrega contêineres</strong> em pods separados.  Quando existem vários contêineres em um pod (por exemplo, um servidor de aplicativos e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servidor proxy</a> ), os contêineres são gerenciados como um único objeto e compartilham os recursos do pod. </li><li>  <strong>Implantação</strong> .  No Kubernetes, a implantação é um objeto que é uma coleção de pods idênticos.  A implantação executa várias réplicas de pods distribuídos pelos nós do cluster.  A implantação substitui automaticamente os pods que falham ou não respondem. </li><li>  <strong>Serviço Kubernetes</strong> .  Quando você executa o código do aplicativo no GKE, a conexão entre o <strong>loadgen</strong> e o <strong>servidor</strong> muda.  Quando você iniciou os serviços na máquina virtual do Cloud Shell ou no computador, enviou solicitações ao <strong>servidor</strong> em <strong>localhost: 8080</strong> .  Após a implantação no GKE, os pods são executados nos nós disponíveis.  Por padrão, você não pode controlar em que pod de host está sendo executado, para que os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pods</a> não tenham endereços IP permanentes. <br>  Para obter o endereço IP do <strong>servidor</strong> , você precisa definir a abstração da rede no topo dos pods.  Este é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">serviço Kubernetes</a> .  O serviço Kubernetes fornece um ponto final permanente para um conjunto de pods.  Existem vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos de serviços</a> .  <strong>O servidor</strong> usa um <strong>LoadBalancer</strong> , que fornece um endereço IP externo para entrar em contato com o <strong>servidor</strong> de fora do cluster. <br>  O Kubernetes também possui um sistema DNS interno que atribui nomes DNS (por exemplo, <strong>helloserver.default.cluster.local</strong> ) aos serviços.  Graças a isso, os pods dentro do cluster se comunicam com outros pods no cluster em um endereço fixo.  O nome DNS não pode ser usado fora do cluster, como no Cloud Shell ou em um computador. </li></ul><br><h3 id="manifesty-kubernetes">  Manifests de Kubernetes </h3><br><p>  Quando você iniciou o aplicativo a partir do código-fonte, usou o comando imperativo <strong>python3</strong> </p><br><p>  <strong>server.py</strong> </p><br><p>  Imperativo implica o verbo: "faça". </p><br><p>  Kubernetes usa um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo declarativo</a> .  Isso significa que não informamos ao Kubernetes o que exatamente precisa ser feito, mas descrevemos o estado desejado.  Por exemplo, o Kubernetes inicia e interrompe os pods conforme necessário, para que o estado real do sistema seja o desejado. </p><br><p>  Você especifica o estado desejado em manifestos ou arquivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YAML</a> .  O arquivo YAML contém especificações para um ou mais objetos Kubernetes. </p><br><p>  O exemplo contém o arquivo YAML para <strong>server</strong> e <strong>loadgen</strong> .  Cada arquivo YAML indica o estado desejado do objeto de implantação e do serviço Kubernetes. </p><br><p>  <strong>server.yaml</strong> </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: helloserver spec: selector: matchLabels: app: helloserver replicas: 1 template: metadata: labels: app: helloserver spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/helloserver:v0.0.1 imagePullPolicy: Always</code> </pre> <br><ul><li>  <strong>tipo</strong> indica o tipo de objeto. </li><li>  <strong>metadata.name</strong> indica o nome da implantação. </li><li>  A primeira <strong>especificação do</strong> campo contém uma descrição do estado desejado. </li><li>  <strong>spec.replicas</strong> indica o número desejado de pods. </li><li>  A seção <strong>spec.template</strong> define o modelo do <strong>pod</strong> .  Na especificação de pods, há um campo de <strong>imagem em</strong> que o nome da imagem a ser extraída do Registro de Contêiner é indicado. </li></ul><br><p>  O serviço é definido da seguinte maneira: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: hellosvc spec: type: LoadBalancer selector: app: helloserver ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><ul><li>  <strong>LoadBalancer</strong> : os clientes enviam solicitações para o endereço IP do balanceador de carga, que possui um endereço IP fixo e acessível de fora do cluster. </li><li>  <strong>targetPort</strong> : como você se lembra, o comando <strong>EXPOSE</strong> <strong>8080</strong> no <strong>Dockerfile</strong> não forneceu portas.  Você fornece a porta <strong>8080</strong> para poder alcançar o contêiner do <strong>servidor</strong> de fora do cluster.  No nosso caso, <strong>hellosvc.default.cluster.local: 80</strong> (nome abreviado: <strong>hellosvc</strong> ) corresponde à porta <strong>8080 do</strong> endereço IP do pod <strong>helloserver</strong> . </li><li>  <strong>port</strong> : este é o número da porta para a qual outros serviços no cluster enviarão solicitações. </li></ul><br><p>  <strong>loadgen.yaml</strong> </p><br><p>  O objeto de implementação no <strong>loadgen.yaml</strong> é semelhante ao <strong>server.yaml</strong> .  A diferença é que o objeto de implantação contém uma seção <strong>env</strong> .  Ele define as variáveis ​​de ambiente que o <strong>loadgen</strong> precisa e que você define quando iniciou o aplicativo a partir do código-fonte. </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: loadgenerator spec: selector: matchLabels: app: loadgenerator replicas: 1 template: metadata: labels: app: loadgenerator spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/loadgen:v0.0.1 imagePullPolicy: Always env: - name: SERVER_ADDR value: "http://hellosvc:80/" - name: REQUESTS_PER_SECOND value: "10" resources: requests: cpu: 300m memory: 256Mi limits: cpu: 500m memory: 512Mi</code> </pre> <br><p>  Como o <strong>loadgen</strong> não aceita solicitações de entrada, o <strong>ClusterIP é</strong> especificado para o campo de <strong>tipo</strong> .  Esse tipo fornece um endereço IP fixo que os serviços no cluster podem usar, mas esse endereço IP não é fornecido para clientes externos. </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: loadgensvc spec: type: ClusterIP selector: app: loadgenerator ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><h3 id="razvertyvanie-konteynerov-v-gke">  Implantar contêineres no GKE </h3><br><p>  1) Vá para o diretório em que o exemplo do <strong>servidor</strong> está localizado: </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br><p>  2) Abra <strong>server.yaml</strong> em um editor de texto. <br>  3) Substitua o nome no campo da <strong>imagem</strong> pelo nome da sua imagem do Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/helloserver:v0.0.1</code> </pre> <br><p>  Substitua <strong>PROJECT_ID</strong> pelo identificador do seu projeto GCP. <br>  4) Salve e feche <strong>server.yaml</strong> . <br>  5) Expanda o arquivo YAML no Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f server.yaml</code> </pre> <br><p>  Após a conclusão bem-sucedida, o comando emite o seguinte código: </p><br><pre> <code class="plaintext hljs">deployment.apps/helloserver created service/hellosvc created</code> </pre> <br><p>  6) Vá para o diretório em que o <strong>loadgen</strong> está localizado: </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  7) Abra o <strong>loadgen.yaml</strong> em um editor de texto. <br>  8) Substitua o nome no campo da <strong>imagem</strong> pelo nome da sua imagem do Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/loadgenv0.0.1</code> </pre> <br><p>  Substitua <strong>PROJECT_ID</strong> pelo identificador do seu projeto GCP. <br>  9) Salve e feche o <strong>loadgen.yaml</strong> , feche o editor de texto. <br>  10) Expanda o arquivo YAML no Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f loadgen.yaml</code> </pre> <br><p>  Após a conclusão bem-sucedida, o comando emite o seguinte código: </p><br><pre> <code class="plaintext hljs">deployment.apps/loadgenerator created service/loadgensvc created</code> </pre> <br><p>  11) Verifique o status das lareiras: </p><br><pre> <code class="plaintext hljs">kubectl get pods</code> </pre> <br><p>  O comando mostra o status: </p><br><pre> <code class="plaintext hljs">NAME READY STATUS RESTARTS AGE helloserver-69b9576d96-mwtcj 1/1 Running 0 58s loadgenerator-774dbc46fb-gpbrz 1/1 Running 0 57s</code> </pre> <br><p>  12) Extraia os logs do aplicativo do pod do <strong>loadgen</strong> .  Substitua <strong>POD_ID</strong> pelo identificador da resposta anterior. </p><br><pre> <code class="plaintext hljs">kubectl logs loadgenerator-POD_ID</code> </pre> <br><p>  13) Obtenha os <strong>IPs hellosvc</strong> externos: </p><br><pre> <code class="plaintext hljs">kubectl get service</code> </pre> <br><p>  A resposta do comando é mais ou menos assim: </p><br><pre> <code class="plaintext hljs">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE hellosvc LoadBalancer 10.81.15.158 192.0.2.1 80:31127/TCP 33m kubernetes ClusterIP 10.81.0.1 &lt;none&gt; 443/TCP 93m loadgensvc ClusterIP 10.81.15.155 &lt;none&gt; 80/TCP 4m52s</code> </pre> <br><p>  14) Envie uma solicitação ao <strong>hellosvc</strong> : substitua <strong>EXTERNAL_IP</strong> pelo endereço IP externo do <strong>hellosvc</strong> . </p><br><pre> <code class="plaintext hljs">curl http://EXTERNAL_IP</code> </pre> <br><h3 id="beremsya-za-istio">  Enfrentar Istio </h3><br><p>  Você já possui um aplicativo implantado no GKE.  <strong>O loadgen</strong> pode usar o DNS do Kubernetes ( <strong>hellosvc: 80</strong> ) para enviar solicitações ao <strong>servidor</strong> e você pode enviar solicitações ao <strong>servidor</strong> em um endereço IP externo.  Embora o Kubernetes tenha muitos recursos, faltam algumas informações sobre os serviços: </p><br><ul><li>  <strong>Como os serviços interagem?</strong>  Qual é a relação entre os serviços?  Como é o tráfego entre serviços?  Você está ciente de que o <strong>loadgen</strong> envia solicitações ao <strong>servidor</strong> , mas imagine que você não sabe nada sobre o aplicativo.  Para responder a essas perguntas, examinamos a lista de lares em funcionamento no GKE. </li><li>  <strong>Métricas</strong> .  Quanto tempo o <strong>servidor</strong> responde a uma solicitação de entrada?  Quantas solicitações por segundo vão para o servidor?  Dá mensagens de erro? </li><li>  <strong>Informações de segurança</strong> .  <strong>O</strong> tráfego entre o <strong>loadgen</strong> e o <strong>servidor é</strong> simplesmente via <strong>HTTP</strong> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mTLS</a> ? </li></ul><br><p>  Todas essas perguntas são respondidas por Istio.  Para fazer isso, o Istio coloca um proxy lateral do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Envoy</a> em cada pod.  O proxy Envoy intercepta todo o tráfego de entrada e saída para contêineres de aplicativos.  Isso significa que o <strong>servidor</strong> e o <strong>loadgen</strong> recebem proxies laterais do Envoy, e todo o tráfego do <strong>loadgen</strong> para o <strong>servidor</strong> passa pelos proxies do Envoy. </p><br><p>  As conexões entre os proxies Envoy formam uma malha de serviço.  A arquitetura de malha de serviço fornece uma camada de controle sobre o Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/7n/sk/z-/7nskz-5os2onyoaaf5kz5x38ve4.png"></p><br><p>  Depois que os proxies Envoy são executados em seus contêineres, o Istio pode ser instalado na parte superior do cluster GKE, quase sem alterar o código do aplicativo.  Mas você trabalhou para preparar o aplicativo para gerenciamento usando o Istio: </p><br><ul><li>  Serviços para todos os contêineres.  As <strong>implantações de</strong> <strong>servidor</strong> e <strong>loadgen são</strong> vinculadas pelo serviço Kubernetes.  Até o <strong>loadgen</strong> , que não recebe solicitações de entrada, possui um serviço. </li><li>  As portas nos serviços devem ter nomes.  Embora as portas de serviço possam ser deixadas sem nome no GKE, o Istio exige um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nome de porta de</a> acordo com seu protocolo.  No arquivo YAML, a porta do <strong>servidor</strong> é chamada <strong>http</strong> porque o servidor usa o <strong>protocolo HTTP</strong> .  Se o <strong>serviço</strong> usasse <strong>gRPC</strong> , você <strong>nomearia</strong> a porta <strong>grpc</strong> . </li><li>  As implantações estão marcadas.  Portanto, você pode usar os recursos de gerenciamento de tráfego do Istio, por exemplo, compartilhando o tráfego entre versões do mesmo serviço. </li></ul><br><h3 id="ustanovka-istio">  Instale o Istio </h3><br><p>  Existem duas maneiras de instalar o Istio.  Você pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ativar a extensão Istio no GKE</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instalar a versão de código aberto do Istio</a> em um cluster.  Com o Istio no GKE, você pode gerenciar facilmente a instalação e a atualização do Istio como parte do ciclo de vida do cluster GKE.  Se você precisar da versão mais recente do Istio ou de mais controle sobre a configuração do painel de controle do Istio, instale a versão de código aberto em vez da extensão Istio on GKE.  Para decidir sobre a abordagem, leia o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Preciso de Istio no GKE?</a>  . </p><br><p>  Selecione uma opção, estude o manual apropriado e siga as instruções para instalar o Istio no cluster.  Se você deseja usar o Istio com seu aplicativo recém-implantado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ative a incorporação de side-car</a> no espaço para nome <strong>padrão</strong> . </p><br><h3 id="ochistka">  Limpeza </h3><br><p>  Para garantir que os recursos utilizados neste guia não sejam debitados da sua conta do Google Cloud Platform, remova o cluster de contêiner ao instalar o Istio e brincar com o aplicativo de amostra.  Isso excluirá todos os recursos do cluster, como instâncias de computação, discos e recursos de rede. </p><br><h3 id="chto-dalshe">  O que vem a seguir? </h3><br><ul><li><p>  Aprenda as seguintes tecnologias: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Contentores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registro de contêiner</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gke</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Malha de serviço</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Isstio</a> </li></ol><br></li><li><p>  Aprenda as seguintes ferramentas: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cloud sdk</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Referência Gcloud</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>kubectl</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>estivador</strong></a> </li></ol><br></li><li><p>  Aprenda os conceitos do Kubernetes: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Clusters</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nós</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pods</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serviços</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implantação</a> </li></ol><br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469515/">https://habr.com/ru/post/pt469515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469499/index.html">Como nós da Parallels Conquistamos entre com a Apple</a></li>
<li><a href="../pt469503/index.html">Segurança cibernética: protegemos os dados dos assinantes contra vazamentos em 2019</a></li>
<li><a href="../pt469505/index.html">3 maneiras práticas de levar negócios para mercados estrangeiros: abordagens e técnicas de empresas reais</a></li>
<li><a href="../pt469507/index.html">Terceira vulnerabilidade do Steam Windows Client, mas não 0 dia</a></li>
<li><a href="../pt469509/index.html">Esquemas angulares, ou como eu escrevi meu modelo para cli angular</a></li>
<li><a href="../pt469521/index.html">Comprei uma moto para andar, para não cair</a></li>
<li><a href="../pt469523/index.html">Dependência do desempenho do código no contexto da declaração de variáveis ​​em JavaScript</a></li>
<li><a href="../pt469525/index.html">Sistema de controle automatizado para uma escavadeira de mineração</a></li>
<li><a href="../pt469527/index.html">O interfone é um ouvido espião?</a></li>
<li><a href="../pt469529/index.html">A renderização de texto odeia você</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>