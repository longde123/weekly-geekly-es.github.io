<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ·ï¸ â˜ğŸ¼ â­•ï¸ Blockchain Sharding ğŸ‚ â¬†ï¸ ğŸ‘§ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, saya adalah salah satu pengembang Near Protocol, yang, antara lain, mengimplementasikan sharding, dan dalam artikel ini saya ingin memb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Halo semuanya, saya adalah salah satu pengembang Near Protocol, yang, antara lain, mengimplementasikan sharding, dan dalam artikel ini saya ingin memberi tahu secara terperinci apa sharding yang ada di blockchain secara umum, cara kerjanya, dan menyentuh sejumlah masalah yang muncul ketika mencoba membangunnya. </p><br><p>  Diketahui bahwa Ethereum, platform dApps paling populer, memproses kurang dari 20 transaksi per detik.  Karena pembatasan ini, harga transaksi dan waktu untuk mengonfirmasinya sangat tinggi: terlepas dari kenyataan bahwa sebuah blok diterbitkan di Ethereum setiap 10-12 detik sekali, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ETH Gas Station,</a> waktu antara pengiriman transaksi dan bagaimana hal itu benar-benar jatuh ke dalam blok adalah rata-rata 1,2. menit.  Bandwidth rendah, harga tinggi, dan konfirmasi transaksi panjang tidak memungkinkan untuk meluncurkan layanan berkinerja tinggi di Ethereum. </p><br><p>  Alasan utama Ethereum tidak dapat memproses lebih dari 20 transaksi per detik adalah karena setiap node di Ethereum harus memeriksa setiap transaksi.  Selama lima tahun sejak rilis Ethereum, banyak ide telah diusulkan untuk menyelesaikan masalah ini.  Solusi ini dapat secara kasar dibagi menjadi dua kelompok: solusi yang menawarkan untuk mendelegasikan transaksi ke sekelompok kecil node dengan perangkat keras yang sangat baik, dan solusi yang menawarkan setiap node untuk memproses hanya sebagian dari semua transaksi.  Contoh dari pendekatan pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Guntur</a> , di mana blok dibuat hanya oleh satu simpul, yang memungkinkan, menurut pengembang, untuk menerima 1.200 transaksi per detik, yang 100 kali lebih banyak dari Ethereum.  Contoh lain dari kategori pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solana</a> .  Semua protokol ini meningkatkan berbagai aspek protokol dan memungkinkan Anda untuk melakukan lebih banyak transaksi daripada di Ethereum, tetapi semua dibatasi oleh kecepatan satu mesin (walaupun sangat kuat). </p><a name="habracut"></a><br><p>  Pendekatan kedua, di mana setiap node hanya memproses sebagian dari transaksi, disebut Sharding.  Ini adalah bagaimana Yayasan Ethereum berencana untuk meningkatkan bandwidth Ethereum. </p><br><p>  Dalam posting ini saya akan memberi tahu Anda bagaimana Sharding bekerja di Blockchain menggunakan contoh beberapa protokol yang saat ini sedang dikembangkan. </p><br><div class="spoiler">  <b class="spoiler_title">Terminologi</b> <div class="spoiler_text"><p>  Karena terminologinya tidak terstandarisasi, saya akan menggunakan istilah Rusia berikut dalam artikel: </p><br><p>  <strong>Blockchain</strong> adalah teknologi secara umum atau struktur data yang berisi semua blok, termasuk garpu. </p><br><p>  <strong>Rantai</strong> adalah satu rantai tertentu di blockchain, yaitu, semua blok yang dapat dijangkau dimulai dari blok menggunakan tautan ke blok sebelumnya. </p><br><p>  <strong>Rantai kanonik</strong> adalah satu rantai dalam blockchain yang partisipan yang menonton blockchain mempertimbangkan rantai saat ini.  Sebagai contoh, dalam blockchain Proof of Work, itu akan menjadi rantai dengan kompleksitas terbesar. </p><br><p>  <strong>Sebuah jaringan</strong> banyak peserta membangun dan menggunakan blockchain. </p><br><p>  <strong>Node</strong> adalah server yang mendukung atau menggunakan jaringan. </p></div></div><br><h2 id="samyy-prostoy-sharding">  Pecahan termudah </h2><br><p>  Dalam implementasi yang paling sederhana, alih-alih mendukung satu blockchain, kami akan mendukung beberapa blockchain, dan kami akan menyebut setiap blockchain tersebut sebagai "beling".  Setiap pecahan didukung oleh set node independen yang memverifikasi transaksi dan membuat blok.  Selanjutnya, saya akan memanggil validator node tersebut. </p><br><p>  Setiap pecahan bertanggung jawab atas sebagian kontrak dan akun.  Asumsikan untuk saat ini bahwa transaksi selalu beroperasi hanya dengan kontrak dan akun dalam beling yang sama.  Desain yang disederhanakan seperti ini sudah cukup untuk menunjukkan beberapa masalah menarik dan fitur sharding. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Pengangkatan Validator dan Central Blockchain </h2><br><p>  Masalah pertama dengan fakta bahwa setiap beling memiliki validator sendiri adalah bahwa jika kita memiliki 10 shadras, maka setiap beling sekarang 10 kali lebih tidak dapat diandalkan daripada satu blockchain.  Jadi, jika blockchain dengan validator X memutuskan untuk membuat garpu sulit dalam sistem beling dengan 10 pecahan, dan memecah validator X antara 10 beling, sekarang hanya ada validator X / 10 di setiap beling, dan untuk mendapatkan kontrol atas beling memerlukan kontrol lebih dari 5,1% (51). % / 10) validator. </p><br><p>  Yang mengarah ke pertanyaan menarik pertama: siapa yang menugaskan validator ke pecahan?  Memiliki kendali atas 5,1% validator adalah masalah hanya jika semua 5,1% validator berada dalam beling yang sama.  Jika validator sendiri tidak dapat memilih beling mana mereka ditugaskan, mendapatkan kendali atas 5,1% dari validator sebelum mereka ditugaskan ke beling tidak akan memungkinkan mereka untuk mendapatkan kontrol atas beling apa pun. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="gambar"></p><br><p>  Hampir semua rancangan pecahan yang ada menggunakan beberapa sumber nomor acak untuk menetapkan validator ke pecahan.  Memperoleh angka acak dalam sistem terdistribusi di mana peserta tidak percaya satu sama lain bukanlah masalah yang sepenuhnya diselesaikan hari ini, yang tidak akan kita bahas dalam artikel ini, dan anggap saja kita memiliki sumber angka acak seperti itu. </p><br><p>  Baik penerimaan nomor acak dan penunjukan validator adalah perhitungan pada skala sistem yang tidak spesifik untuk pecahan tertentu.  Untuk perhitungan seperti itu, desain blockchain shard modern memiliki blockchain khusus khusus yang ada hanya untuk melakukan perhitungan seluruh sistem.  Selain nomor acak dan penunjukan validator, perhitungan seperti itu mungkin termasuk mendapatkan hash blok terakhir dari pecahan dan menyimpannya;  memproses agunan dalam sistem Bukti-taruhan, dan mempelajari bukti perilaku yang tidak pantas dengan pemilihan agunan yang terkait;  menyeimbangkan pecahan, jika fungsi tersebut disediakan.  Blockchain semacam itu disebut rantai Beacon di Ethereum 2.0 dan Near Protocol, rantai Relay di PolkaDot, dan Cosmos Hub di Cosmos. </p><br><p>  Dalam posting ini kita akan menyebut blockchain tersebut sebagai "central blockchain".  Keberadaan blockchain pusat membawa kita ke topik menarik berikutnya - penguapan kuadratik. </p><br><h2 id="kvadratichnoe-shardirovanie">  Sharding kuadratik </h2><br><p>  Sharding sering disajikan sebagai solusi yang berskala tak terbatas dengan meningkatnya jumlah node.  Mungkin, Anda benar-benar dapat membuat sistem dengan properti ini, tetapi sistem dengan blockchain pusat memiliki batas atas jumlah pecahan, dan akibatnya tidak memiliki skalabilitas yang tak terbatas.  Sangat mudah untuk memahami alasannya: blockchain pusat melakukan beberapa perhitungan, seperti menetapkan validator dan mempertahankan status pecahan terbaru, kompleksitasnya sebanding dengan jumlah pecahan.  Karena blockchain pusat itu sendiri tidak sharded, dan throughputnya dibatasi oleh throughput dari setiap node, jumlah pecahan yang dapat didukungnya terbatas. </p><br><p>  Mari kita lihat bagaimana throughput seluruh sistem berubah jika kekuatan dari node yang mendukungnya meningkat k kali.  Setiap pecahan akan dapat memproses k kali lebih banyak transaksi, dan blockchain pusat akan dapat mendukung k kali lebih banyak pecahan.  Dengan demikian, throughput seluruh sistem akan bertambah 2 kali lipat.  Oleh karena itu nama "sharding kuadratik". </p><br><p>  Sulit untuk memprediksi berapa banyak pecahan yang dapat mendukung blockchain pusat hari ini, tetapi kemungkinan besar dalam waktu dekat kami tidak akan mendekati batas transaksi untuk blockchain yang terbelokkan dengan pecahan kuadratik.  Kemungkinan besar, kami akan segera berlari ke batas berapa banyak node yang diperlukan untuk mendukung jumlah pecahan tersebut. </p><br><h2 id="shardirovanie-sostoyaniya">  Sharding negara </h2><br><p>  Status adalah semua informasi tentang semua akun dan kontrak.  Sejauh ini, kita telah berbicara tentang sharding secara umum, tanpa menentukan apa sebenarnya sharding.  Node dalam blockchain melakukan tiga tugas berikut: 1) melakukan transaksi 2) meneruskan transaksi dan memblokir ke node lain dan 3) menyimpan status dan riwayat blockchain.  Masing-masing dari ketiga tugas ini dikaitkan dengan beberapa peningkatan beban pada node: </p><br><ol><li>  Kebutuhan untuk melakukan transaksi membutuhkan daya komputasi yang lebih besar dengan peningkatan jumlah transaksi; </li><li>  Kebutuhan untuk meneruskan transaksi memerlukan lebih banyak bandwidth jaringan seiring bertumbuhnya transaksi; </li><li>  Kebutuhan untuk mempertahankan status dan riwayat memerlukan lebih banyak ruang disk saat ukuran status dan / atau sejarah meningkat.  Penting untuk dicatat bahwa, tidak seperti dua poin pertama, jumlah ruang disk yang diperlukan tumbuh bahkan jika jumlah transaksi per unit waktu tidak berubah. </li></ol><br><p>  Dari daftar di atas, mungkin tampak bahwa ruang disk adalah masalah terbesar, karena hanya ruang disk tumbuh bahkan jika jumlah transaksi tidak bertambah, tetapi dalam praktiknya tidak.  Saat ini, keadaan Ethereum menempati sekitar 100GB, yang dapat dengan mudah disimpan pada mesin modern mana pun, tetapi jumlah transaksi yang dapat diproses oleh Ethereum terbatas hingga beberapa puluh per detik, bergantung pada daya komputasi dan jaringan. </p><br><p>  Zilliqa adalah proyek paling terkenal yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memanfaatkan komputasi dan jaringan</a> tetapi tidak menyatakannya.  Komputasi sharding lebih sederhana daripada keadaan sharding, karena semua node memiliki semua status, dan masih dapat dengan mudah menjalankan kontrak yang menyebabkan kontrak lain, atau memengaruhi akun pada pecahan yang berbeda.  Dalam aspek-aspek ini, desain Zilliqa terlalu disederhanakan, kritik terhadap desain dalam bahasa Inggris dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Sementara negara sharding tanpa perhitungan shading diusulkan, saya tidak tahu ada proyek yang benar-benar melakukan ini, jadi kami akan menganggap bahwa negara sharding menyiratkan perhitungan sharding. </p><br><p>  Dalam praktiknya, fakta bahwa negara terbelenggu dalam beberapa cara mengisolasi pecahan, memungkinkan mereka untuk menjadi blockchain independen, seperti yang kita definisikan di atas.  Validator di pecahan hanya menyimpan negara yang khusus untuk beling mereka, dan hanya transaksi yang mempengaruhi keadaan ini yang dieksekusi dan diteruskan.  Ini mengurangi beban pada prosesor, disk dan jaringan secara linear dengan jumlah pecahan, tetapi membawa masalah baru, seperti transaksi antar-pecahan. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Transaksi antar-beling </h2><br><p>  Sejauh ini, kami telah melihat pecahan sebagai blockchains independen dalam hal bagaimana mereka melakukan transaksi.  Dengan desain ini, misalnya, tidak mungkin untuk menyelesaikan transaksi yang mentransfer uang antara dua akun di dua pecahan yang berbeda, atau menyebabkan kontak pada satu beling dari kontrak pada yang lain.  Saya ingin mendukung kedua skenario. </p><br><p>  Untuk kesederhanaan, kami hanya akan mempertimbangkan transaksi yang mentransfer uang, dan kami akan menganggap bahwa setiap peserta memiliki akun tepat pada satu beling.  Jika peserta pada beberapa pecahan ingin mentransfer uang ke peserta pada pecahan yang sama, validator pecahan ini dapat memproses transaksi ini dan menerapkannya kepada negara.  Tetapi jika, misalnya, Alice memiliki akun di shard # 1 dan dia ingin mengirim uang ke Bob dengan akun di shard # 2, tidak ada validator shard # 1 (yang tidak dapat menambahkan uang ke Bob) atau validator shard # 2 (yang tidak dapat mengambil uang Alice ) tidak dapat menyelesaikan transaksi dan memperbarui status. </p><br><p>  Ada dua kelompok besar pendekatan untuk memecahkan masalah ini: </p><br><ol><li><p>  <strong>Sinkron</strong> : untuk setiap transaksi yang melibatkan beberapa pecahan, blok dalam pecahan yang berisi pembaruan keadaan untuk transaksi ini diproduksi secara bersamaan, dan validator dalam pecahan ini bekerja bersama untuk membuat blok tersebut.  Desain yang paling rumit dari pendekatan ini, yang saya kenal, adalah Merge Blocks, yang dijelaskan (dalam bahasa Inggris) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br></li><li><p>  <strong>Asynchronous</strong> : transaksi antar-beling dilakukan dalam pecahan yang memengaruhi, asynchronous: bagian dari transaksi yang menambahkan uang ke Bob dieksekusi di beling # 2 ketika validator di beling memiliki beberapa bukti bahwa bagian dari transaksi yang mengurangi uang dari Alice dieksekusi di beling # 1.  Pendekatan ini lebih populer dalam sistem yang dikembangkan saat ini karena fakta bahwa itu tidak memerlukan sinkronisasi tambahan antara pecahan untuk produksi blok.  Sistem seperti ini ditawarkan hari ini di Cosmos, Ethereum Serenity, Near Protocol, Kadena, dan lainnya.  Masalah dengan pendekatan ini adalah bahwa jika blok diproduksi secara independen, ada kemungkinan bahwa salah satu blok yang berisi pembaruan negara untuk transaksi tidak akan berada dalam rantai kanonik di belingnya, dan dengan demikian transaksi hanya akan diselesaikan sebagian.  Sebagai contoh, perhatikan gambar di bawah ini.  Ini menunjukkan dua pecahan di mana garpu terjadi, dan transaksi antar-beling, pembaruan negara yang tercermin dalam blok A dan X ', masing-masing.  Jika rantai AB dan V'-X'-Y'-Z 'berubah menjadi kanonik di pecahannya, maka transaksi sepenuhnya diselesaikan.  Jika rantai A'-B'-C'-D 'dan VX adalah kanonik, maka transaksi sepenuhnya dibatalkan, yang dapat diterima.  Tetapi jika, misalnya, AB dan VX menjadi kanonik, maka satu bagian dari transaksi diselesaikan, dan yang lainnya dibatalkan, dan transaksi tersebut sebagian selesai. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="gambar"></p><br><p>  Skenario yang dijelaskan di atas adalah salah satu masalah besar dalam sharding, di mana semua solusi yang diusulkan tidak optimal.  Kami akan menyentuhnya sedikit di bawah. </p><br><h2 id="plohoe-povedenie">  Perilaku buruk </h2><br><p>  Sekarang setelah kami mengetahui cara kerja blockard chard dan mempelajari konsep blockchain sentral, penunjukan validator, dan transaksi antar-beling, pada akhir artikel ini kita akan melihat topik menarik lainnya: apa yang dapat dilakukan oleh peserta yang mencoba menyerang sistem jika ia berhasil mendapatkan kontrol atas sejumlah besar validator dalam satu beling. </p><br><h3 id="celenapravlennye-forki">  Garpu Bertarget </h3><br><p>  Jika peserta memiliki kontrol yang cukup terhadap beling, ia dapat dengan sengaja membuat garpu.  Untuk membuat garpu, tidak masalah apa konsensus yang digunakan dalam pecahan, khususnya, tidak masalah apakah itu BFT atau tidak, jika sejumlah validator dikontrol oleh penyerang, ia dapat membuat garpu.  Misalnya, tujuan garpu mungkin untuk memutar kembali transaksi yang membayar sesuatu di luar blockchain. </p><br><p>  Dikatakan bahwa mendapatkan kontrol 50% dari beling lebih mudah daripada 50% dari seluruh jaringan (misalnya, karena seorang peserta dapat mencoba untuk meretas atau menyuap validator setelah mereka ditugaskan ke beling).  Menurut definisi, transaksi antar-beling mengubah keadaan di beberapa pecahan.  Perubahan tersebut akan jatuh ke beberapa blok di blockchains dari pecahan yang sesuai.  Diperlukan agar semua blok tersebut difinalisasi (mis., Milik rantai kanonik di pecahannya masing-masing), atau semua tidak boleh difinalisasi (mis., Tidak termasuk dalam rantai kanonik dalam pecahannya).  Karena kami menganggap bahwa beberapa peserta dengan niat buruk dapat, pada prinsipnya, mendapatkan kontrol atas beling, kami tidak dapat berasumsi bahwa garpu tidak akan terjadi bahkan jika konsensus Bizantium tercapai, atau sejumlah besar blok dibangun di atas blok dengan transaksi. </p><br><p>  Masalah ini memiliki banyak solusi, yang paling sederhana adalah kadang-kadang untuk menyimpan hash dari blok terakhir di beling ke blockchain pusat.  Algoritme pemilihan rantai kanonik dalam pecahan kemudian diubah sehingga tidak ada target yang berisi blok terakhir yang disimpan di kanonik blockchain pusat.  Kemudian, untuk benar-benar menghindari situasi ketika transaksi sebagian diselesaikan karena fakta bahwa beberapa blok yang berisi pembaruan keadaan ternyata berada di luar rantai kanonik, Anda dapat mengubah algoritma untuk melakukan transaksi antar-beling sehingga pecahan A tidak menerima bukti transaksi di beling B sampai blok mengandung pembaruan negara untuk transaksi dalam pecahan B tidak disimpan di blockchain pusat. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Membuat blok tidak valid </h3><br><p>  Jika peserta dapat memperoleh kontrol atas sejumlah besar validator di beling, ia dapat mencoba membuat blok yang benar-benar tidak valid.  Misalnya, anggap bahwa sebelum blok, negara adalah sedemikian rupa sehingga Alice memiliki 10 token, dan di Bob - 0, blok hanya berisi satu transaksi, yang mengirim 10 token dari akun Alice ke akun Bob, tetapi di negara baru itu mencerminkan 0 token dari Alice, dan 1000 dengan Bob. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="gambar"></p><br><p>  Dalam blockchain klasik, non-sharded, membuat blok seperti itu tidak mungkin, karena semua peserta, seperti mereka yang membuat blok dan mereka yang hanya menggunakan blockchain, periksa semua blok dan segera buang semua blok yang mengandung kesalahan tersebut.  Bahkan jika validator yang dikendalikan oleh penyerang dapat membangun rantai lebih cepat, ini tidak akan memungkinkan mereka untuk melewati rantai yang lebih panjang berisi blok yang tidak valid sebagai yang kanonik, karena semua peserta jaringan akan segera membuang blok yang tidak valid, dan setiap blok yang dibangun di atas.  Validator yang jujur â€‹â€‹akan terus membangun di atas blok valid terakhir, dan semua peserta jaringan akan melihat rantai mereka sebagai kanonik. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="gambar"></p><br><p>  Gambar di atas menunjukkan lima validator, tiga di antaranya berada di bawah kendali penyerang.  Mereka menciptakan blok A 'yang tidak valid, dan kemudian melanjutkan untuk membangun rantai di atas.  Dua validator pribadi segera membuang blok A 'sebagai tidak sah dan terus membangun di atas blok valid terakhir yang mereka tahu, sehingga membuat garpu.  Karena ada lebih sedikit validator dalam rantai yang jujur â€‹â€‹daripada yang tidak jujur, rantai mereka lebih pendek.  Namun, di blockchain unsharded klasik, semua peserta dalam sistem memvalidasi semua blok yang mereka lihat.  Dengan demikian, setiap peserta yang menggunakan blockchain akan melihat bahwa A 'tidak valid, buang itu, dan karena itu buang B', C 'dan D' seperti yang dibangun di atas blok yang tidak valid, dan dengan demikian semua peserta akan melihat AB sebagai rantai kanonik. </p><br><p>  Dalam desain beling, tidak ada peserta yang dapat memvalidasi semua blok di semua blockchain.   - ,        ,                ,     - . </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     â€”   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya banyak menulis tentang blockchain dan sharding dalam bahasa Inggris. </font><font style="vertical-align: inherit;">Kami juga secara berkala mewawancarai penulis protokol lain seperti Cosmos dan Solana, menggali lebih dalam rincian teknis. </font><font style="vertical-align: inherit;">Jika Anda tertarik dengan topik ini, Anda dapat mengikuti posting dan video baru dengan berlangganan ke Twitter saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437924/">https://habr.com/ru/post/id437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437912/index.html">Notebook kecil untuk administrator sistem</a></li>
<li><a href="../id437914/index.html">Jaxb (XJC) generasi kelas dari XML Schema (XSD) dengan deskripsi kelas dan lapangan dalam bentuk anotasi. Plugin XJC</a></li>
<li><a href="../id437916/index.html">Berikan pembaca e-book di setiap saku! Tinjau inovasi terbaru dari ONYX BOOX</a></li>
<li><a href="../id437918/index.html">Rekaman video dengan jeda otomatis dikeluarkan oleh perangkat lunak gratis dengan bangunan sepeda</a></li>
<li><a href="../id437922/index.html">Model serangan: di mana ia terutama disalahgunakan dalam pengadaan elektronik dan bagaimana menghadapinya</a></li>
<li><a href="../id437926/index.html">Panduan resmi untuk Blockchain Sharding</a></li>
<li><a href="../id437928/index.html">Cara belajar bahasa Inggris</a></li>
<li><a href="../id437930/index.html">Perlengkapan pencahayaan Combo</a></li>
<li><a href="../id437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../id437934/index.html">Manajemen waktu dalam kehidupan nyata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>