<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 👨🏼‍💻 🛃 Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2 🧜🏻 👨🏾‍💼 👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Im ersten Teil wurde das POCSAG-Messenger-Protokoll betrachtet. Digitale Nachrichten wurden berücksichtigt, jetzt werden wir zu mehr "v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438638/">  Hallo Habr! <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> wurde das POCSAG-Messenger-Protokoll betrachtet.  Digitale Nachrichten wurden berücksichtigt, jetzt werden wir zu mehr "vollwertigen" Nachrichten im ASCII-Format übergehen.  Darüber hinaus ist es interessanter, sie zu dekodieren, weil  Die Ausgabe ist lesbarer Text. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hu/ew/hr/huewhrcwg9oow3xpzglh8skuhqi.jpeg"></div><br>  Für diejenigen, die daran interessiert sind, wie dies funktioniert, weiter unter dem Schnitt. <br><a name="habracut"></a><br><h2>  Signalempfang </h2><br>  Zunächst muss das Signal empfangen werden, für das wir denselben RTL-SDR-Empfänger und dasselbe HDSDR-Programm verwenden.  Wir wissen bereits aus dem ersten Teil, dass Paging-Nachrichten digital sein können (der Inhalt ist nur die Zahlen 0-9, der Buchstabe U ist "ugrent", ein Leerzeichen und ein Paar Klammern) und alphanumerisch, der Inhalt sind vollständige ASCII-Zeichen.  Natürlich kennen wir den Nachrichtentyp nicht im Voraus (es ist immer noch nicht möglich, sie "nach Gehör" zu dekodieren). Daher wählen wir bei der Aufnahme einfach eine Nachricht aus, die authentischer ist. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Das Programm zum Konvertieren einer WAV-Datei in einen Bitstrom wurde bereits berücksichtigt. Zeigen Sie daher sofort das Ergebnis an - die gesamte Paging-Nachricht sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Einige Merkmale sind mit bloßem Auge sofort sichtbar - beispielsweise ist zu erkennen, dass die Startsequenz 01010101010101 zweimal wiederholt wird.  Das heißt,  Diese Nachricht ist nicht nur länger, sondern besteht im Wesentlichen aus zwei zusammengeklebten Nachrichten, die der Standard jedoch nicht verbietet. <br><br><h2>  Dekodierung </h2><br>  Erinnern Sie sich zunächst an den kurzen Inhalt des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teils</a> .  Die Paging-Nachricht beginnt mit einem langen Header 0101010101, gefolgt von einer Folge von "Paketen", die im Bild als Batch1..N angezeigt werden: <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png" alt="Bild"><br><br>  Jedes Paket beginnt mit einer Frame Sync Code-Startsequenz (01111100 ...), gefolgt von 32-Bit-Blöcken.  Jeder Block kann entweder eine Adresse oder einen Nachrichtentext speichern. <br><br>  Das letzte Mal, als wir nur digitale Nachrichten betrachteten, sind wir jetzt an ASCII-Nachrichten interessiert.  Zunächst müssen Sie lernen, wie Sie zwischen ihnen unterscheiden können.  Dazu benötigen wir das Feld „Funktionsbits“. Wenn diese 2 Bits 00 sind, ist die Nachricht digital, wenn 11, dann Text. <br><br>  Wie aus der Abbildung ersichtlich ist, werden dem Nachrichtenfeld 20 Bits zugewiesen, was perfekt in den 5 4-Bit-BCD-Code passt, wenn die Nachricht digital ist.  Wenn es sich bei der Nachricht jedoch um Text handelt, kann nicht viel Text in 20 Bit eingepasst werden, und 20 kann weder durch 7 noch durch 8 geteilt werden. Es kann davon ausgegangen werden, dass die erste Version des Protokolls (und es wurde bereits 1982 erstellt) nur digitale Nachrichten unterstützt ( <s>ja und es ist unwahrscheinlich, dass die ersten Pager dieser Jahre auf Nixie-Röhren mehr anzeigen konnten</s> ), und erst dann wurde in der nächsten Version die Unterstützung für ASCII hinzugefügt.  Aber seitdem  Es war nicht mehr möglich, den Formatstandard zu verletzen, es war einfacher - der Bitstrom wird einfach so wie er ist kombiniert (20 Bits werden aus jeder Nachricht extrahiert und am Ende des Puffers hinzugefügt), und erst dann wird all dies in Zeichen decodiert. <br><br>  Betrachten Sie einen Block einer empfangenen Nachricht (zur Verdeutlichung werden Leerzeichen hinzugefügt): <br><br><pre><code class="plaintext hljs">0 0001010011100010111111110010010 1 00010100000110110011 11100111001 1 01011010011001110100 01111011100 1 11010001110110100100 11011000100 1 11000001101000110100 10011110111 1 11100000010100011011 11101110000 1 00110010111011001101 10011011010 1 00011001011100010110 10011000010 1 10101100000010010101 10110000101 1 00010110111011001101 00000011011 1 10100101000000101000 11001010100 1 00111101010101101100 11011111010</code> </pre> <br>  In der ersten Zeile zeigt "0" im ersten Bit an, dass dies ein Adressfeld ist, und "11" in den Bits 20-21 zeigt an, dass diese Nachricht symbolisch ist.  Nehmen Sie als nächstes einfach 20 Bits aus jeder Zeile und addieren Sie sie. <br><br>  Wir erhalten die folgende Bitfolge: <br><br><pre> <code class="plaintext hljs">00010100000110110011010110100110011101001101000111011010010011000001101000 11010011100000010100011011001100101110110011010001100101110001011010101100 000010010101000101101110110011011010010100000010100000111101010101101</code> </pre> <br>  Das POCSAG-Protokoll verwendet 7-Bit-ASCII. Teilen Sie die Zeile also einfach in Blöcke mit 7 Bit auf: <br><br><pre> <code class="plaintext hljs">0001010 0000110 1100110 1011010 0110011 1010011 ...</code> </pre> <br>  Wir versuchen, Zeichencodes zu dekodieren (die ASCII-Tabelle wird im Internet leicht gegoogelt), und ... wir bekommen Müll an der Ausgabe.  Öffnen Sie erneut die Dokumentation und suchen Sie den subtilen Satz "ASCII-Zeichen werden von links nach rechts platziert (MSB zu LSB).  Das LSB sendet zuerst. "  Das heißt,  Zuerst wird das niederwertige Bit und dann das höherwertige Bit übertragen. Für die korrekte Decodierung von ASCII-Codes müssen 7-Bit-Zeichenfolgen umgedreht werden. <br><br>  Um dies nicht manuell zu tun, schreiben wir Python-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Als Ergebnis erhalten wir die folgende Sequenz (Bits, Zeichencodes und die Zeichen selbst): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Kombinieren Sie die Zeichen und erhalten Sie die Zeile: "(03-feb-2019 13:31:45 * 476) AWZ".  Wie zu Beginn des Artikels versprochen, ist der Text gut lesbar. <br><br>  Ein weiterer interessanter Punkt ist übrigens, dass das Protokoll, wie Sie sehen, 7-Bit-ASCII verwendet.  Kyrillische Zeichen passen nicht in diesen Bereich, daher bleibt die Frage offen, wie Pager die russische Sprache blitzten.  Wenn jemand weiß, schreibe in die Kommentare. <br><br><h2>  Schlussfolgerungen </h2><br>  Natürlich ist das Protokoll nicht vollständig verstanden, aber der interessanteste Teil wurde erledigt, und dann bleibt die Routine, die nicht mehr so ​​interessant ist.  Zumindest gibt es keine Dekodierung von Empfängeradressen (Capcodes), und die Unterstützung für den Fehlerkorrekturcode (BCH Check Bits) ist nicht implementiert - dies würde die Korrektur von bis zu 2 "verdorbenen" Bits während der Übertragung ermöglichen.  Das Ziel war jedoch nicht, einen vollwertigen Decoder herzustellen - es gibt bereits solche Decoder, und ein weiterer wird kaum benötigt. <br><br>  Diejenigen, die versuchen möchten, Nachrichten mit rtl-sdr zu dekodieren, können dies selbst mit dem kostenlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDW-</a> Programm tun.  Es ist keine Installation erforderlich. Nach dem Start muss der HDSDR-Ausgang mit dem Programm Virtual Audio Cable auf den PDW-Eingang umgeleitet und in den PDW-Audioeinstellungen das entsprechende Gerät ausgewählt werden. <br><br>  Das Ergebnis des Programms sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  Zu diesem Thema können Paging-Nachrichten als geschlossen betrachtet werden.  Diejenigen, die das Thema genauer untersuchen möchten, können die Quellcodes des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multimon-ng-</a> Programms studieren, das viele Protokolle, einschließlich POCSAG und FLEX, decodieren kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438638/">https://habr.com/ru/post/de438638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438628/index.html">Benachrichtigung über den Status der Änderung der SharedState-Komponente</a></li>
<li><a href="../de438630/index.html">Google+ Sic Transit Gloria Mundi ...</a></li>
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In Büros ist es entweder zu heiß oder zu kalt: Gibt es eine bessere Möglichkeit, die Temperatur anzupassen?</a></li>
<li><a href="../de438636/index.html">Fehlerhafte Einbettung von Funktionen in Go</a></li>
<li><a href="../de438640/index.html">Offene elektronische Hochgeschwindigkeitswährung</a></li>
<li><a href="../de438642/index.html">Die Grundlagen der reaktiven Programmierung mit RxJS</a></li>
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen für maschinelles Lernen. Schützen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de438648/index.html">Vergleich von BI-Systemen (Tableau, Power BI, Oracle, Qlik)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>