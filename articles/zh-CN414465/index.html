<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍮 🛳️ ▫️ Meta Crush Saga：编译时游戏 📷 👨‍🌾 🏨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="去年，在获得期待已久的Lead C ++ Over-Engineer头衔的过程中，我决定使用现代C ++（C ++ 17）的精髓重写我在工作时间内开发的游戏（Candy Crush Saga）。 因此， Meta Crush Saga诞生了：一种在编译阶段运行的游戏 。 马特·伯纳（Matt Bir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga：编译时游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="图片"></div><br> 去年，在获得期待已久的<strong>Lead C ++ Over-Engineer</strong>头衔的过程中，我决定使用现代C ++（C ++ 17）的精髓重写我在工作时间内开发的游戏（Candy Crush Saga）。 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Meta Crush Saga</a>诞生了：一种<strong>在编译阶段运行</strong>的<strong>游戏</strong> 。 马特·伯纳（Matt Birner）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nibbler</a>游戏给我很大的启发，该游戏在模板上使用纯元编程，以诺基亚3310重现著名的Snake。 <br><br>  “ <strong>它在编译阶段正在运行</strong>哪种<strong>游戏</strong> ？”，“它看起来如何？”，“在该项目中您使用了<strong>C ++ 17的</strong>哪些功能？”，“您学到了什么？”  -您可能会想到类似的问题。 要回答这些问题，您要么必须阅读整个帖子，要么忍受内心的懒惰，并观看该帖子的视频版本-我在斯德哥尔摩的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Meetup活动</a>中的报告： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 注意：为了您的心理健康，并且由于<em>人道的错误</em> ，本文提供了一些替代事实。 <br><a name="habracut"></a><br><h2> 一个在编译时运行的游戏？ </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br> 我认为，为了理解<strong>在编译阶段执行</strong>的<strong>游戏</strong>的“概念”的含义，您需要将此类游戏的生命周期与普通游戏的生命周期进行比较。 <br><br><h3> 常规游戏的生命周期： </h3><br> 作为具有正常生活的游戏的常规开发者，以正常的心理健康水平从事常规工作，您通常首先以自己喜欢的语言（当然是C ++）编写<strong>游戏逻辑</strong> ，然后运行<strong>编译器</strong>将其转换，就像意大利面条一样<strong>可执行文件中的</strong>逻辑。 双击<strong>可执行文件</strong> （或从控制台开始）后，操作系统会产生一个<strong>进程</strong> 。 此<strong>过程</strong>将执行<strong>游戏逻辑</strong> ，该<strong>逻辑</strong>由99.42％的<strong>游戏周期</strong>组成。  <strong>游戏周期</strong>根据某些规则和<strong>用户输入来</strong> <strong>更新</strong>游戏状态，一次又一次，一次又一次地<strong>渲染</strong>新计算出的游戏状态。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3> 在编译过程中运行的游戏的生命周期： </h3><br> 作为创建新的酷炫编译游戏的过度工程师，您仍然可以使用自己喜欢的语言（当然，还是C ++！）来编写<strong>游戏逻辑</strong> 。 然后，和以前一样， <strong>编译阶段</strong>继续<strong>进行</strong> ，但是有一个图样折衷：您在编译阶段<strong>执行</strong> <strong>游戏逻辑</strong> 。 您可以将其称为“执行”（编译）。 在这里，C ++非常有用。 它具有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板元编程（TMP）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">constexpr之类的功能</a> ，可让您在<strong>编译阶段</strong>执行<strong>计算</strong> 。 稍后我们将考虑可用于此目的的功能。 由于在此阶段我们执行游戏的<strong>逻辑</strong> ，因此在这一刻，我们还需要插入<strong>玩家的输入</strong> 。 显然，我们的编译器仍会在输出中创建一个<strong>可执行文件</strong> 。 它可以用来做什么？ 可执行文件将不再包含<strong>游戏循环</strong> ，但其任务非常简单：显示新的<strong>计算状态</strong> 。 让我们将此<strong>可执行文件称为</strong> <strong>渲染器</strong> ，然后<strong>渲染</strong> <strong>其</strong> <strong>渲染</strong> <strong>的数据</strong> 。 在我们的<strong>渲染中，</strong>不会包含美丽的粒子效果或环境光遮蔽阴影，而是ASCII。 新计算<strong>状态的</strong> ASCII <strong>呈现</strong>是一种方便的属性，可以很容易地向播放器演示，但是我们还将其复制到文本文件中。 为什么是文本文件？ 显然，因为它可以以某种方式与<strong>代码</strong>结合并重新执行所有前面的步骤，从而获得一个<strong>循环</strong> 。 <br><br> 如您所知， <strong>在编译过程</strong>中<strong>执行</strong>的游戏包含一个<strong>游戏周期</strong> ，其中<strong>游戏的</strong>每个<strong>帧</strong>都是一个<strong>编译阶段</strong> 。  <strong>编译的</strong>每个<strong>阶段都会</strong>计算出游戏的新<strong>状态</strong> ，可以将其显示给玩家并插入下一<strong>帧</strong> / <strong>编译阶段</strong> 。 <br><br> 您可以随心所欲地构思一下这个宏伟的图表，直到了解我刚刚写的内容： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br> 在我们详细介绍实现这种循环的细节之前，我确定您想问我唯一的问题... <br><br><h3>  “为什么要这么做？” </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br> 您是否真的认为破坏我的C ++元编程田园诗是一个基本问题？ 是的，一辈子都没有！ <br><br><ul><li> 首先也是最重要的一点是<strong>，在编译阶段执行的游戏</strong>将具有惊人的执行速度，因为大部分计算是在<strong>编译阶段</strong>执行的。 运行速度是使用ASCII图形的AAA游戏成功的关键！ </li><li> 您可以减少一些甲壳类动物出现在您的存储库中的可能性，并要求您用<strong>Rust</strong>重写游戏。 一旦您向他解释编译时就不会存在无效的指针，那么他准备充分的演讲就会崩溃。  <strong>Haskell</strong>自信的程序员甚至可以在您的代码中确认<strong>类型安全性</strong> 。 </li><li> 您将赢得<strong>Javascript</strong>时髦王国的尊重，只要重新命名的框架带有很酷的名字，任何具有强烈NIH综合症的经过重新设计的框架都可以统治该框架。 </li><li> 我的一个朋友曾经说过，实际上任何行的Perl代码都可以用作非常强大的密码。 我确信他从来没有尝试过用<strong>C ++编译时</strong>生成密码。 </li></ul><br> 怎么了 您对我的回答满意吗？ 那么也许您的问题应该是：“您甚至如何做到这一点？” <br><br> 实际上，我真的很想尝试<strong>C ++ 17中</strong>添加的功能。 它的许多功能旨在提高语言的有效性以及元编程（主要是constexpr）。 我认为，与其编写小的​​代码示例，不如将所有这些都变成游戏，将更加有趣。 宠物项目是学习不需要在工作中经常使用的概念的好方法。 再次在编译时执行基本游戏逻辑的能力再次证明模板和constepxr是C ++语言的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图灵完备</a>子集。 <br><br><h2> 元粉碎传奇游戏评论 </h2><br><h3> 三消游戏： </h3><br>  <strong>Meta Crush Saga</strong>是一款类似于<strong>Bejeweled</strong>和<strong>Candy Crush Saga的</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏</a> 。 游戏规则的核心是将具有相同图案的三个图块连接起来以获得得分。 快速浏览一下我“转储” <strong>的游戏状态</strong> （以ASCII转储很容易实现）： <br><br><pre>  R“（
    迷恋传奇      
 ------------------------  
 |  | 
 |  RBGBBYGR | 
 |  | 
 |  | 
 |  YYGRBGBR | 
 |  | 
 |  | 
 |  RBYRGRYG | 
 |  | 
 |  | 
 |  RYBY（R）YGY | 
 |  | 
 |  | 
 |  BGYRYGGR | 
 |  | 
 |  | 
 |  RYBGYBBG | 
 |  | 
 ------------------------  
 &gt;得分：9009
招式：27
 ）“ </pre><br><br> 这款Match-3游戏本身的玩法并不特别有趣，但是，它们都可以在其上运行的架构又如何呢？ 为了让您理解它，我将尝试用代码解释这个<strong>编译期</strong>游戏生命周期的每个部分。 <br><br><h3> 游戏状态注入： </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br> 如果您是一个热情的C ++爱好者或书呆子，您可能已经注意到，以前的游戏状态转储以以下模式开头： <strong>R“（</strong> 。实际上，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始的C ++ 11字符串文字</a> ，这意味着我不需要转义特殊字符，例如， <strong>翻译字符串</strong> ：原始字符串文字存储在名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">current_state.txt</a>的文件中。 <br><br> 我们如何将游戏的当前状态注入编译状态？ 让我们将其添加到循环输入中！ <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br> 无论是<em>.txt</em>文件还是<em>.h</em>文件，C预处理器中的<strong>include</strong>指令都将以相同的方式工作：它将文件的内容复制到其位置。 在这里，我将游戏状态的原始字符串文字（以ascii形式）复制到一个名为<strong>game_state_string</strong>的变量中。 <br><br> 请注意， <a href="">loop_inputs.hpp</a>头<a href="">文件</a>还将键盘输入扩展到当前帧/编译步骤。 与游戏状态不同，键盘的状态非常小，可以很容易地将其作为预处理程序的定义。 <br><br><h3> 在编译时计算新状态： </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br> 现在我们已经收集了足够的数据，我们可以计算新状态。 最后，我们到达了需要编写<a href="">main.cpp</a>文件的地步： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br> 奇怪，但是考虑到它的作用，此C ++代码看起来并不那么混乱。 大多数代码在编译阶段执行，但是它遵循传统的OOP和过程编程范例。 为了在编译时完全执行计算，只有最后一行（渲染）是一个障碍。 正如我们将在下面看到的，在正确的地方扔一些constexpr，我们可以在C ++ 17中获得相当优雅的元编程。 当在运行时和编译时执行混合执行时，C ++给我们带来了自由，这让我感到很高兴。 <br><br> 您还将注意到，此代码仅执行一帧，没有<strong>游戏循环</strong> 。 让我们解决这个问题！ <br><br><h3> 我们将所有内容粘合在一起： </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br> 如果您讨厌<strong>C ++的</strong>技巧，那么希望您不要介意我的<strong>Bash</strong>技能。 实际上，我的<strong>游戏循环不过</strong>是一个不断编译的<a href="">bash脚本</a> 。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br> 实际上，从控制台获取键盘输入时遇到了一些麻烦。 最初，我想与编译并行进行。 经过多次尝试和错误，我设法从<strong>Bash</strong>的<code>read</code>命令中获得或多或少的帮助。 我从不敢与决斗的巫师<strong>Bash</strong>战斗-这种语言太险恶了！ <br><br> 因此，我必须承认，为了管理游戏周期，我不得不求助于另一种语言。 尽管从技术上讲，没有什么阻止我用C ++编写这部分代码。 此外，这并不否认我的游戏90％的逻辑是在<strong>g ++</strong>编译团队内部执行的事实，这真是太了不起了！ <br><br><h3> 一个小游戏，让您休息一下： </h3><br> 既然您已经经历了解释游戏架构的折磨，那么吸引眼球的绘画的时候到了： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br> 这个像素化的gif记录了我如何玩<strong>Meta Crush Saga</strong> 。 如您所见，游戏运行流畅，可以实时播放。 显然，她并没有那么吸引人，我可以流传她的Twitch并成为新的Pewdiepie，但是她可以工作！ <br><br> 在<em>.txt</em>文件中存储<strong>游戏状态</strong>的有趣方面之一是非常方便地作弊或测试极端情况的能力。 <br><br> 现在，我已经向您简要介绍了体系结构，我们将深入研究该项目中使用的C ++ 17功能。 我不会详细考虑游戏逻辑，因为它专门指的是Match-3，而是我将讨论可用于其他项目的C ++方面。 <br><br><h2> 我有关C ++ 17的教程： </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br> 与主要包含次要修复程序的C ++ 14不同，新的C ++ 17标准可以为我们提供很多帮助。 希望最终会出现期待已久的功能（模块，协程，概念……），但是……总的来说……它们并没有出现。 它使我们许多人不高兴。 但是，在消除了哀悼之后，我们发现了许多意外的小型珍宝，但这些珍宝已成为标准品。 <br><br> 我敢说，喜欢元编程的孩子今年太宠坏了！ 现在，对该语言进行了单独的细微更改和添加，使您可以编写在编译时以及运行后非常有效的代码。 <br><br><h3>  Constepxr在所有领域： </h3><br> 正如Ben Dean和Jason Turner在其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关C ++ 14</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告中所</a>预测的那样，C ++使您可以在编译时使用全能关键字<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">constexpr</a>快速改进值的编译。 通过在正确的位置放置此关键字，可以告诉编译器表达式是常量， <strong>可以</strong>在编译时直接<strong>对其</strong>求值。 在<strong>C ++ 11中，</strong>我们已经可以编写以下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br> 尽管<strong>constexpr</strong>关键字功能非常强大，但是它有很多使用限制，因此很难以这种方式编写表达性代码。 <br><br>  <strong>C ++ 14</strong>大大减少了<strong>constexpr</strong>的需求，并且使用起来变得更加自然。 我们以前的阶乘函数可以重写如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong>摆脱了<strong>constexpr函数</strong>应仅包含一个return语句的规则，这迫使我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三元运算符</a>作为主要构造块。 现在， <strong>C ++ 17</strong>带来了更多<strong>constexpr</strong>关键字应用程序，我们可以探索！ <br><br><h4> 在编译时分支： </h4><br> 您是否曾经遇到过根据所使用的模板参数需要采取不同行为的情况？ 假设我们需要一个参数<code>serialize</code>函数<code>serialize</code> ，如果对象提供了该函数，它将调用<code>.serialize()</code> ，否则将诉诸于调用<code>to_string</code> 。 如这篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于SFINAE的文章</a>中更详细地解释的那样，很可能您将不得不编写这样的外来代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br> 只有在梦中，您才能将这个<strong>从SFINAE技巧</strong>到<strong>C ++ 14的</strong>丑陋<strong>技巧</strong>重写为如此宏伟的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br> 不幸的是，当您醒来并开始编写真正的<strong>C ++ 14代码时</strong> ，编译器发出了有关调用<code>serialize(42);</code>的令人不愉快的消息<code>serialize(42);</code>  。 它解释说<code>obj</code>类型为<code>int</code>的<code>obj</code>没有成员函数<code>serialize()</code> 。 不管它如何激怒您，编译器都是正确的！ 使用此代码，他将始终尝试编译两个分支<code>return obj.serialize();</code> 和 <br> <code>return std::to_string(obj);</code>  。 对于<code>int</code>分支， <code>return obj.serialize();</code> 可能是某种<code>has_serialize(obj)</code>代码，因为<code>has_serialize(obj)</code>将始终返回<code>false</code> ，但是编译器仍必须对其进行编译。 <br><br> 您可能已经猜到了， <strong>C ++ 17使</strong>我们摆脱了这种令人不快的情况，因为它使在if语句后添加<strong>constexpr</strong>以在编译时“强制”分支并丢弃未使用的构造成为可能： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br> 显然，这是对我们之前必须应用<strong>的SFINAE技巧</strong>的巨大改进。 此后，我们开始与Ben和Jason一样上瘾-我们开始在所有地方始终使用<strong>constexpr</strong> 。  las，还有另一个适合<strong>constexpr</strong>关键字但尚未使用的地方： <strong>constexpr parameters</strong> 。 <br><br><h4>  Constexpr参数： </h4><br> 如果小心，在前面的代码示例中可能会注意到一个奇怪的模式。 我说的是循环输入： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br> 为什么将变量<strong>game_state_string</strong>封装在constexpr lambda中？ 她为什么不让她成为<strong>全局变量constexpr</strong> ？ <br><br> 我想将此变量及其内容传递给一些函数。 例如， <strong>您</strong>需要将其传递给我的<strong>parse_board</strong>并在某些常量表达式中使用它： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(“...something...”);</span></span></code> </pre> <br> 如果我们采用这种方式，则<strong>脾气暴躁的</strong>编译器将抱怨<strong>game_state_string</strong>参数不是常量表达式。 创建切片数组时，需要直接计算其固定容量（由于需要内存分配，因此无法在编译时使用向量），并将其作为参数传递给<strong>std :: array中</strong>的值模板。 因此， <strong>parse_board_size（game_state_string）</strong>表达式必须是一个常量表达式。 尽管<strong>parse_board_size被</strong>显式标记为<strong>constexpr</strong> ，但<strong>game_state_string</strong>不是，也不能是！ 在这种情况下，有两个规则会干扰我们： <br><br><ul><li>  constexpr函数的参数不是constexpr！ </li><li> 而且我们不能在它们前面添加constexpr！ </li></ul><br> 所有这些归结为一个事实，即<strong>constexpr函数</strong>必须适用于计算运行时和编译时间。 假设存在<strong>constexpr参数</strong> ，则不允许在运行时使用它们。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br> 幸运的是，有一种方法可以解决此问题。 除了将值作为函数的常规参数接受之外，我们可以将此值封装为一个类型并将此类型作为模板参数传递： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br> 在此代码示例中，我将创建一个具有静态成员函数constexpr <strong>value（）</strong>的<strong>GameString</strong>结构类型，该成员函数返回要传递给<strong>parse_board</strong>的字符串文字。 在<strong>parse_board中，</strong>我使用<strong>GameStringType</strong>模板<strong>参数</strong> （使用提取模板参数的规则）获得此类型。 拥有<strong>GameStringType</strong> ，由于<strong>value（）</strong>是constexpr的事实，即使在需要常量表达式的地方，我也可以在适当的时间简单地调用静态成员函数<strong>value（）</strong>以获取字符串文字。 <br><br> 我们设法封装了文字，以便使用constexpr将其传递给<strong>parse_board</strong> 。 但是，每次需要发送新的<strong>parse_board</strong>文字时，都需要定义一个新类型是非常烦人的：“ ... something1 ...”，“ ... something2 ...”。 为了解决<strong>C ++ 11中的</strong>这个问题，您可以使用匿名联合和lambda应用一些丑陋的宏和间接寻址。 迈克尔•帕克（Michael Park）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇帖子中</a>很好地解释了这个话题。 <br><br> 在<strong>C ++ 17中，</strong>情况甚至更好。 如果我们列出了传递字符串文字的要求，则会得到以下信息： <br><br><ul><li> 函数生成 </li><li> 那就是constexpr </li><li> 具有唯一或匿名名称 </li></ul><br> 这些要求应该给您提示。 我们需要的是<strong>constexpr lambda</strong> ！ 在<strong>C ++ 17中，他们</strong>完全自然地增加了将<strong>constexpr关键字</strong>用于lambda函数的功能。 我们可以如下重写示例代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return “...something...”; }); // ^    constexpr.</span></span></code> </pre> <br> 相信我，这已经比以前使用<strong>C ++ 11</strong>使用宏进行黑客攻击更加方便了。 感谢我参与的C ++ mitap小组的成员<strong>Bjorn Fahler</strong> ，我发现了这个很棒的技巧。 在他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客中</a>阅读有关此技巧的更多信息。 同样值得考虑的是，在这种情况下，实际上<strong>constexpr</strong>关键字是可选的：默认情况下，所有具有成为<strong>constexpr</strong>能力的<strong>lambda</strong>都是它们。 显式添加<strong>constexpr</strong>是一种签名，可以简化我们的故障排除。 <br><br> 现在，您必须了解为什么我被迫使用<strong>constexpr</strong> lambda传递代表游戏状态的字符串。 查看此lambda函数，您将再次遇到另一个问题。 我还用来包装股票文字的<strong>constexpr_string</strong>类型是什么？ <br><br><h5>  constexpr_string和constexpr_string_view： </h5><br> 在处理字符串时，您不应以C风格处理它们，您需要忘记所有执行原始迭代并检查零完成的烦人算法！  <strong>C ++</strong>提供的替代方法是万能的<strong>std :: string</strong>和<strong>STL算法</strong> 。 不幸的是， <strong>std :: string</strong>可能需要在堆上分配内存（即使使用Small String Optimization）也要存储其内容。 回到一两个标准，我们可以使用<strong>constexpr new / delete</strong> ，也可以将<strong>constexpr分配器</strong>传递给<strong>std :: string</strong> ，但是现在我们需要找到另一个解决方案。 <br><br> 我的方法是编写一个具有固定容量的<strong>constexpr_string</strong>类。 此容量作为参数传递给值模板。 这是我班的简要概述： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br> 我的<a href="">constexpr_string</a>类试图尽可能地模仿<strong>std :: string</strong>接口（用于我需要的操作）：我们可以请求<strong>开始和结束的迭代器</strong> ，获取<strong>大小（大小）</strong> ，访问<strong>数据（数据）</strong> ， <strong>删除（擦除）其中的</strong>一部分，获取<strong>substr</strong>使用<strong>substr</strong>等。 这<strong>使得</strong>将一段代码从<strong>std :: string转换</strong>为<strong>constexpr_string</strong>非常容易。 您可能想知道当我们需要使用通常需要在<strong>std :: string中</strong>突出显示的操作时会发生什么。 在这种情况下，我被迫将它们转换为创建<strong>constexpr_string</strong>的新实例的<strong>不可变操作</strong> 。 <br><br> 让我们看一下<strong>append</strong>操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br> 您不需要菲尔兹奖就可以假设，如果我们有一个大小为<strong>N</strong>的字符串和一个大小为<strong>M</strong>的字符串，那么大小为<strong>N + M</strong>的字符串就足以存储它们的串联。 我们可能会浪费“编译时存储库”的一部分，因为两条代码行可能都没有使用全部容量，但是为方便起见，这是一个相当小的价格。 显然，我还写了一个<strong>std :: string_view的副本</strong> ，称为<a href="">constexpr_string_view</a> 。 <br><br> 在这两个类中，我准备编写优美的代码来解析我的<strong>游戏状态</strong> 。 想像这样的事情： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(“...something...”); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br> 在运动场上遍历珠宝非常容易-顺便说一句，您在此代码示例中注意到<strong>C ++ 17的</strong>另一个重要功能吗？ <br><br> 是的 在构造它时，我不必显式指定<strong>constexpr_string</strong>的容量。 以前，使用<strong>类模板时</strong> ，我们必须明确指出其参数。 为了避免这些麻烦，我们创建了<em>make_xxx</em>函数，因为可以跟踪<strong>函数模板</strong>的参数。 了解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">跟踪类模板参数</a>如何更好地改变我们的生活： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br> 在某些困难的情况下，您将需要帮助编译器正确地计算参数。 如果遇到此类问题，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用户定义参数计算手册</a> 。 <br><br><h4> 来自STL的免费食物： </h4><br> 好吧，我们总是可以自己重写所有内容。 但是，也许委员会成员已经在标准库中为我们慷慨地准备了一些东西？ <br><br><h5> 新的助手类型： </h5><br> 在<strong>C ++ 17中</strong> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: variant</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: optional被</a>添加到基于<strong>constexpr</strong>的标准字典类型中。 第一个非常有趣，因为它允许我们表达类型安全的关联，但是使用常量表达式时，使用<strong>GCC 7.2</strong>的<strong>libstdc ++库中</strong>的实现存在问题。 因此，我放弃了在代码中添加<strong>std :: variant</strong>的想法，而只使用<strong>std :: optional</strong> 。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于类型</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许我们创建一个新的类型</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以包含类型</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">或不</font><font style="vertical-align: inherit;">包含任何值</font><font style="vertical-align: inherit;">。这与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有意义的类型</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常相似，这些</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">有意义的类型允许</font></a><font style="vertical-align: inherit;">在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃</font></font></strong><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">中使用未定义的值</font></a><font style="vertical-align: inherit;">。让我们看一下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">返回第一个元素在确认谓词正确的字段上的位置。字段上可能没有这样的元素。要处理这种情况，头寸类型必须是可选的：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前，我们不得不求助于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">语义</font></strong><font style="vertical-align: inherit;">，或者直接向位置类型添加“空状态”，或者返回布尔值并采用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出参数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。诚然，这很尴尬！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些预先存在的类型也获得了</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我不会详细解释它们的用法，因为已经有很多关于它们的文章，但是我将分享我的失望之一。该委员会</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">标准中添加了</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法糖</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以提取</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元组</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成对</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">。这种新的声明类型称为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构化绑定</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使用括号指定在其中存储拆分</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元组</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很聪明！</font><font style="vertical-align: inherit;">但是可惜的是，委员会成员[无法，不想，没有找到时间，忘记了]使他们对</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">友好</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我期望这样的事情：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在我们有了复杂的容器和帮助程序类型，但是如何方便地操作它们呢？ </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 算法： </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">升级容器以处理</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一项非常单调的任务。</font><font style="vertical-align: inherit;">与之相比，将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移植</font><font style="vertical-align: inherit;">到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">修改</font></strong><strong><font style="vertical-align: inherit;">算法</font></strong><font style="vertical-align: inherit;">似乎很简单。</font><font style="vertical-align: inherit;">但是很奇怪，在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们没有看到这方面的进展，它只会出现在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，出色的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">未接收</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">签名</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是不要害怕！</font><font style="vertical-align: inherit;">正如Ben和Jason解释的那样，您</font><font style="vertical-align: inherit;">只需复制当前实现</font><font style="vertical-align: inherit;">即可轻松地将算法转换为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（但不要忘记版权）。</font><font style="vertical-align: inherit;">cppreference很好。</font><font style="vertical-align: inherit;">女士们，先生们，我请您注意</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std ::查找</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已经从看台上听到优化迷的尖叫声！</font><font style="vertical-align: inherit;">是的，仅</font><font style="vertical-align: inherit;">在</font><strong><font style="vertical-align: inherit;">cppreference</font></strong><font style="vertical-align: inherit;">提供的示例代码之前</font><font style="vertical-align: inherit;">添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能无法</font><strong><font style="vertical-align: inherit;">在运行时</font></strong><font style="vertical-align: inherit;">提供理想的</font><strong><font style="vertical-align: inherit;">速度</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，如果我们必须改进此算法，则</font><strong><font style="vertical-align: inherit;">在编译时</font></strong><font style="vertical-align: inherit;">为了</font><strong><font style="vertical-align: inherit;">提高速度</font></strong><font style="vertical-align: inherit;">将需要它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">据我所知，谈到</font><strong><font style="vertical-align: inherit;">编译</font></strong><font style="vertical-align: inherit;">速度</font><font style="vertical-align: inherit;">，简单的解决方案是最好的。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 速度和错误： </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 任何AAA游戏的开发人员都应该投资解决这些问题，对吗？ </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 速度： </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我设法创建一个半工作版本的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga时</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，工作进行得更加顺利。实际上，</font><font style="vertical-align: inherit;">我的旧笔记本电脑将i5超频到1.80 GHz（在这种情况下，频率很重要）</font><font style="vertical-align: inherit;">，我设法达到了</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（每秒帧数）以上。像在任何项目中一样，我很快意识到以前编写的代码令人讨厌，并开始使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和标准算法</font><font style="vertical-align: inherit;">来重写游戏状态的解析</font><font style="vertical-align: inherit;">。尽管这使代码的维护更加方便，但是更改严重影响了速度。新的上限为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管关于C ++的说法很老套，但“零头抽象”不适用于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译时计算</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们将编译器视为某些“编译时间代码”的解释器，则这是非常合乎逻辑的。</font><font style="vertical-align: inherit;">仍然可以对各种编译器进行改进，但是对于我们（此类代码的作者）来说，也存在增长的机会。</font><font style="vertical-align: inherit;">这是我发现的观察结果和提示的不完整列表，可能特定于GCC：</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C数组</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更好</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C样式数组</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之上</font><strong><font style="vertical-align: inherit;">的一些</font></strong><font style="vertical-align: inherit;">现代C ++外观，</font><font style="vertical-align: inherit;">因此在这种情况下使用它必须付出一定的代价。</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     «». </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多时候，我的编译器喷出了可怕的编译错误，并且我的代码逻辑遭受了损失。但是，如何找到错误隐藏的地方？没有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试器</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事情将变得更加复杂。如果您的隐喻“程序员的胡须”尚未屈服（我的隐喻和真正的胡须都还远未达到这些期望），那么您可能没有动力使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">templight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或调试编译器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的第一个朋友是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它使我们有机会检查编译时间的布尔值。我们的第二个朋友将是一个</font><font style="vertical-align: inherit;">在可能的情况下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和禁用</font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;">的宏</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用此宏，我们可以使逻辑在运行时工作，这意味着我们可以将调试器附加到该宏。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II-在运行时完全追求游戏性： </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今年不会赢得</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏大奖</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它具有巨大的潜力，但是游戏性</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编译时</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并未完全执行</font><font style="vertical-align: inherit;">。这可能会使铁杆游戏玩家感到烦恼……除非有人</font><font style="vertical-align: inherit;">在编译阶段</font><font style="vertical-align: inherit;">添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键盘输入</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和不洁的逻辑，</font><font style="vertical-align: inherit;">否则我无法摆脱bash脚本</font><font style="vertical-align: inherit;">的困扰（坦白地说，这很疯狂！）。但是我相信有一天我将能够完全放弃</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染器</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可执行文件，</font><font style="vertical-align: inherit;">并</font><font style="vertical-align: inherit;">在</font><strong><font style="vertical-align: inherit;">编译时</font></strong><font style="vertical-align: inherit;">显示</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疯狂男子与化名</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC的扩展</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，添加到语言结构</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此构造应采用多个常量表达式或字符串文字，并在编译阶段将其输出。如果将这样的工具添加到标准中，或者至少将其扩展为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其</font><strong><font style="vertical-align: inherit;">接受</font></strong><font style="vertical-align: inherit;">常量表达式，</font><font style="vertical-align: inherit;">我将感到高兴</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17中，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能有一种方法可以实现此结果。编译器已经输出了两件事- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！如果我们能够以某种方式管理或更改</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以适应我们的需求，我们将已经收到一个有价值的结论。我尝试了几种解决方案，特别是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不推荐使用的属性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然输出显然存在并且可以解析，但是不幸的是，代码无法播放！</font><font style="vertical-align: inherit;">如果纯属巧合，如果您是可以在编译期间执行输出的C ++程序员秘密协会的成员，那么我将很乐意邀请​​您加入我们的团队来创建完美的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结论： </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我最终把我的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诈骗</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏</font><font style="vertical-align: inherit;">卖给了你</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">希望您对此文章感到好奇，并在阅读过程中学到一些新东西。</font><font style="vertical-align: inherit;">如果您发现错误或改进文章的方法，请与我联系。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我要感谢</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwedenCpp团队让</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在他们的活动之一中进行项目报告。</font><font style="vertical-align: inherit;">此外，我还要感谢</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Gurdeev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，他帮助我改善了</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的重要方面</font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414465/">https://habr.com/ru/post/zh-CN414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414451/index.html">6月的“测试者日历”。 测试人员必须抓住错误，阅读Caner并组织迁移。</a></li>
<li><a href="../zh-CN414453/index.html">使用NavMesh为AI代理实施路径查找器</a></li>
<li><a href="../zh-CN414455/index.html">调色板生成算法</a></li>
<li><a href="../zh-CN414459/index.html">FAST，BRIEF，ORB奇异点的检测器和描述符</a></li>
<li><a href="../zh-CN414463/index.html">AI本身学会了如何构建魔方</a></li>
<li><a href="../zh-CN414467/index.html">明斯克C ++会议CoreHard 2018春季论文</a></li>
<li><a href="../zh-CN414469/index.html">安全周22：两秒钟的智能锁</a></li>
<li><a href="../zh-CN414471/index.html">缺乏新工作经验的人的11个地狱</a></li>
<li><a href="../zh-CN414473/index.html">忍者DVR：Neoline G-Tech X27 Dual评测</a></li>
<li><a href="../zh-CN414475/index.html">“最终用户-我们与您同在”：关于CFT中的Android开发</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>