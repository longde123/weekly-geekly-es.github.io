<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß üòä ü§ûüèæ Initialisierung in modernem C ++ üî¥ üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist bekannt, dass die Initialisierungssemantik einer der komplexesten Teile von C ++ ist. Es gibt viele Arten der Initialisierung, die durch unters...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Initialisierung in modernem C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469465/"><p><img src="https://habrastorage.org/webt/fy/g7/eb/fyg7ebgmdmbykh6evie2r7gx-zc.jpeg"></p><br><p>  Es ist bekannt, dass die Initialisierungssemantik einer der komplexesten Teile von C ++ ist.  Es gibt viele Arten der Initialisierung, die durch unterschiedliche Syntax beschrieben werden, und alle interagieren auf komplexe und herausfordernde Weise.  C ++ 11 brachte das Konzept der "universellen Initialisierung".  Leider f√ºhrte sie noch komplexere Regeln ein, die wiederum in C ++ 14, C ++ 17 blockiert und in C ++ 20 erneut ge√§ndert wurden. </p><br><p>  Unter dem Schnitt - Video und √úbersetzung von Timur Doumlers Bericht von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russia</a> Konferenz.  Timur fasst zun√§chst die historischen Ergebnisse der Entwicklung der Initialisierung in C ++ zusammen, gibt einen systematischen √úberblick √ºber die aktuelle Version der Initialisierungsregel, typische Probleme und √úberraschungen, erkl√§rt, wie all diese Regeln effektiv verwendet werden k√∂nnen, und spricht schlie√ülich √ºber neue Vorschl√§ge im Standard, die eine Initialisierungssemantik erm√∂glichen C ++ 20 ist etwas praktischer.  Weiter ist die Geschichte in seinem Namen. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Inhaltsverzeichnis</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardinitialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kopierinitialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aggregierte Initialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Initialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Direkte Initialisierung (C ++ 98)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wertinitialisierung (C ++ 03)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Universelle Initialisierung (C ++ 11)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbesserungen in C ++ 14</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So initialisieren Sie korrekt in C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugewiesene Initialisierung (C ++ 20)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korrekturen in C ++ 20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Direkte Initialisierung von Aggregattypen (C ++ 20)</a> </li></ul><br><p><img src="https://habrastorage.org/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif"></p><br><p>  Das GIF, das Sie jetzt sehen, vermittelt die Hauptbotschaft des Berichts sehr gut.  Ich habe es vor ungef√§hr sechs Monaten im Internet gefunden und auf meinem Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gepostet</a> .  In den Kommentaren zu ihr sagte jemand, dass drei weitere Arten der Initialisierung fehlen.  Es begann eine Diskussion, in der ich eingeladen wurde, dar√ºber zu berichten.  Und so fing alles an. </p><br><p>  √úber die Initialisierung hat Nikolay Yossutis bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berichtet</a> .  Sein Bericht enthielt eine Folie mit 19 verschiedenen M√∂glichkeiten zum Initialisieren eines int: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-comment"><span class="hljs-comment">//undefined value int i2 = 42; //note: inits with 42 int i3(42); //inits with 42 int i4 = int(); //inits with 42 int i5{42}; //inits with 42 int i6 = {42}; //inits with 42 int i7{}; //inits with 0 int i8 = {}; //inits with 0 auto i9 = 42; //inits with 42 auto i10{42}; //C++11: std::initializer_list&lt;int&gt;, C++14: int auto i11 = {42}; //inits std::initializer_list&lt;int&gt; with 42 auto i12 = int{42}; //inits int with 42 int i13(); //declares a function int i14(7, 9); //compile-time error int i15 = (7, 9); //OK, inits int with 9 (comma operator) int i16 = int(7, 9); //compile-time error int i17(7, 9); //compile-time error auto i18 = (7, 9); //OK, inits int with 9 (comma operator) auto i19 = int(7, 9); //compile-time error</span></span></code> </pre> <br><p>  Es scheint mir, dass dies eine einzigartige Situation f√ºr eine Programmiersprache ist.  Das Initialisieren einer Variablen ist eine der einfachsten Aktionen, aber in C ++ ist dies √ºberhaupt nicht einfach.  Es ist unwahrscheinlich, dass diese Sprache einen anderen Bereich hat, in dem in den letzten Jahren ebenso viele Berichte √ºber Abweichungen vom Standard, Korrekturen und √Ñnderungen vorliegen w√ºrden.  Die Initialisierungsregeln √§ndern sich von Standard zu Standard, und im Internet gibt es unz√§hlige Beitr√§ge zum Initialisieren in C ++.  Eine systematische √úberpr√ºfung ist daher keine triviale Aufgabe. </p><br><p>  Ich werde das Material in chronologischer Reihenfolge pr√§sentieren: Zuerst werden wir dar√ºber sprechen, was von C geerbt wurde, dann √ºber C ++ 98, dann √ºber C ++ 03, C ++ 11, C ++ 14 und C ++ 17.  Wir werden h√§ufige Fehler diskutieren und meine Empfehlungen zur ordnungsgem√§√üen Initialisierung geben.  Ich werde auch √ºber Innovationen in C ++ 20 sprechen.  Eine √úbersichtstabelle wird ganz am Ende des Berichts angezeigt. </p><br><a name="a1"></a><br><h1 id="inicializaciya-po-umolchaniyu-s">  Standardinitialisierung (C) </h1><br><p>  In C ++ werden viele Dinge von C geerbt, deshalb werden wir damit beginnen.  Es gibt verschiedene M√∂glichkeiten, Variablen in C zu initialisieren.  Sie werden m√∂glicherweise √ºberhaupt nicht initialisiert. Dies wird als <em>Standardinitialisierung bezeichnet</em> .  Meiner Meinung nach ist dies ein ungl√ºcklicher Name.  Tatsache ist, dass keiner Variablen ein Standardwert zugewiesen wird, sondern einfach nicht initialisiert wird.  Wenn Sie sich in C ++ und C einer nicht initialisierten Variablen zuwenden, erhalten Sie ein undefiniertes Verhalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-comment"><span class="hljs-comment">// undefined behaviour }</span></span></code> </pre> <br><p>  Gleiches gilt f√ºr benutzerdefinierte Typen: Wenn in einer <code>struct</code> nicht initialisierte Felder vorhanden sind, tritt beim Zugriff auf diese Felder auch undefiniertes Verhalten auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.i; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  C ++ wurden viele neue Konstrukte hinzugef√ºgt: Klassen, Konstruktoren, √∂ffentliche, private Methoden, aber nichts davon beeinflusst das gerade beschriebene Verhalten.  Wenn ein Element in der Klasse nicht initialisiert ist, tritt beim Zugriff darauf ein undefiniertes Verhalten auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_j</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.get_i(); <span class="hljs-comment"><span class="hljs-comment">// Undefined behaviour! }</span></span></code> </pre> <br><p>  Es gibt keine magische M√∂glichkeit, ein Klassenelement in C ++ standardm√§√üig zu initialisieren.  Dies ist ein interessanter Punkt, und in den ersten Jahren meiner Karriere bei C ++ wusste ich das nicht.  Weder der Compiler noch die IDE, die ich damals benutzte, erinnerten mich in irgendeiner Weise daran.  Meine Kollegen haben diese Funktion bei der √úberpr√ºfung des Codes nicht ber√ºcksichtigt.  Ich bin mir ziemlich sicher, dass mein Code in diesen Jahren einige ziemlich seltsame Fehler enth√§lt.  Mir schien klar, dass Klassen ihre Variablen initialisieren sollten. </p><br><p>  In C ++ 98 k√∂nnen Sie Variablen mithilfe der Member-Initialisiererliste initialisieren.  Eine solche L√∂sung des Problems ist jedoch nicht optimal, da sie in jedem Konstruktor durchgef√ºhrt werden muss, und dies ist leicht zu vergessen.  Dar√ºber hinaus erfolgt die Initialisierung in der Reihenfolge, in der die Variablen deklariert sind, und nicht in der Reihenfolge der Mitgliederinitialisierungsliste: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++98: member initialiser list class Widget { public: Widget() : i(0), j(0) {} // member initialiser list int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i; int j; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  In C ++ 11 wurden direkte Elementinitialisierer hinzugef√ºgt, die viel bequemer zu verwenden sind.  Mit ihnen k√∂nnen Sie alle Variablen gleichzeitig initialisieren. Dies gibt Ihnen die Sicherheit, dass alle Elemente initialisiert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11: default member initialisers class Widget { public: Widget() {} int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i = 0; // default member initialisers int j = 0; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  Meine erste Empfehlung: Verwenden Sie immer DMI (Direct Member Initialisierer), wann immer Sie k√∂nnen.  Sie k√∂nnen sowohl mit integrierten Typen ( <code>float</code> und <code>int</code> ) als auch mit Objekten verwendet werden.  Die Gewohnheit, Elemente zu initialisieren, l√§sst uns dieses Problem bewusster angehen. </p><br><a name="a2"></a><br><h1 id="kopiruyuschaya-inicializaciya-s">  Kopierinitialisierung (C) </h1><br><p>  Die erste von C geerbte Initialisierungsmethode ist also standardm√§√üig die Initialisierung und sollte nicht verwendet werden.  Der zweite Weg ist die <em>Kopierinitialisierung</em> .  In diesem Fall geben wir die Variable und durch das Gleichheitszeichen ihren Wert an: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int main() { int i = 2; }</span></span></code> </pre> <br><p>  Die Kopierinitialisierung wird auch verwendet, wenn ein Argument wertm√§√üig an eine Funktion √ºbergeben wird oder wenn ein Objekt wertm√§√üig von einer Funktion zur√ºckgegeben wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int square(int i) { return i * i; }</span></span></code> </pre> <br><p>  Ein Gleichheitszeichen kann den Eindruck erwecken, dass ein Wert zugewiesen wird, dies ist jedoch nicht der Fall.  Die Kopierinitialisierung ist keine Wertzuweisung.  In diesem Bericht wird nichts √ºber die Aneignung gesagt. </p><br><p>  Eine weitere wichtige Eigenschaft der Kopierinitialisierung: Wenn die Wertetypen nicht √ºbereinstimmen, wird eine Konvertierungssequenz ausgef√ºhrt.  Eine Konvertierungssequenz hat bestimmte Regeln, z. B. ruft sie keine expliziten Konstruktoren auf, da sie keine Konstruktoren transformieren.  Wenn Sie eine Kopierinitialisierung f√ºr ein Objekt durchf√ºhren, dessen Konstruktor als explizit markiert ist, tritt daher ein Kompilierungsfehler auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br><p>  Wenn es einen anderen Konstruktor gibt, der nicht explizit ist, dessen Typ jedoch schlechter ist, wird er von der Kopierinitialisierung aufgerufen, wobei der explizite Konstruktor ignoriert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double)</span></span></code> </pre> <br><a name="a3"></a><br><h1 id="agregatnaya-inicializaciya-s">  Aggregierte Initialisierung (C) </h1><br><p>  Die dritte Art der Initialisierung, √ºber die ich sprechen m√∂chte, ist die <em>aggregierte Initialisierung</em> .  Es wird ausgef√ºhrt, wenn das Array mit einer Reihe von Werten in geschweiften Klammern initialisiert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><p>  Wenn Sie die Gr√∂√üe des Arrays nicht angeben, wird es aus der Anzahl der in Klammern eingeschlossenen Werte abgeleitet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// array size deduction</span></span></code> </pre> <br><p>  Dieselbe Initialisierung wird f√ºr Aggregatklassen verwendet, d. H. Klassen, die nur eine Sammlung √∂ffentlicher Elemente sind (die Definition von Aggregatklassen enth√§lt einige weitere Regeln, auf die wir jetzt jedoch nicht n√§her eingehen werden): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> j; }; Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Diese Syntax funktionierte sogar in C und C ++ 98, und ab C ++ 11 k√∂nnen Sie das Gleichheitszeichen darin √ºberspringen: </p><br><pre> <code class="cpp hljs">Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Die Aggregatinitialisierung verwendet tats√§chlich die Kopierinitialisierung f√ºr jedes Element.  Wenn Sie daher versuchen, die aggregierte Initialisierung (sowohl mit als auch ohne Gleichheitszeichen) f√ºr mehrere Objekte mit expliziten Konstruktoren zu verwenden, wird f√ºr jedes Objekt eine Kopierinitialisierung durchgef√ºhrt, und es tritt ein Kompilierungsfehler auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ERROR Thingy thingy {3, 4}; // ERROR }</span></span></code> </pre> <br><p>  Und wenn es f√ºr diese Objekte einen anderen Konstruktor gibt, der nicht explizit ist, wird er aufgerufen, auch wenn er f√ºr die Eingabe schlechter geeignet ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Thingy thingy {3, 4}; //  Widget(double) }</span></span></code> </pre> <br><p>  Betrachten wir eine weitere Eigenschaft der aggregierten Initialisierung.  Frage: Welchen Wert gibt dieses Programm zur√ºck? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.j; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>  Das stimmt, Null.  Wenn Sie w√§hrend der Aggregatinitialisierung einige Elemente in einem Array von Werten √ºberspringen, werden die entsprechenden Variablen auf Null gesetzt.  Dies ist eine sehr n√ºtzliche Eigenschaft, da es dank dieser Eigenschaft niemals nicht initialisierte Elemente geben kann.  Es funktioniert mit Aggregatklassen und mit Arrays: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int[100] = {};</span></span></code> </pre> </div></div><br><p>  Eine weitere wichtige Eigenschaft der Aggregatinitialisierung ist das Weglassen von Klammern (Klammerelision).  Welchen Wert gibt dieses Programm Ihrer Meinung nach zur√ºck?  Es hat ein <code>Widget</code> , das aus zwei <code>int</code> Werten besteht, und <code>Thingy</code> , ein Aggregat aus <code>Widget</code> und <code>int</code> .  Was erhalten wir, wenn wir zwei Initialisierungswerte √ºbergeben: <code>{1, 2}</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy t = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tk; <span class="hljs-comment"><span class="hljs-comment">//   ? }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>  Die Antwort ist Null.  Hier handelt es sich um ein Unteraggregat, dh um eine verschachtelte Aggregatklasse.  Solche Klassen k√∂nnen mit verschachtelten Klammern initialisiert werden. Sie k√∂nnen jedoch eines dieser Klammerpaare √ºberspringen.  In diesem Fall wird eine rekursive Durchquerung des Unteraggregats durchgef√ºhrt, und <code>{1, 2}</code> stellt sich als √§quivalent zu <code>{{1, 2}, 0}</code> .  Zugegeben, diese Eigenschaft ist nicht ganz offensichtlich. </p></div></div><br><a name="a4"></a><br><h1 id="staticheskaya-inicializaciya-s">  Statische Initialisierung (C) </h1><br><p>  Schlie√ülich wird die <em>statische Initialisierung</em> auch von C geerbt: Statische Variablen werden immer initialisiert.  Dies kann auf verschiedene Arten erfolgen.  Eine statische Variable kann mit einem konstanten Ausdruck initialisiert werden.  In diesem Fall erfolgt die Initialisierung zur Kompilierungszeit.  Wenn Sie der Variablen keinen Wert zuweisen, wird sie auf Null initialisiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   statit int j; //   int main() { return i + j; }</span></span></code> </pre> <br><p>  Dieses Programm gibt 3 zur√ºck, obwohl <code>j</code> nicht initialisiert ist.  Wenn die Variable nicht durch eine Konstante, sondern durch ein Objekt initialisiert wird, k√∂nnen Probleme auftreten. </p><br><p>  Hier ist ein Beispiel aus einer realen Bibliothek, an der ich gearbeitet habe: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Colour red = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p>  Es gab eine Farbklasse, und die Prim√§rfarben (rot, gr√ºn, blau) wurden als statische Objekte definiert.  Dies ist eine g√ºltige Aktion, aber sobald ein anderes statisches Objekt in dem Initialisierer erscheint, dessen <code>red</code> verwendet wird, tritt Unsicherheit auf, da es keine starre Reihenfolge gibt, in der die Variablen initialisiert werden.  Ihre Anwendung kann auf eine nicht initialisierte Variable zugreifen und st√ºrzt dann ab.  Gl√ºcklicherweise wurde es in C ++ 11 m√∂glich, den Konstruktor <code>constexpr</code> verwenden, und dann haben wir es mit st√§ndiger Initialisierung zu tun.  In diesem Fall gibt es keine Probleme mit der Initialisierungsreihenfolge. </p><br><p>  Daher werden vier Arten der Initialisierung von der C-Sprache geerbt: Standardinitialisierung, Kopieren, Aggregieren und statische Initialisierung. </p><br><a name="a5"></a><br><h1 id="pryamaya-inicializaciya-s98">  Direkte Initialisierung (C ++ 98) </h1><br><p>  Fahren wir mit C ++ 98 fort.  Das vielleicht wichtigste Merkmal, das C ++ von C unterscheidet, sind die Konstruktoren.  Hier ist ein Beispiel f√ºr einen Konstruktoraufruf: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  Mit derselben Syntax k√∂nnen Sie integrierte Typen wie <code>int</code> und <code>float</code> initialisieren.  Diese Syntax wird als <em>direkte Initialisierung bezeichnet</em> .  Es wird immer ausgef√ºhrt, wenn wir ein Argument in Klammern haben. </p><br><p>  Bei integrierten Typen ( <code>int</code> , <code>bool</code> , <code>float</code> ) gibt es hier keinen Unterschied zur Kopierinitialisierung.  Wenn es sich um Benutzertypen handelt, k√∂nnen Sie im Gegensatz zur Kopierinitialisierung bei der direkten Initialisierung mehrere Argumente √ºbergeben.  Aus diesem Grund wurde die direkte Initialisierung erfunden. </p><br><p>  Au√üerdem f√ºhrt eine direkte Initialisierung keine Konvertierungssequenz aus.  Stattdessen wird der Konstruktor mit der √úberlastungsaufl√∂sung aufgerufen.  Die direkte Initialisierung hat dieselbe Syntax wie ein Funktionsaufruf und verwendet dieselbe Logik wie andere C ++ - Funktionen. </p><br><p>  In der Situation mit einem expliziten Konstruktor funktioniert die direkte Initialisierung daher einwandfrei, obwohl die Kopierinitialisierung einen Fehler ausl√∂st: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w2(1); //   </span></span></code> </pre> <br><p>  In einer Situation mit zwei Konstruktoren, von denen einer explizit ist und der zweite weniger geeignet ist, wird der erste mit direkter Initialisierung und der zweite mit der Kopie aufgerufen.  In dieser Situation f√ºhrt das √Ñndern der Syntax zu einem Aufruf eines anderen Konstruktors - dies wird h√§ufig vergessen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Widget w2(1); //  Widget(int)</span></span></code> </pre> <br><p>  Die direkte Initialisierung wird immer verwendet, wenn Klammern verwendet werden, einschlie√ülich der Konstruktoraufrufnotation zum Initialisieren eines tempor√§ren Objekts sowie in <code>new</code> Ausdr√ºcken mit einem Initialisierer in Klammern und in <code>cast</code> : </p><br><pre> <code class="cpp hljs">useWidget(Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   auto* widget_ptr = new Widget(2, 3); // new-expression with (args) static_cast&lt;Widget&gt;(thingy); // cast</span></span></code> </pre> <br><p>  Diese Syntax existiert, solange C ++ selbst existiert, und sie hat einen wichtigen Fehler, den Nikolai in seiner Grundsatzrede erw√§hnt hat: <em>die √§rgerlichste Analyse</em> .  Dies bedeutet, dass alles, was der Compiler als Deklaration (Deklaration) lesen kann, genau als Deklaration gelesen wird. </p><br><p>  <code>Thingy</code> Sie sich ein Beispiel vor, in dem es eine <code>Widget</code> Klasse und eine <code>Thingy</code> Klasse sowie einen <code>Thingy</code> Konstruktor gibt, der ein <code>Widget</code> empf√§ngt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Thingy(Widget) {} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Thingy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget())</span></span></span></span>; }</code> </pre> <br><p>  Auf den ersten Blick scheint es, dass bei der Initialisierung von <code>Thingy</code> das erstellte Standard- <code>Widget</code> an dieses √ºbergeben wird, aber tats√§chlich wird die Funktion hier deklariert.  Dieser Code deklariert eine Funktion, die eine andere Funktion als Eingabe empf√§ngt, die nichts als Eingabe empf√§ngt und ein <code>Widget</code> zur√ºckgibt, und die erste Funktion gibt <code>Thingy</code> .  Der Code wird fehlerfrei kompiliert, aber es ist unwahrscheinlich, dass wir nach einem solchen Verhalten gesucht haben. </p><br><a name="a6"></a><br><h1 id="inicializaciya-znacheniem-c03">  Wertinitialisierung (C ++ 03) </h1><br><p>  Fahren wir mit der n√§chsten Version fort - C ++ 03.  Es ist allgemein anerkannt, dass es in dieser Version keine wesentlichen √Ñnderungen gab, dies ist jedoch nicht der Fall.  In C ++ 03 wurde eine Wertinitialisierung angezeigt, in die leere Klammern geschrieben sind: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// UB  C++98, 0   C++03 }</span></span></code> </pre> <br><p>  In C ++ 98 tritt hier ein undefiniertes Verhalten auf, da die Initialisierung standardm√§√üig erfolgt und dieses Programm ab C ++ 03 Null zur√ºckgibt. </p><br><p>  Die Regel lautet: Wenn es einen benutzerdefinierten Standardkonstruktor gibt, ruft die Initialisierung mit einem Wert diesen Konstruktor auf, andernfalls wird Null zur√ºckgegeben. </p><br><p>  Lassen Sie uns die Situation mit dem benutzerdefinierten Konstruktor genauer betrachten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Widget(); <span class="hljs-comment"><span class="hljs-comment">// value initialization } int main() { return get_widget().i; }</span></span></code> </pre> <br><p>  In diesem Programm initialisiert die Funktion den Wert f√ºr das neue <code>Widget</code> und gibt ihn zur√ºck.  Wir rufen diese Funktion auf und greifen auf das Element <code>i</code> des <code>Widget</code> Objekts zu.  Seit C ++ 03 ist der R√ºckgabewert hier Null, da es keinen benutzerdefinierten Standardkonstruktor gibt.  Und wenn ein solcher Konstruktor existiert, aber <code>i</code> nicht initialisiert, erhalten wir undefiniertes Verhalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {} <span class="hljs-comment"><span class="hljs-comment">//   int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //   ,  UB }</span></span></code> </pre> <br><p>  Es ist erw√§hnenswert, dass "benutzerdefiniert" nicht "benutzerdefiniert" bedeutet.  Dies bedeutet, dass der Benutzer den K√∂rper des Konstruktors bereitstellen muss, d. H. Geschweifte Klammern.  Wenn Sie im obigen Beispiel den Konstruktork√∂rper durch <code>= default</code> ersetzen (diese Funktion wurde in C ++ 11 hinzugef√ºgt), √§ndert sich die Bedeutung des Programms.  Jetzt haben wir einen Konstruktor, der vom Benutzer definiert (benutzerdefiniert), aber nicht vom Benutzer bereitgestellt (vom Benutzer bereitgestellt) wird, sodass das Programm Null zur√ºckgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// user-defined,   user-provided int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //  0 }</span></span></code> </pre> <br><p>  Versuchen wir nun <code>Widget() = default</code> aus der Klasse zu verschieben.  Die Bedeutung des Programms hat sich erneut ge√§ndert: <code>Widget() = default</code> wird als vom Benutzer bereitgestellter Konstruktor betrachtet, wenn er sich au√üerhalb der Klasse befindet.  Das Programm gibt wieder undefiniertes Verhalten zur√ºck. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; Widget::Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  user-provided Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //    , UB }</span></span></code> </pre> <br><p>  Es gibt eine bestimmte Logik: Ein au√üerhalb einer Klasse definierter Konstruktor kann sich innerhalb einer anderen √úbersetzungseinheit befinden.  Der Compiler sieht diesen Konstruktor m√∂glicherweise nicht wie in einer anderen <code>.cpp</code> Datei.  Daher kann der Compiler keine Schlussfolgerungen √ºber einen solchen Konstruktor ziehen und einen Konstruktor mit einem Body nicht von einem Konstruktor mit <code>= default</code> . </p><br><a name="a7"></a><br><h1 id="universalnaya-inicializaciya-c11">  Universelle Initialisierung (C ++ 11) </h1><br><p>  Es gab viele sehr wichtige √Ñnderungen in C ++ 11.  Insbesondere wurde eine universelle (einheitliche) Initialisierung eingef√ºhrt, die ich lieber als "Einhorninitialisierung" bezeichne, weil sie einfach magisch ist.  Mal sehen, warum sie aufgetaucht ist. </p><br><p>  Wie Sie bereits bemerkt haben, gibt es in C ++ viele verschiedene Initialisierungssyntaxen mit unterschiedlichem Verhalten.  Die √§rgerliche Analyse in Klammern verursachte viele Unannehmlichkeiten.  Den Entwicklern gefiel auch nicht, dass die aggregierte Initialisierung nur mit Arrays verwendet werden konnte, nicht jedoch mit Containern wie <code>std::vector</code> .  Stattdessen mussten Sie <code>.reserve</code> und <code>.push_back</code> ausf√ºhren oder alle m√∂glichen gruseligen Bibliotheken verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  : std::vector&lt;int&gt; vec = {0, 1, 2, 3, 4}; //   : std::vector&lt;int&gt; vec; vec.reserve(5); vec.push_back(0); vec.push_back(1); vec.push_back(2); vec.push_back(3); vec.push_back(4);</span></span></code> </pre> <br><p>  Die Sch√∂pfer der Sprache versuchten, all diese Probleme zu l√∂sen, indem sie die Syntax mit geschweiften Klammern einf√ºhrten, jedoch ohne Gleichheitszeichen.  Es wurde angenommen, dass dies eine einzige Syntax f√ºr alle Typen ist, in denen geschweifte Klammern verwendet werden und es kein st√∂rendes Analyseproblem gibt.  In den meisten F√§llen erledigt diese Syntax ihre Aufgabe. </p><br><p>  Diese neue Initialisierung wird als <em>Listeninitialisierung</em> bezeichnet und ist in zwei Typen erh√§ltlich: Direkt und Kopieren.  Im ersten Fall werden nur geschweifte Klammern verwendet, im zweiten Fall geschweifte Klammern mit Gleichheitszeichen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// direct-list-initialization Widget widget{1, 2}; // copy-list-initialization Widget widget = {1, 2};</span></span></code> </pre> <br><p>  Die zur Initialisierung verwendete Liste hei√üt <em>Braced-Init-List</em> .  Es ist wichtig, dass diese Liste kein Objekt ist und keinen Typ hat.  Der Wechsel von fr√ºheren Versionen zu C ++ 11 verursacht keine Probleme mit Aggregattypen, daher ist diese √Ñnderung nicht kritisch.  Aber jetzt hat die Liste in geschweiften Klammern neue Funktionen.  Obwohl es keinen Typ hat, kann es versteckt in <code>std::initializer_list</code> konvertiert werden, es ist so ein spezieller neuer Typ.  Und wenn es einen Konstruktor gibt, der <code>std::initializer_list</code> als Eingabe akzeptiert, hei√üt dieser Konstruktor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... vector(std::initializer_list&lt;T&gt; init); //   initializer_list }; std::vector&lt;int&gt; vec{0, 1, 2, 3, 4}; //  ^ </span></span></code> </pre> <br><p>  Es scheint mir, dass <code>std::initializer_list</code> von der Seite des C ++ - Komitees nicht die erfolgreichste L√∂sung war.  Von ihm mehr Schaden als Nutzen. </p><br><p>  Zun√§chst ist <code>std::initializer_list</code> ein Vektor fester Gr√∂√üe mit <code>const</code> Elementen.  Das hei√üt, es ist ein Typ, es hat <code>begin</code> und Endfunktionen, die Iteratoren zur√ºckgeben, es hat einen eigenen Iteratortyp, und um ihn zu verwenden, m√ºssen Sie einen speziellen Header einf√ºgen.  Da die Elemente <code>std::initializer_list</code> <code>const</code> , kann sie nicht verschoben werden. Wenn also <code>T</code> im obigen Code vom Typ move-only ist, wird der Code nicht ausgef√ºhrt. </p><br><p>  Als n√§chstes ist <code>std::initializer_list</code> ein Objekt.  Damit erstellen und √ºbertragen wir tats√§chlich Objekte.  In der Regel kann der Compiler dies optimieren, aber aus semantischer Sicht besch√§ftigen wir uns immer noch mit unn√∂tigen Objekten. </p><br><p>  Vor einigen Monaten gab es auf Twitter eine Umfrage: Wenn Sie in die Vergangenheit reisen und etwas aus C ++ entfernen k√∂nnten, was w√ºrden Sie entfernen?  Vor allem Stimmen haben genau <code>initializer_list</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://twitter.com/shafikyaghmour/status/1058031143935561728</a> </p><br><p>         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   initializer_list</code></a> .         ,     . </p><br><p>  ,    .   ,     <code>initializer_list</code> ,              .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0, 0, 0 std::vector&lt;int&gt; v{3, 0}; //   3, 0</span></span></code> </pre> <br><p>   <code>vector</code>    <code>int</code>    ,    ,      ,   ‚Äî  .       .       ,   <code>initializer_list</code>        , 3  0. </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">48</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" std::string s{48, 'a'}; // "0a"</span></span></code> </pre> <br><p>       48  ¬´¬ª,     ¬´0¬ª.   ,   <code>string</code>    <code>initializer_list</code>  . 48   ,     .  ASCII  48 ‚Äî   ¬´0¬ª.   ,    ,    , <code>int</code>  <code>char</code> .         .    ,       ,   . </p><br><p>       .   ,    ?    ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;{N}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;().size(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>      ,    ‚Äî 3.   <code>string</code>   <code>int</code> ,   1,    <code>std::vector&lt;std::int&gt;</code>   <code>initializer_list</code> .         <code>initializer_list</code> ,   .    <code>string</code>  <code>int</code>  <code>float</code> ,     ,  .      ,     . ,     emplace ,          .  ,     <code>{}</code>    . </p></div></div><br><p>   ,     . </p><br><p>         <br> . <br>    ‚Äî   ( <code>{a}</code> )  <br>   ( <code>= {a}</code> ); <br>      : </p><br><ol><li>  ¬´¬ª   ,   <code>std::initializer_list</code> . <br>         ‚Äî  . </li><li>    ,   <br>   <code>()</code>    . </li></ol><br><p>      . </p><br><p>  1:   <code>= {a}</code> ,      <code>a</code> , <br>     . </p><br><p>  2:   , <code>{}</code> . <br>           ,   <code>initializer_list</code> . <br>     <code>Widget&lt;int&gt; widget{}\</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Typename&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; widget{}; <span class="hljs-comment"><span class="hljs-comment">//    ? }</span></span></code> </pre> <br><p>  ,    ,  <code>initializer_list</code> ,      <code>initializer_list</code>   .        .      ,  ,  <code>initializer_list</code> .     ,   .  ,     . </p><br><p>       <code>{}</code> . , -,  ,   <code>Widget() = default</code>  <code>Widget() {}</code>    ‚Äî     . </p><br><p> <code>Widget() = default</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{}; <span class="hljs-comment"><span class="hljs-comment">//   (),   vexing parse return widget.i; //  0 }</span></span></code> </pre> <br><p> <code>Widget() {}</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {}; <span class="hljs-comment"><span class="hljs-comment">// user-provided  int i; }; int main() { Widget widget{}; //  ,    return widget.i; //  ,  UB }</span></span></code> </pre> <br><p>      :   ,    (narrowing conversions).    <code>int</code>  <code>double</code> ,    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{<span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre> <br><p>    ,       <code>double</code> .   C++11,         ,      .          : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   ++11    C++98/03 }</span></span></code> </pre> <br><p> ,        , ,     ,       (brace elision).   ,       ,   . ,    <code>map</code> .       <code>map</code> ,     ‚Äî  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; my_map {{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>   ,      .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; v1 {<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::vector&lt;std::string&gt; v2 {{"abc", "def"}}; // ??</span></span></code> </pre> <br><p> ,    ,     <code>initializer_list</code> .      <code>initializer_list</code>   ,   , ,     .           ,   .  , . </p><br><p>  <code>initializer_list</code>     ‚Äî  <code>initializer_list</code> ,        .     ,    <code>const char*</code> . ,  <code>string</code>  ,     <code>char</code>    .        .     ,     ,   . </p><br><p> : </p><br><ul><li>       ; </li><li>       . </li></ul><br><p>  .    braced-init-list     .    : </p><br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// copy-list    } void f2(Widget); f2({3, 0}); // copy-list  </span></span></code> </pre> <br><p>     ,    ,    braced-init-list    .    braced-init-list ,       . </p><br><p> ,          .  StackOverflow   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,             . ,      .      ,      ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct A { A() {} A(const A&amp;) {} }; struct B { B(const A&amp;) {} }; void f(const A&amp;) { std::cout &lt;&lt; "A" &lt;&lt; std::endl; } void f(const B&amp;) { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } int main() { A a; f( {a} ); // A f( {{a}} ); // ambiguous f( {{{a}}} ); // B f({{{{a}}}}); // no matching function }</span></span></span></span></code> </pre> <br><a name="a8"></a><br><h1 id="uluchsheniya-v-s14">   ++14 </h1><br><p> ,      C++11 .      ,   ,        .    C++14.      ,    . </p><br><p> ,  ++11       direct member initializers,     .      ,  direct member initializers  .   ++14,      direct member initializers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    C++14</span></span></code> </pre> <br><p>        ,    <code>auto</code> .   ++11  <code>auto</code>  braced-init-list,       <code>std::initializer_list</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int int i(3); // int int i{3}; // int int i = {3}; // int auto i = 3; // int auto i(3); // int auto i{3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt; auto i = {3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p>   :   <code>auto i{3}</code> ,     <code>int</code> ,   <code>std::initializer_list&lt;int&gt;</code> .  ++14   ,  <code>auto i{3}</code>    <code>int</code> .          ,     . , <code>auto i = {3}</code>    <code>std::initializer_list&lt;int&gt;</code> .  ,     :      <code>int</code> ,     ‚Äî <code>initializer_list</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int auto i(3); // int auto i{3}; //  ++14 ‚Äî int,         auto i = {3}; //    std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p> ,  C++14      ,      ,  ,     ,       .   ,     . </p><br><p>     ,  ++14      : </p><br><ul><li><p>   ,   ,  <code>std::initializer_list</code> . </p><br></li><li><p>  <code>std::initializer_list</code>    move-only . </p><br></li><li><p>  c   ,  <code>emplace</code>  <code>make_unique</code>     . </p><br></li><li><p>    ,     : </p><br><ul><li>      ,  -; </li><li>       ; </li><li> auto     . </li></ul><br></li><li><p> ,    ,        . </p><br></li></ul><br><p>   : <code>assert(Widget(2,3))</code> ,  <code>assert(Widget{2,3})</code>  .   ,      ,       ,        .           ,     .    . </p><br><a name="a9"></a><br><h1 id="kak-pravilno-inicializirovat-v-c">     C++ </h1><br><p>       ,      ++. </p><br><p>     <code>int</code>   , . .     ‚Äî      ,          . </p><br><p>      :   ,   ,  <code>std::initializer_list</code> ,   direct member initializers.          ,       . </p><br><p>  ,         √© .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; setPosition(Point{<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget(Widget{});</code> </pre> <br><p>        braced-init-list ‚Äî      . </p><br><pre> <code class="cpp hljs">setPosition({<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget({});</code> </pre> <br><p>      ,       ,    .   ,         ‚Äî  ,       .  ,     ,     ,    ,   ,    .    ,   ,     <code>initializer_list</code> .        :     ,  ,   . </p><br><p>   : </p><br><ul><li><p> <code>= value</code>    </p><br></li><li><p> <code>= {args}</code>  <code>= {}</code> : </p><br><ul><li>    </li><li>    <code>std::initializer_list</code> </li><li>  direct member initialisation (    <code>(args)</code> ) </li></ul><br></li><li><p> <code>{args}</code>  <code>{}</code>     √©  </p><br></li><li><p> <code>(args)</code>    </p><br></li></ul><br><p> ,   <code>(args)</code>     vexing parse.        .    2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   ,          <code>auto</code> .     ,        :   <code>auto i;</code> ‚Äî    .     ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>   ,        .  ,           ,     vexing parse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> thingy = Thingy();</code> </pre> <br><p>      ¬´  auto¬ª (¬´almost always auto¬ª, AAA),   ++11  ++14       , , ,     <code>std::atomic&lt;int&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++11/14:  // std::atomic is neither copyable nor movable</span></span></code> </pre> <br><p>   ,  atomic    .   ,          ,    ,    ,       .  ++17    ,    ,      (guaranteed copy elision): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++17: OK, guaranteed copy elision</span></span></code> </pre> <br><p>        <code>auto</code> .   ‚Äî  direct member initializers.     <code>auto</code>  . </p><br><p>  ++17    CTAD (class template argument deduction). ,              .        .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  CppCon,   CTAD</a> ,       .   ,  ++17   ,    ++11  ++14,   ,       .     ,    , ,   ,      . </p><br><a name="a10"></a><br><h1 id="naznachennaya-inicializaciya-s20">   (++20) </h1><br><p>     ++20,     .  ,  ,          : <em> </em> (designated initialization): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, .c = <span class="hljs-number"><span class="hljs-number">7</span></span>}; };</code> </pre> <br><p>  ,      .         ,      ,      .        ,       .      <code></code>  <code></code> ,  <code>b</code>  . </p><br><p>      ,  ,     ,     .       ,         . </p><br><p>       ,    ,   99,   : </p><br><ul><li><p>       ,         ,   .  ++   ,     ,    .  :: </p><br><pre> <code class="cpp hljs">Widget widget{.c = <span class="hljs-number"><span class="hljs-number">7</span></span>, .a = <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  ,     . </p><br></li><li><p>  ++      ,     <code>{.ce = 7};</code> ,    <code>{.c{.e = 7}}</code> : </p><br><pre> <code class="cpp hljs">Widget widget{.ce = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       ,      ,      : </p><br><pre> <code class="cpp hljs">Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       . , -,   ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>]{.[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li></ul><br><a name="a11"></a><br><h1 id="ispravleniya-v-c20">   C++20 </h1><br><p>      ++20       ,        .     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p1008</a> ). </p><br><p>   ++17    ,    ,        .             ,    ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; Widget widget1; <span class="hljs-comment"><span class="hljs-comment">//  Widget widget2{}; //   C++17,     C++20</span></span></code> </pre> <br><p>    ,       ,      .  ++20   .        ,              .  ,   .       ,    ,     ,   . </p><br><p>         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p1009</a> ). Braced-init-list     <code>new</code> ,   :        ,    ?  ‚Äî ,    : braced-init-list      <code>new</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK double* p = new double[]{1, 2, 3}; //   C++17,   C++20</span></span></code> </pre> <br><p>    ,   ++11  braced-init-list.  ++   .        ,       . </p><br><a name="a12"></a><br><h1 id="pryamaya-inicializaciya-agregatnyh-tipov-c20">     (C++20) </h1><br><p> ,  ++20      .       ,             .  ++20  :         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p0960</a> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   C++20</span></span></code> </pre> <br><p>            .   ,        <code>emplace</code>  <code>make_unique</code> .      .  :   <code>auto</code> ,          : <em>58.11</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>   ,   :   uniform  2.0.     .         ,    , ,  ,           .  ‚Äî  <code>initializer_list</code> :    ,    ,   ‚Äî .    ,    .  ,   -     ,   ‚Äî .       . </p><br><p> ,    .   direct member initializers.   <code>auto</code> .      direct member initializers ‚Äî  ,    .   ,        .         ‚Äî ,     . </p><br><p>    ,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .     ‚Äî  ,   ‚Äî  .     ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b8d/8a2/229/b8d8a2229e93baf65b78f738750ac635.png"></p><br><blockquote>   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++ Russia 2019 Piter</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´Type punning in modern C++¬ª</a> .     ,   ++20,  ,    ,    ¬´¬ª  ++  ,    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469465/">https://habr.com/ru/post/de469465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469455/index.html">Migration von Nginx zu Envoy Proxy</a></li>
<li><a href="../de469457/index.html">Wohin Extravaganza f√ºhrt</a></li>
<li><a href="../de469459/index.html">Anschlie√üen von IoT-Ger√§ten in der Smart City</a></li>
<li><a href="../de469461/index.html">"Zu den Sternen": Anti-Kosmische "Apokalypse heute"</a></li>
<li><a href="../de469463/index.html">Trends und Prognosen in der Verarbeitung nat√ºrlicher Sprache</a></li>
<li><a href="../de469467/index.html">C ++ vs C #</a></li>
<li><a href="../de469471/index.html">"5 Cent", um √ºber Sorten zu sprechen</a></li>
<li><a href="../de469475/index.html">Der Aufstieg und Fall von Flash, dem nervigen Plugin, das das moderne Web gepr√§gt hat</a></li>
<li><a href="../de469477/index.html">Apple ist an der Zeit, den Vergleich von iPad und PC einzustellen</a></li>
<li><a href="../de469479/index.html">Woher kommt die Quantenwahrscheinlichkeit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>