<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 😊 🤞🏾 Initialisierung in modernem C ++ 🔴 👩‍👩‍👦‍👦 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist bekannt, dass die Initialisierungssemantik einer der komplexesten Teile von C ++ ist. Es gibt viele Arten der Initialisierung, die durch unters...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Initialisierung in modernem C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469465/"><p><img src="https://habrastorage.org/webt/fy/g7/eb/fyg7ebgmdmbykh6evie2r7gx-zc.jpeg"></p><br><p>  Es ist bekannt, dass die Initialisierungssemantik einer der komplexesten Teile von C ++ ist.  Es gibt viele Arten der Initialisierung, die durch unterschiedliche Syntax beschrieben werden, und alle interagieren auf komplexe und herausfordernde Weise.  C ++ 11 brachte das Konzept der "universellen Initialisierung".  Leider führte sie noch komplexere Regeln ein, die wiederum in C ++ 14, C ++ 17 blockiert und in C ++ 20 erneut geändert wurden. </p><br><p>  Unter dem Schnitt - Video und Übersetzung von Timur Doumlers Bericht von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russia</a> Konferenz.  Timur fasst zunächst die historischen Ergebnisse der Entwicklung der Initialisierung in C ++ zusammen, gibt einen systematischen Überblick über die aktuelle Version der Initialisierungsregel, typische Probleme und Überraschungen, erklärt, wie all diese Regeln effektiv verwendet werden können, und spricht schließlich über neue Vorschläge im Standard, die eine Initialisierungssemantik ermöglichen C ++ 20 ist etwas praktischer.  Weiter ist die Geschichte in seinem Namen. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Inhaltsverzeichnis</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardinitialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kopierinitialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aggregierte Initialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Initialisierung (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Direkte Initialisierung (C ++ 98)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wertinitialisierung (C ++ 03)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Universelle Initialisierung (C ++ 11)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbesserungen in C ++ 14</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So initialisieren Sie korrekt in C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugewiesene Initialisierung (C ++ 20)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korrekturen in C ++ 20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Direkte Initialisierung von Aggregattypen (C ++ 20)</a> </li></ul><br><p><img src="https://habrastorage.org/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif"></p><br><p>  Das GIF, das Sie jetzt sehen, vermittelt die Hauptbotschaft des Berichts sehr gut.  Ich habe es vor ungefähr sechs Monaten im Internet gefunden und auf meinem Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gepostet</a> .  In den Kommentaren zu ihr sagte jemand, dass drei weitere Arten der Initialisierung fehlen.  Es begann eine Diskussion, in der ich eingeladen wurde, darüber zu berichten.  Und so fing alles an. </p><br><p>  Über die Initialisierung hat Nikolay Yossutis bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berichtet</a> .  Sein Bericht enthielt eine Folie mit 19 verschiedenen Möglichkeiten zum Initialisieren eines int: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-comment"><span class="hljs-comment">//undefined value int i2 = 42; //note: inits with 42 int i3(42); //inits with 42 int i4 = int(); //inits with 42 int i5{42}; //inits with 42 int i6 = {42}; //inits with 42 int i7{}; //inits with 0 int i8 = {}; //inits with 0 auto i9 = 42; //inits with 42 auto i10{42}; //C++11: std::initializer_list&lt;int&gt;, C++14: int auto i11 = {42}; //inits std::initializer_list&lt;int&gt; with 42 auto i12 = int{42}; //inits int with 42 int i13(); //declares a function int i14(7, 9); //compile-time error int i15 = (7, 9); //OK, inits int with 9 (comma operator) int i16 = int(7, 9); //compile-time error int i17(7, 9); //compile-time error auto i18 = (7, 9); //OK, inits int with 9 (comma operator) auto i19 = int(7, 9); //compile-time error</span></span></code> </pre> <br><p>  Es scheint mir, dass dies eine einzigartige Situation für eine Programmiersprache ist.  Das Initialisieren einer Variablen ist eine der einfachsten Aktionen, aber in C ++ ist dies überhaupt nicht einfach.  Es ist unwahrscheinlich, dass diese Sprache einen anderen Bereich hat, in dem in den letzten Jahren ebenso viele Berichte über Abweichungen vom Standard, Korrekturen und Änderungen vorliegen würden.  Die Initialisierungsregeln ändern sich von Standard zu Standard, und im Internet gibt es unzählige Beiträge zum Initialisieren in C ++.  Eine systematische Überprüfung ist daher keine triviale Aufgabe. </p><br><p>  Ich werde das Material in chronologischer Reihenfolge präsentieren: Zuerst werden wir darüber sprechen, was von C geerbt wurde, dann über C ++ 98, dann über C ++ 03, C ++ 11, C ++ 14 und C ++ 17.  Wir werden häufige Fehler diskutieren und meine Empfehlungen zur ordnungsgemäßen Initialisierung geben.  Ich werde auch über Innovationen in C ++ 20 sprechen.  Eine Übersichtstabelle wird ganz am Ende des Berichts angezeigt. </p><br><a name="a1"></a><br><h1 id="inicializaciya-po-umolchaniyu-s">  Standardinitialisierung (C) </h1><br><p>  In C ++ werden viele Dinge von C geerbt, deshalb werden wir damit beginnen.  Es gibt verschiedene Möglichkeiten, Variablen in C zu initialisieren.  Sie werden möglicherweise überhaupt nicht initialisiert. Dies wird als <em>Standardinitialisierung bezeichnet</em> .  Meiner Meinung nach ist dies ein unglücklicher Name.  Tatsache ist, dass keiner Variablen ein Standardwert zugewiesen wird, sondern einfach nicht initialisiert wird.  Wenn Sie sich in C ++ und C einer nicht initialisierten Variablen zuwenden, erhalten Sie ein undefiniertes Verhalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-comment"><span class="hljs-comment">// undefined behaviour }</span></span></code> </pre> <br><p>  Gleiches gilt für benutzerdefinierte Typen: Wenn in einer <code>struct</code> nicht initialisierte Felder vorhanden sind, tritt beim Zugriff auf diese Felder auch undefiniertes Verhalten auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.i; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  C ++ wurden viele neue Konstrukte hinzugefügt: Klassen, Konstruktoren, öffentliche, private Methoden, aber nichts davon beeinflusst das gerade beschriebene Verhalten.  Wenn ein Element in der Klasse nicht initialisiert ist, tritt beim Zugriff darauf ein undefiniertes Verhalten auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_j</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.get_i(); <span class="hljs-comment"><span class="hljs-comment">// Undefined behaviour! }</span></span></code> </pre> <br><p>  Es gibt keine magische Möglichkeit, ein Klassenelement in C ++ standardmäßig zu initialisieren.  Dies ist ein interessanter Punkt, und in den ersten Jahren meiner Karriere bei C ++ wusste ich das nicht.  Weder der Compiler noch die IDE, die ich damals benutzte, erinnerten mich in irgendeiner Weise daran.  Meine Kollegen haben diese Funktion bei der Überprüfung des Codes nicht berücksichtigt.  Ich bin mir ziemlich sicher, dass mein Code in diesen Jahren einige ziemlich seltsame Fehler enthält.  Mir schien klar, dass Klassen ihre Variablen initialisieren sollten. </p><br><p>  In C ++ 98 können Sie Variablen mithilfe der Member-Initialisiererliste initialisieren.  Eine solche Lösung des Problems ist jedoch nicht optimal, da sie in jedem Konstruktor durchgeführt werden muss, und dies ist leicht zu vergessen.  Darüber hinaus erfolgt die Initialisierung in der Reihenfolge, in der die Variablen deklariert sind, und nicht in der Reihenfolge der Mitgliederinitialisierungsliste: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++98: member initialiser list class Widget { public: Widget() : i(0), j(0) {} // member initialiser list int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i; int j; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  In C ++ 11 wurden direkte Elementinitialisierer hinzugefügt, die viel bequemer zu verwenden sind.  Mit ihnen können Sie alle Variablen gleichzeitig initialisieren. Dies gibt Ihnen die Sicherheit, dass alle Elemente initialisiert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11: default member initialisers class Widget { public: Widget() {} int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i = 0; // default member initialisers int j = 0; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  Meine erste Empfehlung: Verwenden Sie immer DMI (Direct Member Initialisierer), wann immer Sie können.  Sie können sowohl mit integrierten Typen ( <code>float</code> und <code>int</code> ) als auch mit Objekten verwendet werden.  Die Gewohnheit, Elemente zu initialisieren, lässt uns dieses Problem bewusster angehen. </p><br><a name="a2"></a><br><h1 id="kopiruyuschaya-inicializaciya-s">  Kopierinitialisierung (C) </h1><br><p>  Die erste von C geerbte Initialisierungsmethode ist also standardmäßig die Initialisierung und sollte nicht verwendet werden.  Der zweite Weg ist die <em>Kopierinitialisierung</em> .  In diesem Fall geben wir die Variable und durch das Gleichheitszeichen ihren Wert an: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int main() { int i = 2; }</span></span></code> </pre> <br><p>  Die Kopierinitialisierung wird auch verwendet, wenn ein Argument wertmäßig an eine Funktion übergeben wird oder wenn ein Objekt wertmäßig von einer Funktion zurückgegeben wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int square(int i) { return i * i; }</span></span></code> </pre> <br><p>  Ein Gleichheitszeichen kann den Eindruck erwecken, dass ein Wert zugewiesen wird, dies ist jedoch nicht der Fall.  Die Kopierinitialisierung ist keine Wertzuweisung.  In diesem Bericht wird nichts über die Aneignung gesagt. </p><br><p>  Eine weitere wichtige Eigenschaft der Kopierinitialisierung: Wenn die Wertetypen nicht übereinstimmen, wird eine Konvertierungssequenz ausgeführt.  Eine Konvertierungssequenz hat bestimmte Regeln, z. B. ruft sie keine expliziten Konstruktoren auf, da sie keine Konstruktoren transformieren.  Wenn Sie eine Kopierinitialisierung für ein Objekt durchführen, dessen Konstruktor als explizit markiert ist, tritt daher ein Kompilierungsfehler auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br><p>  Wenn es einen anderen Konstruktor gibt, der nicht explizit ist, dessen Typ jedoch schlechter ist, wird er von der Kopierinitialisierung aufgerufen, wobei der explizite Konstruktor ignoriert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double)</span></span></code> </pre> <br><a name="a3"></a><br><h1 id="agregatnaya-inicializaciya-s">  Aggregierte Initialisierung (C) </h1><br><p>  Die dritte Art der Initialisierung, über die ich sprechen möchte, ist die <em>aggregierte Initialisierung</em> .  Es wird ausgeführt, wenn das Array mit einer Reihe von Werten in geschweiften Klammern initialisiert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><p>  Wenn Sie die Größe des Arrays nicht angeben, wird es aus der Anzahl der in Klammern eingeschlossenen Werte abgeleitet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// array size deduction</span></span></code> </pre> <br><p>  Dieselbe Initialisierung wird für Aggregatklassen verwendet, d. H. Klassen, die nur eine Sammlung öffentlicher Elemente sind (die Definition von Aggregatklassen enthält einige weitere Regeln, auf die wir jetzt jedoch nicht näher eingehen werden): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> j; }; Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Diese Syntax funktionierte sogar in C und C ++ 98, und ab C ++ 11 können Sie das Gleichheitszeichen darin überspringen: </p><br><pre> <code class="cpp hljs">Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Die Aggregatinitialisierung verwendet tatsächlich die Kopierinitialisierung für jedes Element.  Wenn Sie daher versuchen, die aggregierte Initialisierung (sowohl mit als auch ohne Gleichheitszeichen) für mehrere Objekte mit expliziten Konstruktoren zu verwenden, wird für jedes Objekt eine Kopierinitialisierung durchgeführt, und es tritt ein Kompilierungsfehler auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ERROR Thingy thingy {3, 4}; // ERROR }</span></span></code> </pre> <br><p>  Und wenn es für diese Objekte einen anderen Konstruktor gibt, der nicht explizit ist, wird er aufgerufen, auch wenn er für die Eingabe schlechter geeignet ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Thingy thingy {3, 4}; //  Widget(double) }</span></span></code> </pre> <br><p>  Betrachten wir eine weitere Eigenschaft der aggregierten Initialisierung.  Frage: Welchen Wert gibt dieses Programm zurück? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.j; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>  Das stimmt, Null.  Wenn Sie während der Aggregatinitialisierung einige Elemente in einem Array von Werten überspringen, werden die entsprechenden Variablen auf Null gesetzt.  Dies ist eine sehr nützliche Eigenschaft, da es dank dieser Eigenschaft niemals nicht initialisierte Elemente geben kann.  Es funktioniert mit Aggregatklassen und mit Arrays: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int[100] = {};</span></span></code> </pre> </div></div><br><p>  Eine weitere wichtige Eigenschaft der Aggregatinitialisierung ist das Weglassen von Klammern (Klammerelision).  Welchen Wert gibt dieses Programm Ihrer Meinung nach zurück?  Es hat ein <code>Widget</code> , das aus zwei <code>int</code> Werten besteht, und <code>Thingy</code> , ein Aggregat aus <code>Widget</code> und <code>int</code> .  Was erhalten wir, wenn wir zwei Initialisierungswerte übergeben: <code>{1, 2}</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy t = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tk; <span class="hljs-comment"><span class="hljs-comment">//   ? }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>  Die Antwort ist Null.  Hier handelt es sich um ein Unteraggregat, dh um eine verschachtelte Aggregatklasse.  Solche Klassen können mit verschachtelten Klammern initialisiert werden. Sie können jedoch eines dieser Klammerpaare überspringen.  In diesem Fall wird eine rekursive Durchquerung des Unteraggregats durchgeführt, und <code>{1, 2}</code> stellt sich als äquivalent zu <code>{{1, 2}, 0}</code> .  Zugegeben, diese Eigenschaft ist nicht ganz offensichtlich. </p></div></div><br><a name="a4"></a><br><h1 id="staticheskaya-inicializaciya-s">  Statische Initialisierung (C) </h1><br><p>  Schließlich wird die <em>statische Initialisierung</em> auch von C geerbt: Statische Variablen werden immer initialisiert.  Dies kann auf verschiedene Arten erfolgen.  Eine statische Variable kann mit einem konstanten Ausdruck initialisiert werden.  In diesem Fall erfolgt die Initialisierung zur Kompilierungszeit.  Wenn Sie der Variablen keinen Wert zuweisen, wird sie auf Null initialisiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   statit int j; //   int main() { return i + j; }</span></span></code> </pre> <br><p>  Dieses Programm gibt 3 zurück, obwohl <code>j</code> nicht initialisiert ist.  Wenn die Variable nicht durch eine Konstante, sondern durch ein Objekt initialisiert wird, können Probleme auftreten. </p><br><p>  Hier ist ein Beispiel aus einer realen Bibliothek, an der ich gearbeitet habe: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Colour red = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p>  Es gab eine Farbklasse, und die Primärfarben (rot, grün, blau) wurden als statische Objekte definiert.  Dies ist eine gültige Aktion, aber sobald ein anderes statisches Objekt in dem Initialisierer erscheint, dessen <code>red</code> verwendet wird, tritt Unsicherheit auf, da es keine starre Reihenfolge gibt, in der die Variablen initialisiert werden.  Ihre Anwendung kann auf eine nicht initialisierte Variable zugreifen und stürzt dann ab.  Glücklicherweise wurde es in C ++ 11 möglich, den Konstruktor <code>constexpr</code> verwenden, und dann haben wir es mit ständiger Initialisierung zu tun.  In diesem Fall gibt es keine Probleme mit der Initialisierungsreihenfolge. </p><br><p>  Daher werden vier Arten der Initialisierung von der C-Sprache geerbt: Standardinitialisierung, Kopieren, Aggregieren und statische Initialisierung. </p><br><a name="a5"></a><br><h1 id="pryamaya-inicializaciya-s98">  Direkte Initialisierung (C ++ 98) </h1><br><p>  Fahren wir mit C ++ 98 fort.  Das vielleicht wichtigste Merkmal, das C ++ von C unterscheidet, sind die Konstruktoren.  Hier ist ein Beispiel für einen Konstruktoraufruf: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  Mit derselben Syntax können Sie integrierte Typen wie <code>int</code> und <code>float</code> initialisieren.  Diese Syntax wird als <em>direkte Initialisierung bezeichnet</em> .  Es wird immer ausgeführt, wenn wir ein Argument in Klammern haben. </p><br><p>  Bei integrierten Typen ( <code>int</code> , <code>bool</code> , <code>float</code> ) gibt es hier keinen Unterschied zur Kopierinitialisierung.  Wenn es sich um Benutzertypen handelt, können Sie im Gegensatz zur Kopierinitialisierung bei der direkten Initialisierung mehrere Argumente übergeben.  Aus diesem Grund wurde die direkte Initialisierung erfunden. </p><br><p>  Außerdem führt eine direkte Initialisierung keine Konvertierungssequenz aus.  Stattdessen wird der Konstruktor mit der Überlastungsauflösung aufgerufen.  Die direkte Initialisierung hat dieselbe Syntax wie ein Funktionsaufruf und verwendet dieselbe Logik wie andere C ++ - Funktionen. </p><br><p>  In der Situation mit einem expliziten Konstruktor funktioniert die direkte Initialisierung daher einwandfrei, obwohl die Kopierinitialisierung einen Fehler auslöst: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w2(1); //   </span></span></code> </pre> <br><p>  In einer Situation mit zwei Konstruktoren, von denen einer explizit ist und der zweite weniger geeignet ist, wird der erste mit direkter Initialisierung und der zweite mit der Kopie aufgerufen.  In dieser Situation führt das Ändern der Syntax zu einem Aufruf eines anderen Konstruktors - dies wird häufig vergessen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Widget w2(1); //  Widget(int)</span></span></code> </pre> <br><p>  Die direkte Initialisierung wird immer verwendet, wenn Klammern verwendet werden, einschließlich der Konstruktoraufrufnotation zum Initialisieren eines temporären Objekts sowie in <code>new</code> Ausdrücken mit einem Initialisierer in Klammern und in <code>cast</code> : </p><br><pre> <code class="cpp hljs">useWidget(Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   auto* widget_ptr = new Widget(2, 3); // new-expression with (args) static_cast&lt;Widget&gt;(thingy); // cast</span></span></code> </pre> <br><p>  Diese Syntax existiert, solange C ++ selbst existiert, und sie hat einen wichtigen Fehler, den Nikolai in seiner Grundsatzrede erwähnt hat: <em>die ärgerlichste Analyse</em> .  Dies bedeutet, dass alles, was der Compiler als Deklaration (Deklaration) lesen kann, genau als Deklaration gelesen wird. </p><br><p>  <code>Thingy</code> Sie sich ein Beispiel vor, in dem es eine <code>Widget</code> Klasse und eine <code>Thingy</code> Klasse sowie einen <code>Thingy</code> Konstruktor gibt, der ein <code>Widget</code> empfängt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Thingy(Widget) {} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Thingy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget())</span></span></span></span>; }</code> </pre> <br><p>  Auf den ersten Blick scheint es, dass bei der Initialisierung von <code>Thingy</code> das erstellte Standard- <code>Widget</code> an dieses übergeben wird, aber tatsächlich wird die Funktion hier deklariert.  Dieser Code deklariert eine Funktion, die eine andere Funktion als Eingabe empfängt, die nichts als Eingabe empfängt und ein <code>Widget</code> zurückgibt, und die erste Funktion gibt <code>Thingy</code> .  Der Code wird fehlerfrei kompiliert, aber es ist unwahrscheinlich, dass wir nach einem solchen Verhalten gesucht haben. </p><br><a name="a6"></a><br><h1 id="inicializaciya-znacheniem-c03">  Wertinitialisierung (C ++ 03) </h1><br><p>  Fahren wir mit der nächsten Version fort - C ++ 03.  Es ist allgemein anerkannt, dass es in dieser Version keine wesentlichen Änderungen gab, dies ist jedoch nicht der Fall.  In C ++ 03 wurde eine Wertinitialisierung angezeigt, in die leere Klammern geschrieben sind: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// UB  C++98, 0   C++03 }</span></span></code> </pre> <br><p>  In C ++ 98 tritt hier ein undefiniertes Verhalten auf, da die Initialisierung standardmäßig erfolgt und dieses Programm ab C ++ 03 Null zurückgibt. </p><br><p>  Die Regel lautet: Wenn es einen benutzerdefinierten Standardkonstruktor gibt, ruft die Initialisierung mit einem Wert diesen Konstruktor auf, andernfalls wird Null zurückgegeben. </p><br><p>  Lassen Sie uns die Situation mit dem benutzerdefinierten Konstruktor genauer betrachten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Widget(); <span class="hljs-comment"><span class="hljs-comment">// value initialization } int main() { return get_widget().i; }</span></span></code> </pre> <br><p>  In diesem Programm initialisiert die Funktion den Wert für das neue <code>Widget</code> und gibt ihn zurück.  Wir rufen diese Funktion auf und greifen auf das Element <code>i</code> des <code>Widget</code> Objekts zu.  Seit C ++ 03 ist der Rückgabewert hier Null, da es keinen benutzerdefinierten Standardkonstruktor gibt.  Und wenn ein solcher Konstruktor existiert, aber <code>i</code> nicht initialisiert, erhalten wir undefiniertes Verhalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {} <span class="hljs-comment"><span class="hljs-comment">//   int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //   ,  UB }</span></span></code> </pre> <br><p>  Es ist erwähnenswert, dass "benutzerdefiniert" nicht "benutzerdefiniert" bedeutet.  Dies bedeutet, dass der Benutzer den Körper des Konstruktors bereitstellen muss, d. H. Geschweifte Klammern.  Wenn Sie im obigen Beispiel den Konstruktorkörper durch <code>= default</code> ersetzen (diese Funktion wurde in C ++ 11 hinzugefügt), ändert sich die Bedeutung des Programms.  Jetzt haben wir einen Konstruktor, der vom Benutzer definiert (benutzerdefiniert), aber nicht vom Benutzer bereitgestellt (vom Benutzer bereitgestellt) wird, sodass das Programm Null zurückgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// user-defined,   user-provided int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //  0 }</span></span></code> </pre> <br><p>  Versuchen wir nun <code>Widget() = default</code> aus der Klasse zu verschieben.  Die Bedeutung des Programms hat sich erneut geändert: <code>Widget() = default</code> wird als vom Benutzer bereitgestellter Konstruktor betrachtet, wenn er sich außerhalb der Klasse befindet.  Das Programm gibt wieder undefiniertes Verhalten zurück. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; Widget::Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  user-provided Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //    , UB }</span></span></code> </pre> <br><p>  Es gibt eine bestimmte Logik: Ein außerhalb einer Klasse definierter Konstruktor kann sich innerhalb einer anderen Übersetzungseinheit befinden.  Der Compiler sieht diesen Konstruktor möglicherweise nicht wie in einer anderen <code>.cpp</code> Datei.  Daher kann der Compiler keine Schlussfolgerungen über einen solchen Konstruktor ziehen und einen Konstruktor mit einem Body nicht von einem Konstruktor mit <code>= default</code> . </p><br><a name="a7"></a><br><h1 id="universalnaya-inicializaciya-c11">  Universelle Initialisierung (C ++ 11) </h1><br><p>  Es gab viele sehr wichtige Änderungen in C ++ 11.  Insbesondere wurde eine universelle (einheitliche) Initialisierung eingeführt, die ich lieber als "Einhorninitialisierung" bezeichne, weil sie einfach magisch ist.  Mal sehen, warum sie aufgetaucht ist. </p><br><p>  Wie Sie bereits bemerkt haben, gibt es in C ++ viele verschiedene Initialisierungssyntaxen mit unterschiedlichem Verhalten.  Die ärgerliche Analyse in Klammern verursachte viele Unannehmlichkeiten.  Den Entwicklern gefiel auch nicht, dass die aggregierte Initialisierung nur mit Arrays verwendet werden konnte, nicht jedoch mit Containern wie <code>std::vector</code> .  Stattdessen mussten Sie <code>.reserve</code> und <code>.push_back</code> ausführen oder alle möglichen gruseligen Bibliotheken verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  : std::vector&lt;int&gt; vec = {0, 1, 2, 3, 4}; //   : std::vector&lt;int&gt; vec; vec.reserve(5); vec.push_back(0); vec.push_back(1); vec.push_back(2); vec.push_back(3); vec.push_back(4);</span></span></code> </pre> <br><p>  Die Schöpfer der Sprache versuchten, all diese Probleme zu lösen, indem sie die Syntax mit geschweiften Klammern einführten, jedoch ohne Gleichheitszeichen.  Es wurde angenommen, dass dies eine einzige Syntax für alle Typen ist, in denen geschweifte Klammern verwendet werden und es kein störendes Analyseproblem gibt.  In den meisten Fällen erledigt diese Syntax ihre Aufgabe. </p><br><p>  Diese neue Initialisierung wird als <em>Listeninitialisierung</em> bezeichnet und ist in zwei Typen erhältlich: Direkt und Kopieren.  Im ersten Fall werden nur geschweifte Klammern verwendet, im zweiten Fall geschweifte Klammern mit Gleichheitszeichen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// direct-list-initialization Widget widget{1, 2}; // copy-list-initialization Widget widget = {1, 2};</span></span></code> </pre> <br><p>  Die zur Initialisierung verwendete Liste heißt <em>Braced-Init-List</em> .  Es ist wichtig, dass diese Liste kein Objekt ist und keinen Typ hat.  Der Wechsel von früheren Versionen zu C ++ 11 verursacht keine Probleme mit Aggregattypen, daher ist diese Änderung nicht kritisch.  Aber jetzt hat die Liste in geschweiften Klammern neue Funktionen.  Obwohl es keinen Typ hat, kann es versteckt in <code>std::initializer_list</code> konvertiert werden, es ist so ein spezieller neuer Typ.  Und wenn es einen Konstruktor gibt, der <code>std::initializer_list</code> als Eingabe akzeptiert, heißt dieser Konstruktor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... vector(std::initializer_list&lt;T&gt; init); //   initializer_list }; std::vector&lt;int&gt; vec{0, 1, 2, 3, 4}; //  ^ </span></span></code> </pre> <br><p>  Es scheint mir, dass <code>std::initializer_list</code> von der Seite des C ++ - Komitees nicht die erfolgreichste Lösung war.  Von ihm mehr Schaden als Nutzen. </p><br><p>  Zunächst ist <code>std::initializer_list</code> ein Vektor fester Größe mit <code>const</code> Elementen.  Das heißt, es ist ein Typ, es hat <code>begin</code> und Endfunktionen, die Iteratoren zurückgeben, es hat einen eigenen Iteratortyp, und um ihn zu verwenden, müssen Sie einen speziellen Header einfügen.  Da die Elemente <code>std::initializer_list</code> <code>const</code> , kann sie nicht verschoben werden. Wenn also <code>T</code> im obigen Code vom Typ move-only ist, wird der Code nicht ausgeführt. </p><br><p>  Als nächstes ist <code>std::initializer_list</code> ein Objekt.  Damit erstellen und übertragen wir tatsächlich Objekte.  In der Regel kann der Compiler dies optimieren, aber aus semantischer Sicht beschäftigen wir uns immer noch mit unnötigen Objekten. </p><br><p>  Vor einigen Monaten gab es auf Twitter eine Umfrage: Wenn Sie in die Vergangenheit reisen und etwas aus C ++ entfernen könnten, was würden Sie entfernen?  Vor allem Stimmen haben genau <code>initializer_list</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://twitter.com/shafikyaghmour/status/1058031143935561728</a> </p><br><p>         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   initializer_list</code></a> .         ,     . </p><br><p>  ,    .   ,     <code>initializer_list</code> ,              .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0, 0, 0 std::vector&lt;int&gt; v{3, 0}; //   3, 0</span></span></code> </pre> <br><p>   <code>vector</code>    <code>int</code>    ,    ,      ,   —  .       .       ,   <code>initializer_list</code>        , 3  0. </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">48</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" std::string s{48, 'a'}; // "0a"</span></span></code> </pre> <br><p>       48  «»,     «0».   ,   <code>string</code>    <code>initializer_list</code>  . 48   ,     .  ASCII  48 —   «0».   ,    ,    , <code>int</code>  <code>char</code> .         .    ,       ,   . </p><br><p>       .   ,    ?    ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;{N}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;().size(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>      ,    — 3.   <code>string</code>   <code>int</code> ,   1,    <code>std::vector&lt;std::int&gt;</code>   <code>initializer_list</code> .         <code>initializer_list</code> ,   .    <code>string</code>  <code>int</code>  <code>float</code> ,     ,  .      ,     . ,     emplace ,          .  ,     <code>{}</code>    . </p></div></div><br><p>   ,     . </p><br><p>         <br> . <br>    —   ( <code>{a}</code> )  <br>   ( <code>= {a}</code> ); <br>      : </p><br><ol><li>  «»   ,   <code>std::initializer_list</code> . <br>         —  . </li><li>    ,   <br>   <code>()</code>    . </li></ol><br><p>      . </p><br><p>  1:   <code>= {a}</code> ,      <code>a</code> , <br>     . </p><br><p>  2:   , <code>{}</code> . <br>           ,   <code>initializer_list</code> . <br>     <code>Widget&lt;int&gt; widget{}\</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Typename&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; widget{}; <span class="hljs-comment"><span class="hljs-comment">//    ? }</span></span></code> </pre> <br><p>  ,    ,  <code>initializer_list</code> ,      <code>initializer_list</code>   .        .      ,  ,  <code>initializer_list</code> .     ,   .  ,     . </p><br><p>       <code>{}</code> . , -,  ,   <code>Widget() = default</code>  <code>Widget() {}</code>    —     . </p><br><p> <code>Widget() = default</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{}; <span class="hljs-comment"><span class="hljs-comment">//   (),   vexing parse return widget.i; //  0 }</span></span></code> </pre> <br><p> <code>Widget() {}</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {}; <span class="hljs-comment"><span class="hljs-comment">// user-provided  int i; }; int main() { Widget widget{}; //  ,    return widget.i; //  ,  UB }</span></span></code> </pre> <br><p>      :   ,    (narrowing conversions).    <code>int</code>  <code>double</code> ,    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{<span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre> <br><p>    ,       <code>double</code> .   C++11,         ,      .          : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   ++11    C++98/03 }</span></span></code> </pre> <br><p> ,        , ,     ,       (brace elision).   ,       ,   . ,    <code>map</code> .       <code>map</code> ,     —  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; my_map {{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>   ,      .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; v1 {<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::vector&lt;std::string&gt; v2 {{"abc", "def"}}; // ??</span></span></code> </pre> <br><p> ,    ,     <code>initializer_list</code> .      <code>initializer_list</code>   ,   , ,     .           ,   .  , . </p><br><p>  <code>initializer_list</code>     —  <code>initializer_list</code> ,        .     ,    <code>const char*</code> . ,  <code>string</code>  ,     <code>char</code>    .        .     ,     ,   . </p><br><p> : </p><br><ul><li>       ; </li><li>       . </li></ul><br><p>  .    braced-init-list     .    : </p><br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// copy-list    } void f2(Widget); f2({3, 0}); // copy-list  </span></span></code> </pre> <br><p>     ,    ,    braced-init-list    .    braced-init-list ,       . </p><br><p> ,          .  StackOverflow   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,             . ,      .      ,      ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct A { A() {} A(const A&amp;) {} }; struct B { B(const A&amp;) {} }; void f(const A&amp;) { std::cout &lt;&lt; "A" &lt;&lt; std::endl; } void f(const B&amp;) { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } int main() { A a; f( {a} ); // A f( {{a}} ); // ambiguous f( {{{a}}} ); // B f({{{{a}}}}); // no matching function }</span></span></span></span></code> </pre> <br><a name="a8"></a><br><h1 id="uluchsheniya-v-s14">   ++14 </h1><br><p> ,      C++11 .      ,   ,        .    C++14.      ,    . </p><br><p> ,  ++11       direct member initializers,     .      ,  direct member initializers  .   ++14,      direct member initializers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    C++14</span></span></code> </pre> <br><p>        ,    <code>auto</code> .   ++11  <code>auto</code>  braced-init-list,       <code>std::initializer_list</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int int i(3); // int int i{3}; // int int i = {3}; // int auto i = 3; // int auto i(3); // int auto i{3}; //  ++11 — std::initializer_list&lt;int&gt; auto i = {3}; //  ++11 — std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p>   :   <code>auto i{3}</code> ,     <code>int</code> ,   <code>std::initializer_list&lt;int&gt;</code> .  ++14   ,  <code>auto i{3}</code>    <code>int</code> .          ,     . , <code>auto i = {3}</code>    <code>std::initializer_list&lt;int&gt;</code> .  ,     :      <code>int</code> ,     — <code>initializer_list</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int auto i(3); // int auto i{3}; //  ++14 — int,         auto i = {3}; //    std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p> ,  C++14      ,      ,  ,     ,       .   ,     . </p><br><p>     ,  ++14      : </p><br><ul><li><p>   ,   ,  <code>std::initializer_list</code> . </p><br></li><li><p>  <code>std::initializer_list</code>    move-only . </p><br></li><li><p>  c   ,  <code>emplace</code>  <code>make_unique</code>     . </p><br></li><li><p>    ,     : </p><br><ul><li>      ,  -; </li><li>       ; </li><li> auto     . </li></ul><br></li><li><p> ,    ,        . </p><br></li></ul><br><p>   : <code>assert(Widget(2,3))</code> ,  <code>assert(Widget{2,3})</code>  .   ,      ,       ,        .           ,     .    . </p><br><a name="a9"></a><br><h1 id="kak-pravilno-inicializirovat-v-c">     C++ </h1><br><p>       ,      ++. </p><br><p>     <code>int</code>   , . .     —      ,          . </p><br><p>      :   ,   ,  <code>std::initializer_list</code> ,   direct member initializers.          ,       . </p><br><p>  ,         é .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; setPosition(Point{<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget(Widget{});</code> </pre> <br><p>        braced-init-list —      . </p><br><pre> <code class="cpp hljs">setPosition({<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget({});</code> </pre> <br><p>      ,       ,    .   ,         —  ,       .  ,     ,     ,    ,   ,    .    ,   ,     <code>initializer_list</code> .        :     ,  ,   . </p><br><p>   : </p><br><ul><li><p> <code>= value</code>    </p><br></li><li><p> <code>= {args}</code>  <code>= {}</code> : </p><br><ul><li>    </li><li>    <code>std::initializer_list</code> </li><li>  direct member initialisation (    <code>(args)</code> ) </li></ul><br></li><li><p> <code>{args}</code>  <code>{}</code>     é  </p><br></li><li><p> <code>(args)</code>    </p><br></li></ul><br><p> ,   <code>(args)</code>     vexing parse.        .    2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   ,          <code>auto</code> .     ,        :   <code>auto i;</code> —    .     ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>   ,        .  ,           ,     vexing parse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> thingy = Thingy();</code> </pre> <br><p>      «  auto» («almost always auto», AAA),   ++11  ++14       , , ,     <code>std::atomic&lt;int&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++11/14:  // std::atomic is neither copyable nor movable</span></span></code> </pre> <br><p>   ,  atomic    .   ,          ,    ,    ,       .  ++17    ,    ,      (guaranteed copy elision): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++17: OK, guaranteed copy elision</span></span></code> </pre> <br><p>        <code>auto</code> .   —  direct member initializers.     <code>auto</code>  . </p><br><p>  ++17    CTAD (class template argument deduction). ,              .        .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  CppCon,   CTAD</a> ,       .   ,  ++17   ,    ++11  ++14,   ,       .     ,    , ,   ,      . </p><br><a name="a10"></a><br><h1 id="naznachennaya-inicializaciya-s20">   (++20) </h1><br><p>     ++20,     .  ,  ,          : <em> </em> (designated initialization): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, .c = <span class="hljs-number"><span class="hljs-number">7</span></span>}; };</code> </pre> <br><p>  ,      .         ,      ,      .        ,       .      <code></code>  <code></code> ,  <code>b</code>  . </p><br><p>      ,  ,     ,     .       ,         . </p><br><p>       ,    ,   99,   : </p><br><ul><li><p>       ,         ,   .  ++   ,     ,    .  :: </p><br><pre> <code class="cpp hljs">Widget widget{.c = <span class="hljs-number"><span class="hljs-number">7</span></span>, .a = <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  ,     . </p><br></li><li><p>  ++      ,     <code>{.ce = 7};</code> ,    <code>{.c{.e = 7}}</code> : </p><br><pre> <code class="cpp hljs">Widget widget{.ce = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       ,      ,      : </p><br><pre> <code class="cpp hljs">Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       . , -,   ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>]{.[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li></ul><br><a name="a11"></a><br><h1 id="ispravleniya-v-c20">   C++20 </h1><br><p>      ++20       ,        .     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p1008</a> ). </p><br><p>   ++17    ,    ,        .             ,    ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; Widget widget1; <span class="hljs-comment"><span class="hljs-comment">//  Widget widget2{}; //   C++17,     C++20</span></span></code> </pre> <br><p>    ,       ,      .  ++20   .        ,              .  ,   .       ,    ,     ,   . </p><br><p>         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p1009</a> ). Braced-init-list     <code>new</code> ,   :        ,    ?  — ,    : braced-init-list      <code>new</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK double* p = new double[]{1, 2, 3}; //   C++17,   C++20</span></span></code> </pre> <br><p>    ,   ++11  braced-init-list.  ++   .        ,       . </p><br><a name="a12"></a><br><h1 id="pryamaya-inicializaciya-agregatnyh-tipov-c20">     (C++20) </h1><br><p> ,  ++20      .       ,             .  ++20  :         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wg21.link/p0960</a> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   C++20</span></span></code> </pre> <br><p>            .   ,        <code>emplace</code>  <code>make_unique</code> .      .  :   <code>auto</code> ,          : <em>58.11</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>   ,   :   uniform  2.0.     .         ,    , ,  ,           .  —  <code>initializer_list</code> :    ,    ,   — .    ,    .  ,   -     ,   — .       . </p><br><p> ,    .   direct member initializers.   <code>auto</code> .      direct member initializers —  ,    .   ,        .         — ,     . </p><br><p>    ,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .     —  ,   —  .     ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b8d/8a2/229/b8d8a2229e93baf65b78f738750ac635.png"></p><br><blockquote>   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C++ Russia 2019 Piter</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«Type punning in modern C++»</a> .     ,   ++20,  ,    ,    «»  ++  ,    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469465/">https://habr.com/ru/post/de469465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469455/index.html">Migration von Nginx zu Envoy Proxy</a></li>
<li><a href="../de469457/index.html">Wohin Extravaganza führt</a></li>
<li><a href="../de469459/index.html">Anschließen von IoT-Geräten in der Smart City</a></li>
<li><a href="../de469461/index.html">"Zu den Sternen": Anti-Kosmische "Apokalypse heute"</a></li>
<li><a href="../de469463/index.html">Trends und Prognosen in der Verarbeitung natürlicher Sprache</a></li>
<li><a href="../de469467/index.html">C ++ vs C #</a></li>
<li><a href="../de469471/index.html">"5 Cent", um über Sorten zu sprechen</a></li>
<li><a href="../de469475/index.html">Der Aufstieg und Fall von Flash, dem nervigen Plugin, das das moderne Web geprägt hat</a></li>
<li><a href="../de469477/index.html">Apple ist an der Zeit, den Vergleich von iPad und PC einzustellen</a></li>
<li><a href="../de469479/index.html">Woher kommt die Quantenwahrscheinlichkeit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>