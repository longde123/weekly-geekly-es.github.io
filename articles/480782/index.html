<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçç üñáÔ∏è üìÄ 5 cosas que me gustar√≠a saber cuando comenc√© a usar Angular üí∂ ü§¥ üßöüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern Angular es un marco poderoso con muchas caracter√≠sticas, junto con el cual a primera vista surgen conceptos y mecanismos complejos. Esto es esp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 cosas que me gustar√≠a saber cuando comenc√© a usar Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/480782/"><p>  Modern Angular es un marco poderoso con muchas caracter√≠sticas, junto con el cual a primera vista surgen conceptos y mecanismos complejos.  Esto es especialmente notable para aquellos que acaban de comenzar a trabajar tanto en el front-end en principio, como con Angular en particular. </p><br><p>  Tambi√©n enfrent√© el mismo problema cuando llegu√© a Tinkoff al puesto de Desarrollador Frontend Junior hace aproximadamente dos a√±os y me sumerg√≠ en el mundo de Angular.  Por lo tanto, les ofrezco una breve historia sobre cinco cosas, cuya comprensi√≥n facilitar√≠a en gran medida mi trabajo al principio. </p><br><p><img src="https://habrastorage.org/webt/er/qq/op/erqqope6skve-m43vun9ivrjyda.png"></p><a name="habracut"></a><br><h2 id="dependency-injection-di">  Inyecci√≥n de dependencia (DI) </h2><br><p>  Al principio entr√© en el componente y vi que hab√≠a algunos argumentos en el constructor de la clase.  Hice un peque√±o an√°lisis del trabajo de los m√©todos de clase, y qued√≥ claro que se trata de algunas dependencias externas.  ¬øPero c√≥mo entraron en clase?  ¬øD√≥nde se llamaba el constructor? </p><br><p>  Sugiero inmediatamente entender un ejemplo, pero para esto necesitamos una clase.  Si en JavaScript "normal" OOP est√° presente con ciertos "hacks", entonces junto con ES6 hay una sintaxis "real".  Angular usa TypeScript de inmediato, en el que la sintaxis es casi la misma.  Por lo tanto, propongo usarlo m√°s. </p><br><p> Imagine que hay una clase <code>JokerService</code> en nuestra aplicaci√≥n que gestiona chistes.  El m√©todo <code>getJokes()</code> devuelve una lista de chistes.  Supongamos que lo usamos en tres lugares.  ¬øC√≥mo hacer bromas en tres lugares diferentes del c√≥digo?  Hay varias formas: </p><br><ol><li>  Crea una instancia de la clase en cada lugar.  Pero, ¬øpor qu√© necesitamos obstruir la memoria y crear tantos servicios id√©nticos?  ¬øY si hay 100 asientos? </li><li>  Haga que el m√©todo sea est√°tico y recupere datos utilizando JokerService.getJokes (). </li><li>  Implemente uno de los patrones de dise√±o.  Si necesitamos que el servicio sea uno para toda la aplicaci√≥n, entonces ser√° Singleton.  Pero para esto necesitas escribir una nueva l√≥gica en la clase. </li></ol><br><p>  Entonces, tenemos tres opciones bastante funcionales.  El primero no nos conviene, en este caso es ineficaz.  No queremos crear copias adicionales, ya que ser√°n completamente id√©nticas.  Quedan dos opciones. </p><br><p>  Vamos a complicar la tarea para comprender qu√© m√©todo nos conviene m√°s.  Supongamos que, en tercer lugar, necesitamos por alguna raz√≥n crear nuestro propio servicio con ciertos par√°metros.  Este puede ser un autor espec√≠fico, la duraci√≥n de la broma, el idioma y m√°s.  ¬øQu√© haremos entonces? </p><br><p>  En el caso del m√©todo est√°tico, deber√° pasar la configuraci√≥n con cada llamada, ya que la clase es com√∫n a todos los lugares.  Es decir, en cada llamada a <code>getJokes()</code> pasaremos todos los par√°metros √∫nicos de este lugar.  Por supuesto, es mejor pasarlos cuando <code>getJokes()</code> instancia y luego simplemente llamar al m√©todo <code>getJokes()</code> . </p><br><p>  Resulta que la segunda opci√≥n tampoco nos conviene: nos har√° duplicar mucho c√≥digo en cada lugar.  Solo queda Singleton, que nuevamente necesitar√° actualizar la l√≥gica, pero con variaciones.  Pero, ¬øc√≥mo entender qu√© opci√≥n necesitamos? </p><br><p>  Si cre√≠a que simplemente pod√≠a crear un objeto y usar la clave para tomar el servicio deseado, puedo felicitarlo: acaba de darse cuenta de c√≥mo funciona la <em>inyecci√≥n de dependencia</em> en general.  Pero vamos un poco m√°s profundo. </p><br><p>  Para asegurarse de que se necesita un mecanismo para ayudarnos a obtener las instancias necesarias, imagine que JokerService necesita otros dos servicios m√°s, uno de los cuales es opcional, y el segundo deber√≠a dar un resultado especial en un lugar determinado.  No es dificil. </p><br><h3 id="dependency-injection-v-angular">  Inyecci√≥n de dependencia en angular </h3><br><p>  Como dice la <a href="https://angular.io/guide/dependency-injection">documentaci√≥n</a> , DI es un patr√≥n de dise√±o importante para una aplicaci√≥n.  Angular tiene su propio marco de dependencia, que se utiliza en Angular para aumentar la eficiencia y la modularidad. </p><br><p>  En t√©rminos generales, la <em>inyecci√≥n de dependencias</em> es un mecanismo poderoso en el que una clase recibe las dependencias necesarias de alg√∫n lugar externo, en lugar de crear instancias por s√≠ misma. </p><br><p>  Deje que la sintaxis y los archivos con la extensi√≥n <code>html</code> no lo confundan.  Cada componente en Angular es un objeto JavaScript normal, una instancia de una clase.  En t√©rminos generales: cuando inserta un componente en una plantilla, se crea una instancia de la clase de componente.  En consecuencia, en este momento, puede pasar las dependencias necesarias al constructor.  Ahora considere un ejemplo: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'jokes', template: './jokes.template.html', }) export class JokesComponent { private jokes: Observable&lt;IJoke[]&gt;; constructor(private jokerService: JokerService) { this.jokes = this.jokerService.getJokes(); } }</code> </pre> <br><p>  En el constructor de componentes, simplemente indicamos que necesitamos un <code>JokerService</code> .  No lo creamos nosotros mismos.  Si hay cinco componentes m√°s que lo usan, todos se referir√°n a la misma instancia.  Todo esto nos permite ahorrar tiempo, eliminar repeticiones y escribir aplicaciones muy productivas. </p><br><h3 id="providers">  Proveedores </h3><br><p>  Y ahora propongo tratar el caso cuando necesite obtener diferentes instancias del servicio.  Primero, eche un vistazo al servicio en s√≠: </p><br><pre> <code class="plaintext hljs">@Injectable({ providedIn: 'root', //   ,   ¬´¬ª  }) export class JokerService { getJokes(): Observable&lt;IJoke[]&gt; { //     } }</code> </pre> <br><p>  Cuando el servicio es uno para toda la aplicaci√≥n, esta opci√≥n ser√° suficiente.  ¬øPero qu√© <code>JokerService</code> si tenemos, digamos, dos implementaciones de <code>JokerService</code> ?  ¬øO es solo por alguna raz√≥n que un componente espec√≠fico necesita su propia instancia de servicio?  La respuesta es simple: <a href="https://angular.io/guide/providers"><code>provider</code></a> . </p><br><p>  Por conveniencia, llamar√© a <code>provider</code> <em>proveedor</em> , y se <em>comprobar√°</em> el proceso de sustituci√≥n de un valor en una clase.  Por lo tanto, podemos proporcionar servicio de diferentes maneras y en diferentes lugares.  Comencemos con el √∫ltimo.  Hay tres opciones disponibles: </p><br><ul><li>  En toda la aplicaci√≥n, especifique <code>provideIn: 'root'</code> en el decorador de servicios. </li><li>  En el m√≥dulo, especifique el proveedor en el decorador de servicios como <code>provideIn: JokesModule</code> o en el decorador del m√≥dulo <code>@NgModule  providers: [JokerService]</code> . </li><li>  En el componente: especifique el proveedor en el decorador del componente, como en el m√≥dulo. </li></ul><br><p>  El lugar se elige seg√∫n sus necesidades.  Descubrimos el lugar, pasemos al mecanismo en s√≠.  Si simplemente especificamos <code>provideIn: root</code> en el servicio, esto ser√≠a equivalente a la siguiente entrada en el m√≥dulo: </p><br><pre> <code class="plaintext hljs">@NgModule({ // ...     providers: [{provide: JokerService, useClass: JokerService}], }) //  </code> </pre> <br><p>  Esto se puede leer de la siguiente manera: "Si <code>JokerService</code> solicita un <code>JokerService</code> , proporcione una instancia de la clase <code>JokerService¬ª</code>  Desde aqu√≠ puede obtener una instancia espec√≠fica de varias maneras: </p><br><ul><li><p>  Por token: debe especificar un <code>InjectionToken</code> y obtener un servicio en √©l.  Tenga en cuenta que en los ejemplos a continuaci√≥n en <code>provide</code> puede pasar el mismo token: </p><br><pre> <code class="plaintext hljs">const JOKER_SERVICE_TOKEN = new InjectionToken&lt;string&gt;('JokerService'); // ...     [{provide: JOKER_SERVICE_TOKEN, useClass: JokerService}];</code> </pre> <br></li><li><p>  Por clase: puede reemplazar la clase.  Por ejemplo, pediremos <code>JokerService</code> y daremos - <code>JokerHappyService</code> : </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useClass: JokerHappyService}];</code> </pre> <br></li><li><p>  Por valor: puede devolver inmediatamente la instancia deseada: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useValue: jokerService}];</code> </pre> <br></li><li><p>  Por f√°brica: puede reemplazar la clase con una f√°brica que crear√° la instancia deseada cuando se acceda a ella: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useFactory: jokerServiceFactory}];</code> </pre> <br></li></ul><br><p>  Eso es todo  Es decir, para resolver el ejemplo con una instancia especial, puede usar cualquiera de los m√©todos anteriores.  Elija el m√°s adecuado para sus necesidades. </p><br><p>  Por cierto, DI funciona no solo para los servicios, sino en general para cualquier entidad que obtenga en el constructor de componentes.  Este es un mecanismo muy poderoso que debe utilizarse en todo su potencial. </p><br><h3 id="nebolshoy-itog">  Un peque√±o resumen </h3><br><p>  Para una comprensi√≥n completa, propongo considerar el mecanismo simplificado de Inyecci√≥n de dependencias en Angular en pasos utilizando el ejemplo de servicio: </p><br><ol><li>  Al inicializar la aplicaci√≥n, el servicio tiene un token.  Si no lo especificamos espec√≠ficamente en el proveedor, entonces este es JokerService. </li><li>  Cuando se solicita un servicio en un componente, el mecanismo DI verifica si existe el token transferido. </li><li>  Si el token no existe, DI lanzar√° un error.  En nuestro caso, el token existe y el JokerService se encuentra en √©l. </li><li>  Cuando se crea el componente, se pasa una instancia de JokerService al constructor como argumento. </li></ol><br><h2 id="change-detection">  Detecci√≥n de cambio </h2><br><p>  A menudo escuchamos, como argumento para usar marcos, algo as√≠ como ‚ÄúEl marco har√° todo por usted, m√°s r√°pido y m√°s eficientemente.  No necesitas pensar en nada.  Solo administra los datos.  Quiz√°s esto sea cierto con una aplicaci√≥n muy simple.  Pero si tiene que trabajar con la entrada del usuario y operar constantemente con datos, solo necesita saber c√≥mo funciona el proceso de detecci√≥n de cambios y representaci√≥n. </p><br><p>  En Angular, la <em>detecci√≥n de cambios</em> es responsable de verificar los cambios.  Como resultado de varias operaciones: cambiar el valor de una propiedad de clase, completar una operaci√≥n asincr√≥nica, responder a una solicitud HTTP, etc., el proceso de verificaci√≥n comienza en todo el √°rbol de componentes. </p><br><p>  Dado que el objetivo principal del proceso es comprender c√≥mo volver a representar un componente, la esencia es verificar los datos utilizados en las plantillas.  Si son diferentes, la plantilla se marca como "cambiada" y se volver√° a dibujar. </p><br><h3 id="zonejs">  Zone.js </h3><br><p>  Comprender c√≥mo Angular realiza un seguimiento de las propiedades de clase y las operaciones sincr√≥nicas es bastante simple.  Pero, ¬øc√≥mo rastrea as√≠ncrono?  La biblioteca Zone.js, creada por uno de los desarrolladores de Angular, es responsable de esto. </p><br><p>  Aqu√≠ est√° lo que es.  Una zona en s√≠ misma es un "contexto de ejecuci√≥n", para decirlo sin rodeos, el lugar y el estado en el que se ejecuta el c√≥digo.  Una vez que se completa la operaci√≥n asincr√≥nica, la funci√≥n de devoluci√≥n de llamada se ejecuta en la misma zona donde se registr√≥.  Entonces Angular descubre d√≥nde ocurri√≥ el cambio y qu√© verificar. </p><br><p>  Zone.js reemplaza con sus implementaciones casi todas las funciones y m√©todos asincr√≥nicos nativos.  Por lo tanto, puede rastrear cu√°ndo se llamar√° la <code>callback</code> una funci√≥n asincr√≥nica.  Es decir, Zone le dice a Angular cu√°ndo y d√≥nde comenzar el proceso de validaci√≥n de cambio. </p><br><h3 id="strategii-obnaruzheniya-izmeneniy">  Estrategias de detecci√≥n de cambios </h3><br><p>  Descubrimos c√≥mo Angular monitorea un componente y ejecuta la verificaci√≥n de cambios.  Ahora imagine que tiene una gran aplicaci√≥n con docenas de componentes.  Y por cada clic, cada operaci√≥n asincr√≥nica, cada solicitud ejecutada con √©xito, se inicia una verificaci√≥n en todo el √°rbol de componentes.  Lo m√°s probable es que dicha aplicaci√≥n tenga serios problemas de rendimiento. </p><br><p>  Los desarrolladores angulares pensaron en esto y nos dieron la oportunidad de establecer una estrategia de detecci√≥n de cambios, cuya elecci√≥n correcta puede aumentar significativamente la productividad. </p><br><p>  Hay dos opciones para elegir: </p><br><ul><li>  Predeterminado: como su nombre indica, esta es la estrategia predeterminada cuando se inicia un CD para cada acci√≥n. </li><li>  OnPush es una estrategia en la que se lanza un CD en solo unos pocos casos: <br><ul><li>  si el valor de <code>@Input()</code> ha cambiado; </li><li>  si ha ocurrido un evento dentro del componente o sus descendientes; </li><li>  si la verificaci√≥n se inici√≥ manualmente; </li><li>  si llega un nuevo evento a Async Pipe. </li></ul></li></ul><br><p>  Basado en mi propia experiencia de desarrollo en Angular, as√≠ como en la experiencia de mis colegas, puedo decir con certeza que siempre es mejor especificar la estrategia <code>OnPush</code> , a menos que el <code>default</code> realmente necesario.  Esto le dar√° varias ventajas: </p><br><ul><li>  Una comprensi√≥n clara de c√≥mo funciona el proceso de CD. </li><li>  Trabajo <code>@Input()</code> con las propiedades <code>@Input()</code> . </li><li>  Ganancia de rendimiento. </li></ul><br><h2 id="rabota-s-input">  Trabajar con <code>@Input()</code> </h2><br><p>  Al igual que otros marcos populares, Angular utiliza un flujo de datos aguas abajo.  El componente acepta par√°metros de entrada que est√°n marcados con el decorador <code>@Input()</code> .  Considere un ejemplo: </p><br><pre> <code class="plaintext hljs">interface IJoke { author: string; text: string; } @Component({ selector: 'joke', template: './joke.template.html', }) export class JokeComponent { @Input() joke: IJoke; }</code> </pre> <br><p>  Supongamos que hay un componente descrito anteriormente que muestra el texto de la broma y el autor.  El problema con esta escritura es que puede mutar accidental o espec√≠ficamente el objeto transferido.  Por ejemplo, sobrescribir texto o autor. </p><br><pre> <code class="plaintext hljs">setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.joke.author = name; }</code> </pre> <br><p>  Noto de inmediato que este es un mal ejemplo, pero muestra claramente lo que podr√≠a suceder.  Para protegerse contra tales errores, debe hacer que los par√°metros de entrada sean de solo lectura.  Gracias a esto, comprender√° c√≥mo trabajar correctamente con los datos y crear un CD.  Basado en esto, la mejor manera de escribir una clase se ver√° as√≠: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'joke', template: './joke.template.html', changeDetection: ChangeDetectionStrategy.OnPush, }) export class JokeComponent { @Input() readonly joke: IJoke; @Output() updateName = new EventEmitter&lt;string&gt;(); setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.updateName.emit(name); } }</code> </pre> <br><p>  El enfoque descrito no es una regla, sino solo una recomendaci√≥n.  Hay muchas situaciones en las que este enfoque ser√° inconveniente e ineficaz.  Con el tiempo, aprender√° a comprender en qu√© caso puede rechazar el m√©todo propuesto para trabajar con entradas. </p><br><h2 id="rxjs">  Rxjs </h2><br><p>  Por supuesto, podr√≠a estar equivocado, pero parece que ReactiveX y la programaci√≥n reactiva en general son una nueva tendencia.  Angular sucumbi√≥ a esta tendencia (o tal vez la cre√≥) y usa RxJS por defecto.  La l√≥gica b√°sica de todo el marco se ejecuta en esta biblioteca, por lo que es muy importante comprender los principios de la programaci√≥n reactiva. </p><br><p>  Pero, ¬øqu√© es RxJS?  Combina tres ideas que revelar√© en un lenguaje bastante simple con algunas omisiones: </p><br><ul><li>  <em>El patr√≥n "Observador"</em> es una entidad que produce eventos, y hay un oyente que recibe informaci√≥n sobre estos eventos. </li><li>  <em>El patr√≥n iterador</em> : le permite obtener acceso secuencial a los elementos de un objeto sin revelar su estructura interna. </li><li>  <em>La programaci√≥n funcional con colecciones</em> es un patr√≥n en el que la l√≥gica se convierte en componentes peque√±os y muy simples, cada uno de los cuales resuelve un solo problema. </li></ul><br><p>  La combinaci√≥n de estos patrones nos permite describir de manera muy simple algoritmos que son complejos a primera vista, por ejemplo: </p><br><pre> <code class="plaintext hljs">private loadUnreadJokes() { this.showLoader(); //   fromEvent(document, 'load') .pipe( switchMap( () =&gt; this.http .get('/api/v1/jokes') //   .pipe(map((jokes: any[]) =&gt; jokes.filter(joke =&gt; joke.unread))), //   ), ) .subscribe( (jokes: any[]) =&gt; (this.jokes = jokes), //   error =&gt; { /*   */ }, () =&gt; this.hideLoader(), //       ); }</code> </pre> <br><p>  Solo 18 l√≠neas con toda la hermosa sangr√≠a.  Ahora intente reescribir este ejemplo en Vanilla o al menos jQuery.  Casi el 100% de esto le llevar√° al menos el doble de espacio y no ser√° tan expresivo.  Aqu√≠ puedes seguir la l√≠nea con los ojos y leer el c√≥digo como un libro. </p><br><h3 id="observable">  Observable </h3><br><p>  Comprender que cualquier dato se puede representar como una secuencia no llega de inmediato.  Por lo tanto, propongo pasar a una analog√≠a simple.  Imagine que una secuencia es una matriz de datos ordenados por tiempo.  Por ejemplo, en esta realizaci√≥n: </p><br><pre> <code class="plaintext hljs">const observable = []; let counter = 0; const intervalId = setInterval(() =&gt; { observable.push(counter++); }, 1000); setTimeout(() =&gt; { clearInterval(intervalId); }, 6000);</code> </pre> <br><p>  Consideraremos que el √∫ltimo valor de la matriz es relevante.  Cada segundo se agregar√° un n√∫mero a la matriz.  ¬øC√≥mo podemos descubrir en otra parte de la aplicaci√≥n que se ha agregado un elemento a la matriz?  En una situaci√≥n normal, llamar√≠amos a alg√∫n tipo de <code>callback</code> de <code>callback</code> y actualizar√≠amos el valor de la matriz, y luego simplemente tomar√≠amos el √∫ltimo elemento. </p><br><p>  Gracias a la programaci√≥n reactiva, no es necesario no solo escribir mucha l√≥gica nueva, sino tambi√©n pensar en actualizar la informaci√≥n.  Esto se puede comparar con un simple oyente: </p><br><pre> <code class="plaintext hljs">document.addEventListener('click', event =&gt; {});</code> </pre> <br><p>  Puede poner una gran cantidad de <code>EventListener</code> en toda la aplicaci√≥n, y funcionar√°n, a menos que, por supuesto, usted se encargue de lo contrario a prop√≥sito. </p><br><p>  La programaci√≥n reactiva tambi√©n funciona.  En un lugar, simplemente creamos un flujo de datos y peri√≥dicamente colocamos nuevos valores all√≠, y en otro, nos suscribimos a este flujo y simplemente escuchamos estos valores.  Es decir, siempre aprendemos sobre la actualizaci√≥n y podemos manejarla. </p><br><p>  Ahora veamos un ejemplo real: </p><br><pre> <code class="plaintext hljs">export class JokesListComponent implements OnInit { jokes$: Observable&lt;IJoke&gt;; authors$ = new Subject&lt;string[]&gt;(); unread$ = new Subject&lt;number&gt;(); constructor(private jokerService: JokerService) {} ngOnInit() { //  ,    subscribe()    this.jokes$ = this.jokerService.getJokes(); this.jokes$.subscribe(jokes =&gt; { this.authors$.next(jokes.map(joke =&gt; joke.author)); this.unread$.next(jokes.filter(joke =&gt; joke.unread).length); }); } }</code> </pre> <br><p>  Gracias a esta l√≥gica, al cambiar los datos en <code>jokes</code> , actualizamos autom√°ticamente los datos sobre el n√∫mero de chistes no le√≠dos y la lista de autores.  Si tiene un par de componentes m√°s, uno de los cuales recopila estad√≠sticas sobre el n√∫mero de chistes le√≠dos por un autor, y el segundo calcula la duraci√≥n promedio de los chistes, entonces las ventajas se vuelven obvias. </p><br><h2 id="testbed">  Banco de pruebas </h2><br><p>  Tarde o temprano, el desarrollador comprende que si el proyecto no es MVP, entonces debe escribir pruebas.  Y cuantas m√°s pruebas se escriban, cuanto m√°s clara y detallada sea su descripci√≥n, m√°s f√°cil, m√°s r√°pido y m√°s confiable ser√° hacer cambios e implementar nuevas funcionalidades. </p><br><p>  Angular probablemente previ√≥ esto y nos dio una poderosa herramienta de prueba.  Muchos desarrolladores al principio intentan dominar alg√∫n tipo de tecnolog√≠a "desde el principio" sin entrar en la documentaci√≥n.  Hice lo mismo, por eso me di cuenta bastante tarde de todas las capacidades de prueba disponibles "listas para usar". </p><br><p>  Puede probar cualquier cosa en Angular, pero si solo necesita crear instancias y comenzar a llamar a m√©todos para probar una clase o servicio regular, la situaci√≥n con el componente es completamente diferente. </p><br><p>  Como ya descubrimos, gracias a las dependencias DI se toman fuera del componente.  Por un lado, esto complica un poco todo el sistema, por otro lado, nos brinda grandes oportunidades para configurar pruebas y verificar muchos casos.  Propongo entender el ejemplo de un componente: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'app-joker', template: '&lt;some-dependency&gt;&lt;/some-dependency&gt;', styleUrls: ['./joker.component.less'], }) export class JokerComponent { constructor( private jokesService: JokesService, @Inject(PARTY_TOKEN) private partyService: PartyService, @Optional() private sleepService: SleepService, ) {} makeNewFriend(): IFriend { if (this.sleepService &amp;&amp; this.sleepService.isSleeping) { this.sleepService.wakeUp(); } const joke = this.jokesService.generateNewJoke(); this.partyService.goToParty('Pacha'); this.partyService.toSay(joke.text); const laughingPeople = this.partyService.getPeopleByReaction('laughing'); const girl = laughingPeople.find(human =&gt; human.sex === 'female'); const friend = this.partyService.makeFriend(girl); return friend; } }</code> </pre> <br><p>  Entonces, en el ejemplo actual hay tres servicios.  Uno se importa de la manera habitual, uno por token y otro servicio es opcional.  ¬øC√≥mo configuramos el m√≥dulo de prueba?  Enseguida mostrar√© la vista terminada: </p><br><pre> <code class="plaintext hljs">beforeEach(async(() =&gt; { TestBed.configureTestingModule({ imports: [SomeDependencyModule], declarations: [JokerComponent], //  ,    providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }).compileComponents(); fixture = TestBed.createComponent(JokerComponent); component = fixture.componentInstance; fixture.detectChanges(); //    ,     }));</code> </pre> <br><p>  <code>TestBed</code> nos permite hacer una simulaci√≥n completa del m√≥dulo requerido.  Puede conectar cualquier servicio, reemplazar m√≥dulos, obtener instancias de clases de un componente y mucho m√°s.  Ahora que tenemos el m√≥dulo ya configurado, pasemos a las posibilidades. </p><br><h3 id="mozhno-izbegat-lishnih-zavisimostey">  Se pueden evitar dependencias innecesarias </h3><br><p>  Una aplicaci√≥n angular consta de m√≥dulos, que pueden incluir otros m√≥dulos, servicios, directivas y m√°s.  En la prueba, necesitamos, de hecho, recrear la operaci√≥n del m√≥dulo.  Si en nuestro ejemplo usamos <code>&lt;some-dependency&gt;&lt;/some-dependency&gt;</code> en la plantilla, esto significa que tambi√©n debemos importar <code>SomeDependencyModule</code> en la prueba.  ¬øY si hay adicciones all√≠?  Entonces, tambi√©n necesitan ser importados. <br>  Si la aplicaci√≥n es compleja, habr√° muchas dependencias de este tipo.  La importaci√≥n de todas las dependencias conducir√° al hecho de que en cada prueba se ubicar√° la aplicaci√≥n completa y se llamar√° a todos los m√©todos.  Quiz√°s esto no nos convenga. </p><br><p>  Hay al menos una forma de deshacerse de las dependencias necesarias: simplemente reescriba la plantilla.  Suponga que tiene pruebas de captura de pantalla o pruebas de integraci√≥n y no hay necesidad de probar la apariencia del componente.  Entonces es suficiente simplemente verificar los m√©todos.  En este caso, puede escribir la configuraci√≥n de la siguiente manera: </p><br><pre> <code class="plaintext hljs">TestBed.configureTestingModule({ declarations: [JokerComponent], providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }) .overrideTemplate(JokerComponent, '') //   ,   .compileComponents();</code> </pre> <br><p> ,    .           ,      . ,          .    ,       , ,    ,     .        ‚Äî    . </p><br><h3 id="mozhno-mokirovat-vse-zavisimosti-iz-konstruktora">       </h3><br><p>     <em>Injection Token</em> ,      .           .      ,       ,   . </p><br><p>        <code>ts-mockito</code> ,     ,    . Angular    ¬´ ¬ª. </p><br><pre> <code class="plaintext hljs">//    export class MockPartyService extends PartyService { meetFriend(): IFriend { return {} as IFriend; } goToParty() {} toSay(some: string) { console.log(some); } } // ... TestBed.configureTestingModule({ declarations: [JokerComponent, MockComponent], providers: [{provide: PARTY_TOKEN, useClass: MockPartyService}], //    }).compileComponents();</code> </pre> <br><p>  Eso es todo         . </p><br><h3 id="mnozhestvo-keysov">   </h3><br><p>       .    ,  ‚Äî  ,   ‚Äî . ,              : </p><br><ul><li>          . </li><li>      ‚Äî ,      .    ‚Äî    . </li></ul><br><p>  ‚Äî       .          ,          .   ‚Äî     . </p><br><h2 id="itog">  Resumen </h2><br><p>       Angular,           .     ,   ,        ¬´¬ª. </p><br><p>      , Angular       - .    HTTP-, , lazy-loading  .            <a href="https://angular.io/docs"> Angular</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480782/">https://habr.com/ru/post/480782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480760/index.html">Trabajar en el extranjero: ¬øen qu√© pa√≠ses est√° Internet m√°s r√°pido?</a></li>
<li><a href="../480762/index.html">V&V no significa venganza</a></li>
<li><a href="../480774/index.html">No nginx unificado: Ayhor hosting - dash-scratch live</a></li>
<li><a href="../480776/index.html">Implementamos Active Directory por todos los m√©todos posibles.</a></li>
<li><a href="../480778/index.html">Gesti√≥n de gestos: manejo de superposiciones visuales. Parte 2</a></li>
<li><a href="../480786/index.html">Clonaci√≥n profunda independiente de objetos en JavaScript</a></li>
<li><a href="../480788/index.html">√Årbol de navidad en la l√≠nea de comando</a></li>
<li><a href="../480790/index.html">"Eficiencia de f√°brica". Encontrar un cuello de botella e implementar un sistema de extracci√≥n para aumentar la productividad</a></li>
<li><a href="../480792/index.html">Ingenier√≠a de regalos</a></li>
<li><a href="../480794/index.html">Un poco sobre el caso especial de la implementaci√≥n de algoritmos de b√∫squeda de puertas abiertas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>