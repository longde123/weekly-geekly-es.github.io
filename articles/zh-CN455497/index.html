<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏻 ➿ 🌈 最佳线性滤波：从梯度下降到自适应滤波器 👧🏿 🎳 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在硕士专业“通信与信号处理”（TU Ilmenau）中开发摘要主题时，我想继续学习“自适应与阵列信号处理”课程的主要主题之一。 即，自适应滤波的基础。 


 本文最初是为谁编写的： 
 
 1）对于本地专业的学生团体； 
 2）对于准备实践研讨会但尚未决定工具的老师-以下是python和Matla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>最佳线性滤波：从梯度下降到自适应滤波器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455497/"><p> 在硕士专业“通信与信号处理”（TU Ilmenau）中开发摘要主题时，我想继续学习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“自适应与阵列信号处理”</a>课程的主要主题之一。 即，自适应滤波的基础。 </p><br><p>  <u>本文最初是为谁编写的：</u> <u><br></u> <br>  1）对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本地专业</a>的学生团体； <br>  2）对于准备实践研讨会但尚未决定工具的老师-以下是<strong>python</strong>和<strong>Matlab / Octave</strong>中的示例； <br>  3）对于任何对过滤主题感兴趣的人。 </p><br><p>  <u>可以在切割下找到什么：</u> <u><br></u> <br>  1）来自理论的信息，我试图尽可能简洁地进行整理，但在我看来，这是翔实的； <br>  2）滤波器使用示例：特别是作为天线阵列均衡器的一部分； <br>  3）链接到基本文献和开放库（使用python），这可能对研究有用。 </p><br><p> 一般来说，欢迎您，让我们按要点对所有内容进行排序。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2f1/98b/d67/2f198bd673789161db58ad770c629faf.jpg"></p><a name="habracut"></a><br><p>  <em>我想，照片中沉思的人对许多人来说都是Norbert Wiener所熟悉的。</em>  <em>在大多数情况下，我们将研究他的名字的过滤条件。</em>  <em>但是，不能不提及我们的同胞安德烈·尼古拉耶维奇·科尔莫戈洛夫（Andrei Nikolaevich Kolmogorov），他在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1941年的文章</a>也为最优滤波理论的发展做出了重要贡献，即使在英语中也被称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kolmogorov-Wiener滤波理论</a> 。</em> </p><br><h2 id="chto-rassmatrivaem"> 我们在考虑什么？ </h2><br><p> 今天，我们正在考虑具有有限冲激响应（FIR，有限冲激响应）的经典滤波器，可以通过以下简单电路来对其进行描述（图1）。 </p><br><p><img src="https://habrastorage.org/webt/to/or/u7/tooru7vj_f6aj0oe9wvpcde28kw.png"></p><br><p>  <em>图1。</em>  <em>研究维纳滤波器的FIR滤波器方案[1。</em>  <em>第117页]</em> </p><br><p> 我们将以矩阵形式编写此展位输出的确切信息： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/615/39b/43f61539ba1f68998b24c39a8c539706.svg" alt="e（n）= d（n）-\ hat {d}（n | \ mathcal {U} _n）= d（n）-\ mathbf {w} ^ H \ mathbf {u} \ qquad（1）"></div><br><p> 解密符号： </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/6c5/882/04e/6c588204ed25c8bbb270106d7f08a4dd.svg" alt="e（n）"> 给定和接收信号之间的差异（误差）是 </li><li><img src="https://habrastorage.org/getpro/habr/post_images/771/807/bef/771807bef08a5612654d97e67695cf07.svg" alt="d（n）"> 是一些预定义的信号 </li><li><img src="https://habrastorage.org/getpro/habr/post_images/960/b4e/a48/960b4ea48f3968f42c64eed1af640e1d.svg" alt="\ mathbf {u}"> 是样本的向量，或者换句话说，是滤波器输入端的信号 </li><li><img src="https://habrastorage.org/getpro/habr/post_images/75f/f22/a5a/75ff22a5a4f95cbe489056bf704597f0.svg" alt="\ hat {d}（n | \ mathcal {U} _n）"> 信号在滤波器输出端吗 </li><li><img src="https://habrastorage.org/getpro/habr/post_images/6f6/81f/9be/6f681f9be2ae30d1666fec498b59b3a3.svg" alt="\ mathbf {w} ^ H">  -这是滤波器系数向量的Hermitian共轭-滤波器<u>的适应性在于它们的最佳选择</u> </li></ul><br><p> 您可能已经猜到了，我们将努力在给定信号和滤波信号之间寻求最小的差异，即最小的误差。 这意味着我们正面临优化任务。 </p><br><h2 id="chto-budem-optimizirovat"> 我们将优化什么？ </h2><br><p> 为了优化或最小化，我们不仅会<strong>表示</strong>误差， <strong>均方误差</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MSE-均方误差</a> ）： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/b62/193/b83b62193ca3490681c2cd8910e4d99a.svg" alt="MSE：J（\ mathbf {w}）= E \ {e（n）^ 2 \} \ qquad（2）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/c48/76a/b10/c4876ab1024579fa30ea997a45efd50a.svg" alt="J（\ mathbf {w}）"> 表示滤波器系数向量的代价函数，并且 <img src="https://habrastorage.org/getpro/habr/post_images/f39/8e4/ded/f398e4ded6db9e55108d575a9b7d2f1f.svg" alt="E \ {* \}"> 表示垫子。 等待中。 </p><br><p> 这种情况下的平方非常令人愉快，因为这意味着我们面临着<em>凸编程</em>的问题（我只用谷歌英语<em>凸优化</em>的类似物），这反过来意味着一个<u>极值</u> （在我们的例子中是最小）。 </p><br><p><img src="https://habrastorage.org/webt/hr/xj/mb/hrxjmbmimv7c2uvvicnuklqn9y0.png"></p><br><p>  <em>图2。</em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表面的均方误差</a> 。</em> </p><br><p> 我们的误差函数具有规范形式[1，第121页]： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/121/788/5da121788f801656b55ee459c2f4d56d.svg" alt="J（\ mathbf {w}）= \ sigma ^ 2_d-\ mathbf {w} ^ H \ mathbf {p}-\ mathbf {p} ^ H \ mathbf {w} + \ mathbf {w} ^ H \ mathbf { R} \ mathbf {w} \ qquad（3）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/24f/50c/410/24f50c410ab0c2ca3dd302c630c734e8.svg" alt="\ sigma ^ 2_d"> 是预期信号的方差， <img src="https://habrastorage.org/getpro/habr/post_images/82c/861/559/82c86155992ccb2e83d6f9f3f9e92737.svg" alt="\ mathbf {p} = E \ {\ mathbf {u}（n）d ^ *（n）\}"> 是输入矢量和期望信号之间的互相关矢量，并且 <img src="https://habrastorage.org/getpro/habr/post_images/664/01c/a88/66401ca883516093b2e73b7d519588ac.svg" alt="\ mathbf {R} = E \ {\ mathbf {u}（n）\ mathbf {u} ^ H（n）\}"> 是输入信号的自相关矩阵。 </p><br><div class="spoiler">  <b class="spoiler_title">这个公式的结论在这里（我更清楚地尝试过）。</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/q6/sw/p5/q6swp5meopsxauj7yvygkwuc7-g.png" width="650"></div></div><br><p> 如上所述，如果我们谈论凸编程，那么我们将有一个极值（最小）。 因此，要找到成本函数的最小值（最小均方根误差），找到切线斜率的切线就足够了，换句话说， <u>就</u>我们的研究变量<u>而言</u> ，找到<u>偏导数就</u>足够了： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cd/d0b/114/1cdd0b114b5457761dd27338b4ee57f4.svg" alt="\ frac {\ delta J（\ mathbf {w}）} {\ delta w ^ *} =-\ mathbf {p} + \ mathbf {R} \ mathbf {w} \ qquad（4）"></div><br><p> 在最佳情况下（ <img src="https://habrastorage.org/getpro/habr/post_images/ac6/219/d1c/ac6219d1cc1885e6f5936e40b5c7a980.svg" alt="\ mathbf {w} = \ mathbf {w} _ {opt}">  ），误差当然应该很小，这意味着我们将导数等于零： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/777/46e/9a7/77746e9a7ab3ff9df3cf340da4b7238d.svg" alt="\ mathbf {R} \ mathbf {w} _ {opt} = \ mathbf {p} \ qquad（5）"></div><br><p> 实际上，这里是我们的炉子，从中我们可以进一步跳动：在我们前面的是一个<u>线性方程组</u> 。 </p><br><h2 id="kak-budem-reshat"> 我们将如何决定？ </h2><br><p> 应当立即指出，在这种情况下，我们将在下面讨论的两种解决方案都是理论上和教育上的，因为 <img src="https://habrastorage.org/getpro/habr/post_images/1cf/d71/499/1cfd714992b16fcc961ad10bcc855134.svg" alt="\ mathbf {R}"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/1fa/0e8/e9e/1fa0e8e9e33d7dbd533901bbf025bd9f.svg" alt="\ mathbf {p}"> 事先已知（也就是说，我们据称有能力收集足够的统计数据来进行计算）。 但是，这里对此类简化示例的分析是理解基本方法的最佳方式。 </p><br><h3 id="analiticheskoe-reshenie"> 分析溶液 </h3><br><p> 可以说，可以使用反矩阵在额头上解决此问题： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/c3e/052/759c3e052c502aa04fe6da682a41ea2a.svg" alt="\ mathbf {w} _ {opt} = \ mathbf {R} ^ {-1} \ mathbf {p} \ qquad（6）"></div><br><p> 这样的表达式称为维纳-霍普夫方程-它仍然对我们有用。 </p><br><blockquote> 当然，要完全谨慎，以一般的方式记下这种情况可能更正确，即 不与 <img src="https://habrastorage.org/getpro/habr/post_images/bd8/f0f/04a/bd8f0f04a92fe1055c350d4e32a8a256.svg" alt="^ {-}"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/017/3d5/ed9/0173d5ed99b25d00ec4245287142f165.svg" alt="^ +">  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伪反转</a> ）： <br><img src="https://habrastorage.org/getpro/habr/post_images/003/47f/bca/00347fbca15f40943c7fb7b20c38a3f9.svg" alt="\ mathbf {R} ^ + = \ mathbf {R} ^ H（\ mathbf {R} \ mathbf {R} ^ H）^ {-1}"><br><br> 但是，自相关矩阵不能是非平方或奇异的，因此，很正确地，我们认为不存在矛盾。 </blockquote><p> 从该方程式可以分析得出成本函数的最小值等于多少（即在我们的情况下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MMSE-</a>最小均方误差）： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/d2d/1f9/c00d2d1f9427762a17deae92ae3ea77c.svg" alt="J_ {min} = J（\ mathbf {w} _ {opt}）= \ sigma ^ 2_d-\ mathbf {p} ^ H \ mathbf {R} ^ {-1} \ mathbf {p} \ qquad（7）"></div><br><div class="spoiler">  <b class="spoiler_title">公式的推导在这里（我也尝试过使其更生动）。</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ds/vh/nx/dsvhnxoudmo_qd4hesg_qkysdg8.jpeg"></p></div></div><br><p> 好吧，有一种解决方案。 </p><br><h3 id="reshenie-iterativnym-metodom"> 迭代解 </h3><br><p> 但是，是的，可以解决线性方程组而无需反演自相关矩阵的情况（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以节省计算量</a> ）。 为此，请考虑使用本机且易于理解<strong>的梯度下降</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法（最陡/梯度下降方法</a> ）。 </p><br><p> 该算法的实质可以简化为以下几点： </p><br><ol><li> 我们将所需变量设置为某个默认值（例如， <img src="https://habrastorage.org/getpro/habr/post_images/231/554/6f0/2315546f0e8aa127a8da693d41c53ff6.svg" alt="\ mathbf {w}（0）= \ mathbf {0}">  ） </li><li> 选择一些步骤 <img src="https://habrastorage.org/getpro/habr/post_images/849/a42/16c/849a4216c1bc55877bc86f4a97513f7a.svg" alt="\亩">  （我们如何选择，我们将在下面讨论）。 </li><li> 然后，实际上，我们沿着给定的步骤沿着原始曲面（在本例中，这是MSE曲面）下降 <img src="https://habrastorage.org/getpro/habr/post_images/849/a42/16c/849a4216c1bc55877bc86f4a97513f7a.svg" alt="\亩"> 并由梯度的大小确定一定的速度。 </li></ol><br><p> 因此，名称为： <em>梯度</em> -梯度或<em>最陡</em> -逐步<em>下降</em> -下降。 </p><br><p> 在我们的案例中，梯度是已知的：实际上，是在微分成本函数时发现的（表面为凹面，与[1，p。220]比较）。 我们写了所需变量（滤波器系数）的迭代更新公式如何看起来像[1，p。  220]： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/4ff/7eb/6d64ff7eb98c4274e05a33a3eb127933.svg" alt="\ mathbf {w}（n + 1）= \ mathbf {w}（n）-\ mu [-\ mathbf {p} + \ mathbf {R} \ mathbf {w}（n）] \ qquad（8）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="ñ"> 是迭代次数。 </p><br><p> 现在让我们谈谈选择步长的方法。 </p><br><p> 我们列出了明显的前提： </p><br><ul><li> 步骤不能为负或零 </li><li> 步长不应太大，否则算法将不会收敛（实际上，它会从一条边跳到另一边，而不会陷入极端） </li><li> 当然，步长可能很小，但这也不是完全理想的-算法将花费更多时间 </li></ul><br><p> 关于维纳过滤器，当然，很早以前就已经发现了限制条件[1，第222-226页]： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/64a/b6c/67d64ab6cf46d3438791ccea853421fb.svg" alt="0 <\ mu <\ frac {2} {\ lambda_ {max}} \ qquad（9）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/e5d/fa8/35d/e5dfa835ded907ecd7cf2b56d7061307.svg" alt="\ lambda_ {max}"> 是自相关矩阵的最大特征值 <img src="https://habrastorage.org/getpro/habr/post_images/1cf/d71/499/1cfd714992b16fcc961ad10bcc855134.svg" alt="\ mathbf {R}">  。 </p><br><blockquote> 顺便说一下，在线性滤波的背景下，特征值和向量是一个单独的有趣主题。 在这种情况下，甚至有一个完整的本<em>征滤波器</em> （请参阅附录1）。 </blockquote><p> 幸运的是，这还不是全部。 还有一个最佳的自适应解决方案： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4c/3c2/fdf/f4c3c2fdf8ae926094bb67b391cd896b.svg" alt="\ mu（n）= \ frac {\ mathbf {\ gamma}（n）^ H \ mathbf {\ gamma}（n）} {\ mathbf {\ gamma}（n）^ H \ mathbf {R} \ mathbf { \ gamma}（n）} \ qquad（10）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/1b0/4a6/a31/1b04a6a318f99ec501290f59c0f924ac.svg" alt="\ mathbf {\ gamma}（n）= \ mathbf {p}-\ mathbf {R} \ mathbf {w}（n）"> 是负梯度。 从公式中可以看出，该步骤将重新计算到每次迭代中，也就是说，它可以适应。 </p><br><div class="spoiler">  <b class="spoiler_title">公式的结论在这里（很多数学-只看像我这样臭名昭著的书呆子）。</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/au/hq/0s/auhq0sxrspaduxdkclqctns1xtw.jpeg"></p></div></div><br><p> 好的，对于第二个决定，我们也做好了准备。 </p><br><h2 id="a-nelzya-li-na-primerah"> 但是有可能举例吗？ </h2><br><p> 为了清楚起见，我们将进行一个小的模拟。 我们将使用<strong>Python 3.6.4</strong> 。 </p><br><blockquote> 我将立即说这些示例是一项家庭作业的一部分，每项作业将在两周内提供给学生以解决。 我在python下重写了该部分（以便在无线电工程师中普及该语言）。 也许您会在网上找到其他以前的学生的其他选择。 </blockquote><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.linalg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> toeplitz <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convmtx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h,n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toeplitz(np.hstack([h, np.zeros(n<span class="hljs-number"><span class="hljs-number">-1</span></span>)]),\ np.hstack([h[<span class="hljs-number"><span class="hljs-number">0</span></span>], np.zeros(n<span class="hljs-number"><span class="hljs-number">-1</span></span>)])) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MSE_calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sigmaS, R, p, w)</span></span></span><span class="hljs-function">:</span></span> w = w.reshape(w.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) wH = np.conj(w).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, w.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) p = p.reshape(p.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) pH = np.conj(p).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, p.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) MSE = sigmaS - np.dot(wH, p) - np.dot(pH, w) + np.dot(np.dot(wH, R), w) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MSE[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mu_opt_calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gamma, R)</span></span></span><span class="hljs-function">:</span></span> gamma = gamma.reshape(gamma.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) gammaH = np.conj(gamma).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, gamma.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) mu_opt = np.dot(gammaH, gamma) / np.dot(np.dot(gammaH, R), gamma) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu_opt[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p> 我们将使用线性滤波器解决<u>信道均衡</u>问题，其主要目的是<u>均衡</u>该信道对有用信号的各种影响。 </p><br><blockquote> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>或<a href="">此处的</a>一个文件中下载源代码（是的，我有这样的爱好-编辑Wikipedia）。 </blockquote><br><h3 id="model-sistemy"> 系统型号 </h3><br><p> 假设有一个天线阵列（我们已经在有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MUSIC</a>的文章中对其进行了检查）。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/61a/9c2/da7/61a9c2da745081459f9001d0252936f1.png"></p><br><p>  <em>图</em>  <em>3.无方向性线性天线阵列（ULAA-均匀线性天线阵列）[2，p。</em>  <em>32]。</em> </p><br><p> 定义初始晶格参数： </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (number of sensors)</span></span></code> </pre> <br><p> 在本文中，我们将考虑<u>带有衰落</u>的<u>宽带信道之</u>类的东西，其特征是<u>多径传播</u> 。 对于这种情况，通常采用一种方法，其中使用一定幅度的延迟对每个波束建模（图4）。 </p><br><p><img src="https://habrastorage.org/webt/3t/tc/va/3ttcvau0o4njat-1beejefcudpy.png"></p><br><p>  <em>图</em>  <em>4.具有n个固定延迟的宽带信道模型[3，p。2]。</em>  <em>29]。</em>  <em>如您所知，特定名称不起作用-在接下来的内容中，我们将使用略有不同的名称。</em> </p><br><p> 一个传感器的接收信号模型表示如下： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/c3f/2f0/a3fc3f2f0cd278622946ce2da28005fd.svg" alt="x（n）= \ sum_ {l = 0} ^ Lh（l）s（n-l）+ \ nu（n）"></div><br><p> 在这种情况下 <img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="ñ"> 表示参考编号， <img src="https://habrastorage.org/getpro/habr/post_images/e9f/c39/8e5/e9fc398e58e24442ddc2cf11684debbc.svg" alt="小时（l）"> 是信道沿着第<em>l</em>束的响应， <em>L</em>是延迟寄存器的数量， <em>s</em>是传输的（有用的）信号， <img src="https://habrastorage.org/getpro/habr/post_images/270/81a/400/27081a40025995898a2b982ff59a7e39.svg" alt="\ nu（n）">  -加性噪声。 </p><br><p> 对于多个传感器，公式将采用以下形式： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/835/aa7/c0e835aa74d5dccf4ccdf625ebcc88b4.svg" alt="\ mathbf {x}（n）= \ mathbf {H} \ mathbf {s}（n）+ \ mathbf {\ nu}（n）"></div><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/b0e/184/0ed/b0e1840edef9169f3e1f52974bea066d.svg" alt="\ mathbf {x}（n）"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/270/81a/400/27081a40025995898a2b982ff59a7e39.svg" alt="\ mathbf {\ nu}（n）">  -有尺寸 <img src="https://habrastorage.org/getpro/habr/post_images/132/724/0f2/1327240f26480a83dffca393bb730c44.svg" alt="M \次1"> 尺寸 <img src="https://habrastorage.org/getpro/habr/post_images/ed0/8c1/e77/ed08c1e77cfaf357d5e90e9e2ae918aa.svg" alt="\ mathbf {H}"> 等于 <img src="https://habrastorage.org/getpro/habr/post_images/25e/e63/fbb/25ee63fbb4a32f1a00d5c02aaea9b80c.svg" alt="M \次（M-L）">  ，以及尺寸 <img src="https://habrastorage.org/getpro/habr/post_images/5e3/d36/045/5e3d360455a5a33db6c17f93c119a694.svg" alt="\ mathbf {s}（n）"> 等于 <img src="https://habrastorage.org/getpro/habr/post_images/6e2/fc1/636/6e2fc16365ac2698555dd979ed6b5eeb.svg" alt="（M-L）\倍1">  。 </p><br><p> 假设由于波以一定角度入射，每个传感器还接收到具有一定延迟的信号。 矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/ed0/8c1/e77/ed08c1e77cfaf357d5e90e9e2ae918aa.svg" alt="\ mathbf {H}"> 在我们的例子中，它将是每条射线的响应向量的卷积矩阵。 我认为代码会更清晰： </p><br><pre> <code class="python hljs">h = np.array([<span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">0.779</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">0.722</span></span>, <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">1.862</span></span>]) L = len(h)<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment"># number of signal sources H = convmtx(h,ML) print(H.shape) print(H)</span></span></code> </pre> <br><p> 结论将是： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; array([[ <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> ], [<span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>, <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> ], [<span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>, <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>]])</code> </pre> <br><p> 接下来，我们为有用的信号和噪声设置初始数据： </p><br><pre> <code class="python hljs">sigmaS = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (the signal's s(n) power) sigmaN = 0.01 #   (the noise's n(n) power)</span></span></code> </pre> <br><p> 现在我们转到相关性。 </p><br><pre> <code class="python hljs">Rxx = (sigmaS)*(np.dot(H,np.matrix(H).H))+(sigmaN)*np.identity(M) p = (sigmaS)*H[:,<span class="hljs-number"><span class="hljs-number">0</span></span>] p = p.reshape((len(p), <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">这里公式的推导（也是最绝望的工作表）。</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hi/lh/ks/hilhksxoc_rkum_5ibn3m42ukxc.jpeg"></p></div></div><br><p> 我们找到了维纳的解决方案： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Solution of the Wiener-Hopf equation: wopt = np.dot(np.linalg.inv(Rxx), p) MSEopt = MSE_calc(sigmaS, Rxx, p, wopt)</span></span></code> </pre> <br><p> 现在，让我们继续进行梯度下降法。 </p><br><p> 找到最大特征值，以便可以从中推导台阶的上边界（参见公式（9））： </p><br><pre> <code class="python hljs">lamda_max = max(np.linalg.eigvals(Rxx))</code> </pre> <br><p> 现在，让我们设置一些步骤，这些步骤将构成最大值的一部分： </p><br><pre> <code class="python hljs">coeff = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>]) mus = <span class="hljs-number"><span class="hljs-number">2</span></span>/lamda_max*coeff <span class="hljs-comment"><span class="hljs-comment"># different step sizes</span></span></code> </pre> <br><p> 定义最大迭代次数： </p><br><pre> <code class="python hljs">N_steps = <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br><p> 运行算法： </p><br><pre> <code class="python hljs">MSE = np.empty((len(mus), N_steps), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> mu_idx, mu <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(mus): w = np.zeros((M,<span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> N_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N_steps): w = w - mu*(np.dot(Rxx, w) - p) MSE[mu_idx, N_i] = MSE_calc(sigmaS, Rxx, p, w)</code> </pre> <br><p> 现在，我们将执行相同的操作，但对于自适应步骤（公式（10））： </p><br><pre> <code class="python hljs">MSEoptmu = np.empty((<span class="hljs-number"><span class="hljs-number">1</span></span>, N_steps), dtype=complex) w = np.zeros((M,<span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> N_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N_steps): gamma = p - np.dot(Rxx,w) mu_opt = mu_opt_calc(gamma, Rxx) w = w - mu_opt*(np.dot(Rxx,w) - p) MSEoptmu[:, N_i] = MSE_calc(sigmaS, Rxx, p, w)</code> </pre> <br><p> 您应该得到这样的内容： </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><pre> <code class="python hljs">x = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, N_steps+<span class="hljs-number"><span class="hljs-number">1</span></span>)] plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(coeff): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item == <span class="hljs-number"><span class="hljs-number">1</span></span>: item = <span class="hljs-string"><span class="hljs-string">''</span></span> plt.loglog(x, np.abs(MSE[idx, :]),\ label=<span class="hljs-string"><span class="hljs-string">'$\mu = '</span></span>+str(item)+<span class="hljs-string"><span class="hljs-string">'\mu_{max}$'</span></span>) plt.loglog(x, np.abs(MSEoptmu[<span class="hljs-number"><span class="hljs-number">0</span></span>, :]),\ label=<span class="hljs-string"><span class="hljs-string">'$\mu = \mu_{opt}$'</span></span>) plt.loglog(x, np.abs(MSEopt*np.ones((len(x), <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex)),\ label = <span class="hljs-string"><span class="hljs-string">'Wiener solution'</span></span>) plt.grid(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Number of steps'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Mean-Square Error'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">'Steepest descent'</span></span>) plt.legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/il/fa/8d/ilfa8dmoxgt4sjitiyvwbdjga6m.png"></p><br><p>  <em>图</em>  <em>5.学习不同大小步长的曲线。</em> </p><br><p> 为了说明有关梯度下降的要点，紧固件： </p><br><ul><li> 不出所料，最佳步骤可提供最快的收敛速度； </li><li> 不再意味着更好：超出上限之后，我们根本没有达到收敛。 </li></ul><br><p> 因此，我们找到了滤波器系数的最佳矢量，它可以最佳地平化通道的效果-我们<u>训练了均衡器</u> 。 </p><br><h2 id="a-est-chto-to-bolee-blizkoe-k-realnosti"> 有没有更接近现实的东西？ </h2><br><p> 当然可以！ 我们已经说过好几次了，在实时系统中收集统计数据（即计算相关矩阵和向量）远非总是负担得起的。 但是，人类已经适应了这些困难：在实践中，不是采用<em>确定性</em>方法，而是使用了<u>自适应</u>方法。 它们可以分为两个大组[1，p。1。  246]： </p><br><ul><li>  <em>概率（随机）</em> （例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SG-</a>随机梯度） </li><li> 并基于<em>最小二乘</em>法（例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LMS-</a>最小均方或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RLS-</a>递归最小二乘） </li></ul><br><p> 自适应过滤器的主题在开源社区（python示例）中得到了很好的体现： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">热声</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Padasip</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">适应过滤</a> </li></ul><br><blockquote> 在第二个示例中，我特别喜欢该文档。 但是，要小心！ 当我测试<strong>padasip</strong>软件包时，在处理复数时遇到了困难（默认情况下，float64隐含在其中）。 当使用某些其他实现时，可能会出现相同的问题。 </blockquote><p> 当然，算法各有优缺点，其总和决定了算法的范围。 </p><br><p> 让我们快速看一下示例：我们将考虑已经提到的三种算法<em>SG</em> ， <em>LMS</em>和<em>RLS</em> （我们将以MATLAB语言进行建模-我承认，已经存在空白，为了...而将所有内容重写为均一Python）。 </p><br><p>  <em>LMS</em>和<em>RLS</em>算法的说明可以在例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">padasip</a>扩展坞中找到。 </p><br><div class="spoiler">  <b class="spoiler_title">SG的描述可以在这里找到。</b> <div class="spoiler_text"><p> 与梯度下降的主要区别是可变梯度： </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76f/9e3/fbb/76f9e3fbbb4c7643f5af595103791091.svg" alt="\ mathbf {w} [n] = \ mathbf {w} [n-1] + \ mu \左（\ mathbf {\ hat {p}} [n]-\ mathbf {\ hat {R}} _ {xx } [n] \ mathbf {w} [n-1] \右）"></div><br><p> 在 </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/bac/0aa/633bac0aae95be15cd31a312b4e0d2c5.svg" alt="\ mathbf {\ hat {R}} _ {xx} [n] = \ frac {1} {n} \ left（（n-1）\ mathbf {\ hat {R}} _ {xx} [n-1 ] + \ mathbf {x} [n] \ mathbf {x} [n] ^ H \右）"></div><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f7/bfd/f81/4f7bfdf81571e19eac474c7a8c380093.svg" alt="\ mathbf {\ hat {p}} [n] = \ frac {1} {n} \ left（（n-1）\ mathbf {\ hat {p}} [n-1] + \ mathbf {x} [ n] d [n] ^ * \右）"></div></div></div><br><p>  1）与上述情况类似的情况。 </p><br><div class="spoiler">  <b class="spoiler_title">来源（MatLab /八度）。</b> <div class="spoiler_text"><p> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>下载资源。 </p></div></div><br><p><img src="https://habrastorage.org/webt/ff/zm/hq/ffzmhqsrnwvvc0hdrcyzhapropw.png"></p><br><p>  <em>图</em>  <em>6. LMS，RLS和SG的学习曲线。</em> </p><br><p> 可以立即注意到，由于LMS算法相对简单，原则上可能不会以较大步长获得最佳解决方案。  RLS给出最快的结果，但是它也可能由于相对较小的<em>遗忘因子而</em>失败。 到目前为止，SG表现不错，但让我们来看另一个示例。 </p><br><p>  2）频道随时间变化的情况。 </p><br><div class="spoiler">  <b class="spoiler_title">来源（MatLab /八度）。</b> <div class="spoiler_text"><p> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>下载资源。 </p></div></div><br><p><img src="https://habrastorage.org/webt/v-/9d/sx/v-9dsxxwzr9jnbnswf0dmnvqrcu.png"></p><br><p>  <em>图</em>  <em>7.学习LMS，RLS和SG的曲线（通道随时间变化）。</em> </p><br><p> 而这里的情况已经变得更加有趣：随着信道响应的急剧变化，LMS已经似乎是最可靠的解决方案。 谁会想到的。 尽管具有正确遗忘因子的RLS也可以提供可接受的结果。 </p><br><div class="spoiler">  <b class="spoiler_title">关于性能的几句话。</b> <div class="spoiler_text"><p> 是的，当然每种算法都有其特定的计算复杂度，但是根据我的测量，我的旧机器可以在LMS和SG的情况下每次迭代处理大约120μs的时间，而在RLS的情况下每次迭代处理250 s的时间。 即，通常该差异是可比较的。 </p></div></div><br><p> 今天就这些了。 感谢所有看过的人！ </p><br><h2 id="literatura"> 文学作品 </h2><br><ol><li>  Haykin SS自适应滤波器理论。  -印度Pearson Education，2005年。 </li><li>  Haykin，Simon和KJ Ray Liu。 阵列处理和传感器网络手册。 卷  63.约翰·威利父子（John Wiley＆Sons），2010年。  102-107 </li><li>  Arndt，D.（2015年）。 陆上移动卫星接收的信道建模（博士学位论文）。 </li></ol><br><h2 id="prilozhenie-1"> 附录1 </h2><br><div class="spoiler">  <b class="spoiler_title">本征过滤器</b> <div class="spoiler_text"><p> 这种滤波器的主要目的是使信噪比（SNR）最大化。 </p><br><p><img src="https://habrastorage.org/webt/kk/v_/uu/kkv_uu-08dppu5i4yhkucc_b0ww.jpeg"></p><br><p> 但是从计算中存在相关性来看，这也更多是一种理论构造，而不是实际解决方案。 </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455497/">https://habr.com/ru/post/zh-CN455497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455483/index.html">艾达（Ai-Da）艺术家：人形机器人为其首次个展做准备</a></li>
<li><a href="../zh-CN455485/index.html">Check Point脚本-直接从Smart Console执行脚本</a></li>
<li><a href="../zh-CN455487/index.html">培训Cisco 200-125 CCNA v3.0。 第10天。交换机端口操作模式</a></li>
<li><a href="../zh-CN455489/index.html">将第三方音频和视频解决方案连接到Microsoft Teams</a></li>
<li><a href="../zh-CN455493/index.html">Angular 8版本的新功能</a></li>
<li><a href="../zh-CN455499/index.html">拔智齿：这是怎么做的？</a></li>
<li><a href="../zh-CN455501/index.html">好莱坞如何秘密使用AI做出关键的拍摄决策</a></li>
<li><a href="../zh-CN455503/index.html">成为一名有效的Angular开发人员需要学习的19个概念</a></li>
<li><a href="../zh-CN455505/index.html">React应用加速四倍</a></li>
<li><a href="../zh-CN455507/index.html">Datatable Python软件包概述</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>