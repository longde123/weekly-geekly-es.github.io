<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèø ‚õ∏Ô∏è üôè Guia do Node.js, parte 8: protocolos HTTP e WebSocket üóÉÔ∏è üéπ üêÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Node.js √© uma plataforma de servidor. A principal tarefa do servidor √© processar solicita√ß√µes de clientes, em particular, de navegadores, da maneira...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do Node.js, parte 8: protocolos HTTP e WebSocket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  O Node.js √© uma plataforma de servidor.  A principal tarefa do servidor √© processar solicita√ß√µes de clientes, em particular, de navegadores, da maneira mais r√°pida e eficiente poss√≠vel.  A oitava parte da tradu√ß√£o do tutorial Node.js. que publicamos hoje √© sobre os protocolos HTTP e WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Aconselhamos a ler] Outras partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informa√ß√µes gerais e introdu√ß√£o</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript, V8, alguns truques de desenvolvimento</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hospedagem, REPL, trabalho com o console, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos npm, package.json e package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">npm e npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loop de eventos, pilha de chamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa√ß√£o ass√≠ncrona</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, Parte 8: Protocolos HTTP e WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, parte 9: trabalhando com o sistema de arquivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Node.js, Parte 10: M√≥dulos padr√£o, fluxos, bancos de dados, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDF completo do Guia Node.js.</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O que acontece ao fazer solicita√ß√µes HTTP?</font> </h2><br>  Vamos falar sobre como os navegadores fazem solicita√ß√µes para servidores usando o protocolo HTTP / 1.1. <br><br>  Se voc√™ j√° teve uma entrevista no campo de TI, poder√° ser perguntado o que acontece quando voc√™ digita algo na barra de endere√ßos do seu navegador e pressiona Enter.  Talvez essa seja uma das perguntas mais populares que ocorrem nessas entrevistas.  Qualquer pessoa que fa√ßa essas perguntas quer saber se voc√™ pode explicar alguns conceitos bastante simples e descobrir se voc√™ entende os princ√≠pios da Internet. <br><br>  Esta quest√£o aborda muitas tecnologias, para entender os princ√≠pios gerais dos quais significa entender como √© constru√≠do um dos sistemas mais complexos j√° constru√≠dos pela humanidade, que abrange o mundo inteiro. <br><br><h3>  <font color="#3AC1EF">‚ñç protocolo HTTP</font> </h3><br>  Os navegadores modernos s√£o capazes de distinguir os URLs reais inseridos na barra de endere√ßos das consultas de pesquisa, para o processamento do qual o mecanismo de pesquisa padr√£o geralmente √© usado.  Vamos falar sobre URLs.  Se voc√™ inserir um endere√ßo de site, como <code>flaviocopes.com</code> , na linha do navegador, o navegador converter√° esse endere√ßo no formato <code>http://flaviocopes.com</code> , com base na suposi√ß√£o de que o protocolo HTTP ser√° usado para trocar dados com o recurso especificado.  Observe que no Windows, o que falaremos aqui pode parecer um pouco diferente do que no macOS e Linux. <br><br><h3>  <font color="#3AC1EF">Phase fase de pesquisa de DNS</font> </h3><br>  Portanto, o navegador, iniciando o trabalho de download de dados do endere√ßo solicitado pelos usu√°rios, executa a opera√ß√£o de Pesquisa de DNS (Pesquisa de DNS) para descobrir o endere√ßo IP do servidor correspondente.  Os nomes simb√≥licos dos recursos inseridos na barra de endere√ßos s√£o convenientes para as pessoas, mas o dispositivo da Internet implica a possibilidade de trocar dados entre computadores usando endere√ßos IP, que s√£o conjuntos de n√∫meros como 222.324.3.1 (para IPv4). <br><br>  Primeiro, descobrindo o endere√ßo IP do servidor, o navegador examina o cache DNS local para verificar se um procedimento semelhante foi executado recentemente.  No navegador Chrome, por exemplo, existe uma maneira conveniente de examinar o cache DNS inserindo o seguinte endere√ßo na barra de endere√ßos: <code>chrome://net-internals/#dns</code> . <br><br>  Se nada puder ser encontrado no cache, o navegador utilizar√° a chamada de sistema <code>gethostbyname</code> do POSIX para descobrir o endere√ßo IP do servidor. <br><br><h3>  <font color="#3AC1EF">‚ñç fun√ß√£o gethostbyname</font> </h3><br>  A fun√ß√£o <code>gethostbyname</code> primeiro verifica o <code>hosts</code> , que, no macOS ou Linux, pode ser encontrado em <code>/etc/hosts</code> para descobrir se as informa√ß√µes locais podem ser encontradas ao descobrir o endere√ßo do servidor. <br><br>  Se local significa resolver a solicita√ß√£o e descobrir o endere√ßo IP do servidor, o sistema executar√° uma solicita√ß√£o ao servidor DNS.  Os endere√ßos desses servidores s√£o armazenados nas configura√ß√µes do sistema. <br><br>  Aqui est√£o alguns servidores DNS populares: <br><br><ul><li>  8.8.8.8: servidor DNS do Google. </li><li>  1.1.1.1: servidor DNS CloudFlare. </li></ul><br>  A maioria das pessoas usa os servidores DNS fornecidos por seus provedores.  O navegador executa consultas DNS usando o protocolo UDP. <br><br>  TCP e UDP s√£o dois protocolos b√°sicos usados ‚Äã‚Äãem redes de computadores.  Eles est√£o localizados no mesmo n√≠vel conceitual, mas o TCP √© um protocolo orientado a conex√£o e, para a troca de mensagens UDP, cujo processamento cria uma pequena carga adicional no sistema, n√£o √© necess√°rio um procedimento de estabelecimento de conex√£o.  N√£o falaremos exatamente sobre como os dados s√£o trocados pelo UDP. <br><br>  O endere√ßo IP correspondente ao nome de dom√≠nio de seu interesse pode estar no cache do servidor DNS.  Se n√£o for esse o caso, ele entrar√° em contato com o servidor DNS raiz.  O sistema do servidor DNS raiz consiste em 13 servidores, dos quais depende a opera√ß√£o de toda a Internet. <br><br>  Deve-se notar que o servidor DNS raiz n√£o conhece a correspond√™ncia entre todos os nomes de dom√≠nio e endere√ßos IP existentes no mundo.  Por√©m, servidores semelhantes conhecem os endere√ßos dos servidores DNS de n√≠vel superior para dom√≠nios como .com, .it, .pizza e assim por diante. <br><br>  Ap√≥s o recebimento da solicita√ß√£o, o servidor DNS raiz o redireciona para o servidor DNS do dom√≠nio de n√≠vel superior, para o chamado servidor TLD (do dom√≠nio de n√≠vel superior). <br><br>  Suponha que o navegador esteja procurando o endere√ßo IP do servidor <code>flaviocopes.com</code> .  Voltando ao servidor DNS raiz, o navegador receber√° o endere√ßo do servidor TLD da zona .com.  Agora, esse endere√ßo ser√° armazenado no cache; como resultado, se voc√™ precisar descobrir o endere√ßo IP de outro URL da zona .com, n√£o precisar√° acessar o servidor DNS raiz novamente. <br><br>  Os servidores de TLD t√™m endere√ßos IP de servidores de nomes (Name Server, NS), com a ajuda da qual voc√™ pode descobrir o endere√ßo IP a partir do URL que temos.  Onde o servidor NS obt√©m essas informa√ß√µes?  O fato √© que, se voc√™ compra um dom√≠nio, o registrador do dom√≠nio envia dados sobre ele para os servidores de nomes.  Um procedimento semelhante √© realizado, por exemplo, ao alterar a hospedagem. <br><br>  Os servidores em quest√£o geralmente s√£o de propriedade de provedores de hospedagem.  Como regra, para proteger contra falhas, v√°rios desses servidores s√£o criados.  Por exemplo, eles podem ter estes endere√ßos: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Para descobrir o endere√ßo IP por URL, no final, eles recorrem a esses servidores.  Eles armazenam os dados reais sobre endere√ßos IP. <br><br>  Agora, depois que conseguimos descobrir o endere√ßo IP por tr√°s da URL inserida na barra de endere√ßos do navegador, passamos para a pr√≥xima etapa do nosso trabalho. <br><br><h3>  <font color="#3AC1EF">‚ñç Estabelecendo uma conex√£o TCP</font> </h3><br>  Depois de aprender o endere√ßo IP do servidor, o cliente pode iniciar uma conex√£o TCP com ele.  No processo de estabelecer uma conex√£o TCP, o cliente e o servidor transmitem um ao outro alguns dados de servi√ßo, ap√≥s o qual eles podem trocar informa√ß√µes.  Isso significa que depois que a conex√£o for estabelecida, o cliente poder√° enviar uma solicita√ß√£o ao servidor. <br><br><h3>  <font color="#3AC1EF">RequestEnviando pedido</font> </h3><br>  Uma solicita√ß√£o √© um fragmento de texto estruturado de acordo com as regras do protocolo usado.  Consiste em tr√™s partes: <br><br><ul><li>  String de consulta </li><li>  Cabe√ßalho da solicita√ß√£o. </li><li>  Corpo da solicita√ß√£o. </li></ul><br><h4>  String de consulta </h4><br>  A cadeia de consulta √© uma cadeia de texto √∫nica que cont√©m as seguintes informa√ß√µes: <br><br><ul><li>  M√©todo HTTP. </li><li>  Endere√ßo do recurso </li><li>  Vers√£o do protocolo. </li></ul><br>  Pode parecer, por exemplo, assim: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  Cabe√ßalho da solicita√ß√£o </h4><br>  O cabe√ßalho da solicita√ß√£o √© representado por um conjunto de <code>: </code> .  Existem 2 campos de cabe√ßalho obrigat√≥rios, um dos quais √© <code>Host</code> e o segundo √© <code>Connection</code> .  Os demais campos s√£o opcionais. <br><br>  O t√≠tulo pode ficar assim: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  O campo <code>Host</code> indica o nome de dom√≠nio no qual o navegador est√° interessado.  O campo <code>Connection</code> , definido para <code>close</code> , significa que a conex√£o entre o cliente e o servidor n√£o precisa ser mantida aberta. <br><br>  Outros cabe√ßalhos de solicita√ß√£o comumente usados ‚Äã‚Äãincluem o seguinte: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  De fato, existem muitos mais. <br><br>  O cabe√ßalho da solicita√ß√£o termina com uma sequ√™ncia vazia. <br><br><h4>  Organismo de solicita√ß√£o </h4><br>  O corpo da solicita√ß√£o √© opcional; n√£o √© usado nas solicita√ß√µes GET.  O corpo da solicita√ß√£o √© usado em solicita√ß√µes POST, bem como em outras solicita√ß√µes.  Pode conter, por exemplo, dados no formato JSON. <br><br>  Como agora estamos falando de uma solicita√ß√£o GET, o corpo da solicita√ß√£o estar√° vazio, n√£o trabalharemos com ela. <br><br><h3>  <font color="#3AC1EF">‚ñç Resposta</font> </h3><br>  Depois que o servidor recebe a solicita√ß√£o enviada pelo cliente, ele a processa e envia uma resposta ao cliente. <br><br>  A resposta come√ßa com um c√≥digo de status e uma mensagem correspondente.  Se a solicita√ß√£o for bem-sucedida, o in√≠cio da resposta ter√° a seguinte apar√™ncia: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  Se algo der errado, pode haver outros c√≥digos.  Por exemplo, o seguinte: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  Al√©m disso, a resposta cont√©m uma lista de cabe√ßalhos HTTP e o corpo da resposta (que, como a solicita√ß√£o √© executada pelo navegador, ser√° c√≥digo HTML). <br><br><h4>  An√°lise de HTML </h4><br>  Depois que o navegador recebe a resposta do servidor, cujo corpo cont√©m c√≥digo HTML, ele come√ßa a analis√°-lo, repetindo o processo acima para cada recurso necess√°rio para formar a p√°gina.  Esses recursos incluem, por exemplo, o seguinte: <br><br><ul><li>  Arquivos CSS. </li><li>  Imagens </li><li>  √çcone de p√°gina da Web (favicon). </li><li>  Arquivos JavaScript. </li></ul><br>  Como exatamente o navegador exibe a p√°gina n√£o se aplica √† nossa conversa.  O principal que nos interessa aqui √© que o processo acima de solicitar e receber dados √© usado n√£o apenas para o c√≥digo HTML, mas tamb√©m para outros objetos transferidos do servidor para o navegador usando o protocolo HTTP. <br><br><h2>  <font color="#3AC1EF">Sobre a cria√ß√£o de um servidor simples usando o Node.js</font> </h2><br>  Agora, depois de examinarmos o processo de intera√ß√£o entre o navegador e o servidor, voc√™ pode dar uma nova olhada na se√ß√£o do aplicativo First Node.js da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> desta s√©rie de materiais, na qual descrevemos o c√≥digo para um servidor simples. <br><br><h2>  <font color="#3AC1EF">Fazendo solicita√ß√µes HTTP com Node.js</font> </h2><br>  Para executar solicita√ß√µes HTTP usando o Node.js, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://nodejs.org/api/">m√≥dulo</a> apropriado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://nodejs.org/api/">√© usado</a> .  Os exemplos abaixo usam o m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://nodejs.org/api/">https</a> .  O fato √© que, em condi√ß√µes modernas, sempre que poss√≠vel, √© necess√°rio usar o protocolo HTTPS. <br><br><h3>  <font color="#3AC1EF">‚ñç Executando solicita√ß√µes GET</font> </h3><br>  Aqui est√° um exemplo de execu√ß√£o de uma solicita√ß√£o GET usando o Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">Execu√ß√£o de solicita√ß√£o POST</font> </h3><br>  Veja como fazer uma solicita√ß√£o POST no Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPUT e DELETE consultas</font> </h3><br>  A execu√ß√£o de tais solicita√ß√µes √© igual √† execu√ß√£o de solicita√ß√µes POST.  A principal diferen√ßa, al√©m do conte√∫do sem√¢ntico de tais opera√ß√µes, √© o valor da propriedade <code>method</code> do objeto <code>options</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Executando solicita√ß√µes HTTP no Node.js usando a biblioteca Axios</font> </h3><br>  O Axios √© uma biblioteca JavaScript muito popular que funciona tanto no navegador (que inclui todos os navegadores modernos e no IE, come√ßando no IE8), quanto no ambiente Node.js., que pode ser usado para executar solicita√ß√µes HTTP. <br><br>  Essa biblioteca √© baseada em promessas, possui algumas vantagens sobre os mecanismos padr√£o, em particular sobre a API Fetch.  Entre suas vantagens est√£o as seguintes: <br><br><ul><li>  Suporte para navegadores mais antigos (voc√™ precisa de um polyfill para usar o Fetch). </li><li>  Capacidade de interromper solicita√ß√µes. </li><li>  Suporte para definir tempos limite para solicita√ß√µes. </li><li>  Prote√ß√£o integrada contra ataques CSRF. </li><li>  Suporte para upload de dados com o fornecimento de informa√ß√µes sobre o andamento desse processo. </li><li>  Suporte para convers√£o de dados JSON. </li><li>  Empregos em Node.js </li></ul><br><h4>  Instala√ß√£o </h4><br>  Voc√™ pode usar o npm para instalar o Axios: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  O mesmo efeito pode ser alcan√ßado com o fio: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Voc√™ pode conectar a biblioteca √† p√°gina usando <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API do Axios </h4><br>  Voc√™ pode fazer uma solicita√ß√£o HTTP usando o objeto <code>axios</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  Mas geralmente √© mais conveniente usar m√©todos especiais: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Isso √© semelhante a como o jQuery usa <code>$.get()</code> e <code>$.post()</code> vez de <code>$.ajax()</code> <code>$.post()</code> . <br><br>  O Axios oferece m√©todos separados para executar outros tipos de solicita√ß√µes HTTP, que n√£o s√£o t√£o populares quanto GET e POST, mas ainda s√£o usados: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  A biblioteca possui um m√©todo para executar uma solicita√ß√£o projetada para receber apenas cabe√ßalhos HTTP, sem o corpo da resposta: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  Solicita√ß√µes GET </h4><br>  O Axios √© conveniente de usar usando a sintaxe ass√≠ncrona / aguardada moderna.  O exemplo de c√≥digo a seguir, desenvolvido para o Node.js, usa a biblioteca para carregar uma lista de ra√ßas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√£es da API Dog</a> .  Aqui o m√©todo <code>axios.get()</code> √© aplicado e as rochas s√£o contadas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  O mesmo pode ser reescrito sem usar async / waitit, aplicando promessas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Usando par√¢metros em solicita√ß√µes GET </h4><br>  Uma solicita√ß√£o GET pode conter par√¢metros parecidos com este em um URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Ao usar o Axios, uma consulta desse tipo pode ser feita assim: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  O mesmo efeito pode ser alcan√ßado configurando a propriedade <code>params</code> em um objeto com par√¢metros: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  Solicita√ß√µes POST </h4><br>  A execu√ß√£o de solicita√ß√µes POST √© muito semelhante √† execu√ß√£o de solicita√ß√µes GET, mas aqui, em vez do m√©todo <code>axios.get()</code> , o m√©todo <code>axios.post()</code> √© usado: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Como segundo argumento, o m√©todo <code>post</code> aceita um objeto com par√¢metros de solicita√ß√£o: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Usando o protocolo WebSocket no Node.js</font> </h2><br>  O WebSocket √© uma alternativa ao HTTP, pode ser usado para organizar a troca de dados em aplicativos da web.  Esse protocolo permite criar canais de comunica√ß√£o bidirecional de longa dura√ß√£o entre o cliente e o servidor.  Ap√≥s o estabelecimento da conex√£o, o canal de comunica√ß√£o permanece aberto, o que coloca a aplica√ß√£o √† disposi√ß√£o de uma conex√£o muito r√°pida, caracterizada por baixas lat√™ncias e uma pequena carga adicional no sistema. <br><br>  O protocolo WebSocket √© suportado por todos os navegadores modernos. <br><br><h3>  <font color="#3AC1EF">‚ñç Diferen√ßas HTTP</font> </h3><br>  HTTP e WebSocket s√£o protocolos muito diferentes que usam abordagens diferentes para a troca de dados.  O HTTP √© baseado no modelo "solicita√ß√£o-resposta": o servidor envia alguns dados para o cliente ap√≥s a solicita√ß√£o.  No caso do WebSocket, tudo √© organizado de maneira diferente.  Ou seja: <br><br><ul><li>  O servidor pode enviar mensagens para o cliente por sua pr√≥pria iniciativa, sem aguardar uma solicita√ß√£o do cliente. </li><li>  O cliente e o servidor podem trocar dados ao mesmo tempo. </li><li>  Ao transmitir uma mensagem, uma quantidade extremamente pequena de dados de servi√ßo √© usada.  Isso, em particular, leva a baixa lat√™ncia na transmiss√£o de dados. </li></ul><br>  O protocolo WebSocket √© muito adequado para comunica√ß√µes em tempo real atrav√©s de canais que permanecem abertos por muito tempo.  O HTTP, por sua vez, √© excelente para organizar sess√µes de comunica√ß√£o ocasionais iniciadas pelo cliente.  Ao mesmo tempo, deve-se notar que, do ponto de vista da programa√ß√£o, √© muito mais f√°cil implementar a troca de dados usando o protocolo HTTP do que usando o protocolo WebSocket. <br><br><h3>  <font color="#3AC1EF">Version Vers√£o protegida do protocolo WebSocket</font> </h3><br>  H√° uma vers√£o n√£o segura do protocolo WebSocket (esquema URI <code>ws://</code> ), que se assemelha, em termos de seguran√ßa, ao protocolo <code>http://</code> .  O uso de <code>ws://</code> deve ser evitado, preferindo uma vers√£o segura do protocolo - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">ReatCriando uma conex√£o WebSocket</font> </h3><br>  Para criar uma conex√£o WebSocket, voc√™ precisa usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor</a> apropriado: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Ap√≥s uma conex√£o bem-sucedida, o evento <code>open</code> √© gerado.  Voc√™ pode organizar esse evento atribuindo uma fun√ß√£o de retorno de chamada √† propriedade <code>onopen</code> do objeto de <code>connection</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Para manipular erros, o manipulador de eventos <code>onerror</code> √© usado: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">DataEnviando dados para o servidor</font> </h3><br>  Ap√≥s abrir uma conex√£o WebSocket com o servidor, voc√™ pode enviar dados para ele.  Isso pode ser feito, por exemplo, no <code>onopen</code> aberto: <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Obtendo dados do servidor</font> </h3><br>  Para receber dados enviados usando o protocolo WebSocket do servidor, voc√™ pode atribuir o <code>onmessage</code> onmessage, que ser√° chamado quando o evento da <code>message</code> for recebido: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Implementa√ß√£o do servidor WebSocket no ambiente Node.js.</font> </h3><br>  Para implementar um servidor WebSocket no ambiente Node.js., voc√™ pode usar a popular biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ws</a> .  Vamos us√°-lo para o desenvolvimento de servidores, mas √© adequado para criar clientes, bem como para organizar a intera√ß√£o entre dois servidores. <br><br>  Instale esta biblioteca inicializando o projeto: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  O c√≥digo para o servidor WebSocket que precisamos escrever √© bastante compacto: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Aqui, criamos um novo servidor que escuta na porta padr√£o 8080 o protocolo WebSocket e descreve um retorno de chamada que, quando a conex√£o √© estabelecida, envia uma mensagem <code>ho!</code> ao cliente <code>ho!</code>  e imprime no console uma mensagem recebida do cliente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui est√° um</a> exemplo de trabalho de um servidor WebSocket e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> est√° um cliente que pode interagir com ele. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Hoje falamos sobre os mecanismos de rede suportados pela plataforma Node.js., tra√ßando paralelos com mecanismos similares usados ‚Äã‚Äãnos navegadores.  Nosso pr√≥ximo t√≥pico estar√° trabalhando com arquivos. <br><br>  <b>Caros leitores!</b>  Voc√™ usa o protocolo WebSocket em seus aplicativos Web, cujo servidor foi criado usando o Node.js.? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424557/">https://habr.com/ru/post/pt424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424541/index.html">Hist√≥ria do fiasco do UGJ 2018: como fazer um jogo que ningu√©m gosta (n√£o fa√ßa isso!)</a></li>
<li><a href="../pt424543/index.html">Java 11 / JDK 11: Disponibilidade Geral</a></li>
<li><a href="../pt424551/index.html">Quente e tubo: cinco balalaikas sobre a tecnologia de √°udio magn√©tico</a></li>
<li><a href="../pt424553/index.html">Guia do Node.js, parte 6: loop de eventos, pilha de chamadas, temporizadores</a></li>
<li><a href="../pt424555/index.html">Manual do Node.js., Parte 7: Programa√ß√£o ass√≠ncrona</a></li>
<li><a href="../pt424559/index.html">Resist√™ncia ao Big Data 1 ou Joe indescrit√≠vel. Anonimato na Internet, anti-detec√ß√£o, anti-rastreamento para anti-voc√™ e anti-n√≥s</a></li>
<li><a href="../pt424563/index.html">Beeline envia detalhes de conversas para estranhos</a></li>
<li><a href="../pt424565/index.html">Vis√£o geral: digitaliza√ß√£o 3D de instala√ß√µes imobili√°rias</a></li>
<li><a href="../pt424567/index.html">A experi√™ncia de bloquear a publicidade on-line na rede local da empresa</a></li>
<li><a href="../pt424569/index.html">Contrata√ß√£o de programadores. Dicas para programadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>