<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó≥Ô∏è üìú üêê Como piscar 4 LEDs no CortexM usando C ++ 17, tupla e um pouco de fantasia üë®‚Äçüé® üßöüèª üõãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa sa√∫de a todos! 

 Ao ensinar aos alunos o desenvolvimento de software incorporado para microcontroladores na universidade, uso C ++ e, √†s vezes, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como piscar 4 LEDs no CortexM usando C ++ 17, tupla e um pouco de fantasia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457246/"> Boa sa√∫de a todos! <br><br>  Ao ensinar aos alunos o desenvolvimento de software incorporado para microcontroladores na universidade, uso C ++ e, √†s vezes, dou estudantes especialmente interessados ‚Äã‚Äãem todo tipo de tarefas para identificar alunos talentosos <s>com</s> dores de cabe√ßa especiais. <br><br>  Mais uma vez, esses alunos tiveram a tarefa de piscar 4 LEDs usando a linguagem C ++ 17 e a biblioteca C ++ padr√£o, sem conectar bibliotecas adicionais, como o CMSIS e seus arquivos de cabe√ßalho, com uma descri√ß√£o das estruturas de registro, e assim por diante ... Aquele com o c√≥digo vence na ROM ter√° o menor tamanho e menos mem√≥ria RAM gasta.  A otimiza√ß√£o do compilador n√£o deve ser maior que M√©dia.  Compilador IAR 8.40.1. <br>  O vencedor <s>vai para Can√°rias e</s> recebe 5 para o exame. <br><br>  Eu tamb√©m n√£o resolvi esse problema antes, ent√£o vou contar como os alunos o resolveram e o que aconteceu comigo.  Eu aviso imediatamente que √© improv√°vel que esse c√≥digo possa ser usado em aplicativos reais, e foi por isso que publiquei a publica√ß√£o na se√ß√£o "Programa√ß√£o anormal", apesar de quem sabe. <br><a name="habracut"></a><br><h3>  Condi√ß√µes da tarefa </h3><br>  Existem 4 LEDs nas portas GPIOA.5, GPIOC.5, GPIOC.8, GPIOC.9.  Eles precisam piscar.  Para ter algo com o que comparar, pegamos o c√≥digo escrito em C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++i){ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  A fun√ß√£o <code>delay()</code> aqui √© puramente formal, um ciclo regular, n√£o pode ser otimizada. <br>  Sup√µe-se que as portas j√° estejam configuradas para sa√≠da e o rel√≥gio seja aplicado a elas. <br>  Tamb√©m direi imediatamente que a divis√£o de bits n√£o foi usada para tornar o c√≥digo port√°til. <br><br>  Esse c√≥digo ocupa 8 bytes na pilha e 256 bytes na ROM na Otimiza√ß√£o M√©dia <br><blockquote>  255 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  8 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br>  255 bytes devido ao fato de parte da mem√≥ria estar sob a tabela de vetores de interrup√ß√£o, chamadas para fun√ß√µes IAR para inicializar um bloco de ponto flutuante, todos os tipos de fun√ß√µes de depura√ß√£o e a fun√ß√£o __low_level_init, na qual as pr√≥prias portas foram configuradas. <br><br>  Portanto, todos os requisitos s√£o: <br><br><ul><li>  A fun√ß√£o main () deve conter o m√≠nimo de c√≥digo poss√≠vel </li><li>  Voc√™ n√£o pode usar macros </li><li>  Compilador IAR 8.40.1 suportando C ++ 17 </li><li>  Arquivos de cabe√ßalho CMSIS como "#include" stm32f411xe.h "n√£o podem ser usados </li><li>  Voc√™ pode usar a diretiva __forceinline para fun√ß√µes embutidas </li><li>  Otimiza√ß√£o de compilador m√©dio </li></ul><br><h3>  Decis√£o dos alunos </h3><br>  Em geral, havia v√°rias solu√ß√µes, vou mostrar apenas uma ... n√£o √© √≥tima, mas gostei. <br><br>  Como os cabe√ßalhos n√£o podem ser usados, a primeira coisa que os alunos fizeram foi a classe <code>Gpio</code> , que deve armazenar um link para os registros de portas em seus endere√ßos.  Para fazer isso, eles usam uma sobreposi√ß√£o de estrutura, provavelmente tiraram a id√©ia daqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobreposi√ß√£o de estrutura</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); } ;</span></span></code> </pre> <br>  Como voc√™ pode ver, eles imediatamente identificaram a classe <code>Gpio</code> com atributos que devem estar localizados nos endere√ßos dos registros correspondentes e um m√©todo para alternar o estado pelo n√∫mero de pernas: <br>  Em seguida, determinamos a estrutura para <code>GpioPin</code> contendo o ponteiro para <code>Gpio</code> e o n√∫mero da perna: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GpioPin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio* port ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum ; } ;</code> </pre> <br>  Em seguida, eles criaram uma s√©rie de LEDs que ficam nas pernas espec√≠ficas da porta e a <code>Toggle()</code> chamando o m√©todo <code>Toggle()</code> de cada LED: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GpioPin leds[] = {{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpioaBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>} } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsDriver</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggelAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bem, na verdade todo o c√≥digo:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; } ; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); struct GpioPin { volatile Gpio* port ; std::uint32_t pinNum ; } ; const GpioPin leds[] = {{reinterpret_cast&lt;volatile Gpio*&gt;(GpioaBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9} } ; struct LedsDriver { __forceinline static inline void ToggelAll() { for (auto&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ; int main() { for(;;) { LedsContainer::ToggleAll() ; delay(); } return 0 ; }</span></span></code> </pre> <br></div></div><br>  Estat√≠sticas de seu c√≥digo na otimiza√ß√£o M√©dia: <br><blockquote>  275 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  8 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br>  Uma boa solu√ß√£o, mas consome muita mem√≥ria :) <br><br><h3>  Minha decis√£o </h3><br>  Claro, decidi n√£o procurar maneiras simples e decidi agir de maneira s√©ria :). <br>  Os LEDs est√£o em diferentes portas e pernas diferentes.  A primeira coisa que voc√™ precisa √© criar a classe <code>Port</code> , mas, para se livrar dos ponteiros e vari√°veis ‚Äã‚Äãque ocupam a RAM, voc√™ precisa usar m√©todos est√°ticos.  A classe de porta pode ficar assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  -  };</span></span></code> </pre> <br>  Como par√¢metro do modelo, ele ter√° um endere√ßo de porta.  No <code>"#include "stm32f411xe.h"</code> , por exemplo, para a porta A, √© definido como GPIOA_BASE. Mas n√£o temos permiss√£o para usar os cabe√ßalhos, portanto, precisamos criar nossa pr√≥pria constante. Como resultado, a classe pode ser usada assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ;</code> </pre><br>  Para piscar, voc√™ precisa do m√©todo Toggle (const std :: uint8_t bit), que alternar√° o bit necess√°rio usando uma opera√ß√£o OR exclusiva.  O m√©todo deve ser est√°tico, adicione-o √† classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   __forceinline,        __forceinline inline static void Toggle(const std::uint8_t bitNum) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr+20) ^= (1 &lt;&lt; bitNum) ; //addr + 20  ODR  } };</span></span></code> </pre> <br>  Excelente <code>Port&lt;&gt;</code> , ele pode mudar o estado das pernas.  O LED fica em uma perna espec√≠fica, portanto, √© l√≥gico criar uma classe <code>Pin</code> , que ter√° a <code>Port&lt;&gt;</code> e o n√∫mero da perna como par√¢metros do modelo.  Como o tipo de <code>Port&lt;&gt;</code> √© o modelo, ou seja,  diferente para diferentes portas, s√≥ podemos transmitir o tipo universal T. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T::Toggle(pinNum) ; } } ;</code> </pre> <br>  √â ruim que possamos passar qualquer bobagem do tipo <code>T</code> que tenha um m√©todo <code>Toggle()</code> e isso funcionar√°, embora se presuma que devemos passar apenas o tipo <code>Port&lt;&gt;</code> .  Para <code>PortBase</code> protegermos disso, faremos o <code>Port&lt;&gt;</code> herdar da classe base do <code>PortBase</code> e, no modelo, verificaremos se nosso tipo passado √© realmente baseado no <code>PortBase</code> .  Temos o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortBase</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class">:</span></span> PortBase { __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">//   struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ;</span></span></code> </pre> <br>  Agora o modelo √© instanciado apenas se nossa classe tiver a classe base <code>PortBase</code> . <br>  Em teoria, voc√™ j√° pode usar essas classes, vamos ver o que acontece sem a otimiza√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led2 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led3 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led4 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { Led1::Toggle(); Led2::Toggle(); Led3::Toggle(); Led4::Toggle(); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br><blockquote>  271 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  24 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br>  De onde vieram esses 16 bytes extras na RAM e 16 bytes na ROM.  Elas v√™m do fato de que passamos o par√¢metro bit para a fun√ß√£o Toggle (const std :: uint8_t bit) da classe Port, e o compilador, ao entrar na fun√ß√£o principal, salva 4 registros adicionais na pilha pela qual esse par√¢metro passa e os utiliza. registradores nos quais os valores do n√∫mero da perna de cada pino s√£o armazenados e, ao sair do main, restaura esses registros da pilha.  E, embora, em ess√™ncia, esse seja um tipo de trabalho completamente in√∫til, uma vez que as fun√ß√µes s√£o integradas, mas o compilador age em total conformidade com o padr√£o. <br>  Voc√™ pode se livrar disso removendo a classe de porta em geral, passando o endere√ßo da porta como um par√¢metro de modelo para a classe <code>Pin</code> e, dentro do m√©todo <code>Toggle()</code> , calcule o endere√ßo do registro ODR: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr + OdrAddrShift ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } } ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;GpioaBaseAddr, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ;</code> </pre> <br>  Mas isso n√£o parece muito bom e amig√°vel.  Portanto, esperamos que o compilador remova essa preserva√ß√£o desnecess√°ria de registro com um pouco de otimiza√ß√£o. <br><br>  Colocamos otimiza√ß√£o no Medium e vemos o resultado: <br><blockquote>  251 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  8 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br>  Uau uau uau ... temos 4 bytes a menos <div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><blockquote>  255 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  8 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br></div></div><br>  Como isso pode ser?  Vamos dar uma olhada no assembler no depurador para o c√≥digo C ++ (√† esquerda) e o c√≥digo C (√† direita): <br><br><img src="https://habrastorage.org/webt/vh/ym/d9/vhymd9hbcko9luonsasg-xz7w7e.png" alt="imagem"><br><br>  Pode-se ver que, primeiro, o compilador incorporou todas as fun√ß√µes, agora n√£o h√° chamadas e, em segundo lugar, otimizou o uso de registradores.  Pode ser visto, no caso do c√≥digo C, o compilador usa o registro R1 ou R2 para armazenar os endere√ßos de porta e executa opera√ß√µes adicionais cada vez que o bit √© alternado (salve o endere√ßo no registro em R1 ou R2).  No segundo caso, ele usa apenas o registro R1 e, como as tr√™s √∫ltimas chamadas de comuta√ß√£o s√£o sempre da porta C, n√£o √© mais necess√°rio salvar o mesmo endere√ßo da porta C no registro.  Como resultado, 2 equipes e 4 bytes s√£o salvos. <br><br>  Aqui est√° um milagre dos compiladores modernos :) Bem, tudo bem.  Em princ√≠pio, pode-se parar por a√≠, mas vamos seguir em frente.  N√£o acho que seja poss√≠vel otimizar qualquer outra coisa, embora provavelmente n√£o esteja certo, se voc√™ tiver id√©ias, escreva nos coment√°rios.  Mas com a quantidade de c√≥digo em main () voc√™ pode trabalhar. <br><br>  Agora eu quero que todos os LEDs estejam em algum lugar no cont√™iner e voc√™ possa chamar o m√©todo, mudar tudo ... Algo assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { LedsContainer::ToggleAll() ; delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  N√£o inseriremos estupidamente a comuta√ß√£o de 4 LEDs na fun√ß√£o LedsContainer :: ToggleAll, porque n√£o √© interessante :).  Queremos colocar os LEDs em um cont√™iner e depois examin√°-los e chamar o m√©todo Toggle () em cada um. <br><br>  <i>Os alunos usaram uma matriz para armazenar ponteiros para LEDs.</i>  Mas tenho tipos diferentes, por exemplo: <code>Pin&lt;PortA, 5&gt;</code> , <code>Pin&lt;PortC, 5&gt;</code> e n√£o consigo armazenar ponteiros para tipos diferentes em uma matriz.  Voc√™ pode fazer uma aula de base virtual para todos os Pinos, mas uma tabela de fun√ß√µes virtuais ser√° exibida e eu n√£o conseguirei ganhar alunos. <br><br>  Portanto, usaremos a tupla.  Permite armazenar objetos de diferentes tipos.  Este caso ter√° a seguinte apar√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> records = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple ( Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt;{} ) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tRecordsTuple = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(records) ; }</code> </pre> <br>  H√° um √≥timo recipiente, ele armazena todos os LEDs.  Agora adicione o m√©todo <code>ToggleAll()</code> a ele: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        } private: constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  Voc√™ n√£o pode simplesmente percorrer os elementos de uma tupla, pois o elemento de tupla deve ser recebido apenas no est√°gio de compila√ß√£o.  Para acessar os elementos da tupla, existe um m√©todo de obten√ß√£o de modelo.  Bem, isto √©  se escrevermos <code>std::get&lt;0&gt;(records).Toggle()</code> , o m√©todo <code>Toggle()</code> ser√° chamado para o objeto da classe <code>Pin&lt;PortA, 5&gt;</code> , se <code>std::get&lt;1&gt;(records).Toggle()</code> , ent√£o o m√©todo <code>Toggle()</code> √© chamado para o objeto da classe <code>Pin&lt;Port, 5&gt;</code> e assim por diante ... <br><br>  Voc√™ pode <s>limpar o nariz dos alunos</s> e simplesmente escrever: <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(records).Toggle(); }</code> </pre> <br>  Mas n√£o queremos for√ßar o programador que oferecer√° suporte a esse c√≥digo e permitir que ele fa√ßa um trabalho adicional, gastando os recursos de sua empresa, por exemplo, caso outro LED apare√ßa.  Voc√™ precisar√° adicionar o c√≥digo em dois lugares, na tupla e neste m√©todo - e isso n√£o √© bom e o propriet√°rio da empresa n√£o ficar√° muito satisfeito.  Portanto, ignoramos a tupla usando m√©todos auxiliares: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); //    get&lt;3&gt;(records).Toggle(), get&lt;2&gt;(records).Toggle(), get&lt;1&gt;(records).Toggle(), get&lt;0&gt;(records).Toggle() } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) {//      } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  Parece assustador, mas avisei no in√≠cio do artigo que o m√©todo <s>shizany</s> n√£o <s>√©</s> muito comum ... <br><br>  Toda essa m√°gica de cima na fase de compila√ß√£o faz literalmente o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  LedsContainer::ToggleAll() ; //   4 : Pin&lt;Port, 9&gt;().Toggle() ; Pin&lt;Port, 8&gt;().Toggle() ; Pin&lt;PortC, 5&gt;().Toggle() ; Pin&lt;PortA, 5&gt;().Toggle() ; //     Toggle() inline,   : *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 9) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 8) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 5) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020014 ) ^= (1 &lt;&lt; 5) ;</span></span></code> </pre> <br>  V√° em frente, compile e verifique o tamanho do c√≥digo sem otimiza√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">O c√≥digo que compila</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; #include &lt;tuple&gt; #include &lt;utility&gt; #include &lt;cstdint&gt; #include &lt;type_traits&gt; //#include "stm32f411xe.h" #define __forceinline _Pragma("inline=forced") constexpr std::uint32_t GpioaBaseAddr = 0x4002'0000 ; constexpr std::uint32_t GpiocBaseAddr = 0x4002'0800 ; constexpr std::uint32_t OdrAddrShift = 20U; struct PortBase { }; template &lt;std::uint32_t addr&gt; struct Port: PortBase { __forceinline inline static void Toggle(const std::uint8_t bit) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr + OdrAddrShift) ^= (1 &lt;&lt; bit) ; } }; template &lt;typename T, std::uint8_t pinNum, class = typename std::enable_if_t&lt;std::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ; using PortA = Port&lt;GpioaBaseAddr&gt; ; using PortC = Port&lt;GpiocBaseAddr&gt; ; //using Led1 = Pin&lt;PortA, 5&gt; ; //using Led2 = Pin&lt;PortC, 5&gt; ; //using Led3 = Pin&lt;PortC, 8&gt; ; //using Led4 = Pin&lt;PortC, 9&gt; ; class LedsContainer { friend int main() ; public: __forceinline static inline void ToggleAll() { //    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) { } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; } ; void delay() { for (int i = 0; i &lt; 1000000; ++i){ } } int main() { for(;;) { LedsContainer::ToggleAll() ; //GPIOA-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 8; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 9; delay(); } return 0 ; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Prova de montagem, desembalada conforme planejado:</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0e/aa/un/0eaaunh1qwmg73s1p-3ev4zcpws.png" alt="imagem"><br></div></div><br>  Vemos que a mem√≥ria √© um exagero, mais 18 bytes.  Os problemas s√£o os mesmos, mais outros 12 bytes.  Eu n√£o entendi de onde eles vieram ... talvez algu√©m explique. <br><blockquote>  283 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  24 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br>  Agora, a mesma coisa na otimiza√ß√£o M√©dia e eis que ... temos c√≥digo id√™ntico √†s implementa√ß√µes de C ++ na testa e, de maneira mais otimizada, c√≥digo C. <br><blockquote>  251 bytes de mem√≥ria de c√≥digo somente leitura <br>  1 byte de mem√≥ria de dados somente leitura <br>  8 bytes de mem√≥ria de leitura e grava√ß√£o de dados </blockquote><br><div class="spoiler">  <b class="spoiler_title">Montador</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y4/7w/l9/y47wl95frzmeyb2brdekbnvqvr8.png" alt="imagem"><br></div></div><br>  Como voc√™ pode ver, ganhei e <s>fui para as Ilhas Can√°rias</s> e tenho o prazer de descansar em Chelyabinsk :), mas os alunos tamb√©m foram √≥timos, passaram no exame com sucesso! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quem se importa, o c√≥digo est√° aqui</a> <br><br>  Onde posso usar isso? Bem, eu vim com, por exemplo, tais, temos par√¢metros na mem√≥ria EEPROM e uma classe que descreve esses par√¢metros (leitura, grava√ß√£o, inicializa√ß√£o para o valor inicial).  A classe √© modelo, como <code>Param&lt;float&lt;&gt;&gt;</code> , <code>Param&lt;int&lt;&gt;&gt;</code> e voc√™ precisa, por exemplo, de redefinir todos os par√¢metros para os valores padr√£o.  √â aqui que voc√™ pode colocar todos eles em uma tupla, pois o tipo √© diferente e chame o m√©todo <code>SetToDefault()</code> em cada par√¢metro.  √â verdade que, se houver 100 desses par√¢metros, a ROM comer√° muito, mas a RAM n√£o sofrer√°. <br><br>  PS Devo admitir que, na otimiza√ß√£o m√°xima, esse c√≥digo tem o mesmo tamanho que em C e na minha solu√ß√£o.  E todos os esfor√ßos do programador para melhorar o c√≥digo se resumem ao mesmo c√≥digo do assembler. <br><br>  P.S1 Obrigado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">0xd34df00d</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">bons</a> conselhos.  Voc√™ pode simplificar a descompacta√ß√£o de uma tupla com <code>std::apply()</code> .  O c√≥digo da fun√ß√£o <code>ToggleAll()</code> simplifica para isso: <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>... args) { (args.Toggle(), ...); }, records); }</code> </pre> <br>  Infelizmente, no IAR, o std :: apply ainda n√£o est√° implementado na vers√£o atual, mas tamb√©m funcionar√°. Consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o com o std :: apply</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457246/">https://habr.com/ru/post/pt457246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457224/index.html">Uma abordagem moderna da concorr√™ncia no Android: Corotins no Kotlin</a></li>
<li><a href="../pt457232/index.html">Abelha rob√¥ "Bumble" - o primeiro v√¥o de teste dentro da ISS</a></li>
<li><a href="../pt457234/index.html">Vi√©s cognitivo do produto</a></li>
<li><a href="../pt457236/index.html">Como uma empresa de TI lutou para vender m√∫sica</a></li>
<li><a href="../pt457240/index.html">Not√≠cias da semana: rede neural e imagens fotografadas, crescimento das a√ß√µes Yandex, Huawei exige US $ 1 bilh√£o em patentes</a></li>
<li><a href="../pt457248/index.html">Programa√ß√£o JavaScript para um torno</a></li>
<li><a href="../pt457250/index.html">Dia sombrio para Vue.js</a></li>
<li><a href="../pt457254/index.html">Resumo de materiais interessantes para o desenvolvedor de dispositivos m√≥veis # 303 (17 a 23 de junho)</a></li>
<li><a href="../pt457256/index.html">Hist√≥rico da Internet: ARPANET - pacote</a></li>
<li><a href="../pt457258/index.html">O Pirate Bay por 15 anos e n√£o poderia matar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>