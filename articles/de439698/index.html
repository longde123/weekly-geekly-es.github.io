<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏽 🏇🏽 🍿 Einführung in die Programmierung: Ein einfacher 3D-Shooter von Grund auf über das Wochenende, Teil 1 🚶 ⏹️ ⏯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Text ist für diejenigen gedacht, die nur die Programmierung beherrschen. Die Hauptidee ist es, Schritt für Schritt zu zeigen, wie Sie das Spiel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die Programmierung: Ein einfacher 3D-Shooter von Grund auf über das Wochenende, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439698/">  Dieser Text ist für diejenigen gedacht, die nur die Programmierung beherrschen.  Die Hauptidee ist es, Schritt für Schritt zu zeigen, wie Sie das Spiel à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfenstein 3D</a> unabhängig machen können.  Achtung, ich werde überhaupt nicht mit Carmack konkurrieren, er ist ein Genie und sein Code ist wunderschön.  Ich ziele auf einen ganz anderen Ort: Ich nutze die enorme Rechenleistung moderner Computer, damit die Schüler in wenigen Tagen lustige Projekte erstellen können, ohne sich in der Wildnis der Optimierung zu verlieren.  Ich schreibe speziell langsamen Code, da dieser viel kürzer und leichter zu verstehen ist.  Carmack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schreibt 0x5f3759df</a> , ich schreibe 1 / sqrt (x).  Wir haben verschiedene Ziele. <br><br>  Ich bin überzeugt, dass ein guter Programmierer nur von jemandem erhalten wird, der zu Hause zum Vergnügen codiert und nicht nur paarweise an der Universität sitzt.  An unserer Universität werden Programmierer in einer endlosen Reihe von Bibliothekskatalogen aller Art und anderer Langeweile unterrichtet.  Brr  Mein Ziel ist es, Beispiele für Projekte zu zeigen, die interessant zu programmieren sind.  Dies ist ein Teufelskreis: Wenn es interessant ist, ein Projekt zu erstellen, verbringt eine Person viel Zeit damit, sammelt Erfahrungen und sieht noch interessantere Dinge (es ist zugänglicher geworden!) Und taucht wieder in ein neues Projekt ein.  Dies nennt man Projekttraining mit soliden Gewinnen. <br><br>  Das Blatt war lang, also habe ich den Text in zwei Teile geteilt: <br><br><ul><li>  <b>Erster Teil: Wände zeichnen</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil zwei: Bewohnen Sie unsere Welt + Fensterschnittstelle</a> </li></ul><br>  Die Codeausführung aus meinem Repository sieht folgendermaßen aus: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zPIVTqVilCM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dies ist kein fertiges Spiel, sondern nur ein Leerzeichen für Schüler.  Ein Beispiel für ein fertiges Spiel, das von zwei Neulingen geschrieben wurde, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im zweiten Teil</a> . <br><a name="habracut"></a><br>  Es stellt sich heraus, dass ich Sie ein wenig getäuscht habe. Ich werde Ihnen nicht sagen, wie Sie an einem Wochenende ein komplettes Spiel machen können.  Ich habe nur eine 3D-Engine gemacht.  Monster rennen nicht auf mich zu und die Hauptfigur schießt nicht.  Aber zumindest habe ich diesen Motor an einem Samstag geschrieben, Sie können den Verlauf der Commits überprüfen.  Grundsätzlich reichen Sonntage aus, um etwas spielbar zu machen, dh an einem Wochenende kann man sich treffen. <br><br>  Zum Zeitpunkt dieses Schreibens enthält das Repository 486 Codezeilen: <br><br><pre><code class="bash hljs">haqreu@daffodil:~/tinyraycaster$ cat *.cpp *.h | wc -l 486</code> </pre> <br>  Das Projekt hängt von SDL2 ab, aber im Allgemeinen erscheinen die Fensteroberfläche und die Verarbeitung von Ereignissen über die Tastatur ziemlich spät, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Samstag um Mitternacht</a> :), wenn der gesamte Rendering-Code bereits fertig ist. <br><br>  Also zerlege ich den gesamten Code in Schritte, beginnend mit dem nackten C ++ - Compiler.  Wie in meinen vorherigen Artikeln zum Zeitplan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tyts</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tyts</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tyts</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halte</a> ich mich an die Regel „one step = one commit“, da es mit github sehr bequem ist, den Verlauf von Codeänderungen anzuzeigen. <br><br><h1>  Stufe 1: Speichern Sie das Bild auf der Festplatte </h1><br>  Also lass uns gehen.  Wir sind immer noch sehr weit von der Fensteroberfläche entfernt. Zunächst speichern wir die Bilder einfach auf der Festplatte.  Insgesamt müssen wir in der Lage sein, das Bild im Arbeitsspeicher des Computers zu speichern und in einem Format auf der Festplatte zu speichern, das einige Programme von Drittanbietern verstehen.  Ich möchte diese Datei erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bc/757/fd3/8bc757fd3da42088dbf24380970e109d.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> vollständige C ++ - Code, der das zeichnet, was wir brauchen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;cstdint&gt; #include &lt;cassert&gt; uint32_t pack_color(const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a=255) { return (a&lt;&lt;24) + (b&lt;&lt;16) + (g&lt;&lt;8) + r; } void unpack_color(const uint32_t &amp;color, uint8_t &amp;r, uint8_t &amp;g, uint8_t &amp;b, uint8_t &amp;a) { r = (color &gt;&gt; 0) &amp; 255; g = (color &gt;&gt; 8) &amp; 255; b = (color &gt;&gt; 16) &amp; 255; a = (color &gt;&gt; 24) &amp; 255; } void drop_ppm_image(const std::string filename, const std::vector&lt;uint32_t&gt; &amp;image, const size_t w, const size_t h) { assert(image.size() == w*h); std::ofstream ofs(filename); ofs &lt;&lt; "P6\n" &lt;&lt; w &lt;&lt; " " &lt;&lt; h &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; h*w; ++i) { uint8_t r, g, b, a; unpack_color(image[i], r, g, b, a); ofs &lt;&lt; static_cast&lt;char&gt;(r) &lt;&lt; static_cast&lt;char&gt;(g) &lt;&lt; static_cast&lt;char&gt;(b); } ofs.close(); } int main() { const size_t win_w = 512; // image width const size_t win_h = 512; // image height std::vector&lt;uint32_t&gt; framebuffer(win_w*win_h, 255); // the image itself, initialized to red for (size_t j = 0; j&lt;win_h; j++) { // fill the screen with color gradients for (size_t i = 0; i&lt;win_w; i++) { uint8_t r = 255*j/float(win_h); // varies between 0 and 255 as j sweeps the vertical uint8_t g = 255*i/float(win_w); // varies between 0 and 255 as i sweeps the horizontal uint8_t b = 0; framebuffer[i+j*win_w] = pack_color(r, g, b); } } drop_ppm_image("./out.ppm", framebuffer, win_w, win_h); return 0; }</span></span></span></span></code> </pre><br>  Wenn Sie keinen Compiler zur Hand haben, spielt dies keine Rolle. Wenn Sie ein Konto auf einem Github haben, können Sie diesen Code anzeigen, bearbeiten und ausführen (sic!). Mit einem Klick direkt vom Browser aus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br>  Wenn Sie diesem Link folgen, erstellt gitpod eine virtuelle Maschine für Sie, startet VS Code und öffnet ein Terminal auf der Remote-Maschine.  In der Historie der Terminalbefehle (klicken Sie auf die Konsole und drücken Sie den Aufwärtspfeil) gibt es bereits einen vollständigen Befehlssatz, mit dem Sie den Code kompilieren, ausführen und das resultierende Bild öffnen können. <br><br>  Also, was Sie aus diesem Code verstehen müssen.  Zuerst die Farben, die ich in einem 4-Byte-Integer-Typ uint32_t speichere.  Jedes Byte ist eine Komponente von R, G, B oder A. Mit den Funktionen pack_color () und unpack_color () können Sie zu den einzelnen Komponenten jeder Farbe gelangen. <br><br>  Das zweite zweidimensionale Bild speichere ich in der üblichen eindimensionalen Anordnung.  Um mit den Koordinaten (x, y) zum Pixel zu gelangen, schreibe ich kein Bild [x] [y], sondern ein Bild [x + y * width].  Wenn diese Methode zum Packen zweidimensionaler Informationen in ein eindimensionales Array für Sie neu ist, greifen Sie jetzt zu einem Stift und beschäftigen Sie sich damit.  Für mich persönlich erreicht dieses Stadium nicht einmal das Gehirn, es wird direkt im Rückenmark verarbeitet.  Drei- und mehrdimensionale Arrays können genauso verpackt werden, aber wir werden uns nicht über die beiden Komponenten erheben. <br><br>  Dann gehe ich mein Bild in einem einfachen Doppelzyklus durch, fülle es mit einem Farbverlauf und speichere es im PPM-Format auf der Festplatte. <br><br><hr><br><h1>  Stufe 2: Zeichnen Sie eine Levelkarte </h1><br>  Wir brauchen eine Weltkarte.  An dieser Stelle möchte ich nur die Datenstruktur bestimmen und eine Karte auf dem Bildschirm zeichnen.  Es sollte ungefähr so ​​aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/c96/1c7/7b8c961c7be837c6c9777770b0eed987.png"><br><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> .  Dort ist alles einfach: Ich habe die Karte in ein eindimensionales Array von Zeichen fest codiert, die Funktion zum Zeichnen eines Rechtecks ​​definiert und bin um die Karte herumgegangen, wobei ich jede Zelle gezeichnet habe. <br><br>  Ich erinnere Sie daran, dass diese Schaltfläche den Code sofort startet: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 3: Fügen Sie einen Spieler hinzu </h1><br>  Was brauchen wir, um einen Spieler auf die Karte zeichnen zu können?  GPS-Koordinaten sind genug :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf0/dfa/e21/cf0dfae212fd0372d368f53334218301.png"><br><br>  Fügen Sie zwei Variablen x und y hinzu und zeichnen Sie den Player an der entsprechenden Stelle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b8/519/2e6/8b85192e6a40e7b146ecc98d219f895b.png"><br><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> .  Über Gitpod werde ich nicht mehr erinnern :) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 4: auch bekannt als Virtual Rangefinder First Ray Trace </h1><br>  Zusätzlich zu den Koordinaten des Spielers wäre es schön zu wissen, in welche Richtung er schaut.  Daher fügen wir eine weitere Variable player_a hinzu, die die Blickrichtung des Spielers angibt (den Winkel zwischen der Blickrichtung und der Abszissenachse): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/f9a/af5/08df9aaf5713ca862e718a5fb0095d03.png"><br><br>  Und jetzt möchte ich in der Lage sein, über den orangefarbenen Strahl zu gleiten.  Wie geht das?  Sehr einfach.  Schauen wir uns ein grünes rechtwinkliges Dreieck an.  Wir wissen, dass cos (player_a) = a / c und sin (player_a) = b / c. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99c/338/bcf/99c338bcf91ba076c1bd2bfdb15e129d.png"><br><br>  Was passiert, wenn ich willkürlich den Wert von c (positiv) nehme und x = Spieler_x + c * cos (Spieler_a) und y = Spieler_y + c * sin (Spieler_a) zähle?  Wir werden uns am violetten Punkt befinden;  Durch Variieren des Parameters c von Null bis unendlich können wir diesen violetten Punkt entlang unseres orangefarbenen Strahls gleiten lassen, und c ist der Abstand von (x, y) zu (player_x, player_y)! <br><br>  Das Herzstück unserer Grafik-Engine ist dieser Zyklus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; c&lt;<span class="hljs-number"><span class="hljs-number">20</span></span>; c+=<span class="hljs-number"><span class="hljs-number">.05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = player_x + c*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = player_y + c*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(x)+<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(y)*map_w]!=<span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Wir bewegen den Punkt (x, y) entlang des Strahls. Wenn er auf ein Hindernis auf der Karte stößt, beenden wir den Zyklus und die Variable c gibt den Abstand zum Hindernis an!  Was ist kein Laser-Entfernungsmesser? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9f/52d/3ce/c9f52d3ceaaffc1b4396fd13c9ab24df.png"><br><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 5: Sektorübersicht </h1><br>  Ein Strahl ist in Ordnung, aber unsere Augen sehen immer noch einen ganzen Sektor.  Nennen wir den Betrachtungswinkel fov (Sichtfeld): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d4/83a/e06/1d483ae06cf65809eea61660c1a58db5.png"><br><br>  Und lassen Sie uns 512 Strahlen freisetzen (übrigens, warum 512?), Die den gesamten Betrachtungssektor reibungslos erfassen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/271/d5d/fab271d5dfe3dd4e8b87df6fc4c52676.png"><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 6: 3D! </h1><br>  Und jetzt der entscheidende Punkt.  Für jede der 512 Strahlen haben wir die Entfernung zum nächsten Hindernis, richtig?  Und jetzt machen wir ein zweites Bild mit einer Breite von 512 Pixel (Spoiler).  in dem wir für jeden Strahl ein vertikales Segment zeichnen und die Höhe des Segments umgekehrt proportional zum Abstand zum Hindernis ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f4/bf6/c7c/4f4bf6c7caa9931a087d04d6f33b4dbc.png"><br><br>  Auch dies ist der Schlüssel zum Erstellen der 3D-Illusion. Stellen Sie sicher, dass Sie verstehen, worum es geht.  Beim Zeichnen vertikaler Segmente zeichnen wir einen Lattenzaun, bei dem die Höhe jedes Pfahls umso geringer ist, je weiter er von uns entfernt ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/fc6/030/ed6fc60305a6da0d29d07850ba49e92a.jpg"><br><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 7: Erste Animation </h1><br>  Zu diesem Zeitpunkt zeichnen wir zum ersten Mal etwas Dynamisches (ich lege einfach 360 Bilder auf die Festplatte).  Alles ist trivial: Ich ändere player_a, zeichne ein Bild, speichere, ändere player_a, zeichne, speichere.  Um es ein bisschen lustiger zu machen, habe ich jedem Zelltyp in unserer Karte einen zufälligen Farbwert zugewiesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29d/38f/f7a/29d38ff7a03c91429cd5cbd7476fb8ed.gif"><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 8: Fischaugenkorrektur </h1><br>  Haben Sie bemerkt, welchen großartigen Fischaugeneffekt wir erzielen, wenn wir eine Wand aus der Nähe betrachten?  Es sieht so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/fe7/f78/362fe7f78fc2d314e09b36f39d0bab6d.png"><br><br>  Warum?  Ja, sehr einfach.  Hier schauen wir uns die Wand an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/632/227/e6763222768e380912c1c47d51a95871.png"><br><br>  Um unsere Wand zu zeichnen, beleuchten wir unseren blauen Sichtbereich mit einem lila Strahl.  Nehmen Sie den spezifischen Wert der Strahlrichtung wie in diesem Bild.  Die Länge des orangefarbenen Segments ist deutlich geringer als die Länge des Purpurs.  Da wir zur Bestimmung der Höhe jedes vertikalen Segments, das wir auf dem Bildschirm zeichnen, durch den Abstand zum Hindernis dividieren, ist das Fischauge ganz natürlich. <br><br>  Um diese Verzerrung zu korrigieren, ist es überhaupt nicht schwierig, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen Sie sich an, wie dies gemacht wird</a> .  Bitte stellen Sie sicher, dass Sie verstehen, woher der Kosinus stammt.  Das Zeichnen eines Diagramms auf ein Blatt Papier hilft sehr. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df8/a7d/df4/df8a7ddf414fdc2018bd1649be3682f9.gif"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Schritt 9: Laden Sie die Texturdatei </h1><br>  Es ist Zeit, sich mit Texturen zu befassen.  Ich bin faul, selbst einen Bild-Downloader zu schreiben, also habe ich die ausgezeichnete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stb-Bibliothek genommen</a> .  Ich habe eine Datei mit Texturen für die Wände vorbereitet, alle Texturen sind quadratisch und horizontal im Bild gepackt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c6/48e/8fd/5c648e8fd4cca05610b977b3f5b31cfe.png"><br><br>  Zu diesem Zeitpunkt lade ich einfach die Texturen in den Speicher.  Um den geschriebenen Code zu testen, zeichne ich einfach, da es sich um eine Textur mit Index 5 in der oberen linken Ecke des Bildschirms handelt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e4/a78/a9a/8e4a78a9a98ccfe4acd81ceb8f2faafa.png"><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 10: rudimentäre Verwendung von Texturen </h1><br>  Jetzt werfe ich zufällig erzeugte Farben aus und färbe meine Wände, indem ich das obere linke Pixel aus der entsprechenden Textur nehme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/21d/0b1/87d21d0b13110a2b05194033b8f609aa.png"><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 11: Texturieren der Wände </h1><br>  Und jetzt ist der lang erwartete Moment gekommen, in dem wir endlich die Backsteinmauern sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/e25/e71/175e25e71fccf3ad167a120b878f1b60.png"><br><br>  Die Grundidee ist sehr einfach: Hier gleiten wir entlang des aktuellen Strahls und halten am Punkt x, y an.  Nehmen wir an, wir haben uns auf einer „horizontalen“ Wand niedergelassen, dann ist y fast eine ganze Zahl (nicht wirklich, weil unsere Art, sich entlang des Strahls zu bewegen, einen kleinen Fehler verursacht).  Nehmen wir den Bruchteil von x und nennen ihn hitx.  Der Bruchteil ist kleiner als eins. Wenn wir also hitx mit der Größe der Textur multiplizieren (ich habe 64), erhalten wir die Texturspalte, die an dieser Stelle gezeichnet werden muss.  Es bleibt, um es auf die richtige Größe zu dehnen und das Ding ist im Hut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f9/444/f1c/1f9444f1cb378b082588479885799b80.png"><br><br>  Im Allgemeinen ist die Idee äußerst primitiv, erfordert jedoch eine sorgfältige Ausführung, da wir auch „vertikale“ Wände haben (solche mit Hitx nahe Null [x Ganzzahl]).  Für sie wird die Texturspalte durch hity, den Bruchteil von y, bestimmt.  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><hr><br><h1>  Stufe 12: Zeit zum Refactor! </h1><br>  Zu diesem Zeitpunkt habe ich nichts Neues gemacht, sondern nur mit der allgemeinen Reinigung begonnen.  Bis jetzt hatte ich eine gigantische Datei (185 Zeilen!), Und es wurde schwierig, darin zu arbeiten.  Daher habe ich es leider im Vorbeigehen in eine Wolke kleinerer Teile zerlegt und die Codegröße (319 Zeilen) fast verdoppelt, ohne zusätzliche Funktionen hinzuzufügen.  Aber dann ist es viel bequemer geworden, zum Beispiel eine Animation zu generieren. Es reicht aus, eine solche Schleife zu erstellen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> frame=<span class="hljs-number"><span class="hljs-number">0</span></span>; frame&lt;<span class="hljs-number"><span class="hljs-number">360</span></span>; frame++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setfill(<span class="hljs-string"><span class="hljs-string">'0'</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; frame &lt;&lt; <span class="hljs-string"><span class="hljs-string">".ppm"</span></span>; player.a += <span class="hljs-number"><span class="hljs-number">2</span></span>*M_PI/<span class="hljs-number"><span class="hljs-number">360</span></span>; render(fb, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, player, tex_walls); drop_ppm_image(ss.str(), fb.img, fb.w, fb.h); }</code> </pre><br>  Nun, hier ist das Ergebnis: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyraycaster/master/doc/012.gif"><br>  Die Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können Sie hier sehen</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitpod.io/&amp;usg=ALkJrhibdoBgAuWxDm4AQYVqruhB1rn__g#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Im gitpod öffnen"></a> <br><br><h1>  Fortsetzung folgt ... sofort </h1><br>  In diesem optimistischen Sinne beende ich die aktuelle Hälfte meines Blattes, die zweite Hälfte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Darin werden wir Monster hinzufügen und auf SDL2 verlinken, damit Sie einen Spaziergang durch unsere virtuelle Welt machen können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439698/">https://habr.com/ru/post/de439698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439688/index.html">Überblick über AI & ML-Lösungen im Jahr 2018 und Prognosen für 2019: Teil 1 - NLP, Computer Vision</a></li>
<li><a href="../de439690/index.html">Vergleich der Leistung virtueller Maschinen von 6 Cloud-Plattformen: Selectel, MCS, I. Cloud, Google Cloud, AWS und Azure</a></li>
<li><a href="../de439692/index.html">AT & T wurde wegen Änderung des Netzwerksymbols von 4G auf 5G E verklagt</a></li>
<li><a href="../de439694/index.html">Intelligentes Gewebe, das auf Änderungen der Körpertemperatur reagiert</a></li>
<li><a href="../de439696/index.html">Auf dem Wellenkamm oder "Ich will Mainstream" - aber lohnt es sich?</a></li>
<li><a href="../de439700/index.html">Brettspielpatent in Russland</a></li>
<li><a href="../de439704/index.html">Von der Poolanforderung bis zur Freigabe. Bericht Yandex.Taxi</a></li>
<li><a href="../de439706/index.html">Konferenz BLACK HAT. Lehren aus dem Überleben eines DDOS-Angriffs mit 300 Gbit / s. Teil 1</a></li>
<li><a href="../de439708/index.html">Konferenz BLACK HAT. Lehren aus dem Überleben eines DDOS-Angriffs mit 300 Gbit / s. Teil 2</a></li>
<li><a href="../de439710/index.html">Merkmale der Erstellung von Produkten für den US-Markt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>