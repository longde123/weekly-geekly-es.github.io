<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 ✳️ 🗒️ Uji ketahanan otomasi ℹ️ 🤰🏿 👩🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terlepas dari kenyataan bahwa teknologi unit testing telah ada selama 30 tahun (Kent Beck menulis artikel “Simple Smalltalk Testing: With Patterns” pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uji ketahanan otomasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418491/"><p>  Terlepas dari kenyataan bahwa teknologi unit testing telah ada selama 30 tahun (Kent Beck menulis artikel “Simple Smalltalk Testing: With Patterns” pada tahun 1989), tidak semua programmer memiliki teknologi ini dan tidak semua perusahaan menjadikan pengujian otomatis sebagai bagian dari budaya perusahaan mereka. .  Meskipun ada keuntungan nyata dari pengujian otomatis, resistensi perilaku masih cukup kuat.  Siapa pun yang mencoba menerapkan tes otomatis tahu bahwa selalu ada beberapa alasan mengapa ini tidak dapat dilakukan. </p><br><p>  Dari pengalaman pribadi saya menerapkan metode pemrograman yang andal di perusahaan saya, di perusahaan yang saya berkonsultasi, berkomunikasi di konferensi, dan juga dari sumber yang tersedia untuk umum, saya telah merumuskan keberatan dan penolakan yang khas yang menghambat penerapan budaya pengujian otomatis. </p><br><p>  Saya mengelompokkan semua keberatan ke dalam piramida pemrograman yang andal, yang meliputi empat level: <a name="habracut"></a></p><br><ul><li>  <strong>Budaya profesional</strong> (tingkat tertinggi, dasar pemrograman yang andal) adalah seperangkat norma, aturan tidak tertulis, keyakinan karyawan yang membimbingnya dalam pekerjaannya.  Sebagai contoh: "Mengirim kode yang ditemukan oleh tes ke repositori buruk", "Membungkam tentang kesalahan yang ditemukan dalam kode itu memalukan". </li><li>  <strong>Manajemen</strong> adalah prosedur, kebijakan, aturan yang diadopsi oleh organisasi, serta kehendak (keputusan) para pemimpin.  Misalnya: “Setiap fungsi aplikasi yang dikembangkan harus melewati kode ulasan.  Tanpa pengecualian! " </li><li>  <strong>Metode</strong> adalah pendekatan ilmiah, metode untuk memecahkan masalah tertentu.  Misalnya: "Jika fungsi aplikasi sulit untuk diuji, Anda perlu meningkatkan testabilitas aplikasi dengan menerapkan templat Injeksi Ketergantungan." </li><li>  <strong>Teknologi</strong> (tingkat terendah) adalah bahasa pemrograman, perpustakaan, kerangka kerja, alat.  Misalnya, JUnit, Selenium, XCTest dan sebagainya. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Mengapa pembagian seperti itu diperlukan?  Karena masalah satu tingkat diselesaikan dengan metode tingkat yang sama atau dengan metode tingkat yang lebih tinggi.  Misalnya, jika tidak lazim bagi organisasi untuk menulis tes otomatis (masalah budaya profesional), maka masalah ini tidak dapat diselesaikan dengan menjelaskan proses bisnis pengujian secara terperinci (level "manajemen") atau dengan memasang kerangka kerja modern (level "teknologi").  Saya memberikan jaminan bahwa dalam seminggu tidak ada yang akan menulis tes, terlepas dari proses bisnis yang disetujui. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Keberatan budaya </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  “Program saya tidak rusak.  Saya tidak melihat perlunya pengujian. " </h3><br><p>  Saya mendengar pernyataan ini dari para pemula atau programmer yang terlalu percaya diri. <br>  Tentu saja, sekali fungsi tertulis tidak dapat rusak dengan sendirinya.  Tetapi di sini penting untuk dipahami bahwa seiring waktu, program mungkin memerlukan dukungan, pengenalan fungsi baru atau penambahan fungsi yang ada.  Kompleksitas program - jumlah kelas dan ketergantungannya - cukup besar, dan akhirnya, setelah membuat fungsi baru atau meningkatkan yang sudah ada, kesalahan akan terjadi cepat atau lambat.  Tes otomatis akan mendeteksi regresi semacam itu. </p><br><p>  Selain itu, seringkali keberatan semacam itu dapat didengar dari programmer pemula yang tidak memiliki konsep pengujian.  Misalnya, hanya kerusakan yang dianggap gangguan, bukan kesalahan fungsional. </p><br><p>  Pada salah satu wawancara yang saya lakukan, dialog berikut berlangsung: </p><br><p>  - Apakah Anda memiliki keterampilan pengujian otomatis? <br>  - Tidak, saya menulis program sederhana, tidak ada yang perlu dipecahkan. <br>  - Apa motivasi Anda untuk berganti pekerjaan? <br>  - Saya ingin menulis aplikasi yang kompleks. </p><br><p>  Saya tahu betul bagaimana ini berakhir.  Programmer dipercaya untuk mengembangkan program yang lebih kompleks, tetapi ia tidak tahu metode pengujian otomatis, ia tidak dapat menguji aplikasi secara kualitatif, dan ia tidak dapat mengatasi skala proyek, yang akan mengarah pada gangguan proyek, pembengkakan biaya pengembangan, hilangnya reputasi.  Karena saya pribadi mengelola proyek, di mana saya tidak dapat mengatasi skala proyek dan gagal justru karena kurangnya tes otomatis. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Keengganan untuk bertanggung jawab atas kualitas kode, untuk pengujian. </h3><br><p>  Tes otomatis adalah satu-satunya sumber informasi operasional dan obyektif tentang kualitas sebenarnya dari produk perangkat lunak.  Dengan kata lain, programmer selalu memiliki pengawas di belakangnya, yang dapat melaporkan kepada manajemen kapan saja tentang seberapa baik programmer melakukan pekerjaannya.  Tes otomatis memungkinkan Anda untuk menghubungkan produktivitas pekerjaan tidak dengan tiket tertutup di Jira, tetapi dengan kualitas produk perangkat lunak yang sebenarnya.  Dan di sini Anda sudah perlu memikirkan cara menulis dengan andal sehingga setiap perubahan kode tidak merusak fungsi yang ada.  Sehingga setiap fungsi baru berfungsi tidak hanya dalam skrip, ketika semuanya baik-baik saja, tetapi juga memproses kesalahan dengan benar. </p><br><p>  Tanggung jawab adalah komitmen sukarela untuk memastikan hasil kerja yang positif.  Karyawan menerima kewajiban ini berdasarkan karakter dan pendidikannya.  Sayangnya, karena krisis budaya dan profesional, tidak setiap programmer siap untuk mengambil kewajiban seperti itu. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Tulis sekarang juga tanpa kesalahan" </h3><br><p>  Orang-orang yang tidak begitu akrab dengan cara kerja pengembangan perangkat lunak mungkin memiliki sikap negatif terhadap pengembang yang menyebutkan beberapa jenis kesalahan. </p><br><p>  - Mari kita bahas aplikasi dengan tes otomatis. <br>  - Kenapa? <br>  - Untuk memastikan semuanya bekerja dengan benar dan tidak ada kesalahan. <br>  - Apakah Anda menulis dengan kesalahan?  Apakah Anda memiliki kualifikasi rendah?  Menulis segera tanpa kesalahan. <br>  "Ya, tapi semua orang membuat kesalahan ..." <br>  - Tetapi perusahaan XYZ berkata kepada seorang teman bahwa mereka memiliki programmer top yang menulis tanpa kesalahan! </p><br><p>  Dengan demikian, pengembangan tes sulit untuk "dijual" kepada pelanggan yang secara teknis tidak paham.  Akibatnya, manajemen terpaksa mengembangkan proyek tanpa tes otomatis, yang mengarah ke masalah yang diketahui. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Keberatan Manajemen </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  “Dengan tes, menulis sebuah program dua kali lebih lama.  Kami tidak akan memenuhi tenggat waktu. ” </h3><br><p>  Sepintas, tesis ini tampak adil.  Sangat penting untuk menghabiskan waktu menulis tes programmer.  Tetapi programmer dan manajemen tidak memperhitungkan bahwa total waktu pengembangan produk tidak hanya mencakup pemrograman, tetapi juga debugging dan dukungan, serta biaya yang sangat besar untuk pengujian regresi manual setelah melakukan koreksi. </p><br><p>  Tes otomatis memiliki beberapa fungsi: </p><br><ol><li>  <strong>Memeriksa</strong> <br>  1.1.  Tes memverifikasi bahwa objek uji berfungsi dengan benar. <br>  1.2.  Tes memeriksa kualitas pekerjaan programmer: apakah tugas diselesaikan, apakah ada efek samping dalam bentuk regresi. </li><li>  <strong>Mendiagnosis</strong>  Tes diagnostik dapat secara signifikan mengurangi waktu untuk mencari cacat.  Tes memungkinkan Anda untuk menentukan lokasi kesalahan yang akurat untuk kelas dan metode, dan kadang-kadang akurat ke baris kode. </li><li>  <strong>Mengotomatisasi</strong> .  Tes memungkinkan Anda untuk dengan cepat dan mudah memasukkan objek uji dalam kondisi yang diinginkan untuk debugging. </li><li>  <strong>Mendokumentasikan</strong> . <br>  4.1.  Tes penerimaan mencatat persyaratan pelanggan untuk produk yang sedang dikembangkan. <br>  4.2.  Pengujian menunjukkan contoh penggunaan komponen yang dikembangkan, sehingga mengurangi waktu yang dihabiskan untuk mempelajari pekerjaan sistem oleh programmer lain. </li></ol><br><p>  Di salah satu organisasi yang saya berkonsultasi, manajer menolak memperkenalkan budaya pengujian otomatis: </p><br><p>  - Tapi bagaimanapun, menulis tes untuk waktu yang lama!  Kami tidak akan memenuhi tenggat waktu! <br>  - Apakah Anda memiliki kesalahan yang telah Anda cari dan koreksi untuk waktu yang sangat lama? <br>  - Ya, ada beberapa. <br>  - Kasus apa yang paling sulit? <br>  - Kami mencari satu kesalahan selama 80 jam. <br>  - 80 jam adalah dua minggu kerja programmer.  Jika Anda bahkan menghabiskan satu minggu penuh pengujian otomatisasi, itu akan menghemat waktu berbulan-bulan dalam mendiagnosis dan men-debug aplikasi Anda! </p><br><p>  Organisasi kami memiliki postulat: "Dengan tes, menulis sebuah program dua kali lebih cepat!"  dan dalil ini tidak dibahas.  Hanya koefisien 2 yang dibahas - kadang-kadang ada 3 dan 4. Dan beberapa proyek tidak dapat diselesaikan tanpa pengujian otomatis yang kompeten (lihat proyek kewalahan). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  "Kami sudah memiliki departemen pengujian manual, biarkan mereka menguji." </h3><br><p>  Sekilas, pemisahan spesialisasi ke dalam pengujian dan pemrograman tampaknya logis. </p><br><p>  Tapi mari kita lihat kelemahan dari pengujian manual: </p><br><ul><li>  Itu sangat mahal. </li><li>  Butuh waktu yang sangat lama.  Sebagai contoh: skrip uji untuk aplikasi mobile "Bioskop Online" menghasilkan waktu 40 jam.  Dan ini hanya untuk satu platform!  Jika Anda perlu menguji aplikasi pada iPhone, iPad, Apple TV, Android, Fire TV, maka Anda perlu menghabiskan 40 × 6 = 240 jam waktu kerja, ini adalah satu setengah bulan, yang tidak dapat diterima untuk siklus pengembangan singkat. </li><li>  Pengujian manual tunduk pada kesalahan manusia yang umum - itu tidak memberikan hasil yang objektif dan benar. </li></ul><br><p>  Selain itu, beberapa jenis pengujian tidak dapat dilakukan dalam waktu yang wajar, karena jumlah kombinasi format dan berbagai skrip pengujian sangat besar.  Sebagai contoh: </p><br><ol><li>  Berfungsi untuk mengimpor file CSV. </li><li>  Parser untuk dokumen teks. </li><li>  Instrumen keuangan. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Metode Tingkat Keberatan </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ketidaktahuan tentang metode pengujian otomatis. </h3><br><p>  Karena krisis dalam pendidikan, tidak ada disiplin pengujian otomatis di mana pun di universitas.  Ada beberapa kursus seperti itu di sekolah-sekolah TI komersial.  Dan kursus yang ada dangkal dan berkualitas buruk.  Oleh karena itu, saya sering bertemu orang bodoh di antara programmer: mereka tidak tahu cara menguji aplikasi non-sepele (lebih sulit dari 2 + 2 = 4). </p><br><p>  Padahal, ilmu pengujian cukup luas.  Misalnya, tidak setiap programmer akan segera menjawab pertanyaan: a) apa itu testability?  b) apa yang dapat dikontrol dan diamati?  c) pola desain mana yang meningkatkan testabilitas aplikasi?  Dan sebagainya. </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Pemrogram tidak tahu apa yang mereka tulis, bagaimana tampilannya, apa fungsi dan antarmuka yang akan. </h3><br><p>  Sangat sulit untuk menguji apa yang tidak jelas kelihatannya.  Dengan kata lain, tanpa persyaratan yang ditentukan sebelumnya untuk aplikasi, programmer tidak dapat memahami apa yang diharapkan darinya. </p><br><p>  Keunikan dari beberapa proyek adalah bahwa mereka dikembangkan menggunakan teknologi Produk yang Layak Minimum, yang dengan kata lain dapat digambarkan sebagai berikut: "Mari kita lakukan setidaknya sesuatu untuk waktu minimum dan anggaran minimum", dan programmer dianggap oleh pelanggan atau manajemen sebagai analis, desainer, arsitek, programmer dan tester dalam satu botol.  Dengan pendekatan ini, tahap formal merancang sistem perangkat lunak tidak termasuk: definisi logika bisnis, domain, antarmuka komponen, serta organisasi internal mereka tentang hubungan mereka di antara mereka.  Tidak ada arsitektur formal, tidak ada antarmuka, tidak ada proses bisnis yang ditentukan - tidak jelas apa yang harus diuji, melalui antarmuka mana dan apa hasil yang diharapkan. </p><br><h3 id="netestoprigodnyy-kod">  Kode yang tidak pantas. </h3><br><p>  Testability adalah properti proyek yang mengatakan betapa mudahnya dapat diuji.  Kesesuaian tes ditentukan oleh dua sifat lainnya: kemampuan kontrol dan kemampuan observasi.  Manageability - properti yang menentukan betapa mudahnya memasukkan aplikasi ke kondisi yang diinginkan untuk pengujian (memenuhi prasyarat).  Observabilitas - betapa mudahnya mempertimbangkan keadaan setelah tes, bandingkan dengan yang diharapkan. </p><br><p>  Misalnya, otentikasi dua faktor menggunakan SMS sangat sulit untuk diuji secara otomatis, karena fungsi menerima SMS berada di luar lingkup lingkungan pengujian otomatis.  Sistem seperti itu tidak cocok. </p><br><p>  Menghadapi sistem yang tidak cocok, programmer menyerah dan menghindari pengujian sistem seperti itu. </p><br><h3 id="podgotovka-testovyh-dannyh">  Persiapan data uji. </h3><br><p>  Salah satu hambatan yang tidak terlihat adalah persiapan data uji dan standar.  Misalnya: keadaan awal basis data tempat pengujian dilakukan.  Penyiapan data uji dapat memakan banyak waktu dan pekerjaan rutin, sehingga pekerjaan ini dianggap tidak berterima kasih dan tidak menarik di kalangan programmer. </p><br><p>  Solusi: </p><br><ul><li>  pengembangan nilai referensi dan contoh-contoh pada tahap pengembangan tes penerimaan - mereka juga akan membantu menyelesaikan konflik dengan pelanggan pada tahap penerimaan pekerjaan; </li><li>  pengembangan nilai referensi pada tahap perancangan sistem.  Misalnya, permintaan dan respons HTTP standar - akan membantu lebih mudah untuk mengintegrasikan klien dan server; </li><li>  pengembangan prosedur khusus untuk merakit basis data, di mana keadaan yang diperlukan dari basis data dibuat secara otomatis, dan tidak secara manual </li><li>  penggunaan templat Object Mother [Fowler, Schuh, Peter, dan Stephanie Punke.  "Mempermudah Pembuatan Objek Tes di XP."  XP Universe.  2003], yang membantu untuk dengan mudah mengalokasikan dan menginisialisasi objek dalam keadaan yang diperlukan. </li></ul><br><h3 id="obsluzhivanie-testov">  Layanan pengujian. </h3><br><p>  Selama pengembangan proyek, persyaratan untuk itu (klarifikasi, perubahan) dapat berubah.  Atau internal refactoring dapat terjadi, yang akan mengarah pada perubahan antarmuka kelas.  Dengan perubahan persyaratan, kriteria penerimaan fungsi tertentu juga akan berubah, dan disertai pengujian.  Pada titik tertentu, pemrogram mungkin menolak untuk melayani tes - yaitu, dari mempertahankan mereka up to date. </p><br><p>  Solusi: </p><br><ul><li>  menggunakan templat “adaptor” untuk memisahkan logika pengujian dari antarmuka yang diuji; </li><li>  penggunaan tes tingkat tinggi (Gherkin, Mentimun, Diberi Kapan-Saat); </li><li>  lihat solusi untuk resistensi "persiapan data uji". </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Tidak ada keraguan bahwa perangkat lunak harus dapat diandalkan: melebihi harapan pelanggan.  Tes otomatis bukan satu-satunya, tetapi komponen penting dalam pengembangan perangkat lunak yang andal. </p><br><p>  Saya merumuskan keberatan dan hambatan khas untuk pelaksanaan pengujian otomatis, yang secara pribadi saya temui di organisasi saya, serta di organisasi-organisasi yang saya konsultasikan. </p><br><p>  Artikel ini hanya menguraikan masalah dan hampir tidak menyentuh cara untuk menyelesaikannya.  Secara umum, strategi untuk menyelesaikan masalah ini bagi saya seperti ini: </p><br><ol><li>  Pembentukan dan promosi budaya desain TI yang baru, yaitu keandalan, kebanggaan, dan tanggung jawab pribadi atas hasilnya. </li><li>  Mengembangkan standar tinggi baru untuk pengujian kode. </li><li>  Pengembangan dan implementasi kursus pelatihan. </li><li>  Pengenalan motivasi dalam karier programmer dan manajer, terkait dengan kualitas produk perangkat lunak yang dikembangkan, serta keterampilan pengujian otomatis. </li></ol><br><p>  Hal terpenting yang berhasil saya pahami adalah bahwa masalahnya ada pada tingkat yang berbeda: teknologi, metodologis, manajerial dan budaya.  Dan mereka perlu ditangani pada tingkat yang sesuai.  Sangat sulit untuk menerapkan tes otomatis jika programmer tidak terlatih dalam metode desain yang sesuai uji atau jika manajemen tidak mendukung budaya pemrograman yang dapat diandalkan dalam organisasi. </p><br><p>  Saya akan berterima kasih atas contoh dari praktik Anda tentang betapa mudah atau sulitnya untuk menerapkan tes otomatis di organisasi Anda.  Masalah apa yang kamu hadapi?  Bagaimana Anda mengatasinya? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418491/">https://habr.com/ru/post/id418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418481/index.html">Kehidupan di Israel - Beberapa Momen Terkait IT</a></li>
<li><a href="../id418483/index.html">Cara memampatkan bootloader untuk STM8 ke ukuran 8 byte dalam memori FLASH</a></li>
<li><a href="../id418485/index.html">Breaking Bad 3 - Cross the Dark Forester</a></li>
<li><a href="../id418487/index.html">Tentang pekerjaan di Jerman</a></li>
<li><a href="../id418489/index.html">Karya konstruksi kolom dunia: evolusi standar tiga arah, sekte studio JBL</a></li>
<li><a href="../id418493/index.html">Bluetooth Kisah orang pertama</a></li>
<li><a href="../id418497/index.html">"Aku tidak mengenali kamu dalam makeup" (c)</a></li>
<li><a href="../id418499/index.html">SAMBA meningkatkan pengalaman klasik di Debian 8</a></li>
<li><a href="../id418501/index.html">Korban GDPR: yang sudah berhenti bekerja karena peraturan baru tentang data pribadi</a></li>
<li><a href="../id418503/index.html">Setelah 2020, Inggris akan memperoleh pelabuhan antariksa pertama - di Skotlandia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>