<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 📤 🏪 Comment analyser le protocole réseau MMORPG mobile 👨🏿‍🚒 💪🏽 🧒🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au fil des années de jeu sur un MMORPG mobile, j'ai acquis une certaine expérience dans sa rétro-ingénierie, que je voudrais partager dans une série d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment analyser le protocole réseau MMORPG mobile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451512/">  Au fil des années de jeu sur un MMORPG mobile, j'ai acquis une certaine expérience dans sa rétro-ingénierie, que je voudrais partager dans une série d'articles.  Exemples de sujets: <br><br><ol><li>  Analyser le format des messages entre le serveur et le client. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Écrire une application d'écoute pour visualiser le trafic du jeu de manière pratique.</a> </li><li>  Interception du trafic et sa modification à l'aide d'un serveur proxy non HTTP. </li><li>  Les premières étapes vers votre propre serveur ("piraté"). </li></ol><br>  Dans cet article, je vais discuter de l' <b>analyse du format de message entre le serveur et le client</b> .  Intéressé, je demande chat. <br><a name="habracut"></a><br><h3>  Outils requis </h3><br>  Pour pouvoir répéter les étapes décrites ci-dessous, vous aurez besoin de: <br><br><ul><li>  PC (je l'ai fait sur Windows 7/10, mais MacOS pourrait aussi fonctionner si les éléments ci-dessous sont disponibles là-bas); </li><li>  Wireshark pour l'analyse des paquets; </li><li>  010Éditeur pour analyser les paquets par modèle (facultatif, mais vous permet de décrire rapidement et facilement le format du message); </li><li>  l'appareil mobile lui-même avec le jeu. </li></ul><br>  De plus, il est très souhaitable d'avoir à portée de main des données lisibles du jeu, comme une liste d'objets, de créatures, etc. avec leurs identifiants.  Cela simplifie considérablement la recherche de points clés dans les packages et parfois vous permet de filtrer le message souhaité dans un flux constant de données. <br><br><h3><anchor>  Analyse </anchor>  format de message entre serveur et client </h3><br>  Pour commencer, nous devons voir le trafic de l'appareil mobile.  C'est assez simple à faire (même si j'ai pris cette décision évidente pendant très longtemps): sur notre PC, nous créons un point d'accès Wi-Fi, nous nous connectons à partir d'un appareil mobile, sélectionnons l'interface souhaitée dans Wireshark - et nous avons tout le trafic mobile devant nos yeux. <br><br>  Après être entré dans le jeu et avoir attendu un certain temps afin que les requêtes qui ne sont pas liées au serveur de jeu lui-même soient arrêtées, vous pouvez observer l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/ye/61/inye619dyp2vh8iq8nvncdb25u0.png"></div><br>  À ce stade, nous pouvons déjà utiliser des filtres Wireshark pour voir uniquement les paquets entre le jeu et le serveur, ainsi qu'avec la charge utile uniquement: <br><br><pre><code class="plaintext hljs">tcp &amp;&amp; tcp.payload &amp;&amp; tcp.port == 44325</code> </pre> <br>  Si vous vous tenez dans un endroit calme, loin des autres joueurs et du PNJ, et que vous ne faites rien, vous pouvez voir constamment répéter les messages du serveur et du client (taille 76 et 84 octets respectivement).  Dans mon cas, le nombre minimum de packages différents a été envoyé sur l'écran de sélection des personnages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u-/n9/su/u-n9sutlnqod9lbgttfuon6g1ue.png"></div><br>  La fréquence de la demande du client est très similaire au ping.  Prenons quelques messages pour vérification (3 groupes, ci-dessus est une demande d'un client, ci-dessous est une réponse du serveur): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/z9/3e/v3z93eejzkii_hh6di5dwvbowfi.png"></div><br>  La première chose qui attire votre attention est l'identité des colis.  Les 8 octets supplémentaires dans la réponse une fois convertis au système décimal sont très similaires à l'horodatage en secondes: <code>5CD008F8 <sub>16</sub> = 1557137656 <sub>10</sub></code> (de la première paire).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous vérifions l'horloge</a> - oui, ça l'est.  Les 4 octets précédents correspondent aux 4 derniers octets de la demande.  Lors de la traduction, nous obtenons: <code>A4BB <sub>16</sub> = 42171 <sub>10</sub></code> , ce qui est également très similaire au temps, mais en millisecondes.  Cela coïncide à peu près avec le temps écoulé depuis le lancement du jeu, et c'est probablement le cas. <br><br>  Il reste à considérer les 6 premiers octets de la demande et de la réponse.  Il est facile de remarquer la dépendance de la valeur des quatre premiers octets du message (appelons ce paramètre <code>L</code> ) sur la taille du message: la réponse du serveur est supérieure à 8 octets, la valeur de <code>L</code> également augmenté de 8, cependant, la taille du paquet est supérieure de 6 octets à la valeur de <code>L</code> dans les deux cas.  Vous pouvez également remarquer que les deux octets après <code>L</code> conservent leur valeur à la fois dans les requêtes du client et du serveur, et étant donné que leur valeur diffère de un, nous pouvons dire avec certitude qu'il s'agit du code de message <code>C</code> (les codes de message associés seront très probablement déterminés séquentiellement).  La structure générale est suffisamment claire pour écrire un modèle minimal pour 010Editor: <br><br><ul><li>  4 premiers octets - <code>L</code> - taille de la charge utile du message; </li><li>  2 octets suivants - <code>C</code> - code de message; </li><li>  charge utile elle-même. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> {</span></span> uint payload_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFFFF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Payload Length"</span></span>&gt;; ushort event_code &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFF9988</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Event Code"</span></span>&gt;; byte payload[payload_length] &lt;name=<span class="hljs-string"><span class="hljs-string">"Event Payload"</span></span>&gt;; };</code> </pre><br>  Par conséquent, le format du message ping client: envoyer l'heure ping locale;  format de réponse du serveur: envoyez la même heure et l'heure d'envoi de la réponse en secondes.  Cela ne semble pas difficile, non? <br><br>  Essayons de rendre un exemple plus compliqué.  Debout dans un endroit calme et cachant les paquets ping, vous pouvez trouver des messages se téléporter et créer un objet (artisanat).  Commençons par le premier.  Possédant les données du jeu, je savais quelle valeur du point de téléportation rechercher.  Pour les tests, j'ai utilisé des points avec les valeurs <code>0x2B</code> , <code>0x67</code> , <code>0x6B</code> et <code>0x1AF</code> .  Comparez avec les valeurs dans les messages: <code>0x2B</code> , <code>0x67</code> , <code>0x6B</code> et <code>0x3AF</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y7/7r/qs/y77rqsd0mxecueorqwdip3ow3r8.png"></div><br>  Le désordre.  Deux problèmes sont visibles: <br><br><ol><li>  les valeurs ne sont pas 4 octets, mais de tailles différentes; </li><li>  toutes les valeurs ne correspondent pas aux données des fichiers, et dans ce cas, la différence est de 128. </li></ol><br>  De plus, lors de la comparaison avec le format ping, vous pouvez remarquer une différence: <br><br><ul><li>  incompréhensible <code>0x08</code> avant la valeur attendue; </li><li>  Une valeur de 4 octets, 4 de moins que <code>L</code> (appelons-le <code>D</code> Ce champ n'apparaît pas dans tous les messages, ce qui est un peu étrange, mais là où il est, la dépendance <code>L - 4 = D</code> préservée. D'une part, pour les messages avec une structure simple (comme ping) ce n'est pas nécessaire, mais de l'autre - ça a l'air inutile). </li></ul><br>  Certains d'entre vous, je pense, auraient déjà pu deviner la raison de l'inadéquation des valeurs attendues, mais je vais continuer.  Voyons ce qui se passe dans le métier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8f/zk/vs/8fzkvsleifr5b1yodx6a77ggx_g.png"></div><br>  Les valeurs attendues de 14183 et 14285 ne correspondent pas non plus aux valeurs réelles 28391 et 28621, mais la différence ici est déjà beaucoup plus grande que 128. Après de nombreux tests (y compris avec d'autres types de messages), il s'est avéré que plus le nombre attendu est élevé, plus la différence entre la valeur dans le paquet est grande.  Ce qui était étrange, c'est que les valeurs jusqu'à 128 restaient seules.  Compris, quoi de neuf?  La situation évidente est pour ceux qui l'ont déjà rencontré, et, sans le savoir, j'ai dû démonter ce «code» pendant deux jours (au final, l'analyse des valeurs sous forme binaire a aidé au «piratage»).  Le comportement décrit ci-dessus est appelé <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quantité de longueur variable</a></i> - une représentation d'un nombre qui utilise un nombre indéfini d'octets, où le huitième bit d'un octet (bit de continuation) détermine la présence de l'octet suivant.  D'après la description, il est évident que la lecture de VLQ n'est possible que dans l'ordre Little-Endian.  Par coïncidence, toutes les valeurs dans les paquets sont dans cet ordre. <br><br>  Maintenant que nous savons comment obtenir la valeur initiale, nous pouvons écrire un modèle pour le type: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VLQ</span></span></span><span class="hljs-class"> {</span></span> local <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> size = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { byte obf_byte; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((obf_byte &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80</span></span>) { size++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } FSeek(FTell() - size); byte bytes[size]; local uint64 _ = FromVLQ(bytes, size); };</code> </pre><br>  Et la fonction de conversion d'un tableau d'octets en une valeur entière: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromVLQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte bytes[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ local uint64 source = <span class="hljs-number"><span class="hljs-number">0</span></span>; local <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; local byte x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { x = bytes[i]; source |= (x &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>) * Pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, i * <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   &lt;&lt;   , ..     ,  uint32,        uint64 if ((x &amp; 0x80) != 0x80) { break; } } return source; };</span></span></code> </pre><br>  Mais revenons à la création du sujet.  <code>D</code> apparaît à nouveau et à nouveau <code>0x08</code> devant la valeur changeante.  Les deux derniers octets du message <code>0x10 0x01</code> sont étrangement similaires au nombre d'éléments de fabrication, où <code>0x10</code> a un rôle similaire à <code>0x08</code> mais toujours incompréhensible.  Mais maintenant, vous pouvez écrire un modèle pour cet événement: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CraftEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; byte marker1; VLQ craft_id &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Craft ID"</span></span>&gt;; byte marker2; VLQ quantity &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Craft Quantity"</span></span>&gt;; };</code> </pre><br>  Qui ressemblerait à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ex/sl/y1/exsly1e_f3_3dtj4mhyzryehzou.png"></div><br>  Et pourtant, c'étaient des exemples simples.  Il sera plus difficile d'analyser l'événement du mouvement du personnage.  Quelles informations attendons-nous?  Au minimum, les coordonnées du personnage où il regarde, sa vitesse et son état (debout, courir, sauter, etc.).  Puisqu'aucune ligne n'est visible dans le message, l'état est très probablement décrit par <code>enum</code> .  En énumérant les options, en les comparant simultanément avec les données des fichiers de jeu, ainsi qu'à travers de nombreux tests, vous pouvez trouver trois vecteurs XYZ en utilisant ce modèle encombrant: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; byte marker; VLQ move_time &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; VLQ character_state &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; };</code> </pre><br>  Résultat visuel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aw/wn/rz/awwnrzzruq2wtcnmwbpkho3q1x8.png"></div><br>  Les trois verts se sont avérés être les coordonnées de l'emplacement, les trois jaunes, très probablement, montrent où le personnage regarde et le vecteur de sa vitesse, et le dernier est l'état du personnage.  Vous pouvez remarquer des octets constants (marqueurs) entre les valeurs de coordonnées ( <code>0x0D</code> avant la valeur <code>X</code> , <code>0x015</code> avant <code>Y</code> et <code>0x1D</code> avant <code>Z</code> ) et avant l'état ( <code>0x30</code> ), dont la signification est <code>0x08</code> similaire à <code>0x08</code> et <code>0x10</code> .  Après avoir analysé de nombreux marqueurs d'autres événements, il s'est avéré qu'il détermine le type de valeur qui le suit (les trois premiers bits) et la signification sémantique, c'est-à-dire  dans l'exemple ci-dessus, si vous échangez les vecteurs tout en conservant leurs marqueurs ( <code>0x120F</code> devant les coordonnées, etc.), le jeu (théoriquement) devrait normalement analyser le message.  Sur la base de ces informations, vous pouvez ajouter quelques nouveaux types: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Packed</span></span></span><span class="hljs-class"> {</span></span> VLQ marker &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFFBB00</span></span>&gt;; <span class="hljs-comment"><span class="hljs-comment">//    VLQ! local uint size = marker.size; //       ( , )          switch (marker._ &amp; 0x7) { case 1: double v; size += 8; break; //     case 5: float v; size += 4; break; default: VLQ v; size += v.size; break; } }; struct PackedVector3 { Packed marker &lt;name="Marker"&gt;; Packed x &lt;name="X"&gt;; Packed y &lt;name="Y"&gt;; Packed z &lt;name="Z"&gt;; };</span></span></code> </pre><br>  Maintenant, notre modèle de message de mouvement a été considérablement réduit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; Packed move_time &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; PackedVector3 position &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; PackedVector3 direction &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; PackedVector3 speed &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; Packed state &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; };</code> </pre><br>  Un autre type dont nous pourrions avoir besoin dans l'article suivant est les lignes qui sont précédées de la valeur <code>Packed</code> de leur taille: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackedString</span></span></span><span class="hljs-class"> {</span></span> Packed length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[length.v._]; };</code> </pre><br>  Maintenant, en connaissant l'exemple de format de message, vous pouvez écrire votre application d'écoute pour la commodité de filtrer et d'analyser les messages, mais c'est le sujet de l'article suivant. <br><br>  <b>Upd:</b> merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">aml</a> pour l'allusion que la structure de message décrite ci-dessus est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Protocol Buffer</a> , et aussi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Tatikoma</a> pour un lien vers un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> connexe utile. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451512/">https://habr.com/ru/post/fr451512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451502/index.html">Événements numériques à Moscou du 13 au 19 mai</a></li>
<li><a href="../fr451504/index.html">Photos sur le web 2019</a></li>
<li><a href="../fr451506/index.html">Comment DNSCrypt a résolu le problème de certificat expiré en entrant une période de validité de 24 heures</a></li>
<li><a href="../fr451508/index.html">Guide factice: Création de chaînes DevOps à l'aide d'outils Open Source</a></li>
<li><a href="../fr451510/index.html">Un peu de paroles techniques sur les outils C ++ de JetBrains, et qu'est-ce que les licornes ont à voir avec ça</a></li>
<li><a href="../fr451514/index.html">Nouvelles des sous-grilles CSS</a></li>
<li><a href="../fr451516/index.html">Modèles de conception utilisés dans le framework Spring</a></li>
<li><a href="../fr451518/index.html">Nos sites Web mobiles dépouillés</a></li>
<li><a href="../fr451520/index.html">VDI: pas cher et gai</a></li>
<li><a href="../fr451522/index.html">Nous déployons l'automatisation en quelques heures: TypeScript, Protractor, Jasmine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>