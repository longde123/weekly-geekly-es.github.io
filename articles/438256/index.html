<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüç≥ üëß ü•Ä Haga m√°s con patrones en C # 8.0 ‚¨ÖÔ∏è üë®üèΩ‚Äç‚öïÔ∏è üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Visual Studio 2019 Preview 2 ya est√° disponible! Y con √©l, un par de caracter√≠sticas m√°s de C # 8.0 est√°n listas para que las pruebe. Se trata princi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haga m√°s con patrones en C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/438256/"><img width="120" align="left" src="https://habrastorage.org/webt/8w/rq/7v/8wrq7vfhyqv2saamr2d5z2jha5o.png"><p>  ¬°Visual Studio 2019 Preview 2 ya est√° disponible!  Y con √©l, un par de caracter√≠sticas m√°s de C # 8.0 est√°n listas para que las pruebe.  Se trata principalmente de coincidencia de patrones, aunque tocar√© algunas otras noticias y cambios al final. </p><br><a name="habracut"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Original en Blog</a> <br><br><h1>  M√°s patrones en m√°s lugares. </h1><br><p> Cuando C # 7.0 introdujo la coincidencia de patrones, dijimos que esper√°bamos agregar <em>m√°s</em> patrones en <em>m√°s</em> lugares en el futuro.  Ese momento ha llegado!  Estamos agregando lo que llamamos <em>patrones recursivos</em> , as√≠ como una forma de expresi√≥n m√°s compacta de instrucciones de <code>switch</code> llamadas (¬°lo has adivinado!) <em>Expresiones de cambio</em> . </p><br><p>  Aqu√≠ hay un ejemplo simple de patrones de C # 7.0 para comenzar: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { get; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre><br><h2>  Cambiar expresiones </h2><br><p>  Primero, observemos que muchas declaraciones de <code>switch</code> realmente no hacen mucho trabajo interesante dentro de los cuerpos de los <code>case</code> .  A menudo, todos solo producen un valor, ya sea asign√°ndolo a una variable o devolvi√©ndolo (como se indic√≥ anteriormente).  En todas esas situaciones, la declaraci√≥n de cambio es francamente bastante torpe.  Se siente como la caracter√≠stica del lenguaje de hace 5 d√©cadas, con mucha ceremonia. </p><br><p>  Decidimos que era hora de agregar una forma de expresi√≥n de <code>switch</code> .  Aqu√≠ est√°, aplicado al ejemplo anterior: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre><br><p>  Hay varias cosas aqu√≠ que cambiaron de las declaraciones de cambio.  Vamos a enumerarlos: </p><br><ul><li>  La palabra clave de <code>switch</code> es "infijo" entre el valor probado y la lista de casos <code>{...}</code> .  Eso lo hace m√°s compositivo con otras expresiones, y tambi√©n m√°s f√°cil de distinguir visualmente de una declaraci√≥n de cambio. </li><li>  La palabra clave <code>case</code> y <code>:</code> se han reemplazado con una flecha lambda <code>=&gt;</code> por brevedad. </li><li>  <code>default</code> se ha reemplazado con el patr√≥n <code>_</code> descarte por brevedad. </li><li>  ¬°Los cuerpos son expresiones!  El resultado del cuerpo seleccionado se convierte en el resultado de la expresi√≥n de cambio. </li></ul><br><p>  Dado que una expresi√≥n debe tener un valor o lanzar una excepci√≥n, una expresi√≥n de cambio que llegue al final sin una coincidencia arrojar√° una excepci√≥n.  El compilador hace un gran trabajo advirti√©ndole cuando este puede ser el caso, pero no lo obligar√° a finalizar todas las expresiones de cambio con un comod√≠n: ¬°puede que lo sepa mejor! </p><br><p>  Por supuesto, dado que nuestro m√©todo de <code>Display</code> ahora consiste en una √∫nica declaraci√≥n de retorno, podemos simplificarlo para que tenga cuerpo de expresi√≥n: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Para ser honesto, no estoy seguro de qu√© orientaci√≥n de formato daremos aqu√≠, pero debe quedar claro que esto es mucho m√°s claro y claro, especialmente porque la brevedad generalmente le permite formatear el interruptor de forma "tabular", como se indic√≥ anteriormente. , con patrones y cuerpos en la misma l√≠nea, y los <code>=&gt;</code> s alineados uno debajo del otro. </p><br><p>  Por cierto, planeamos permitir una coma final <code>,</code> despu√©s del √∫ltimo caso, de acuerdo con todas las otras "listas separadas por comas entre llaves" en C #, pero la Vista previa 2 a√∫n no permite eso. </p><br><h2>  Patrones de propiedad </h2><br><p>  Hablando de brevedad, los patrones de repente se est√°n convirtiendo en los elementos m√°s pesados ‚Äã‚Äãde la expresi√≥n de cambio anterior.  Hagamos algo al respecto. </p><br><p>  Tenga en cuenta que la expresi√≥n de cambio utiliza el <em>patr√≥n de tipo</em> <code>Point p</code> (dos veces), as√≠ como una cl√°usula <code>when</code> para agregar condiciones adicionales para el primer <code>case</code> . </p><br><p>  En C # 8.0 estamos agregando m√°s elementos opcionales al patr√≥n de tipo, lo que permite que el patr√≥n mismo profundice m√°s en el valor que coincide con el patr√≥n.  Puede convertirlo en un <em>patr√≥n de propiedad</em> agregando <code>{...}</code> contenga patrones anidados para aplicar a las propiedades o campos accesibles del valor.  Esto nos permite reescribir la expresi√≥n de cambio de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } p =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Ambos casos a√∫n comprueban que <code>o</code> es un <code>Point</code> .  El primer caso aplica el patr√≥n constante <code>0</code> recursivamente a las propiedades <code>X</code> e <code>Y</code> de <code>p</code> , verificando si tienen ese valor.  Por lo tanto, podemos eliminar la cl√°usula <code>when</code> en este y en muchos casos comunes. </p><br><p>  El segundo caso aplica el patr√≥n <code>var</code> a cada uno de <code>X</code> e <code>Y</code>  Recuerde que el patr√≥n <code>var</code> en C # 7.0 siempre tiene √©xito y simplemente declara una variable nueva para mantener el valor.  Por lo tanto, <code>x</code> e <code>y</code> pueden contener los valores int de <code>pX</code> y <code>pY</code> . </p><br><p>  Nunca usamos <code>p</code> , y de hecho podemos omitirlo aqu√≠: </p><br><pre> <code class="cpp hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre><br><p>  Una cosa que sigue siendo cierta para todos los patrones de tipo, incluidos los patrones de propiedad, es que requieren que el valor no sea nulo.  Eso abre la posibilidad de que el patr√≥n de propiedad "vac√≠o" <code>{}</code> se use como un patr√≥n compacto "no nulo".  Por ejemplo, podr√≠amos reemplazar el caso de reserva con los siguientes dos casos: </p><br><pre> <code class="cpp hljs"> {} =&gt; o.ToString(), null =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre><br><p>  El <code>{}</code> trata con los objetos no nulos restantes, y <code>null</code> obtiene los nulos, por lo que el cambio es exhaustivo y el compilador no se quejar√° de los valores que caen. </p><br><h2>  Patrones posicionales </h2><br><p>  El patr√≥n de propiedad no acort√≥ exactamente el segundo caso de <code>Point</code> , y no parece que valga la pena, pero hay m√°s que se puede hacer. </p><br><p>  Tenga en cuenta que la clase <code>Point</code> tiene un m√©todo <code>Deconstruct</code> , un llamado <em>deconstructor</em> .  En C # 7.0, los deconstructores permitieron que se deconstruyera un valor en la asignaci√≥n, para que pudiera escribir, por ejemplo: </p><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre><br><p>  C # 7.0 no integr√≥ la deconstrucci√≥n con patrones.  Eso cambia con los <em>patrones posicionales,</em> que son una forma adicional de extender los patrones de tipo en C # 8.0.  Si el tipo coincidente es un tipo de tupla o tiene un deconstructor, podemos usar patrones posicionales como una forma compacta de aplicar patrones recursivos sin tener que nombrar propiedades: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(var x, var y) =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Una vez que el objeto se ha emparejado como un <code>Point</code> , se aplica el deconstructor y los patrones anidados se aplican a los valores resultantes. </p><br><p>  Los deconstructores no siempre son apropiados.  Solo deben agregarse a tipos donde est√° realmente claro cu√°l de los valores es cu√°l.  Para una clase <code>Point</code> , por ejemplo, es seguro e intuitivo suponer que el primer valor es <code>X</code> y el segundo es <code>Y</code> , por lo que la expresi√≥n de cambio anterior es intuitiva y f√°cil de leer. </p><br><h2>  Patrones de tuplas </h2><br><p>  Un caso especial muy √∫til de patrones posicionales es cuando se aplican a tuplas.  Si una instrucci√≥n switch se aplica directamente a una expresi√≥n de tupla, incluso permitimos que se omita el conjunto adicional de par√©ntesis, como en <code>switch (x, y, z)</code> lugar de <code>switch ((x, y, z))</code> . </p><br><p>  Los patrones de tupla son excelentes para probar m√∫ltiples piezas de entrada al mismo tiempo.  Aqu√≠ hay una implementaci√≥n simple de una m√°quina de estado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Por supuesto, podr√≠amos optar por incluir <code>hasKey</code> en la tupla encendida en lugar de usar las cl√°usulas <code>when</code> ; es realmente una cuesti√≥n de gustos: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  En general, espero que puedan ver que los patrones recursivos y las expresiones de cambio pueden conducir a una l√≥gica de programa m√°s clara y declarativa. </p><br><h1>  Otras caracter√≠sticas de C # 8.0 en la Vista previa 2 </h1><br><p>  Si bien las caracter√≠sticas del patr√≥n son las principales que se pondr√°n en l√≠nea en VS 2019 Preview 2, hay algunas m√°s peque√±as que espero que tambi√©n encuentren √∫tiles y divertidas.  No entrar√© en detalles aqu√≠, pero solo te doy una breve descripci√≥n de cada uno. </p><br><h2>  Usando declaraciones </h2><br><p>  En C #, el <code>using</code> sentencias siempre causa un nivel de anidamiento, que puede ser muy molesto y perjudica la legibilidad.  Para los casos simples en los que solo desea que se limpie un recurso al final de un √°mbito, ahora debe <em>usar declaraciones en su</em> lugar.  Las declaraciones de uso son simplemente declaraciones de variables locales con una palabra clave de <code>using</code> en frente, y sus contenidos se disponen al final del bloque de declaraci√≥n actual.  Entonces en lugar de: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre><br><p>  Puedes simplemente escribir </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> var options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre><br><h2>  Estructuras de referencia desechables </h2><br><p>  Las estructuras de referencia se introdujeron en C # 7.2, y este no es el lugar para reiterar su utilidad, pero a cambio vienen con algunas limitaciones severas, como no poder implementar interfaces.  Las estructuras de referencia ahora pueden ser desechables sin implementar la interfaz <code>IDisposable</code> , simplemente teniendo un m√©todo <code>Dispose</code> en ellas. </p><br><h2>  Funciones locales est√°ticas </h2><br><p>  Si desea asegurarse de que su funci√≥n local no incurra en los costos de tiempo de ejecuci√≥n asociados con las variables de "captura" (referencia) del √°mbito de inclusi√≥n, puede declararla como <code>static</code> .  Luego, el compilador evitar√° la referencia de cualquier cosa declarada en las funciones de cierre, ¬°excepto otras funciones locales est√°ticas! </p><br><h1>  Cambios desde la vista previa 1 </h1><br><p>  Las caracter√≠sticas principales de la Vista previa 1 eran tipos de referencia anulables y secuencias as√≠ncronas.  Ambos han evolucionado un poco en la Vista previa 2, por lo que si ha comenzado a usarlos, es bueno tener en cuenta lo siguiente. </p><br><h2>  Tipos de referencia anulables </h2><br><p>  Hemos agregado m√°s opciones para controlar las advertencias anulables tanto en origen (a trav√©s de <code>#pragma warning</code> directivas de <code>#pragma warning</code> <code>#nullable</code> y <code>#pragma warning</code> ) como a nivel de proyecto.  Tambi√©n cambiamos la <code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> archivo del proyecto a <code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> . </p><br><h2>  Transmisiones as√≠ncronas </h2><br><p>  ¬°Cambiamos la forma de la <code>IAsyncEnumerable&lt;T&gt;</code> que el compilador espera!  Esto hace que el compilador no est√© sincronizado con la interfaz proporcionada en .NET Core 3.0 Preview 1, lo que puede ocasionarle muchos problemas.  Sin embargo, .NET Core 3.0 Preview 2 saldr√° pronto, y eso vuelve a sincronizar las interfaces. </p><br><h1>  Tener en eso! </h1><br><p>  Como siempre, ¬°estamos ansiosos por sus comentarios!  Juega con las nuevas caracter√≠sticas del patr√≥n en particular.  ¬øTe encuentras con paredes de ladrillo?  ¬øHay algo molesto?  ¬øCu√°les son algunos escenarios interesantes y √∫tiles que encuentres para ellos?  Pulse el bot√≥n de comentarios y h√°ganos saber! </p><br><p>  Feliz pirater√≠a </p><br><p>  Mads Torgersen, jefe de dise√±o de C # </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438256/">https://habr.com/ru/post/438256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438244/index.html">Nos ocupamos de las regulaciones criptogr√°ficas rusas ... usando el ejemplo del arresto de un narcotraficante</a></li>
<li><a href="../438248/index.html">GitHub Action Life</a></li>
<li><a href="../438250/index.html">La ignorancia de los principios de seguridad de la informaci√≥n no exime</a></li>
<li><a href="../438252/index.html">¬øPor qu√© no despeg√≥ el portal inmobiliario? Parte 1</a></li>
<li><a href="../438254/index.html">Eclipse lanza GlassFish 5.1 para Java EE 8</a></li>
<li><a href="../438260/index.html">C ++ "moderno": una sesi√≥n de lamentaci√≥n con lamentaciones</a></li>
<li><a href="../438262/index.html">Sistemas ciberf√≠sicos en el mundo moderno.</a></li>
<li><a href="../438264/index.html">Cifrado de tr√°fico en Direct Connect, Parte 1</a></li>
<li><a href="../438266/index.html">¬øPor qu√© el pentesting es importante para su negocio?</a></li>
<li><a href="../438270/index.html">Love Kubernetes en Mail.ru Group: 14 de febrero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>