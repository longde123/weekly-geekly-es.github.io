<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦 🧑🏿‍🤝‍🧑🏼 👩‍⚖️ كيف نجد تعبيرات لامدا في IntelliJ IDEA 👳 🧖🏽 🏴󠁧󠁢󠁳󠁣󠁴󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="يعد البحث عن التعليمات البرمجية والتنقل ميزات مهمة لأي IDE. في Java ، أحد خيارات البحث الشائعة الاستخدام هو البحث عن جميع تطبيقات الواجهة. تسمى هذه ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف نجد تعبيرات لامدا في IntelliJ IDEA</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img alt="اكتب التسلسل الهرمي في IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  يعد البحث عن التعليمات البرمجية والتنقل ميزات مهمة لأي IDE.  في Java ، أحد خيارات البحث الشائعة الاستخدام هو البحث عن جميع تطبيقات الواجهة.  تسمى هذه الميزة غالبًا Type Hierarchy ، ويبدو تمامًا مثل الصورة الموجودة على اليمين. </p><br><p style=";text-align:right;direction:rtl">  من غير الفعال التكرار في جميع فئات المشروع عندما يتم استدعاء هذه الميزة.  يتمثل أحد الخيارات في حفظ التسلسل الهرمي للفئة الكاملة في الفهرس أثناء التحويل البرمجي نظرًا لأن المترجم يقوم بإنشائه على أي حال.  نقوم بذلك عندما يتم تشغيل التحويل البرمجي بواسطة IDE ولا يتم تفويضه ، على سبيل المثال ، إلى Gradle.  ولكن هذا لا يعمل إلا إذا لم يتغير شيء في الوحدة النمطية بعد التحويل البرمجي.  بشكل عام ، الكود المصدري هو أكثر مزود معلومات محدّثًا ، وتستند الفهارس إلى الكود المصدري. </p><br><p style=";text-align:right;direction:rtl"> العثور على الأطفال المباشرين مهمة بسيطة إذا لم نتعامل مع واجهة وظيفية.  عند البحث عن تطبيقات واجهة <code>Foo</code> ، نحتاج إلى العثور على جميع الفئات التي <code>implements Foo</code> والواجهات التي <code>extends Foo</code> ، بالإضافة إلى فصول مجهولة <code>new Foo(...) {...}</code> .  للقيام بذلك ، يكفي إنشاء شجرة بناء جملة لكل ملف مشروع مسبقًا ، والعثور على الإنشاءات المقابلة ، وإضافتها إلى فهرس. <a name="habracut"></a>  ومع ذلك ، هناك تعقيد هنا: قد تبحث عن واجهة <code>com.example.goodcompany.Foo</code> ، بينما يتم استخدام <code>org.example.evilcompany.Foo</code> فعليًا.  هل يمكننا وضع الاسم الكامل للواجهة الأصل في الفهرس مقدمًا؟  يمكن أن يكون خادعا.  على سبيل المثال ، قد يبدو الملف الذي تستخدم فيه الواجهة كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  من خلال النظر إلى الملف وحده ، من المستحيل معرفة ما هو اسم <code>Foo</code> المؤهل بالكامل الفعلي.  سيتعين علينا النظر في محتوى العديد من الحزم.  ويمكن تعريف كل حزمة في عدة أماكن في المشروع (على سبيل المثال ، في العديد من ملفات JAR).  إذا قمنا بإجراء تحليل مناسب للرمز عند تحليل هذا الملف ، فستستغرق عملية الفهرسة الكثير من الوقت.  لكن المشكلة الرئيسية هي أن الفهرس المبني على <code>MyFoo.java</code> سيعتمد على الملفات الأخرى أيضًا.  يمكننا نقل إعلان واجهة <code>Foo</code> ، على سبيل المثال ، من حزمة <code>org.example.foo</code> إلى حزمة <code>org.example.bar</code> ، دون تغيير أي شيء في ملف <code>MyFoo.java</code> ، ولكن سيتم تغيير اسم <code>Foo</code> المؤهل بالكامل. </p><br><p style=";text-align:right;direction:rtl">  في IntelliJ IDEA ، تعتمد الفهارس فقط على محتوى ملف واحد.  من ناحية ، هو مناسب للغاية: يصبح الفهرس المرتبط بملف معين غير صالح عند تغيير الملف.  من ناحية أخرى ، يفرض قيودًا كبيرة على ما يمكن وضعه في الفهرس.  على سبيل المثال ، لا يسمح بحفظ الأسماء المؤهلة بالكامل للفئات الرئيسية بشكل موثوق في الفهرس.  لكن بشكل عام ، هذا ليس بالأمر السيء.  عند طلب تسلسل هرمي للكتابة ، يمكننا العثور على كل ما يطابق طلبنا باسم قصير ، ثم تنفيذ دقة الرمز المناسبة لهذه الملفات وتحديد ما إذا كان هذا هو ما نبحث عنه.  في معظم الحالات ، لن يكون هناك الكثير من الرموز الزائدة ولن يستغرق التحقق وقتًا طويلاً. </p><br><p style=";text-align:right;direction:rtl"><img alt="التسلسل الهرمي للواجهة الوظيفية في IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  ومع ذلك ، تتغير الأمور عندما يكون الفصل الذي نبحث عن أطفاله هو واجهة وظيفية.  ثم ، بالإضافة إلى الفئات الفرعية الصريحة والمجهولة ، ستكون هناك تعبيرات lambda ومراجع الطريقة.  ماذا نضعه في الفهرس الآن ، وما الذي يجب تقييمه أثناء البحث؟ </p><br><p style=";text-align:right;direction:rtl">  لنفترض أن لدينا واجهة وظيفية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الكود يحتوي على تعبيرات لامدا مختلفة.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا يعني أنه يمكننا تصفية بسرعة lambdas التي تحتوي على عدد غير مناسب من المعلمات أو نوع الإرجاع غير مناسب بشكل واضح ، على سبيل المثال ، الفراغ بدلاً من عدم الفراغ.  عادة ما يكون من المستحيل تحديد نوع الإرجاع بدقة أكبر.  على سبيل المثال ، في <code>s -&gt; list.add(s)</code> سيتعين عليك حل <code>list</code> <code>add</code> ، وربما ، تشغيل إجراء منتظم لاستنتاج الكتابة.  يستغرق وقتًا ويعتمد على محتوى الملفات الأخرى. </p><br><p style=";text-align:right;direction:rtl">  نحن محظوظون إذا كانت الواجهة الوظيفية تأخذ خمس حجج.  ولكن إذا استغرق الأمر واحدًا فقط ، فسيحتفظ المرشح بعدد كبير من اللمبات غير الضرورية.  الأمر أسوأ عندما يتعلق الأمر بمراجع الأسلوب.  بالمناسبة ، لا يستطيع المرء معرفة ما إذا كان مرجع الطريقة مناسب أم لا. </p><br><p style=";text-align:right;direction:rtl">  للحصول على الأمور في نصابها الصحيح ، قد يكون من المفيد النظر إلى ما يحيط لامدا.  في بعض الأحيان ، كان يعمل.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  في جميع هذه الحالات ، يمكن تحديد الاسم المختصر للواجهة الوظيفية المقابلة من الملف الحالي ويمكن وضعه في الفهرس بجانب التعبير الوظيفي ، سواء كان لامدا أو مرجعًا للطريقة.  لسوء الحظ ، في هذه المشروعات الواقعية ، تغطي هذه الحالات نسبة مئوية صغيرة جدًا من جميع اللمبات.  في معظم الحالات ، يتم استخدام lambdas كوسائط طريقة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p style=";text-align:right;direction:rtl">  أي من لامدا الثلاثة يمكن أن تحتوي على <code>StringConsumer</code> ؟  من الواضح ، لا شيء.  هنا لدينا سلسلة Stream API التي تحتوي فقط على واجهات وظيفية من المكتبة القياسية ، ولا يمكن أن يكون لها النوع المخصص. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، يجب أن يكون IDE قادراً على رؤية الحيلة ومنحنا إجابة دقيقة.  ماذا لو كانت <code>list</code> ليست <code>java.util.List</code> بالضبط ، و <code>list.stream()</code> تُرجع شيئًا مختلفًا عن <code>java.util.stream.Stream</code> ؟  بعد ذلك ، سيتعين علينا حل <code>list</code> التي ، كما نعلم ، لا يمكن القيام بها بشكل موثوق استنادًا إلى محتوى الملف الحالي فقط.  وحتى لو فعلنا ذلك ، يجب ألا يعتمد البحث على تنفيذ المكتبة القياسية.  ماذا لو قمنا في هذا المشروع بالذات باستبدال <code>java.util.List</code> بفئة خاصة بنا؟  يجب أن يأخذ البحث هذا في الاعتبار.  وبطبيعة الحال ، يتم استخدام لامدا ليس فقط في التدفقات القياسية: هناك العديد من الطرق الأخرى التي يتم تمريرها. </p><br><p style=";text-align:right;direction:rtl">  نتيجة لذلك ، يمكننا الاستعلام عن الفهرس للحصول على قائمة بجميع ملفات Java التي تستخدم lambdas مع العدد المطلوب من المعلمات ونوع الإرجاع صالح (في الواقع ، نحن نبحث فقط عن أربعة خيارات: باطلة ، غير خالية ، منطقية ، و وجدت).  وماذا بعد؟  هل نحن بحاجة إلى إنشاء شجرة PSI كاملة (نوع من شجرة التحليل مع دقة الرمز ، والاستدلال على الكتابة ، والميزات الذكية الأخرى) لكل من هذه الملفات وتنفيذ استدلال مناسب للكتابة على lambdas؟  بالنسبة لمشروع كبير ، سيستغرق الأمر الأعمار للحصول على قائمة بجميع تطبيقات الواجهة ، حتى لو كان هناك اثنان منها فقط. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، نحن بحاجة إلى اتخاذ الخطوات التالية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  اسأل مؤشر (غير مكلف) </li><li style=";text-align:right;direction:rtl">  بناء PSI (مكلف) </li><li style=";text-align:right;direction:rtl">  استنتج نوع لامدا (مكلف للغاية) </li></ul><br><p style=";text-align:right;direction:rtl">  بالنسبة لنظام التشغيل Java 8 والإصدارات الأحدث ، تعد عملية الاستدلال عملية مكلفة للغاية.  في سلسلة نداء معقدة ، قد يكون هناك العديد من المعلمات العامة البديلة ، والتي يجب تحديد قيمها باستخدام إجراء الضرب الثابت الموصوف في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الفصل 18</a> من المواصفات.  بالنسبة للملف الحالي ، يمكن القيام بذلك في الخلفية ، ولكن معالجة الآلاف من الملفات غير المفتوحة بهذه الطريقة ستكون مهمة مكلفة. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، من الممكن هنا خفض الزوايا قليلاً: في معظم الحالات ، لا نحتاج إلى النوع الملموس.  ما لم تقبل الطريقة معلمة عامة حيث يتم تمرير lambda إليها ، يمكن تجنب خطوة استبدال المعلمة النهائية.  إذا استنتجنا نوع <code>java.util.function.Function&lt;T, R&gt;</code> lambda ، فلن يتعين علينا تقييم قيم المعلمات البديلة <code>T</code> و <code>R</code> : من الواضح بالفعل ما إذا كان يجب تضمين lambda في نتائج البحث أم لا. لا.  ومع ذلك ، لن تنجح هذه الطريقة مثل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن استدعاء هذه الطريقة باستخدام <code>doSmth(Runnable.class, () -&gt; {})</code> .  ثم سيتم الاستدلال على نوع lambda كـ <code>T</code> ، لا يزال الاستبدال مطلوبًا.  ومع ذلك ، هذه هي حالة نادرة.  يمكننا بالفعل توفير بعض الوقت لوحدة المعالجة المركزية هنا ، ولكن حوالي 10٪ فقط ، لذلك هذا لا يحل المشكلة في جوهرها. </p><br><p style=";text-align:right;direction:rtl">  بدلاً من ذلك ، عندما يكون الاستدلال النوعي الدقيق معقدًا للغاية ، فيمكن تقريبه.  على عكس المواصفات المقترحة ، دعها تعمل فقط على أنواع الفئات المحوّة ولا تخفض من مجموعة القيود ، لكن ببساطة اتبع سلسلة الاتصال.  طالما أن النوع الذي تم مسحه لا يتضمن معلمات عامة ، فكل شيء على ما يرام.  دعونا ننظر في الدفق من المثال أعلاه وتحديد ما إذا كان lambda الأخير ينفذ <code>StringConsumer</code> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>list</code> متغير -&gt; <code>java.util.List</code> نوع </li><li style=";text-align:right;direction:rtl">  <code>List.stream()</code> طريقة → <code>java.util.stream.Stream</code> النوع </li><li style=";text-align:right;direction:rtl">  <code>Stream.filter(...)</code> -&gt; <code>java.util.stream.Stream</code> type ، لسنا <code>Stream.filter(...)</code> للنظر في وسيطات <code>filter</code> </li><li style=";text-align:right;direction:rtl">  وبالمثل ، <code>Stream.map(...)</code> → نوع <code>java.util.stream.Stream</code> </li><li style=";text-align:right;direction:rtl">  <code>Stream.forEach(...)</code> طريقة → مثل هذه الطريقة موجودة ، المعلمة لديها نوع <code>Consumer</code> ، والذي من الواضح أنه ليس <code>StringConsumer</code> . </li></ul><br><p style=";text-align:right;direction:rtl">  وهذه هي الطريقة التي يمكننا القيام بها دون الاستدلال النوعي العادي.  مع هذا النهج البسيط ، مع ذلك ، من السهل الدخول في طرق مثقلة.  إذا لم نقم بإجراء الاستنتاج الصحيح للكتابة ، فلن نتمكن من اختيار الطريقة المثقلة بشكل صحيح.  في بعض الأحيان يكون ذلك ممكنًا: إذا كان للطرق عدد مختلف من المعلمات.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا يمكننا أن نرى ما يلي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  هناك طريقتان <code>CompletableFuture.supplyAsync</code> ؛  الأولى تأخذ حجة واحدة والثانية تأخذ اثنين ، لذلك نختار الثانية.  تقوم بإرجاع <code>CompletableFuture</code> . </li><li style=";text-align:right;direction:rtl">  هناك طريقتان <code>thenRunAsync</code> أيضًا ، ويمكننا بالمثل اختيار الطريقة التي تأخذ وسيطة واحدة.  المعلمة المقابلة لها نوع <code>Runnable</code> ، مما يعني أنها ليست <code>StringConsumer</code> . </li></ul><br><p style=";text-align:right;direction:rtl">  إذا كانت هناك عدة طرق تأخذ نفس عدد المعلمات أو تحتوي على عدد متغير من المعلمات ولكنها تبدو مناسبة ، فسوف يتعين علينا البحث في جميع الخيارات.  غالبًا ما لا يكون ذلك مخيفًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>new StringBuilder()</code> الواضح أن <code>new StringBuilder()</code> ينشئ <code>java.lang.StringBuilder</code> .  بالنسبة للمنشئين ، ما زلنا نحدد المرجع ، لكن الاستدلال النوعي المعقد غير مطلوب هنا.  حتى لو كان هناك <code>new Foo&lt;&gt;(x, y, z)</code> ، فلن نستنتج قيم معلمات الكتابة لأن <code>Foo</code> فقط هي التي تهمنا. </li><li style=";text-align:right;direction:rtl">  هناك الكثير من أساليب <code>StringBuilder.append</code> التي تأخذ وسيطة واحدة ، ولكنها جميعًا تُرجع نوع <code>java.lang.StringBuilder</code> ، لذلك نحن لا نهتم بأنواع <code>foo</code> و <code>bar</code> . </li><li style=";text-align:right;direction:rtl">  هناك طريقة <code>StringBuilder.chars</code> واحدة ، وتقوم بإرجاع <code>java.util.stream.IntStream</code> . </li><li style=";text-align:right;direction:rtl">  هناك طريقة واحدة <code>IntStream.forEach</code> ، ويستغرق نوع <code>IntConsumer</code> . </li></ul><br><p style=";text-align:right;direction:rtl">  حتى إذا بقيت عدة خيارات ، فلا يزال بإمكانك تتبعها جميعًا.  على سبيل المثال ، قد يكون نوع lambda الذي تم تمريره إلى <code>ForkJoinPool.getInstance().submit(...)</code> قد يكون <code>ForkJoinPool.getInstance().submit(...)</code> <code>Runnable</code> أو <code>Runnable</code> ، وإذا كنا نبحث عن خيار آخر ، فلا يزال بإمكاننا تجاهل هذا lambda. </p><br><p style=";text-align:right;direction:rtl">  الأمور تزداد سوءًا عندما تُرجع الطريقة معلمة عامة.  ثم يفشل الإجراء وعليك القيام باستنتاج الكتابة الصحيح.  ومع ذلك ، لقد دعمنا حالة واحدة.  يتم عرضها بشكل جيد في مكتبة StreamEx الخاصة بي ، والتي تحتوي على <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> فئة الملخص الذي يحتوي على أساليب مثل <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  عادةً ما يعمل الأشخاص باستخدام <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> ملموسة <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> فئة.  في هذه الحالة ، يمكنك استبدال معلمة الكتابة ومعرفة ذلك <code>S = StreamEx</code> . </p><br><p style=";text-align:right;direction:rtl">  هكذا تخلصنا من الاستدلال المكلف للكثير من الحالات.  لكننا لم نفعل أي شيء مع بناء PSI.  من المخيب للآمال أن يتم تحليل ملف يحتوي على 500 سطر من التعليمات البرمجية فقط لمعرفة أن lambda على السطر 480 لا يطابق استعلامنا.  دعنا نعود إلى ساحة مشاركاتنا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p style=";text-align:right;direction:rtl">  إذا كانت <code>list</code> عبارة عن متغير محلي ، أو معلمة أسلوب ، أو حقل في الفصل الحالي ، بالفعل في مرحلة الفهرسة ، يمكننا أن نجد إعلانها ونثبت أن اسم النوع المختصر هو <code>List</code> .  وفقًا لذلك ، يمكننا وضع المعلومات التالية في فهرس آخر لامدا: </p><br><blockquote style=";text-align:right;direction:rtl">  هذا النوع من lambda هو نوع معلمة من أساليب <code>forEach</code> يأخذ وسيطة واحدة ، تسمى نتيجة طريقة <code>map</code> تأخذ وسيطة واحدة ، تسمى نتيجة طريقة <code>filter</code> تأخذ وسيطة واحدة ، تسمى نتيجة طريقة <code>stream</code> الذي يأخذ وسيطات الصفر ، ودعا على كائن <code>List</code> . </blockquote><p style=";text-align:right;direction:rtl">  كل هذه المعلومات متاحة من الملف الحالي ، وبالتالي ، يمكن وضعها في الفهرس.  أثناء البحث ، نطلب مثل هذه المعلومات حول جميع lambdas من الفهرس ونحاول استعادة نوع lambda دون إنشاء PSI.  أولاً ، سيتعين علينا إجراء بحث عالمي للفصول الدراسية باستخدام اسم <code>List</code> القصيرة.  من الواضح ، لن نجد <code>java.util.List</code> فقط ولكن أيضًا <code>java.awt.List</code> أو شيء من رمز المشروع.  بعد ذلك ، ستخضع كل هذه الفئات لنفس الإجراء التقريبي لاستدلال النوع الذي استخدمناه من قبل.  غالبًا ما يتم تصفية الطبقات الزائدة بسرعة.  على سبيل المثال ، <code>java.awt.List</code> لا يحتوي على طريقة <code>stream</code> ، لذلك سيتم استبعادها.  ولكن حتى لو بقي شيء زائدًا ووجدنا العديد من المرشحين لنوع lambda ، فليس من المحتمل أن يطابق أي منهم استعلام البحث ، وسنستمر في تجنب بناء PSI كامل. </p><br><p style=";text-align:right;direction:rtl">  قد يكون البحث الشامل مكلفًا للغاية (عندما يحتوي المشروع على عدد كبير جدًا من فئات <code>List</code> ) ، أو لا يمكن حل بداية السلسلة في سياق ملف واحد (على سبيل المثال ، إنه حقل لفئة الأصل) ، أو سلسلة يمكن كسر كما إرجاع الأسلوب معلمة عامة.  لن نستسلم وسوف نحاول البدء من جديد بالبحث العالمي عن الطريقة التالية للسلسلة.  على سبيل المثال ، بالنسبة إلى <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> ، ينتقل التعليمة التالية إلى الفهرس: </p><br><blockquote style=";text-align:right;direction:rtl">  هذا النوع من lambda هو نوع المعلمة <code>updateAndGet</code> لطريقة <code>updateAndGet</code> ، والتي تسمى نتيجة لطريقة <code>get</code> مع معلمة واحدة ، تسمى على كائن <code>Map</code> . </blockquote><p style=";text-align:right;direction:rtl">  تخيل أننا محظوظون ، والمشروع به نوع <code>Map</code> واحد فقط - <code>java.util.Map</code> .  يحتوي على طريقة <code>get(Object)</code> ، لكن لسوء الحظ ، تقوم بإرجاع معلمة عامة <code>V</code>  بعد ذلك <code>updateAndGet</code> السلسلة ونبحث عن طريقة <code>updateAndGet</code> مع معلمة واحدة على مستوى العالم (باستخدام الفهرس ، بالطبع).  ويسعدنا أن نكتشف أن هناك ثلاث طرق فقط في المشروع: في <code>AtomicInteger</code> <code>AtomicLong</code> و <code>AtomicReference</code> و <code>AtomicReference</code> مع أنواع المعلمات <code>IntUnaryOperator</code> و <code>LongUnaryOperator</code> و <code>UnaryOperator</code> ، على التوالي.  إذا كنا نبحث عن أي نوع آخر ، فقد اكتشفنا بالفعل أن هذا لامدا لا يتطابق مع الطلب ، وليس لدينا لبناء PSI. </p><br><p style=";text-align:right;direction:rtl">  والمثير للدهشة ، هذا مثال جيد على ميزة تعمل بشكل أبطأ مع مرور الوقت.  على سبيل المثال ، عندما تبحث عن تطبيقات للواجهة الوظيفية ولديك ثلاثة منها فقط في مشروعك ، يستغرق IntelliJ IDEA عشر ثوانٍ للعثور عليها.  تتذكر أنه منذ ثلاث سنوات كان عددهم هو نفسه ، لكن IDE زودك بنتائج البحث في ثانيتين فقط على نفس الجهاز.  وعلى الرغم من أن مشروعك ضخم ، إلا أنه نما بنسبة خمسة بالمائة فقط خلال هذه السنوات.  من المعقول أن نبدأ في التذمر بشأن ما فعله مطورو IDE بشكل خاطئ لجعله بطيئًا بشكل رهيب. </p><br><p style=";text-align:right;direction:rtl">  في حين أننا ربما لم نغير شيئًا على الإطلاق.  البحث يعمل تماما كما كان قبل ثلاث سنوات.  الشيء هو أنه قبل ثلاث سنوات ، قمت فقط بالتبديل إلى Java 8 ولم يكن لديك سوى مائة lambdas في مشروعك.  الآن ، قام زملاؤك بتحويل فصول مجهولة إلى lambdas ، وبدأوا في استخدام التدفقات أو بعض المكتبات التفاعلية.  نتيجة لذلك ، بدلاً من مائة lambdas ، هناك عشرة آلاف.  والآن ، للعثور على الخيارات الثلاثة الضرورية ، يتعين على IDE البحث في خيارات أكثر من مائة مرة. </p><br><p style=";text-align:right;direction:rtl">  قلت "ربما" لأننا ، بطبيعة الحال ، نعود إلى هذا البحث من وقت لآخر ونحاول تسريعه.  لكن الأمر أشبه بالتجديف في مجرى النهر ، أو بالأحرى إلى أعلى الشلال.  نحن نحاول جاهدين ، ولكن عدد lambdas في المشاريع يستمر في النمو بسرعة كبيرة. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar451754/">https://habr.com/ru/post/ar451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar451742/index.html">قبل يوم واحد من DotNext 2019 Piter. إعلان البث المجاني</a></li>
<li><a href="../ar451746/index.html">MegaSlerm للمهندسين والمهندسين المعماريين Kubernetes</a></li>
<li><a href="../ar451748/index.html">مراقبة حالة SSD في مصفوفات Qsan</a></li>
<li><a href="../ar451750/index.html">كتاب "Elasticsearch ، Kibana ، Logstash ومحركات البحث من الجيل التالي"</a></li>
<li><a href="../ar451752/index.html">الذكرى الثلاثين لانعدام الأمن المتفشي</a></li>
<li><a href="../ar451758/index.html">روابط إضافية في بنية نظام المنطق Intel C620</a></li>
<li><a href="../ar451760/index.html">استخدام Golang لإنشاء خدمات Microservices في The Economist: A بأثر رجعي</a></li>
<li><a href="../ar451766/index.html">Heisenbug 2019 Piter: ماذا سيحدث في البث المجاني ، وماذا سيحدث فقط في الحدث</a></li>
<li><a href="../ar451768/index.html">تحسين عمل Wi-Fi. المبادئ العامة والأشياء المفيدة</a></li>
<li><a href="../ar451770/index.html">Veeam النسخ الاحتياطي والنسخ المتماثل: نصائح مفيدة لجعل النسخ الاحتياطية والنسخ المتماثلة قابلة للحياة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>