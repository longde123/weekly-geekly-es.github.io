<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏼 👍🏼 🤱🏻 Indeks dalam PostgreSQL - 8 (RUM) 👨🏽‍💻 💇🏽 🏅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah membahas mesin pengindeksan PostgreSQL, antarmuka metode akses, dan metode akses utama, seperti: indeks hash , B-tree , GiST , SP-GiST , da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 8 (RUM)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452116/">  Kami telah membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL, antarmuka metode akses, dan metode akses utama, seperti: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP-GiST</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIN</a> .  Pada artikel ini, kita akan melihat bagaimana gin berubah menjadi rum. <br><br><h1>  RUM </h1><br>  Meskipun penulis mengklaim bahwa gin adalah jin yang kuat, tema minuman akhirnya menang: GIN generasi berikutnya telah disebut RUM. <br><br>  Metode akses ini memperluas konsep yang mendasari GIN dan memungkinkan kami untuk melakukan pencarian teks lengkap lebih cepat.  Dalam seri artikel ini, ini adalah satu-satunya metode yang tidak termasuk dalam pengiriman PostgreSQL standar dan merupakan ekstensi eksternal.  Beberapa opsi instalasi tersedia untuknya: <br><br><ul><li>  Ambil paket "yum" atau "apt" dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori PGDG</a> .  Sebagai contoh, jika Anda menginstal PostgreSQL dari paket "postgresql-10", instal juga "postgresql-10-rum". </li><li>  Bangun dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber di github</a> dan instal sendiri (instruksi juga ada di sana). </li><li>  Gunakan sebagai bagian dari Postgres Pro Enterprise (atau setidaknya baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dari sana). </li></ul><br><h2>  Keterbatasan gin </h2><br>  Keterbatasan GIN apa yang memungkinkan RUM untuk melampaui kita? <br><br>  Pertama, tipe data "tsvector" tidak hanya berisi leksem, tetapi juga informasi tentang posisi mereka di dalam dokumen.  Seperti yang kami amati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> , indeks GIN tidak menyimpan informasi ini.  Karena alasan ini, operasi untuk mencari frasa, yang muncul dalam versi 9.6, didukung oleh indeks GIN secara tidak efisien dan harus mengakses data asli untuk diperiksa ulang. <br><br>  Kedua, sistem pencarian biasanya mengembalikan hasil yang diurutkan berdasarkan relevansi (apa pun artinya).  Kita dapat menggunakan fungsi peringkat "ts_rank" dan "ts_rank_cd" untuk tujuan ini, tetapi mereka harus dihitung untuk setiap baris hasil, yang tentu saja lambat. <br><br>  Untuk perkiraan pertama, metode akses RUM dapat dianggap sebagai GIN yang juga menyimpan informasi posisi dan dapat mengembalikan hasil dalam urutan yang diperlukan (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> dapat mengembalikan tetangga terdekat).  Mari kita bergerak selangkah demi selangkah. <br><a name="habracut"></a><br><h2>  Mencari frasa </h2><br>  Permintaan pencarian teks lengkap dapat berisi operator khusus yang memperhitungkan jarak antar leksem.  Misalnya, kita dapat menemukan dokumen di mana "tangan" dipisahkan dari "paha" dengan dua kata lagi: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;3&gt; thigh'</span></span>);</code> </pre> <pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Atau kita dapat menunjukkan bahwa kata-kata harus ditempatkan satu demi satu: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;-&gt; slap'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Indeks GIN biasa dapat mengembalikan dokumen yang berisi kedua leksem tersebut, tetapi kami dapat memeriksa jarak di antara keduanya hanya dengan melihat ke dalam tsvector: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector -------------------------------------- 'clap':1 'hand':3 'slap':4 'thigh':6 (1 row)</code> </pre><br>  Dalam indeks RUM, setiap leksem tidak hanya mereferensikan baris tabel: setiap TID disediakan dengan daftar posisi di mana leksem terjadi dalam dokumen.  Ini adalah bagaimana kita dapat membayangkan indeks yang dibuat pada tabel "slit-sheet", yang sudah cukup akrab bagi kita ("rum_tsvector_ops" kelas operator digunakan untuk tsvector secara default): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> rum; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(doc_tsv);</code> </pre><br><br><img src="https://habrastorage.org/webt/k0/up/gn/k0upgnbhka1wfwq6oozy9qo24ka.png"><br><br>  Kotak abu-abu pada gambar berisi informasi posisi yang ditambahkan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  GIN juga menyediakan penyisipan yang ditunda ketika parameter "pembaruan cepat" ditentukan;  fungsi ini dihapus dari RUM. <br><br>  Untuk melihat bagaimana indeks bekerja pada data langsung, mari kita gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsip</a> dari mailing list pgsql-hacker. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> default_text_search_config = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">... UPDATE 356125</code> </pre><br>  Ini adalah bagaimana kueri yang menggunakan pencarian frasa dilakukan dengan indeks GIN: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv); fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Rows Removed by Index Recheck: 1517 Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual time=2.204..2.204 rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.266 ms Execution time: 18.151 ms (8 rows)</code> </pre><br>  Seperti yang dapat kita lihat dari rencana, indeks GIN digunakan, tetapi mengembalikan 1776 pertandingan potensial, yang tersisa 259 dan 1517 dijatuhkan pada tahap periksa ulang. <br><br>  Mari kita hapus indeks GIN dan bangun RUM. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin; fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_rum <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv);</code> </pre><br>  Indeks sekarang berisi semua informasi yang diperlukan, dan pencarian dilakukan dengan akurat: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Heap Blocks: exact=250 -&gt; Bitmap Index Scan on tsv_rum (actual time=2.768..2.768 rows=259 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.245 ms Execution time: 3.053 ms (7 rows)</code> </pre><br><h2>  Menyortir berdasarkan relevansi </h2><br>  Untuk mengembalikan dokumen dengan mudah dalam urutan yang diperlukan, indeks RUM mendukung operator pemesanan, yang kami bahas dalam artikel terkait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> .  Ekstensi RUM mendefinisikan operator seperti itu, <code>&lt;=&gt;</code> , yang mengembalikan jarak antara dokumen ("tsvector") dan permintaan ("tsquery").  Sebagai contoh: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&amp;gtl to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 16.4493 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'sheet'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 13.1595 (1 row)</code> </pre><br>  Dokumen itu tampaknya lebih relevan dengan permintaan pertama daripada yang kedua: semakin sering kata itu muncul, semakin sedikit "berharganya" itu. <br><br>  Mari kita coba lagi membandingkan GIN dan RUM pada ukuran data yang relatif besar: kita akan memilih sepuluh dokumen paling relevan yang berisi "halo" dan "peretas". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ts_rank(tsv,to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------- Limit (actual time=27.076..27.078 rows=10 loops=1) -&gt; Sort (actual time=27.075..27.076 rows=10 loops=1) Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) Sort Method: top-N heapsort Memory: 29kB -&gt; Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual ... rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Planning time: 0.276 ms Execution time: 27.121 ms (11 rows)</code> </pre><br>  Indeks GIN menghasilkan 1776 pertandingan, yang kemudian diurutkan sebagai langkah terpisah untuk memilih sepuluh klik terbaik. <br><br>  Dengan indeks RUM, kueri dilakukan menggunakan pemindaian indeks sederhana: tidak ada dokumen tambahan yang dilihat, dan tidak diperlukan penyortiran terpisah: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> tsv &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------- Limit (actual time=5.083..5.171 rows=10 loops=1) -&gt; Index Scan using tsv_rum on mail_messages (actual ... rows=10 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) Planning time: 0.244 ms Execution time: 5.207 ms (6 rows)</code> </pre><br><h2>  Informasi tambahan </h2><br>  Indeks RUM, serta GIN, dapat dibangun di beberapa bidang.  Tetapi sementara GIN menyimpan leksem dari setiap kolom secara terpisah dari yang dari kolom lain, RUM memungkinkan kita untuk "mengasosiasikan" bidang utama ("tsvector" dalam kasus ini) dengan yang tambahan.  Untuk melakukan ini, kita perlu menggunakan kelas operator khusus "rum_tsvector_addon_ops": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv RUM_TSVECTOR_ADDON_OPS, sent) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (ATTACH=<span class="hljs-string"><span class="hljs-string">'sent'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span>=<span class="hljs-string"><span class="hljs-string">'tsv'</span></span>);</code> </pre><br>  Kami dapat menggunakan indeks ini untuk mengembalikan hasil yang diurutkan pada bidang tambahan: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | sent | ?column? ---------+---------------------+---------- 2298548 | 2017-01-01 15:03:22 | 202 2298547 | 2017-01-01 14:53:13 | 407 2298545 | 2017-01-01 13:28:12 | 5508 2298554 | 2017-01-01 18:30:45 | 12645 2298530 | 2016-12-31 20:28:48 | 66672 2298587 | 2017-01-02 12:39:26 | 77966 2298588 | 2017-01-02 12:43:22 | 78202 2298597 | 2017-01-02 13:48:02 | 82082 2298606 | 2017-01-02 15:50:50 | 89450 2298628 | 2017-01-02 18:55:49 | 100549 (10 rows)</code> </pre><br>  Di sini kami mencari baris yang cocok sedekat mungkin dengan tanggal yang ditentukan, tidak peduli sebelumnya atau nanti.  Untuk mendapatkan hasil yang secara ketat mendahului (atau mengikuti) tanggal yang ditentukan, kita perlu menggunakan <code>&lt;=|</code>  (atau <code>|=&gt;</code> ) operator. <br><br>  Seperti yang kami harapkan, kueri dilakukan hanya dengan pemindaian indeks sederhana: <br><br><pre> <code class="pgsql hljs">ts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Limit -&gt; Index Scan using mail_messages_tsv_sent_idx on mail_messages Index Cond: (tsv @@ to_tsquery('hello'::text)) Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) (4 rows)</code> </pre><br>  Jika kami membuat indeks tanpa informasi tambahan tentang asosiasi lapangan, untuk permintaan yang sama, kami harus mengurutkan semua hasil pemindaian indeks. <br><br>  Selain tanggal, kami tentu saja dapat menambahkan bidang tipe data lain ke indeks RUM.  Hampir semua tipe dasar didukung.  Misalnya, toko online dapat dengan cepat menampilkan barang berdasarkan kebaruan (tanggal), harga (numerik), dan nilai popularitas atau diskon (integer atau floating-point). <br><br><h2>  Kelas operator lainnya </h2><br>  Untuk melengkapi gambar, kita harus menyebutkan kelas operator lain yang tersedia. <br><br>  Mari kita mulai dengan <strong>"rum_tsvector_hash_ops"</strong> dan <strong>"rum_tsvector_hash_addon_ops"</strong> .  Mereka mirip dengan yang sudah dibahas "rum_tsvector_ops" dan "rum_tsvector_addon_ops", tetapi indeks menyimpan kode hash dari lexeme daripada lexeme itu sendiri.  Ini dapat mengurangi ukuran indeks, tetapi tentu saja, pencarian menjadi kurang akurat dan memerlukan pengecekan ulang.  Selain itu, indeks tidak lagi mendukung pencarian kecocokan parsial. <br><br>  Sangat menarik untuk melihat kelas operator <strong>"rum_tsquery_ops"</strong> .  Ini memungkinkan kami untuk memecahkan masalah "terbalik": temukan pertanyaan yang cocok dengan dokumen.  Mengapa ini diperlukan?  Misalnya, untuk berlangganan pengguna ke barang baru sesuai dengan filternya atau untuk secara otomatis mengkategorikan dokumen baru.  Lihatlah contoh sederhana ini: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> categories(query <span class="hljs-type"><span class="hljs-type">tsquery</span></span>, category <span class="hljs-type"><span class="hljs-type">text</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (to_tsquery(<span class="hljs-string"><span class="hljs-string">'vacuum | autovacuum | freeze'</span></span>), <span class="hljs-string"><span class="hljs-string">'vacuum'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'xmin | xmax | snapshot | isolation'</span></span>), <span class="hljs-string"><span class="hljs-string">'mvcc'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'wal | (write &amp; ahead &amp; log) | durability'</span></span>), <span class="hljs-string"><span class="hljs-string">'wal'</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(query); fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> array_agg(category) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector( <span class="hljs-string"><span class="hljs-string">'Hello hackers, the attached patch greatly improves performance of tuple freezing and also reduces size of generated write-ahead logs.'</span></span> ) @@ query;</code> </pre><pre> <code class="plaintext hljs"> array_agg -------------- {vacuum,wal} (1 row)</code> </pre><br>  Kelas operator yang tersisa <strong>"rum_anyarray_ops"</strong> dan <strong>"rum_anyarray_addon_ops"</strong> dirancang untuk memanipulasi array daripada "tsvector".  Ini sudah dibahas untuk GIN <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> dan tidak perlu diulang. <br><br><h2>  Ukuran indeks dan log write-ahead (WAL) </h2><br>  Jelas bahwa karena RUM menyimpan lebih banyak informasi daripada GIN, RUM harus berukuran lebih besar.  Kami membandingkan ukuran indeks yang berbeda terakhir kali;  mari tambahkan RUM ke tabel ini: <br><br><pre> <code class="plaintext hljs"> rum | gin | gist | btree --------+--------+--------+-------- 457 MB | 179 MB | 125 MB | 546 MB</code> </pre><br>  Seperti yang dapat kita lihat, ukurannya tumbuh cukup signifikan, yang merupakan biaya pencarian cepat. <br><br>  Perlu memperhatikan satu hal lagi yang tidak jelas: RUM adalah ekstensi, yaitu, dapat diinstal tanpa modifikasi pada inti sistem.  Ini diaktifkan di versi 9.6 berkat tambalan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Korotkov</a> .  Salah satu masalah yang harus dipecahkan untuk tujuan ini adalah pembuatan catatan log.  Teknik untuk pencatatan operasi harus benar-benar andal, oleh karena itu, ekstensi tidak dapat dibiarkan masuk ke dapur ini.  Alih-alih mengizinkan ekstensi untuk membuat jenis catatan log sendiri, berikut ini ada di tempat: kode ekstensi mengomunikasikan niatnya untuk memodifikasi halaman, membuat perubahan apa pun padanya, dan memberi sinyal penyelesaian, dan itu adalah inti sistem, yang membandingkan versi lama dan baru dari halaman dan menghasilkan catatan log yang disatukan diperlukan. <br><br>  Algoritma pembuatan log saat ini membandingkan halaman byte demi byte, mendeteksi fragmen yang diperbarui, dan mencatat masing-masing fragmen ini, beserta offsetnya dari mulai halaman.  Ini berfungsi dengan baik ketika memperbarui hanya beberapa byte atau seluruh halaman.  Tetapi jika kita menambahkan fragmen di dalam halaman, memindahkan sisa konten ke bawah (atau sebaliknya, menghapus fragmen, memindahkan konten ke atas), secara signifikan lebih banyak byte akan berubah daripada yang sebenarnya ditambahkan atau dihapus. <br><br>  Karena hal ini, indeks RUM yang diubah secara intensif dapat menghasilkan catatan log dengan ukuran yang jauh lebih besar daripada GIN (yang, karena bukan merupakan ekstensi, tetapi bagian dari inti, mengelola log itu sendiri).  Tingkat efek menjengkelkan ini sangat tergantung pada beban kerja yang sebenarnya, tetapi untuk mendapatkan wawasan tentang masalah ini, mari kita coba untuk menghapus dan menambahkan sejumlah baris beberapa kali, menghubungkan operasi-operasi ini dengan "vakum".  Kita dapat mengevaluasi ukuran catatan log sebagai berikut: di awal dan di akhir, ingat posisi dalam log menggunakan fungsi "pg_current_wal_location" ("pg_current_xlog_location" dalam versi lebih awal dari sepuluh) dan kemudian lihat perbedaannya. <br><br>  Tetapi tentu saja, kita harus mempertimbangkan banyak aspek di sini.  Kami perlu memastikan bahwa hanya satu pengguna yang bekerja dengan sistem (jika tidak, catatan "ekstra" akan diperhitungkan).  Bahkan jika ini masalahnya, kami memperhitungkan tidak hanya RUM, tetapi juga pembaruan tabel itu sendiri dan indeks yang mendukung kunci utama.  Nilai parameter konfigurasi juga memengaruhi ukuran (level log "replika", tanpa kompresi, digunakan di sini).  Tapi mari kita coba. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> start_lsn \gset</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3576</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3590</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3605</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">98</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3637</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3625</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">97</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3668</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> end_lsn \gset fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(:<span class="hljs-string"><span class="hljs-string">'end_lsn'</span></span>::pg_lsn - :<span class="hljs-string"><span class="hljs-string">'start_lsn'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 3114 MB (1 row)</code> </pre><br>  Jadi, kami mendapatkan sekitar 3 GB.  Tetapi jika kami mengulangi percobaan yang sama dengan indeks GIN, ini hanya akan menghasilkan sekitar 700 MB. <br><br>  Oleh karena itu, diinginkan untuk memiliki algoritma yang berbeda, yang akan menemukan jumlah minimal operasi insert dan delete yang dapat mengubah satu keadaan halaman menjadi yang lain.  Utilitas "Diff" bekerja dengan cara yang sama.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oleg Ivanov</a> telah menerapkan algoritma semacam itu, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalannya</a> sedang dibahas.  Dalam contoh di atas, tambalan ini memungkinkan kita untuk mengurangi ukuran catatan log sebanyak 1,5 kali, menjadi 1900 MB, dengan biaya perlambatan kecil. <br><br><blockquote>  Sayangnya, tambalan macet dan tidak ada aktivitas di sekitarnya. <br></blockquote><br><h2>  Properti </h2><br>  Seperti biasa, mari kita lihat properti dari metode akses RUM, memperhatikan perbedaan dari GIN (pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah disediakan</a> ). <br><br>  Berikut ini adalah properti dari metode akses: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- rum | can_order | f rum | can_unique | f rum | can_multi_col | t rum | can_exclude | t -- f for gin</code> </pre><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t -- f for gin bitmap_scan | t backward_scan | f</code> </pre><br>  Perhatikan bahwa, tidak seperti GIN, RUM mendukung pemindaian indeks - jika tidak, RUM tidak akan mungkin mengembalikan jumlah hasil yang diinginkan secara tepat dalam kueri dengan klausa "batas".  Tidak perlu untuk counterpart dari parameter "gin_fuzzy_search_limit" sesuai.  Dan sebagai konsekuensinya, indeks dapat digunakan untuk mendukung batasan pengecualian. <br><br>  Berikut ini adalah properti lapisan-kolom: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | t -- f for gin returnable | f search_array | f search_nulls | f</code> </pre><br>  Perbedaannya di sini adalah bahwa RUM mendukung operator pemesanan.  Namun, ini benar bukan untuk semua kelas operator: misalnya, ini salah untuk "tsquery_ops". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452116/">https://habr.com/ru/post/id452116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452106/index.html">Kami mengundang pembicara ke pertemuan DIY musim panas pada 16 Juni 2019</a></li>
<li><a href="../id452108/index.html">Docker: saran tidak berbahaya</a></li>
<li><a href="../id452110/index.html">Mengotomatiskan penggantian disk dengan Ansible</a></li>
<li><a href="../id452112/index.html">CRM ++</a></li>
<li><a href="../id452114/index.html">HolyJS 2019: Pembekalan dari SEMrush (Bagian 1)</a></li>
<li><a href="../id452118/index.html">Ilmuwan memecahkan kode naskah misterius Voynich</a></li>
<li><a href="../id452122/index.html">"Pil dari iblis" bergerak</a></li>
<li><a href="../id452124/index.html">“Kita perlu lapar akan pengetahuan dan prestasi” - bagaimana rasanya menjadi penguji di Alfa-Bank</a></li>
<li><a href="../id452128/index.html">Kesalahpahaman populer tentang resistensi radiasi dari sirkuit mikro</a></li>
<li><a href="../id452130/index.html">Bulan menyusut, menyebabkan gempa bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>