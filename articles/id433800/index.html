<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš±ï¸ ğŸ‘©ğŸ¾â€âš–ï¸ ğŸ‘©â€âš–ï¸ Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi interupsi pada printer 3D ğŸ—¿ ğŸ‘¨ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ˜›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam komentar pada terjemahan dokumentasi hak milik pada UDB, dengan tepat dicatat bahwa fakta kering tidak berkontribusi pada pemahaman materi. Tapi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi interupsi pada printer 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433800/"><img src="https://habrastorage.org/webt/8h/et/xb/8hetxbp_jjuad07ws86ov24ch-c.jpeg"><br><br>  Dalam komentar pada terjemahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi hak milik pada UDB,</a> dengan tepat dicatat bahwa fakta kering tidak berkontribusi pada pemahaman materi.  Tapi dokumen itu justru mengandung fakta kering.  Untuk melemahkannya dengan latihan, mari kita berhenti sejenak dari penerjemahan.  Mari kita putar blok ini di tangan kita dan lihat apa dan bagaimana itu dapat dicapai dalam praktek. <br><a name="habracut"></a><br><h2>  Pengantar panjang </h2><br>  Artikel ini adalah bagian kedua dari trilogi yang dikandung.  Bagian pertama terletak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (kontrol LED RGB melalui unit mikrokontroler Cypress UDB PSoC). <br><br>  Selain pengontrol PSBC UDB Cypress, di mana antarmuka tertentu diimplementasikan pada mereka, akan menarik untuk memeriksa bagaimana blok ini dapat membuat hidup lebih mudah bagi programmer dengan menurunkan prosesor pusat dari tugas-tugas intensif sumber daya tertentu.  Tetapi untuk memperjelas apa yang akan saya lakukan, saya harus menulis kata pengantar yang luas. <br><br>  Pada musim gugur 2015, saya membeli printer 3D MZ3D yang baru, dan pada musim semi 2016 saya bosan dengan bagaimana motor loncatannya berderak.  Masa-masa itu liar, kami bertahan sebaik mungkin, jadi satu-satunya solusi adalah beralih dari microstep 1/16 ke 1/32.  Korespondensi dengan pabrik menunjukkan bahwa ini tidak mungkin di Arduino.  Ternyata, ada pembatasan dalam "firmware" tahun-tahun itu, dengan frekuensi langkah lebih tinggi dari 10 KHz, bukan langkah virtual yang diambil, tetapi dua langkah virtual, jika tidak sistem tidak punya cukup waktu untuk memproses semua "langkah" interupsi.  Hanya ada satu jalan keluar - untuk menyeret semuanya ke platform ARM.  Itu adalah drag and drop, bukan unduhan, karena tidak ada solusi ARM yang siap pakai saat itu.  Dalam beberapa minggu saya mentransfer semua ini ke STM32F4, suara mesin menjadi lebih menyenangkan, masalah terselesaikan. <br><br>  Kemudian pengembangan OS dimulai di perusahaan kami, dan pada pertemuan itu saya harus membuktikan untuk waktu yang lama bahwa pendekatan khas untuk memproses interupsi tidak selalu dapat diterima dalam hal kecepatan, menarik hanya untuk kasus yang khas, tetapi sangat rakus.  Diskusi tentang hal ini diterbitkan dalam artikel saya tentang interupsi di OS di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (Tinjauan satu RTOS Rusia, bagian 8. Bekerja dengan interupsi).  Secara umum, masalah telah ada di kepala saya untuk waktu yang lama: gangguan tambahan yang sering melayani satu subsistem memperlambat segalanya.  Penyempurnaan sederhana dari prosesor sentral, tentu saja, menghilangkan masalah, tetapi tidak membawa Kepuasan Moral Dalam bahwa semuanya dilakukan dengan benar. <br><br>  Secara berkala, saya kembali ke pertanyaan ini dalam pengertian teoretis semata.  Misalnya, suatu hari pikiran itu merayap ke kepala saya bahwa alih-alih menggunakan pengontrol yang mahal, Anda dapat mengambil tiga STM32F103C8T6, di mana papan tempat memotong roti yang sudah jadi harganya 110 rubel, dengan memperhitungkan pengiriman akun, dan chip itu sendiri bahkan lebih murah.  Di salah satunya hanya mengeluarkan fungsi kontrol mesin.  Biarkan dia menghabiskan semua daya komputasi untuk fungsi ini.  Beberapa yang lain (bahkan mungkin satu) menyelesaikan tugas-tugas lain (memproses perintah, bekerja dengan PWM, mempertahankan suhu, dll.) Dalam lingkungan yang tenang.  Solusi ini juga memiliki sisi besar plus - jumlah pin untuk beberapa pengontrol cukup besar.  Pada satu STM32, saya harus membuat solitaire untuk waktu yang lama, untuk leg yang mana.  Meskipun kaki-kaki pengatur waktu dan kaki-kaki ADC dari ARM ditetapkan lebih fleksibel daripada pengontrol lama (satu output dari unit perangkat keras dapat menuju ke salah satu dari beberapa kaki fisik), tetapi ketika melipat solitaire yang sangat, Anda memahami bahwa fleksibilitas mungkin tidak cukup.  Jika ada banyak pengontrol, maka pilihan meningkat.  Pada motor yang melayani stepper motor, secara umum, kami hanya menetapkan semua kaki sebagai output digital.  Yang lain juga punya tempat untuk berbalik. <br><br>  Satu masalah dengan pendekatan ini adalah bagaimana cara menyinkronkan pengontrol ini?  Secara teori, MAX Max RTOS berisi semua yang Anda butuhkan.  Pawang perintah menghasilkan daftar tugas untuk memindahkan kepala.  Secara berkala, ia memodifikasi mereka (dengan mengkoordinasikan akselerasi dengan tugas yang baru tiba).  Jadi memori untuk pembentuk dan pemain harus dibagikan.  RTOS MAX berisi fungsionalitas untuk mengatur memori bersama tersebut.  Saya jelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (Tinjauan satu RTOS Rusia, bagian 7. Cara bertukar data antar tugas).  Namun dalam praktiknya, satu nuansa merusak segalanya: servis motor stepper adalah jenis tugas yang sangat menentukan waktu.  Penundaan sedikit pun, dan kami mendapatkan aliran plastik untuk printer 3D, untuk mesin CNC lainnya - baik, misalnya, ulir yang salah.  Komunikasi apa pun melalui antarmuka serial bukan yang tercepat.  Plus - waktu untuk arbitrasi dan kebutuhan resmi lainnya.  Dan ternyata semua keuntungan dari penghapusan fungsionalitas dari prosesor utama menjadi overhead.  Tentu saja, saya mengambil keuntungan dari posisi resmi saya: saya pergi dan membahas masalah ini dengan para pengembang subsistem ini.  Sayang  Mereka mengatakan bahwa ada sinkronisasi tanpa banyak overhead di OS, tetapi untuk peralatan yang mendukung bus yang sesuai.  Sekarang, jika saya mengambil arsitektur TigerShark sebagai dasar, OS akan mengatur segalanya untuk saya tanpa overhead.  Hanya pengontrol yang dibuat menurut arsitektur ini yang beberapa kali lebih mahal daripada seluruh printer 3D yang ingin saya masukkan ke dalamnya.  Secara umum, sekali lagi tidak dapat diterima. <br><br>  Kami mendekati akhir dari pengantar yang berlarut-larut.  Seseorang akan mengatakan bahwa karena alasan tertentu aku masih mencari pangeran di atas kuda putih.  Anda dapat mengambil dan melakukan semuanya tanpa OS, dan di sini saya sedang mempertimbangkan segala macam pilihan ... Anda bisa, tetapi Anda bisa, tetapi ketika masalah praktis "Bosan mendengarkan tabrakan printer" muncul, itu cepat diperbaiki.  Itu saja.  Dia tidak ada lagi.  Selain itu, sejak itu ada driver motor stepper baru yang umumnya menyelesaikan masalah itu dengan cara yang sama sekali berbeda (mereka mendapatkan microstep 1/16, dan membagikan 1/256).  Dan dalam pengantar ini, saya menjelaskan dengan tepat bahwa "Tidak ada solusi yang bagus untuk masalah seringnya gangguan."  Keputusan jelek telah lama dibuat.  Saya tidak ingin membuang waktu memeriksa keputusan buruk lainnya.  Mereka hanya menggulir di kepalaku. <br><br>  Tetapi ketika saya berurusan dengan blok UDB, saya merasa bahwa masalahnya dapat diselesaikan dengan indah dan dramatis.  Anda cukup membawa pemrosesan gangguan dari perangkat lunak ke tingkat firmware, meninggalkan bagian komputasi pada hati nurani prosesor utama.  Tidak diperlukan pengontrol tambahan!  Semuanya ditempatkan pada chip yang sama!  Jadi, mari kita mulai. <br><br><h2>  Kuda bulat dalam ruang hampa </h2><br>  Dalam artikel ini, bekerja dengan UDB sendiri akan berada di garis depan.  Jika saya berbicara tentang terikat pada "firmware" tertentu, mereka dapat dengan tepat menunjukkan kepada saya bahwa saya salah dengan hub.  Apa itu untuk GeekTimes.  Oleh karena itu, UDB adalah yang utama, dan motor stepper adalah hal yang indah untuk digambarkan.  Pada bagian ini saya umumnya akan membuat kuda bulat dalam ruang hampa.  Dia akan memiliki kekurangan praktis, yang akan saya hilangkan di bagian kedua.  Tetapi mengulangi tindakan saya, pembaca akan dapat menguasai metodologi pengembangan firmware untuk UDB. <br><br>  Jadi  Bagaimana cara kerja mekanisme kontrol motor stepper?  Ada tugas yang mengatur segmen yang harus dilewati kepala dengan kecepatan linier.  Sejauh ini, saya akan berpura-pura tidak ingat tentang akselerasi di awal dan akhir segmen.  Hanya kepala yang harus dilaluinya.  Segmen baru diletakkan di ujung antrian.  Berdasarkan rekaman dari kepala, tugas terpisah mengirimkan sinyal <b>LANGKAH</b> ke semua mesin aktif. <br><br>  Biarkan printer memiliki kecepatan head maksimum 200 mm / s.  Biarkan 200 langkah diperlukan per 1 milimeter gerakan (angka ini sesuai dengan printer nyata MZ3D-256C dengan microstep 1/32).  Maka pulsa harus dilengkapi dengan frekuensi hingga 200 * 200 = 40.000 Hz = 40 KHz.  Ini dengan frekuensi sedemikian rupa sehingga tugas pulsa langkah pengiriman mungkin dipanggil.  Ini harus secara terprogram membentuk pulsa sendiri, dan juga menghitung berapa lama setelah itu pengaktifan berikutnya harus dipanggil. <br><br>  Saya ingat sebuah lelucon tentang Kolobok dan Tiga Bogatyrs, di mana Kolobok secara konsisten menyapa para Bogatyrs, kemudian secara konsisten mengajukan pertanyaan kepada mereka dan menerima jawaban.  Kemudian berturut-turut mengucapkan selamat tinggal kepada mereka.  Nah, kemudian dia bertemu dengan Tiga Puluh Tiga Ksatria.  Prosesor dalam peran roti, dan motor stepper dalam peran Bogatyrs.  Jelas bahwa di hadapan sejumlah besar blok UDB, dimungkinkan untuk memparalelkan pekerjaan dengan mesin, setelah setiap mesin diservis ke bloknya.  Dan karena kita memiliki segmen di mana mesin akan bergerak secara merata, mari kita coba untuk membuat peralatan bekerja dengan transaksi seperti itu, dan tidak dengan setiap langkah. <br><br>  Informasi apa yang diperlukan untuk kuda bulat untuk melintasi bagian linier dalam ruang hampa? <br><br><ul><li>  Jumlah langkah. </li><li>  Periode waktu antar langkah. </li></ul><br>  Dua parameter.  UDB hanya memiliki dua baterai dan dua register parameter D0 dan D1.  Tampaknya semuanya dapat diwujudkan.  Kami hanya memperkirakan kedalaman bit yang seharusnya dimiliki register ini. <br><br>  Pertama, jumlah langkah.  Jika ada 8 digit, maka dalam satu siklus operasi UDB, printer akan dapat menggerakkan kepala printer Cartesian sedikit lebih dari 1 mm (200 langkah mikro).  Tidak cukup  Jika kapasitasnya 16 bit, maka jumlah langkahnya adalah 65536. Ini adalah 65536/200 = 327 milimeter.  Dapat diterima untuk sebagian besar model.  Untuk Core, Delta dan lainnya perlu untuk memperkirakan, tetapi secara keseluruhan - untuk stroke penuh, segmen dapat dibagi menjadi beberapa bagian.  Tidak akan ada begitu banyak (dua, yah, maksimal tiga). <br><br>  Sekarang waktunya.  Biarkan frekuensi clock menjadi 48 MHz.  48000000/65536 = 732.  Artinya, frekuensi minimum yang diijinkan yang dapat diperoleh dengan menggunakan pembagi 16-bit adalah 732 Hz.  Terlalu banyak  Dalam Marlin Firmware, minimum adalah 120 Hz (yang kira-kira setara dengan 8 MHz dibagi dengan konstanta yang sama 65536).  Kami harus membuat register 24 bit.  Maka frekuensi minimum akan sama dengan 48000000 / (2 ^ 24) = 48000000/16777216 = 2,861 Hz. <br><br>  Bagus  Hentikan teori yang membosankan!  Mari kita lanjutkan berlatih!  Luncurkan PSoC Creator dan pilih File-&gt; New-&gt; Project: <br><br><img src="https://habrastorage.org/webt/tk/9t/bj/tk9tbjfppfjemih3s-ydrk54lfc.png"><br><br>  Selanjutnya, saya memilih papan tempat memotong roti yang saya miliki, dari mana lingkungan akan mengambil informasi dasar tentang pengontrol yang digunakan dan pengaturannya: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Saya sudah merasa siap untuk membuat proyek dari awal, jadi saya pilih <b>Kosong Skema</b> : <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Berikan lingkungan kerja nama <b>PSoC3DTest</b> : <br><br><img src="https://habrastorage.org/webt/rr/0u/pd/rr0updtyevaseusbwel37v76bgc.png"><br><br>  Dan ini dia, proyek yang sudah selesai! <br><br><img src="https://habrastorage.org/webt/fw/0s/xu/fw0sxucryznmujjsvr5ockarrjc.png"><br><br>  Hal pertama yang ingin saya lakukan adalah membuat komponen sendiri berdasarkan UDB.  Oleh karena itu, sebagaimana telah disebutkan dalam artikel terakhir, saya perlu beralih ke tab <b>Komponen</b> : <br><br><img src="https://habrastorage.org/webt/oa/o8/s5/oao8s5whrsdn9xsnophfoaom_n4.png"><br><br>  Klik kanan pada proyek dan pilih <b>Tambahkan Komponen</b> : <br><br><img src="https://habrastorage.org/webt/zq/kt/hu/zqkthur3pa19fpcrq4kcrmdac_y.png"><br><br>  Kami mengatakan bahwa kami perlu menambahkan <b>Dokumen UDB</b> , mengubah nama menjadi <b>StepperController</b> dan klik <b>Buat Baru</b> : <br><br><img src="https://habrastorage.org/webt/tz/v8/qk/tzv8qkfqumypnq3ctjeh9moitpc.png"><br><br>  Komponen muncul di pohon, plus - editor komponen ini dibuka: <br><br><img src="https://habrastorage.org/webt/yo/4g/np/yo4gnpvs5fuewpovam09lbq3zmw.png"><br><br>  Tempatkan blok Datapath pada formulir: <br><br><img src="https://habrastorage.org/webt/nx/1o/bl/nx1oblbig1eqyqat0yj-evlvwo0.png"><br><br>  Setelah memilih blok ini, kita pergi ke propertinya dan mengubah kedalaman bit dari 8 menjadi 24. Parameter yang tersisa dapat dibiarkan tidak berubah. <br><br><img src="https://habrastorage.org/webt/1e/oq/rf/1eoqrfsjz5uh1fj2mopwtmf5vao.png"><br><br>  Untuk memulai semua blok (untuk semua mesin) secara bersamaan, saya akan memulai sinyal awal dari luar (tambahkan input <b>Mulai</b> ).  Output: Saya akan membuat <b>Langkah</b> keluar secara langsung, sehingga saya bisa mengirimkannya ke driver motor stepper, serta <b>Out_Idle</b> .  Berdasarkan sinyal ini, prosesor akan dapat menentukan bahwa pada saat unit telah selesai bekerja.  Nama-nama sirkuit yang cocok dengan input dan output ini terlihat pada gambar. <br><br><img src="https://habrastorage.org/webt/sx/xq/gv/sxxqgvsyvpyr_jvzdblaf_l1soc.png"><br><br>  Sebelum berbicara tentang logika automaton, saya akan menjelaskan masalah rekayasa murni: mengatur durasi pulsa.  Dokumentasi driver DRV8825 mengharuskan lebar pulsa setidaknya 1,9 Î¼s.  Driver lain kurang menuntut pada lebarnya.  Seperti yang sudah disebutkan di bagian teoretis, register yang ada sudah ditempati dengan menetapkan durasi langkah dan jumlah langkah.  Suka atau tidak, penghitung tujuh-bit harus ditempatkan pada sirkuit.  Kami menyebutnya one-shot, yang mengatur pulsa langkah.  Pada frekuensi 48 MHz, untuk memastikan durasi 1,9 Î¼s, penghitung ini harus menghitung setidaknya 91,2 langkah.  Bulatkan hingga 92. Nilai apa pun yang melebihi ini akan menjadi tidak kurang.  Ternyata pengaturan berikut: <br><br><img src="https://habrastorage.org/webt/6w/k9/em/6wk9emz-qedseywswmgk24bdjqe.png"><br><br>  Counter Name <b>SingleVibrator</b> .  Ini tidak pernah diatur ulang, sehingga input <b>Reset</b> selalu terhubung ke nol, itu menganggap ketika mesin (dijelaskan di bawah) berada dalam keadaan Satu, itu memuat di semua negara lain (pada awalnya saya memilih negara bagian tertentu dari mesin, tetapi ternyata dengan metode yang rumit seperti itu , sumber daya PLD jauh lebih sedikit, tetapi hasilnya sama).  Nilai muatnya adalah desimal 92. Benar, editor yang baik akan segera mengganti nilai ini dengan heksadesimal: <br><br><img src="https://habrastorage.org/webt/qt/h0/nv/qth0nvcbb_8m7qty2mj1zpde2m4.png"><br><br>  Ketika penghitung dihitung ke nol, itu akan melaporkan ini ke rantai dengan nama <b>One_Finished</b> .  Dengan konter - itu saja. <br><br>  Apa jenis bendera status yang akan digunakan mesin kami?  Saya mendapatkannya seperti ini (saya mengingatkan Anda untuk mengklik dua kali pada daftar output di Datapath untuk mengaturnya): <br><br><img src="https://habrastorage.org/webt/mk/oo/z_/mkooz_ywbi5vnaenpgfqo98p580.png"><br><br><img src="https://habrastorage.org/webt/br/u9/rz/bru9rzw4kk4ja4j6ehutvm7od14.png"><br><br>  Saya akan menggunakan baterai A0 sebagai penghitung untuk durasi pulsa, jadi ketika nilainya mencapai nol, sebuah bendera akan dikokang, yang saya beri nama <b>Pulse_Finished</b> .  Baterai A1 akan menghitung pulsa untuk saya.  Oleh karena itu, penekanannya akan memiringkan bendera <b>Process_Finished</b> . <br><br>  Kami membuat grafik transisi automaton: <br><br><img src="https://habrastorage.org/webt/bv/rr/cv/bvrrcv0pgjs9fvadt08iyqaj92i.png"><br><br>  Variabel yang menetapkan negaranya disebut <b>State</b> .  Segera memetakan variabel ini ke register alamat dari instruksi ALU.  Awalnya saya lupa melakukan ini, jadi untuk waktu yang lama saya tidak bisa mengerti mengapa mesin saya tidak berfungsi.  Klik dua kali pada blok entri dalam Datapath: <br><br><img src="https://habrastorage.org/webt/zl/z2/e0/zlz2e0tvkl11wc5ot0id4vsdnh4.png"><br><br>  Dan mencocokkan: <br><br><img src="https://habrastorage.org/webt/1e/sp/q1/1espq1co36mt063kgyvig-kzhsw.png"><br><br>  Kami mulai berurusan dengan grafik transisi dan instruksi ALU yang terkait dengannya. <br><br>  Mari kita mulai dengan kondisi <b>Idle</b> .  Cukup jenuh dalam aksinya. <br><br>  Pertama, nilai register data D0 dan D1 secara konstan ditempatkan pada baterai A0 dan A1, masing-masing: <br><br><img src="https://habrastorage.org/webt/hz/8p/c-/hz8pc-lydhvzq3cnvsg2jw2qcem.png"><br><br>  Dari entri ini, mata yang terlatih akan melihat semua yang Anda butuhkan.  Karena mata kita masih belum diatur, kita klik dua kali pada entri dan melihat hal yang sama, tetapi lebih terinci: <br><br><img src="https://habrastorage.org/webt/yu/yy/qe/yuyyqemtvqbcsp25mbud7y3y1mu.png"><br><br>  Nilai utama di sini adalah mengisi baterai A1, penghitung pulsa.  Ketika program memasukkan nilai D1, itu segera pergi ke A1.  Program pasti tidak akan punya waktu untuk memulai proses sampai langkah selanjutnya.  Nilai ini diperiksa untuk membentuk suatu kondisi untuk keluar dari keadaan ini, yaitu, tidak ada tempat lain untuk mengisinya. <br><br>  Sekarang mari kita lihat apa yang dilakukan pada level grafik transisi: <br><br><img src="https://habrastorage.org/webt/97/p-/2d/97p-2dwdvbxyb_tpi-xaqjdhuck.png"><br><br>  Pemicu bantu <b>Start_Prev</b> memungkinkan <b>Anda</b> untuk menangkap <b>sisi</b> positif pada input <b>Mulai</b> , mengatur garis tunda selama 1 siklus.  Itu akan selalu berisi keadaan input <b>Mulai</b> , yang pada ukuran sebelumnya.  Seseorang yang lebih terbiasa melihat ini di Verilog: <br><br><img src="https://habrastorage.org/webt/mm/pc/vw/mmpcvwuturlr5nieqnkgieml_tm.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama</b> <div class="spoiler_text"><pre><code class="plaintext hljs">always @ (posedge clock) begin : Idle_state_logic case(State) Idle : begin Start_Prev &lt;= (Start); IsIdle &lt;= (1); if (( Start&amp;(!Start_Prev)&amp;(!Process_Finished) ) == 1'b1) begin State &lt;= One ; end end</code> </pre> <br></div></div><br>  Dengan demikian, kondisi <b>Mulai &amp; (! Mulai_Prev)</b> benar hanya ketika perbedaan garis <b>Mulai</b> positif <b>terjadi di antara langkah-langkah</b> . <br><br>  Selain itu, ketika mesin berada dalam keadaan ini, output <b>IsIdle dibawa</b> ke dalam satu keadaan, menginformasikan lingkungan eksternal bahwa blok pasif.  Dengan pendekatan ini, lebih sedikit sumber daya PLD yang dihabiskan daripada jika <b>Negara ==</b> Konstruksi <b>menganggur</b> diserahkan ke output. <br><br>  Ketika perbedaan sinyal <b>Mulai</b> berasal dari lingkungan eksternal, dan akumulator A1 memiliki nilai non-nol, mesin akan keluar dari status <b>Idle</b> .  Jika nol dimasukkan dalam A1, maka mesin tidak terlibat dalam pengembangan segmen ini, sehingga perbedaan pada garis <b>Start</b> diabaikan.  Ini berlaku untuk ekstruder yang tidak digunakan.  Untuk beberapa printer, mesin Z-axis juga jarang digunakan. Biarkan saya mengingatkan Anda bagaimana kondisi terbentuk yang mengungkapkan nilai nol di A1 (dan bukan nol adalah inversinya): <br><br><img src="https://habrastorage.org/webt/ez/kk/up/ezkkuprcmblrfjx22av9dlfu5bc.png"><br><br>  Selanjutnya, mesin memasuki negara <b>One</b> : <br><br><img src="https://habrastorage.org/webt/zr/qc/cm/zrqccmzwghfncwcqyfekuhawmcg.png"><br><br>  Dalam keadaan ini, output <b>Langkah</b> diatur ke 1. Pulsa langkah diterapkan ke driver.  Selain itu, nilai pemicu <b>IsIdle diatur ulang</b> .  Lingkungan eksternal diinformasikan bahwa unit berada dalam fase aktif. <br><br>  Keadaan ini <b>dikeluarkan</b> oleh sinyal <b>One_Finished</b> , yang akan dinaikkan menjadi satu ketika penghitung tujuh-bit dihitung menjadi nol.  Biarkan saya mengingatkan Anda bahwa sinyal <b>One_Finished</b> dihasilkan oleh penghitung khusus ini: <br><br><img src="https://habrastorage.org/webt/ls/yp/re/lsypreow8ydou_tqhrls8us-qem.png"><br><br>  Saat mesin dalam kondisi ini, ALU memuat ke dalam baterai A0 (mengatur durasi pulsa) nilai dari register D0.  Biarkan saya menunjukkan kepada Anda hanya catatan singkat yang mengatakan ini: <br><br><img src="https://habrastorage.org/webt/am/b_/fa/amb_faw1o-9vsgframn5iswseas.png"><br><br>  Nilai yang dimuat akan digunakan dalam kondisi berikut.  Berada di dalamnya, mesin menghasilkan penundaan yang menetapkan durasi pulsa: <br><br><img src="https://habrastorage.org/webt/hh/eb/kf/hhebkfiwmsmnnrtkf17w2wqby8o.png"><br><br>  Output <b>Langkah</b> diatur ulang ke nol.  Baterai A0 berkurang, sebagaimana dibuktikan oleh entri singkat berikut: <br><br><img src="https://habrastorage.org/webt/bb/63/dk/bb63dkglkjd8_7wn1s2by22_hym.png"><br><br>  Dan jika Anda mengklik dua kali di atasnya - entri lengkap: <br><br><img src="https://habrastorage.org/webt/-8/6d/ry/-86dryefyslh1qsvlo4ggkdojhg.png"><br><br>  Ketika nilai A0 mencapai nol, bendera Pules_Finished akan dinaikkan, dan mesin akan masuk ke status <b>Pengurangan</b> : <br><br><img src="https://habrastorage.org/webt/6k/sw/yv/6kswyvakmiszucfe1cx49pjcyig.png"><br><br>  Dalam keadaan ini, dalam ALU, nilai akumulator A1 berkurang, yang menetapkan jumlah pulsa: <br><br><img src="https://habrastorage.org/webt/ci/9r/1e/ci9r1ervyzj1gyma_tpj4uxnzfq.png"><br><br>  Versi lengkap dari catatan: <br><br><img src="https://habrastorage.org/webt/l9/dk/hy/l9dkhy0a6bb2bqpzgmzgtox7clk.png"><br><br>  Bergantung pada hasilnya, transisi baik ke pulsa berikutnya atau ke kondisi <b>Idle</b> terjadi.  Klik dua kali pada negara untuk melihat transisi dengan mempertimbangkan prioritas: <br><br><img src="https://habrastorage.org/webt/jm/r-/7n/jmr-7nle2advdfl95fn8hnkid0i.png"><br><br>  Sebenarnya, dengan UDB semuanya.  Sekarang kita membuat simbol yang sesuai.  Untuk melakukan ini, klik kanan pada editor dan pilih <b>Generate Symbol</b> : <br><br><img src="https://habrastorage.org/webt/j6/j3/qc/j6j3qcgoye9-2gac8fgowordfx8.png"><br><br>  Kami pergi ke diagram proyek: <br><br><img src="https://habrastorage.org/webt/ab/hb/l4/abhbl4ocjtfgw8r4vjfo8nfs05c.png"><br><br>  Dan kami memperkenalkan sirkuit di mana ada sejumlah pengontrol ini.  Saya memilih lima (tiga sumbu ditambah dua ekstruder).  Printer dengan sejumlah besar pengekstrusi tidak akan dianggap murah.  Anda dapat menempatkan FPGA pada mereka.  Sepanjang jalan, untuk melihat kompleksitas sebenarnya, saya melemparkan blok USB-UART (untuk menerima data dari komputer atau Raspberry Pi yang sama) dan UART nyata (itu akan menyediakan komunikasi dengan modul Wi-Fi murah ESP8266 atau, katakanlah, layar cerdas yang dapat kirim GCODE melalui UART).  Saya tidak menambahkan PWM dan sebagainya, karena kompleksitasnya kira-kira jelas, dan sistem yang sebenarnya masih jauh.  Ternyata entah bagaimana seperti ini: <br><br><img src="https://habrastorage.org/webt/he/a6/ok/hea6okfr7irbrzjwm-bze2xlfxy.png"><br><br>  Register kontrol menghasilkan sinyal pemicu, yang pergi ke semua blok secara bersamaan.  Selain itu, biarkan sinyal keluar darinya, yang statis selama pembentukan segmen.  Saya mengumpulkan semua output <b>Idle</b> oleh "Dan" dan diterapkan pada input interupsi.  Saya menunjuk gangguan di sisi positif.  Jika setidaknya satu mesin mulai, input interupsi akan diatur ulang.  Pada akhir mesin terakhir, itu akan dikokang, yang akan menginformasikan prosesor tentang kesiapan untuk kesimpulan dari segmen berikutnya.  Sekarang sesuaikan frekuensinya dengan mengklik dua kali pada elemen pohon <b>Jam</b> : <br><br><img src="https://habrastorage.org/webt/zy/yf/kl/zyyfklrmcfz5kmg-59qmzgdztug.png"><br><br>  Di tabel yang muncul, klik dua kali pada elemen <b>PLL_OUT</b> : <br><br><img src="https://habrastorage.org/webt/8z/m0/r1/8zm0r10tu28rjatkhmo1h0skp80.png"><br><br>  Kami akan mengisi tabel ini entah bagaimana (saya belum memahami aturan untuk menyiapkan tabel ini dengan cukup baik, itulah sebabnya saya menggunakan istilah "Sesuatu seperti itu"): <br><br><img src="https://habrastorage.org/webt/se/55/ps/se55ps9rti9fyvyguffgxdx0f0i.png"><br><br>  Sekarang klik dua kali pada garis <b>Clock_1</b> : <br><br><img src="https://habrastorage.org/webt/vn/py/px/vnpypxluipgeeme1fyf9icn9tu4.png"><br><br>  Atur frekuensi clock dari blok UDB ke 48 MHz: <br><br><img src="https://habrastorage.org/webt/8z/sk/ik/8zskik6rpyovzo7ryqrxjeptinm.png"><br><br>  Karena proyek ini eksperimental, tidak masuk akal untuk membuat API untuk itu.  Tetapi untuk mengkonsolidasikan materi yang dipelajari dalam artikel sebelumnya, kita kembali pergi ke tab Komponen dan untuk proyek StepperController, klik kanan melalui Tambahkan Komponen Item pertama kita menambahkan file header, dan kemudian file kode sumber C: <br><br><img src="https://habrastorage.org/webt/3i/bg/zk/3ibgzkq8nugwau5lszhe9ikudxi.png"><br><br><img src="https://habrastorage.org/webt/bm/k3/iw/bmk3iwh-aouvspv20g7_1bgi3wq.png"><br><br>  Saya akan menunjukkan secara dangkal dua fungsi inisialisasi dan mulai dari segmen yang saya tambahkan.  Selebihnya bisa dilihat pada contoh artikel. <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start } void `$INSTANCE_NAME`_PrepareStep(int nSteps,int duration) { CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D0_PTR, duration&gt;92?duration-92:0); CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D1_PTR, nSteps&gt;1?nSteps-1:0); }</code> </pre><br>  Saya mengganti nama <b>main.c</b> dengan <b>main.cpp</b> untuk memverifikasi bahwa lingkungan pengembangan akan merespons C ++ secara normal, karena firmware Marlin berorientasi objek.  Kesalahan tak terduga yang diprediksi yang dihilangkan dengan penambahan hal biasa: <br><br><img src="https://habrastorage.org/webt/5m/mn/cd/5mmncdgxig9oxchcekaofuv1k9y.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "project.h" }</code> </pre><br></div></div><br>  Untuk peluncuran mesin secara global, saya membuat fungsi seperti itu (sangat kasar, tetapi untuk eksperimen dengan kuda berbentuk bola dalam ruang hampa, itu akan dilakukan, dalam eksperimen waktu pengembangan lebih penting daripada keindahan): <br><pre> <code class="plaintext hljs">void StartSteppers() { Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (0); }</code> </pre><br>  Dia memulai sinyal <b>Mulai</b> , untuk berjaga-jaga, segera untuk tiga langkah, lalu menjatuhkannya lagi. <br><br>  Baiklah, mari kita mulai eksperimen.  Pertama, cukup melangkahi mesin X dan Y (dalam contoh, grup panggilan pertama menginisialisasi semua pengontrol, yang kedua mengatur pengontrol X dan Y ke sejumlah langkah yang diperlukan dan memulai proses): <br><br><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); StepperController_X_PrepareStep (10,1000); //    StepperController_Y_PrepareStep (50,500); StartSteppers(); //   for(;;) { } }</code> </pre><br>  Kami melihat hasilnya: <br><br><img src="https://habrastorage.org/webt/6x/io/v7/6xiov7g15a-ksl1_6kw7vkko0dc.png"><br><br>  Periksa durasi pulsa positif: <br><br><img src="https://habrastorage.org/webt/ay/hk/jy/ayhkjyjphl4-pearn7zi3hnnknc.png"><br><br>  Benar juga.  Akhirnya, kami memeriksa seberapa baik interupsi bekerja.  Tambahkan variabel penghitung global: <br><br><pre> <code class="plaintext hljs">static int nStep=0;</code> </pre><br>  Variabel ini ditugaskan untuk satu di fungsi <b>utama</b> , dan meningkatkan fungsi penangan interrupt.  Handler interrupt akan memecat hanya sekali, murni untuk verifikasi.  Saya membuatnya seperti ini: <br><br><pre> <code class="plaintext hljs">extern "C" { CY_ISR(StepperFinished) { if (nStep == 1) { StepperController_X_PrepareStep (5,500); StartSteppers(); nStep += 1; } } }</code> </pre><br>  Dan dalam fungsi <b>utama</b> , saya menambahkan dua baris: dimasukkannya interupsi dan penugasan variabel ini.  Dan saya sudah menetapkan ketika mesin mulai.  Kalau tidak, permintaan interupsi palsu datang.  Tidak ada alasan khusus untuk melawannya sekarang.  Proyek ini adalah proyek eksperimental. <br><br><img src="https://habrastorage.org/webt/kb/v2/dm/kbv2dmk2s6cg9nzc9fjzypg5uyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); /* Place your initialization/startup code here (eg MyInst_Start()) */ StepperController_X_PrepareStep (10,1000); StepperController_Y_PrepareStep (20,500); StartSteppers(); nStep = 1; for(;;) { } }</code> </pre><br></div></div><br>  Kami memeriksa hasilnya (pada langkah kedua hanya mesin X yang akan bekerja, dan langkah-langkahnya akan menjadi setengah lebih banyak): <br><br><img src="https://habrastorage.org/webt/0q/vi/iq/0qviiqvpko6m9i7o9tub3gmnqhw.png"><br><br>  Benar juga. <br><br><h2>  Kesimpulan </h2><br>  Secara umum, sudah jelas bahwa blok UDB dapat digunakan tidak hanya untuk mengatur fungsi perangkat keras yang cepat, tetapi juga untuk memindahkan logika dari perangkat lunak ke tingkat firmware.  Sayangnya, volume artikel ternyata sangat besar sehingga tidak mungkin untuk menyelesaikan ulasan dan mendapatkan jawaban yang jelas apakah kemampuan UDB cukup untuk solusi akhir dari tugas tersebut.  Sejauh ini, hanya kuda bulat yang siap dalam ruang hampa, tindakan yang pada prinsipnya sangat mirip dengan yang diperlukan, tetapi pembaca yang mengganggu akrab dengan teori kontrol motor stepper akan menemukan banyak kekurangan di dalamnya.  Unit yang disajikan tidak mendukung akselerasi, yang tanpanya pengoperasian motor stepper sungguhan menjadi tidak mungkin.  Sebaliknya, ini mendukung, tetapi pada tahap ini diperlukan tingkat interupsi yang tinggi, dan semuanya dirancang untuk menghindarinya. <br><br>  Keakuratan pengaturan frekuensi blok yang disajikan jauh dari dapat diterima.  Secara khusus, ini akan memberikan frekuensi pulsa 40.000 Hz dengan pembagi 1.200 dan 39966 Hz dengan pembagi 1201. Frekuensi menengah antara kedua nilai pada blok ini tidak dapat dicapai. <br><br>  Mungkin ada beberapa kekurangan lain di dalamnya.  Tetapi kita akan membahasnya di artikel berikutnya untuk memeriksa apakah ada cukup sumber daya UDB. <br><br>  Sementara itu, pembaca telah menerima, antara lain, contoh nyata membuat blok berdasarkan UDB dari awal.  Proyek pengujian yang diperoleh selama penulisan artikel ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat dilakukan di sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433800/">https://habr.com/ru/post/id433800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433788/index.html">Transaksi Aman dan Ulasan Freelance Baru</a></li>
<li><a href="../id433790/index.html">Templat bangun multi tahap tingkat lanjut</a></li>
<li><a href="../id433792/index.html">Skrip shell dalam Ansible</a></li>
<li><a href="../id433796/index.html">Bagaimana Homo Sapiens menaklukkan dunia. Keterampilan komunikasi dan negosiasi</a></li>
<li><a href="../id433798/index.html">HomeKit dan ioBroker Mari berteman di rumah</a></li>
<li><a href="../id433802/index.html">Bagaimana dan mengapa kami memenangkan jalur Big Data di Urban Tech Challenge Hackathon</a></li>
<li><a href="../id433804/index.html">Jaringan kerapatan campuran</a></li>
<li><a href="../id433806/index.html">Ketika arsip online lupa</a></li>
<li><a href="../id433808/index.html">5 kesalahan paling umum yang dilakukan programmer pada saat wawancara</a></li>
<li><a href="../id433810/index.html">Pendekatan berorientasi masalah untuk proyek-proyek pemasaran Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>