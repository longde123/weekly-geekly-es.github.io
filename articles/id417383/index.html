<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬅️ 🎪 👩‍👧‍👧 JavaScript ES6: Kelemahan 🈯️ 🌭 📳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bulan Juni 2018, standar ECMAScript 2015 ( ES6 ) merayakan peringatan tiga tahun. Dalam ES6, pertama, banyak fitur JavaScript baru telah muncul, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: Kelemahan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  Pada bulan Juni 2018, standar ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ES6</a> ) merayakan peringatan tiga tahun.  Dalam ES6, pertama, banyak fitur JavaScript baru telah muncul, dan kedua, era baru pengembangan bahasa dimulai dengan standar ini.  Selain itu, ini adalah rilis JS berskala besar terakhir, karena sekarang TC39 menggunakan skema untuk menerbitkan masalah tahunan standar yang kecil, dan tidak mengeluarkannya lagi setiap beberapa tahun. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  4 tahun terakhir, ES6, cukup dibenarkan, telah menarik perhatian universal.  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa selama ini, terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel</a> , ia menulis semua kode menggunakan versi modern dari spesifikasi JS.  Dia percaya bahwa cukup waktu telah berlalu untuk menganalisis secara kritis fitur-fitur baru ES6.  Secara khusus, dia tertarik pada apa yang dia gunakan untuk beberapa waktu, dan kemudian berhenti menggunakannya karena memperburuk kodenya. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tentang kelemahan JS</font> </h2><br>  Douglas Crockford, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukunya,</a> JavaScript: Strengths, juga menulis tentang apa yang dapat dianggap sebagai kelemahan bahasa.  Ini adalah sesuatu yang, menurutnya, tidak layak digunakan.  Untungnya, di antara inovasi ES6 tidak ada yang tidak sedap dipandang seperti beberapa fitur bermasalah lama JS, seperti operator kesetaraan lemah yang melakukan konversi tipe implisit, fungsi <code>eval()</code> , dan pernyataan <code>with</code> .  Fitur-fitur baru ES6 dirancang jauh lebih baik.  Namun, ada beberapa hal dalam dirinya yang saya hindari.  Fitur-fitur yang ada dalam daftar "kelemahan" JS saya ada di daftar ini karena alasan berikut: <br><br><ul><li>  Mereka pada dasarnya adalah "jebakan".  Artinya, tampaknya mereka dirancang untuk melakukan tindakan tertentu, dan dalam kebanyakan kasus, mereka berfungsi seperti yang diharapkan.  Namun, terkadang mereka berperilaku tidak terduga, yang dengan mudah dapat menyebabkan kesalahan. </li><li>  Mereka meningkatkan volume bahasa dengan imbalan manfaat kecil.  Peluang semacam itu memberi pengembang beberapa keuntungan kecil, tetapi membutuhkan seseorang yang mencoba mencari tahu kodenya untuk memiliki pengetahuan tentang mekanisme tertentu, biasanya tersembunyi di suatu tempat.  Ini berlaku ganda untuk kemampuan API, ketika menggunakan fitur ini berarti bahwa kode lain yang berinteraksi dengan kode yang ditulis oleh pengembang tertentu harus mengetahui penerapan fitur API ini. </li></ul><br>  Sekarang, dipandu oleh pertimbangan ini, mari kita bicara tentang kelemahan ES6. <br><br><h2>  <font color="#3AC1EF">Kata kunci const</font> </h2><br>  Sebelum ES6, variabel dalam JavaScript dapat dideklarasikan menggunakan kata kunci <code>var</code> .  Selain itu, variabel tidak dapat dideklarasikan sama sekali, maka mereka, bahkan jika digunakan dalam fungsi, termasuk dalam ruang lingkup global.  Properti objek dapat memainkan peran variabel, dan fungsi dideklarasikan menggunakan <code>function</code> kata kunci.  Kata kunci <code>var</code> memiliki fitur tertentu. <br><br>  Jadi, ini memungkinkan Anda untuk membuat variabel yang ditambahkan ke objek global, atau yang lingkupnya dibatasi oleh fungsi.  Namun, kata kunci <code>var</code> tidak memperhatikan blok kode.  Selain itu, Anda dapat merujuk ke variabel yang dideklarasikan menggunakan kata kunci <code>var</code> dalam kode yang terletak sebelum perintah untuk deklarasi.  Fenomena ini dikenal sebagai menaikkan variabel.  Fitur-fitur ini, jika tidak diperhitungkan, dapat menyebabkan kesalahan.  Untuk memperbaiki situasi, ES6 memperkenalkan dua kata kunci baru untuk mendeklarasikan variabel: <code>let</code> dan <code>const</code> .  Mereka memecahkan masalah utama <code>var</code> .  Yaitu, kita berbicara tentang fakta bahwa variabel yang dideklarasikan menggunakan kata kunci ini memiliki cakupan blok, sebagai akibatnya, sebagai contoh, variabel yang dideklarasikan dalam satu lingkaran tidak terlihat di luarnya.  Selain itu, menggunakan <code>let</code> dan <code>const</code> tidak memungkinkan variabel diakses sebelum mereka dideklarasikan.  Ini akan menghasilkan kesalahan <code>ReferenceError</code> .  Ini adalah langkah besar ke depan.  Namun, munculnya dua kata kunci baru, serta fitur-fiturnya, menyebabkan kebingungan tambahan. <br><br>  Nilai variabel (konstan) yang dinyatakan menggunakan kata kunci <code>const</code> tidak dapat ditimpa setelah deklarasi.  Ini adalah satu-satunya perbedaan antara <code>const</code> dan <code>let</code> .  Peluang baru ini terlihat bermanfaat, dan benar-benar dapat membawa manfaat.  Masalahnya adalah kata kunci <code>const</code> itu sendiri.  Cara konstanta yang dinyatakan menggunakannya berperilaku tidak sesuai dengan apa yang diasosiasikan sebagian besar pengembang dengan konsep "konstan". <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  Menggunakan kata kunci <code>const</code> mencegah nilai baru ditulis ke konstanta, tetapi tidak membuat objek yang direferensikan oleh konstanta seperti tidak dapat diubah.  Fitur ini memberikan perlindungan yang buruk terhadap perubahan nilai saat bekerja dengan sebagian besar tipe data.  Akibatnya, karena fakta bahwa menggunakan <code>const</code> dapat menyebabkan kebingungan, dan karena fakta bahwa jika kata kunci <code>let</code> hadir, keberadaan <code>const</code> terlihat berlebihan, saya memutuskan untuk selalu menggunakan <code>let</code> . <br><br><h2>  <font color="#3AC1EF">String Templat Tagged</font> </h2><br>  Kata kunci <code>const</code> adalah contoh bagaimana spesifikasi menciptakan terlalu banyak cara untuk menyelesaikan terlalu sedikit masalah.  Dalam hal string templat yang ditandai, kami memiliki situasi sebaliknya.  Sintaksis string semacam itu dianggap oleh komite TC39 sebagai cara untuk menyelesaikan interpolasi string dan string multiline.  Kemudian mereka memutuskan untuk memperluas kesempatan ini melalui penggunaan makro. <br><br>  Jika Anda belum pernah melihat string pola yang ditandai sebelumnya, perlu diingat bahwa mereka sedikit seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator</a> string.  Berikut adalah contoh bekerja dengan mereka dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  String template yang ditandai tidak dapat disebut tidak berguna sama sekali.  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ikhtisar dari</a> beberapa kegunaannya.  Misalnya, mereka berguna dalam membersihkan kode HTML.  Dan, saat ini, aplikasi mereka menunjukkan pendekatan yang paling akurat dalam situasi ketika Anda perlu melakukan operasi yang sama pada semua data input dari templat string yang arbitrer.  Namun, ini relatif jarang terjadi, Anda dapat melakukan hal yang sama menggunakan API yang sesuai (meskipun solusi seperti itu lebih lama).  Dan, untuk mengatasi sebagian besar masalah, menggunakan API tidak akan lebih buruk daripada menggunakan string templat yang ditandai.  Fitur ini tidak menambahkan fitur baru ke bahasa.  Dia menambahkan pendekatan baru untuk bekerja dengan data yang seharusnya tidak asing bagi mereka yang harus membaca kode yang ditulis menggunakan string templat yang ditandai.  Dan saya berusaha untuk memastikan bahwa kode saya tetap sebersih dan semudah mungkin dimengerti. <br><br><h2>  <font color="#3AC1EF">Ekspresi Penugasan Destructive Redesigned</font> </h2><br>  Beberapa fitur bahasa tampak hebat ketika digunakan untuk menyelesaikan tugas-tugas sederhana, namun, ketika tugas menjadi lebih kompleks, fitur-fitur ini bisa lepas kendali.  Sebagai contoh, saya suka operator kondisional ternary: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Namun, kode yang ditulis dengan bantuannya, menjadi sulit untuk dipahami jika, menggunakan operator ini, Anda mulai menggunakan konstruksi bersarang: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  Hal yang sama dapat dikatakan tentang penugasan destruktif.  Mekanisme ini memungkinkan Anda untuk menarik nilai variabel dari objek atau array: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  Selain itu, saat menggunakannya, Anda dapat mengubah nama variabel, mendapatkan nilai bersarang, mengatur nilai default: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  Semua ini luar biasa - sampai sampai pada membangun ekspresi kompleks menggunakan semua fitur ini.  Misalnya, dalam ekspresi di bawah ini, 4 variabel dinyatakan: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> , dan <code>eventId</code> .  Nilai-nilai mereka diambil dari tempat yang berbeda dalam struktur objek <code>eventRecord</code> . <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Memahami kode semacam itu hampir tidak mungkin.  Masalah ini dapat diselesaikan dengan menggunakan kode yang lebih mudah dibaca, jika Anda menggunakan beberapa operasi perusakan atau benar-benar meninggalkannya. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  Saya tidak memiliki pedoman yang jelas yang menunjukkan bahwa ekspresi tugas destruktif perlu dikerjakan ulang.  Namun, setiap kali saya melihat ekspresi yang sama dan tidak dapat langsung memahami masalah apa yang dipecahkannya, variabel apa yang digunakan di dalamnya, saya mengerti bahwa inilah saatnya untuk menyederhanakan kode untuk meningkatkan keterbacaannya. <br><br><h2>  <font color="#3AC1EF">Ekspor default</font> </h2><br>  ES6 memiliki satu fitur yang bagus.  Ini terdiri dari bagaimana pengembangnya mendekati standardisasi dari apa yang sebelumnya dilakukan dengan bantuan berbagai perpustakaan, seringkali saling bersaing.  Jadi dalam spesifikasi muncul kelas, janji, modul.  Ini semua yang digunakan komunitas pengembang JS sebelum ES6, menemukannya di perpustakaan pihak ketiga.  Sebagai contoh, modul ES6 adalah pengganti yang sangat baik untuk apa yang tumpah ke dalam perang format AMD / CommonJS dan memberikan sintaksis yang mudah untuk mengatur impor. <br><br>  Modul ES6 mendukung dua cara utama untuk mengekspor nilai: ekspor bernama dan ekspor default, atau ekspor standar: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Modul dapat menggunakan beberapa perintah ekspor bernama, tetapi hanya satu perintah ekspor default.  Saat mengimpor apa yang diekspor menggunakan perintah ekspor default, dalam file impor, Anda dapat memberikan apa pun yang diekspor secara default nama apa pun, karena tidak ada nama yang dicari selama operasi ini.  Saat menggunakan ekspor bernama, Anda perlu menggunakan nama variabel dari file yang diekspor, meskipun penggantian nama juga dimungkinkan. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  Ekspor default menikmati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perhatian khusus dari pengembang</a> standar ES6, dan mereka sengaja membuat sintaksis yang lebih sederhana untuk itu.  Namun, dalam praktiknya, saya dapat mengetahui bahwa menggunakan teknologi ekspor yang dinamai lebih disukai karena alasan berikut. <br><br><ol><li>  Saat menggunakan ekspor bernama, nama-nama variabel yang diekspor, secara default, sesuai dengan nama-nama variabel yang diimpor, yang menyederhanakan pencarian mereka bagi mereka yang tidak menggunakan alat pengembangan cerdas. </li><li>  Saat menggunakan ekspor bernama, programmer yang menggunakan alat pengembangan pintar mendapatkan fitur nyaman seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">impor otomatis</a> . </li><li>  Ekspor bernama memungkinkan Anda untuk mengekspor seragam dari modul apa pun yang Anda inginkan, dalam jumlah yang tepat.  Ekspor default membatasi pengembang untuk hanya mengekspor nilai tunggal.  Sebagai solusinya, Anda bisa menerapkan ekspor objek dengan beberapa properti.  Namun, pendekatan ini kehilangan nilai algoritma pengocok pohon yang digunakan untuk mengurangi ukuran aplikasi JS yang dibangun oleh sesuatu seperti webpack.  Menggunakan modul yang diberi nama secara eksklusif menyederhanakan pekerjaan. </li></ol><br>  Secara umum, dapat dicatat bahwa entitas penamaan adalah praktik yang baik, karena memungkinkan Anda untuk mengidentifikasi mereka secara unik dalam kode dan dalam percakapan tentang kode ini.  Itu sebabnya saya menggunakan ekspor bernama. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Anda baru saja belajar tentang fitur ES6, yang, menurut penulis materi ini, tidak berhasil.  Mungkin Anda bergabung dengan pendapat ini, mungkin juga tidak.  Bahasa pemrograman apa pun adalah sistem yang kompleks, yang kemampuannya dapat dilihat dari berbagai sudut pandang.  Namun, kami berharap artikel ini bermanfaat bagi semua yang berusaha menulis kode yang jelas dan berkualitas tinggi. <br><br>  <b>Pembaca yang budiman!</b>  Adakah sesuatu dalam JavaScript modern yang Anda coba hindari? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417383/">https://habr.com/ru/post/id417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417369/index.html">15 alat untuk gudang kerja manajer produk</a></li>
<li><a href="../id417373/index.html">Penyimpanan ZFS, Siaga, dan Lingkungan Uji</a></li>
<li><a href="../id417375/index.html">15 Metode elemen HTML yang mungkin belum pernah Anda dengar</a></li>
<li><a href="../id417377/index.html">Mengapa Anda tidak harus menggunakan Google Cloud</a></li>
<li><a href="../id417379/index.html">Motor roket propelan solid baru untuk Vega-C dan Ariane 6</a></li>
<li><a href="../id417385/index.html">Bagaimana saya pindah ... rumah, atau jawaban saya kepada penulis artikel tentang "tepung tanpa ampun"</a></li>
<li><a href="../id417389/index.html">Efek Lensa Tilt Shift</a></li>
<li><a href="../id417391/index.html">Ekstensi web lintas browser untuk skrip khusus Bagian 4</a></li>
<li><a href="../id417393/index.html">Bagaimana kami membuat sistem yang memberikan diskon kepada pelanggan berdasarkan karakteristik individu</a></li>
<li><a href="../id417395/index.html">Pengujian end-to-end: apa, mengapa, mengapa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>