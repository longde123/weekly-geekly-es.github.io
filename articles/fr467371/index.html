<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 💨 🙇🏿 Analyse des entretiens d'embauche Google: recherche de relations 🔶 🙅🏽 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bienvenue dans le prochain article d'une série d' énigmes que j'ai posées lors d'entretiens avec Google avant leur interdiction après la fuite. Depuis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des entretiens d'embauche Google: recherche de relations</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Bienvenue dans le prochain article d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">série d'</a> énigmes que j'ai posées lors d'entretiens avec Google avant leur interdiction après la fuite.  Depuis lors, j'ai cessé de travailler en tant qu'ingénieur logiciel chez Google et j'ai déménagé au poste de responsable du développement chez Reddit, mais j'ai encore quelques bons sujets.  À ce jour, nous avons examiné <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la programmation dynamique</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">élevant les matrices à la puissance</a> et à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">synonymie des requêtes</a> .  Cette fois, une question complètement nouvelle. <br><a name="habracut"></a><br>  Mais d'abord, deux points.  Tout d'abord, le travail chez Reddit était génial.  Au cours des huit derniers mois, j'ai construit et dirigé la nouvelle équipe de pertinence des annonces et mis en place un nouveau bureau de développement à New York.  Peu importe à quel point cela peut être amusant, malheureusement, j'ai trouvé que jusqu'à récemment, je n'avais plus de temps ni d'énergie pour un blog.  J'ai peur d'avoir un peu abandonné cette série.  Désolé pour le retard. <br><br>  Deuxièmement, si vous avez suivi les articles, après le dernier numéro, vous pourriez penser que je commencerais à creuser dans les options synonymiques des requêtes.  Bien que j'aimerais y revenir un jour, je dois admettre que j'ai perdu tout intérêt pour ce problème en raison d'un changement de travail et jusqu'à présent, j'ai décidé de le reporter.  Restez en contact!  Je le dois et j'ai l'intention de le rendre.  Juste, tu sais, un peu plus tard ... <br><br>  <i>Avis de non-responsabilité rapide: Bien que l'entretien des candidats soit l'une de mes tâches professionnelles, ce blog présente mes observations personnelles, mes histoires personnelles et mes opinions personnelles.</i>  <i>Veuillez ne pas prendre cela pour toute déclaration officielle de Google, Alphabet, Reddit ou de toute autre personne ou organisation.</i> <br><br><h2>  Rechercher une nouvelle question </h2><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> j'ai décrit une de mes questions préférées que j'ai utilisée pendant longtemps, avant l'inévitable fuite.  Les questions précédentes étaient fascinantes d'un point de vue théorique, mais je voulais choisir un problème un peu plus pertinent pour Google en tant qu'entreprise.  Lorsque cette question a été interdite, j'ai voulu trouver un remplaçant, en tenant compte de la nouvelle restriction: rendre la question <i>plus simple</i> . <br><br>  Maintenant, cela peut sembler un peu surprenant compte tenu du tristement célèbre processus d'entrevue chez Google.  Mais à cette époque, un problème plus simple avait du sens.  Mon raisonnement comportait deux parties.  La première est pragmatique: les candidats ne réagissaient généralement pas très bien aux questions précédentes, malgré de nombreux indices et simplifications, et je ne savais pas toujours pourquoi.  La deuxième théorie: le processus d'entrevue devrait diviser les candidats en catégories «mérite d'être embauché» et «ne vaut pas la peine d'être embauché», et j'étais curieux de savoir si cela pourrait être fait un peu plus facilement avec la question. <br><br>  Avant de clarifier ces deux points, je veux souligner ce qu'ils <i>ne</i> signifient <i>pas</i> .  "Je ne sais pas toujours pourquoi une personne a des problèmes" ne signifie pas l'inutilité des questions et que je voulais simplifier l'entretien pour cette raison.  Même la question la plus difficile, beaucoup se sont bien débrouillées.  Je veux dire, quand les candidats avaient des problèmes, il était difficile pour moi de comprendre ce qu'ils manquaient. <br><br>  De bons entretiens donnent une vue d'ensemble des forces et des faiblesses du candidat.  Il ne suffit pas que le comité de recrutement dise simplement qu'il a «échoué»: le comité détermine si le candidat possède les qualités spécifiques à l'entreprise qu'il recherche.  De même, les mots «il est cool» n'aident pas le comité à choisir un candidat fort dans certains domaines, mais douteux dans d'autres.  J'ai constaté que des questions plus complexes séparent trop souvent les candidats en ces deux catégories.  Dans cette optique, «je ne sais pas toujours pourquoi une personne a des problèmes» signifie «l’incapacité de progresser sur cette question ne donne pas en soi une image des capacités de ce candidat». <br><br>  La classification des candidats comme «mérite d'être embauchée» et «ne vaut pas la peine d'être embauchée» <i>ne</i> signifie <i>pas</i> que le processus d'entrevue devrait séparer les candidats stupides des candidats intelligents.  Je ne me souviens pas d'un seul candidat qui n'était pas intelligent, talentueux et motivé.  Beaucoup venaient d'excellentes universités et les autres étaient clairement extrêmement motivés.  Passer des entretiens téléphoniques est déjà un bon tamis, et même refuser à ce stade n'est pas un signe de manque de capacité. <br><br>  Cependant, je me souviens de beaucoup de personnes qui n'étaient pas suffisamment préparées pour l'entretien ou qui travaillaient trop lentement, ou nécessitaient trop de supervision pour résoudre le problème, ou communiquaient de manière peu claire, ou ne pouvaient pas traduire leurs idées en code, ou occupaient un poste qui ne conduirait tout simplement pas son succès à long terme, etc. La définition de «vaut la peine d'être embauchée» est vague et varie selon l'entreprise, et le processus d'entrevue consiste à déterminer si chaque candidat répond aux exigences d'une entreprise particulière. <br><br>  J'ai lu beaucoup de commentaires reddit se plaignant de questions d'entrevue trop complexes.  J'étais curieux de savoir s'il était encore possible de faire une recommandation digne / indigne pour une tâche plus simple.  Je soupçonnais que cela donnerait un signal utile sans crier inutilement les nerfs du candidat.  Je vais vous parler de mes conclusions à la fin de l'article ... <br><br>  Avec ces pensées, je cherchais une nouvelle question.  Dans un monde idéal, c'est une question assez simple à résoudre en 45 minutes, mais avec des questions supplémentaires pour que les candidats les plus puissants montrent leurs compétences.  Il devrait également être compact dans la mise en œuvre, car de nombreux candidats écrivent toujours au tableau.  Un gros plus si le sujet est en quelque sorte lié aux produits Google. <br><br>  Enfin, je me suis installé sur une question qu'un merveilleux googleur a soigneusement décrite et insérée dans notre base de données de questions.  Maintenant, j'ai consulté d'anciens collègues et je me suis assuré que la question était toujours interdite, donc vous ne serez certainement pas posé lors de l'entretien.  Je le présente sous la forme dans laquelle il me semble le plus efficace, avec des excuses à l'auteur original. <br><br><h2>  Question </h2><br>  Parlez de mesurer les distances.  <i>La main</i> est une unité de mesure de quatre pouces couramment utilisée dans les pays anglophones pour mesurer la hauteur des chevaux.  <i>Une année-lumière</i> est une autre unité de mesure égale à la distance parcourue par une particule (ou une onde?) De lumière en un certain nombre de secondes, approximativement égal à une année terrestre.  À première vue, ils ont peu en commun les uns avec les autres, sauf qu'ils sont utilisés pour mesurer la distance.  Mais il s'avère que Google peut les convertir assez facilement: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Cela peut sembler évident: au final, ils mesurent tous deux la distance, il est donc clair qu'il y a une transformation.  Mais si vous y réfléchissez, c'est un peu étrange: comment ont-ils calculé ce taux de conversion?  De toute évidence, personne n'a vraiment compté le nombre de mains dans une année-lumière.  En fait, vous n'avez pas besoin de prendre cela directement.  Vous pouvez simplement utiliser des conversions bien connues: <br><br><ul><li>  <i>1 main</i> = <i>4 pouces</i> <br></li><li>  <i>4 pouces</i> = <i>0,33333 pied</i> <br></li><li>  <i>0,33333 pi</i> = <i>6,3125e - 5 milles</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 années-lumière</i> </li></ul><br>  Le but de la tâche est de développer un système qui effectuera cette transformation.  En particulier: <br><br><blockquote>  À l'entrée, vous avez une liste de facteurs de conversion (formatés dans la langue de votre choix) sous la forme d'un ensemble d'unités de mesure initiales, d'unités finales et de facteurs, par exemple: <br><br><pre>  ft 12
 cour de pied 0.3333333
 etc. </pre><br>  Pour que ORIGINE * MULTIPLICATEUR = DESTINATION.  Développez un algorithme qui prend deux valeurs unitaires arbitraires et renvoie le facteur de conversion entre elles. </blockquote><br><h2>  La discussion </h2><br>  J'aime ce problème car il a une réponse intuitive et évidente: il suffit de convertir d'une unité à une autre, puis à la suivante, jusqu'à ce que vous trouviez la cible!  Je ne me souviens pas d'un seul candidat qui a rencontré ce problème et a été complètement perplexe sur la façon de le résoudre.  Cela correspond bien à l'exigence d'un problème «plus simple», car les précédents nécessitaient généralement une longue étude et une réflexion avant de trouver au moins une approche de base de la solution. <br><br>  Néanmoins, de nombreux candidats n'ont pas réussi à réaliser leur intuition comme une solution de travail sans conseils évidents.  L'un des avantages de cette question est qu'elle teste la capacité du candidat à formuler le problème (à faire un cadrage) afin qu'il se prête à l'analyse et au codage.  Comme nous le verrons, il y a ici une extension très intéressante qui nécessite un nouveau saut conceptuel. <br><br>  Pour le contexte, le cadrage est l'acte de traduire un problème avec une solution non évidente en un problème équivalent, où la solution est déduite de manière naturelle.  Si cela semble complètement abstrait et imprenable, je suis désolé, mais ça l'est.  J'expliquerai ce que je veux dire lorsque je présenterai la solution initiale à ce problème.  La première partie de la solution sera un exercice de développement et d'application des connaissances algorithmiques.  La deuxième partie sera un exercice de manipulation de ces connaissances afin d'arriver à une optimisation nouvelle et non évidente. <br><br><h2>  Partie 0. Intuition </h2><br>  Avant de creuser plus profondément, explorons à fond la solution «évidente».  La plupart des conversions requises sont simples et directes.  Tout Américain qui a voyagé en dehors des États-Unis sait que la plupart du monde utilise la mystérieuse unité «kilomètre» pour mesurer les distances.  Pour convertir, il vous suffit de multiplier le nombre de miles par environ 1,6. <br><br>  Nous avons rencontré de telles choses pour la plupart de nos vies.  Pour la plupart des unités, il existe déjà une conversion pré-calculée, il vous suffit donc de la consulter dans le tableau correspondant.  Mais s'il n'y a pas de conversion directe (par exemple, des mains aux années-lumière), il est logique de construire un chemin de conversion, comme indiqué ci-dessus: <br><br><ul><li>  <i>1 main</i> = <i>4 pouces</i> <br></li><li>  <i>4 pouces</i> = <i>0,33333 pied</i> <br></li><li>  <i>0,33333 pi</i> = <i>6,3125e - 5 milles</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 années-lumière</i> </li></ul><br>  C'était très simple, je viens de proposer une telle transformation en utilisant mon imagination et une table de transformation standard!  Cependant, certaines questions demeurent.  Y a-t-il un moyen plus court?  Quelle est la précision du coefficient?  La conversion est-elle toujours possible?  Est-il possible de l'automatiser?  Malheureusement, ici l'approche naïve échoue. <br><br><h2>  Partie 1. Décision naïve </h2><br>  C'est bien que le problème ait une solution intuitive, mais en fait, cette simplicité est un obstacle à la résolution du problème.  Il n'y a rien de plus difficile que d'essayer de comprendre d'une manière nouvelle ce que vous comprenez déjà - notamment parce que vous en savez souvent moins que vous ne le pensez.  Pour illustrer, imaginez que vous êtes venu pour un entretien - et que vous avez cette méthode intuitive en tête.  Mais il ne permet pas de résoudre un certain nombre de problèmes importants. <br><br>  Par exemple, que faire s'il <i>n'y a pas de conversion</i> ?  L'approche évidente ne dit rien, est-il vraiment possible de passer d'une unité à une autre.  S'ils me donnent mille taux de conversion, il sera très difficile pour moi de déterminer si c'est possible en principe.  Si on me demande de faire une conversion entre des unités inconnues (ou inventées) d'un <i>pointeur</i> et d'un <i>jab</i> , alors je n'ai aucune idée par où commencer.  Comment une approche intuitive aide-t-elle ici? <br><br>  Je dois admettre que c'est une sorte de scénario artificiel, mais il y en a aussi un plus réaliste.  Vous voyez que mon énoncé du problème ne comprend que des unités de distance.  Cela se fait exprès.  Et si je demande au système de convertir des pouces en kilogrammes?  Vous et moi savons que ce n'est pas possible car ils mesurent différents types, mais l'entrée ne dit rien sur le «type» que chaque unité mesure. <br><br>  C'est ici qu'une formulation soigneuse de la question permet aux candidats forts de faire leurs preuves.  <i>Avant de</i> développer l'algorithme, ils réfléchissent aux cas extrêmes du système.  Et une telle déclaration du problème leur donne délibérément l'occasion de me demander si nous allons traduire différentes unités.  Ce n'est pas un problème si énorme s'il se produit à un stade précoce, mais c'est toujours un bon signe lorsque quelqu'un me demande à l'avance: «Que devrait retourner le programme si la conversion n'est pas possible?»  Poser la question de cette façon me donne une idée des capacités du candidat avant qu'il n'écrive au moins une ligne de code. <br><br>  <i>Vue graphique</i> <br><br>  De toute évidence, l'approche naïve ne convient pas, nous devons donc réfléchir à la façon de faire une telle conversion?  La réponse est de considérer les unités comme un graphique.  Il s'agit du premier pas de compréhension nécessaire pour résoudre ce problème. <br><br>  En particulier, imaginez que chaque unité est un nœud dans un graphique, et qu'il y a un bord du nœud <code>A</code> au nœud <code>B</code> si <code>A</code> peut être converti en <code>B</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Les bords sont étiquetés avec un taux de conversion par lequel vous devez multiplier <code>A</code> pour obtenir <code>B</code> <br><br>  Je m'attendais presque toujours à ce que le candidat propose un tel cadrage et lui donnais rarement de sérieux indices.  Je peux pardonner au candidat qui ne remarque pas la solution au problème de l'utilisation d'ensembles disjoints ou qui n'est pas trop familier avec l'algèbre linéaire pour réaliser une solution qui se réduit à re-rehausser la puissance de la matrice d'adjacence, mais les graphiques sont enseignés dans n'importe quel programme ou cours de programmation.  Si le candidat n'a pas les connaissances appropriées, il s'agit d'un signal «pas d'embauche». <br><br>  <i>Bref</i> <br><br>  Une représentation graphique réduit la solution au problème classique de recherche graphique.  En particulier, deux algorithmes sont utiles ici: la recherche large (BFS) et la recherche approfondie (DFS).  Lors de la recherche en largeur, nous examinons les nœuds en fonction de leur distance par rapport à l'origine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Les bleus plus foncés signifient les générations futures</font></i> <br><br>  Et lors d'une recherche approfondie, nous examinons les nœuds dans l'ordre dans lequel ils se produisent: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Les bleus plus foncés signifient également les générations futures.</font></i>  <i><font color="gray">Veuillez noter que nous ne visitons pas réellement tous les sites</font></i> <br><br>  N'importe lequel des algorithmes détermine facilement s'il y a une conversion d'une unité à une autre, il suffit de rechercher simplement le graphique.  Nous partons de l'unité source et recherchons jusqu'à ce que nous trouvions l'unité de destination.  Si vous ne trouvez pas votre destination (comme si vous tentiez de convertir des pouces en kilogrammes), nous savons qu'il n'y a aucun moyen. <br><br>  Mais attendez, il manque quelque chose.  Nous ne voulons pas chercher un moyen, nous voulons trouver un taux de conversion!  C'est là que le candidat doit faire le saut: il s'avère que vous pouvez modifier n'importe quel algorithme de recherche pour calculer le taux de conversion en enregistrant simplement l'état supplémentaire au fur et à mesure de votre progression.  C'est là que les illustrations n'ont plus de sens, alors plongeons-nous dans le code. <br><br>  Tout d'abord, vous devez déterminer la structure des données du graphique, nous utilisons donc ceci: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Commençons ensuite avec DFS.  Il existe de nombreuses façons de le mettre en œuvre, mais de loin la plus courante est une solution récursive.  Commençons par ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  En un mot, cet algorithme commence par un nœud, itère sur ses voisins et visite immédiatement chacun, faisant un appel récursif à la fonction.  Chaque appel de fonction sur la pile enregistre l'état de sa propre itération, donc lorsqu'une visite récursive est retournée, son parent continue immédiatement l'itération.  Nous évitons de visiter à nouveau le même site en maintenant un ensemble de sites visités dans tous les appels.  Nous calculons également le coefficient en attribuant un facteur de conversion entre chaque nœud et la source.  Ainsi, lorsque nous rencontrons le nœud / bloc cible, nous avons déjà créé le coefficient de conversion à partir du nœud source, et nous pouvons simplement le renvoyer. <br><br>  Il s'agit d'une excellente mise en œuvre, mais elle souffre de deux défauts principaux.  Premièrement, il est récursif.  S'il s'avère que le chemin souhaité consiste en plus d'un millier de sauts, nous volerons avec un petit problème.  Bien sûr, cela est peu probable, mais s'il y a quelque chose d'inacceptable pour un service à long terme, c'est un échec.  Deuxièmement, même si nous réussissons, la réponse a certaines propriétés indésirables. <br><br>  En fait, j'ai déjà donné un indice au début du message.  Avez-vous remarqué comment Google affiche le taux de conversion de <code>1.0739e-17</code> , mais mon calcul manuel donne <code>1.0737e-17</code> ?  Il s'avère que toutes ces multiplications en virgule flottante font déjà penser à la propagation de l'erreur.  Il y a trop de nuances pour cet article, mais l'essentiel est que vous devez minimiser la multiplication en virgule flottante pour éviter les erreurs qui s'accumulent et causent des problèmes. <br><br>  DFS est un excellent algorithme de recherche.  Si une solution existe, elle la trouvera.  Mais il lui manque une propriété clé: il ne trouve pas forcément le chemin le plus court.  Ceci est important pour nous car un chemin plus court signifie moins de sauts et moins d'erreur en raison des multiplications en virgule flottante.  Pour résoudre le problème, nous nous tournons vers BFS. <br><br><h2>  Partie 2. Solution BFS </h2><br>  À ce stade, si un candidat met en œuvre avec succès une solution DFS récursive et s'arrête dessus, je donne généralement au moins une faible recommandation sur l'embauche de ce candidat.  Il a compris le problème, a choisi le cadrage approprié et a mis en œuvre une solution de travail.  C'est une décision naïve, donc je n'insiste pas pour l'embaucher, mais s'il a bien fait avec d'autres interviews, je ne recommanderai pas de refuser. <br><br>  Cela vaut la peine d'être répété: en cas de doute, écrivez une solution naïve!  Même si elle n'est pas complètement optimale, la présence de code sur la carte est déjà une réussite, et souvent la bonne solution peut être trouvée sur sa base.  Je dirai différemment: ne travaillez jamais pour rien.  Très probablement, vous avez pensé à une solution naïve, mais vous ne vouliez pas l'offrir, car vous savez qu'elle n'est pas optimale.  Si vous êtes prêt à proposer la meilleure solution dès maintenant, c'est bien, mais sinon, enregistrez les progrès réalisés avant de passer à des choses plus complexes. <br><br>  A partir de maintenant, parlons des améliorations de l'algorithme.  Les principaux inconvénients d'une solution DFS récursive sont qu'elle est récursive et ne minimise pas le nombre de multiplications.  Comme nous le verrons bientôt, BFS minimise le nombre de multiplications, et il est également très difficile de l'implémenter récursivement.  Malheureusement, nous devrons abandonner la solution récursive DFA, car pour l'améliorer, nous devrons réécrire complètement le code. <br><br>  Sans plus tarder, je présente une approche itérative basée sur BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Cette implémentation est fonctionnellement très différente de la précédente, mais si vous regardez de près, elle fait à peu près la même chose, avec un changement significatif: tandis que le DFS récursif enregistre l'état de la route supplémentaire dans la pile d'appels, mettant en œuvre efficacement la pile LIFO, la solution itérative le stocke dans la file d'attente FIFO <br><br>  Cela implique la propriété «chemin le plus court / moins de multiplications».  Nous visitons les nœuds dans l'ordre dans lequel ils se produisent et nous obtenons ainsi des générations de nœuds.  Le premier nœud insère ses voisins, puis nous visitons ces voisins dans l'ordre, en collant leurs voisins tout le temps et ainsi de suite.  La propriété de chemin le plus court découle du fait que les nœuds sont visités dans l'ordre de leur distance à la source.  Par conséquent, lorsque nous rencontrons une destination, nous savons qu'aucune génération antérieure ne pourrait y conduire. <br><br>  En ce moment, nous avons <i>presque</i> terminé.  Vous devez d'abord répondre à quelques questions, et ils sont obligés de revenir à la formulation originale du problème. <br><br>  Premièrement, la chose la plus triviale à faire si l'unité d'origine n'existe pas?  Autrement dit, nous ne pouvons pas trouver le nœud avec le nom donné.  En pratique, vous devez effectuer une certaine normalisation des chaînes de sorte que le livre, le livre et lb pointent vers le même nœud «livre» (ou une autre représentation canonique), mais cela dépasse le cadre de notre question. <br><br>  Deuxièmement, que se passe-t-il s'il n'y a pas de conversion entre les deux unités?  Rappelons que dans les données initiales, il n'y a que des conversions entre les unités, et cela ne donne aucune indication sur la possibilité d'en obtenir une autre à partir d'une unité particulière.  Cela se résume au fait que les transformations et les chemins sont directement équivalents, donc s'il n'y a pas de chemin entre deux nœuds, alors il n'y a pas de transformation.  En pratique, vous vous retrouvez avec des îlots d'unités sans rapport: un pour les distances, un pour les poids, un pour les devises, etc. <br><br>  Enfin, si vous regardez attentivement le graphique ci-dessus, il s'avère que vous ne pouvez pas convertir entre les mains et les années-lumière avec cette solution.  La direction des connexions entre les nœuds signifie qu'il n'y a aucun moyen de passer de la main aux années-lumière.  Cependant, cela est assez facile à corriger, car les transformations peuvent être inversées.  Nous pouvons changer notre code d'initialisation de graphique comme suit: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Partie 3. Évaluation </h2><br>  C'est fait!  Si le candidat a atteint ce point, je le recommanderai très probablement à l'embauche.  Si vous avez étudié l'informatique ou suivi un cours d'algorithmique, vous pouvez demander: «Est-ce vraiment suffisant pour obtenir un entretien avec ce type?», Auquel je répondrai: «Essentiellement, oui.» <br><br>  Avant de décider que la question est trop simple, regardons ce qu'un candidat doit faire pour atteindre ce point: <br><br><ul><li>  Comprendre la question <br></li><li>  Construire un réseau de transformations sous forme de graphe <br></li><li>  Comprendre que les coefficients peuvent être comparés avec les bords du graphique <br></li><li>  Voir la possibilité d'utiliser des algorithmes de recherche pour y parvenir. <br></li><li>  Choisissez votre algorithme préféré et modifiez-le pour suivre les cotes <br></li><li>  S'il a implémenté DFS comme une solution naïve, reconnaissez ses faiblesses. <br></li><li>  Implémenter BFS <br></li><li>  Pour prendre du recul et étudier les cas extrêmes: <br><ul><li>  Et si on nous interroge sur un nœud qui n'existe pas? <br></li><li>  Et si le facteur de conversion n'existe pas? </li></ul></li><li>  Reconnaître que des transformations inverses sont possibles et probablement nécessaires </li></ul><br>  Cette question est plus facile que les précédentes, mais elle est également difficile.  Comme dans toutes les questions précédentes, le candidat doit faire un saut mental d'une question formulée de manière abstraite à un algorithme ou une structure de données qui ouvre la voie à une solution.  La seule chose est que l'algorithme final est moins avancé que dans d'autres problèmes.  En dehors de ce matériel algorithmique, les mêmes exigences s'appliquent, en particulier en ce qui concerne les cas extrêmes et l'exactitude. <br><br>  "Mais attendez!" Vous pouvez demander.  - Google n'est-il pas obsédé par la complexité d'exécution?  Vous ne vous êtes même pas interrogé sur la complexité temporelle ou spatiale de ce problème.  Oh bien! "  Vous pouvez également demander: «Attendez une minute, vous avez donné la note« fortement recommandé pour la location »?  Comment l'obtenir? "  Très bonnes questions, les deux.  Cela nous amène à notre dernier tour de bonus supplémentaire ... <br><br><h2>  Partie 4. Est-il possible de faire mieux? </h2><br>  À ce stade, je tiens à féliciter le candidat pour sa bonne réponse et à préciser que tout ce qui précède n'est qu'un bonus.  Lorsque la pression disparaît, nous pouvons commencer à créer. <br><br>  Quelle est donc la difficulté d'exécuter BFS?  Dans le pire des cas, nous devons considérer chaque nœud et bord individuel, ce qui donne une complexité linéaire <code>O(N+E)</code> .  Ceci s'ajoute à la même complexité de construction graphique <code>O(N+E)</code> .  Pour un moteur de recherche, c'est probablement bon: un millier d'unités de mesure est suffisant pour la plupart des applications raisonnables, et faire une recherche de mémoire pour chaque requête n'est pas une surcharge. <br><br>  Cependant, on peut faire mieux.  Pour motiver, considérez comment ce code est inséré dans la chaîne de recherche.  Les conversions de certaines unités non standard sont un peu plus courantes, nous les calculerons donc encore et encore.  Chaque fois qu'une recherche est effectuée, des valeurs intermédiaires sont calculées, etc. <br><br>  Il est souvent suggéré de simplement mettre en cache les résultats des calculs.  Chaque fois qu'une conversion d'unité est calculée, nous pouvons toujours simplement ajouter un bord entre les deux conversions.  En bonus, nous obtenons la transformation inverse, et gratuitement!  Vous avez terminé? <br><br>  En effet, cela nous donnera un temps de recherche asymptotiquement constant, mais cela coûtera le stockage d'arêtes supplémentaires.  Cela devient en fait assez cher: au fil du temps, nous nous efforcerons d'obtenir un graphique complet, car toutes les paires de transformations sont progressivement calculées et stockées.  Le nombre d'arêtes possibles dans le graphique est la moitié du carré du nombre de nœuds, donc pour mille nœuds, nous avons besoin d'un demi-million d'arêtes.  Pour dix mille nœuds, environ cinquante millions, etc. <br><br>  Allant au-delà de la portée du moteur de recherche, pour un graphique d'un million de nœuds, nous nous efforçons d'atteindre un demi-billion de bords.  Ce montant est tout simplement déraisonnable à stocker, et nous passons du temps à insérer des bords dans le graphique.  Nous devons faire mieux. <br><br>  Heureusement, il existe un moyen d'atteindre un temps constant pour rechercher des coefficients, sans croissance d'espace quadratique.  En fait, presque tout ce dont nous avons besoin est juste sous notre nez. <br><br><h2>  Partie 4. Temps constant </h2><br>  Ainsi, la mise en cache totale est en fait proche de la solution optimale.  Dans cette approche, nous obtenons (finalement) des arêtes entre tous les nœuds, c'est-à-dire que notre transformation est réduite à trouver une arête.  Mais est-il vraiment nécessaire de stocker les conversions de chaque nœud à chaque nœud?  Et si nous enregistrions simplement les facteurs de conversion d' <i>un</i> nœud à tous les autres? <br><br>  Jetez un autre regard sur la solution BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Voyons ce qui se passe ici: nous partons du nœud source, et pour chaque nœud que nous rencontrons, nous calculons le coefficient de conversion de la source à ce nœud.  Ensuite, dès que nous arrivons à destination, nous retournons le coefficient entre les points de départ et d'arrivée et rejetons les coefficients intermédiaires. <br><br>  Ces ratios intermédiaires sont essentiels.  Mais que se passe-t-il si nous ne les jetons pas?  Et si nous les écrivions à la place?  Toutes les recherches les plus complexes et incompréhensibles deviennent simples: pour trouver le rapport de A sur B, trouvez d'abord le rapport de X sur B, puis divisez-le par le rapport de X sur A, et vous avez terminé!  Visuellement, cela ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Notez qu'entre deux nœuds au maximum deux arêtes</font></i> <br><br>  Il s'avère que pour calculer ce tableau, nous n'avons presque pas besoin de changer la solution BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  La structure de transformation est représentée par un dictionnaire de l'unité A en deux valeurs: la racine de la composante associée de l'unité A et le coefficient de conversion entre l'unité racine et l'unité A. Puisque nous insérons une unité dans ce dictionnaire à chaque visite, nous pouvons utiliser l'espace clé de ce dictionnaire comme un ensemble de visites au lieu d'utiliser un ensemble de visites dédiées.  Notez que nous n'avons pas de nœud final et que nous parcourons plutôt les nœuds jusqu'à ce que nous ayons terminé. <br><br>  En dehors de ce BFS, il existe une fonction d'assistance qui itère sur les nœuds d'un graphique.  Chaque fois qu'il rencontre un nœud en dehors du dictionnaire de traduction, il démarre BFS à partir de ce nœud.  ,         . <br><br>      ,     ,    : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br>  «  »        .  «  »     :     , ,       BFS,        ,        . ,   . <br><br>  !        <code>O(V+E)</code> ( ,    ),       . ,     ,  ó        ,          .        ,   :   <code>O(V+E)</code> ,        ,      <code>O(V)</code> ,       . <br><br><h2>  Résultats </h2><br>     ,   ,        ,  ,      -              .     -   ,         .   ,     . <br><br>         ( ,  , ,     ),          « ».    ,     :     ,       ,    . <br><br>     .   ,         ,    ,      .   —              .              , ,       Google (  ,    ,    ). <br><br>   ,        . ,    ,       . ,    ,          , ,  -   ,    . <br><br>   .          DFS, ,     ,      .   ,   BFS  DFS, ,    ,          . <br><br>    ,    ,      «»,        .       ,        ,    .       .      ,         .  :   ,  « »  . <br><br><h2>  ,    ! </h2><br>  ,    ,        ,     ,      .     : <br><br> -, :     ,   ,        .  ,     ,    .   ,         - ,  -               .     ,       ,            . <br><br> -,    ,        ,    .       —  :  —  ,    A  B   —    /   .            :  , ,    ,    ,     ,   .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, un vrai bijou: certaines unités sont exprimées comme une combinaison de différentes unités de base. Par exemple, un watt est défini dans le système SI comme kg • m² / s³. La dernière tâche consiste à étendre ce système pour prendre en charge la conversion entre ces unités, en ne prenant en compte que les définitions des unités SI de base. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez des questions, n'hésitez pas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à me contacter sur reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusion </h2><br>        ,  ,      .      :     ,      ,       ,        . ,   ,  ,   ,     :            ,        .   ,      ,  ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espère que cet article vous a été utile. </font><font style="vertical-align: inherit;">Je comprends qu'il peut ne pas y avoir autant d'aventures avec des algorithmes que dans certains articles précédents. </font><font style="vertical-align: inherit;">Lors des entretiens avec les développeurs, il est habituel de discuter abondamment des algorithmes. </font><font style="vertical-align: inherit;">Mais la vérité est que d'importantes difficultés surviennent lors de l'utilisation même d'une méthode simple et bien connue. </font><font style="vertical-align: inherit;">Tout le code est dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">référentiel de cette série d'articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467371/">https://habr.com/ru/post/fr467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467359/index.html">PVS-Studio passe aux nuages: Azure DevOps</a></li>
<li><a href="../fr467361/index.html">Nous avons oublié la délégation en JavaScript. Délégation d'événement en réaction</a></li>
<li><a href="../fr467363/index.html">Utilisation de fonctions de perte personnalisées et apprentissage des métriques de qualité dans Keras</a></li>
<li><a href="../fr467365/index.html">Relais de surveillance de tension résidentiels</a></li>
<li><a href="../fr467369/index.html">RubyRussia 2019. Mikhail Pronyakin: Ruby est-il sûr?</a></li>
<li><a href="../fr467375/index.html">Gestion de l'expérience client - qu'est-ce que c'est?</a></li>
<li><a href="../fr467377/index.html">Trois d'affilée: les 10 meilleurs rapports de Mobius 2019 Piter</a></li>
<li><a href="../fr467381/index.html">LED à plusieurs étages, lumières intelligentes et ampoules pour 18 roubles</a></li>
<li><a href="../fr467383/index.html">«Le manager doit continuer à coder»: entretien avec Stephen Chin</a></li>
<li><a href="../fr467385/index.html">Une sélection de questions techniques psychologiques et atypiques issues d'entretiens avec des développeurs Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>