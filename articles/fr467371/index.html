<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÖ üí® üôáüèø Analyse des entretiens d'embauche Google: recherche de relations üî∂ üôÖüèΩ ü§¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bienvenue dans le prochain article d'une s√©rie d' √©nigmes que j'ai pos√©es lors d'entretiens avec Google avant leur interdiction apr√®s la fuite. Depuis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des entretiens d'embauche Google: recherche de relations</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Bienvenue dans le prochain article d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie d'</a> √©nigmes que j'ai pos√©es lors d'entretiens avec Google avant leur interdiction apr√®s la fuite.  Depuis lors, j'ai cess√© de travailler en tant qu'ing√©nieur logiciel chez Google et j'ai d√©m√©nag√© au poste de responsable du d√©veloppement chez Reddit, mais j'ai encore quelques bons sujets.  √Ä ce jour, nous avons examin√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la programmation dynamique</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©levant les matrices √† la puissance</a> et √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">synonymie des requ√™tes</a> .  Cette fois, une question compl√®tement nouvelle. <br><a name="habracut"></a><br>  Mais d'abord, deux points.  Tout d'abord, le travail chez Reddit √©tait g√©nial.  Au cours des huit derniers mois, j'ai construit et dirig√© la nouvelle √©quipe de pertinence des annonces et mis en place un nouveau bureau de d√©veloppement √† New York.  Peu importe √† quel point cela peut √™tre amusant, malheureusement, j'ai trouv√© que jusqu'√† r√©cemment, je n'avais plus de temps ni d'√©nergie pour un blog.  J'ai peur d'avoir un peu abandonn√© cette s√©rie.  D√©sol√© pour le retard. <br><br>  Deuxi√®mement, si vous avez suivi les articles, apr√®s le dernier num√©ro, vous pourriez penser que je commencerais √† creuser dans les options synonymiques des requ√™tes.  Bien que j'aimerais y revenir un jour, je dois admettre que j'ai perdu tout int√©r√™t pour ce probl√®me en raison d'un changement de travail et jusqu'√† pr√©sent, j'ai d√©cid√© de le reporter.  Restez en contact!  Je le dois et j'ai l'intention de le rendre.  Juste, tu sais, un peu plus tard ... <br><br>  <i>Avis de non-responsabilit√© rapide: Bien que l'entretien des candidats soit l'une de mes t√¢ches professionnelles, ce blog pr√©sente mes observations personnelles, mes histoires personnelles et mes opinions personnelles.</i>  <i>Veuillez ne pas prendre cela pour toute d√©claration officielle de Google, Alphabet, Reddit ou de toute autre personne ou organisation.</i> <br><br><h2>  Rechercher une nouvelle question </h2><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent,</a> j'ai d√©crit une de mes questions pr√©f√©r√©es que j'ai utilis√©e pendant longtemps, avant l'in√©vitable fuite.  Les questions pr√©c√©dentes √©taient fascinantes d'un point de vue th√©orique, mais je voulais choisir un probl√®me un peu plus pertinent pour Google en tant qu'entreprise.  Lorsque cette question a √©t√© interdite, j'ai voulu trouver un rempla√ßant, en tenant compte de la nouvelle restriction: rendre la question <i>plus simple</i> . <br><br>  Maintenant, cela peut sembler un peu surprenant compte tenu du tristement c√©l√®bre processus d'entrevue chez Google.  Mais √† cette √©poque, un probl√®me plus simple avait du sens.  Mon raisonnement comportait deux parties.  La premi√®re est pragmatique: les candidats ne r√©agissaient g√©n√©ralement pas tr√®s bien aux questions pr√©c√©dentes, malgr√© de nombreux indices et simplifications, et je ne savais pas toujours pourquoi.  La deuxi√®me th√©orie: le processus d'entrevue devrait diviser les candidats en cat√©gories ¬´m√©rite d'√™tre embauch√©¬ª et ¬´ne vaut pas la peine d'√™tre embauch√©¬ª, et j'√©tais curieux de savoir si cela pourrait √™tre fait un peu plus facilement avec la question. <br><br>  Avant de clarifier ces deux points, je veux souligner ce qu'ils <i>ne</i> signifient <i>pas</i> .  "Je ne sais pas toujours pourquoi une personne a des probl√®mes" ne signifie pas l'inutilit√© des questions et que je voulais simplifier l'entretien pour cette raison.  M√™me la question la plus difficile, beaucoup se sont bien d√©brouill√©es.  Je veux dire, quand les candidats avaient des probl√®mes, il √©tait difficile pour moi de comprendre ce qu'ils manquaient. <br><br>  De bons entretiens donnent une vue d'ensemble des forces et des faiblesses du candidat.  Il ne suffit pas que le comit√© de recrutement dise simplement qu'il a ¬´√©chou√©¬ª: le comit√© d√©termine si le candidat poss√®de les qualit√©s sp√©cifiques √† l'entreprise qu'il recherche.  De m√™me, les mots ¬´il est cool¬ª n'aident pas le comit√© √† choisir un candidat fort dans certains domaines, mais douteux dans d'autres.  J'ai constat√© que des questions plus complexes s√©parent trop souvent les candidats en ces deux cat√©gories.  Dans cette optique, ¬´je ne sais pas toujours pourquoi une personne a des probl√®mes¬ª signifie ¬´l‚Äôincapacit√© de progresser sur cette question ne donne pas en soi une image des capacit√©s de ce candidat¬ª. <br><br>  La classification des candidats comme ¬´m√©rite d'√™tre embauch√©e¬ª et ¬´ne vaut pas la peine d'√™tre embauch√©e¬ª <i>ne</i> signifie <i>pas</i> que le processus d'entrevue devrait s√©parer les candidats stupides des candidats intelligents.  Je ne me souviens pas d'un seul candidat qui n'√©tait pas intelligent, talentueux et motiv√©.  Beaucoup venaient d'excellentes universit√©s et les autres √©taient clairement extr√™mement motiv√©s.  Passer des entretiens t√©l√©phoniques est d√©j√† un bon tamis, et m√™me refuser √† ce stade n'est pas un signe de manque de capacit√©. <br><br>  Cependant, je me souviens de beaucoup de personnes qui n'√©taient pas suffisamment pr√©par√©es pour l'entretien ou qui travaillaient trop lentement, ou n√©cessitaient trop de supervision pour r√©soudre le probl√®me, ou communiquaient de mani√®re peu claire, ou ne pouvaient pas traduire leurs id√©es en code, ou occupaient un poste qui ne conduirait tout simplement pas son succ√®s √† long terme, etc. La d√©finition de ¬´vaut la peine d'√™tre embauch√©e¬ª est vague et varie selon l'entreprise, et le processus d'entrevue consiste √† d√©terminer si chaque candidat r√©pond aux exigences d'une entreprise particuli√®re. <br><br>  J'ai lu beaucoup de commentaires reddit se plaignant de questions d'entrevue trop complexes.  J'√©tais curieux de savoir s'il √©tait encore possible de faire une recommandation digne / indigne pour une t√¢che plus simple.  Je soup√ßonnais que cela donnerait un signal utile sans crier inutilement les nerfs du candidat.  Je vais vous parler de mes conclusions √† la fin de l'article ... <br><br>  Avec ces pens√©es, je cherchais une nouvelle question.  Dans un monde id√©al, c'est une question assez simple √† r√©soudre en 45 minutes, mais avec des questions suppl√©mentaires pour que les candidats les plus puissants montrent leurs comp√©tences.  Il devrait √©galement √™tre compact dans la mise en ≈ìuvre, car de nombreux candidats √©crivent toujours au tableau.  Un gros plus si le sujet est en quelque sorte li√© aux produits Google. <br><br>  Enfin, je me suis install√© sur une question qu'un merveilleux googleur a soigneusement d√©crite et ins√©r√©e dans notre base de donn√©es de questions.  Maintenant, j'ai consult√© d'anciens coll√®gues et je me suis assur√© que la question √©tait toujours interdite, donc vous ne serez certainement pas pos√© lors de l'entretien.  Je le pr√©sente sous la forme dans laquelle il me semble le plus efficace, avec des excuses √† l'auteur original. <br><br><h2>  Question </h2><br>  Parlez de mesurer les distances.  <i>La main</i> est une unit√© de mesure de quatre pouces couramment utilis√©e dans les pays anglophones pour mesurer la hauteur des chevaux.  <i>Une ann√©e-lumi√®re</i> est une autre unit√© de mesure √©gale √† la distance parcourue par une particule (ou une onde?) De lumi√®re en un certain nombre de secondes, approximativement √©gal √† une ann√©e terrestre.  √Ä premi√®re vue, ils ont peu en commun les uns avec les autres, sauf qu'ils sont utilis√©s pour mesurer la distance.  Mais il s'av√®re que Google peut les convertir assez facilement: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Cela peut sembler √©vident: au final, ils mesurent tous deux la distance, il est donc clair qu'il y a une transformation.  Mais si vous y r√©fl√©chissez, c'est un peu √©trange: comment ont-ils calcul√© ce taux de conversion?  De toute √©vidence, personne n'a vraiment compt√© le nombre de mains dans une ann√©e-lumi√®re.  En fait, vous n'avez pas besoin de prendre cela directement.  Vous pouvez simplement utiliser des conversions bien connues: <br><br><ul><li>  <i>1 main</i> = <i>4 pouces</i> <br></li><li>  <i>4 pouces</i> = <i>0,33333 pied</i> <br></li><li>  <i>0,33333 pi</i> = <i>6,3125e - 5 milles</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 ann√©es-lumi√®re</i> </li></ul><br>  Le but de la t√¢che est de d√©velopper un syst√®me qui effectuera cette transformation.  En particulier: <br><br><blockquote>  √Ä l'entr√©e, vous avez une liste de facteurs de conversion (format√©s dans la langue de votre choix) sous la forme d'un ensemble d'unit√©s de mesure initiales, d'unit√©s finales et de facteurs, par exemple: <br><br><pre>  ft 12
 cour de pied 0.3333333
 etc. </pre><br>  Pour que ORIGINE * MULTIPLICATEUR = DESTINATION.  D√©veloppez un algorithme qui prend deux valeurs unitaires arbitraires et renvoie le facteur de conversion entre elles. </blockquote><br><h2>  La discussion </h2><br>  J'aime ce probl√®me car il a une r√©ponse intuitive et √©vidente: il suffit de convertir d'une unit√© √† une autre, puis √† la suivante, jusqu'√† ce que vous trouviez la cible!  Je ne me souviens pas d'un seul candidat qui a rencontr√© ce probl√®me et a √©t√© compl√®tement perplexe sur la fa√ßon de le r√©soudre.  Cela correspond bien √† l'exigence d'un probl√®me ¬´plus simple¬ª, car les pr√©c√©dents n√©cessitaient g√©n√©ralement une longue √©tude et une r√©flexion avant de trouver au moins une approche de base de la solution. <br><br>  N√©anmoins, de nombreux candidats n'ont pas r√©ussi √† r√©aliser leur intuition comme une solution de travail sans conseils √©vidents.  L'un des avantages de cette question est qu'elle teste la capacit√© du candidat √† formuler le probl√®me (√† faire un cadrage) afin qu'il se pr√™te √† l'analyse et au codage.  Comme nous le verrons, il y a ici une extension tr√®s int√©ressante qui n√©cessite un nouveau saut conceptuel. <br><br>  Pour le contexte, le cadrage est l'acte de traduire un probl√®me avec une solution non √©vidente en un probl√®me √©quivalent, o√π la solution est d√©duite de mani√®re naturelle.  Si cela semble compl√®tement abstrait et imprenable, je suis d√©sol√©, mais √ßa l'est.  J'expliquerai ce que je veux dire lorsque je pr√©senterai la solution initiale √† ce probl√®me.  La premi√®re partie de la solution sera un exercice de d√©veloppement et d'application des connaissances algorithmiques.  La deuxi√®me partie sera un exercice de manipulation de ces connaissances afin d'arriver √† une optimisation nouvelle et non √©vidente. <br><br><h2>  Partie 0. Intuition </h2><br>  Avant de creuser plus profond√©ment, explorons √† fond la solution ¬´√©vidente¬ª.  La plupart des conversions requises sont simples et directes.  Tout Am√©ricain qui a voyag√© en dehors des √âtats-Unis sait que la plupart du monde utilise la myst√©rieuse unit√© ¬´kilom√®tre¬ª pour mesurer les distances.  Pour convertir, il vous suffit de multiplier le nombre de miles par environ 1,6. <br><br>  Nous avons rencontr√© de telles choses pour la plupart de nos vies.  Pour la plupart des unit√©s, il existe d√©j√† une conversion pr√©-calcul√©e, il vous suffit donc de la consulter dans le tableau correspondant.  Mais s'il n'y a pas de conversion directe (par exemple, des mains aux ann√©es-lumi√®re), il est logique de construire un chemin de conversion, comme indiqu√© ci-dessus: <br><br><ul><li>  <i>1 main</i> = <i>4 pouces</i> <br></li><li>  <i>4 pouces</i> = <i>0,33333 pied</i> <br></li><li>  <i>0,33333 pi</i> = <i>6,3125e - 5 milles</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 ann√©es-lumi√®re</i> </li></ul><br>  C'√©tait tr√®s simple, je viens de proposer une telle transformation en utilisant mon imagination et une table de transformation standard!  Cependant, certaines questions demeurent.  Y a-t-il un moyen plus court?  Quelle est la pr√©cision du coefficient?  La conversion est-elle toujours possible?  Est-il possible de l'automatiser?  Malheureusement, ici l'approche na√Øve √©choue. <br><br><h2>  Partie 1. D√©cision na√Øve </h2><br>  C'est bien que le probl√®me ait une solution intuitive, mais en fait, cette simplicit√© est un obstacle √† la r√©solution du probl√®me.  Il n'y a rien de plus difficile que d'essayer de comprendre d'une mani√®re nouvelle ce que vous comprenez d√©j√† - notamment parce que vous en savez souvent moins que vous ne le pensez.  Pour illustrer, imaginez que vous √™tes venu pour un entretien - et que vous avez cette m√©thode intuitive en t√™te.  Mais il ne permet pas de r√©soudre un certain nombre de probl√®mes importants. <br><br>  Par exemple, que faire s'il <i>n'y a pas de conversion</i> ?  L'approche √©vidente ne dit rien, est-il vraiment possible de passer d'une unit√© √† une autre.  S'ils me donnent mille taux de conversion, il sera tr√®s difficile pour moi de d√©terminer si c'est possible en principe.  Si on me demande de faire une conversion entre des unit√©s inconnues (ou invent√©es) d'un <i>pointeur</i> et d'un <i>jab</i> , alors je n'ai aucune id√©e par o√π commencer.  Comment une approche intuitive aide-t-elle ici? <br><br>  Je dois admettre que c'est une sorte de sc√©nario artificiel, mais il y en a aussi un plus r√©aliste.  Vous voyez que mon √©nonc√© du probl√®me ne comprend que des unit√©s de distance.  Cela se fait expr√®s.  Et si je demande au syst√®me de convertir des pouces en kilogrammes?  Vous et moi savons que ce n'est pas possible car ils mesurent diff√©rents types, mais l'entr√©e ne dit rien sur le ¬´type¬ª que chaque unit√© mesure. <br><br>  C'est ici qu'une formulation soigneuse de la question permet aux candidats forts de faire leurs preuves.  <i>Avant de</i> d√©velopper l'algorithme, ils r√©fl√©chissent aux cas extr√™mes du syst√®me.  Et une telle d√©claration du probl√®me leur donne d√©lib√©r√©ment l'occasion de me demander si nous allons traduire diff√©rentes unit√©s.  Ce n'est pas un probl√®me si √©norme s'il se produit √† un stade pr√©coce, mais c'est toujours un bon signe lorsque quelqu'un me demande √† l'avance: ¬´Que devrait retourner le programme si la conversion n'est pas possible?¬ª  Poser la question de cette fa√ßon me donne une id√©e des capacit√©s du candidat avant qu'il n'√©crive au moins une ligne de code. <br><br>  <i>Vue graphique</i> <br><br>  De toute √©vidence, l'approche na√Øve ne convient pas, nous devons donc r√©fl√©chir √† la fa√ßon de faire une telle conversion?  La r√©ponse est de consid√©rer les unit√©s comme un graphique.  Il s'agit du premier pas de compr√©hension n√©cessaire pour r√©soudre ce probl√®me. <br><br>  En particulier, imaginez que chaque unit√© est un n≈ìud dans un graphique, et qu'il y a un bord du n≈ìud <code>A</code> au n≈ìud <code>B</code> si <code>A</code> peut √™tre converti en <code>B</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Les bords sont √©tiquet√©s avec un taux de conversion par lequel vous devez multiplier <code>A</code> pour obtenir <code>B</code> <br><br>  Je m'attendais presque toujours √† ce que le candidat propose un tel cadrage et lui donnais rarement de s√©rieux indices.  Je peux pardonner au candidat qui ne remarque pas la solution au probl√®me de l'utilisation d'ensembles disjoints ou qui n'est pas trop familier avec l'alg√®bre lin√©aire pour r√©aliser une solution qui se r√©duit √† re-rehausser la puissance de la matrice d'adjacence, mais les graphiques sont enseign√©s dans n'importe quel programme ou cours de programmation.  Si le candidat n'a pas les connaissances appropri√©es, il s'agit d'un signal ¬´pas d'embauche¬ª. <br><br>  <i>Bref</i> <br><br>  Une repr√©sentation graphique r√©duit la solution au probl√®me classique de recherche graphique.  En particulier, deux algorithmes sont utiles ici: la recherche large (BFS) et la recherche approfondie (DFS).  Lors de la recherche en largeur, nous examinons les n≈ìuds en fonction de leur distance par rapport √† l'origine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Les bleus plus fonc√©s signifient les g√©n√©rations futures</font></i> <br><br>  Et lors d'une recherche approfondie, nous examinons les n≈ìuds dans l'ordre dans lequel ils se produisent: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Les bleus plus fonc√©s signifient √©galement les g√©n√©rations futures.</font></i>  <i><font color="gray">Veuillez noter que nous ne visitons pas r√©ellement tous les sites</font></i> <br><br>  N'importe lequel des algorithmes d√©termine facilement s'il y a une conversion d'une unit√© √† une autre, il suffit de rechercher simplement le graphique.  Nous partons de l'unit√© source et recherchons jusqu'√† ce que nous trouvions l'unit√© de destination.  Si vous ne trouvez pas votre destination (comme si vous tentiez de convertir des pouces en kilogrammes), nous savons qu'il n'y a aucun moyen. <br><br>  Mais attendez, il manque quelque chose.  Nous ne voulons pas chercher un moyen, nous voulons trouver un taux de conversion!  C'est l√† que le candidat doit faire le saut: il s'av√®re que vous pouvez modifier n'importe quel algorithme de recherche pour calculer le taux de conversion en enregistrant simplement l'√©tat suppl√©mentaire au fur et √† mesure de votre progression.  C'est l√† que les illustrations n'ont plus de sens, alors plongeons-nous dans le code. <br><br>  Tout d'abord, vous devez d√©terminer la structure des donn√©es du graphique, nous utilisons donc ceci: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Commen√ßons ensuite avec DFS.  Il existe de nombreuses fa√ßons de le mettre en ≈ìuvre, mais de loin la plus courante est une solution r√©cursive.  Commen√ßons par ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  En un mot, cet algorithme commence par un n≈ìud, it√®re sur ses voisins et visite imm√©diatement chacun, faisant un appel r√©cursif √† la fonction.  Chaque appel de fonction sur la pile enregistre l'√©tat de sa propre it√©ration, donc lorsqu'une visite r√©cursive est retourn√©e, son parent continue imm√©diatement l'it√©ration.  Nous √©vitons de visiter √† nouveau le m√™me site en maintenant un ensemble de sites visit√©s dans tous les appels.  Nous calculons √©galement le coefficient en attribuant un facteur de conversion entre chaque n≈ìud et la source.  Ainsi, lorsque nous rencontrons le n≈ìud / bloc cible, nous avons d√©j√† cr√©√© le coefficient de conversion √† partir du n≈ìud source, et nous pouvons simplement le renvoyer. <br><br>  Il s'agit d'une excellente mise en ≈ìuvre, mais elle souffre de deux d√©fauts principaux.  Premi√®rement, il est r√©cursif.  S'il s'av√®re que le chemin souhait√© consiste en plus d'un millier de sauts, nous volerons avec un petit probl√®me.  Bien s√ªr, cela est peu probable, mais s'il y a quelque chose d'inacceptable pour un service √† long terme, c'est un √©chec.  Deuxi√®mement, m√™me si nous r√©ussissons, la r√©ponse a certaines propri√©t√©s ind√©sirables. <br><br>  En fait, j'ai d√©j√† donn√© un indice au d√©but du message.  Avez-vous remarqu√© comment Google affiche le taux de conversion de <code>1.0739e-17</code> , mais mon calcul manuel donne <code>1.0737e-17</code> ?  Il s'av√®re que toutes ces multiplications en virgule flottante font d√©j√† penser √† la propagation de l'erreur.  Il y a trop de nuances pour cet article, mais l'essentiel est que vous devez minimiser la multiplication en virgule flottante pour √©viter les erreurs qui s'accumulent et causent des probl√®mes. <br><br>  DFS est un excellent algorithme de recherche.  Si une solution existe, elle la trouvera.  Mais il lui manque une propri√©t√© cl√©: il ne trouve pas forc√©ment le chemin le plus court.  Ceci est important pour nous car un chemin plus court signifie moins de sauts et moins d'erreur en raison des multiplications en virgule flottante.  Pour r√©soudre le probl√®me, nous nous tournons vers BFS. <br><br><h2>  Partie 2. Solution BFS </h2><br>  √Ä ce stade, si un candidat met en ≈ìuvre avec succ√®s une solution DFS r√©cursive et s'arr√™te dessus, je donne g√©n√©ralement au moins une faible recommandation sur l'embauche de ce candidat.  Il a compris le probl√®me, a choisi le cadrage appropri√© et a mis en ≈ìuvre une solution de travail.  C'est une d√©cision na√Øve, donc je n'insiste pas pour l'embaucher, mais s'il a bien fait avec d'autres interviews, je ne recommanderai pas de refuser. <br><br>  Cela vaut la peine d'√™tre r√©p√©t√©: en cas de doute, √©crivez une solution na√Øve!  M√™me si elle n'est pas compl√®tement optimale, la pr√©sence de code sur la carte est d√©j√† une r√©ussite, et souvent la bonne solution peut √™tre trouv√©e sur sa base.  Je dirai diff√©remment: ne travaillez jamais pour rien.  Tr√®s probablement, vous avez pens√© √† une solution na√Øve, mais vous ne vouliez pas l'offrir, car vous savez qu'elle n'est pas optimale.  Si vous √™tes pr√™t √† proposer la meilleure solution d√®s maintenant, c'est bien, mais sinon, enregistrez les progr√®s r√©alis√©s avant de passer √† des choses plus complexes. <br><br>  A partir de maintenant, parlons des am√©liorations de l'algorithme.  Les principaux inconv√©nients d'une solution DFS r√©cursive sont qu'elle est r√©cursive et ne minimise pas le nombre de multiplications.  Comme nous le verrons bient√¥t, BFS minimise le nombre de multiplications, et il est √©galement tr√®s difficile de l'impl√©menter r√©cursivement.  Malheureusement, nous devrons abandonner la solution r√©cursive DFA, car pour l'am√©liorer, nous devrons r√©√©crire compl√®tement le code. <br><br>  Sans plus tarder, je pr√©sente une approche it√©rative bas√©e sur BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Cette impl√©mentation est fonctionnellement tr√®s diff√©rente de la pr√©c√©dente, mais si vous regardez de pr√®s, elle fait √† peu pr√®s la m√™me chose, avec un changement significatif: tandis que le DFS r√©cursif enregistre l'√©tat de la route suppl√©mentaire dans la pile d'appels, mettant en ≈ìuvre efficacement la pile LIFO, la solution it√©rative le stocke dans la file d'attente FIFO <br><br>  Cela implique la propri√©t√© ¬´chemin le plus court / moins de multiplications¬ª.  Nous visitons les n≈ìuds dans l'ordre dans lequel ils se produisent et nous obtenons ainsi des g√©n√©rations de n≈ìuds.  Le premier n≈ìud ins√®re ses voisins, puis nous visitons ces voisins dans l'ordre, en collant leurs voisins tout le temps et ainsi de suite.  La propri√©t√© de chemin le plus court d√©coule du fait que les n≈ìuds sont visit√©s dans l'ordre de leur distance √† la source.  Par cons√©quent, lorsque nous rencontrons une destination, nous savons qu'aucune g√©n√©ration ant√©rieure ne pourrait y conduire. <br><br>  En ce moment, nous avons <i>presque</i> termin√©.  Vous devez d'abord r√©pondre √† quelques questions, et ils sont oblig√©s de revenir √† la formulation originale du probl√®me. <br><br>  Premi√®rement, la chose la plus triviale √† faire si l'unit√© d'origine n'existe pas?  Autrement dit, nous ne pouvons pas trouver le n≈ìud avec le nom donn√©.  En pratique, vous devez effectuer une certaine normalisation des cha√Ænes de sorte que le livre, le livre et lb pointent vers le m√™me n≈ìud ¬´livre¬ª (ou une autre repr√©sentation canonique), mais cela d√©passe le cadre de notre question. <br><br>  Deuxi√®mement, que se passe-t-il s'il n'y a pas de conversion entre les deux unit√©s?  Rappelons que dans les donn√©es initiales, il n'y a que des conversions entre les unit√©s, et cela ne donne aucune indication sur la possibilit√© d'en obtenir une autre √† partir d'une unit√© particuli√®re.  Cela se r√©sume au fait que les transformations et les chemins sont directement √©quivalents, donc s'il n'y a pas de chemin entre deux n≈ìuds, alors il n'y a pas de transformation.  En pratique, vous vous retrouvez avec des √Ælots d'unit√©s sans rapport: un pour les distances, un pour les poids, un pour les devises, etc. <br><br>  Enfin, si vous regardez attentivement le graphique ci-dessus, il s'av√®re que vous ne pouvez pas convertir entre les mains et les ann√©es-lumi√®re avec cette solution.  La direction des connexions entre les n≈ìuds signifie qu'il n'y a aucun moyen de passer de la main aux ann√©es-lumi√®re.  Cependant, cela est assez facile √† corriger, car les transformations peuvent √™tre invers√©es.  Nous pouvons changer notre code d'initialisation de graphique comme suit: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Partie 3. √âvaluation </h2><br>  C'est fait!  Si le candidat a atteint ce point, je le recommanderai tr√®s probablement √† l'embauche.  Si vous avez √©tudi√© l'informatique ou suivi un cours d'algorithmique, vous pouvez demander: ¬´Est-ce vraiment suffisant pour obtenir un entretien avec ce type?¬ª, Auquel je r√©pondrai: ¬´Essentiellement, oui.¬ª <br><br>  Avant de d√©cider que la question est trop simple, regardons ce qu'un candidat doit faire pour atteindre ce point: <br><br><ul><li>  Comprendre la question <br></li><li>  Construire un r√©seau de transformations sous forme de graphe <br></li><li>  Comprendre que les coefficients peuvent √™tre compar√©s avec les bords du graphique <br></li><li>  Voir la possibilit√© d'utiliser des algorithmes de recherche pour y parvenir. <br></li><li>  Choisissez votre algorithme pr√©f√©r√© et modifiez-le pour suivre les cotes <br></li><li>  S'il a impl√©ment√© DFS comme une solution na√Øve, reconnaissez ses faiblesses. <br></li><li>  Impl√©menter BFS <br></li><li>  Pour prendre du recul et √©tudier les cas extr√™mes: <br><ul><li>  Et si on nous interroge sur un n≈ìud qui n'existe pas? <br></li><li>  Et si le facteur de conversion n'existe pas? </li></ul></li><li>  Reconna√Ætre que des transformations inverses sont possibles et probablement n√©cessaires </li></ul><br>  Cette question est plus facile que les pr√©c√©dentes, mais elle est √©galement difficile.  Comme dans toutes les questions pr√©c√©dentes, le candidat doit faire un saut mental d'une question formul√©e de mani√®re abstraite √† un algorithme ou une structure de donn√©es qui ouvre la voie √† une solution.  La seule chose est que l'algorithme final est moins avanc√© que dans d'autres probl√®mes.  En dehors de ce mat√©riel algorithmique, les m√™mes exigences s'appliquent, en particulier en ce qui concerne les cas extr√™mes et l'exactitude. <br><br>  "Mais attendez!" Vous pouvez demander.  - Google n'est-il pas obs√©d√© par la complexit√© d'ex√©cution?  Vous ne vous √™tes m√™me pas interrog√© sur la complexit√© temporelle ou spatiale de ce probl√®me.  Oh bien! "  Vous pouvez √©galement demander: ¬´Attendez une minute, vous avez donn√© la note¬´ fortement recommand√© pour la location ¬ª?  Comment l'obtenir? "  Tr√®s bonnes questions, les deux.  Cela nous am√®ne √† notre dernier tour de bonus suppl√©mentaire ... <br><br><h2>  Partie 4. Est-il possible de faire mieux? </h2><br>  √Ä ce stade, je tiens √† f√©liciter le candidat pour sa bonne r√©ponse et √† pr√©ciser que tout ce qui pr√©c√®de n'est qu'un bonus.  Lorsque la pression dispara√Æt, nous pouvons commencer √† cr√©er. <br><br>  Quelle est donc la difficult√© d'ex√©cuter BFS?  Dans le pire des cas, nous devons consid√©rer chaque n≈ìud et bord individuel, ce qui donne une complexit√© lin√©aire <code>O(N+E)</code> .  Ceci s'ajoute √† la m√™me complexit√© de construction graphique <code>O(N+E)</code> .  Pour un moteur de recherche, c'est probablement bon: un millier d'unit√©s de mesure est suffisant pour la plupart des applications raisonnables, et faire une recherche de m√©moire pour chaque requ√™te n'est pas une surcharge. <br><br>  Cependant, on peut faire mieux.  Pour motiver, consid√©rez comment ce code est ins√©r√© dans la cha√Æne de recherche.  Les conversions de certaines unit√©s non standard sont un peu plus courantes, nous les calculerons donc encore et encore.  Chaque fois qu'une recherche est effectu√©e, des valeurs interm√©diaires sont calcul√©es, etc. <br><br>  Il est souvent sugg√©r√© de simplement mettre en cache les r√©sultats des calculs.  Chaque fois qu'une conversion d'unit√© est calcul√©e, nous pouvons toujours simplement ajouter un bord entre les deux conversions.  En bonus, nous obtenons la transformation inverse, et gratuitement!  Vous avez termin√©? <br><br>  En effet, cela nous donnera un temps de recherche asymptotiquement constant, mais cela co√ªtera le stockage d'ar√™tes suppl√©mentaires.  Cela devient en fait assez cher: au fil du temps, nous nous efforcerons d'obtenir un graphique complet, car toutes les paires de transformations sont progressivement calcul√©es et stock√©es.  Le nombre d'ar√™tes possibles dans le graphique est la moiti√© du carr√© du nombre de n≈ìuds, donc pour mille n≈ìuds, nous avons besoin d'un demi-million d'ar√™tes.  Pour dix mille n≈ìuds, environ cinquante millions, etc. <br><br>  Allant au-del√† de la port√©e du moteur de recherche, pour un graphique d'un million de n≈ìuds, nous nous effor√ßons d'atteindre un demi-billion de bords.  Ce montant est tout simplement d√©raisonnable √† stocker, et nous passons du temps √† ins√©rer des bords dans le graphique.  Nous devons faire mieux. <br><br>  Heureusement, il existe un moyen d'atteindre un temps constant pour rechercher des coefficients, sans croissance d'espace quadratique.  En fait, presque tout ce dont nous avons besoin est juste sous notre nez. <br><br><h2>  Partie 4. Temps constant </h2><br>  Ainsi, la mise en cache totale est en fait proche de la solution optimale.  Dans cette approche, nous obtenons (finalement) des ar√™tes entre tous les n≈ìuds, c'est-√†-dire que notre transformation est r√©duite √† trouver une ar√™te.  Mais est-il vraiment n√©cessaire de stocker les conversions de chaque n≈ìud √† chaque n≈ìud?  Et si nous enregistrions simplement les facteurs de conversion d' <i>un</i> n≈ìud √† tous les autres? <br><br>  Jetez un autre regard sur la solution BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Voyons ce qui se passe ici: nous partons du n≈ìud source, et pour chaque n≈ìud que nous rencontrons, nous calculons le coefficient de conversion de la source √† ce n≈ìud.  Ensuite, d√®s que nous arrivons √† destination, nous retournons le coefficient entre les points de d√©part et d'arriv√©e et rejetons les coefficients interm√©diaires. <br><br>  Ces ratios interm√©diaires sont essentiels.  Mais que se passe-t-il si nous ne les jetons pas?  Et si nous les √©crivions √† la place?  Toutes les recherches les plus complexes et incompr√©hensibles deviennent simples: pour trouver le rapport de A sur B, trouvez d'abord le rapport de X sur B, puis divisez-le par le rapport de X sur A, et vous avez termin√©!  Visuellement, cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Notez qu'entre deux n≈ìuds au maximum deux ar√™tes</font></i> <br><br>  Il s'av√®re que pour calculer ce tableau, nous n'avons presque pas besoin de changer la solution BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  La structure de transformation est repr√©sent√©e par un dictionnaire de l'unit√© A en deux valeurs: la racine de la composante associ√©e de l'unit√© A et le coefficient de conversion entre l'unit√© racine et l'unit√© A. Puisque nous ins√©rons une unit√© dans ce dictionnaire √† chaque visite, nous pouvons utiliser l'espace cl√© de ce dictionnaire comme un ensemble de visites au lieu d'utiliser un ensemble de visites d√©di√©es.  Notez que nous n'avons pas de n≈ìud final et que nous parcourons plut√¥t les n≈ìuds jusqu'√† ce que nous ayons termin√©. <br><br>  En dehors de ce BFS, il existe une fonction d'assistance qui it√®re sur les n≈ìuds d'un graphique.  Chaque fois qu'il rencontre un n≈ìud en dehors du dictionnaire de traduction, il d√©marre BFS √† partir de ce n≈ìud.  ,         . <br><br>      ,     ,    : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br>  ¬´  ¬ª        .  ¬´  ¬ª     :     , ,       BFS,        ,        . ,   . <br><br>  !        <code>O(V+E)</code> ( ,    ),       . ,     ,  √≥        ,          .        ,   :   <code>O(V+E)</code> ,        ,      <code>O(V)</code> ,       . <br><br><h2>  R√©sultats </h2><br>     ,   ,        ,  ,      -              .     -   ,         .   ,     . <br><br>         ( ,  , ,     ),          ¬´ ¬ª.    ,     :     ,       ,    . <br><br>     .   ,         ,    ,      .   ‚Äî              .              , ,       Google (  ,    ,    ). <br><br>   ,        . ,    ,       . ,    ,          , ,  -   ,    . <br><br>   .          DFS, ,     ,      .   ,   BFS  DFS, ,    ,          . <br><br>    ,    ,      ¬´¬ª,        .       ,        ,    .       .      ,         .  :   ,  ¬´ ¬ª  . <br><br><h2>  ,    ! </h2><br>  ,    ,        ,     ,      .     : <br><br> -, :     ,   ,        .  ,     ,    .   ,         - ,  -               .     ,       ,            . <br><br> -,    ,        ,    .       ‚Äî  :  ‚Äî  ,    A  B   ‚Äî    /   .            :  , ,    ,    ,     ,   .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, un vrai bijou: certaines unit√©s sont exprim√©es comme une combinaison de diff√©rentes unit√©s de base. Par exemple, un watt est d√©fini dans le syst√®me SI comme kg ‚Ä¢ m¬≤ / s¬≥. La derni√®re t√¢che consiste √† √©tendre ce syst√®me pour prendre en charge la conversion entre ces unit√©s, en ne prenant en compte que les d√©finitions des unit√©s SI de base. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez des questions, n'h√©sitez pas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† me contacter sur reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusion </h2><br>        ,  ,      .      :     ,      ,       ,        . ,   ,  ,   ,     :            ,        .   ,      ,  ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que cet article vous a √©t√© utile. </font><font style="vertical-align: inherit;">Je comprends qu'il peut ne pas y avoir autant d'aventures avec des algorithmes que dans certains articles pr√©c√©dents. </font><font style="vertical-align: inherit;">Lors des entretiens avec les d√©veloppeurs, il est habituel de discuter abondamment des algorithmes. </font><font style="vertical-align: inherit;">Mais la v√©rit√© est que d'importantes difficult√©s surviennent lors de l'utilisation m√™me d'une m√©thode simple et bien connue. </font><font style="vertical-align: inherit;">Tout le code est dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel de cette s√©rie d'articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467371/">https://habr.com/ru/post/fr467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467359/index.html">PVS-Studio passe aux nuages: Azure DevOps</a></li>
<li><a href="../fr467361/index.html">Nous avons oubli√© la d√©l√©gation en JavaScript. D√©l√©gation d'√©v√©nement en r√©action</a></li>
<li><a href="../fr467363/index.html">Utilisation de fonctions de perte personnalis√©es et apprentissage des m√©triques de qualit√© dans Keras</a></li>
<li><a href="../fr467365/index.html">Relais de surveillance de tension r√©sidentiels</a></li>
<li><a href="../fr467369/index.html">RubyRussia 2019. Mikhail Pronyakin: Ruby est-il s√ªr?</a></li>
<li><a href="../fr467375/index.html">Gestion de l'exp√©rience client - qu'est-ce que c'est?</a></li>
<li><a href="../fr467377/index.html">Trois d'affil√©e: les 10 meilleurs rapports de Mobius 2019 Piter</a></li>
<li><a href="../fr467381/index.html">LED √† plusieurs √©tages, lumi√®res intelligentes et ampoules pour 18 roubles</a></li>
<li><a href="../fr467383/index.html">¬´Le manager doit continuer √† coder¬ª: entretien avec Stephen Chin</a></li>
<li><a href="../fr467385/index.html">Une s√©lection de questions techniques psychologiques et atypiques issues d'entretiens avec des d√©veloppeurs Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>