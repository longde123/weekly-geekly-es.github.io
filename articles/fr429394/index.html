<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊙️ 🙎🏽 🧑🏿‍🤝‍🧑🏿 Cours MIT "Sécurité des systèmes informatiques". Conférence 16: «Side Channel Attacks», partie 3 📯 ❗️ 🔻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "Sécurité des systèmes informatiques." Nikolai Zeldovich, James Mickens. 2014 année...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "Sécurité des systèmes informatiques". Conférence 16: «Side Channel Attacks», partie 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/429394/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "Sécurité des systèmes informatiques."  Nikolai Zeldovich, James Mickens.  2014 année </h3><br>  Computer Systems Security est un cours sur le développement et la mise en œuvre de systèmes informatiques sécurisés.  Les conférences couvrent les modèles de menace, les attaques qui compromettent la sécurité et les techniques de sécurité basées sur des travaux scientifiques récents.  Les sujets incluent la sécurité du système d'exploitation (OS), les fonctionnalités, la gestion du flux d'informations, la sécurité des langues, les protocoles réseau, la sécurité matérielle et la sécurité des applications Web. <br><br>  Cours 1: «Introduction: modèles de menace» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 2: «Contrôle des attaques de pirates» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 3: «Débordements de tampon: exploits et protection» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 4: «Séparation des privilèges» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 5: «D'où viennent les systèmes de sécurité?» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> <br>  Conférence 6: «Opportunités» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 7: «Native Client Sandbox» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 8: «Modèle de sécurité réseau» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 9: «Sécurité des applications Web», <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 10: «Exécution symbolique» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 11: «Ur / Web Programming Language» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 12: Sécurité du réseau, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 13: «Protocoles réseau», <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 14: «SSL et HTTPS» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 15: «Logiciel médical» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 16: «Side Channel Attacks» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  <b>Public:</b> Utilisez-vous la méthode Karatsuba? <br><br>  <b>Professeur:</b> oui, c'est une méthode de multiplication intelligente qui ne nécessite pas quatre étapes de calcul.  La méthode Karatsuba est enseignée dans le cours .601, ou comment est-elle désignée aujourd'hui? <br><br>  <b>Audience:</b> 042. <br><br>  <b>Professeur:</b> 042, excellent.  Oui, c'est une très bonne méthode.  Presque toutes les bibliothèques cryptographiques l'utilisent.  Pour ceux d'entre vous qui ne sont pas diplômés de notre institut - je dis cela parce que nous avons des étudiants diplômés ici - j'écrirai sur la méthode Karatsuba au tableau.  Ici, vous devez calculer trois valeurs: <br><br>  a <sub>1</sub> b <sub>1</sub> <br>  (a <sub>1</sub> - a <sub>0</sub> ) (b <sub>1</sub> - b <sub>0</sub> ) <br>  a <sub>0</sub> b <sub>0</sub> <br><br>  Ainsi, vous effectuez 3 multiplications au lieu de quatre, et il s'avère que vous pouvez restaurer cette valeur a <sub>1</sub> b <sub>0</sub> + a <sub>0</sub> b <sub>1 à</sub> partir de ces trois résultats de multiplication. <br><br><img src="https://habrastorage.org/webt/sg/_m/od/sg_modaezv2yehkmftzlhpybti0.jpeg"><br><br>  La façon spéciale de le faire est la suivante ... laissez-moi le mettre sous une forme différente. <br><br>  Nous aurons donc: <br><br>  (2 <sup>64</sup> + 2 <sup>32</sup> ) (a <sub>1</sub> b <sub>1</sub> ) + <br>  (2 <sup>32</sup> ) (- (a <sub>1</sub> - a <sub>0</sub> ) (b <sub>1</sub> - b <sub>0</sub> ) <br>  (2 <sup>32</sup> + 1) (a <sub>0</sub> b <sub>0</sub> ) <br><br>  Ce n'est pas très clair, mais si vous travaillez sur les détails, finissez par vous convaincre que cette valeur dans ces 3 lignes est équivalente à la valeur de ab, mais en même temps réduit le calcul par une multiplication.  Et la façon dont nous appliquons cela à des multiplications plus volumineuses est que vous continuez à descendre récursivement.  Donc, si vous avez des valeurs de 512 bits, vous pouvez les diviser en multiplication de 256 bits.  Vous effectuez trois multiplications de 256 bits, à chaque fois récursivement en utilisant la méthode Karatsuba.  Au final, vos calculs se résument à la taille de la machine et peuvent être traités par une seule instruction machine. <br><br><img src="https://habrastorage.org/webt/gv/7s/ae/gv7saezq-q5xj52fvxnjxenikgo.jpeg"><br><br>  Alors, où est l'attaque temporelle?  Comment ces gars utilisent-ils la multiplication de Karatsuba?  Il s'avère qu'OpenSSL s'inquiète de deux types de multiplication que vous pourriez avoir à faire. <br>  Le premier est la multiplication de deux grands nombres approximativement de la même taille.  Cela se produit plusieurs fois lorsque nous effectuons une exponentiation modulaire, car toutes les valeurs que nous multiplierons auront une taille d'environ 512 bits.  Par conséquent, lorsque nous multiplions c par y ou carré, nous multiplions deux choses d'environ la même taille.  Dans ce cas, la méthode Karatsuba a beaucoup de sens, car elle réduit la taille des nombres au carré d'environ 1,58 fois, ce qui accélère considérablement le processus de calcul. <br>  Le deuxième type de multiplication est lorsque OpenSSL multiplie deux nombres dont la taille diffère considérablement l'un de l'autre: l'un est très grand et l'autre est très petit.  Dans ce cas, vous pouvez également utiliser la méthode Karatsuba, mais cela fonctionnera plus lentement que la multiplication primitive.  Supposons que vous multipliez un nombre de 512 bits par un nombre de 64 bits, vous devrez augmenter chaque bit du premier nombre à une puissance de 64, entraînant un ralentissement du processus de 2n au lieu d'une accélération de n / 1,58.  Par conséquent, ces gars qui utilisent OpenSSL ont essayé de faire plus intelligemment, et c'est là que les problèmes ont commencé. <br><br>  Ils ont décidé qu'ils basculeraient dynamiquement entre la méthode efficace de Karatsuba et la méthode de multiplication des écoles élémentaires.  Leur heuristique était la suivante.  Si les deux nombres que vous multipliez sont constitués du même nombre de mots machine, ou ont au moins le même nombre de bits que les unités 32 bits, alors la méthode Karatsuba est utilisée.  Si deux nombres diffèrent considérablement en taille l'un de l'autre, au carré ou directement simple, une multiplication normale est effectuée. <br><br>  Dans ce cas, vous pouvez suivre la façon dont le passage à une autre méthode de multiplication se produit.  Étant donné que le moment de la commutation ne passe pas sans laisser de trace, il sera visible après cela qu'il faut maintenant beaucoup plus de temps pour la multiplication ou beaucoup moins qu'auparavant.  Les chercheurs ont profité de cette circonstance pour organiser une attaque en utilisant la méthode du chronométrage. <br><br>  Je pense que j'ai fini de vous parler de toutes les astuces étranges que les gens utilisent lors de la mise en œuvre de RSA dans la pratique.  Essayons maintenant de les assembler et de les utiliser par rapport à l'ensemble du serveur Web pour savoir comment vous pouvez "pincer" les bits qui nous intéressent dans le paquet réseau d'entrée. <br><br>  Si vous vous souvenez de la conférence sur HTTPS, le serveur Web a une clé secrète.  Il utilise cette clé secrète pour prouver qu'il est le propriétaire correct de tous les certificats via HTTPS ou TLS.  Cela est dû au fait que les clients envoient des bits sélectionnés au hasard, ces bits sont chiffrés à l'aide de la clé publique du serveur et le serveur déchiffre ce message à l'aide du protocole TLS.  Et si le message est vérifié, ces bits aléatoires sont utilisés pour établir une session de communication. <br><br>  Mais dans notre cas, ce message ne sera pas vérifié, car il sera créé de manière spéciale, et lorsqu'il s'avérera que les bits supplémentaires ne correspondent pas, le serveur renverra une erreur dès qu'il aura fini de décrypter notre message. <br><br>  Voici ce que nous allons faire ici.  Le serveur - vous pouvez supposer qu'il s'agit d'Apache avec SSL ouvert - recevra un message du client qu'il considère comme du texte crypté avec ou du texte crypté hypothétique que le client a créé.  La première chose que nous faisons avec le texte chiffré c est de le déchiffrer en utilisant la formule avec → (c <sup>d</sup> mod n) = m. <br><br>  Si vous vous souvenez de la première optimisation, nous allons appliquer le théorème du reste chinois et diviser notre texte en deux parties: l'une pour calculer par mod p, l'autre par mod q, puis combiner les résultats.  Tout d'abord, prenez c et représentez-le en deux quantités: la première est appelée c <sub>0</sub> , elle sera égale à mod q, et la seconde est c <sub>1</sub> , et elle sera égale à c mod p.  Ensuite, nous ferons de même pour calculer c pour d mod p et c pour d mod q. <br><br><img src="https://habrastorage.org/webt/re/sp/qo/respqor_rehsunlfqjtc9lbmeok.jpeg"><br><br>  Ensuite, nous allons passer à la vue Montgomery car cela rendra nos multiplications très rapides.  Donc, la prochaine chose que SSL va faire avec votre numéro est de calculer c <sub>0</sub> ', qui sera égal à c <sub>0</sub> R mod q et faire la même chose ci-dessous pour c1, je ne l'écrirai pas car il a la même apparence . <br><br>  Maintenant que nous sommes passés à la forme Montgomery, nous pouvons enfin effectuer nos multiplications, et ici nous allons utiliser la technique de la «fenêtre coulissante».  Dès que nous obtenons c <sub>0</sub> ', nous faisons cette simple élévation de c <sub>0</sub> ' à la puissance de d dans le mod q.  Et ici, puisque nous calculons cette valeur pour d, nous utiliserons des «fenêtres coulissantes» pour des bits d'exposant d, et nous utiliserons également la méthode de Karatsuba ou la multiplication habituelle, selon la taille de nos opérandes. <br><br><img src="https://habrastorage.org/webt/ah/oa/um/ahoaumcorgtkbkeuj6uxli1yv9i.jpeg"><br><br>  Donc, s'il s'avère que cette valeur c <sub>0</sub> 'et le résultat de la quadrature précédemment obtenu sont de la même taille, nous utilisons la méthode de Karatsuba.  Si c <sub>0</sub> 'est très petit et que le résultat précédent de la multiplication est grand, alors nous allons quadriller et multiplier de la manière habituelle.  Ici, nous utilisons des «fenêtres coulissantes» et la méthode Karatsuba au lieu d'une multiplication normale. <br><br><img src="https://habrastorage.org/webt/pk/xc/wl/pkxcwlnkl3fndnsc-nx3rqk1auo.jpeg"><br><br>  Toujours à ce stade, des réductions supplémentaires apparaissent.  Parce qu'à chaque multiplication, les réductions supplémentaires seront proportionnelles à ce que nous élevons à la puissance du mod q, c'est-à-dire la valeur de (c <sub>0</sub> ') <sup>d</sup> .  Ici, avec une simple connexion de la formule, la probabilité de réductions supplémentaires sera proportionnelle à la valeur c <sub>0</sub> 'mod q divisée par 2R.  C'est à cet endroit qu'un peu apparaît qui affecte le timing. <br><br>  En fait, il y a deux effets possibles: utiliser la méthode Karatsuba au lieu de la multiplication normale et l'apparition d'abréviations supplémentaires que vous allez faire. <br><br>  Dans une seconde, vous verrez comment il peut être utilisé.  Maintenant, lorsque vous obtenez ce résultat pour le mod q et que vous allez obtenir un résultat similaire pour le mod p, vous pouvez enfin recombiner ces deux parties en haut et en bas et utiliser CRT, le théorème du reste chinois. <br><br>  Et ce que vous obtenez de CRT en conséquence ... désolé, je pense que nous devons d'abord le convertir à partir du formulaire Montgomery.  Par conséquent, avant la recombinaison, nous convertissons la partie supérieure en l'expression (c <sub>0</sub> ') <sup>d</sup> / R mod q et retournons notre valeur cd mod q.  En partie basse, on obtient donc cd mod p. <br><br>  Vous pouvez maintenant utiliser CRT pour obtenir la valeur de c <sup>d</sup> mod n.  Désolé pour la petite police, je n'avais pas assez de tableau noir.  À propos de la même chose que nous obtenons ici ci-dessous avec <sub>1</sub> , et nous pouvons enfin obtenir notre résultat, c'est-à-dire le message m. <br><br><img src="https://habrastorage.org/webt/vw/md/4x/vwmd4xcq0kjbfpsvw29dyqtglnk.jpeg"><br><br>  Ainsi, le serveur prend un paquet entrant qu'il reçoit, l'exécute à travers tout ce pipeline, exécute deux parties de ce pipeline et se termine par un message déchiffré m égal à cd mod m.  Ensuite, il va vérifier le rembourrage de ce post.  Dans le cas de notre attaque spécifique, nous avons créé de telle manière qu'en fait cet ajout ne correspondra pas.  Nous avons choisi la valeur c pour les heuristiques qui ne chiffrent pas le message réel avec l'ajout de remplissage correct. <br><br>  Ainsi, le module complémentaire ne réussit pas le test, le serveur devra enregistrer une erreur, envoyer un message d'erreur au client et se déconnecter.  Nous allons donc mesurer le temps qu'il faudra au serveur pour transmettre notre message via ce pipeline.  Vous avez des questions sur le processus de traitement d'un message par le serveur et la combinaison de toutes ces optimisations? <br><br>  <b>Public:</b> à mon avis, il y a une erreur avec un indice de grandeur c. <br><br>  <b>Professeur:</b> oui, vous avez raison, j'ajoute l'index 0, ici devrait être c <sub>0</sub> <sup>d</sup> mod q. <br><br><img src="https://habrastorage.org/webt/zf/c8/eb/zfc8ebgspz9g347khmvzs1n-9hc.jpeg"><br><br>  <b>Public:</b> lorsque vous divisez par R mod q, n'y a-t-il aucune hypothèse sur la quantité q que vous devez ajouter pour réduire davantage les bits faibles en zéros? <br><br>  <b>Professeur:</b> oui, vous avez raison, à ce stade final (c <sub>0</sub> ') <sup>d</sup> / R mod q il peut y avoir des réductions supplémentaires.  Nous devons donc faire cette division par R de la bonne manière, et probablement faire la même chose que de faire la réduction de Montgomery ici, lorsque nous divisons par R, pour reconvertir la valeur.  Puisqu'au début des calculs, on ne sait pas exactement combien de q nous devons ajouter, nous utilisons la méthode de sélection, détruisons les zéros faibles, puis faisons de nouveau le mod q et, éventuellement, une réduction supplémentaire.  Vous avez absolument raison, dans ce cas c'est exactement la même division par R mod q que pour chaque étape de multiplication de Montgomery. <br><br>  Alors, comment profitez-vous de cela?  Comment un attaquant peut-il résoudre la clé secrète d'un serveur en mesurant le temps nécessaire pour terminer les opérations?  Ces gars-là ont un plan basé sur la supposition d'un bit de clé privée à la fois.  Nous pouvons supposer que la clé secrète est l'exposant chiffré d, car vous connaissez e et connaissez n, il s'agit de la clé publique.  La seule chose que vous ne savez pas est d. <br><br><img src="https://habrastorage.org/webt/qw/pv/cg/qwpvcgujkfsub1kworr1vy2bmea.jpeg"><br><br>  En fait, dans cette attaque, ils ne devinent pas directement la valeur de d, car c'est assez compliqué.  Au lieu de cela, ils considèrent q ou p, peu importe laquelle de ces deux quantités.  Une fois que vous avez deviné ce qui compte p ou q, vous pouvez calculer n = pq.  Ensuite, si vous connaissez les valeurs de p et q, vous pouvez calculer la fonction φ dont nous avons parlé précédemment.  Cela vous permet d'obtenir la valeur de d à partir de la valeur de e.  Ainsi, cette factorisation de la valeur de n est extrêmement importante, elle doit être gardée secrète afin d'assurer la sécurité RSA. <br><br>  Donc en fait, ces gars-là avaient l'intention de deviner la valeur q en analysant les timings de ce pipeline.  Que font-ils pour ça?  Ils sélectionnent soigneusement la valeur initiale de la valeur de c et mesurent le temps de son passage à travers le pipeline du serveur. <br><br>  En particulier, cette attaque comporte deux parties, et vous devez prendre certaines mesures initiales pour deviner les premiers bits.  Ensuite, dès que vous avez les premiers bits, vous pouvez deviner le bit suivant.  Par conséquent, permettez-moi de ne pas vous dire en détail comment ils devinent les deux premiers bits, car en fait, il est beaucoup plus intéressant de considérer comment ils devinent le bit suivant.  Si nous avons le temps, nous reviendrons sur la façon dont la devinette de plusieurs bits initiaux est décrite dans un article de conférence. <br><br>  Supposons donc que vous ayez l'hypothèse g sur les bits de la valeur de ce q.  Soit cette valeur composée de ces bits: g = g <sub>0</sub> g <sub>1</sub> g <sub>2</sub> ... et ainsi de suite.  Au contraire, ce n'est même pas g, mais les vrais bits de q, alors permettez-moi de le réécrire comme ceci: g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ....  Nous pensons que ces q sont des bits hauts, et nous essayons de deviner les bits de plus en plus bas.  Supposons que nous connaissions la valeur de q jusqu'au bit qj, puis tous les zéros suivent.  Vous n'avez aucune idée de ce que sont les autres bits. <br><br><img src="https://habrastorage.org/webt/8c/ca/df/8ccadfhe0orkn4jalptuhmm_c9a.jpeg"><br><br>  Ces gars-là ont essayé d'injecter cette conjecture g à cet endroit de notre pipeline: (c0 ') d mod q.  Parce que c'est l'endroit où deux types d'optimisation sont utilisés: la méthode Karatsub au lieu de la multiplication habituelle et un nombre différent d'abréviations supplémentaires en fonction de la valeur de c <sub>0</sub> '.  En fait, ils ont essayé d'introduire deux suppositions différentes à cet endroit du pipeline: le premier, qui ressemble à g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ... qj 000 ... 0000, et le second, qu'ils ont appelé g <sub>high</sub> , qui se compose des mêmes bits hauts, mais à la place de tous les zéros à la fin, il y a une unité désignant un bit élevé, suivie à nouveau par des zéros: <br><br>  g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ... qj 100 ... 0000. <br><br>  Comment cela aide-t-il ces gars à comprendre ce qui se passe?  Il y a deux façons de procéder.  Supposons que notre supposition g soit égale à la valeur c <sub>0</sub> '.  On peut supposer que ces g et g <sub>high</sub> correspondent à la valeur c <sub>0</sub> 'donnée sur le tableau de gauche.  En fait, il est assez simple de le faire, car c <sub>0</sub> 'est assez facile à calculer à l'envers à partir de la valeur d'entrée chiffrée c <sub>0</sub> , il suffit de le multiplier par R. <br><br><img src="https://habrastorage.org/webt/u9/5k/yp/u95kypmv569-dhhozaeqfpcwgjo.jpeg"><br><br>  Par conséquent, pour deviner la valeur (c <sub>0</sub> ') <sup>d</sup> , il leur suffit de prendre leur supposition, leur supposition g, et de la diviser d'abord par R, c'est-à-dire de diviser par 512 quelque chose de mod.  Ensuite, ils vont le réintroduire, le serveur le multipliera par R et poursuivra le processus décrit dans notre schéma de pipeline. <br><br>  Supposons donc que nous ayons pu mettre notre valeur entière sélectionnée au bon endroit.  Alors, quel sera le temps de calcul c <sub>0</sub> 'à d mod q? <br><br><img src="https://habrastorage.org/webt/zy/b5/ud/zyb5udmf96e2cvwliab80lhusum.jpeg"><br><br>  Il y a deux options possibles où q s'inscrit dans cette image.  Il se peut que q soit entre ces deux valeurs de g et g <sub>high</sub> , car le bit suivant de q est 0. Ainsi, cette valeur - le premier 0 après qj - sera inférieure à q, mais cette valeur - 1 après q - sera supérieure à q.  Cela se produit si le bit suivant de q est 0, ou il est possible que q soit au-dessus de ces deux valeurs si le bit suivant de q est 1. <br><br><img src="https://habrastorage.org/webt/g5/uk/mn/g5ukmnfmvzp_rdlyhwtptj-8e4o.jpeg"><br><br>  Nous pouvons maintenant dire quel sera le temps de déchiffrement de ces deux valeurs si q se situe entre elles, ou si q est situé au-dessus des deux. <br><br>  Regardons la situation où q est situé au-dessus.  Dans ce cas, tout est à peu près le même.  Puisque ces deux valeurs sont inférieures à q, la valeur de ces choses dans le mod q sera approximativement la même.  Ils sont légèrement différents en raison de ce bit supplémentaire, mais toujours plus ou moins la même taille.  Et le nombre de réductions supplémentaires, réduction supplémentaire, ne différera probablement pas beaucoup non plus, car il est proportionnel à la valeur de c0 'mod q.  Et pour g et g <sub>des</sub> valeurs <sub>élevées</sub> inférieures à q, elles sont toutes à peu près les mêmes.  Aucun d'eux ne dépassera q et n'entraînera pas un grand nombre de réductions supplémentaires, car pour q supérieur à ces deux suppositions, le nombre de calculs par la méthode de Karatsuba par rapport au nombre de calculs ordinaires restera le même.  En termes de cette relation, le serveur gérera g et g <sub>high</sub> également.  Par conséquent, le serveur est sur le point de créer à peu près la même quantité d'abréviations supplémentaires pour ces deux valeurs.  Ainsi, si vous voyez que le serveur passe le même temps à répondre à ces conjectures, alors vous devriez probablement supposer qu'il y a vraiment 1 dans la valeur <sub>élevée</sub> g à ce stade. <br><br><img src="https://habrastorage.org/webt/ui/d_/tg/uid_tglidwosbzxkquvonqfrzi0.jpeg"><br><br>  D'un autre côté, si q est situé entre ces deux valeurs, alors il y a deux choses possibles qui peuvent provoquer des changements de commutation et de synchronisation.  L'une des choses est que, puisque g <sub>élevé est</sub> légèrement supérieur à q, le nombre de coupes supplémentaires sera proportionnel à c <sub>0</sub> 'mod q, qui est très petit, car c <sub>0</sub> ' est q plus quelques bits dans cette séquence de bits supplémentaires de 100 ... 00.  Ainsi, le nombre de réductions supplémentaires sera plus visible et tout commencera à se produire plus rapidement. <br>    ,   ,  , , ,  : «,         !».  ,    g  c <sub>0</sub> '     ,   q,   ,  g <sub>high</sub>  q,  g <sub>high</sub> mod q     .      ,       .         –    ,       ,   . <br><br>     c <sub>0</sub> ' mod q.  c <sub>0</sub>     g <sub>high</sub> ,   q,    ,        g  q.       ,     .     ,     ,          . ,    32-        ,        . <br><br>   ,     32- , ,     ,   .  ,         .         32 ,   ,    -  .   ,     ,  32, , ,     ,      . <br><br> ,  ,     ,            .    ,     q  1,         ,     q  0,   ,    g <sub>high</sub>  q   ,      ,   . <br><br>          . ,      .          ,    .   ,     ,  1-2 .        , ,   Ethernet. <br>      ,   .      .   ,        7    . ,   , -,         ,        ? <br><br> <b>:</b>     ? <br><br> <b>:</b> ,        ,           ,               ,     ,   .   ,       . <br><br>        ,    ,           7 ,        ,            7 .     7   g,   7   g + 1,  g + 2   7      g + 400.      g,     g, , 7   400,    ? <br><br><img src="https://habrastorage.org/webt/oo/at/9h/ooat9hm2htm-wjoamvqlpfv1vac.jpeg"><br><br> <b>:</b> ,    ,   ? <br><br> : ,     ,   ,        — (c <sub>0</sub> ') <sup>d</sup> .      . ,  ,   ,     mod p.    ,           ,     .  ,         g,  1, 2, 3,  ,    . <br><br>       ,     ,          –    100…00.  ,        mod p,    ,      mod p       .       « »,     ,        (c <sub>0</sub> ') <sup>d</sup> ,    .  ? <br><br> <b>:</b>   ,     ? <br><br> <b>:</b>      -   ,       q. ,        q,   ,     ,     . <br><br> <b>:</b>    c <sub>0</sub> '? <br><br> <b>:</b>     c <sub>0</sub> ',     c,     c <sub>0</sub> '      R  mod n. <br><br><img src="https://habrastorage.org/webt/br/j9/xp/brj9xpzlbunothk8hhovxqsxcz8.jpeg"><br><br>      ,  «»  ,     c <sub>0</sub> =  mod q,       c <sub>0</sub> = ((c <sub>0</sub> ' R <sup>-1</sup> ) mod n) mod q.      R,     R.           c <sub>0</sub> ',     (c <sub>0</sub> ') <sup>d</sup> mod q.  ,     ,   ,  ,       R.   ,  R = 2 <sup>512</sup> .  ,    . <br><br> <b>:</b>            mod p    ? <br><br> <b>:</b>     ,    ,      ?    ,     !   ,        . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3v5Von-oNUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en le recommandant à vos amis, une <b>réduction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vérité sur VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbps à partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps   </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV à partir de 249 $</a> aux Pays-Bas et aux États-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">création d'un bâtiment d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429394/">https://habr.com/ru/post/fr429394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429384/index.html">Composants de vélos électriques: moteur</a></li>
<li><a href="../fr429386/index.html">Le fournisseur AT&T devient le plus grand détenteur de droits d'auteur et commencera à déconnecter les utilisateurs accusés de piratage</a></li>
<li><a href="../fr429388/index.html">Comment refaire un site Web et ne pas créer de problèmes: 4 étapes importantes</a></li>
<li><a href="../fr429390/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 16: «Side Channel Attacks», partie 1</a></li>
<li><a href="../fr429392/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 16: Attaques par le canal latéral, partie 2</a></li>
<li><a href="../fr429396/index.html">Comment tester une application lors de l'interaction avec l'API à l'aide de SoapUI</a></li>
<li><a href="../fr429400/index.html">Seals vs neural network 2. Ou exécutez SqueezeNet v.1.1 sur Raspberry Zero en temps réel (presque)</a></li>
<li><a href="../fr429402/index.html">ML.NET 0.7 (Machine Learning .NET)</a></li>
<li><a href="../fr429404/index.html">8 secondes et demie pour hiérarchiser les fonctionnalités</a></li>
<li><a href="../fr429406/index.html">"Monstres dans les jeux ou comment créer la peur"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>