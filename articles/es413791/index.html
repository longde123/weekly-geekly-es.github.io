<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîä üåº üíÇüèº Mec√°nica Cu√°ntica de C√°lculos en JS üö© üòØ üë®üèΩ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, mi nombre es Dmitry Karlovsky y yo ... desempleado. Por lo tanto, tengo mucho tiempo libre para tocar m√∫sica, deportes, creatividad, idiomas, co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mec√°nica Cu√°ntica de C√°lculos en JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Hola, mi nombre es Dmitry Karlovsky y yo ... desempleado.  Por lo tanto, tengo mucho tiempo libre para tocar m√∫sica, deportes, creatividad, idiomas, conferencias JS y ciencias de la computaci√≥n.  Te contar√© sobre las √∫ltimas investigaciones en el campo de la divisi√≥n semiautom√°tica de c√°lculos largos en peque√±os cuantos de varios milisegundos, lo que result√≥ en una biblioteca en miniatura <code>$mol_fiber</code> .  Pero primero, describamos los problemas que resolveremos ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Esta es una versi√≥n de texto del rendimiento hom√≥nimo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS 2018 Piter</a> .  Puede <a href="">leerlo como un art√≠culo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abrirlo en la interfaz de presentaci√≥n</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver un video</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Problema: baja capacidad de respuesta </h1><br><p>  Si queremos tener 60 cuadros estables por segundo, entonces solo tenemos 16 con un poco de milisegundos para hacer todo el trabajo, incluido lo que hace el navegador para mostrar los resultados en la pantalla. </p><br><p>  Pero, ¬øqu√© pasa si tomamos el flujo por m√°s tiempo?  Luego, el usuario observar√° una interfaz retrasada, inhibiendo la animaci√≥n y similares de la degradaci√≥n de UX. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Baja capacidad de respuesta"></p><br><h1 id="issue-no-escape">  Problema: sin escape </h1><br><p>  Sucede que mientras realizamos los c√°lculos, el resultado ya no nos interesa.  Por ejemplo, tenemos un desplazamiento virtual, el usuario lo tira activamente, pero no podemos seguirlo y no podemos representar el √°rea real hasta que la representaci√≥n anterior devuelva el control para procesar los eventos del usuario. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="No se puede deshacer"></p><br><p>  Idealmente, no importa cu√°nto tiempo trabajemos, debemos continuar procesando eventos y poder cancelar en cualquier momento el trabajo que hemos comenzado, pero que a√∫n no hemos completado. </p><br><h1 id="im-fast-and-i-know-it">  Soy rapido y lo se </h1><br><p>  Pero, ¬øqu√© pasa si nuestro trabajo no es uno, sino varios, sino un flujo?  Imagine que conduce en su loto amarillo reci√©n comprado y conduce hasta el cruce del ferrocarril.  Cuando es gratis, puedes deslizarlo en una fracci√≥n de segundo.  Pero .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="Coche genial"></p><br><h1 id="issue-no-concurrency">  Problema: sin concurrencia </h1><br><p>  Cuando el cruce est√° ocupado por un tren de un kil√≥metro, debes pararte y esperar diez minutos hasta que pase.  No es por eso que compraste un auto deportivo, ¬øverdad? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="R√°pido espera lento"></p><br><p>  ¬°Y qu√© genial ser√≠a si este tren se dividiera en 10 trenes de 100 metros cada uno y hubiera varios minutos entre ellos para pasar!  No llegar√≠as tan tarde entonces. </p><br><p>  Entonces, ¬øcu√°les son las soluciones a estos problemas en el mundo JS ahora? </p><br><h1 id="solution-workers">  Soluci√≥n: trabajadores </h1><br><p>  Lo primero que viene a la mente: ¬øvamos a poner todos los c√°lculos complejos en un hilo separado?  Para hacer esto, tenemos un mecanismo para WebWorkers. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="Logica de los trabajadores"></p><br><p>  Los eventos de la secuencia de IU se pasan al trabajador.  All√≠ se procesan y las instrucciones sobre qu√© y c√≥mo cambiar en la p√°gina ya se devuelven.  Por lo tanto, guardamos el flujo de la interfaz de usuario de una gran capa de computaci√≥n, pero no todos los problemas se resuelven de esta manera, y adem√°s se agregan otros nuevos. </p><br><h1 id="workers-issues-deserialization">  Trabajadores: Problemas: (De) Serializaci√≥n </h1><br><p>  La comunicaci√≥n entre flujos se produce mediante el env√≠o de mensajes que se serializan en un flujo de bytes, se transfieren a otro flujo y all√≠ se analizan en objetos.  Todo esto es mucho m√°s lento que una llamada a m√©todo directo dentro de un solo hilo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(Des) serializaci√≥n"></p><br><h1 id="workers-issues-asynchronous-only">  Trabajadores: Problemas: solo as√≠ncrono </h1><br><p>  Los mensajes se transmiten estrictamente asincr√≥nicamente.  Y esto significa que algunas caracter√≠sticas que le pido no est√°n disponibles.  Por ejemplo, no puede detener el ascenso de un evento ui de un trabajador, ya que para cuando se inicie el controlador, el evento en el hilo de la IU ya completar√° su ciclo de vida. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Colas de mensajes"></p><br><h1 id="workers-issues-limited-apis">  Trabajadores: Problemas: API limitadas </h1><br><p>  Las siguientes API no est√°n disponibles para nosotros en los trabajadores. </p><br><ul><li>  DOM, CSSOM </li><li>  Lienzo </li><li>  GeoLocation </li><li>  Historia y ubicacion </li><li>  Sincronizar solicitudes http </li><li>  XMLHttpRequest.responseXML </li><li>  Ventana </li></ul><br><h1 id="workers-issues-cant-cancel">  Trabajadores: Problemas: no se puede cancelar </h1><br><p>  Y de nuevo, no tenemos forma de detener los c√°lculos en woker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="Basta!"></p><br><p>  S√≠, podemos detener a todo el trabajador, pero eso detendr√° todas las tareas en √©l. <br>  S√≠, puede ejecutar cada tarea en un trabajador independiente, pero requiere muchos recursos. </p><br><h1 id="solution-react-fiber">  Soluci√≥n: Reaccionar fibra </h1><br><p>  Seguramente muchos escucharon que FaceBook reescrib√≠a heroicamente React, dividiendo todos los c√°lculos en un conjunto de peque√±as funciones lanzadas por un programador especial. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Tricky React Fiber Logic"></p><br><p>  No entrar√© en detalles sobre su implementaci√≥n, ya que este es un gran tema separado.  Notar√© solo algunas caracter√≠sticas, por lo que puede no ser adecuado para usted ... </p><br><h1 id="react-fiber-react-required">  Reaccionar fibra: se requiere reacci√≥n </h1><br><p>  Obviamente, si usa Angular, Vue u otro marco que no sea React, entonces React Fiber es in√∫til para usted. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="¬°Reacciona en todas partes!"></p><br><h1 id="react-fiber-only-rendering">  Reaccionar fibra: solo renderizado </h1><br><p>  Reaccionar: solo cubre la capa de representaci√≥n.  Todas las dem√°s capas de la aplicaci√≥n quedan sin cuantificaci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="¬°No tan r√°pido!"></p><br><p>  React Fiber no lo salvar√° cuando necesite, por ejemplo, filtrar un gran bloque de datos por condiciones dif√≠ciles. </p><br><h1 id="react-fiber-quantization-is-disabled">  Reaccionar fibra: la cuantizaci√≥n est√° desactivada </h1><br><p>  A pesar del soporte reclamado para la cuantizaci√≥n, todav√≠a est√° desactivado de forma predeterminada, ya que rompe la compatibilidad con versiones anteriores. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Trampa de marketing"></p><br><p>  La cuantizaci√≥n en React sigue siendo algo experimental.  Ten cuidado </p><br><h1 id="react-fiber-debug-is-pain">  Reaccionar fibra: la depuraci√≥n es dolorosa </h1><br><p>  Cuando activa la cuantizaci√≥n, la pila de llamadas ya no coincide con su c√≥digo, lo que complica enormemente la depuraci√≥n.  Pero volveremos a este tema. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Todo el dolor de la depuraci√≥n"></p><br><h1 id="solution-quantization">  Soluci√≥n: cuantizaci√≥n </h1><br><p>  Intentemos generalizar el enfoque React Fiber para deshacernos de las desventajas mencionadas.  Queremos permanecer en el marco de una secuencia, pero dividimos los c√°lculos largos en peque√±os cuantos, entre los cuales el navegador puede representar los cambios que ya se han realizado en la p√°gina, y responderemos a los eventos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="cartas de llamas"></p><br><p>  Arriba ves un c√°lculo largo que detuvo al mundo entero en m√°s de 100 ms.  Y desde abajo, el mismo c√°lculo, pero desglosado en segmentos de tiempo de aproximadamente 16 ms, que dieron un promedio de 60 fotogramas por segundo.  Como generalmente no sabemos cu√°nto tiempo llevar√°n los c√°lculos, no podemos dividirlo manualmente en trozos de 16 ms por adelantado.  por lo tanto, necesitamos alg√∫n tipo de mecanismo de tiempo de ejecuci√≥n que mida el tiempo que lleva completar la tarea y cu√°ndo se excede el cuanto, lo que detiene la ejecuci√≥n hasta el siguiente cuadro de animaci√≥n.  Pensemos qu√© mecanismos tenemos implementados para implementar tareas suspendidas aqu√≠. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Concurrencia: fibras - corutinas apiladas </h1><br><p>  En lenguajes como Go y D existe un modismo como "corutina con una pila", tambi√©n es una "fibra" o "fibra". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  En el ejemplo de c√≥digo, ver√° <code>one</code> funci√≥n, que puede pausar la fibra actual, pero en s√≠ misma tiene una interfaz completamente sincr√≥nica.  Las <code>two</code> , <code>three</code> y <code>four</code> funciones son funciones s√≠ncronas regulares que no saben nada acerca de la fibra.  En ellos puedes usar todas las caracter√≠sticas de javascript en su totalidad.  Y finalmente, en la √∫ltima l√≠nea, simplemente ejecutamos las <code>four</code> funciones en una fibra separada. </p><br><p>  El uso de fibras es bastante conveniente, pero para admitirlas, necesita soporte en tiempo de ejecuci√≥n, que la mayor√≠a de los int√©rpretes de JS no tienen.  Sin embargo, para NodeJS hay una extensi√≥n nativa <code>node-fibers</code> que agrega este soporte.  Desafortunadamente, no hay navegadores disponibles en ning√∫n navegador. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Concurrencia: FSM - corutinas apiladas </h1><br><p>  En lenguajes como C # y ahora JS hay soporte para "corutinas sin pila" o "funciones asincr√≥nicas".  Dichas funciones son una m√°quina de estado bajo el cap√≥ y no saben nada sobre la pila, por lo que deben marcarse con la palabra clave especial "async", y los lugares donde se pueden pausar est√°n "en espera". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  Como es posible que tengamos que posponer el c√°lculo en cualquier momento, resulta que casi todas las funciones de la aplicaci√≥n tendr√°n que hacerse asincr√≥nicas.  Esto no es solo que la complejidad del c√≥digo, sino que tambi√©n afecta en gran medida el rendimiento.  Adem√°s, muchas API que aceptan devoluci√≥n de llamada a√∫n no admiten devoluciones de llamada asincr√≥nicas.  Un ejemplo sorprendente es el m√©todo de <code>reduce</code> de cualquier matriz. </p><br><h1 id="concurrency-semi-fibers---restarts">  Concurrencia: semi-fibras - reinicios </h1><br><p>  Intentemos hacer algo similar a la fibra, utilizando solo las funciones que est√°n disponibles para nosotros en cualquier navegador moderno. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Como puede ver, las funciones intermedias no saben nada acerca de la interrupci√≥n; esto es JS normal.  Solo <code>one</code> funci√≥n conoce la posibilidad de suspensi√≥n.  Para abortar el c√°lculo, ella simplemente lanza <code>Promise</code> como una excepci√≥n.  En la √∫ltima l√≠nea, ejecutamos las <code>four</code> funciones en una pseudo fibra separada, que monitorea las excepciones lanzadas dentro, y si llega <code>Promise</code> , se suscribe a su <code>resolve</code> y luego reinicia la fibra. </p><br><h1 id="figures">  Figuras </h1><br><p>  Para mostrar c√≥mo funcionan las pseudo-fibras, escribiremos un c√≥digo complicado ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Cuadro de ejecuci√≥n t√≠pico"></p><br><p>  Imaginemos que la funci√≥n de <code>step</code> aqu√≠ escribe algo en la consola y hace otro trabajo duro durante 20 ms.  Y la funci√≥n de <code>walk</code> llama al <code>step</code> dos veces, registrando todo el proceso.  En el medio, mostrar√° lo que ahora se muestra en la consola.  Y a la derecha est√° el estado del √°rbol de pseudofibra. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: sin cuantizaci√≥n </h1><br><p>  Ejecutemos este c√≥digo y veamos qu√© sucede. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Ejecuci√≥n sin cuantizaci√≥n."></p><br><p>  Hasta ahora, todo es simple y obvio.  El √°rbol de pseudo-fibra, por supuesto, no est√° involucrado.  Y todo estar√≠a bien, pero este c√≥digo se ejecuta durante m√°s de 40 ms, lo que no tiene valor. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: cach√© primero </h1><br><p>  Envuelvamos ambas funciones en un contenedor especial que lo ejecute en una pseudo fibra y veamos qu√© sucede. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Llenado de cach√©s"></p><br><p>  Aqu√≠ vale la pena prestar atenci√≥n al hecho de que para cada lugar de invocaci√≥n de <code>one</code> funci√≥n dentro de la fibra de <code>walk</code> , se cre√≥ una fibra separada.  El resultado de la primera llamada se almacen√≥ en cach√©, pero en lugar de la segunda, se lanz√≥ <code>Promise</code> , ya que hab√≠amos agotado nuestro tiempo. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: segundo cach√© </h1><br><p>  Lanzado en el primer fotograma, <code>Promise</code> se resolver√° autom√°ticamente en el siguiente, lo que conducir√° a un reinicio de la fibra de <code>walk</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Reutilizaci√≥n de cach√©"></p><br><p>  Como puede ver, debido al reinicio, de nuevo enviamos "inicio" y "primer hecho" a la consola, pero "primer comienzo" ya se ha ido, ya que est√° en la fibra con el cach√© lleno anteriormente, por lo que su controlador es m√°s no llamado  Cuando se llena el cach√© de la fibra de <code>walk</code> , se destruyen todas las fibras incrustadas, ya que la ejecuci√≥n nunca las alcanzar√°. </p><br><p>  Entonces, ¬øpor qu√© <code>first begin</code> imprimir una vez y <code>first done</code> dos?  Se trata de idempotencia.  <code>console.log</code> : operaci√≥n no idempotente, cu√°ntas veces la llamas, tantas veces agregar√° una entrada a la consola.  Pero la fibra que se est√° ejecutando en otra fibra es idempotente, solo ejecuta el identificador en la primera llamada y, en las devoluciones posteriores, inmediatamente el resultado de la memoria cach√©, sin provocar efectos secundarios adicionales. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: idempotencia primero </h1><br><p>  Vamos a envolver <code>console.log</code> en una fibra, convirti√©ndola en idempotente, y veamos c√≥mo se comporta el programa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="llenar cach√©s idempotentes"></p><br><p>  Como puede ver, ahora en el √°rbol de fibra tenemos entradas para cada llamada a la funci√≥n de <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: segunda idempotencia </h1><br><p>  En el pr√≥ximo reinicio de la fibra de <code>walk</code> , las llamadas repetidas a la funci√≥n de <code>log</code> ya no generan llamadas a la <code>console.log</code> , pero tan pronto como llegamos a la ejecuci√≥n de las fibras con un cach√© vac√≠o, las llamadas a <code>console.log</code> reanudan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Reutilizando cach√©s idempotentes"></p><br><p>  Tenga en cuenta que en la consola ahora no mostramos nada superfluo, exactamente lo que se mostrar√≠a en c√≥digo s√≠ncrono sin fibra ni cuantificaci√≥n. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: descanso </h1><br><p>  ¬øC√≥mo interrumpe el c√°lculo?  Al comienzo del cuanto, se establece una fecha l√≠mite.  Y antes de comenzar cada fibra, se verifica si la hemos alcanzado.  Y si alcanzas, <code>Promise</code> apresura, lo que se resuelve en el siguiente cuadro y comienza un nuevo cuanto. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: fecha l√≠mite </h1><br><p>  La fecha l√≠mite para el cuanto es f√°cil de establecer.  Se agregan 8 milisegundos a la hora actual.  ¬øPor qu√© exactamente 8, porque hay hasta 16 para preparar el tiro?  El hecho es que no sabemos de antemano cu√°nto tiempo tendr√° que procesar el navegador, por lo que debemos dejar algo de tiempo para que funcione.  Pero a veces sucede que el navegador no necesita renderizar nada, y luego con 8 ms quanta podemos insertar otro cuanto en el mismo marco, lo que dar√° un paquete denso de cuantos con un tiempo de inactividad m√≠nimo del procesador. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Pero si solo lanzamos una excepci√≥n cada 8 ms, entonces la depuraci√≥n con la parada de excepci√≥n activada se convertir√° en una peque√±a rama del infierno.  Necesitamos alg√∫n mecanismo para detectar este modo de depurador.  Desafortunadamente, esto solo puede entenderse indirectamente: una persona tarda aproximadamente un segundo en comprender si contin√∫a la ejecuci√≥n o no.  Y esto significa que si el control no volvi√≥ al script durante mucho tiempo, entonces el depurador se detuvo o hubo un c√°lculo pesado.  Para sentarnos en ambas sillas, agregamos al cu√°ntico el 10% del tiempo transcurrido, pero no m√°s de 100 ms.  Esto no afecta en gran medida a los FPS, pero reduce la frecuencia de detenci√≥n del depurador en un orden de magnitud debido a la cuantizaci√≥n. </p><br><h1 id="debug-trycatch">  Depurar: probar / atrapar </h1><br><p>  Ya que estamos hablando de depuraci√≥n, ¬øqu√© piensas, en qu√© lugar de este c√≥digo se detiene el depurador? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  Como regla general, debe detenerse donde se lanza la excepci√≥n por primera vez, pero la realidad es que se detiene solo donde se lanz√≥ la √∫ltima vez, que generalmente est√° muy lejos de donde ocurri√≥.  Por lo tanto, para no complicar la depuraci√≥n, nunca se deben detectar excepciones a trav√©s de try-catch.  Pero incluso sin un manejo excepcional es imposible. </p><br><h1 id="debug-unhandled-events">  Depuraci√≥n: eventos no controlados </h1><br><p>  Normalmente, un tiempo de ejecuci√≥n proporciona un evento global que se produce para cada excepci√≥n no detectada. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  Adem√°s de la molestia, esta soluci√≥n tiene un inconveniente tal que todas las excepciones caen aqu√≠ y es bastante dif√≠cil entender de qu√© fibra y fibra se produjo el evento. </p><br><h1 id="debug-promise">  Depurar: promesa </h1><br><p>  Las promesas son la mejor manera de manejar las excepciones. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  La funci√≥n pasada a Promise se llama de forma inmediata, sincr√≥nica, pero la excepci√≥n no se detecta y detiene de forma segura el depurador en el lugar de su aparici√≥n.  Un poco m√°s tarde, de forma as√≠ncrona, ya llama al controlador de errores, en el que sabemos exactamente qu√© fibra dio la falla y qu√© falla.  Este es precisamente el mecanismo utilizado en $ mol_fiber. </p><br><h1 id="stack-trace-react-fiber">  Seguimiento de pila: reaccionar fibra </h1><br><p>  Echemos un vistazo a la traza de pila que obtienes en React Fiber. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Carrera de pila vac√≠a"></p><br><p>  Como puede ver, tenemos mucha reacci√≥n intestinal.  De lo √∫til aqu√≠, solo el punto de ocurrencia de la excepci√≥n y los nombres de los componentes son m√°s altos en la jerarqu√≠a.  No mucho </p><br><h1 id="stack-trace-mol_fiber">  Seguimiento de pila: $ mol_fiber </h1><br><p>  En $ mol_fiber, obtenemos un seguimiento de pila mucho m√°s √∫til: sin agallas, solo puntos espec√≠ficos en el c√≥digo de la aplicaci√≥n a trav√©s del cual lleg√≥ a una excepci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Strain de contenido"></p><br><p>  Esto se logra mediante el uso de la pila nativa, las promesas y la eliminaci√≥n autom√°tica de los intestinos.  Si lo desea, puede expandir el error en la consola, como en la captura de pantalla, y ver las tripas, pero no hay nada interesante. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: manejar </h1><br><p>  Entonces, para interrumpir un cuanto, se lanza Promesa. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Pero, como puede suponer, Promise puede ser absolutamente cualquier cosa: para Fiber, en general, no importa qu√© esperar: el siguiente marco, la finalizaci√≥n de la carga de datos u otra cosa ... </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Fiber simplemente se suscribe para resolver promesas y reinicia.  Pero no es necesario lanzar y atrapar promesas manualmente, porque el paquete incluye varios envoltorios √∫tiles. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: funciones </h1><br><p>  Para convertir cualquier funci√≥n s√≠ncrona en una fibra idempotente, simplemente envu√©lvala en <code>$mol_fiber_func</code> .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Aqu√≠ creamos <code>console.log</code> idempotent, y <code>main</code> ense√±√≥ a interrumpir mientras esperaba la descarga. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: manejo de errores </h1><br><p>  Pero, ¬øc√≥mo responder a las excepciones si no queremos usar <code>try-catch</code> ?  Entonces podemos registrar el controlador de errores con <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Si devolvemos algo diferente del error, ser√° el resultado de la fibra actual.  En este ejemplo, si no es posible descargar la configuraci√≥n del servidor, la funci√≥n <code>getConfig</code> devolver√° la configuraci√≥n de forma predeterminada. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: m√©todos </h1><br><p>  Por supuesto, puede ajustar no solo las funciones, sino tambi√©n los m√©todos que usan un decorador. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Aqu√≠, por ejemplo, subimos datos de Google y los subimos a Yandex. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: promesas </h1><br><p>  Para descargar datos del servidor, basta con tomar, por ejemplo, la funci√≥n de <code>fetch</code> as√≠ncrona y, con un simple movimiento de la mu√±eca, la convierte en sincronizada. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Esta implementaci√≥n es buena para todos, pero no admite la cancelaci√≥n de una solicitud cuando se destruye un √°rbol de fibras, por lo que debemos utilizar una <code>API</code> m√°s confusa. </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: cancelar solicitud </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  La funci√≥n que se pasa al reiniciador <code>async</code> se llama solo una vez y el reiniciador se le pasa, en el que debe ajustar las devoluciones de llamada.  En consecuencia, en estas devoluciones de llamada, debe devolver el valor o lanzar una excepci√≥n.  Cualquiera que sea el resultado de la devoluci√≥n de llamada, tambi√©n ser√° el resultado de la fibra.  Tenga en cuenta que al final devolveremos una funci√≥n que se llamar√° en caso de destrucci√≥n prematura de la fibra. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: cancelar respuesta </h1><br><p>  Del lado del servidor, tambi√©n puede ser √∫til cancelar el c√°lculo cuando el cliente se ha ca√≠do.  Implementemos un contenedor sobre <code>midleware</code> que crear√° una fibra en la que se ejecutar√° el <code>midleware</code> original.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Solicitudes r√°pidas y lentas"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber ‚Äî   ,         .  ‚Äî ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links"> Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nin-jin.github.io/slides/fibers/</a> ‚Äî this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mol.js.org/fiber</a> ‚Äî $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> ‚Äî $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">t.me/mam_mol</a> ‚Äî lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="Retroalimentaci√≥n"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    ¬´¬ª. </p><br><p> <strong></strong> :      ‚Äî       .  Gracias </p><br><p> <strong></strong> :    .    ,   .  ! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            ‚Äî .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s o menos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : no trabaj√© con fibra. </font><font style="vertical-align: inherit;">En el informe escuch√© la teor√≠a del trabajo de la fibra. </font><font style="vertical-align: inherit;">Pero no entend√≠ absolutamente c√≥mo usar mol_fiber en casa ... Los ejemplos peque√±os son geniales, pero ¬øc√≥mo se puede aplicar esto en una aplicaci√≥n grande con 30 fps para acelerar hasta 60 fps? No hubo comprensi√≥n. </font><font style="vertical-align: inherit;">Ahora, si el autor prestara m√°s atenci√≥n a esto y menos dise√±o de m√≥dulo interno, la calificaci√≥n ser√≠a m√°s alta.</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413791/">https://habr.com/ru/post/es413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413779/index.html">Temporizadores y multitarea en Arduino</a></li>
<li><a href="../es413781/index.html">C√≥mo los sabuesos publicitarios siguen tu rastro en Internet</a></li>
<li><a href="../es413783/index.html">¬øC√≥mo mueren las estrellas m√°s masivas: supernova, hipernova o colapso directo?</a></li>
<li><a href="../es413787/index.html">Angular: ngx-translate. Mejorando la infraestructura con Webpack</a></li>
<li><a href="../es413789/index.html">En Florida, no revisaron a los compradores de armas en la base del FBI durante un a√±o porque olvidaron la contrase√±a</a></li>
<li><a href="../es413793/index.html">Casetes de audio en la cultura pop: por qu√© el formato de grabaci√≥n de sonido obsoleto se considera nuevamente de moda</a></li>
<li><a href="../es413795/index.html">Por qu√© la industria del entretenimiento se est√° mudando a IaaS: estudio de caso</a></li>
<li><a href="../es413797/index.html">EA present√≥ la nueva parte de C&C en E3. Y es f√≠sicamente doloroso mirarlo</a></li>
<li><a href="../es413799/index.html">Raspberry Pi Neural Network Conteo de abejas</a></li>
<li><a href="../es413801/index.html">"Roskosmos" ofrece rehacer un ca√±√≥n l√°ser ... un telescopio √≥ptico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>