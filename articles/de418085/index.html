<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥧 👉🏻 👨‍🏫 Versprechen in JavaScript verwenden 👨🏾‍🔬 🔯 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit veröffentlichen wir Materialien, die sich auf die eine oder andere Weise auf die Verwendung von Versprechungen in JavaScript beziehen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versprechen in JavaScript verwenden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  Von Zeit zu Zeit veröffentlichen wir Materialien, die sich auf die eine oder andere Weise auf die Verwendung von Versprechungen in JavaScript beziehen. <br><br><div class="spoiler">  <b class="spoiler_title">Hier sind einige davon.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versprechen in ES6: Muster und Anti-Muster</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript: asynchrone Programmiermethoden</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript ES8 und Übergang zu async / await</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async / warten: 6 Gründe, Versprechen zu vergessen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flucht aus der Hölle asynchron / warten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript ES6: weniger schreiben - mehr tun</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versprechen Leitfaden für diejenigen, die verstehen wollen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrones / wartendes JavaScript-Design: Stärken, Fallstricke und Verwendungsmuster</a> </div></div><br>  Warum wird so viel Aufmerksamkeit auf Versprechen gelenkt?  Wir glauben, dass der springende Punkt ist, dass diese Technologie sehr gefragt ist und dass es ziemlich schwer zu verstehen ist. <br><br>  Wenn Sie die Versprechen besser verstehen möchten, bieten wir Ihnen daher eine Übersetzung des nächsten Artikels zu diesem Thema an.  Sein Autor sagt, dass er Java und PHP in den letzten 10 Jahren entwickelt hat, aber die ganze Zeit hat er sich mit Interesse für JavaScript interessiert.  Vor kurzem beschloss er, sich ernsthaft mit JS zu beschäftigen, und Versprechen wurden das erste Thema, das ihn interessierte. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Wir glauben, dass dieses Material für unerfahrene Entwickler interessant sein wird, die das Gefühl haben, dass sie, obwohl sie Versprechen verwenden, diese nicht gut genug verstehen.  Es ist möglich, dass die Geschichte von jemandem, der JavaScript mit einem frischen Blick betrachtet und anderen erklären möchte, was er selbst verstanden hat, ohne zu glauben, dass einige Dinge für alle verständlich sind und ohne Erklärung, Anfängern hilft, JavaScript-Mechanismen zu beherrschen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript mit den Augen eines Anfängers</font> </h2><br>  Jeder, der anfängt, in JavaScript zu schreiben, kann fühlen, was als "fehl am Platz" bezeichnet wird.  Einige sagen, dass JS eine synchrone Programmiersprache ist, andere sagen, dass es asynchron ist.  Ein Neuling erfährt von Code, der den Hauptthread blockiert, und von Code, der ihn nicht blockiert, von ereignisbasierten Entwurfsmustern, vom Lebenszyklus von Ereignissen, vom Stapel von Funktionsaufrufen, von der Warteschlange von Ereignissen und deren Aufstieg, von Polyfills.  Er erfährt, dass es solche Dinge wie Babel, Angular, React, Vue und eine Vielzahl anderer Bibliotheken gibt.  Wenn Sie sich gerade in einem solchen „Anfänger“ wiedererkannt haben - machen Sie sich darüber keine Sorgen.  Du bist weder der Erste noch der Letzte.  Dafür gibt es sogar einen Begriff - die sogenannte „JavaScript-Müdigkeit“.  Lucas F. Costa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">sprach</a> treffend zu diesem Thema: " <i>JavaScript-Müdigkeit kann beobachtet werden, wenn Benutzer Tools verwenden, die sie nicht benötigen, um Probleme zu lösen, die sie nicht haben</i> ." <br><br>  Aber reden wir nicht über traurige Dinge.  JavaScript ist also eine synchrone Programmiersprache, mit der Sie dank des Rückrufmechanismus Funktionen auf die gleiche Weise wie in asynchronen Sprachen aufrufen können. <br><br><h2>  <font color="#3AC1EF">Eine einfache Geschichte über Versprechen</font> </h2><br>  Das Wort Versprechen bedeutet Versprechen.  Versprechen Objekte in der Programmierung, die wir "Versprechen" nennen, sind den üblichen Versprechen, die sich Menschen im wirklichen Leben gegenseitig geben, sehr ähnlich.  Sprechen wir also zuerst über diese Versprechen. <br><br>  Auf Wikipedia finden Sie die folgende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition des</a> Wortes „Versprechen“: „Verpflichtung, Zustimmung von jemandem, etwas zu erfüllen oder im Gegenteil nicht zu tun“.  In Ozhegovs Wörterbuch ist "Versprechen" "eine freiwillige Verpflichtung, etwas zu tun". <br><br>  Was wissen wir über Versprechen? <br><br><ol><li>  Ein Versprechen gibt Ihnen die Garantie, dass etwas getan wird.  Es spielt keine Rolle, wer genau dies tut: derjenige, der das Versprechen gegeben hat, oder jemand anderes auf Anfrage desjenigen, der das Versprechen gegeben hat.  Ein Versprechen gibt Vertrauen in etwas, basierend auf diesem Vertrauen kann derjenige, der das Versprechen erhalten hat, zum Beispiel einige Pläne machen. </li><li>  Ein Versprechen kann entweder erfüllt werden oder nicht. </li><li>  Wenn das Versprechen erfüllt ist, erwarten Sie daher etwas, das Sie in Zukunft verwenden können, um Maßnahmen durchzuführen oder Pläne umzusetzen. </li><li>  Wenn das Versprechen nicht erfüllt wird, möchten Sie herausfinden, warum derjenige, der es gegeben hat, es nicht erfüllen konnte.  Nachdem Sie den Grund für das Geschehene herausgefunden haben und sicher sind, dass das Versprechen nicht erfüllt wurde, können Sie überlegen, was als Nächstes zu tun ist oder wie Sie mit der Situation umgehen sollen. </li><li>  Nachdem Ihnen etwas versprochen wurde, haben Sie nur eine Art Garantie.  Sie können das, was Ihnen versprochen wird, nicht sofort nutzen.  Sie können selbst bestimmen, was Sie tun müssen, wenn das Versprechen erfüllt ist (daher erhalten Sie das Versprechen), und was Sie tun müssen, wenn es sich als fehlerhaft herausstellt (in diesem Fall kennen Sie den Grund für das, was passiert ist, und können daher über einen Sicherungsplan nachdenken ) </li><li>  Es ist wahrscheinlich, dass die Person, die das Versprechen gegeben hat, einfach verschwindet.  In solchen Fällen ist es nützlich, dass das Versprechen an einen bestimmten Zeitrahmen gebunden ist.  Wenn beispielsweise derjenige, der Ihnen das Versprechen gegeben hat, nicht innerhalb von 10 Tagen erscheint, können Sie davon ausgehen, dass er einige Probleme hatte und das Versprechen gebrochen hat.  Selbst wenn derjenige, der das Versprechen abgegeben hat, es in 15 Tagen erfüllt, spielt dies keine Rolle. Sie handeln also bereits nach dem alternativen Plan und verlassen sich nicht auf das Versprechen. </li></ol><br>  Fahren Sie nun mit JavaScript fort. <br><br><h2>  <font color="#3AC1EF">JavaScript verspricht</font> </h2><br>  Ich habe eine Regel: Wenn ich JavaScript mache, lese ich immer die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> , die auf MDN zu finden ist.  Es scheint mir, dass diese Ressource in Bezug auf Spezifität und Klarheit der Darstellung im Vergleich zu den anderen günstig ist.  Während ich Versprechen studierte, machte ich mich daher mit dem relevanten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> vertraut und experimentierte mit dem Code, um mich an die neuen Syntaxkonstrukte zu gewöhnen. <br><br>  Um die Versprechen zu verstehen, müssen Sie sich mit zwei Hauptsachen befassen.  Das erste ist die Schaffung von Versprechungen.  Die zweite ist die Verarbeitung der von den Versprechungen zurückgegebenen Ergebnisse.  Obwohl der größte Teil des Codes, den wir schreiben, darauf abzielt, mit Versprechungen zu arbeiten, die beispielsweise von bestimmten Bibliotheken erstellt wurden, wird ein umfassendes Verständnis der Mechanismen der Arbeit von Versprechungen zweifellos nützlich sein.  Für einen Programmierer, der bereits Erfahrung hat, ist es ebenso wichtig zu wissen, wie man Versprechen erstellt, wie zu wissen, wie man mit ihnen arbeitet. <br><br><h2>  <font color="#3AC1EF">Versprechen erstellen</font> </h2><br>  So entstehen Versprechen: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  Der Konstruktor akzeptiert eine Funktion, die bestimmte Aktionen ausführt. Wir haben sie hier <code>executor</code> .  Diese Funktion benötigt zwei Parameter - <code>resolve</code> und <code>reject</code> , die wiederum ebenfalls Funktionen sind.  Versprechungen werden normalerweise verwendet, um asynchrone Vorgänge oder Code auszuführen, der den Hauptthread blockieren kann, z. B. einen, der mit Dateien arbeitet, API-Aufrufe ausführt, Datenbankabfragen durchführt, sich mit E / A befasst und so weiter.  Der Start solcher asynchroner Operationen wird in der <code>executor</code> Funktion ausgeführt.  Wenn der asynchrone Vorgang erfolgreich abgeschlossen wurde, wird das vom Versprechen erwartete Ergebnis durch Aufrufen der <code>resolve</code> .  Die Situation, in der diese Funktion aufgerufen wird, wird vom Schöpfer des Versprechens bestimmt.  Wenn ein Fehler auftritt, werden Informationen über das Geschehene durch Aufrufen der <code>reject</code> . <br><br>  Jetzt, da wir allgemein wissen, wie man Versprechen schafft, werden wir ein einfaches Versprechen erstellen, um alles besser zu verstehen. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise hat einen Status (PromiseStatus) und einen Wert (PromiseValue)</font></i> <br><br>  Da unser Versprechen sofort gelöst wird, können wir seinen Ausgangszustand nicht untersuchen.  Lassen Sie uns daher ein neues Versprechen erstellen, das zur Lösung einige Zeit benötigt.  Der einfachste Weg, dies zu tun, ist die Verwendung der Funktion <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  In diesem Code wird ein Versprechen erstellt, das sich mit Sicherheit in 10 Sekunden auflöst.  Dies gibt uns die Möglichkeit, den Zustand eines nicht autorisierten Versprechens zu betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Ungelöstes Versprechen</font></i> <br><br>  Nach Ablauf von 10 Sekunden wird das Versprechen gelöst.  Infolgedessen werden sowohl <code>PromiseStatus</code> als auch <code>PromiseValue</code> entsprechend aktualisiert.  Wie Sie sehen können, haben wir in diesem Beispiel die Funktion geändert, die aufgerufen wurde, als das Versprechen erfolgreich aufgelöst wurde. Jetzt wird keine gewöhnliche Zeichenfolge, sondern ein Objekt zurückgegeben.  Dies geschieht, um die Fähigkeit zu demonstrieren, komplexe Datenstrukturen mithilfe der <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Das Versprechen wurde nach 10 Sekunden gelöst und ein Objekt zurückgegeben</font></i> <br><br>  Schauen wir uns nun das Versprechen an, das wir nicht zulassen, sondern ablehnen wollten.  Dazu ändern wir den Code, der bereits im ersten Beispiel verwendet wurde. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Da wir die Situation der Ablehnung des Versprechens nicht behandeln, wird in der Browserkonsole eine Fehlermeldung angezeigt (hier wird Google Chrome verwendet).  Wir werden weiter unten mehr darüber sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Abgelehntes Versprechen</font></i> <br><br>  Nachdem wir alle drei Beispiele analysiert haben, können wir sehen, dass in <code>PromiseStatus</code> drei verschiedene Werte <code>PromiseStatus</code> : <code>pending</code> (ausstehend), <code>resolved</code> (erfolgreiche Auflösung) und <code>rejected</code> (abgelehnt).  Wenn ein Versprechen erstellt wird, <code>PromiseStatus</code> in <code>PromiseStatus</code> <code>pending</code> und in <code>PromiseValue</code> <code>undefined</code> .  Diese Werte bleiben bestehen, bis das Versprechen gelöst oder abgelehnt wird.  Wenn sich ein Versprechen in einem <code>resolved</code> oder <code>rejected</code> Zustand befindet, wird es als festgelegtes Versprechen bezeichnet.  Ein solches Versprechen ist von einem Wartezustand in einen Zustand übergegangen, in dem es entweder einen <code>resolved</code> Zustand oder einen <code>rejected</code> Zustand hat. <br><br>  Nachdem wir gelernt haben, wie Versprechen erstellt werden, können wir darüber sprechen, wie wir verarbeiten können, was sie zurückgeben.  Um dies herauszufinden, müssen wir die Struktur des <code>Promise</code> Objekts verstehen. <br><br><h2>  <font color="#3AC1EF">Versprechen Objekt</font> </h2><br>  Gemäß der MDN-Dokumentation ist ein <code>Promise</code> Objekt das Ergebnis eines erfolgreichen oder erfolglosen Abschlusses einer asynchronen Operation. <br><br>  Das <code>Promise</code> Objekt verfügt über statische Methoden und Prototypmethoden des Objekts.  Statische Methoden können aufgerufen werden, ohne eine Instanz des Objekts zu erstellen. Um die Prototypmethoden aufzurufen, benötigen Sie eine Instanz des <code>Promise</code> Objekts.  Beachten Sie, dass sowohl statische als auch reguläre Methoden <code>Promise</code> Objekte zurückgeben.  Dies erleichtert die Arbeit. <br><br><h3>  <font color="#3AC1EF">▍ Versprechen Sie Methoden für Objektprototypen</font> </h3><br>  Lassen Sie uns zunächst über die Prototypmethoden des <code>Promise</code> Objekts sprechen.  Es gibt drei solche Methoden.  Vergessen Sie nicht, dass diese Methoden für die <code>Promise</code> Objektinstanz aufgerufen werden können und dass sie selbst die Versprechen zurückgeben.  Dank all dieser Methoden können Sie Handler zuweisen, die auf Änderungen im Status von Versprechungen reagieren.  Wie wir bereits gesehen haben, befindet sich ein Versprechen, wenn es erstellt wird, in einem <code>pending</code> Zustand.  Wenn ein Versprechen in einen <code>resolved</code> oder <code>rejected</code> Zustand <code>rejected</code> , wird mindestens eine der folgenden Methoden aufgerufen: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Unten sehen Sie ein Diagramm der Funktionsweise des Versprechens und der Ereignisse, die zum Aufruf der <code>.catch</code> <code>.then</code> und <code>.catch</code> .  Da diese Methoden <code>Promise</code> Objekte zurückgeben, können ihre Aufrufe verkettet werden. Dies spiegelt sich auch im Diagramm wider.  Wenn das Versprechen die <code>.finally</code> Methode verwendet, wird es aufgerufen, wenn das Versprechen in den festgelegten Zustand versetzt wird, unabhängig davon, ob das Versprechen erfolgreich gelöst oder abgelehnt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Promis-Arbeitsschema (Bild <a href="">von hier</a> )</font></i> <br><br>  Hier ist eine kurze Geschichte.  Sie sind Student und bitten Ihre Mutter, Ihnen ein Handy zu kaufen.  Sie sagt: "Wenn unsere Ersparnisse mehr sind als die Kosten des Telefons, werde ich es für Sie kaufen."  Erzählen Sie diese Geschichte jetzt in JavaScript nach. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Mama hat kein Versprechen gehalten</font></i> <br><br>  Wenn wir den Wert der Variablen <code>momsSavings</code> auf 200.000 <code>momsSavings</code> , kann Mutter ein Geschenk für ihren Sohn kaufen.  In diesem Fall gibt der obige Code Folgendes aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Mama hat ein Versprechen gehalten</font></i> <br><br>  Stellen wir uns nun vor, dass der betreffende Code als Bibliothek konzipiert ist und wir diese Bibliothek verwenden.  Lassen Sie uns über die effektive Verwendung der <code>.catch</code> <code>.then</code> und <code>.catch</code> . <br><br>  Da der <code>.then</code> Methode sowohl der <code>onFulfilled</code> Handler <code>.then</code> werden kann, der <code>onFulfilled</code> wird, wenn das Versprechen erfolgreich aufgelöst wurde, als auch der <code>onRejected</code> Handler, der aufgerufen wird, wenn das Versprechen abgelehnt wird, anstatt sowohl die <code>.then</code> Methode als auch die <code>.catch</code> Methode zu verwenden, können wir denselben Effekt mit nur einem erzielen <code>.then</code> Methode.  So könnte es aussehen: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Dies ist ein funktionierendes Beispiel, aber um die Lesbarkeit des Codes zu verhindern, ist es besser, die Methoden <code>.then</code> und <code>.catch</code> anstelle einer universellen <code>.then</code> . <br><br>  Damit diese Beispiele in einem Browser und speziell in Google Chrome ausgeführt werden können, habe ich versucht, externe Abhängigkeiten zu vermeiden.  Um besser zu verstehen, was wir später betrachten werden, erstellen wir eine Funktion, die ein Versprechen zurückgibt, dessen Auflösung oder Ablehnung zufällig erfolgt.  Auf diese Weise können wir verschiedene Szenarien der Arbeit mit Versprechungen erleben.  Um die Merkmale asynchroner Funktionen zu verstehen, werden wir in unseren Versprechungen zufällige Verzögerungen festlegen.  Da wir Zufallszahlen benötigen, erstellen wir eine Funktion, die eine Zufallszahl zwischen <code>x</code> und <code>y</code> zurückgibt.  Hier ist die Funktion. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Erstellen Sie nun eine Funktion, die Versprechen zurückgibt.  <code>promiseTRRARNOSG</code> es <code>promiseTRRARNOSG</code> .  Der Name dieser Funktion steht für <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> es handelt sich um einen Generator von Versprechungen, die nach einer zufälligen Anzahl von Sekunden zufällig aufgelöst oder abgelehnt werden.  Diese Funktion erstellt ein Versprechen, das nach einer zufälligen Zeitspanne zwischen 2 und 10 Sekunden zugelassen oder abgelehnt wird.  Um ein Versprechen zufällig zuzulassen oder abzulehnen, erhalten wir eine Zufallszahl zwischen 1 und 10. Wenn diese Zahl mehr als 5 beträgt, wird das Versprechen zugelassen, andernfalls wird es abgelehnt. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Führen Sie diesen Code in der Browserkonsole aus, um zu sehen, wie sich zulässige und abgelehnte Versprechen verhalten.  Als nächstes werden wir darüber sprechen, wie Sie viele Versprechen erstellen und die Ergebnisse ihrer Implementierung mithilfe anderer Mechanismen überprüfen können. <br><br><h3>  <font color="#3AC1EF">▍Statische Methoden eines Promise-Objekts</font> </h3><br>  Es gibt vier statische Methoden für ein <code>Promise</code> Objekt. <br><br>  Hier sind zwei Methoden - <code>Promise.reject(reason)</code> und <code>Promise.resolve(value)</code> , mit denen Sie abgelehnte bzw. zulässige Versprechen erstellen können. <br><br>  Hier <code>Promise.reject</code> , wie Sie mit der <code>Promise.reject</code> Methode arbeiten, mit der abgelehnte Versprechen erstellt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Hier ist ein Beispiel mit der <code>Promise.resolve</code> Methode, mit der erfolgreich aufgelöste Versprechen erstellt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Es sollte beachtet werden, dass ein Versprechen mehrere Handler haben kann.  Basierend auf dem vorherigen Beispiel können Sie beispielsweise den unten gezeigten Code erhalten. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Folgendes wird in der Browserkonsole angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Verwenden Sie mehrere .then, wenn Sie mit Promise arbeiten</font></i> <br><br>  Die folgenden beiden Methoden, <code>Promise.all</code> und <code>Promise.race</code> , funktionieren mit Versprechungen.  Wenn zur Lösung eines bestimmten Problems mehrere Versprechen verarbeitet werden müssen, ist es am bequemsten, diese Versprechen in einem Array zu platzieren und dann die erforderlichen Aktionen mit ihnen auszuführen.  Um das Wesentliche der hier betrachteten Methoden zu verstehen, können wir unsere praktische Funktion <code>promiseTRRARNOSG</code> , da das Ergebnis seiner Arbeit zu stark vom Willen des Einzelfalls abhängt.  Es wird für uns bequemer sein, etwas zu verwenden, das vorhersehbarere Versprechen hervorbringt, die es uns ermöglichen, ihr Verhalten zu verstehen.  Daher werden wir zwei neue Funktionen erstellen.  Einer von ihnen ( <code>promiseTRSANSG</code> ) erstellt Versprechen, die nach <code>n</code> Sekunden aufgelöst werden, der zweite ( <code>promiseTRJANSG</code> ) - Versprechen, die nach <code>n</code> Sekunden abgelehnt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Jetzt werden wir diese Funktionen verwenden, um die Funktionen der <code>Promise.all</code> Methode zu verstehen. <br><br><h3>  <font color="#3AC1EF">▍ Methode Promise.all</font> </h3><br>  In der MDN-Dokumentation können Sie feststellen, dass die Methode <code>Promise.all(iterable)</code> ein Versprechen zurückgibt, das aufgelöst wird, wenn alle als <code>iterable</code> Argument übergebenen Versprechen <code>iterable</code> werden oder wenn dieses Argument keine Versprechen enthält.  Dieses Versprechen wird abgelehnt, wenn eines der übertragenen Versprechen abgelehnt wird. <br>  Schauen wir uns einige Beispiele an. <br><br><h4>  Beispiel Nr. 1 </h4><br>  Alle Versprechen werden hier erlaubt sein.  Dieses Szenario ist am häufigsten. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Dieser Code gibt Folgendes an die Konsole aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Alle Versprechen erlaubt</font></i> <br><br>  Nach der Analyse der Ergebnisse dieses Beispiels können zwei wichtige Beobachtungen gemacht werden. <br><br>  Erstens wird das dritte Versprechen, dessen Auflösung 2 Sekunden dauert, vor dem zweiten abgeschlossen, aber wie aus der vom Code erzeugten Ausgabe hervorgeht, bleibt die Reihenfolge der Versprechen im Array erhalten. <br><br>  Zweitens enthält der Code einen Timer, mit dem ermittelt wird, wie lange es dauert, die Anweisung <code>Promise.all</code> auszuführen. <br><br>  Wenn Versprechen nacheinander ausgeführt würden, würde die Ausführungszeit dieser Anweisung 7 Sekunden betragen (1 + 4 + 2).  Der Timer teilt uns jedoch mit, dass der gesamte Vorgang 4 Sekunden gedauert hat, wenn wir das Ergebnis gerundet haben.  Dies ist ein Beweis dafür, dass alle Versprechen parallel ausgeführt werden. <br><br><h4>  Beispiel Nr. 2 </h4><br>  Betrachten Sie nun die Situation, in der das an Promise.all übergebene Array keine Versprechen enthält.  Ich glaube, dies ist der am wenigsten verbreitete Anwendungsfall für diese Funktion. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Hier ist die Ausgabe, die dieser Code generiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Rufen Sie Promise.all auf und übergeben Sie ein Array, das keine Versprechen enthält, an diese Methode</font></i> <br><br>  Da das Array keine Versprechen enthält, wird <code>Promise.all</code> fast sofort aufgelöst. <br><br><h4>  Beispiel Nr. 3 </h4><br>  Schauen wir uns nun an, was passiert, wenn eines der an <code>Promise.all</code> Versprechen abgelehnt wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Wie Sie den unten gezeigten Ergebnissen der Codeausführung entnehmen können, <code>Promise.all</code> Ausführung von <code>Promise.all</code> nach dem ersten abgelehnten Versprechen mit der Ausgabe der Nachricht, die dieses Versprechen gibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">Die Ausführung stoppt nach dem ersten abgelehnten Versprechen</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Promise.race-Methode</font> </h3><br>  MDN meldet, dass die <code>Promise.race(iterable)</code> Methode <code>Promise.race(iterable)</code> ein zulässiges oder abgelehntes Versprechen mit einem Wert oder Grund für die Ablehnung zurückgibt, nachdem eines der übertragenen Versprechen zulässig bzw. abgelehnt wurde. <br><br>  <code>Promise.race</code> wir <code>Promise.race</code> Beispiele für die Arbeit mit <code>Promise.race</code> . <br><br><h4>  Beispiel Nr. 1 </h4><br>  Es zeigt, was passiert, wenn eines der an <code>Promise.race</code> Versprechen vor allen anderen gelöst wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Dies gelangt nach Ausführung dieses Beispiels zur Konsole. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, das sich schneller auflöste als alle anderen</font></i> <br><br>  Alle Versprechen werden hier parallel ausgeführt.  Das dritte Versprechen ist nach 2 Sekunden gelöst.  Sobald dies geschieht, wird das von <code>Promise.race</code> Versprechen aufgelöst. <br><br><h4>  Beispiel Nr. 2 </h4><br>  Betrachten Sie nun die Situation, in der eines der an <code>Promise.race</code> Versprechen abgelehnt wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Nach dem Ausführen dieses Beispiels gelangt Folgendes zur Konsole: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Versprechen vor allen anderen abgelehnt</font></i> <br><br>  Versprechen werden hier wie in den vorherigen Beispielen parallel ausgeführt.  Das vierte Versprechen wird nach 3 Sekunden abgelehnt.  Sobald dies geschieht, wird das von <code>Promise.race</code> zurückgegebene Versprechen abgelehnt. <br><br><h2>  <font color="#3AC1EF">Allgemeines Beispiel und Experimente</font> </h2><br>  Ich habe alle Beispiele, die wir in diesem Material betrachtet haben, an einem Ort gesammelt, um es einfacher zu machen, mit ihnen zu experimentieren und verschiedene Szenarien für die Arbeit mit Versprechungen zu untersuchen.  Dieser Code kann in einem Browser ausgeführt werden. Daher verwenden wir hier keine API-Aufrufe, greifen nicht auf Dateivorgänge zu und arbeiten nicht mit Datenbanken.  Obwohl all dies in der Entwicklung realer Projekte Anwendung findet, glaube ich, dass die Arbeit mit diesen Mechanismen uns von unserem Hauptziel - den Versprechen - ablenken kann.  Die Verwendung einfacher Funktionen, die Zeitverzögerungen simulieren, führt zu ähnlichen Ergebnissen und belastet uns nicht mit zusätzlichen Details. <br><br>  Indem Sie diese Beispiele selbst untersuchen, können Sie mit dem Code und den Werten der Variablen experimentieren und verschiedene Szenarien für die Verwendung von Versprechungen untersuchen.  Insbesondere können Sie eine Kombination aus den <code>promiseTRJANSG</code> <code>promiseTRSANSG</code> <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> und <code>promiseTRRARNOSG</code> verwenden, um viele Szenarien für die Verwendung von Versprechungen zu simulieren, mit denen Sie sie besser verstehen können.  Beachten Sie außerdem, dass Sie mit dem Befehl <code>console.time</code> die Zeit ermitteln können, die zum Ausführen eines bestimmten Codeteils erforderlich ist, und beispielsweise herausfinden können, ob Versprechen parallel oder nacheinander ausgeführt werden.  Hier ist ein <a href="">Link</a> zur Hauptseite mit dem Code.  Übrigens, wenn Sie möchten, schauen Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bluebird-</a> Bibliothek an, die einige interessante Methoden für die Arbeit mit Versprechungen enthält. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich biete Ihnen eine Liste von Regeln an, die ich bei der Arbeit mit Versprechungen einhalte, um sie richtig anzuwenden. <br><br><ol><li>  Verwenden Sie Versprechen in Situationen, in denen Sie mit asynchronem oder blockierendem Code arbeiten. </li><li>  Verwenden Sie die Methode <code>.then</code> um die Situation einer erfolgreichen Lösung eines Versprechens zu bewältigen. Verwenden <code>.then</code> Fällen, in denen das Versprechen abgelehnt wird, <code>.catch</code> . </li><li>  Verwenden <code>.then</code> in allen Versprechungen die <code>.catch</code> <code>.then</code> und <code>.catch</code> . </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Liebe Leser!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418085/">https://habr.com/ru/post/de418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418075/index.html">TOP 5 Dinge, die auf einem 3D-Drucker gedruckt werden können [Video]</a></li>
<li><a href="../de418077/index.html">Unfälle mit „Nicht beobachten“: eine statistische Begründung für die Betriebsart des technischen Supports rund um die Uhr</a></li>
<li><a href="../de418079/index.html">Die beliebtesten Programmiersprachen - 2018</a></li>
<li><a href="../de418081/index.html">Organisation sicherer Tests in der Produktion. Teil 1</a></li>
<li><a href="../de418083/index.html">Einfacher Server mit GraphQL anstelle von REST, Implementierung in Java</a></li>
<li><a href="../de418087/index.html">80% der Selbstbedienungskassen sind gefährdet</a></li>
<li><a href="../de418089/index.html">SolidCraft CNC-Fräsmaschine Übersicht</a></li>
<li><a href="../de418091/index.html">Liste der Artikel und Literatur zu NAS</a></li>
<li><a href="../de418093/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 2</a></li>
<li><a href="../de418095/index.html">Über das Gerät der eingebauten Testfunktionalität in Rust (Übersetzung)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>