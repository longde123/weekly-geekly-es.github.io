<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß üëâüèª üë®‚Äçüè´ Versprechen in JavaScript verwenden üë®üèæ‚Äçüî¨ üîØ üë®üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit ver√∂ffentlichen wir Materialien, die sich auf die eine oder andere Weise auf die Verwendung von Versprechungen in JavaScript beziehen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versprechen in JavaScript verwenden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  Von Zeit zu Zeit ver√∂ffentlichen wir Materialien, die sich auf die eine oder andere Weise auf die Verwendung von Versprechungen in JavaScript beziehen. <br><br><div class="spoiler">  <b class="spoiler_title">Hier sind einige davon.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versprechen in ES6: Muster und Anti-Muster</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript: asynchrone Programmiermethoden</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript ES8 und √úbergang zu async / await</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async / warten: 6 Gr√ºnde, Versprechen zu vergessen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flucht aus der H√∂lle asynchron / warten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript ES6: weniger schreiben - mehr tun</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versprechen Leitfaden f√ºr diejenigen, die verstehen wollen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrones / wartendes JavaScript-Design: St√§rken, Fallstricke und Verwendungsmuster</a> </div></div><br>  Warum wird so viel Aufmerksamkeit auf Versprechen gelenkt?  Wir glauben, dass der springende Punkt ist, dass diese Technologie sehr gefragt ist und dass es ziemlich schwer zu verstehen ist. <br><br>  Wenn Sie die Versprechen besser verstehen m√∂chten, bieten wir Ihnen daher eine √úbersetzung des n√§chsten Artikels zu diesem Thema an.  Sein Autor sagt, dass er Java und PHP in den letzten 10 Jahren entwickelt hat, aber die ganze Zeit hat er sich mit Interesse f√ºr JavaScript interessiert.  Vor kurzem beschloss er, sich ernsthaft mit JS zu besch√§ftigen, und Versprechen wurden das erste Thema, das ihn interessierte. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Wir glauben, dass dieses Material f√ºr unerfahrene Entwickler interessant sein wird, die das Gef√ºhl haben, dass sie, obwohl sie Versprechen verwenden, diese nicht gut genug verstehen.  Es ist m√∂glich, dass die Geschichte von jemandem, der JavaScript mit einem frischen Blick betrachtet und anderen erkl√§ren m√∂chte, was er selbst verstanden hat, ohne zu glauben, dass einige Dinge f√ºr alle verst√§ndlich sind und ohne Erkl√§rung, Anf√§ngern hilft, JavaScript-Mechanismen zu beherrschen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript mit den Augen eines Anf√§ngers</font> </h2><br>  Jeder, der anf√§ngt, in JavaScript zu schreiben, kann f√ºhlen, was als "fehl am Platz" bezeichnet wird.  Einige sagen, dass JS eine synchrone Programmiersprache ist, andere sagen, dass es asynchron ist.  Ein Neuling erf√§hrt von Code, der den Hauptthread blockiert, und von Code, der ihn nicht blockiert, von ereignisbasierten Entwurfsmustern, vom Lebenszyklus von Ereignissen, vom Stapel von Funktionsaufrufen, von der Warteschlange von Ereignissen und deren Aufstieg, von Polyfills.  Er erf√§hrt, dass es solche Dinge wie Babel, Angular, React, Vue und eine Vielzahl anderer Bibliotheken gibt.  Wenn Sie sich gerade in einem solchen ‚ÄûAnf√§nger‚Äú wiedererkannt haben - machen Sie sich dar√ºber keine Sorgen.  Du bist weder der Erste noch der Letzte.  Daf√ºr gibt es sogar einen Begriff - die sogenannte ‚ÄûJavaScript-M√ºdigkeit‚Äú.  Lucas F. Costa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">sprach</a> treffend zu diesem Thema: " <i>JavaScript-M√ºdigkeit kann beobachtet werden, wenn Benutzer Tools verwenden, die sie nicht ben√∂tigen, um Probleme zu l√∂sen, die sie nicht haben</i> ." <br><br>  Aber reden wir nicht √ºber traurige Dinge.  JavaScript ist also eine synchrone Programmiersprache, mit der Sie dank des R√ºckrufmechanismus Funktionen auf die gleiche Weise wie in asynchronen Sprachen aufrufen k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Eine einfache Geschichte √ºber Versprechen</font> </h2><br>  Das Wort Versprechen bedeutet Versprechen.  Versprechen Objekte in der Programmierung, die wir "Versprechen" nennen, sind den √ºblichen Versprechen, die sich Menschen im wirklichen Leben gegenseitig geben, sehr √§hnlich.  Sprechen wir also zuerst √ºber diese Versprechen. <br><br>  Auf Wikipedia finden Sie die folgende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition des</a> Wortes ‚ÄûVersprechen‚Äú: ‚ÄûVerpflichtung, Zustimmung von jemandem, etwas zu erf√ºllen oder im Gegenteil nicht zu tun‚Äú.  In Ozhegovs W√∂rterbuch ist "Versprechen" "eine freiwillige Verpflichtung, etwas zu tun". <br><br>  Was wissen wir √ºber Versprechen? <br><br><ol><li>  Ein Versprechen gibt Ihnen die Garantie, dass etwas getan wird.  Es spielt keine Rolle, wer genau dies tut: derjenige, der das Versprechen gegeben hat, oder jemand anderes auf Anfrage desjenigen, der das Versprechen gegeben hat.  Ein Versprechen gibt Vertrauen in etwas, basierend auf diesem Vertrauen kann derjenige, der das Versprechen erhalten hat, zum Beispiel einige Pl√§ne machen. </li><li>  Ein Versprechen kann entweder erf√ºllt werden oder nicht. </li><li>  Wenn das Versprechen erf√ºllt ist, erwarten Sie daher etwas, das Sie in Zukunft verwenden k√∂nnen, um Ma√ünahmen durchzuf√ºhren oder Pl√§ne umzusetzen. </li><li>  Wenn das Versprechen nicht erf√ºllt wird, m√∂chten Sie herausfinden, warum derjenige, der es gegeben hat, es nicht erf√ºllen konnte.  Nachdem Sie den Grund f√ºr das Geschehene herausgefunden haben und sicher sind, dass das Versprechen nicht erf√ºllt wurde, k√∂nnen Sie √ºberlegen, was als N√§chstes zu tun ist oder wie Sie mit der Situation umgehen sollen. </li><li>  Nachdem Ihnen etwas versprochen wurde, haben Sie nur eine Art Garantie.  Sie k√∂nnen das, was Ihnen versprochen wird, nicht sofort nutzen.  Sie k√∂nnen selbst bestimmen, was Sie tun m√ºssen, wenn das Versprechen erf√ºllt ist (daher erhalten Sie das Versprechen), und was Sie tun m√ºssen, wenn es sich als fehlerhaft herausstellt (in diesem Fall kennen Sie den Grund f√ºr das, was passiert ist, und k√∂nnen daher √ºber einen Sicherungsplan nachdenken ) </li><li>  Es ist wahrscheinlich, dass die Person, die das Versprechen gegeben hat, einfach verschwindet.  In solchen F√§llen ist es n√ºtzlich, dass das Versprechen an einen bestimmten Zeitrahmen gebunden ist.  Wenn beispielsweise derjenige, der Ihnen das Versprechen gegeben hat, nicht innerhalb von 10 Tagen erscheint, k√∂nnen Sie davon ausgehen, dass er einige Probleme hatte und das Versprechen gebrochen hat.  Selbst wenn derjenige, der das Versprechen abgegeben hat, es in 15 Tagen erf√ºllt, spielt dies keine Rolle. Sie handeln also bereits nach dem alternativen Plan und verlassen sich nicht auf das Versprechen. </li></ol><br>  Fahren Sie nun mit JavaScript fort. <br><br><h2>  <font color="#3AC1EF">JavaScript verspricht</font> </h2><br>  Ich habe eine Regel: Wenn ich JavaScript mache, lese ich immer die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> , die auf MDN zu finden ist.  Es scheint mir, dass diese Ressource in Bezug auf Spezifit√§t und Klarheit der Darstellung im Vergleich zu den anderen g√ºnstig ist.  W√§hrend ich Versprechen studierte, machte ich mich daher mit dem relevanten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> vertraut und experimentierte mit dem Code, um mich an die neuen Syntaxkonstrukte zu gew√∂hnen. <br><br>  Um die Versprechen zu verstehen, m√ºssen Sie sich mit zwei Hauptsachen befassen.  Das erste ist die Schaffung von Versprechungen.  Die zweite ist die Verarbeitung der von den Versprechungen zur√ºckgegebenen Ergebnisse.  Obwohl der gr√∂√üte Teil des Codes, den wir schreiben, darauf abzielt, mit Versprechungen zu arbeiten, die beispielsweise von bestimmten Bibliotheken erstellt wurden, wird ein umfassendes Verst√§ndnis der Mechanismen der Arbeit von Versprechungen zweifellos n√ºtzlich sein.  F√ºr einen Programmierer, der bereits Erfahrung hat, ist es ebenso wichtig zu wissen, wie man Versprechen erstellt, wie zu wissen, wie man mit ihnen arbeitet. <br><br><h2>  <font color="#3AC1EF">Versprechen erstellen</font> </h2><br>  So entstehen Versprechen: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  Der Konstruktor akzeptiert eine Funktion, die bestimmte Aktionen ausf√ºhrt. Wir haben sie hier <code>executor</code> .  Diese Funktion ben√∂tigt zwei Parameter - <code>resolve</code> und <code>reject</code> , die wiederum ebenfalls Funktionen sind.  Versprechungen werden normalerweise verwendet, um asynchrone Vorg√§nge oder Code auszuf√ºhren, der den Hauptthread blockieren kann, z. B. einen, der mit Dateien arbeitet, API-Aufrufe ausf√ºhrt, Datenbankabfragen durchf√ºhrt, sich mit E / A befasst und so weiter.  Der Start solcher asynchroner Operationen wird in der <code>executor</code> Funktion ausgef√ºhrt.  Wenn der asynchrone Vorgang erfolgreich abgeschlossen wurde, wird das vom Versprechen erwartete Ergebnis durch Aufrufen der <code>resolve</code> .  Die Situation, in der diese Funktion aufgerufen wird, wird vom Sch√∂pfer des Versprechens bestimmt.  Wenn ein Fehler auftritt, werden Informationen √ºber das Geschehene durch Aufrufen der <code>reject</code> . <br><br>  Jetzt, da wir allgemein wissen, wie man Versprechen schafft, werden wir ein einfaches Versprechen erstellen, um alles besser zu verstehen. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise hat einen Status (PromiseStatus) und einen Wert (PromiseValue)</font></i> <br><br>  Da unser Versprechen sofort gel√∂st wird, k√∂nnen wir seinen Ausgangszustand nicht untersuchen.  Lassen Sie uns daher ein neues Versprechen erstellen, das zur L√∂sung einige Zeit ben√∂tigt.  Der einfachste Weg, dies zu tun, ist die Verwendung der Funktion <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  In diesem Code wird ein Versprechen erstellt, das sich mit Sicherheit in 10 Sekunden aufl√∂st.  Dies gibt uns die M√∂glichkeit, den Zustand eines nicht autorisierten Versprechens zu betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Ungel√∂stes Versprechen</font></i> <br><br>  Nach Ablauf von 10 Sekunden wird das Versprechen gel√∂st.  Infolgedessen werden sowohl <code>PromiseStatus</code> als auch <code>PromiseValue</code> entsprechend aktualisiert.  Wie Sie sehen k√∂nnen, haben wir in diesem Beispiel die Funktion ge√§ndert, die aufgerufen wurde, als das Versprechen erfolgreich aufgel√∂st wurde. Jetzt wird keine gew√∂hnliche Zeichenfolge, sondern ein Objekt zur√ºckgegeben.  Dies geschieht, um die F√§higkeit zu demonstrieren, komplexe Datenstrukturen mithilfe der <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Das Versprechen wurde nach 10 Sekunden gel√∂st und ein Objekt zur√ºckgegeben</font></i> <br><br>  Schauen wir uns nun das Versprechen an, das wir nicht zulassen, sondern ablehnen wollten.  Dazu √§ndern wir den Code, der bereits im ersten Beispiel verwendet wurde. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Da wir die Situation der Ablehnung des Versprechens nicht behandeln, wird in der Browserkonsole eine Fehlermeldung angezeigt (hier wird Google Chrome verwendet).  Wir werden weiter unten mehr dar√ºber sprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Abgelehntes Versprechen</font></i> <br><br>  Nachdem wir alle drei Beispiele analysiert haben, k√∂nnen wir sehen, dass in <code>PromiseStatus</code> drei verschiedene Werte <code>PromiseStatus</code> : <code>pending</code> (ausstehend), <code>resolved</code> (erfolgreiche Aufl√∂sung) und <code>rejected</code> (abgelehnt).  Wenn ein Versprechen erstellt wird, <code>PromiseStatus</code> in <code>PromiseStatus</code> <code>pending</code> und in <code>PromiseValue</code> <code>undefined</code> .  Diese Werte bleiben bestehen, bis das Versprechen gel√∂st oder abgelehnt wird.  Wenn sich ein Versprechen in einem <code>resolved</code> oder <code>rejected</code> Zustand befindet, wird es als festgelegtes Versprechen bezeichnet.  Ein solches Versprechen ist von einem Wartezustand in einen Zustand √ºbergegangen, in dem es entweder einen <code>resolved</code> Zustand oder einen <code>rejected</code> Zustand hat. <br><br>  Nachdem wir gelernt haben, wie Versprechen erstellt werden, k√∂nnen wir dar√ºber sprechen, wie wir verarbeiten k√∂nnen, was sie zur√ºckgeben.  Um dies herauszufinden, m√ºssen wir die Struktur des <code>Promise</code> Objekts verstehen. <br><br><h2>  <font color="#3AC1EF">Versprechen Objekt</font> </h2><br>  Gem√§√ü der MDN-Dokumentation ist ein <code>Promise</code> Objekt das Ergebnis eines erfolgreichen oder erfolglosen Abschlusses einer asynchronen Operation. <br><br>  Das <code>Promise</code> Objekt verf√ºgt √ºber statische Methoden und Prototypmethoden des Objekts.  Statische Methoden k√∂nnen aufgerufen werden, ohne eine Instanz des Objekts zu erstellen. Um die Prototypmethoden aufzurufen, ben√∂tigen Sie eine Instanz des <code>Promise</code> Objekts.  Beachten Sie, dass sowohl statische als auch regul√§re Methoden <code>Promise</code> Objekte zur√ºckgeben.  Dies erleichtert die Arbeit. <br><br><h3>  <font color="#3AC1EF">‚ñç Versprechen Sie Methoden f√ºr Objektprototypen</font> </h3><br>  Lassen Sie uns zun√§chst √ºber die Prototypmethoden des <code>Promise</code> Objekts sprechen.  Es gibt drei solche Methoden.  Vergessen Sie nicht, dass diese Methoden f√ºr die <code>Promise</code> Objektinstanz aufgerufen werden k√∂nnen und dass sie selbst die Versprechen zur√ºckgeben.  Dank all dieser Methoden k√∂nnen Sie Handler zuweisen, die auf √Ñnderungen im Status von Versprechungen reagieren.  Wie wir bereits gesehen haben, befindet sich ein Versprechen, wenn es erstellt wird, in einem <code>pending</code> Zustand.  Wenn ein Versprechen in einen <code>resolved</code> oder <code>rejected</code> Zustand <code>rejected</code> , wird mindestens eine der folgenden Methoden aufgerufen: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Unten sehen Sie ein Diagramm der Funktionsweise des Versprechens und der Ereignisse, die zum Aufruf der <code>.catch</code> <code>.then</code> und <code>.catch</code> .  Da diese Methoden <code>Promise</code> Objekte zur√ºckgeben, k√∂nnen ihre Aufrufe verkettet werden. Dies spiegelt sich auch im Diagramm wider.  Wenn das Versprechen die <code>.finally</code> Methode verwendet, wird es aufgerufen, wenn das Versprechen in den festgelegten Zustand versetzt wird, unabh√§ngig davon, ob das Versprechen erfolgreich gel√∂st oder abgelehnt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Promis-Arbeitsschema (Bild <a href="">von hier</a> )</font></i> <br><br>  Hier ist eine kurze Geschichte.  Sie sind Student und bitten Ihre Mutter, Ihnen ein Handy zu kaufen.  Sie sagt: "Wenn unsere Ersparnisse mehr sind als die Kosten des Telefons, werde ich es f√ºr Sie kaufen."  Erz√§hlen Sie diese Geschichte jetzt in JavaScript nach. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Dieser Code gibt Folgendes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Mama hat kein Versprechen gehalten</font></i> <br><br>  Wenn wir den Wert der Variablen <code>momsSavings</code> auf 200.000 <code>momsSavings</code> , kann Mutter ein Geschenk f√ºr ihren Sohn kaufen.  In diesem Fall gibt der obige Code Folgendes aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Mama hat ein Versprechen gehalten</font></i> <br><br>  Stellen wir uns nun vor, dass der betreffende Code als Bibliothek konzipiert ist und wir diese Bibliothek verwenden.  Lassen Sie uns √ºber die effektive Verwendung der <code>.catch</code> <code>.then</code> und <code>.catch</code> . <br><br>  Da der <code>.then</code> Methode sowohl der <code>onFulfilled</code> Handler <code>.then</code> werden kann, der <code>onFulfilled</code> wird, wenn das Versprechen erfolgreich aufgel√∂st wurde, als auch der <code>onRejected</code> Handler, der aufgerufen wird, wenn das Versprechen abgelehnt wird, anstatt sowohl die <code>.then</code> Methode als auch die <code>.catch</code> Methode zu verwenden, k√∂nnen wir denselben Effekt mit nur einem erzielen <code>.then</code> Methode.  So k√∂nnte es aussehen: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Dies ist ein funktionierendes Beispiel, aber um die Lesbarkeit des Codes zu verhindern, ist es besser, die Methoden <code>.then</code> und <code>.catch</code> anstelle einer universellen <code>.then</code> . <br><br>  Damit diese Beispiele in einem Browser und speziell in Google Chrome ausgef√ºhrt werden k√∂nnen, habe ich versucht, externe Abh√§ngigkeiten zu vermeiden.  Um besser zu verstehen, was wir sp√§ter betrachten werden, erstellen wir eine Funktion, die ein Versprechen zur√ºckgibt, dessen Aufl√∂sung oder Ablehnung zuf√§llig erfolgt.  Auf diese Weise k√∂nnen wir verschiedene Szenarien der Arbeit mit Versprechungen erleben.  Um die Merkmale asynchroner Funktionen zu verstehen, werden wir in unseren Versprechungen zuf√§llige Verz√∂gerungen festlegen.  Da wir Zufallszahlen ben√∂tigen, erstellen wir eine Funktion, die eine Zufallszahl zwischen <code>x</code> und <code>y</code> zur√ºckgibt.  Hier ist die Funktion. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Erstellen Sie nun eine Funktion, die Versprechen zur√ºckgibt.  <code>promiseTRRARNOSG</code> es <code>promiseTRRARNOSG</code> .  Der Name dieser Funktion steht f√ºr <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> es handelt sich um einen Generator von Versprechungen, die nach einer zuf√§lligen Anzahl von Sekunden zuf√§llig aufgel√∂st oder abgelehnt werden.  Diese Funktion erstellt ein Versprechen, das nach einer zuf√§lligen Zeitspanne zwischen 2 und 10 Sekunden zugelassen oder abgelehnt wird.  Um ein Versprechen zuf√§llig zuzulassen oder abzulehnen, erhalten wir eine Zufallszahl zwischen 1 und 10. Wenn diese Zahl mehr als 5 betr√§gt, wird das Versprechen zugelassen, andernfalls wird es abgelehnt. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  F√ºhren Sie diesen Code in der Browserkonsole aus, um zu sehen, wie sich zul√§ssige und abgelehnte Versprechen verhalten.  Als n√§chstes werden wir dar√ºber sprechen, wie Sie viele Versprechen erstellen und die Ergebnisse ihrer Implementierung mithilfe anderer Mechanismen √ºberpr√ºfen k√∂nnen. <br><br><h3>  <font color="#3AC1EF">‚ñçStatische Methoden eines Promise-Objekts</font> </h3><br>  Es gibt vier statische Methoden f√ºr ein <code>Promise</code> Objekt. <br><br>  Hier sind zwei Methoden - <code>Promise.reject(reason)</code> und <code>Promise.resolve(value)</code> , mit denen Sie abgelehnte bzw. zul√§ssige Versprechen erstellen k√∂nnen. <br><br>  Hier <code>Promise.reject</code> , wie Sie mit der <code>Promise.reject</code> Methode arbeiten, mit der abgelehnte Versprechen erstellt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Hier ist ein Beispiel mit der <code>Promise.resolve</code> Methode, mit der erfolgreich aufgel√∂ste Versprechen erstellt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Es sollte beachtet werden, dass ein Versprechen mehrere Handler haben kann.  Basierend auf dem vorherigen Beispiel k√∂nnen Sie beispielsweise den unten gezeigten Code erhalten. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Folgendes wird in der Browserkonsole angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Verwenden Sie mehrere .then, wenn Sie mit Promise arbeiten</font></i> <br><br>  Die folgenden beiden Methoden, <code>Promise.all</code> und <code>Promise.race</code> , funktionieren mit Versprechungen.  Wenn zur L√∂sung eines bestimmten Problems mehrere Versprechen verarbeitet werden m√ºssen, ist es am bequemsten, diese Versprechen in einem Array zu platzieren und dann die erforderlichen Aktionen mit ihnen auszuf√ºhren.  Um das Wesentliche der hier betrachteten Methoden zu verstehen, k√∂nnen wir unsere praktische Funktion <code>promiseTRRARNOSG</code> , da das Ergebnis seiner Arbeit zu stark vom Willen des Einzelfalls abh√§ngt.  Es wird f√ºr uns bequemer sein, etwas zu verwenden, das vorhersehbarere Versprechen hervorbringt, die es uns erm√∂glichen, ihr Verhalten zu verstehen.  Daher werden wir zwei neue Funktionen erstellen.  Einer von ihnen ( <code>promiseTRSANSG</code> ) erstellt Versprechen, die nach <code>n</code> Sekunden aufgel√∂st werden, der zweite ( <code>promiseTRJANSG</code> ) - Versprechen, die nach <code>n</code> Sekunden abgelehnt werden. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Jetzt werden wir diese Funktionen verwenden, um die Funktionen der <code>Promise.all</code> Methode zu verstehen. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Promise.all</font> </h3><br>  In der MDN-Dokumentation k√∂nnen Sie feststellen, dass die Methode <code>Promise.all(iterable)</code> ein Versprechen zur√ºckgibt, das aufgel√∂st wird, wenn alle als <code>iterable</code> Argument √ºbergebenen Versprechen <code>iterable</code> werden oder wenn dieses Argument keine Versprechen enth√§lt.  Dieses Versprechen wird abgelehnt, wenn eines der √ºbertragenen Versprechen abgelehnt wird. <br>  Schauen wir uns einige Beispiele an. <br><br><h4>  Beispiel Nr. 1 </h4><br>  Alle Versprechen werden hier erlaubt sein.  Dieses Szenario ist am h√§ufigsten. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Dieser Code gibt Folgendes an die Konsole aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Alle Versprechen erlaubt</font></i> <br><br>  Nach der Analyse der Ergebnisse dieses Beispiels k√∂nnen zwei wichtige Beobachtungen gemacht werden. <br><br>  Erstens wird das dritte Versprechen, dessen Aufl√∂sung 2 Sekunden dauert, vor dem zweiten abgeschlossen, aber wie aus der vom Code erzeugten Ausgabe hervorgeht, bleibt die Reihenfolge der Versprechen im Array erhalten. <br><br>  Zweitens enth√§lt der Code einen Timer, mit dem ermittelt wird, wie lange es dauert, die Anweisung <code>Promise.all</code> auszuf√ºhren. <br><br>  Wenn Versprechen nacheinander ausgef√ºhrt w√ºrden, w√ºrde die Ausf√ºhrungszeit dieser Anweisung 7 Sekunden betragen (1 + 4 + 2).  Der Timer teilt uns jedoch mit, dass der gesamte Vorgang 4 Sekunden gedauert hat, wenn wir das Ergebnis gerundet haben.  Dies ist ein Beweis daf√ºr, dass alle Versprechen parallel ausgef√ºhrt werden. <br><br><h4>  Beispiel Nr. 2 </h4><br>  Betrachten Sie nun die Situation, in der das an Promise.all √ºbergebene Array keine Versprechen enth√§lt.  Ich glaube, dies ist der am wenigsten verbreitete Anwendungsfall f√ºr diese Funktion. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Hier ist die Ausgabe, die dieser Code generiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Rufen Sie Promise.all auf und √ºbergeben Sie ein Array, das keine Versprechen enth√§lt, an diese Methode</font></i> <br><br>  Da das Array keine Versprechen enth√§lt, wird <code>Promise.all</code> fast sofort aufgel√∂st. <br><br><h4>  Beispiel Nr. 3 </h4><br>  Schauen wir uns nun an, was passiert, wenn eines der an <code>Promise.all</code> Versprechen abgelehnt wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Wie Sie den unten gezeigten Ergebnissen der Codeausf√ºhrung entnehmen k√∂nnen, <code>Promise.all</code> Ausf√ºhrung von <code>Promise.all</code> nach dem ersten abgelehnten Versprechen mit der Ausgabe der Nachricht, die dieses Versprechen gibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">Die Ausf√ºhrung stoppt nach dem ersten abgelehnten Versprechen</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Promise.race-Methode</font> </h3><br>  MDN meldet, dass die <code>Promise.race(iterable)</code> Methode <code>Promise.race(iterable)</code> ein zul√§ssiges oder abgelehntes Versprechen mit einem Wert oder Grund f√ºr die Ablehnung zur√ºckgibt, nachdem eines der √ºbertragenen Versprechen zul√§ssig bzw. abgelehnt wurde. <br><br>  <code>Promise.race</code> wir <code>Promise.race</code> Beispiele f√ºr die Arbeit mit <code>Promise.race</code> . <br><br><h4>  Beispiel Nr. 1 </h4><br>  Es zeigt, was passiert, wenn eines der an <code>Promise.race</code> Versprechen vor allen anderen gel√∂st wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Dies gelangt nach Ausf√ºhrung dieses Beispiels zur Konsole. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, das sich schneller aufl√∂ste als alle anderen</font></i> <br><br>  Alle Versprechen werden hier parallel ausgef√ºhrt.  Das dritte Versprechen ist nach 2 Sekunden gel√∂st.  Sobald dies geschieht, wird das von <code>Promise.race</code> Versprechen aufgel√∂st. <br><br><h4>  Beispiel Nr. 2 </h4><br>  Betrachten Sie nun die Situation, in der eines der an <code>Promise.race</code> Versprechen abgelehnt wird. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Nach dem Ausf√ºhren dieses Beispiels gelangt Folgendes zur Konsole: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Versprechen vor allen anderen abgelehnt</font></i> <br><br>  Versprechen werden hier wie in den vorherigen Beispielen parallel ausgef√ºhrt.  Das vierte Versprechen wird nach 3 Sekunden abgelehnt.  Sobald dies geschieht, wird das von <code>Promise.race</code> zur√ºckgegebene Versprechen abgelehnt. <br><br><h2>  <font color="#3AC1EF">Allgemeines Beispiel und Experimente</font> </h2><br>  Ich habe alle Beispiele, die wir in diesem Material betrachtet haben, an einem Ort gesammelt, um es einfacher zu machen, mit ihnen zu experimentieren und verschiedene Szenarien f√ºr die Arbeit mit Versprechungen zu untersuchen.  Dieser Code kann in einem Browser ausgef√ºhrt werden. Daher verwenden wir hier keine API-Aufrufe, greifen nicht auf Dateivorg√§nge zu und arbeiten nicht mit Datenbanken.  Obwohl all dies in der Entwicklung realer Projekte Anwendung findet, glaube ich, dass die Arbeit mit diesen Mechanismen uns von unserem Hauptziel - den Versprechen - ablenken kann.  Die Verwendung einfacher Funktionen, die Zeitverz√∂gerungen simulieren, f√ºhrt zu √§hnlichen Ergebnissen und belastet uns nicht mit zus√§tzlichen Details. <br><br>  Indem Sie diese Beispiele selbst untersuchen, k√∂nnen Sie mit dem Code und den Werten der Variablen experimentieren und verschiedene Szenarien f√ºr die Verwendung von Versprechungen untersuchen.  Insbesondere k√∂nnen Sie eine Kombination aus den <code>promiseTRJANSG</code> <code>promiseTRSANSG</code> <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> und <code>promiseTRRARNOSG</code> verwenden, um viele Szenarien f√ºr die Verwendung von Versprechungen zu simulieren, mit denen Sie sie besser verstehen k√∂nnen.  Beachten Sie au√üerdem, dass Sie mit dem Befehl <code>console.time</code> die Zeit ermitteln k√∂nnen, die zum Ausf√ºhren eines bestimmten Codeteils erforderlich ist, und beispielsweise herausfinden k√∂nnen, ob Versprechen parallel oder nacheinander ausgef√ºhrt werden.  Hier ist ein <a href="">Link</a> zur Hauptseite mit dem Code.  √úbrigens, wenn Sie m√∂chten, schauen Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bluebird-</a> Bibliothek an, die einige interessante Methoden f√ºr die Arbeit mit Versprechungen enth√§lt. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich biete Ihnen eine Liste von Regeln an, die ich bei der Arbeit mit Versprechungen einhalte, um sie richtig anzuwenden. <br><br><ol><li>  Verwenden Sie Versprechen in Situationen, in denen Sie mit asynchronem oder blockierendem Code arbeiten. </li><li>  Verwenden Sie die Methode <code>.then</code> um die Situation einer erfolgreichen L√∂sung eines Versprechens zu bew√§ltigen. Verwenden <code>.then</code> F√§llen, in denen das Versprechen abgelehnt wird, <code>.catch</code> . </li><li>  Verwenden <code>.then</code> in allen Versprechungen die <code>.catch</code> <code>.then</code> und <code>.catch</code> . </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Liebe Leser!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418085/">https://habr.com/ru/post/de418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418075/index.html">TOP 5 Dinge, die auf einem 3D-Drucker gedruckt werden k√∂nnen [Video]</a></li>
<li><a href="../de418077/index.html">Unf√§lle mit ‚ÄûNicht beobachten‚Äú: eine statistische Begr√ºndung f√ºr die Betriebsart des technischen Supports rund um die Uhr</a></li>
<li><a href="../de418079/index.html">Die beliebtesten Programmiersprachen - 2018</a></li>
<li><a href="../de418081/index.html">Organisation sicherer Tests in der Produktion. Teil 1</a></li>
<li><a href="../de418083/index.html">Einfacher Server mit GraphQL anstelle von REST, Implementierung in Java</a></li>
<li><a href="../de418087/index.html">80% der Selbstbedienungskassen sind gef√§hrdet</a></li>
<li><a href="../de418089/index.html">SolidCraft CNC-Fr√§smaschine √úbersicht</a></li>
<li><a href="../de418091/index.html">Liste der Artikel und Literatur zu NAS</a></li>
<li><a href="../de418093/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Puffer√ºberl√§ufe: Exploits und Schutz, Teil 2</a></li>
<li><a href="../de418095/index.html">√úber das Ger√§t der eingebauten Testfunktionalit√§t in Rust (√úbersetzung)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>