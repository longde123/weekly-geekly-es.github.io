<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèΩ üë®üèæ‚Äçüè≠ üë¥üèº RayTracing compr√©hensible en 256 lignes de C ++ nu ü§µüèæ üè∞ üè≥Ô∏è‚Äçüåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RayTracing compr√©hensible en 256 lignes de C ++ nu 


 Ceci est un autre chapitre de mon bref cours de conf√©rences sur l'infographie . Cette fois, nou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RayTracing compr√©hensible en 256 lignes de C ++ nu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  RayTracing compr√©hensible en 256 lignes de C ++ nu </h1><br><p> Ceci est un autre chapitre de mon <a href="https://github.com/ssloy/tinyrenderer/wiki">bref cours de conf√©rences sur l'infographie</a> .  Cette fois, nous parlons du lancer de rayons.  Comme d'habitude, j'essaie d'√©viter les biblioth√®ques tierces, car je pense que cela permet aux √©tudiants de v√©rifier ce qui se passe sous le capot.  V√©rifiez √©galement le <a href="https://github.com/ssloy/tinykaboom/wiki">projet tinykaboom</a> . </p><br><p>  Il existe de nombreux articles sur le lancer de rayons sur le Web;  cependant, le probl√®me est que presque tous pr√©sentent des logiciels finis qui peuvent √™tre assez difficiles √† comprendre.  Prenons, par exemple, le tr√®s c√©l√®bre d√©fi du <a href="https://www.taylorpetrick.com/blog/post/business-rt">traceur de rayons de cartes d'affaires</a> .  Il produit des programmes tr√®s impressionnants, mais il est tr√®s difficile de comprendre comment cela fonctionne.  Plut√¥t que de montrer que je peux faire des rendus, je veux vous expliquer en d√©tail comment vous pouvez le faire vous-m√™me. </p><br><p>  <i>Remarque: Cela n'a aucun sens de regarder mon code, ni de lire cet article avec une tasse de th√© √† la main.</i>  <i>Cet article est con√ßu pour que vous puissiez utiliser le clavier et impl√©menter votre propre moteur de rendu.</i>  <i>Ce sera s√ªrement mieux que le mien.</i>  <i>Changez √† tout le moins le langage de programmation!</i> </p><br><p>  Donc, l'objectif d'aujourd'hui est d'apprendre √† rendre de telles images: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  √âtape 1: √©crire une image sur le disque </h1><br><p>  Je ne veux pas m'emb√™ter avec les gestionnaires de fen√™tres, le traitement souris / clavier et des trucs comme √ßa.  Le r√©sultat de notre programme sera une simple image enregistr√©e sur le disque.  Donc, la premi√®re chose que nous devons pouvoir faire est de sauvegarder l'image sur le disque.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Ici</a> vous pouvez trouver le code qui nous permet de le faire.  Permettez-moi de lister le fichier principal: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Seul render () est appel√© dans la fonction principale et rien d'autre.  Que contient la fonction render ()?  Tout d'abord, je d√©finis le framebuffer comme un tableau unidimensionnel de valeurs Vec3f, ce sont de simples vecteurs tridimensionnels qui nous donnent des valeurs (r, g, b) pour chaque pixel.  La classe des vecteurs vit dans le fichier geometry.h, je ne la d√©crirai pas ici: c'est vraiment une manipulation triviale de vecteurs bidimensionnels et tridimensionnels (addition, soustraction, affectation, multiplication par un scalaire, produit scalaire). </p><br><p>  J'enregistre l'image au <a href="https://en.wikipedia.org/wiki/Netpbm_format">format ppm</a> .  C'est le moyen le plus simple d'enregistrer des images, mais ce n'est pas toujours le moyen le plus pratique de les visualiser davantage.  Si vous souhaitez enregistrer dans d'autres formats, je vous recommande de lier une biblioth√®que tierce, telle que <a href="https://github.com/nothings/stb">stb</a> .  C'est une excellente biblioth√®que: il vous suffit d'inclure un fichier d'en-t√™te stb_image_write.h dans le projet, et cela vous permettra d'enregistrer des images dans les formats les plus courants. </p><br><p>  <b>Attention:</b> mon code est plein de bugs, je les corrige en amont, mais les commits plus anciens sont affect√©s.  V√©rifiez <a href="https://github.com/ssloy/tinyraycaster/issues/9">ce probl√®me</a> . </p><br><p>  Donc, le but de cette √©tape est de s'assurer que nous pouvons a) cr√©er une image en m√©moire + affecter diff√©rentes couleurs et b) enregistrer le r√©sultat sur le disque.  Ensuite, vous pouvez le visualiser dans un logiciel tiers.  Voici le r√©sultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="image"></p><br><h1>  √âtape 2, cruciale: le lancer de rayons </h1><br><p>  Il s'agit de l'√©tape la plus importante et la plus difficile de toute la cha√Æne.  Je veux d√©finir une sph√®re dans mon code et la dessiner sans √™tre obs√©d√© par les mat√©riaux ou l'√©clairage.  Voici √† quoi devrait ressembler notre r√©sultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="image"></p><br><p>  Par souci de commodit√©, j'ai un commit par √©tape dans mon r√©f√©rentiel;  Github permet de visualiser tr√®s facilement les modifications apport√©es.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Ici, par exemple</a> , ce qui a √©t√© chang√© par le deuxi√®me commit. </p><br><p>  Pour commencer, de quoi avons-nous besoin pour repr√©senter la sph√®re dans la m√©moire de l'ordinateur?  Quatre nombres suffisent: un vecteur tridimensionnel pour le centre de la sph√®re et un scalaire d√©crivant le rayon: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  La seule chose non triviale dans ce code est une fonction qui vous permet de v√©rifier si un rayon donn√© (originaire de l'origine dans la direction de dir) croise notre sph√®re.  Une description d√©taill√©e de l'algorithme pour l'intersection rayon-sph√®re <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">peut √™tre trouv√©e ici</a> , je vous recommande fortement de le faire et de v√©rifier mon code. </p><br><p>  Comment fonctionne le lancer de rayons?  C'est assez simple.  √Ä la premi√®re √©tape, nous venons de remplir l'image avec un d√©grad√© de couleurs: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Maintenant, pour chaque pixel, nous formerons un rayon provenant de l'origine et traversant notre pixel, puis v√©rifier si ce rayon intersecte avec la sph√®re: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  S'il n'y a pas d'intersection avec la sph√®re, nous dessinons le pixel avec color1, sinon avec color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre> <br><p>  √Ä ce stade, je vous recommande de prendre un crayon et de v√©rifier sur papier tous les calculs (l'intersection rayon-sph√®re et le balayage de l'image avec les rayons).  Au cas o√π, notre cam√©ra est d√©termin√©e par les √©l√©ments suivants: </p><br><ul><li>  largeur de l'image </li><li>  hauteur de l'image </li><li>  angle de champ de vision </li><li>  emplacement de la cam√©ra, Vec3f (0.0.0) </li><li>  voir la direction, le long de l'axe z, dans le sens de moins l'infini </li></ul><br><p>  Permettez-moi d'illustrer comment nous calculons la direction initiale du rayon √† tracer.  Dans la boucle principale, nous avons cette formule: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  D'o√π √ßa vient?  Assez simple.  Notre cam√©ra est plac√©e √† l'origine et fait face √† la direction -z.  Permettez-moi d'illustrer les choses, cette image montre la cam√©ra depuis le haut, l'axe y pointe hors de l'√©cran: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="image"></p><br><p>  Comme je l'ai dit, la cam√©ra est plac√©e √† l'origine, et la sc√®ne est projet√©e sur l'√©cran qui se trouve dans le plan z = -1.  Le champ de vision sp√©cifie quel secteur de l'espace sera visible √† l'√©cran.  Dans notre image, l'√©cran fait 16 pixels de large;  pouvez-vous calculer sa longueur en coordonn√©es mondiales?  C'est assez simple: concentrons-nous sur le triangle form√© par la ligne pointill√©e rouge, grise et grise.  Il est facile de voir que le bronzage (champ de vision / 2) = (largeur d'√©cran) <em>0,5 / (distance √©cran-cam√©ra).</em>  <em>Nous avons plac√© l'√©cran √† une distance de 1 de la cam√©ra, donc (largeur d'√©cran) = 2</em> bronzage (champ de vision / 2). </p><br><p>  Disons maintenant que nous voulons projeter un vecteur √† travers le centre du 12√®me pixel de l'√©cran, c'est-√†-dire que nous voulons calculer le vecteur bleu.  Comment faire √ßa?  Quelle est la distance entre la gauche de l'√©cran et la pointe du vecteur bleu?  Tout d'abord, c'est 12 + 0,5 pixels.  Nous savons que 16 pixels de l'√©cran correspondent √† 2 <em>unit√©s mondiales tan (fov / 2).</em>  <em>Ainsi, la pointe du vecteur est situ√©e √† (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) unit√©s mondiales du bord gauche, ou √† la distance de (12 + 0,5)</em> 2/16 * tan (fov / 2) - bronzage (fov / 2) √† partir de l'intersection entre l'√©cran et l'axe -z.  Ajoutez le rapport hauteur / largeur de l'√©cran aux calculs et vous trouverez exactement les formules pour la direction des rayons. </p><br><h1>  √âtape 3: ajouter plus de sph√®res </h1><br><p>  La partie la plus difficile est termin√©e, et maintenant notre chemin est clair.  Si nous savons dessiner une sph√®re, il ne nous faudra pas longtemps pour en ajouter quelques autres.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">V√©rifiez les modifications</a> dans le code, et voici l'image r√©sultante: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="image"></p><br><h1>  √âtape 4: √©clairage </h1><br><p>  L'image est parfaite sous tous les aspects, √† l'exception du manque de lumi√®re.  Dans le reste de l'article, nous parlerons de l'√©clairage.  Ajoutons quelques sources lumineuses ponctuelles: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Le calcul de l'illumination globale r√©elle est une t√¢che tr√®s, tr√®s difficile, donc comme tout le monde, nous tromperons l'≈ìil en dessinant des r√©sultats compl√®tement non physiques, mais visuellement plausibles.  Pour commencer: pourquoi fait-il froid en hiver et chaud en √©t√©?  Parce que le chauffage de la surface de la Terre d√©pend de l'angle d'incidence des rayons du soleil.  Plus le soleil s'√©l√®ve au-dessus de l'horizon, plus la surface est lumineuse.  Inversement, plus il est bas au-dessus de l'horizon, plus il est sombre.  Et apr√®s le coucher du soleil sur l'horizon, les photons ne nous atteignent m√™me pas du tout. </p><br><p>  Retour nos sph√®res: nous √©mettons un rayon de la cam√©ra (pas de relation avec les photons!) √Ä elle s'arr√™te √† une sph√®re.  Comment savons-nous l'intensit√© de l'√©clairage du point d'intersection?  En effet, il suffit de v√©rifier l'angle entre un vecteur normal en ce point et le vecteur d√©crivant une direction de la lumi√®re.  Plus l'angle est petit, meilleure est la surface √©clair√©e.  Rappelons que le produit scalaire entre deux vecteurs a et b est √©gal au produit des normes des vecteurs multipli√© par le cosinus de l'angle entre les vecteurs: a * b = | a |  | b |  cos (alpha (a, b)).  Si nous prenons des vecteurs de longueur unitaire, le produit scalaire nous donnera l'intensit√© de l'√©clairage de surface. </p><br><p>  Ainsi, dans la fonction cast_ray, au lieu d'une couleur constante, nous retournerons la couleur en tenant compte des sources lumineuses: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Les modifications par rapport √† l'√©tape pr√©c√©dente <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">sont disponibles ici</a> , et voici le r√©sultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="image"></p><br><h1>  √âtape 5: √©clairage sp√©culaire </h1><br><p>  L'astuce du produit scalaire donne une bonne approximation de l'√©clairage des surfaces mates, dans la litt√©rature, il est appel√© √©clairage diffus.  Que devons-nous faire si nous voulons dessiner des surfaces brillantes?  Je veux obtenir une photo comme celle-ci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="image"></p><br><p>  V√©rifiez <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">combien de modifications</a> ont √©t√© n√©cessaires.  En bref, plus la lumi√®re est brillante sur les surfaces brillantes, moins l'angle entre la direction de la vue et la direction de <i>la</i> lumi√®re <i>r√©fl√©chie est</i> faible. </p><br><p>  Cette supercherie avec illumination de surfaces mates et brillantes est connue sous le nom de <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">mod√®le de r√©flexion Phong</a> .  Le wiki a une description assez d√©taill√©e de ce mod√®le d'√©clairage.  Il peut √™tre agr√©able de le lire c√¥te √† c√¥te avec le code source.  Voici l'image cl√© pour comprendre la magie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="image"></p><br><h1>  √âtape 6: ombres </h1><br><p>  Pourquoi avons-nous la lumi√®re, mais pas d'ombres?  Ce n'est pas bien!  Je veux cette photo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="image"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Seules six lignes de code</a> nous permettent d'atteindre cet objectif: lors du dessin de chaque point, nous nous assurons simplement que le segment entre le point actuel et la source de lumi√®re n'intersecte pas les objets de notre sc√®ne.  S'il y a une intersection, nous sautons la source de lumi√®re actuelle.  Il n'y a qu'une petite subtilit√©: je perturbe le point en le d√©pla√ßant dans le sens normal: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Pourquoi √ßa?  C'est juste que notre point se trouve sur la surface de l'objet, et (√† l'exception de la question des erreurs num√©riques) tout rayon de ce point coupera l'objet lui-m√™me. </p><br><h1>  √âtape 7: r√©flexions </h1><br><p>  C'est incroyable, mais pour ajouter des reflets √† notre rendu, il suffit d'ajouter trois lignes de code: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">Voyez par vous-m√™me:</a> lorsque vous intersectez la sph√®re, nous calculons simplement le rayon r√©fl√©chi (√† l'aide de la m√™me fonction que nous avons utilis√©e pour les reflets sp√©culaires!) Et appelons r√©cursivement la fonction cast_ray dans la direction du rayon r√©fl√©chi.  Assurez-vous de jouer avec <a href="">la profondeur de r√©cursivit√©</a> , je la mets √† 4, essayez diff√©rentes valeurs commen√ßant √† 0, qu'est-ce qui va changer dans l'image?  Voici mon r√©sultat avec des r√©flexions et une profondeur de r√©cursivit√© de 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="image"></p><br><h1>  √âtape 8: r√©fractions </h1><br><p>  Si nous savons faire des r√©flexions, les <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">r√©fractions sont faciles</a> .  Nous devons ajouter une fonction pour calculer le rayon r√©fract√© (en <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">utilisant la loi de Snell</a> ), et trois autres lignes de code dans notre fonction r√©cursive cast_ray.  Voici le r√©sultat o√π la boule la plus proche est "en verre", elle r√©fl√©chit et r√©fracte la lumi√®re en m√™me temps: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="image"></p><br><h1>  Steo 9: au-del√† des sph√®res </h1><br><p>  Jusqu'√† pr√©sent, nous n'avons rendu que des sph√®res car il s'agit de l'un des objets math√©matiques les plus simples non triviaux.  Ajoutons un avion.  L'√©chiquier est un choix classique.  Pour cela, il suffit de rajouter <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">une dizaine de lignes</a> . </p><br><p>  Et voici le r√©sultat: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Comme promis, le code a 256 lignes de code, <a href="https://github.com/ssloy/tinyraytracer">v√©rifiez par vous-m√™me</a> ! </p><br><h1>  √âtape 10: affectation √† domicile </h1><br><p>  Nous avons parcouru un long chemin: nous avons appris comment ajouter des objets √† une sc√®ne, comment calculer un √©clairage plut√¥t compliqu√©.  Permettez-moi de vous laisser deux devoirs comme devoirs.  Absolument tout le travail pr√©paratoire a d√©j√† √©t√© fait dans la branche <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">homework_assignment</a> .  Chaque affectation n√©cessitera dix lignes de sommets de code. </p><br><h3>  Affectation 1: carte de l'environnement </h3><br><p>  Pour le moment, si le rayon ne coupe aucun objet, nous d√©finissons simplement le pixel sur la couleur d'arri√®re-plan constante.  Et pourquoi, en fait, est-ce constant?  Prenons une photo sph√©rique (fichier <a href="">envmap.jpg</a> ) et utilisons-la comme arri√®re-plan!  Pour vous faciliter la vie, j'ai li√© notre projet √† la biblioth√®que stb pour la commodit√© de travailler avec le format jpg.  Cela devrait nous donner une telle image: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="image"></p><br><h3>  Devoir 2: charlatan-charlatan! </h3><br><p>  Nous pouvons rendre des sph√®res et des plans (voir le damier).  Alors dessinons des mailles triangulaires!  J'ai √©crit un code qui vous permet de lire un fichier .obj et y ai ajout√© une fonction d'intersection rayon-triangle.  Maintenant, ajouter le canard √† notre sc√®ne devrait √™tre assez banal: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="image"></p><br><h1>  Conclusion </h1><br><p>  Mon objectif principal est de montrer des projets int√©ressants (et faciles!) √Ä programmer.  Je suis convaincu que pour devenir un bon programmeur, il faut faire beaucoup de projets parall√®les.  Je ne sais pas pour vous, mais personnellement je ne suis pas attir√© par les logiciels de comptabilit√© et le jeu de dragueur de mines, m√™me si la complexit√© du code est assez comparable. </p><br><p>  Quelques heures et deux cent cinquante lignes de code nous donnent un raytracer.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Cinq cents lignes</a> du rasterizer logiciel peuvent √™tre r√©alis√©es en quelques jours.  Le graphisme est vraiment cool pour apprendre la programmation! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477244/">https://habr.com/ru/post/fr477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477230/index.html">L'histoire des logiciels √©ducatifs: les premiers ordinateurs personnels, jeux √©ducatifs et logiciels pour les √©tudiants</a></li>
<li><a href="../fr477234/index.html">La souris qui a mis fin aux fr√®res de fil</a></li>
<li><a href="../fr477236/index.html">Un tribunal am√©ricain autorise les √âtats √† r√©tablir la neutralit√© du Net</a></li>
<li><a href="../fr477238/index.html">Plus √† Karma: pourquoi le d√©bordement de pile est critiqu√© et pourquoi beaucoup se plaignent de la toxicit√© communautaire</a></li>
<li><a href="../fr477242/index.html">Comment nous avons choisi ServiceDesk. 3e partie</a></li>
<li><a href="../fr477248/index.html">Ma premi√®re exp√©rience de r√©cup√©ration d'une base de donn√©es Postgres apr√®s un crash (page invalide dans le bloc 4123007 de relatton base / 16490)</a></li>
<li><a href="../fr477250/index.html">Vous souhaitez donc ex√©cuter Windows 10 sur une calculatrice? Ok</a></li>
<li><a href="../fr477252/index.html">Comment les incubateurs et les acc√©l√©rateurs d'entreprises se sont d√©velopp√©s: du laboratoire de Thomas Edison au combinateur Y</a></li>
<li><a href="../fr477254/index.html">Authentification XSS, CSRF et Flash. R√©solution de probl√®mes avec r0ot-mi Web - Client. 2e partie</a></li>
<li><a href="../fr477256/index.html">Le premier lancement √† part enti√®re de OneWeb sur le lanceur Soyouz est report√© l'ann√©e prochaine, ainsi que le lancement du lanceur Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>