<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏽 👨🏾‍🏭 👴🏼 RayTracing compréhensible en 256 lignes de C ++ nu 🤵🏾 🏰 🏳️‍🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RayTracing compréhensible en 256 lignes de C ++ nu 


 Ceci est un autre chapitre de mon bref cours de conférences sur l'infographie . Cette fois, nou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RayTracing compréhensible en 256 lignes de C ++ nu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  RayTracing compréhensible en 256 lignes de C ++ nu </h1><br><p> Ceci est un autre chapitre de mon <a href="https://github.com/ssloy/tinyrenderer/wiki">bref cours de conférences sur l'infographie</a> .  Cette fois, nous parlons du lancer de rayons.  Comme d'habitude, j'essaie d'éviter les bibliothèques tierces, car je pense que cela permet aux étudiants de vérifier ce qui se passe sous le capot.  Vérifiez également le <a href="https://github.com/ssloy/tinykaboom/wiki">projet tinykaboom</a> . </p><br><p>  Il existe de nombreux articles sur le lancer de rayons sur le Web;  cependant, le problème est que presque tous présentent des logiciels finis qui peuvent être assez difficiles à comprendre.  Prenons, par exemple, le très célèbre défi du <a href="https://www.taylorpetrick.com/blog/post/business-rt">traceur de rayons de cartes d'affaires</a> .  Il produit des programmes très impressionnants, mais il est très difficile de comprendre comment cela fonctionne.  Plutôt que de montrer que je peux faire des rendus, je veux vous expliquer en détail comment vous pouvez le faire vous-même. </p><br><p>  <i>Remarque: Cela n'a aucun sens de regarder mon code, ni de lire cet article avec une tasse de thé à la main.</i>  <i>Cet article est conçu pour que vous puissiez utiliser le clavier et implémenter votre propre moteur de rendu.</i>  <i>Ce sera sûrement mieux que le mien.</i>  <i>Changez à tout le moins le langage de programmation!</i> </p><br><p>  Donc, l'objectif d'aujourd'hui est d'apprendre à rendre de telles images: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Étape 1: écrire une image sur le disque </h1><br><p>  Je ne veux pas m'embêter avec les gestionnaires de fenêtres, le traitement souris / clavier et des trucs comme ça.  Le résultat de notre programme sera une simple image enregistrée sur le disque.  Donc, la première chose que nous devons pouvoir faire est de sauvegarder l'image sur le disque.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Ici</a> vous pouvez trouver le code qui nous permet de le faire.  Permettez-moi de lister le fichier principal: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Seul render () est appelé dans la fonction principale et rien d'autre.  Que contient la fonction render ()?  Tout d'abord, je définis le framebuffer comme un tableau unidimensionnel de valeurs Vec3f, ce sont de simples vecteurs tridimensionnels qui nous donnent des valeurs (r, g, b) pour chaque pixel.  La classe des vecteurs vit dans le fichier geometry.h, je ne la décrirai pas ici: c'est vraiment une manipulation triviale de vecteurs bidimensionnels et tridimensionnels (addition, soustraction, affectation, multiplication par un scalaire, produit scalaire). </p><br><p>  J'enregistre l'image au <a href="https://en.wikipedia.org/wiki/Netpbm_format">format ppm</a> .  C'est le moyen le plus simple d'enregistrer des images, mais ce n'est pas toujours le moyen le plus pratique de les visualiser davantage.  Si vous souhaitez enregistrer dans d'autres formats, je vous recommande de lier une bibliothèque tierce, telle que <a href="https://github.com/nothings/stb">stb</a> .  C'est une excellente bibliothèque: il vous suffit d'inclure un fichier d'en-tête stb_image_write.h dans le projet, et cela vous permettra d'enregistrer des images dans les formats les plus courants. </p><br><p>  <b>Attention:</b> mon code est plein de bugs, je les corrige en amont, mais les commits plus anciens sont affectés.  Vérifiez <a href="https://github.com/ssloy/tinyraycaster/issues/9">ce problème</a> . </p><br><p>  Donc, le but de cette étape est de s'assurer que nous pouvons a) créer une image en mémoire + affecter différentes couleurs et b) enregistrer le résultat sur le disque.  Ensuite, vous pouvez le visualiser dans un logiciel tiers.  Voici le résultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="image"></p><br><h1>  Étape 2, cruciale: le lancer de rayons </h1><br><p>  Il s'agit de l'étape la plus importante et la plus difficile de toute la chaîne.  Je veux définir une sphère dans mon code et la dessiner sans être obsédé par les matériaux ou l'éclairage.  Voici à quoi devrait ressembler notre résultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="image"></p><br><p>  Par souci de commodité, j'ai un commit par étape dans mon référentiel;  Github permet de visualiser très facilement les modifications apportées.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Ici, par exemple</a> , ce qui a été changé par le deuxième commit. </p><br><p>  Pour commencer, de quoi avons-nous besoin pour représenter la sphère dans la mémoire de l'ordinateur?  Quatre nombres suffisent: un vecteur tridimensionnel pour le centre de la sphère et un scalaire décrivant le rayon: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  La seule chose non triviale dans ce code est une fonction qui vous permet de vérifier si un rayon donné (originaire de l'origine dans la direction de dir) croise notre sphère.  Une description détaillée de l'algorithme pour l'intersection rayon-sphère <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">peut être trouvée ici</a> , je vous recommande fortement de le faire et de vérifier mon code. </p><br><p>  Comment fonctionne le lancer de rayons?  C'est assez simple.  À la première étape, nous venons de remplir l'image avec un dégradé de couleurs: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Maintenant, pour chaque pixel, nous formerons un rayon provenant de l'origine et traversant notre pixel, puis vérifier si ce rayon intersecte avec la sphère: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  S'il n'y a pas d'intersection avec la sphère, nous dessinons le pixel avec color1, sinon avec color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre> <br><p>  À ce stade, je vous recommande de prendre un crayon et de vérifier sur papier tous les calculs (l'intersection rayon-sphère et le balayage de l'image avec les rayons).  Au cas où, notre caméra est déterminée par les éléments suivants: </p><br><ul><li>  largeur de l'image </li><li>  hauteur de l'image </li><li>  angle de champ de vision </li><li>  emplacement de la caméra, Vec3f (0.0.0) </li><li>  voir la direction, le long de l'axe z, dans le sens de moins l'infini </li></ul><br><p>  Permettez-moi d'illustrer comment nous calculons la direction initiale du rayon à tracer.  Dans la boucle principale, nous avons cette formule: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  D'où ça vient?  Assez simple.  Notre caméra est placée à l'origine et fait face à la direction -z.  Permettez-moi d'illustrer les choses, cette image montre la caméra depuis le haut, l'axe y pointe hors de l'écran: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="image"></p><br><p>  Comme je l'ai dit, la caméra est placée à l'origine, et la scène est projetée sur l'écran qui se trouve dans le plan z = -1.  Le champ de vision spécifie quel secteur de l'espace sera visible à l'écran.  Dans notre image, l'écran fait 16 pixels de large;  pouvez-vous calculer sa longueur en coordonnées mondiales?  C'est assez simple: concentrons-nous sur le triangle formé par la ligne pointillée rouge, grise et grise.  Il est facile de voir que le bronzage (champ de vision / 2) = (largeur d'écran) <em>0,5 / (distance écran-caméra).</em>  <em>Nous avons placé l'écran à une distance de 1 de la caméra, donc (largeur d'écran) = 2</em> bronzage (champ de vision / 2). </p><br><p>  Disons maintenant que nous voulons projeter un vecteur à travers le centre du 12ème pixel de l'écran, c'est-à-dire que nous voulons calculer le vecteur bleu.  Comment faire ça?  Quelle est la distance entre la gauche de l'écran et la pointe du vecteur bleu?  Tout d'abord, c'est 12 + 0,5 pixels.  Nous savons que 16 pixels de l'écran correspondent à 2 <em>unités mondiales tan (fov / 2).</em>  <em>Ainsi, la pointe du vecteur est située à (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) unités mondiales du bord gauche, ou à la distance de (12 + 0,5)</em> 2/16 * tan (fov / 2) - bronzage (fov / 2) à partir de l'intersection entre l'écran et l'axe -z.  Ajoutez le rapport hauteur / largeur de l'écran aux calculs et vous trouverez exactement les formules pour la direction des rayons. </p><br><h1>  Étape 3: ajouter plus de sphères </h1><br><p>  La partie la plus difficile est terminée, et maintenant notre chemin est clair.  Si nous savons dessiner une sphère, il ne nous faudra pas longtemps pour en ajouter quelques autres.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Vérifiez les modifications</a> dans le code, et voici l'image résultante: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="image"></p><br><h1>  Étape 4: éclairage </h1><br><p>  L'image est parfaite sous tous les aspects, à l'exception du manque de lumière.  Dans le reste de l'article, nous parlerons de l'éclairage.  Ajoutons quelques sources lumineuses ponctuelles: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Le calcul de l'illumination globale réelle est une tâche très, très difficile, donc comme tout le monde, nous tromperons l'œil en dessinant des résultats complètement non physiques, mais visuellement plausibles.  Pour commencer: pourquoi fait-il froid en hiver et chaud en été?  Parce que le chauffage de la surface de la Terre dépend de l'angle d'incidence des rayons du soleil.  Plus le soleil s'élève au-dessus de l'horizon, plus la surface est lumineuse.  Inversement, plus il est bas au-dessus de l'horizon, plus il est sombre.  Et après le coucher du soleil sur l'horizon, les photons ne nous atteignent même pas du tout. </p><br><p>  Retour nos sphères: nous émettons un rayon de la caméra (pas de relation avec les photons!) À elle s'arrête à une sphère.  Comment savons-nous l'intensité de l'éclairage du point d'intersection?  En effet, il suffit de vérifier l'angle entre un vecteur normal en ce point et le vecteur décrivant une direction de la lumière.  Plus l'angle est petit, meilleure est la surface éclairée.  Rappelons que le produit scalaire entre deux vecteurs a et b est égal au produit des normes des vecteurs multiplié par le cosinus de l'angle entre les vecteurs: a * b = | a |  | b |  cos (alpha (a, b)).  Si nous prenons des vecteurs de longueur unitaire, le produit scalaire nous donnera l'intensité de l'éclairage de surface. </p><br><p>  Ainsi, dans la fonction cast_ray, au lieu d'une couleur constante, nous retournerons la couleur en tenant compte des sources lumineuses: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Les modifications par rapport à l'étape précédente <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">sont disponibles ici</a> , et voici le résultat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="image"></p><br><h1>  Étape 5: éclairage spéculaire </h1><br><p>  L'astuce du produit scalaire donne une bonne approximation de l'éclairage des surfaces mates, dans la littérature, il est appelé éclairage diffus.  Que devons-nous faire si nous voulons dessiner des surfaces brillantes?  Je veux obtenir une photo comme celle-ci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="image"></p><br><p>  Vérifiez <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">combien de modifications</a> ont été nécessaires.  En bref, plus la lumière est brillante sur les surfaces brillantes, moins l'angle entre la direction de la vue et la direction de <i>la</i> lumière <i>réfléchie est</i> faible. </p><br><p>  Cette supercherie avec illumination de surfaces mates et brillantes est connue sous le nom de <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">modèle de réflexion Phong</a> .  Le wiki a une description assez détaillée de ce modèle d'éclairage.  Il peut être agréable de le lire côte à côte avec le code source.  Voici l'image clé pour comprendre la magie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="image"></p><br><h1>  Étape 6: ombres </h1><br><p>  Pourquoi avons-nous la lumière, mais pas d'ombres?  Ce n'est pas bien!  Je veux cette photo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="image"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Seules six lignes de code</a> nous permettent d'atteindre cet objectif: lors du dessin de chaque point, nous nous assurons simplement que le segment entre le point actuel et la source de lumière n'intersecte pas les objets de notre scène.  S'il y a une intersection, nous sautons la source de lumière actuelle.  Il n'y a qu'une petite subtilité: je perturbe le point en le déplaçant dans le sens normal: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Pourquoi ça?  C'est juste que notre point se trouve sur la surface de l'objet, et (à l'exception de la question des erreurs numériques) tout rayon de ce point coupera l'objet lui-même. </p><br><h1>  Étape 7: réflexions </h1><br><p>  C'est incroyable, mais pour ajouter des reflets à notre rendu, il suffit d'ajouter trois lignes de code: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">Voyez par vous-même:</a> lorsque vous intersectez la sphère, nous calculons simplement le rayon réfléchi (à l'aide de la même fonction que nous avons utilisée pour les reflets spéculaires!) Et appelons récursivement la fonction cast_ray dans la direction du rayon réfléchi.  Assurez-vous de jouer avec <a href="">la profondeur de récursivité</a> , je la mets à 4, essayez différentes valeurs commençant à 0, qu'est-ce qui va changer dans l'image?  Voici mon résultat avec des réflexions et une profondeur de récursivité de 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="image"></p><br><h1>  Étape 8: réfractions </h1><br><p>  Si nous savons faire des réflexions, les <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">réfractions sont faciles</a> .  Nous devons ajouter une fonction pour calculer le rayon réfracté (en <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">utilisant la loi de Snell</a> ), et trois autres lignes de code dans notre fonction récursive cast_ray.  Voici le résultat où la boule la plus proche est "en verre", elle réfléchit et réfracte la lumière en même temps: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="image"></p><br><h1>  Steo 9: au-delà des sphères </h1><br><p>  Jusqu'à présent, nous n'avons rendu que des sphères car il s'agit de l'un des objets mathématiques les plus simples non triviaux.  Ajoutons un avion.  L'échiquier est un choix classique.  Pour cela, il suffit de rajouter <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">une dizaine de lignes</a> . </p><br><p>  Et voici le résultat: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Comme promis, le code a 256 lignes de code, <a href="https://github.com/ssloy/tinyraytracer">vérifiez par vous-même</a> ! </p><br><h1>  Étape 10: affectation à domicile </h1><br><p>  Nous avons parcouru un long chemin: nous avons appris comment ajouter des objets à une scène, comment calculer un éclairage plutôt compliqué.  Permettez-moi de vous laisser deux devoirs comme devoirs.  Absolument tout le travail préparatoire a déjà été fait dans la branche <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">homework_assignment</a> .  Chaque affectation nécessitera dix lignes de sommets de code. </p><br><h3>  Affectation 1: carte de l'environnement </h3><br><p>  Pour le moment, si le rayon ne coupe aucun objet, nous définissons simplement le pixel sur la couleur d'arrière-plan constante.  Et pourquoi, en fait, est-ce constant?  Prenons une photo sphérique (fichier <a href="">envmap.jpg</a> ) et utilisons-la comme arrière-plan!  Pour vous faciliter la vie, j'ai lié notre projet à la bibliothèque stb pour la commodité de travailler avec le format jpg.  Cela devrait nous donner une telle image: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="image"></p><br><h3>  Devoir 2: charlatan-charlatan! </h3><br><p>  Nous pouvons rendre des sphères et des plans (voir le damier).  Alors dessinons des mailles triangulaires!  J'ai écrit un code qui vous permet de lire un fichier .obj et y ai ajouté une fonction d'intersection rayon-triangle.  Maintenant, ajouter le canard à notre scène devrait être assez banal: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="image"></p><br><h1>  Conclusion </h1><br><p>  Mon objectif principal est de montrer des projets intéressants (et faciles!) À programmer.  Je suis convaincu que pour devenir un bon programmeur, il faut faire beaucoup de projets parallèles.  Je ne sais pas pour vous, mais personnellement je ne suis pas attiré par les logiciels de comptabilité et le jeu de dragueur de mines, même si la complexité du code est assez comparable. </p><br><p>  Quelques heures et deux cent cinquante lignes de code nous donnent un raytracer.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Cinq cents lignes</a> du rasterizer logiciel peuvent être réalisées en quelques jours.  Le graphisme est vraiment cool pour apprendre la programmation! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477244/">https://habr.com/ru/post/fr477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477230/index.html">L'histoire des logiciels éducatifs: les premiers ordinateurs personnels, jeux éducatifs et logiciels pour les étudiants</a></li>
<li><a href="../fr477234/index.html">La souris qui a mis fin aux frères de fil</a></li>
<li><a href="../fr477236/index.html">Un tribunal américain autorise les États à rétablir la neutralité du Net</a></li>
<li><a href="../fr477238/index.html">Plus à Karma: pourquoi le débordement de pile est critiqué et pourquoi beaucoup se plaignent de la toxicité communautaire</a></li>
<li><a href="../fr477242/index.html">Comment nous avons choisi ServiceDesk. 3e partie</a></li>
<li><a href="../fr477248/index.html">Ma première expérience de récupération d'une base de données Postgres après un crash (page invalide dans le bloc 4123007 de relatton base / 16490)</a></li>
<li><a href="../fr477250/index.html">Vous souhaitez donc exécuter Windows 10 sur une calculatrice? Ok</a></li>
<li><a href="../fr477252/index.html">Comment les incubateurs et les accélérateurs d'entreprises se sont développés: du laboratoire de Thomas Edison au combinateur Y</a></li>
<li><a href="../fr477254/index.html">Authentification XSS, CSRF et Flash. Résolution de problèmes avec r0ot-mi Web - Client. 2e partie</a></li>
<li><a href="../fr477256/index.html">Le premier lancement à part entière de OneWeb sur le lanceur Soyouz est reporté l'année prochaine, ainsi que le lancement du lanceur Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>