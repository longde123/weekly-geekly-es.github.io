<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõ üë©üèæ‚Äçü§ù‚Äçüë©üèª üßíüèª Principais erros de desenvolvimento ao trabalhar com o PostgreSQL üëÜüèø üåÇ üé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O HighLoad ++ existe h√° muito tempo e falamos sobre trabalhar com o PostgreSQL regularmente. Mas os desenvolvedores ainda t√™m os mesmos problemas de m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455248/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O HighLoad ++</a> existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h√°</a> muito tempo e falamos sobre trabalhar com o PostgreSQL regularmente.  Mas os desenvolvedores ainda t√™m os mesmos problemas de m√™s para m√™s, de ano para ano.  Quando em pequenas empresas sem um DBA no estado h√° erros no trabalho com bancos de dados, isso n√£o √© surpreendente.  As grandes empresas tamb√©m precisam de bancos de dados e, mesmo com processos depurados, os erros ainda ocorrem e os bancos de dados caem.  N√£o importa qual o tamanho da empresa - ainda ocorrem erros, os bancos de dados periodicamente travam, travam. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Obviamente, isso nunca acontecer√° com voc√™, mas verificar a lista de verifica√ß√£o n√£o √© dif√≠cil e pode ser muito decente economizar nervos futuros.  Abaixo, listamos os principais erros t√≠picos que os desenvolvedores cometem ao trabalhar com o PostgreSQL, ver por que n√£o precisamos fazer isso e descobrir como. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Sobre o palestrante: Alexey Lesovsky</b> come√ßou como administrador de sistemas Linux.  Das tarefas de virtualiza√ß√£o e monitoramento de sistemas, gradualmente chegou ao PostgreSQL.  Agora, o PostgreSQL DBA na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Data Egret</a> , uma empresa de consultoria que trabalha com muitos projetos diferentes e v√™ muitos exemplos de problemas recorrentes.  Este √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> para a apresenta√ß√£o do relat√≥rio no HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  De onde v√™m os problemas </h2><br>  Para aquecer, algumas hist√≥rias sobre como os erros ocorrem. <br><br><h3>  Hist√≥ria 1. Recursos </h3><br>  Um dos problemas √© quais recursos a empresa usa ao trabalhar com o PostgreSQL.  Tudo come√ßa simples: PostgreSQL, conjuntos de dados, consultas simples com JOIN.  Pegamos os dados, selecionamos - tudo √© simples. <br><br>  Ent√£o come√ßamos a usar a funcionalidade adicional do PostgreSQL, adicionamos novas fun√ß√µes, extens√µes.  O recurso est√° ficando maior.  N√≥s conectamos replica√ß√£o de streaming, sharding.  V√°rios utilit√°rios e kits corporais aparecem ao redor - pgbouncer, pgpool, patroni.  Algo assim. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Cada palavra-chave √© um motivo para o erro aparecer. </blockquote><br><h3>  Hist√≥rico 2. Armazenamento de Dados </h3><br>  A maneira como armazenamos dados tamb√©m √© uma fonte de erros. <br><br>  Quando o projeto apareceu pela primeira vez, havia muitos dados e tabelas nele.  Consultas simples s√£o suficientes para receber e registrar dados.  Mas existem mais e mais tabelas.  Os dados s√£o selecionados em diferentes lugares, JOINs aparecem.  As consultas s√£o complicadas e incluem constru√ß√µes CTE, SUBQUERY, IN, LATERAL.  Cometer um erro e escrever uma consulta de curva se torna muito mais f√°cil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  E esta √© apenas a ponta do iceberg - em algum lugar do lado, pode haver outras 400 tabelas, parti√ß√µes, das quais os dados tamb√©m s√£o ocasionalmente lidos. <br><br><h3>  Hist√≥ria 3. Ciclo de Vida </h3><br>  A hist√≥ria de como o produto √© seguido.  Os dados sempre precisam ser armazenados em algum lugar, para que haja sempre um banco de dados.  Como um banco de dados se desenvolve quando um produto se desenvolve? <br><br>  Por um lado, h√° <b>desenvolvedores</b> que est√£o ocupados com linguagens de programa√ß√£o.  Eles escrevem seus aplicativos e desenvolvem habilidades no campo do desenvolvimento de software, n√£o prestando aten√ß√£o aos servi√ßos.  Frequentemente, eles n√£o est√£o interessados ‚Äã‚Äãem como o Kafka ou o PostgreSQL funciona - eles desenvolvem novos recursos em sua aplica√ß√£o e n√£o se importam com o resto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  <b>Administradores, por</b> outro lado.  Eles criam novas inst√¢ncias da Amazon no Bare-metal e est√£o ocupados com a automa√ß√£o: eles configuram uma implanta√ß√£o para fazer o layout funcionar bem e configuram-se para que os servi√ßos interajam bem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  Existe uma situa√ß√£o em que n√£o h√° tempo ou desejo de ajuste fino dos componentes e do banco de dados tamb√©m.  Os bancos de dados funcionam com configura√ß√µes padr√£o e depois os esquecem completamente - "funciona, n√£o toque". <br><br>  Como resultado, os ancinhos est√£o espalhados em v√°rios lugares, que de vez em quando voam para a testa dos desenvolvedores.  Neste artigo, tentaremos coletar todos esses ancinhos em um barrac√£o para que voc√™ os conhe√ßa e n√£o os pise ao trabalhar com o PostgreSQL. <br><br><h2>  Planejamento e monitoramento </h2><br>  Primeiro, imagine que temos um novo projeto - √© sempre um desenvolvimento ativo, teste de hip√≥teses e implementa√ß√£o de novos recursos.  No momento em que o aplicativo acaba de aparecer e est√° em desenvolvimento, possui pouco tr√°fego, usu√°rios e clientes, e todos eles geram pequenas quantidades de dados.  O banco de dados possui consultas simples que s√£o processadas rapidamente.  N√£o h√° necessidade de arrastar grandes quantidades de dados, n√£o h√° problemas. <br><br>  Mas h√° mais usu√°rios, o tr√°fego chega: novos dados s√£o exibidos, os bancos de dados crescem e as consultas antigas param de funcionar.  √â necess√°rio concluir √≠ndices, reescrever e otimizar consultas.  H√° problemas de desempenho.  Tudo isso leva a alertas √†s quatro da manh√£, estresse para os administradores e descontentamento da ger√™ncia. <br><br><h3>  O que est√° errado? </h3><br><blockquote>  Na minha experi√™ncia, na maioria das vezes n√£o h√° discos suficientes. </blockquote><br>  <b>O primeiro exemplo</b> .  Abrimos o gr√°fico de monitoramento da utiliza√ß√£o do disco e vemos que o <b>espa√ßo livre no disco est√° acabando</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  Observamos quanto espa√ßo e o que √© consumido - acontece que existe um diret√≥rio pg_xlog: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Os administradores de banco de dados geralmente sabem o que √© esse diret√≥rio e n√£o o tocam - ele existe e existe.  Mas o desenvolvedor, especialmente se ele olha para a encena√ß√£o, co√ßa a cabe√ßa e pensa: <br><br>  <i>- Algum tipo de registro ... Vamos excluir o pg_xlog!</i> <br><br>  <b>Exclui o diret√≥rio, o banco de dados para de funcionar</b> .  Imediatamente, voc√™ precisa pesquisar no Google como aumentar o banco de dados ap√≥s excluir os logs de transa√ß√µes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>Segundo exemplo</b> .  Novamente, abrimos o monitoramento e vemos que n√£o h√° espa√ßo suficiente.  Desta vez, o local √© ocupado por algum tipo de base. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Estamos procurando qual banco de dados ocupa mais espa√ßo, quais tabelas e √≠ndices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  Acontece que esta √© uma tabela com logs hist√≥ricos.  N√≥s nunca precis√°vamos de registros hist√≥ricos.  Eles s√£o escritos apenas por precau√ß√£o, e se n√£o fosse pelo problema do local, ningu√©m os olharia at√© a segunda vinda: <br><br>  <i>- Vamos limpar tudo o que mm ... mais antigo que outubro!</i> <br><br>  Fa√ßa um pedido de atualiza√ß√£o, execute-o, ele funcionar√° e excluir√° algumas das linhas. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; ¬´2018-10-01¬ª; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  A consulta √© executada por 10 minutos, mas a tabela ainda ocupa a mesma quantidade de espa√ßo. <br><br>  O PostgreSQL remove as linhas da tabela - tudo est√° correto, mas n√£o retorna o local ao sistema operacional.  Esse comportamento do PostgreSQL √© desconhecido para a maioria dos desenvolvedores e pode ser muito surpreendente. <br><br>  <b>O terceiro exemplo</b> .  Por exemplo, o ORM fez uma solicita√ß√£o interessante.  Geralmente, todo mundo culpa o ORM por fazer consultas "ruins" que leem algumas tabelas. <br><br>  Suponha que haja v√°rias opera√ß√µes JOIN que leem tabelas em paralelo em v√°rios encadeamentos.  O PostgreSQL pode paralelizar opera√ß√µes de dados e pode ler tabelas em v√°rios threads.  Mas, como temos v√°rios servidores de aplicativos, essa consulta l√™ todas as tabelas milhares de vezes por segundo.  Acontece que o servidor do banco de dados est√° sobrecarregado, os discos n√£o conseguem lidar e tudo isso leva a um erro <b>502 Bad Gateway</b> do back-end - o banco de dados est√° indispon√≠vel. <br><br>  Mas isso n√£o √© tudo.  Voc√™ pode recuperar outros recursos do PostgerSQL. <br><br><ul><li>  <b>Freios nos processos em segundo plano do DBMS</b> - O PostgreSQL possui todos os tipos de pontos de verifica√ß√£o, vazios e replica√ß√£o. <br></li><li>  <b>Sobrecarga de virtualiza√ß√£o</b> .  Quando o banco de dados est√° sendo executado em uma m√°quina virtual, no mesmo peda√ßo de ferro tamb√©m existem m√°quinas virtuais ao lado e elas podem entrar em conflito com os recursos. <br></li><li>  <b>O armazenamento √© do fabricante chin√™s NoName</b> , cujo desempenho depende da lua em Capric√≥rnio ou da posi√ß√£o de Saturno, e n√£o h√° como descobrir por que funciona dessa maneira.  A base est√° sofrendo. <br></li><li>  <b>A configura√ß√£o padr√£o</b> .  Este √© o meu t√≥pico favorito: o cliente diz que seu banco de dados est√° ficando mais lento - veja bem, e ele tem uma configura√ß√£o padr√£o.  O fato √© que a configura√ß√£o padr√£o do PostgreSQL foi projetada para ser <b>executada no bule mais fraco</b> .  A base √© lan√ßada, funciona, mas quando j√° funciona em hardware de n√≠vel m√©dio, essa configura√ß√£o n√£o √© suficiente, precisa ser ajustada. <br></li></ul><br><blockquote>  Na maioria das vezes, o PostgreSQL n√£o possui espa√ßo em disco nem desempenho em disco.  Felizmente, com processadores, mem√≥ria e uma rede, tudo est√° mais ou menos em ordem. </blockquote><br>  Como ser  Precisa de monitoramento e planejamento!  Parece √≥bvio, mas por alguma raz√£o, na maioria dos casos, ningu√©m planeja uma base, e o monitoramento n√£o cobre tudo o que precisa ser monitorado durante a opera√ß√£o do PostgreSQL.  H√° um conjunto de regras claras, com as quais tudo funcionar√° bem, e n√£o "aleatoriamente". <br><br><h3>  Planejamento </h3><br>  <b>Hospede o banco de dados em um SSD sem hesitar</b> .  Os SSDs se tornaram confi√°veis, est√°veis ‚Äã‚Äãe produtivos.  Os modelos de SSD corporativo existem h√° anos. <br><br>  <b>Sempre planeje um esquema de dados</b> .  N√£o escreva no banco de dados que voc√™ duvida do que √© necess√°rio - garantido que n√£o √© necess√°rio.  Um exemplo simples √© uma tabela ligeiramente modificada de um de nossos clientes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  Esta √© uma tabela de log na qual h√° uma coluna de dados do tipo json.  Relativamente falando, voc√™ pode escrever qualquer coisa nesta coluna.  No √∫ltimo registro desta tabela, √© poss√≠vel observar que os logs ocupam 8 MB.  O PostgreSQL n√£o tem nenhum problema em armazenar registros desse tamanho.  O PostgreSQL possui um armazenamento muito bom que mastiga esses registros. <br><br>  Mas o problema √© que, quando os servidores de aplicativos leem os dados desta tabela, eles entupem facilmente toda a largura de banda da rede e outras solicita√ß√µes sofrem.  Esse √© o problema de planejar um esquema de dados. <br><br>  <b>Use o particionamento para qualquer dica de uma hist√≥ria que precise ser armazenada por mais de dois anos</b> .  O particionamento √†s vezes parece complicado - voc√™ precisa se preocupar com gatilhos, com fun√ß√µes que criar√£o parti√ß√µes.  Nas novas vers√µes do PostgreSQL, a situa√ß√£o √© melhor e agora a configura√ß√£o do particionamento √© muito mais simples - uma vez feito e funciona. <br><br>  No exemplo considerado de exclus√£o de dados em 10 minutos, <code>DELETE</code> pode ser substitu√≠do por <code>DROP TABLE</code> - uma opera√ß√£o semelhante em circunst√¢ncias semelhantes levar√° apenas alguns milissegundos. <br><br>  Quando os dados s√£o classificados por parti√ß√£o, a parti√ß√£o √© exclu√≠da literalmente em alguns milissegundos e o sistema operacional assume o controle imediatamente.  Gerenciar dados hist√≥ricos √© mais f√°cil, mais f√°cil e mais seguro. <br><br><h3>  Monitoramento </h3><br>  O monitoramento √© um grande t√≥pico separado, mas do ponto de vista do banco de dados, existem recomenda√ß√µes que podem caber em uma se√ß√£o do artigo. <br><br>  Por padr√£o, muitos sistemas de monitoramento fornecem monitoramento de processadores, mem√≥ria, rede, espa√ßo em disco, mas, como regra, <b>n√£o h√° descarte de dispositivos de disco</b> .  Informa√ß√µes sobre a carga dos discos, qual largura de banda est√° atualmente nos discos e o valor da lat√™ncia sempre deve ser adicionado ao monitoramento.  Isso o ajudar√° a avaliar rapidamente como as unidades s√£o carregadas. <br><br>  Existem muitas op√ß√µes de monitoramento do PostgreSQL, existem para todos os gostos.  Aqui est√£o alguns pontos que devem estar presentes. <br><br><ul><li>  <b>Clientes conectados</b> .  √â necess√°rio monitorar com quais status eles trabalham, encontrar rapidamente os clientes "nocivos" que prejudicam o banco de dados e desativ√°-los. </li><li>  <b>Erros</b>  √â necess√°rio monitorar os erros para rastrear como o banco de dados funciona: nenhum erro - √≥timo, erros apareceram - uma raz√£o para examinar os logs e come√ßar a entender o que est√° errado. </li><li>  <b>Pedidos (declara√ß√µes)</b> .  Monitoramos as caracter√≠sticas quantitativas e qualitativas das solicita√ß√µes para avaliar aproximadamente se temos solicita√ß√µes lentas, longas ou com uso intenso de recursos. </li></ul><br>  Para obter mais informa√ß√µes, consulte o relat√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúNo√ß√µes b√°sicas de monitoramento do PostgreSQL‚Äù</a> com o HighLoad ++ Siberia e a p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitoramento</a> no Wiki do PostgreSQL. <br><br>  Quando planejamos tudo e "nos cobrimos" com o monitoramento, ainda podemos encontrar alguns problemas. <br><br><h3>  Dimensionamento </h3><br>  Normalmente, o desenvolvedor v√™ a linha do banco de dados na configura√ß√£o.  Ele n√£o est√° particularmente interessado em como isso √© organizado internamente - como o ponto de verifica√ß√£o, a replica√ß√£o e o agendador funcionam.  O desenvolvedor j√° tem algo a fazer - no todo, h√° muitas coisas interessantes que ele deseja experimentar. <br><br><blockquote>  "D√™-me o endere√ßo da base, ent√£o eu mesmo."  ¬© desenvolvedor an√¥nimo. </blockquote><br>  A ignor√¢ncia do assunto leva a consequ√™ncias bastante interessantes quando o desenvolvedor come√ßa a escrever consultas que funcionam nesse banco de dados.  √Äs vezes, fantasias ao escrever consultas oferecem efeitos impressionantes. <br><br>  Existem dois tipos de transa√ß√µes.  <b>As transa√ß√µes OLTP</b> s√£o r√°pidas, curtas e leves, que levam fra√ß√µes de um milissegundo.  Eles se exercitam muito rapidamente, e existem muitos deles.  <b>OLAP - consultas anal√≠ticas</b> - lentas, longas, pesadas, leem grandes matrizes de tabelas e leem estat√≠sticas. <br><br>  <b>Nos</b> √∫ltimos 2 <b>a</b> 3 anos, a abreviatura <b>HTAP</b> geralmente soa - Transa√ß√£o h√≠brida / processamento anal√≠tico ou processamento <b>transacional-anal√≠tico h√≠brido</b> .  Se voc√™ n√£o tiver tempo para pensar sobre o dimensionamento e a diversidade de solicita√ß√µes OLAP e OLTP, poder√° dizer: "Temos o HTAP!"  Mas a experi√™ncia e a dificuldade dos erros mostram que, afinal, diferentes tipos de solicita√ß√µes devem viver separadamente uma da outra, porque solicita√ß√µes OLAP longas bloqueiam solicita√ß√µes OLTP leves. <br><br>  Ent√£o chegamos √† quest√£o de como escalar o PostgreSQL para espalhar a carga, e todos ficaram satisfeitos. <br><br>  <b>Replica√ß√£o de streaming</b> .  A op√ß√£o mais f√°cil √© <b>a replica√ß√£o de streaming</b> .  Quando o aplicativo trabalha com o banco de dados, conectamos v√°rias r√©plicas a esse banco de dados e distribu√≠mos a carga.  A grava√ß√£o ainda vai para a base principal e a leitura para r√©plicas.  Este m√©todo permite que voc√™ dimensione muito amplamente. <br><br>  Al√©m disso, voc√™ pode conectar mais r√©plicas a r√©plicas individuais e obter <b>replica√ß√£o em cascata</b> .  Grupos de usu√°rios ou aplicativos separados que, por exemplo, leem an√°lises, podem ser movidos para uma r√©plica separada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Publica√ß√µes l√≥gicas, assinaturas</b> - o mecanismo de publica√ß√µes e assinaturas l√≥gicas implica a presen√ßa de v√°rios servidores PostgreSQL independentes, com bancos de dados e conjuntos de tabelas separados.  Esses conjuntos de tabelas podem ser conectados a bancos de dados vizinhos; eles estar√£o vis√≠veis para aplicativos que podem us√°-los normalmente.  Ou seja, todas as altera√ß√µes que ocorrem na origem s√£o replicadas para a base de destino e s√£o vis√≠veis l√°.  Funciona muito bem com o PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Tabelas estrangeiras, particionamento declarativo - particionamento declarativo e tabelas externas</b> .  Voc√™ pode pegar v√°rios PostgreSQL e criar v√°rios conjuntos de tabelas para armazenar os intervalos de dados desejados.  Podem ser dados para um ano espec√≠fico ou dados coletados em qualquer intervalo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Usando o mecanismo de tabelas externas, voc√™ pode combinar todos esses bancos de dados na forma de uma tabela particionada em um PostgreSQL separado.  Um aplicativo j√° pode funcionar com essa tabela particionada, mas na verdade ele ler√° dados de parti√ß√µes remotas.  Quando os volumes de dados s√£o mais do que os recursos de um √∫nico servidor, isso √© fragmenta√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  Tudo isso pode ser combinado com configura√ß√µes espalhadas, para criar diferentes topologias de replica√ß√£o do PostgreSQL, mas como tudo funciona e como gerenci√°-lo √© o t√≥pico de um relat√≥rio separado. <br><br><h3>  Por onde come√ßar? </h3><br>  A op√ß√£o mais f√°cil √© <b>com replica√ß√£o</b> .  O primeiro passo √© espalhar a carga na leitura e na escrita.  Ou seja, escreva para o mestre e leia as r√©plicas.  Ent√£o, escalamos a carga e realizamos a leitura do assistente.  Al√©m disso, n√£o se esque√ßa dos analistas.  As consultas anal√≠ticas funcionam por um longo per√≠odo de tempo, elas precisam de uma r√©plica separada com configura√ß√µes separadas para que consultas anal√≠ticas longas n√£o possam interferir no restante. <br><br>  O pr√≥ximo passo √© <b>equilibrar</b> .  Ainda temos a mesma linha na configura√ß√£o em que o desenvolvedor opera.  Ele precisa de um lugar onde ele escreva e leia.  Existem v√°rias op√ß√µes aqui. <br><br>  O ideal √© implementar o balanceamento <b>no n√≠vel do aplicativo</b> , quando o pr√≥prio aplicativo souber de onde ler os dados e souber escolher uma r√©plica.  Suponha que um saldo da conta seja sempre atualizado e precise ser lido pelo mestre, e a imagem ou informa√ß√µes sobre o produto possam ser lidas com algum atraso e feitas a partir de uma r√©plica. <br><br><ul><li>  <b>O DNS Round Robin</b> , na minha opini√£o, n√£o √© uma implementa√ß√£o muito conveniente, porque √†s vezes funciona por um longo per√≠odo de tempo e n√£o fornece o tempo necess√°rio ao alternar fun√ß√µes de assistente entre servidores em casos de failover. </li><li>  Uma op√ß√£o mais interessante √© usar o <b>Keepalived e o HAProxy</b> .  Endere√ßos virtuais para o mestre e o conjunto de r√©plicas s√£o lan√ßados entre servidores HAProxy, e o HAProxy j√° est√° equilibrando o tr√°fego. </li><li>  <b>Patroni, DCS</b> em conjunto com algo como ZooKeeper, etcd, Consul - a op√ß√£o mais interessante, na minha opini√£o.  Ou seja, a descoberta de servi√ßo √© respons√°vel pelas informa√ß√µes sobre quem √© o mestre agora e quem √© a r√©plica.  Patroni gerencia um cluster do PostgreSQL'ov, realiza a altern√¢ncia - se a topologia mudou, essas informa√ß√µes aparecer√£o na descoberta de servi√ßos e os aplicativos poder√£o descobrir rapidamente a topologia atual. </li></ul><br>  E h√° nuances na replica√ß√£o, a mais comum delas √© o <b>atraso</b> na <b>replica√ß√£o</b> .  Voc√™ pode fazer isso como o GitLab e, quando o atraso se acumular, basta soltar a base.  Mas temos um monitoramento abrangente - analisamos e vemos transa√ß√µes longas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Aplicativos e transa√ß√µes de DBMS </h3><br>  Em geral, transa√ß√µes lentas e ociosas resultam em: <br><br><ul><li>  <b>diminui√ß√£o da produtividade</b> - n√£o para um espasm√≥dico acentuado, mas suave; <br></li><li>  <b>bloqueios e deadlocks</b> , porque transa√ß√µes longas mant√™m bloqueios em linhas e impedem que outras transa√ß√µes funcionem; <br></li><li>  <b>50 * Erros de HTTP no back-end</b> , erros de interface ou outro local. <br></li></ul><br><br>  Vamos examinar uma pequena teoria sobre como esses problemas surgem e por que o mecanismo de transa√ß√µes longas e ociosas √© prejudicial. <br><br>  O PostgreSQL possui MVCC - relativamente falando, um mecanismo de banco de dados.  Ele permite que os clientes trabalhem competitivamente com os dados sem interferir entre si: os leitores n√£o interferem nos leitores e os escritores n√£o interferem nos escritores.  Obviamente, existem algumas exce√ß√µes, mas neste caso elas n√£o s√£o importantes. <br><br>  Acontece que no banco de dados de uma linha pode haver v√°rias vers√µes para transa√ß√µes diferentes.  Os clientes se conectam, o banco de dados fornece a eles instant√¢neos de dados e, dentro desses instant√¢neos, podem existir diferentes vers√µes da mesma linha.  Assim, no ciclo de vida do banco de dados, as transa√ß√µes s√£o alteradas, substituem-se e as vers√µes das linhas parecem desnecess√°rias. <br><br>  Portanto, √© <b>necess√°rio um coletor de lixo - o aspirador autom√°tico</b> .  Existem transa√ß√µes longas e impedem que o v√°cuo autom√°tico limpe as vers√µes de linhas desnecess√°rias.  Esses dados indesejados come√ßam a vagar da mem√≥ria para o disco, do disco para a mem√≥ria.  Para armazenar esse lixo, os recursos da CPU e da mem√≥ria s√£o desperdi√ßados. <br><br><blockquote>  Quanto mais longa a transa√ß√£o, mais lixo e menor desempenho. </blockquote><br>  Do ponto de vista de "Quem √© o culpado?", O aplicativo √© o respons√°vel pelo aparecimento de transa√ß√µes longas.  Se o banco de dados existir por si s√≥, transa√ß√µes longas e sem nada ser√£o tomadas de qualquer lugar.  Na pr√°tica, existem as seguintes op√ß√µes para a apar√™ncia de transa√ß√µes inativas. <br><br>  <b>"Vamos para uma fonte externa</b> . <b>"</b>  O aplicativo abre uma transa√ß√£o, faz algo no banco de dados e decide recorrer a uma fonte externa, por exemplo, Memcached ou Redis, na esperan√ßa de retornar ao banco de dados, continuar trabalhando e fechar a transa√ß√£o.  Mas se ocorrer um erro na fonte externa, o aplicativo trava e a transa√ß√£o permanece fechada at√© que algu√©m perceba e o mate. <br><br>  <b>Sem manipula√ß√£o de erros</b> .  Por outro lado, pode haver um problema ao lidar com erros.  Quando, novamente, o aplicativo abriu uma transa√ß√£o, resolveu algum problema no banco de dados, retornou √† execu√ß√£o do c√≥digo, executou algumas fun√ß√µes e c√°lculos, a fim de continuar trabalhando na transa√ß√£o e fech√°-la.  Quando nesses c√°lculos a opera√ß√£o do aplicativo foi interrompida com um erro, o c√≥digo retornou ao in√≠cio do ciclo e a transa√ß√£o permaneceu novamente fechada. <br><br>  <b>O fator humano</b> .  Por exemplo, um administrador, desenvolvedor, analista, trabalha em algum pgAdmin ou no DBeaver - abriu uma transa√ß√£o, faz algo nela.  Ent√£o a pessoa se distraiu, mudou para outra tarefa e depois para a terceira, esqueceu a transa√ß√£o, deixou para o fim de semana e a transa√ß√£o continua paralisada.  O desempenho b√°sico sofre. <br><br>  Vamos ver o que fazer nesses casos. <br><br><ul><li>  Temos monitoramento; portanto, precisamos de <b>alertas no monitoramento</b> .  Qualquer transa√ß√£o que trava por mais de uma hora e n√£o faz nada √© uma ocasi√£o para ver de onde veio e entender o que est√° errado. </li><li>  O pr√≥ximo passo √© <b>filmar essas transa√ß√µes atrav√©s da tarefa na coroa</b> (pg_terminate_backend (pid)) ou configurar na configura√ß√£o do PostgreSQL.  S√£o necess√°rios limites de 10 a 30 minutos, ap√≥s os quais as transa√ß√µes s√£o conclu√≠das automaticamente. </li><li>  <b>Refatora√ß√£o de aplicativo</b> .  Obviamente, voc√™ precisa descobrir de onde v√™m as transa√ß√µes inativas, por que elas ocorrem e eliminar esses locais. </li></ul><br><blockquote>  Evite transa√ß√µes longas a todo custo, pois elas afetam bastante o desempenho do banco de dados. </blockquote><br>  Tudo se torna ainda mais interessante quando tarefas pendentes aparecem, por exemplo, voc√™ precisa calcular cuidadosamente as unidades.  E chegamos √† quest√£o da constru√ß√£o de bicicletas. <br><br><h3>  Constru√ß√£o de bicicletas </h3><br>  T√≥pico dolorido.  Os neg√≥cios no lado do aplicativo precisam executar o processamento de eventos em segundo plano.  Por exemplo, para calcular agregados: valor m√≠nimo, m√°ximo e m√©dio, enviar notifica√ß√µes aos usu√°rios, cobrar clientes, configurar a conta de um usu√°rio ap√≥s o registro ou o registro em servi√ßos vizinhos - fa√ßa o processamento atrasado. <br><br>  A ess√™ncia dessas tarefas √© a mesma - elas s√£o adiadas para mais tarde.  As tabelas aparecem no banco de dados que apenas executam as filas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  Aqui est√° o identificador da tarefa, o hor√°rio em que a tarefa foi criada, quando atualizada, o manipulador que a executou, o n√∫mero de tentativas para concluir.  Se voc√™ tiver uma tabela que se assemelhe remotamente a esta, ter√° <b>filas auto-escritas</b> . <br><br>  Tudo isso funciona bem at√© que transa√ß√µes longas apare√ßam.  Depois disso, as <b>tabelas que funcionam com filas aumentam de tamanho</b> .  Novos trabalhos s√£o adicionados o tempo todo, antigos s√£o exclu√≠dos, atualiza√ß√µes acontecem - uma tabela com grava√ß√£o intensiva √© obtida.  Ele deve ser limpo regularmente de vers√µes desatualizadas de seq√º√™ncias de caracteres para que o desempenho n√£o sofra. <br><br>  <b>O tempo de processamento est√° aumentando</b> - uma transa√ß√£o longa mant√©m um bloqueio em vers√µes desatualizadas de linhas ou impede que o v√°cuo a limpe.  Quando a tabela aumenta de tamanho, o tempo de processamento tamb√©m aumenta, pois voc√™ precisa ler muitas p√°ginas com lixo.  O tempo aumenta e, <b>em algum momento</b> , a <b>fila deixa de funcionar</b> . <br><br>  Abaixo est√° um exemplo da parte superior de um de nossos clientes que tinha uma fila.  Todas as solicita√ß√µes est√£o relacionadas apenas √† fila. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Preste aten√ß√£o no tempo de execu√ß√£o dessas solicita√ß√µes - todas, exceto uma, funcionam por mais de vinte segundos. <br><br>  Para resolver esses problemas, o <b>Skytools PgQ</b> , um gerenciador de filas do PostgreSQL, foi inventado h√° muito tempo.  N√£o reinvente sua bicicleta - pegue o PgQ, configure-o uma vez e esque√ßa as linhas. <br><br>  √â verdade que ele tamb√©m tem recursos.  O Skytools PgQ possui <b>pouca documenta√ß√£o</b> .  Depois de ler a p√°gina oficial, sente-se que ele n√£o entendeu nada.  O sentimento cresce quando voc√™ tenta fazer algo.  Tudo funciona, mas <b>como funciona n√£o est√° claro</b> .  Algum tipo de magia Jedi.  Mas muita informa√ß√£o pode ser encontrada nas <b>listas de discuss√£o</b> .  Este n√£o √© um formato muito conveniente, mas existem muitas coisas interessantes, e voc√™ ter√° que ler estas folhas. <br><br>  Apesar dos contras, o Skytools PgQ trabalha com o princ√≠pio de "configurar e esquecer".   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     ‚Äî  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> ‚Äî       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  ‚Äî  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         ‚Äî   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> ‚Äî  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> ‚Äî bash-  .    ,   ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Patroni</b></a> ‚Äî   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>PAF</b></a> ‚Äî <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> ¬´      Kubernetes...¬ª</i>    . <br><br> <b> ‚Äî   stateful</b> ,   - .  Onde      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       ‚Äî <b>    </b> . ,      Kubernetes,     CEPH.         ‚Äî    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        ‚Äî    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes ‚Äî  </b>     , <b>streaming replication ‚Äî   </b> ,       <b>PostgreSQL-</b> ,       ‚Äî ,   .       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zalando</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  Sum√°rio </h2><br> <b>         SSD</b> ‚Äî          ,    . <br><br> <b>     </b> .   JSON  8  ‚Äî  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  ‚Äî Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   ‚Äî <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad++ Siberia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  ,    ,           .   38    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ‚Äî     ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455248/">https://habr.com/ru/post/pt455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455234/index.html">Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</a></li>
<li><a href="../pt455236/index.html">Comodo revoga certificados sem motivo</a></li>
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relat√≥rio de erros</a></li>
<li><a href="../pt455244/index.html">Hist√≥ria em quadrinhos "A soldagem √© f√°cil" na vers√£o atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscri√ß√µes para o Customer Experience Day em S√£o Petersburgo est√£o abertas em 20 de junho</a></li>
<li><a href="../pt455250/index.html">Aquele que ressuscitou Duke Nukem: entrevista com Randy Pitchford, m√°gico da Gearbox</a></li>
<li><a href="../pt455252/index.html">.NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1</a></li>
<li><a href="../pt455256/index.html">Habr Weekly # 4 / Computex, como beta da Apple, Durov est√° morrendo de fome, gato BadComedian, por que a rede neural procurou atores pornogr√°ficos</a></li>
<li><a href="../pt455258/index.html">Come√ßou a vota√ß√£o dos relat√≥rios da se√ß√£o Backend no anivers√°rio do DevConfX, que ser√° realizada de 21 a 22 de junho em Moscou</a></li>
<li><a href="../pt455260/index.html">√Årvore Merkle: enferrujado e r√°pido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>