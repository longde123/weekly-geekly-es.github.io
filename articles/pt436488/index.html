<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèø üë∞üèº üî® Caril e aplica√ß√£o parcial em C ++ 14 üßîüèΩ üç∏ üë∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, vou falar sobre uma das op√ß√µes de curry e aplica√ß√£o parcial das fun√ß√µes em C ++, que √© meu favorito. Tamb√©m vou mostrar minha pr√≥pria im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caril e aplica√ß√£o parcial em C ++ 14</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436488/"><p>  Neste artigo, vou falar sobre uma das op√ß√µes de curry e aplica√ß√£o parcial das fun√ß√µes em C ++, que √© meu favorito.  Tamb√©m vou mostrar minha pr√≥pria implementa√ß√£o piloto dessa coisa e explicar o ponto de currying sem f√≥rmula matem√°tica complexa, tornando isso realmente simples para voc√™.  Tamb√©m veremos o que h√° por <a href="" title="kari.hpp">tr√°s da</a> biblioteca <a href="" title="kari.hpp">kari.hpp</a> que usaremos para fun√ß√µes de curry.  De qualquer forma, h√° muitas coisas fascinantes por dentro, ent√£o seja bem-vindo! </p><a name="habracut"></a><br><h2 id="currying">  Currying </h2><br><p>  Ent√£o, o que √© currying?  Eu acho que √© uma daquelas palavras que voc√™ ouve dos programadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Haskell">Haskell</a> o tempo todo (depois da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="M√¥nada">m√¥nada</a> , √© claro).  Essencialmente, a defini√ß√£o do termo √© bastante simples; portanto, os leitores que j√° escreveram em idiomas do tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="ML">ML</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Haskell">Haskell</a> , ou que sabem o que isso significa em outros lugares, ficam √† vontade para pular esta se√ß√£o. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Currying">Currying</a> - √© a t√©cnica de transformar uma fun√ß√£o que leva N argumentos em uma fun√ß√£o, que pega um √∫nico argumento e retorna a fun√ß√£o do pr√≥ximo argumento, e continua at√© que retornemos a fun√ß√£o do √∫ltimo argumento, que representar√° o resultado geral.  Eu acho que ajuda se eu mostrar exemplos: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }</code> </pre> <br><p>  Aqui temos uma fun√ß√£o de adi√ß√£o bin√°ria.  E se quisermos transform√°-lo em fun√ß√£o de vari√°vel √∫nica?  Na verdade, √© muito simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum2(lhs, rhs); }; }</code> </pre> <br><p>  N√£o, o que fizemos?  Pegamos um valor com base em um √∫nico argumento chamado lambda que, por sua vez, pega o segundo argumento e executa a adi√ß√£o em si.  Como resultado, podemos aplicar a fun√ß√£o <strong><code>curried_sum2</code></strong> aos nossos argumentos um por um: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum2(40, 2) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum2(40)(2) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  E esse √© realmente o objetivo da opera√ß√£o de curry.  Claro, √© poss√≠vel faz√™-lo com fun√ß√µes de qualquer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Arity">aridade</a> - vai funcionar absolutamente da mesma maneira.  Retornaremos uma fun√ß√£o ao curry de argumentos N-1 toda vez que extrairmos o valor de outro argumento: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v3){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum3(v1, v2, v3); }; }; } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum3(38, 3, 1) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum3(38)(3)(1) &lt;&lt; std::endl;</span></span></code> </pre> <br><h2 id="partial-application">  Aplica√ß√£o parcial </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Aplica√ß√£o parcial">Aplica√ß√£o parcial</a> - √© uma maneira de chamar fun√ß√µes de N argumentos quando eles pegam apenas uma parte dos argumentos e retornam outra fun√ß√£o dos argumentos restantes. </p><br><p>  Nesse sentido, deve-se notar que em linguagens como Haskell esse processo funciona automaticamente, nas costas de um programador.  O que estamos tentando fazer aqui √© execut√°-lo explicitamente, <strong><code>sum3</code></strong> , chamar nossa fun√ß√£o <strong><code>sum3</code></strong> assim: <strong><code>sum3(38,3)(1)</code></strong> ou talvez assim: <strong><code>sum3(38)(3,1)</code></strong> .  Al√©m disso, se uma fun√ß√£o retornar outra fun√ß√£o que foi curry, ela tamb√©m poder√° ser chamada usando a lista dos argumentos da primeira fun√ß√£o.  Vamos ver o exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kari::curry(boo, v1 + v2); } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; kari::curry(foo)(38,3,1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38,3)(1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38)(3,1) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  Na verdade, temos um pouco de vantagem aqui, mostrando um exemplo do uso do <a href="" title="kari.hpp">kari.hpp</a> , ent√£o sim, ele faz isso. </p><br><h2 id="setting-the-goals">  Estabelecendo as metas </h2><br><p>  Antes de escrevermos algo, √© necess√°rio (ou desej√°vel) entender o que queremos ter no final.  E queremos ter a oportunidade de curry e aplicar parcialmente qualquer fun√ß√£o que possa ser chamada em C ++.  Quais s√£o: </p><br><ul><li>  lambdas (incluindo gen√©ricos) </li><li>  objetos de fun√ß√£o (functors) </li><li>  fun√ß√µes de qualquer aridade (incluindo modelos) </li><li>  fun√ß√µes variadicas </li><li>  m√©todos de uma classe </li></ul><br><p>  Fun√ß√µes vari√°veis ‚Äã‚Äãpodem ser alteradas especificando um n√∫mero exato de argumentos que queremos curry.  Intera√ß√£o padr√£o com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="std :: bind">std :: bind</a> e seus resultados tamb√©m s√£o desej√°veis.  E, √© claro, precisamos de uma oportunidade para aplicar fun√ß√µes de m√∫ltiplas vari√°veis ‚Äã‚Äãe chamar fun√ß√µes aninhadas, para que pare√ßa que estivemos trabalhando com uma fun√ß√£o ao curry. </p><br><p>  E n√£o devemos esquecer o desempenho tamb√©m.  Precisamos minimizar os custos computacionais dos wrappers, a transfer√™ncia de argumentos e seu armazenamento.  Isso significa que precisamos mudar, em vez de copiar, armazenar apenas o que realmente precisamos e retornar (com mais remo√ß√£o) os dados o mais r√°pido poss√≠vel. </p><br><h3 id="author-youve-been-trying-to-invent-stdbind-one-again">  Autor, voc√™ est√° tentando inventar <strong><code>std::bind</code></strong> one novamente! </h3><br><p>  Sim e n√£o  <strong><code>std::bind</code></strong> √© sem d√∫vida uma ferramenta poderosa e comprovada, e n√£o pretendo escrever seu assassino ou alternativa.  Sim, pode ser usado para aplica√ß√£o parcial e expl√≠cita (com a especifica√ß√£o exata de quais argumentos estamos aplicando, onde e quantos).  Mas √© certo que n√£o √© a abordagem mais conveniente, sem mencionar que nem sempre √© aplic√°vel, pois precisamos conhecer a aridade da fun√ß√£o e escrever liga√ß√µes espec√≠ficas, dependendo disso.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-comment"><span class="hljs-comment">// std::bind auto c0 = std::bind(foo, _1, _2, _3, _4); auto c1 = std::bind(c0, 15, _1, _2, _3); auto c2 = std::bind(c1, 20, 2, _1); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42 // kari.hpp auto c0 = kari::curry(foo); auto c1 = c0(15); auto c2 = c1(20, 2); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><h2 id="api">  API </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_curried</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_curried_v = is_curried&lt;F&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... As &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As&amp;&amp;... as)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; }</code> </pre> <br><hr><br><p> <strong><code>kari::curry(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Retorna um objeto de fun√ß√£o do tipo <strong><code>curry_t</code></strong> (uma fun√ß√£o ao curry) com argumentos opcionais <strong><code>args</code></strong> aplicados ou com o resultado da aplica√ß√£o dos argumentos √† fun√ß√£o dada <strong><code>f</code></strong> (√© a fun√ß√£o ser nula ou os argumentos transferidos foram suficientes para cham√°-lo). </p><br><p>  Se o par√¢metro <strong><code>f</code></strong> contiver a fun√ß√£o que j√° foi curry, ele retornar√° sua c√≥pia com os argumentos <strong><code>args</code></strong> aplicados. </p><br><hr><br><p> <strong><code>kari::curryV(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Permite curry fun√ß√µes com n√∫mero vari√°vel de argumentos.  Depois disso, essas fun√ß√µes podem ser chamadas usando o operador <strong><code>()</code></strong> sem argumentos.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); c2(); <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Se o par√¢metro <strong><code>f</code></strong> contiver uma fun√ß√£o que j√° foi curry, ele retornar√° sua c√≥pia com tipo de aplicativo alterado para n√∫mero vari√°vel de argumentos com os argumentos <strong><code>args</code></strong> aplicados. </p><br><hr><br><p> <strong><code>kari::curryN(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Permite curry fun√ß√µes com n√∫mero vari√°vel de argumentos, especificando um n√∫mero exato <strong><code>N</code></strong> de argumentos que queremos aplicar (exceto os dados em <strong><code>args</code></strong> ).  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>] = {<span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = kari::curryN&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>, buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); c(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; buffer &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Se o par√¢metro <strong><code>f</code></strong> contiver uma fun√ß√£o que j√° foi curry, ele retornar√° sua c√≥pia com tipo de aplicativo alterado para N argumentos com os argumentos <strong><code>args</code></strong> aplicados. </p><br><hr><br><p> <strong><code>kari::is_curried&lt;F&gt;, kari::is_curried_v&lt;F&gt;</code></strong> </p> <br><p>  Algumas estruturas auxiliares para verificar se uma fun√ß√£o j√° foi curry.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> l = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = curry(l); <span class="hljs-comment"><span class="hljs-comment">// output: is `l` curried? no std::cout &lt;&lt; "is `l` curried? " &lt;&lt; (is_curried&lt;decltype(l)&gt;::value ? "yes" : "no") &lt;&lt; std::endl; // output: is `c` curried? yes std::cout &lt;&lt; "is `c` curried? " &lt;&lt; (is_curried_v&lt;decltype(c)&gt; ? "yes" : "no") &lt;&lt; std::endl;</span></span></code> </pre> <br><hr><br><p> <strong><code>kari::curry_t::operator()(As&amp;&amp;... as)</code></strong> </p> <br><p>  O operador permite a aplica√ß√£o total ou parcial de uma fun√ß√£o com curry.  Retorna a fun√ß√£o ao curry dos argumentos restantes da fun√ß√£o inicial <strong><code>F</code></strong> , ou o valor dessa fun√ß√£o obtida por sua aplica√ß√£o no backlog de argumentos antigos e novos argumentos <strong><code>as</code></strong> .  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curry(foo); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// partial application auto rr = c1(2, 5); // function call - foo(15,20,2,5) std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><p>  Se voc√™ chamar uma fun√ß√£o ao curry sem argumentos usando <strong><code>curryV</code></strong> ou <strong><code>curryN</code></strong> , ela ser√° chamada se houver argumentos suficientes.  Caso contr√°rio, ele retornar√° uma fun√ß√£o parcialmente aplicada.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// force call variadic function std::printf c2(); // output: 37 + 5 = 42</span></span></code> </pre> <br><h2 id="details-of-implementation">  Detalhes de implementa√ß√£o </h2><br><p>  Ao fornecer detalhes de implementa√ß√£o, vou usar o C ++ 17 para manter o texto do artigo curto e evitar explica√ß√µes desnecess√°rias e empilhadas na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="SFINAE">SFINAE</a> , al√©m de exemplos de implementa√ß√µes que tive que adicionar no C ++ 14 padr√£o.  Tudo isso voc√™ pode encontrar no <a href="" title="kari.hpp">reposit√≥rio</a> do projeto, onde voc√™ tamb√©m pode adicion√°-lo aos seus favoritos :) </p><br><hr><br><p> <strong><code>make_curry(F&amp;&amp; f, std::tuple&lt;Args...&gt;&amp;&amp; args)</code></strong> </p> <br><p>  Uma fun√ß√£o auxiliar que cria um objeto de fun√ß√£o <strong><code>curry_t</code></strong> ou aplica a fun√ß√£o fornecida <strong><code>f</code></strong> aos argumentos <strong><code>args</code></strong> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( N == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, Args...&gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">curry_t</span></span>&lt; N, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;F&gt;, Args... &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_curry&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple()); }</code> </pre> <br><p>  Agora, h√° duas coisas interessantes sobre essa fun√ß√£o: </p><br><ul><li>  aplicamos aos argumentos apenas se for poss√≠vel chamar esses argumentos e o contador de aplicativos <strong><code>N</code></strong> estiver em zero </li><li>  se a fun√ß√£o n√£o puder ser chamada, consideramos essa chamada como aplica√ß√£o parcial e criamos um objeto de fun√ß√£o <strong><code>curry_t</code></strong> contendo a fun√ß√£o e os argumentos </li></ul><br><hr><br><p> <strong><code>struct curry_t</code></strong> </p> <br><p>  O objeto de fun√ß√£o deveria armazenar o backlog de argumentos e a fun√ß√£o que chamaremos ao aplic√°-lo no final.  Esse objeto √© o que vamos chamar e aplicar parcialmente. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;U&gt;(u))</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(args))</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: F f_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; args_; };</code> </pre> <br><p>  H√° v√°rias raz√µes pelas quais armazenamos o backlog de argumentos <strong><code>args_</code></strong> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="std :: tuple">std :: tuple</a> : </p><br><p>  1) situa√ß√µes com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="std :: ref">std :: ref</a> s√£o tratadas automaticamente para armazenar refer√™ncias quando necess√°rio, por padr√£o, com base no valor <br>  2) aplica√ß√£o conveniente de uma fun√ß√£o de acordo com seus argumentos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="std :: apply">std :: apply</a> ) <br>  3) est√° pronto, para que voc√™ n√£o precise escrev√™-lo do zero :) </p><br><p>  Tamb√©m armazenamos o objeto que chamamos e a fun√ß√£o <strong><code>f_</code></strong> por seu valor, e tenha cuidado ao escolher o tipo ao criar um (vou expandir esse problema abaixo), movendo-o ou copiando-o usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="refer√™ncias universais">refer√™ncia universal</a> em o construtor. </p><br><p>  Um par√¢metro de modelo <strong><code>N</code></strong> atua como um contador de aplicativo para fun√ß√µes variadas. </p><br><hr><br><p> <strong><code>curry_t::operator()(const As&amp;...)</code></strong> </p> <br><p>  E, claro, o que faz tudo funcionar - o operador que chama o objeto de fun√ß√£o. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 constexpr decltype(auto) operator()() &amp;&amp; { return detail::make_curry&lt;0&gt;( std::move(f_), std::move(args_)); } // 2 template &lt; typename A &gt; constexpr decltype(auto) operator()(A&amp;&amp; a) &amp;&amp; { return detail::make_curry&lt;(N &gt; 0 ? N - 1 : 0)&gt;( std::move(f_), std::tuple_cat( std::move(args_), std::make_tuple(std::forward&lt;A&gt;(a)))); } // 3 template &lt; typename A, typename... As &gt; constexpr decltype(auto) operator()(A&amp;&amp; a, As&amp;&amp;... as) &amp;&amp; { return std::move(*this)(std::forward&lt;A&gt;(a))(std::forward&lt;As&gt;(as)...); } // 4 template &lt; typename... As &gt; constexpr decltype(auto) operator()(As&amp;&amp;... as) const &amp; { auto self_copy = *this; return std::move(self_copy)(std::forward&lt;As&gt;(as)...); } }</span></span></code> </pre> <br><p>  O operador de chamada possui quatro fun√ß√µes sobrecarregadas. </p><br><ol><li><p>  Uma fun√ß√£o sem par√¢metros que permite iniciar a aplica√ß√£o da fun√ß√£o <strong><code>curryV</code></strong> (criada por <strong><code>curryV</code></strong> ou <strong><code>curryN</code></strong> ).  Aqui, reduzimos o contador do aplicativo para zero, deixando claro que a fun√ß√£o est√° pronta para ser aplicada e, em seguida, fornecemos tudo o que √© necess√°rio para que a fun√ß√£o <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Uma fun√ß√£o de um √∫nico argumento que diminui o contador do aplicativo em 1 (se n√£o estiver em zero) e coloca nosso novo argumento <strong><code>a</code></strong> no backlog dos argumentos <strong><code>args_</code></strong> e transfere tudo isso para <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Uma fun√ß√£o vari√°vel que √© realmente um truque para aplica√ß√£o parcial de v√°rios argumentos.  O que ele faz √© aplic√°-los recursivamente, um por um.  Agora, existem duas raz√µes pelas quais eles n√£o podem ser aplicados de uma s√≥ vez: </p><br><ul><li>  o contador de aplicativos pode chegar a zero antes que n√£o haja mais argumentos </li><li>  a fun√ß√£o <strong><code>f_</code></strong> pode ser chamada anteriormente e retornar outra fun√ß√£o ao curry, portanto todos os pr√≥ximos argumentos ser√£o destinados a ela </li></ul><br></li><li><p>  A √∫ltima fun√ß√£o atua como uma ponte entre chamar <strong><code>curry_t</code></strong> usando <em>lvalue</em> e chamar fun√ß√µes usando <em>rvalue</em> . </p><br></li></ol><br><p>  As tags de fun√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="qualificado">qualificadas para ref</a> tornam todo o processo quase m√°gico.  Para resumir, com a ajuda deles, sabemos que um objeto foi chamado usando a refer√™ncia <em>rvalue</em> e podemos apenas mover os argumentos em vez de copi√°-los no final, chamando a fun√ß√£o <strong><code>make_curry</code></strong> .  Caso contr√°rio, ter√≠amos que copiar os argumentos para ainda ter a oportunidade de chamar essa fun√ß√£o novamente, garantindo que os argumentos ainda estejam l√°. </p><br><h2 id="bonuses">  B√≥nus </h2><br><p>  Antes de prosseguir para a conclus√£o, gostaria de mostrar alguns exemplos do a√ß√∫car sint√°tico que eles t√™m no <a href="" title="kari.hpp">kari.hpp,</a> que podem ser qualificados como b√¥nus. </p><br><h3 id="operator-sections">  Se√ß√µes do operador </h3><br><p>  Os programadores que j√° trabalharam com Haskell devem estar familiarizados com as se√ß√µes do operador, permitindo uma breve descri√ß√£o dos operadores aplicados.  Por exemplo, a estrutura <strong><code>(*2)</code></strong> gera uma fun√ß√£o de argumento √∫nico, retornando o resultado da multiplica√ß√£o desse argumento por 2. Ent√£o, o que eu queria era tentar escrever algo assim em C ++.  Mal disse o que fez! </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(v.begin(), v.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>, _+_); <span class="hljs-comment"><span class="hljs-comment">// result: 15 std::transform(v.begin(), v.end(), v.begin(), _*2); // v = 2, 3, 6, 8, 10 std::transform(v.begin(), v.end(), v.begin(), -_); // v = -2,-3,-6,-8,-10</span></span></code> </pre> <br><h3 id="function-composition">  Composi√ß√£o da fun√ß√£o </h3><br><p>  E √© claro que eu n√£o seria um maluco completo se n√£o tentasse escrever uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Composi√ß√£o da fun√ß√£o">composi√ß√£o de fun√ß√£o</a> .  Como operador de composi√ß√£o, escolhi o <strong><code>operator *</code></strong> como o mais pr√≥ximo (pelo que parece) de todos os s√≠mbolos dispon√≠veis para o sinal de composi√ß√£o em matem√°tica.  Tamb√©m usei para aplicar a fun√ß√£o resultante a um argumento.  Ent√£o, √© isso que eu tenho: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; (_*2) * (_+2) * 4 &lt;&lt; std::endl; // output: 12 // 2 std::cout &lt;&lt; 4 * (_*2) * (_+2) &lt;&lt; std::endl; // output: 10</span></span></code> </pre> <br><ol><li>  composi√ß√£o de fun√ß√µes <strong><code>(*2)</code></strong> e <strong><code>(+2)</code></strong> √© aplicada a <strong><code>4</code></strong> . <strong><code>(4 + 2) * 2 = 12</code></strong> </li><li>  a fun√ß√£o <strong><code>(*2)</code></strong> √© aplicada a <strong><code>4</code></strong> e depois aplicamos <strong><code>(+2)</code></strong> ao resultado. <strong><code>(4 * 2 + 2) = 10</code></strong> </li></ol><br><p>  Da mesma forma que voc√™ pode criar composi√ß√µes bastante complexas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Estilo sem ponto">estilo pointfree</a> , mas lembre-se de que apenas os programadores Haskell entender√£o isso :) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// (. (+2)) (*2) $ 10 == 24 // haskell analog std::cout &lt;&lt; (_*(_+2))(_*2) * 10 &lt;&lt; std::endl; // output: 24 // ((+2) .) (*2) $ 10 == 22 // haskell analog std::cout &lt;&lt; ((_+2)*_)(_*2) * 10 &lt;&lt; std::endl; // output: 22</span></span></code> </pre> <br><h2 id="conclusion">  Conclus√£o </h2><br><p>  Eu acho que era bastante claro antes que n√£o h√° necessidade de usar essas t√©cnicas em projetos reais.  Mas, ainda assim, devo mencionar isso.  Afinal, meu objetivo era provar a mim mesmo e verificar o novo padr√£o C ++.  Eu seria capaz de fazer isso?  E seria C ++?  Bem, acho que voc√™ acabou de ver como n√≥s dois fizemos isso.  E sou muito grato a todos os caras que leram a coisa toda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436488/">https://habr.com/ru/post/pt436488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436476/index.html">Nuvem para seguradoras</a></li>
<li><a href="../pt436480/index.html">Eu fiz um bot que se comunica com os recrutadores para mim e eu gostei</a></li>
<li><a href="../pt436482/index.html">Advanced Three.js: materiais de shader e p√≥s-processamento</a></li>
<li><a href="../pt436484/index.html">Onde encontrar configura√ß√µes de DNS no MacOS</a></li>
<li><a href="../pt436486/index.html">O que est√° acontecendo no mercado de podcast de √°udio</a></li>
<li><a href="../pt436490/index.html">Motorola planeja introduzir a encarna√ß√£o Razr v3</a></li>
<li><a href="../pt436492/index.html">Estamos √† procura de oradores no 10o DIY Mitap 17 de fevereiro de 2019</a></li>
<li><a href="../pt436494/index.html">Substituindo um disco enquanto mant√©m a numera√ß√£o adequada no CEPH</a></li>
<li><a href="../pt436496/index.html">PVS-Studio para Java</a></li>
<li><a href="../pt436498/index.html">Software AG: N√£o apenas ARIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>