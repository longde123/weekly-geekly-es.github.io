<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📏 🕴🏼 🚣🏽 Sketch + Node.js：为许多平台和品牌生成图标。 第二部分 💃🏾 🏰 🎾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是有关创建工具的文章的第二部分，该工具可以导出放置在草图文件中的所有图标：以不同的格式，在不同的平台上使用，并且可以对每个图标进行A / B测试。 

 您可以从链接中阅读第一部分。 



 上次，我们准备了Sketch文件，其中包含所有样式正确且名称正确的图标。 轮到写代码了。 

 只需说我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sketch + Node.js：为许多平台和品牌生成图标。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/442886/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br> 这是有关创建工具的文章的第二部分，该工具可以导出放置在草图文件中的所有图标：以不同的格式，在不同的平台上使用，并且可以对每个图标进行A / B测试。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从链接中</a>阅读第一部分。 <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br> 上次，我们准备了Sketch文件，其中包含所有样式正确且名称正确的图标。 轮到写代码了。 <br><br> 只需说我们经历了反复试验就足够了。 在奠定脚本基础的团队负责人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nihil Verma</a>开发了关键源代码之后，我开始了一个过程，该过程至少需要三个阶段的重构和许多修改。 因此，我将不讨论脚本的最终创建形式，而是着眼于今天的工作方式。 <br><a name="habracut"></a><br><h2> 构建脚本 </h2><br> 用Node.js编写的构建脚本在工作中非常简单：通过导入依赖项，声明要处理的Sketch文件列表（这是品牌列表，每个品牌都有与之相关的文件列表），并确保在客户端上安装了Sketch ，脚本依次处理品牌，并对每个品牌执行一系列操作。 <br><br><ol><li> 获取适合品牌的设计令牌（我们需要颜色值）。 <br></li><li> 克隆与品牌相关的Sketch文件，将其解压缩，提取内部JSON文件，并处理其一些内部值（稍后会对此进行更多介绍）。 <br></li><li> 从这些JSON文件（ <i>document.json</i> ， <i>meta.json</i>和<i>pages / pageUniqueID.json</i> ）中读取必要的元数据。 我们对文件中包含的常用样式和资源/图标的列表感兴趣。 <br></li><li> 使用JSON文件再进行几次操作后，它会重新创建档案，并使用Sketch文件（克隆和更新）导出并创建用于三个平台（iOS，Android，Mobile Web）的最终输出文件。 <br></li></ol><br> 可以在这里找到构建脚本的相关部分： <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; {   // get the design tokens for the brand   const brandTokens = getDesignTokens(brand);    // prepare the Sketch files (unzipped) and get a list of them   const sketchUnzipFolders = await prepareSketchFiles({     brand,     sketchFileNames: SKETCH_FILES[brand],     sketchFolder: SKETCH_FOLDER_PATH,     sketchTempFolder: SKETCH_TEMP_PATH   });   // get the Sketch metadata   const sketchMetadata = getSketchMetadata(sketchUnzipFolders);   const sketchDataSharedStyles = sketchMetadata.sharedStyles;   const sketchDataAssets = sketchMetadata.assetsMetadata;   generateAssetsPDF({     platform: 'ios',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsSVGDynamicMobileWeb({     platform: 'mw',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsVectorDrawableDynamicAndroid({     platform: 'android',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   }); }); }</code> </pre> <br> 实际上，管道代码要复杂得多。 这种复杂性的原因在于<code>prepareSketchFiles</code> ， <code>getSketchMetadata</code>和<code>generateAssets[format][platform]</code>函数。 下面，我将尝试更详细地描述它们。 <br><br><h2> 准备草图文件 </h2><br> 组装过程的第一步是准备Sketch文件，此文件随后将用于导出各种平台的资源。 <br><br> 与特定品牌关联的文件（例如，对于Blendr而言，它们是<i>icons_common.sketch</i>和<i>icons_blendr.sketch文件</i> ）被克隆到一个临时文件夹（更确切地说，是在正在处理的品牌命名的子文件夹中）并解压缩。 <br><br> 然后处理JSON文件。 将前缀添加到要进行A / B测试的资源的名称-因此，在导出过程中，它们将以预定义的名称（对应于实验的唯一名称）保存在子文件夹中。 您可以通过存储资源的页面名称来了解该资源是否要接受A / B测试：如果是，该名称将包含前缀“ <i>XP_</i> ”。 <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br><br> 在上面的示例中，导出的资源将存储在“ <i>this__is_an_experiment</i> ”子文件夹中，文件名的形式为“ <i>icon-name [variant-name] .ext</i> ”。 <br><br><h2> 读取草图元数据 </h2><br> 第二个重要步骤是从Sketch文件或内部JSON文件中提取所有必要的元数据。 正如我们在上面看到的，这是两个主要文件（ <i>document.json</i>和<i>meta.json</i> ）和页面文件（ <i>pages / pageUniqueId.json</i> ）。 <br><br>  <i>document.json</i>文件用于获取出现在<i>layerStyles</i>对象的属性下的常见样式的列表： <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": {  "_class": "sharedStyleContainer",  "objects": [    {      "_class": "sharedStyle",      "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4",      "name": "features/feature-like",      "value": {        "_class": "style",        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.10588235408067703,              "green": 0.4000000059604645,              "red": 1            },            "fillType": 0,            "noiseIndex": 0,            "noiseIntensity": 0,            "patternFillType": 1,            "patternTileScale": 1          }        ],        "blur": {...},        "startMarkerType": 0,        "endMarkerType": 0,        "miterLimit": 10,        "windingRule": 1      }    },    ...</code> </pre> <br> 我们将有关每种样式的基本信息存储在键值格式对象中。 稍后将在我们需要基于唯一ID（Sketch中的<code>do_objectID</code>属性）提取样式名称时使用： <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = {  name: object.name,  isFill: _.get(object, 'value.fills[0].color') !== undefined,  isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br> 现在，我们转到<i>meta.json</i>文件并获取页面列表。 我们对它们的<code>unique-id</code>和<code>name</code>感兴趣： <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": {  "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": {    "name": "Icons",    "artboards": {      "3275987C-CE1B-4369-B789-06366EDA4C98": {        "name": "badge-feature-like"      },      "C6992142-8439-45E7-A346-FC35FA01440F": {        "name": "badge-feature-crush"      },      ...      "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": {        "name": "tabbar-livestream"      }      ...    }  },  "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": {    "name": "XP_this__is_an_experiment",    "artboards": {      "31A812E8-D960-499F-A10F-C2006DDAEB65": {        "name": "this__is_an_experiment/tabbar-livestream[variant1]"      },      "20F03053-ED77-486B-9770-32E6BA73A0B8": {        "name": "this__is_an_experiment/tabbar-livestream[variant2]"      },      "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": {        "name": "this__is_an_experiment/tabbar-livestream[control]"      }    }  },</code> </pre> <br> 然后，我们读取与<i>页面</i>文件夹中每个页面相对应的JSON文件（我重复说，文件名的格式为<i>[pageUniqueId] .json</i> ），并<i>检查</i>存储在该页面上的资源（它们看起来像图层）。 因此，我们得到每个图标的<b>名称</b> ， <b>宽度/高度，</b>该层图标的Sketch <b>元数据</b> 。如果要处理<b>实验</b>页面，则需要获得<b>A / B测试</b>的名称以及该图标的<b>变体</b> 。 <br><br>  <i>注意</i> ：page.json对象具有非常复杂的设备，因此我不再赘述。 如果您对其中的内容感兴趣，建议您创建一个新的空Sketch文件，向其中添加一些内容并保存； 然后将其扩展名重命名为ZIP，解压缩并检查pages文件夹中的文件之一。 <br><br> 在处理画板的过程中，我们还将创建<b>实验列表</b> （和相关资源）。 我们将需要它来确定在哪个实验中使用了哪个图标变体-图标变体的名称附加到“基础”对象上。 <br><br> 对于每个要处理的品牌<code>assetsMetadata</code> Sketch文件，我们创建一个<code>assetsMetadata</code>对象： <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": {  "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977",  ...sketch_artboard_properties,  "name": "navigation-bar-edit",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  "layers": [    {      "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4",      "name": "Path",      ...sketch_layer_properties,      "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5",      "style": {        ...        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.8784313725490196,              "green": 0.8784313725490196,              "red": 0.8784313725490196            },          }        ],        "miterLimit": 10,        "startMarkerType": 0,        "windingRule": 1      },    },  ],  ... }, "experiment-name/navigation-bar-edit[variant]": {  "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7",  ...sketch_artboard_properties,  "name": "experiment-name/navigation-bar-edit[variant]",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  ...</code> </pre> <br> 如您所见，在实验中，一个图标（在本例中为<i>Navigation-bar-edit</i> ）可以对应许多资源。 同时，相同的图标可能会在与该品牌相关联的另一个Sketch文件中以相同的名称出现。  <b>这非常有用</b> ：我们使用此技巧来编译一组通用的图标，然后根据品牌标识特定的选项。 这就是为什么我们将与特定品牌关联的Sketch文件声明为数组的原因： <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br> 在这种情况下，顺序至关重要。 实际上，在脚本调用的<code>getSketchMetadata</code>函数中，我们一次不会作为列表文件返回一个<code>assetsMetadata</code>对象。 相反，我们执行对象的深层合并-我们将它们合并并返回单个<code>assetsMetadata</code>对象。 <br><br> 通常，这无非是将Sketch文件及其资源“逻辑”合并到单个文件中。 但是，逻辑并不像看起来那样简单。 这是我们创建的图表，试图弄清楚当不同文件中具有相同名称（并可能经过A / B测试）的图标与同一品牌相关联时会发生什么： <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br><br><h2> 为不同平台创建不同格式的现成文件 </h2><br> 我们流程的最后阶段是直接为不同平台创建不同格式的图标文件（适用于iOS的PDF，适用于Web的SVG / JSX和适用于Android的VectorDrawable）。 <br><br> 从传递给<code>generateAssets[format][platform]</code>函数的参数数量中可以看到，管道的这一部分最复杂。 这是该过程开始分解并根据平台而变化的地方。 在下面，您将看到脚本的整体逻辑过程，以及与资源生成相关的部分如何分为三个相似但不同的过程： <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br> 要创建具有与所处理品牌相对应的正确颜色的现成资源，我们将需要对JSON文件进行更多操作。 我们遍历应用通用样式的所有层，然后用品牌设计标记中的颜色替换颜色值。 <br><br> 要为Android生成文件，您需要执行其他操作（稍后<code>windingRule</code> ）：我们将每一层的<code>fill-rule</code>属性从<code>even-odd</code>更改<code>non-zero</code> （这由JSON对象的<code>windingRule</code>属性控制，其中1表示“奇/偶” ，而0为“不等于零”）。 <br><br> 完成这些操作后，我们将JSON文件重新打包到标准Sketch文件中，以处理和导出具有更新属性的资源（克隆和更新的文件是普通的Sketch文件，可以打开，查看，编辑，保存等）。 ） <br><br> 之后，我们使用SketchTool（包裹<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Node下</a> ）以适合平台的格式自动导出所有资源。 对于与品牌相关的每个文件（或更确切地说，它们的克隆和更新版本），我们运行以下命令： <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg --scales=1 --output=${destinationFolder} --overwriting`);</code> </pre> <br> 您可能会猜到，此命令以特定格式将资源导出到目标文件夹，可以选择使用缩放（我们暂时保留原始缩放）。 这里的关键是<code>-overwriting</code>选项：就像我们对<code>assetsMetadata</code>对象进行深层合并（对应于“逻辑” Sketch文件）一样，在导出时，我们<code>assetsMetadata</code>许多文件合并到一个目录中（与品牌/平台有关）。 这意味着如果资源（由图层名称标识）在先前的Sketch文件中已经存在，则它将在下一次导出期间被覆盖。 同样，这仅是正常的合并操作。 <br><br> 但是，在此示例中，某些资源可能变成了“鬼”。 当文件中的图标经过A / B测试，但在后续文件中被覆盖时，会发生这种情况。 然后，将变体文件导出到目标文件夹，并具有一个与<code>assetsMetadata</code>对象中的资源相对应的链接（及其键和属性），但不与任何基础资源关联（由于<code>assetsMetadata</code>对象的深度合并）。 在完成此过程之前，稍后将删除此类文件。 <br><br><hr><br> 如前所述，不同的平台需要不同的输出格式。  iOS文件适合PDF，我们可以使用SketchTool命令直接将其导出。  JSX文件对于Mobile Web是必需的，而VectorDrawable对于Android是必需的。 因此，我们将SVG格式的资源导出到一个临时文件夹中，然后我们对其进行处理。 <br><br><h2> 适用于iOS的PDF </h2><br> 奇怪的是，PDF是Xcode和OS / iOS支持导入和呈现矢量资源的唯一（？）格式（以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是对</a> Apple选择<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的简短说明</a> ）。 <br><br> 由于我们可以通过SketchTool直接导出为PDF，因此无需其他步骤：只需将文件直接保存到目标文件夹即可。 <br><br><h2>  React / JSX Web文件 </h2><br> 对于Web，我们使用SVGR库Node，它允许您将SVG转换为React组件。 但是，我们想要突然做一些事情：在运行时对图标“动态着色”（颜色取自标记）。 为此，在转换之前，我们将矢量的<code>fill</code>值更改为以前将通用样式应用于矢量的<code>fill</code>值，以将其替换为与该样式对应的标记中的值。 <br><br> 因此，如果从Sketch导出的<i>badge-feature-like.svg</i>文件看起来像这样： <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) -&lt;a href="http://www.bohemiancoding.com/sketch"&gt; http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt;  &lt;g id="badge-feature-like"&gt;    &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt;    &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt;  &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br> 那么最终的resource / <i>badge-feature-like.js图标</i>将如下所示： <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return (  &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt;    &lt;g fill="none" fillRule="evenodd"&gt;      &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt;      &lt;path fill="#FFF" d="M80.4061668,..." /&gt;    &lt;/g&gt;  &lt;/svg&gt; ); };</code> </pre> <br> 如您所见，我们用从标记中获取值的动态<code>fill</code>色替换了静态<code>fill</code>色（可以通过Context API将其用于React <code>&lt;Icon/&gt;</code>组件，但这是另一回事了）。 <br><br>  <code>assetsMetadata</code>资产元数据对象的资产的Sketch元数据，可以进行替换：递归地遍历图层，您可以创建一个DOM选择器（例如上<code>#Icons</code> <code>#badge-feature-like #circle</code> <code>#Icons</code> <code>#badge-feature-like #circle</code> ），并使用它来搜索SVG树中的节点并替换其值<code>fill</code>属性（为此，我们需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cheerio</a>库）。 <br><br><h2>  Android的VectorDrawable文件 </h2><br>  Android支持使用自定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VectorDrawable</a>矢量格式的矢量图形。 通常从SVG到VectorDrawable的转换<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直接在Android Studio中完成</a> 。 但是，我们希望完全自动化该过程，因此我们正在寻找一种使用代码进行转换的方法。 <br><br> 研究了各种工具和库之后，我们决定使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">svg2vectordrawable</a> 。 它不仅得到了积极的支持（无论如何，比其他任何人都更加活跃），而且比其他功能更强大。 <br><br> 现实情况是VectorDrawable和SVG在功能上并不相同：VectorDrawable不支持某些SVG函数（例如，径向渐变和复杂的高亮显示），而最近（从Android API 24开始）就开始支持其他功能。 由此引起的问题之一是较早的版本（最多24个） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不支持fill-rule属性的奇偶值</a> 。 但是，Badoo我们需要支持Android 5及更高版本。 这就是为什么在较早的阶段之一中，我们将Sketch文件<code>fill</code>每个矢量的<code>fill</code>都设为<code>non-zero</code>值的原因。 <br><br> 原则上，设计人员可以手动执行此操作： <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br> 但这很容易忘记并犯错。 因此，我们决定在Android流程中增加一个步骤，在该步骤中，JSON中的所有向量都将自动转换为<code>non-zero</code> 。 这样做是为了将图标导出到SVG时，它们已经是必需的格式，并且Android 5上的设备支持每个创建的VectorDrawable对象。 <br><br> 完成的<i>badge-feature-like.xml</i>文件如下所示： <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path  android:fillColor="?color_feature_liked_you"  android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path  android:fillColor="#FFFFFF"  android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br> 在VectorDrawable文件中，我们插入<code>fill</code>颜色的变量名，这些变量名通过Android应用程序中的通用样式与设计标记相关联。 <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br><br> 值得注意的是，Android Studio对组织资源有严格的要求：名称中没有子文件夹和大写字母！ 因此，我们不得不为图标名称提出一种新格式：对于要测试的资源，它们看起来像这样： <code>ic_icon-name__experiment-name__variant-name</code> 。 <br><br><h2>  JSON字典作为资源库 </h2><br> 将资源文件保存为最终格式后，仅保留收集在汇编过程中获得的所有元信息并将其保存到“字典”中，以供各种平台的代码库导入和使用资源时使用。 <br><br> 从<code>assetsMetadata</code>对象中提取图标的平面列表之后<code>assetsMetadata</code>我们遍历它，并检查每个图标： <br><br><ul><li> 这是常规资源<code>tabbar-livestream</code> （例如<code>tabbar-livestream</code> ）？ 如果是这样，那就离开吧； <br></li><li> 如果这是A / B测试的选项（例如， <i>Experiment / tabbar-livestream [variant]</i> ），我们将其名称，路径，A / B测试的名称和变量与<code>abtests</code>属性相关联 <br> 基本资源（在我们的示例中是<i>tabbar-livestream</i> ），此后，我们从列表/对象中删除有关变体的记录（仅“ base”元素很重要）； <br></li><li> 如果是“ ghost”，则删除文件，然后从列表/对象中删除条目。 <br></li></ul><br> 完成此过程后，词典将包含所有基本图标（以及它们的A / B测试，如果有）的列表，并且仅包含它们。 有关每个选项的信息包括名称，大小，路径，如果该图标经过A / B测试，则还提供有关其各种选项的信息。 <br><br> 该词典以JSON格式保存在<i>品牌</i>和<i>平台</i>的目标文件夹中。 例如，这是为Mobile Web的Blendr应用程序生成的<i>asset.json</i>文件： <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": {    "badge-feature-like": {    "assetname": "badge-feature-like",    "path": "assets/badge-feature-like.jsx",    "width": 64,    "height": 64,    "source": "icons_common"  },  "navigation-bar-edit": {    "assetname": "navigation-bar-edit",    "path": "assets/navigation-bar-edit.jsx",    "width": 48,    "height": 48,    "source": "icons_common"  },  "tabbar-livestream": {    "assetname": "tabbar-livestream",    "path": "assets/tabbar-livestream.jsx",    "width": 128,    "height": 128,    "source": "icons_blendr",    "abtest": {      "this__is_an_experiment": {        "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx",        "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx",        "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx"      },      "a_second-experiment": {        "control": "assets/a_second-experiment/tabbar-livestream__control.jsx",        "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx"      }    }  },  ... } }</code> </pre> <br> 现在剩下的就是将所有<i>资产</i>文件夹打包到ZIP存档中，以便于下载。 <br><br><h2> 总结 </h2><br> 本文中描述的过程，从克隆和处理Sketch文件到将资源导出和转换为平台支持的格式，以及将收集的元信息保存在资源库中，对于构建脚本中宣布的每个品牌都重复进行。 <br><br> 下面的屏幕快照显示了完成该过程后<i>src</i>和<i>dist</i>文件夹的外观： <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br><br> 在此阶段，您可以使用一个简单的命令将所有资源（JSON，ZIP和资源文件）上载到远程存储，并使它们可用于所有平台，以供下载和在代码库中使用。 <br><br> 平台如何准确地接收和处理资源（使用专门为此目的创建的自定义脚本）并不超出本文的范围。 我的一位同事可能在以下其中一篇文章中讨论了这个问题。 <br><br><h2> 结论（和经验教训） </h2><br> 我一直很喜欢Sketch。 多年来，该程序一直是开发人员和设计人员的默认工具。 因此，我很好奇学习诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">html-sketchapp之</a>类的集成工具以及我们可以在工作流和管道中使用的其他类似工具。 <br><br> 我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">和其他许多人一样</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一直在</a>为这样（理想）的过程而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">努力</a> ： <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br> 但是，我必须承认，我开始怀疑Sketch是否适合用作工具，尤其是考虑到设计系统时。 因此，我开始研究其他服务，例如带有开放API的Figma和具有与React方便集成的Framer X的服务，因为我不觉得Sketch倾向于与代码集成（无论它是什么）。 <br><br> 因此，这个项目说服了我。 不完全，但是在很多方面。 <br><br> 尽管Sketch未打开其API，但其文件内部结构的设备本身却是一种“非官方” API。 创建者可以使用加密的名称，也可以在JSON对象中隐藏密钥，但是他们遵循清晰，可读和概念性的命名约定。 我不认为这是偶然的。 <br><br>  Sketch文件可以通过这种方式进行管理，这一事实为我打开了许多未来的发展和改进的道路：从插件检查图标的名称，样式和层结构到与Wiki集成以及与我们的设计系统文档（相互）。 通过在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Electron</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Carlo</a>上创建Node应用程序，我们可以使设计人员更轻松地完成许多例行任务。 <br><br>    (  ,  )   ,  Sketch-   Cosmos  « » —      - Cosmos.   ,        (   ;    ,    — ).    ,      —  ,   ,  . <br><br>      ,  Sketch-  , ,    MVP-,       .    ,     ,     . , , -,  —    ,             .  ,         . <br><br>  :       <i></i> ,      <i></i> .   ,       <i></i> . <br><br> ,    , —   .  ,  ,       ,    (,         A/B-),            Node.js  Sketch. <br><br>   !     . <br><br><h2>  </h2><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> (Mobile Web),     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> (Android)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> (iOS),           . <br><br> , !             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442886/">https://habr.com/ru/post/zh-CN442886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442872/index.html">我如何在Android保护中找到复活节彩蛋，却没有在Google找到工作</a></li>
<li><a href="../zh-CN442876/index.html">使用KSQL，Raspberry Pi和Radio进行噪声映射</a></li>
<li><a href="../zh-CN442880/index.html">虚拟检查点：设置检查表</a></li>
<li><a href="../zh-CN442882/index.html">[视频]“不需要文字”和另外三个项目管理构想</a></li>
<li><a href="../zh-CN442884/index.html">技术已经使您可以与汽车对话</a></li>
<li><a href="../zh-CN442888/index.html">在纯CSS上自定义选择</a></li>
<li><a href="../zh-CN442890/index.html">CYOD？ 应付？ BYOD？</a></li>
<li><a href="../zh-CN442892/index.html">集成商眼中的面向调试的编程或悲伤</a></li>
<li><a href="../zh-CN442896/index.html">在不久的将来，航空企业的全循环生产将成为问题</a></li>
<li><a href="../zh-CN442898/index.html">解决添加到电报组中的垃圾邮件机器人的问题的解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>