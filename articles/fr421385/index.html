<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèè üë®üèæ‚Äçü§ù‚Äçüë®üèª üí® Apprenez OpenGL. Le√ßon 5.10 - Occlusion ambiante de l'espace d'√©cran üö≤ üôåüèø üíß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SSAO 
 Le sujet de l'√©clairage de fond a √©t√© soulev√© par nous dans une le√ßon sur les bases de l'√©clairage , mais seulement en passant. Permettez-moi d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Le√ßon 5.10 - Occlusion ambiante de l'espace d'√©cran</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421385/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  SSAO </h2><br>  Le sujet de l'√©clairage de fond a √©t√© soulev√© par nous dans une le√ßon sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bases de l'√©clairage</a> , mais seulement en passant.  Permettez-moi de vous rappeler que la composante d'arri√®re-plan de l'√©clairage est essentiellement une valeur constante qui est ajout√©e √† tous les calculs de l'√©clairage de la sc√®ne pour simuler le processus <i>de diffusion de la lumi√®re</i> .  Dans le monde r√©el, la lumi√®re subit de nombreux reflets avec des degr√©s d'intensit√© variables, ce qui conduit √† un √©clairage tout aussi in√©gal de parties de la sc√®ne √©clair√©es indirectement.  √âvidemment, une fus√©e √† intensit√© constante n'est pas tr√®s plausible. <br><br>  Un type de calcul approximatif de l'ombrage de l'√©clairage indirect est l'algorithme d' <i>occlusion ambiante (AO</i> ), qui simule l'att√©nuation de l'√©clairage indirect au voisinage des coins, des rides et d'autres irr√©gularit√©s de surface.  Ces √©l√©ments, en g√©n√©ral, se chevauchent consid√©rablement par la g√©om√©trie adjacente et laissent donc moins de rayons de lumi√®re s'√©chapper √† l'ext√©rieur, obscurcissant ces zones. <br><br>  Vous trouverez ci-dessous une comparaison du rendu sans et en utilisant l'algorithme AO.  Faites attention √† la fa√ßon dont l'intensit√© de l'√©clairage d'arri√®re-plan diminue au voisinage des coins des murs et des autres coupures prononc√©es de la surface: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/8z/kv/6s8zkvpob8nbgaails8mtfutgw8.png"></div><br>  Bien que l'effet ne soit pas tr√®s visible, la pr√©sence de l'effet dans toute la sc√®ne lui donne du r√©alisme en raison de l'illusion suppl√©mentaire de profondeur cr√©√©e par les petits d√©tails de l'effet d'auto-occultation. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text">  Partie 1. Pour commencer <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©ation de fen√™tres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fen√™tre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Syst√®mes de coordonn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol><br>  Partie 2. √âclairage de base <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'√©clairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mat√©riaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'√©clairage multiples</a> </li></ol><br>  Partie 3. T√©l√©charger des mod√®les 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de mod√®le 3D</a> </li></ol><br>  Partie 4. Fonctionnalit√©s avanc√©es d'OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©lange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avanc√© des donn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avanc√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader g√©om√©trique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol><br>  Partie 5. √âclairage avanc√© <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âclairage avanc√©.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®le Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fant√¥mes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombr√©es omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu diff√©r√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol><br>  Partie 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumi√®re analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition miroir.</a> </li></ol><br></div></div><br>  Il convient de noter que les algorithmes de calcul de l'AO sont assez gourmands en ressources, car ils n√©cessitent une analyse de la g√©om√©trie environnante.  Dans une mise en ≈ìuvre na√Øve, il serait possible d'√©mettre simplement beaucoup de rayons √† chaque point de la surface et de d√©terminer le degr√© de son ombrage, mais cette approche atteint tr√®s rapidement la limite de ressources acceptable pour les applications interactives.  Heureusement, en 2007, Crytek a publi√© un document d√©crivant sa propre approche de la mise en ≈ìuvre de l'algorithme <i>Screen-Space Ambient Occlusion (SSAO</i> ) utilis√© dans la version finale de Crysis.  L'approche a calcul√© le degr√© d'ombrage dans l'espace d'√©cran, en utilisant uniquement le tampon de profondeur actuel au lieu de donn√©es r√©elles sur la g√©om√©trie environnante.  Une telle optimisation a radicalement acc√©l√©r√© l'algorithme par rapport √† l'impl√©mentation de r√©f√©rence et en m√™me temps a donn√© des r√©sultats pour la plupart plausibles, ce qui a fait de cette approche de calcul approximatif de l'ombrage d'arri√®re-plan une industrie de facto standard. <br><br>  Le principe sur lequel l'algorithme est bas√© est assez simple: pour chaque fragment d'un quad en plein √©cran, le <i>facteur d'occlusion est</i> calcul√© en fonction des valeurs de profondeur des fragments environnants.  Le coefficient d'ombrage calcul√© est ensuite utilis√© pour r√©duire l'intensit√© de l'√©clairage de fond (jusqu'√† l'exclusion compl√®te).  L'obtention d'un coefficient n√©cessite de collecter des donn√©es de profondeur √† partir d'une pluralit√© d'√©chantillons de la r√©gion sph√©rique entourant le fragment en question et de comparer ces valeurs de profondeur avec la profondeur du fragment en question.  Le nombre d'√©chantillons ayant une profondeur sup√©rieure au fragment actuel d√©termine directement le coefficient d'ombrage.  Regardez ce diagramme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y5/yh/8o/y5yh8oeqvguchqopeu7nz0g-tsy.png"></div><br>  Ici, chaque point gris se trouve √† l'int√©rieur d'un certain objet g√©om√©trique et contribue donc √† la valeur du coefficient d'ombrage.  Plus il y a d'√©chantillons √† l'int√©rieur de la g√©om√©trie des objets environnants, moins sera l'intensit√© r√©siduelle de l'ombrage d'arri√®re-plan dans cette zone. <br><br>  √âvidemment, la qualit√© et le r√©alisme de l'effet d√©pendent directement du nombre d'√©chantillons pr√©lev√©s.  Avec un petit nombre d'√©chantillons, la pr√©cision de l'algorithme diminue et conduit √† l'apparition d'un artefact de <i>bande</i> ou de ¬´ <i>bande</i> ¬ª d√ª √† des transitions brusques entre r√©gions avec des coefficients d'ombrage tr√®s diff√©rents.  Un grand nombre d'√©chantillons tue simplement les performances.  La randomisation du noyau des √©chantillons permet d'obtenir des r√©sultats quelque peu similaires pour r√©duire l√©g√®rement le nombre d'√©chantillons requis.  Une r√©orientation par rotation vers un angle al√©atoire d'un ensemble de vecteurs d'√©chantillonnage est implicite.  Cependant, l'introduction de l'al√©atoire pose imm√©diatement un nouveau probl√®me sous la forme d'un motif de bruit notable, qui n√©cessite l'utilisation de filtres de flou pour lisser le r√©sultat.  Ci-dessous, un exemple de l'algorithme (auteur - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">John Chapman</a> ) et de ses probl√®mes typiques: bandes et mod√®le de bruit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r_/ay/l3/r_ayl3jjozsa6fyuni69ejkwpei.jpeg"></div><br>  Comme on peut le voir, une bande notable due au petit nombre d'√©chantillons est bien supprim√©e en introduisant une randomisation de l'orientation des √©chantillons. <br><br>  L'impl√©mentation SSAO sp√©cifique de Crytek avait un style visuel reconnaissable.  √âtant donn√© que les sp√©cialistes de Crytek utilisaient un noyau sph√©rique de l'√©chantillon, cela affectait m√™me les surfaces planes telles que les murs, les rendant ombrag√©es - car la moiti√© du volume du noyau de l'√©chantillon √©tait submerg√©e sous la g√©om√©trie.  Ci-dessous est une capture d'√©cran d'une sc√®ne de Crysis montr√©e en niveaux de gris bas√©e sur la valeur du facteur d'ombrage.  Ici, l'effet de la "grisaille" est clairement visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/zr/r8/j9zrr81dluj-5eobuqcgst48om8.jpeg"></div><br>  Pour √©viter cet effet, nous allons passer du noyau sph√©rique de l'√©chantillon √† un h√©misph√®re orient√© le long de la normale √† la surface: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Lors de l'√©chantillonnage √† partir d'un tel <i>h√©misph√®re √† orientation normale,</i> nous n'avons pas √† prendre en compte les fragments se trouvant sous la surface de la surface adjacente dans le calcul du coefficient d'ombrage.  Cette approche supprime les ombres inutiles, en g√©n√©ral, donne des r√©sultats plus r√©alistes.  Cette le√ßon utilisera l'approche h√©misph√©rique et un code un peu plus raffin√© de la brillante le√ßon SSAO de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">John Chapman</a> . <br><br><h2>  Tampon de donn√©es brutes </h2><br>  Le processus de calcul du facteur d'ombrage dans chaque fragment n√©cessite la disponibilit√© de donn√©es sur la g√©om√©trie environnante.  Plus pr√©cis√©ment, nous avons besoin des donn√©es suivantes: <br><br><ul><li>  Positionner le vecteur pour chaque fragment; </li><li>  Vecteur normal pour chaque fragment; </li><li>  Couleur diffuse pour chaque fragment; </li><li>  Le c≈ìur de l'√©chantillon </li><li>  Un vecteur de rotation al√©atoire pour chaque fragment utilis√© pour r√©orienter le noyau de l'√©chantillon. </li></ul><br>  En utilisant des donn√©es sur les coordonn√©es du fragment dans l'espace des esp√®ces, nous pouvons orienter l'h√©misph√®re du noyau de l'√©chantillon le long du vecteur normal sp√©cifi√© dans l'espace des esp√®ces pour le fragment actuel.  Ensuite, le noyau r√©sultant est utilis√© pour faire des √©chantillons avec divers d√©calages √† partir d'une texture qui stocke des donn√©es sur les coordonn√©es des fragments.  Nous faisons de nombreux √©chantillons dans chaque fragment, et pour chaque √©chantillon que nous faisons, nous comparons sa valeur de profondeur avec la valeur de profondeur du tampon de coordonn√©es de fragment pour estimer la quantit√© d'ombrage.  La valeur r√©sultante est ensuite utilis√©e pour limiter la contribution du composant d'arri√®re-plan dans le calcul d'√©clairage final.  En utilisant un vecteur de rotation al√©atoire par fragments, nous pouvons r√©duire consid√©rablement le nombre d'√©chantillons requis pour obtenir un r√©sultat d√©cent, et cela sera ensuite d√©montr√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xo/aj/wvxoajroexwvjgq77n81-fjhats.png"></div><br>  Le SSAO √©tant un effet r√©alis√© dans l'espace √©cran, il est possible d'effectuer un calcul direct en effectuant un quadrillage plein √©cran.  Mais alors nous n'aurons pas de donn√©es sur la g√©om√©trie de la sc√®ne.  Pour contourner cette restriction, nous rendrons toutes les informations n√©cessaires dans la texture, qui seront ensuite utilis√©es dans le shader SSAO pour acc√©der √† des informations g√©om√©triques et autres sur la sc√®ne.  Si vous avez suivi attentivement ces le√ßons, vous devez d√©j√† savoir dans l'approche d√©crite l'apparence de l'algorithme d'ombrage diff√©r√©.  C'est en grande partie pourquoi l'effet SSAO en tant que natif appara√Æt dans le rendu avec un ombrage diff√©r√© - apr√®s tout, les textures qui stockent les coordonn√©es et les normales sont d√©j√† disponibles dans le G-buffer. <br><br><blockquote>  Dans cette le√ßon, l'effet est impl√©ment√© au-dessus d'une version l√©g√®rement simplifi√©e du code de la le√ßon sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©clairage diff√©r√©</a> .  Si vous ne vous √™tes pas encore familiaris√© avec les principes de l'√©clairage diff√©r√©, je vous recommande fortement de vous tourner vers cette le√ßon. <br></blockquote><br>  √âtant donn√© que l'acc√®s aux informations de fragment sur les coordonn√©es et les normales devrait d√©j√† √™tre disponible en raison du tampon G, le shader de fragment de l'√©tape de traitement de la g√©om√©trie est assez simple: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 gPosition; layout (location = 1) out vec3 gNormal; layout (location = 2) out vec4 gAlbedoSpec; in vec2 TexCoords; in vec3 FragPos; in vec3 Normal; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        gPosition = FragPos; //       gNormal = normalize(Normal); //    -   gAlbedoSpec.rgb = vec3(0.95); }</span></span></span></span></code> </pre> <br>  √âtant donn√© que l'algorithme SSAO est un effet dans l'espace d'√©cran et que le facteur d'ombrage est calcul√© en fonction de la zone visible de la sc√®ne, il est judicieux d'effectuer des calculs dans l'espace d'affichage.  Dans ce cas, la variable <i>FragPos</i> obtenue √† partir du vertex shader stocke la position exactement dans la fen√™tre.  Il convient de s'assurer que les coordonn√©es et les normales sont stock√©es dans le G-buffer dans l'espace de vue, car tous les autres calculs y seront effectu√©s. <br><br><blockquote>  Il y a la possibilit√© de restaurer le vecteur de position sur la base uniquement d'une profondeur de fragment connue et d'une certaine quantit√© de magie math√©matique, qui est d√©crite, par exemple, dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog de</a> Matt Pettineo.  Bien s√ªr, cela n√©cessite un co√ªt de calcul important, mais cela √©limine le besoin de stocker les donn√©es de position dans le G-buffer, ce qui prend beaucoup de m√©moire vid√©o.  Cependant, dans un souci de simplicit√© de l'exemple de code, nous laisserons cette approche √† l'√©tude personnelle. </blockquote><br>  La texture du tampon de couleur <i>gPosition</i> est configur√©e comme suit: <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</code> </pre> <br>  Cette texture stocke les coordonn√©es des fragments et peut √™tre utilis√©e pour obtenir des donn√©es de profondeur pour chaque point √† partir du noyau des √©chantillons.  Je note que la texture utilise un format de donn√©es √† virgule flottante - cela permettra aux coordonn√©es des fragments de ne pas √™tre r√©duites √† l'intervalle [0., 1.].  <i>Faites</i> √©galement attention au mode de r√©p√©tition - <i>GL_CLAMP_TO_EDGE</i> est d√©fini.  Ceci est n√©cessaire pour √©liminer la possibilit√© de ne pas sur√©chantillonner volontairement l'espace de l'√©cran.  Le d√©passement de l'intervalle principal des coordonn√©es de texture nous donnera des donn√©es de position et de profondeur incorrectes. <br><br>  Ensuite, nous nous engagerons dans la formation d'un noyau h√©misph√©rique des √©chantillons et la cr√©ation d'une m√©thode d'orientation al√©atoire. <br><br><h2>  Cr√©ation d'un h√©misph√®re √† orientation normale </h2><br>  Ainsi, la t√¢che consiste √† cr√©er un ensemble de points d'√©chantillonnage situ√©s √† l'int√©rieur d'un h√©misph√®re orient√© le long de la normale √† la surface.  √âtant donn√© que la cr√©ation d'un √©chantillon de noyau pour toutes les directions possibles de la normale est impossible √† calculer, nous utilisons la transition vers l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">espace tangent</a> , o√π la normale est toujours repr√©sent√©e comme un vecteur dans la direction du demi-axe positif <i>Z.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  En supposant que le rayon de l'h√©misph√®re est un processus unique, la formation d'un noyau d'un √©chantillon de 64 points ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0.0 - 1.0 std::uniform_real_distribution&lt;float&gt; randomFloats(0.0, 1.0); std::default_random_engine generator; std::vector&lt;glm::vec3&gt; ssaoKernel; for (unsigned int i = 0; i &lt; 64; ++i) { glm::vec3 sample( randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) ); sample = glm::normalize(sample); sample *= randomFloats(generator); float scale = (float)i / 64.0; ssaoKernel.push_back(sample); }</span></span></code> </pre> <br>  Ici, nous s√©lectionnons au hasard les coordonn√©es <i>x</i> et <i>y</i> dans l'intervalle [-1., 1.] et la coordonn√©e <i>z</i> dans l'intervalle [0., 1.] (si l'intervalle est le m√™me que pour <i>x</i> et <i>y</i> , nous obtiendrions un noyau sph√©rique √©chantillonnage).  Les vecteurs d'√©chantillons r√©sultants seront limit√©s aux h√©misph√®res, car le noyau de l'√©chantillon sera finalement orient√© le long de la normale √† la surface. <br><br>  √Ä l'heure actuelle, tous les points d'√©chantillonnage sont r√©partis de mani√®re al√©atoire √† l'int√©rieur du noyau, mais pour des raisons de qualit√© de l'effet, les √©chantillons plus proches de l'origine du noyau devraient contribuer davantage au calcul du coefficient d'ombrage.  Cela peut √™tre r√©alis√© en modifiant la distribution des points d'√©chantillonnage form√©s en augmentant leur densit√© pr√®s de l'origine.  Cette t√¢che est facilement accomplie √† l'aide de la fonction d'interpolation d'acc√©l√©ration: <br><br><pre> <code class="cpp hljs">scale = lerp(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, scale * scale); sample *= scale; ssaoKernel.push_back(sample); }</code> </pre> <br>  La fonction <i>lerp ()</i> est d√©finie comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + f * (b - a); }</code> </pre> <br>  Une telle astuce nous donne une distribution modifi√©e, o√π la plupart des points d'√©chantillonnage se trouvent pr√®s de l'origine du noyau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h7/dy/xm/h7dyxm-1zerxg1krzbxszp7kzqi.png"></div><br>  Chacun des vecteurs √©chantillons obtenus sera utilis√© pour d√©placer les coordonn√©es du fragment dans l'espace des esp√®ces afin d'obtenir des donn√©es sur la g√©om√©trie environnante.  Pour obtenir des r√©sultats d√©cents lorsque vous travaillez dans la fen√™tre, vous aurez peut-√™tre besoin d'un nombre impressionnant d'√©chantillons, ce qui affectera in√©vitablement les performances.  Cependant, l'introduction de bruit pseudo-al√©atoire ou la rotation des vecteurs d'√©chantillonnage dans chaque fragment trait√© r√©duira consid√©rablement le nombre requis d'√©chantillons de qualit√© comparable. <br><br><h2>  Rotation al√©atoire du noyau de l'√©chantillon </h2><br>  Ainsi, l'introduction de l'al√©atoire dans la distribution des points dans le noyau de l'√©chantillon peut r√©duire consid√©rablement l'exigence du nombre de ces points pour obtenir un effet de qualit√© d√©cent.  Il serait possible de cr√©er un vecteur de rotation al√©atoire pour chaque fragment de la sc√®ne, mais c'est trop cher de m√©moire.  Il est plus efficace de cr√©er une petite texture contenant un ensemble de vecteurs de rotation al√©atoire, puis de l‚Äôutiliser avec le mode de r√©p√©tition <i>GL_REPEAT</i> . <br><br>  Cr√©ez un tableau 4x4 et remplissez-le de vecteurs de rotation al√©atoire orient√©s le long du vecteur normal dans l'espace tangent: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::vec3&gt; ssaoNoise; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ssaoNoise.push_back(noise); }</code> </pre> <br>  Puisque le noyau est align√© le long du demi-axe positif <i>Z</i> dans l'espace tangent, nous laissons la composante <i>z</i> √©gale √† z√©ro - cela assurera la rotation uniquement autour de l'axe <i>Z.</i> <br><br>  Ensuite, cr√©ez une texture 4x4 et remplissez-la avec notre tableau de vecteurs de rotation.  Assurez-vous d'utiliser le <i>mode de</i> relecture <i>GL_REPEAT</i> pour le pavage de texture: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noiseTexture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;noiseTexture); glBindTexture(GL_TEXTURE_2D, noiseTexture); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number"><span class="hljs-number">0</span></span>]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br>  Eh bien, nous avons maintenant toutes les donn√©es n√©cessaires √† la mise en ≈ìuvre directe de l'algorithme SSAO! <br><br><h2>  Shader SSAO </h2><br>  Un shader d'effet sera ex√©cut√© pour chaque fragment d'un quadruple plein √©cran, calculant le coefficient d'ombrage dans chacun d'eux.  √âtant donn√© que les r√©sultats seront utilis√©s dans une autre √©tape de rendu qui cr√©e l'√©clairage final, nous devrons cr√©er un autre objet framebuffer pour stocker le r√©sultat du shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoColorBuffer; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBuffer); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Comme le r√©sultat de l'algorithme est le seul nombre r√©el dans [0., 1.], pour le stockage, il suffira de cr√©er une texture avec le seul composant disponible.  C'est pourquoi <i>GL_RED</i> est d√©fini comme format interne pour le tampon de couleur. <br><br>  En g√©n√©ral, le processus de rendu d'√©tape SSAO ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :  G- glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); [...] glBindFramebuffer(GL_FRAMEBUFFER, 0); //  G-      SSAO glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); glClear(GL_COLOR_BUFFER_BIT); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, gPosition); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, gNormal); glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, noiseTexture); shaderSSAO.use(); SendKernelSamplesToShader(); shaderSSAO.setMat4("projection", projection); RenderQuad(); glBindFramebuffer(GL_FRAMEBUFFER, 0); //  :    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shaderLightingPass.use(); [...] glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); [...] RenderQuad();</span></span></code> </pre> <br>  Le shader <i>SSAO</i> accepte les textures du tampon G dont il a besoin en entr√©e, ainsi que la texture du bruit et le noyau de l'√©chantillon: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D texNoise; uniform vec3 samples[64]; uniform mat4 projection; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//             //      1280x720 const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); void main() { [...] }</span></span></span></span></code> </pre> <br>  Notez la variable <i>noiseScale</i> .  Notre petite texture avec du bruit devrait √™tre carrel√©e sur toute la surface de l'√©cran, mais puisque les coordonn√©es de texture <i>TexCoords sont</i> dans [0., 1.] cela ne se produira pas sans notre intervention.  √Ä ces fins, nous calculons le facteur pour les coordonn√©es de texture, qui se trouve comme le rapport de la taille de l'√©cran √† la taille de la texture de bruit: <br><br><pre> <code class="cpp hljs">vec3 fragPos = texture(gPosition, TexCoords).xyz; vec3 normal = texture(gNormal, TexCoords).rgb; vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;</code> </pre> <br>  Puisque lors de la cr√©ation de la texture de bruit <i>texNoise</i> , nous avons d√©fini le mode de r√©p√©tition sur <i>GL_REPEAT</i> , il sera maintenant r√©p√©t√© plusieurs fois sur la surface de l'√©cran.  Avec <i>randomVec</i> , <i>fragPos</i> et <i>les</i> valeurs <i>normales</i> , nous pouvons cr√©er une matrice de transformation TBN de l'espace tangent √† l'espace des esp√®ces: <br><br><pre> <code class="cpp hljs">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal)); vec3 bitangent = cross(normal, tangent); mat3 TBN = mat3(tangent, bitangent, normal);</code> </pre> <br>  En utilisant le processus de Gram-Schmidt, nous cr√©ons une base orthogonale inclin√©e de mani√®re al√©atoire dans chaque fragment en fonction de la valeur al√©atoire <i>randomVec</i> .  Un point important: dans ce cas, peu importe pour nous que la matrice TBN soit pr√©cis√©ment orient√©e le long de la surface du triangle (comme dans le cas de la cartographie de parallaxe, environ Per.), Nous n'avons donc pas besoin de donn√©es tangentes et bi-tangentes pr√©calcul√©es. <br><br>  Ensuite, nous parcourons le tableau du noyau de l'√©chantillon, convertissons chaque vecteur √©chantillon de l'espace tangent √† l'espace des esp√®ces et obtenons sa somme avec la position actuelle du fragment.  Ensuite, nous comparons la valeur de profondeur de la quantit√© r√©sultante avec la valeur de profondeur obtenue par √©chantillonnage √† partir de la texture G-buffer correspondante. <br><br>  Bien que cela semble d√©routant, passons par les √©tapes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> occlusion = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kernelSize; ++i) { <span class="hljs-comment"><span class="hljs-comment">//     vec3 sample = TBN * samples[i]; //      - sample = fragPos + sample * radius; [...] }</span></span></code> </pre> <br>  Ici, <i>kernelSize</i> et <i>radius</i> sont des variables qui contr√¥lent les caract√©ristiques de l'effet.  Dans ce cas, ils sont respectivement de 64 et 0,5.  √Ä chaque it√©ration, nous traduisons le vecteur de base de l'√©chantillon dans l'espace des esp√®ces.  Ensuite, nous ajoutons √† la valeur obtenue du d√©placement de l'√©chantillon dans l'espace des esp√®ces la valeur de la position du fragment dans l'espace des esp√®ces.  Dans ce cas, la valeur de d√©calage est multipli√©e par la variable de rayon, qui contr√¥le le rayon du c≈ìur de l'√©chantillon d'effet SSAO. <br><br>  Apr√®s ces √©tapes, nous devons convertir le vecteur <i>√©chantillon</i> r√©sultant en espace d'√©cran, afin de pouvoir s√©lectionner dans la texture du tampon G qui stocke les positions et les profondeurs des fragments en utilisant la valeur projet√©e obtenue.  Puisque l' <i>√©chantillon</i> est dans la fen√™tre, nous avons besoin de la matrice de projection <i>projection</i> : <br><br><pre> <code class="cpp hljs">vec4 offset = vec4(sample, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); offset = projection * offset; <span class="hljs-comment"><span class="hljs-comment">//     offset.xyz /= offset.w; //   offset.xyz = offset.xyz * 0.5 + 0.5; //    [0., 1.]</span></span></code> </pre> <br>  Apr√®s la conversion en espace de clip, nous effectuons manuellement la division en perspective en divisant simplement les composants <i>xyz</i> par le composant <i>w</i> .  Le vecteur r√©sultant en coordonn√©es de p√©riph√©rique normalis√©es ( <i>NDC</i> ) est traduit dans l'intervalle de valeurs [0., 1.] afin qu'il puisse √™tre utilis√© comme coordonn√©es de texture: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleDepth = texture(gPosition, offset.xy).z;</code> </pre> <br>  Nous utilisons les composants <i>xy</i> du vecteur <i>√©chantillon</i> pour s√©lectionner dans la texture les positions du G-buffer.  Nous obtenons la valeur de profondeur (composantes <i>z</i> ) correspondant au vecteur √©chantillon lorsqu'il est vu depuis la position de l'observateur (il s'agit du premier fragment visible non blind√©).  Si en m√™me temps la profondeur d'√©chantillonnage obtenue est sup√©rieure √† la profondeur stock√©e, alors on augmente le coefficient d'ombrage: <br><br><pre> <code class="cpp hljs">occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre> <br>  Notez le d√©calage de <i>biais</i> , qui est ajout√© √† la profondeur du fragment d'origine (d√©fini dans l'exemple √† 0,025).  Ce d√©calage n'est pas toujours requis, mais la pr√©sence d'une variable vous permet de contr√¥ler l'apparence de l'effet SSAO et, dans certaines situations, supprime les probl√®mes d'ondulations dans les zones ombr√©es. <br><br>  Mais ce n'est pas tout, car une telle impl√©mentation conduit √† des artefacts perceptibles.  Il se manifeste dans les cas o√π un fragment situ√© pr√®s du bord d'une certaine surface est consid√©r√©.  Dans de telles situations, lors de la comparaison des profondeurs, l'algorithme capturera in√©vitablement les profondeurs des surfaces, qui peuvent se situer tr√®s loin derri√®re celle consid√©r√©e.  √Ä ces endroits, l'algorithme augmentera consid√©rablement par erreur le degr√© d'ombrage, ce qui cr√©era des halos sombres visibles sur les bords des objets.  L'artefact est trait√© en introduisant une v√©rification de distance suppl√©mentaire (un exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">John Chapman</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/yv/eq/zvyveqh3zc_rjcy6fo-z8d76eme.png"></div><br>  La v√©rification limitera la contribution au coefficient d'ombrage uniquement pour les valeurs de profondeur situ√©es dans le rayon de l'√©chantillon: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rangeCheck = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, radius / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(fragPos.z - sampleDepth)); occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * rangeCheck;</code> </pre> <br>  Nous utilisons √©galement la fonction GLSL <i>smoothstep ()</i> , qui impl√©mente une interpolation douce du troisi√®me param√®tre entre le premier et le second.  En m√™me temps, renvoyer 0 si le troisi√®me param√®tre est inf√©rieur ou √©gal au premier, ou 1 si le troisi√®me param√®tre est sup√©rieur ou √©gal au second.  Si la diff√©rence de profondeur est dans le <i>rayon</i> , alors sa valeur sera liss√©e en douceur dans l'intervalle [0., 1.] conform√©ment √† cette courbe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/9h/p4/jq9hp4-yun_sc277m6pslbjyin0.png"></div><br>  Si nous utilisions des limites claires dans les conditions de v√©rification de la profondeur, cela ajouterait des artefacts sous forme de limites nettes aux endroits o√π les valeurs de la diff√©rence de profondeurs sont en dehors des limites du <i>rayon</i> . <br><br>  Avec la touche finale, nous normalisons la valeur du coefficient d'ombrage en utilisant la taille du noyau de l'√©chantillon et enregistrons le r√©sultat.  Nous inversons √©galement la valeur finale en la soustrayant de l'unit√©, afin que vous puissiez utiliser la valeur finale directement pour moduler le composant d'arri√®re-plan de l'√©clairage sans √©tapes suppl√©mentaires: <br><br><pre> <code class="cpp hljs">} occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = occlusion;</code> </pre> <br>  Pour une sc√®ne avec une nanosuit couch√©e qui nous est famili√®re, l'ex√©cution du shader SSAO donne la texture suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-z/a4/fx/-za4fxhsbref6easc-cgxnsp94q.png"></div><br>  Comme vous pouvez le voir, l'effet de l'ombrage d'arri√®re-plan cr√©e une bonne illusion de profondeur.  Seule l'image de sortie du shader vous permet d√©j√† de distinguer les d√©tails du costume et de vous assurer qu'il repose vraiment sur le sol et ne l√©vite pas √† une certaine distance de celui-ci. <br><br>  N√©anmoins, l'effet est loin d'√™tre id√©al, car le motif de bruit introduit par la texture des vecteurs √† rotation al√©atoire est facilement perceptible.  Pour lisser le r√©sultat du calcul SSAO, nous appliquons un filtre de flou. <br><br><h2>  Ombrage d'arri√®re-plan flou </h2><br>  Apr√®s avoir construit le r√©sultat de SSAO et avant le m√©lange final de l'√©clairage, il est n√©cessaire de brouiller la texture qui stocke les donn√©es sur le coefficient d'ombrage.  Pour ce faire, nous aurons un autre framebuffer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoBlurFBO, ssaoColorBufferBlur; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoBlurFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBufferBlur); glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  La mise en mosa√Øque d'une texture de bruit dans l'espace d'√©cran fournit des caract√©ristiques d'al√©atoire bien d√©finies que vous pouvez utiliser √† votre avantage lors de la cr√©ation d'un filtre de flou: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D ssaoInput; void main() { vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0)); float result = 0.0; for (int x = -2; x &lt; 2; ++x) { for (int y = -2; y &lt; 2; ++y) { vec2 offset = vec2(float(x), float(y)) * texelSize; result += texture(ssaoInput, TexCoords + offset).r; } } FragColor = result / (4.0 * 4.0); }</span></span></code> </pre> <br>  Le shader transite simplement les texels de la texture SSAO avec un d√©calage de -2 √† +2, ce qui correspond √† la taille r√©elle de la texture de bruit.  Le d√©calage est √©gal √† la taille exacte d'un texel: la fonction textureSize <i>()</i> est utilis√©e pour le calcul, qui renvoie <i>vec2</i> avec les dimensions de la texture sp√©cifi√©e.  T.O.  Le shader fait simplement la moyenne des r√©sultats stock√©s dans la texture, ce qui donne un flou rapide et assez efficace: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/0g/i7/5p0gi7qn_v5w738uyindxexally.png"></div><br>  Au total, nous avons une texture avec des donn√©es d'ombrage d'arri√®re-plan pour chaque fragment sur l'√©cran - tout est pr√™t pour l'√©tape de r√©duction finale de l'image! <br><br><h2>  Appliquer un ombrage d'arri√®re-plan </h2><br>  L'√©tape d'application du coefficient d'ombrage dans le calcul final de l'√©clairage est √©tonnamment simple: pour chaque fragment, il suffit de multiplier simplement la valeur de la composante de fond de la source lumineuse par le coefficient d'ombrage de la texture pr√©par√©e.  Vous pouvez prendre un shader pr√™t √† l'emploi avec le mod√®le Blinn-Fong de la le√ßon sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ombrage diff√©r√©</a> et le corriger un peu: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D gAlbedo; uniform sampler2D ssao; struct Light { vec3 Position; vec3 Color; float Linear; float Quadratic; float Radius; }; uniform Light light; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    G- vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedo, TexCoords).rgb; float AmbientOcclusion = texture(ssao, TexCoords).r; //   -    //   :   -  vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion); vec3 lighting = ambient; //    (0, 0, 0)   - vec3 viewDir = normalize(-FragPos); //   vec3 lightDir = normalize(light.Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color; //   vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0); vec3 specular = light.Color * spec; //   float dist = length(light.Position - FragPos); float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br>  Il n'y a que deux changements majeurs: la transition vers les calculs dans la fen√™tre et la multiplication du composant d'√©clairage d'arri√®re-plan par la valeur d' <i>AmbientOcclusion</i> .  Un exemple de sc√®ne avec un seul point bleu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/8_/1i/bz8_1in-othscilg_udfyscghg0.png"></div><br>  Le code source complet est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  La manifestation de l'effet SSAO d√©pend fortement de param√®tres tels que <i>kernelSize</i> , <i>radius</i> et <i>polarisation</i> , souvent les affiner est une √©vidence pour l'artiste de travailler sur un lieu / sc√®ne particulier.  Il n'y a pas de ¬´meilleure¬ª combinaison universelle de param√®tres: pour certaines sc√®nes, un petit rayon du noyau de l'√©chantillon est bon, tandis que d'autres b√©n√©ficient de l'augmentation du rayon et du nombre d'√©chantillons.  L'exemple utilise 64 points d'√©chantillonnage, ce qui, franchement, est redondant, mais vous pouvez toujours modifier le code et voir ce qui se passe avec un plus petit nombre d'√©chantillons. <br><br>  En plus des uniformes r√©pertori√©s responsables de la d√©finition de l'effet, il est possible de contr√¥ler explicitement la gravit√© de l'effet d'ombrage d'arri√®re-plan.  Pour ce faire, il suffit d'√©lever le coefficient √† un degr√© contr√¥l√© par un autre uniforme: <br><br><pre> <code class="cpp hljs">occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(occlusion, power);</code> </pre> <br>  Je vous conseille de passer un peu de temps sur le jeu avec les param√®tres, car cela donnera une meilleure compr√©hension de la nature des changements dans l'image finale. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©sumer, il convient de dire que bien que l'effet visuel de l'utilisation de SSAO soit plut√¥t subtil, mais dans les sc√®nes avec un √©clairage bien plac√©, il ajoute ind√©niablement une fraction notable de r√©alisme. </font><font style="vertical-align: inherit;">Avoir un tel outil dans votre arsenal est certainement pr√©cieux.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ressources suppl√©mentaires </font></font></h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutoriel SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Un excellent article de le√ßon de John Chapman, sur la base duquel le code de cette le√ßon est construit.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connaissez vos artefacts SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Un article tr√®s pr√©cieux montrant avec lucidit√© non seulement les probl√®mes les plus urgents avec la qualit√© SSAO, mais aussi les moyens de les r√©soudre. </font><font style="vertical-align: inherit;">Lecture recommand√©e.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAO avec reconstruction de profondeur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Addendum √† la le√ßon principale de SSAO par OGLDev concernant une technique couramment utilis√©e pour restaurer les coordonn√©es des fragments en fonction de la profondeur. </font><font style="vertical-align: inherit;">L'importance de cette approche est due aux √©conomies de m√©moire importantes dues au manque de n√©cessit√© de stocker des positions dans le G-buffer. </font><font style="vertical-align: inherit;">L'approche est si universelle qu'elle s'applique aux SSAO dans la mesure o√π.</font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nous avons un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√©l√©gramme conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la coordination des transferts. </font><font style="vertical-align: inherit;">Si vous avez un d√©sir s√©rieux d'aider √† la traduction, alors vous √™tes les bienvenus!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421385/">https://habr.com/ru/post/fr421385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421375/index.html">Comment l'incertitude tue le commerce</a></li>
<li><a href="../fr421377/index.html">7 id√©es fausses d'un chef de projet novice √† Gamedev</a></li>
<li><a href="../fr421379/index.html">Culture toxique Intel</a></li>
<li><a href="../fr421381/index.html">Cours gratuit d'administrateur Cisco ASA</a></li>
<li><a href="../fr421383/index.html">Epic Growth Conference Autumn 2018 - conf√©rence de marketing de produit √† Moscou</a></li>
<li><a href="../fr421387/index.html">Entretien avec Lennart Pottering sur Linux Piter sur les changements dans Linux, sur systemd et pourquoi assister √† des conf√©rences</a></li>
<li><a href="../fr421389/index.html">S√©paration des pouvoirs administratifs √† Zimbra</a></li>
<li><a href="../fr421391/index.html">HackThings - un grand hackathon sur l'Internet des objets du 7 au 9 septembre √† Skoltech</a></li>
<li><a href="../fr421393/index.html">Panier Mailchimp abandonn√©: un guide pour les paresseux</a></li>
<li><a href="../fr421395/index.html">Rapport du Club de Rome 2018, chapitre 3.7: ¬´Climat: bonne nouvelle mais gros probl√®mes¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>