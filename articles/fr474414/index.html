<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöß üîë üßò Nous √©crivons notre propre moteur voxel üë®üèæ‚Äçüîß ‚è±Ô∏è üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque: le code source complet de ce projet est disponible ici: [ source ]. 

 Lorsque le projet sur lequel je travaille commence √† s'essouffler, j'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons notre propre moteur voxel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="image"></div><br>  <em><strong>Remarque: le</strong> code source complet de ce projet est disponible ici: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ].</em> <br><br>  Lorsque le projet sur lequel je travaille commence √† s'essouffler, j'ajoute de nouvelles visualisations qui me motivent √† aller de l'avant. <br><br>  Apr√®s la sortie du concept original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Task-Bot</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©], j'ai senti que j'√©tais limit√© par l'espace bidimensionnel dans lequel je travaillais.  Il semblait qu'il restreignait les possibilit√©s de comportement √©mergent des robots. <br><br>  Les pr√©c√©dentes tentatives infructueuses pour apprendre l'OpenGL moderne m'ont mis une barri√®re mentale, mais fin juillet, je l'ai finalement franchie.  Aujourd'hui, fin octobre, j'ai d√©j√† une compr√©hension assez confiante des concepts, j'ai donc sorti mon propre moteur de voxel simple, qui sera l'environnement pour la vie et la prosp√©rit√© de mes Task-Bots. <br><br>  J'ai d√©cid√© de cr√©er mon propre moteur, car j'avais besoin d'un contr√¥le total sur les graphismes;  en plus, je voulais me tester.  D'une certaine mani√®re, j'inventais un v√©lo, mais j'ai vraiment aim√© ce processus! <br><br>  Le but ultime de l'ensemble du projet √©tait une simulation compl√®te de l'√©cosyst√®me, o√π des robots jouant le r√¥le d'agents manipulent l'environnement et interagissent avec lui. <br><br>  √âtant donn√© que le moteur a d√©j√† avanc√© un peu et que je passerai √† nouveau √† la programmation des bots, j'ai d√©cid√© d'√©crire un article sur le moteur, ses fonctions et sa mise en ≈ìuvre afin de me concentrer sur les t√¢ches de niveau sup√©rieur √† l'avenir. <br><a name="habracut"></a><br><h2>  Concept moteur </h2><br>  Le moteur est enti√®rement √©crit √† partir de z√©ro en C ++ (√† quelques exceptions pr√®s, comme la recherche d'un chemin d'acc√®s).  J'utilise SDL2 pour rendre le contexte et traiter les entr√©es, OpenGL pour rendre une sc√®ne 3D et DearImgui pour contr√¥ler la simulation. <br><br>  J'ai d√©cid√© d'utiliser des voxels principalement parce que je voulais travailler avec une grille qui pr√©sente de nombreux avantages: <br><br><ul><li>  La cr√©ation de maillages pour le rendu est bien comprise pour moi. </li><li>  Les capacit√©s de stockage de donn√©es du monde sont plus diverses et compr√©hensibles. </li><li>  J'ai d√©j√† cr√©√© des syst√®mes pour g√©n√©rer des simulations de terrain et de climat √† partir de maillages. </li><li>  Les t√¢ches des bots dans la grille sont plus faciles √† param√©trer. </li></ul><br>  Le moteur se compose d'un syst√®me de donn√©es mondial, d'un syst√®me de rendu et de plusieurs classes auxiliaires (par exemple, pour le traitement du son et des entr√©es). <br><br>  Dans l'article, je vais parler de la liste actuelle des fonctionnalit√©s, ainsi que regarder de plus pr√®s les sous-syst√®mes les plus complexes. <br><br><h3>  Classe mondiale </h3><br>  La classe mondiale sert de classe de base pour stocker toutes les informations du monde.  Il g√®re la g√©n√©ration, le chargement et le stockage des donn√©es de bloc. <br><br>  Les donn√©es de bloc sont stock√©es dans des morceaux de taille constante (16 ^ 3), et le monde stocke le vecteur de fragment charg√© dans la m√©moire virtuelle.  Dans les grands mondes, il est pratiquement n√©cessaire de ne se souvenir que d'une certaine partie du monde, c'est pourquoi j'ai choisi cette approche. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Les fragments stockent les donn√©es de bloc, ainsi que certaines autres m√©tadonn√©es, dans un tableau plat.  Au d√©part, j'ai impl√©ment√© ma propre arborescence octree clairsem√©e pour stocker des fragments, mais il s'est av√©r√© que le temps d'acc√®s al√©atoire √©tait trop √©lev√© pour cr√©er des maillages.  Et bien qu'un tableau plat ne soit pas optimal du point de vue de la m√©moire, il offre la possibilit√© de cr√©er tr√®s rapidement des maillages et des manipulations avec des blocs, ainsi qu'un acc√®s au chemin de recherche. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Si jamais j'impl√©mente des fragments d'enregistrement et de chargement multithread, la conversion d'un tableau plat en une arborescence octree clairsem√©e et vice versa peut √™tre une option tout √† fait possible pour √©conomiser de la m√©moire.  Il y a encore de la place pour l'optimisation! <br><br>  Mon impl√©mentation de l'arbre octree clairsem√© est stock√©e dans le code, vous pouvez donc l'utiliser en toute s√©curit√©. <br><br><h4>  Stockage des fragments et gestion de la m√©moire </h4><br>  Les fragments ne sont visibles que lorsqu'ils se trouvent dans la distance de rendu de la position actuelle de la cam√©ra.  Cela signifie que lorsque la cam√©ra se d√©place, vous devez charger et composer dynamiquement des fragments dans les maillages. <br><br>  Les fragments sont s√©rialis√©s √† l'aide de la biblioth√®que boost, et les donn√©es mondiales sont stock√©es sous la forme d'un simple fichier texte, dans lequel chaque fragment est une ligne du fichier.  Ils sont g√©n√©r√©s dans un ordre sp√©cifique afin de pouvoir √™tre "ordonn√©s" dans un fichier monde.  Ceci est important pour d'autres optimisations. <br><br>  Dans le cas d'un grand monde, le principal goulot d'√©tranglement est la lecture du fichier mondial et le chargement / √©criture de fragments.  Id√©alement, il suffit de t√©l√©charger et de transf√©rer le fichier mondial. <br><br>  Pour ce faire, la m√©thode <code>World::bufferChunks()</code> supprime les fragments qui sont dans la m√©moire virtuelle mais qui sont invisibles et charge intelligemment les nouveaux fragments du fichier world. <br><br>  Par intelligence, il veut simplement d√©cider quels nouveaux fragments charger, les trier par leur position dans le fichier de sauvegarde, puis faire un passage.  Tout est tr√®s simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vid√©o HTML5. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Un exemple de chargement de fragments avec une petite distance de rendu.</i>  <i>Les artefacts de distorsion d'√©cran sont caus√©s par un logiciel d'enregistrement vid√©o.</i>  <i>Des pics notables dans les t√©l√©chargements se produisent parfois, principalement dus au maillage</i> <br><br>  De plus, j'ai d√©fini un indicateur indiquant que le moteur de rendu doit recr√©er le maillage du fragment charg√©. <br><br><h4>  Classe Blueprint et editBuffer </h4><br>  editBuffer est un conteneur bufferObjects triable qui contient des informations sur l'√©dition dans l'espace universel et l'espace fragment√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Si, lorsque vous apportez des modifications au monde, les √©crivez dans un fichier imm√©diatement apr√®s avoir effectu√© la modification, alors nous devrons transf√©rer le fichier texte entier et √©crire CHAQUE modification.  C'est terrible en termes de performances. <br><br>  Donc, j'√©cris d'abord toutes les modifications qui doivent √™tre apport√©es √† editBuffer en utilisant la m√©thode addEditBuffer (qui calcule √©galement la position des modifications dans l'espace du fragment).  Avant de les √©crire dans un fichier, je trie les changements dans l'ordre des fragments auxquels ils appartiennent en fonction de leur emplacement dans le fichier. <br><br>  L'√©criture des modifications dans un fichier consiste en un transfert de fichier, le chargement de chaque ligne (c'est-√†-dire un fragment), pour lequel il y a des modifications dans editBuffer, en apportant toutes les modifications et en l'√©crivant dans un fichier temporaire jusqu'√† ce que editBuffer devienne vide.  Cela se fait dans la fonction <code>evaluateBlueprint()</code> , qui est assez rapide. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  La classe blueprint contient editBuffer, ainsi que plusieurs m√©thodes qui vous permettent de cr√©er des editBuffers pour des objets sp√©cifiques (arbres, cactus, huttes, etc.).  Ensuite, le plan peut √™tre converti √† la position o√π vous souhaitez placer l'objet, puis il suffit de l'√©crire dans la m√©moire du monde. <br><br>  L'une des plus grandes difficult√©s lorsque vous travaillez avec des fragments est que les changements dans plusieurs blocs entre les limites des fragments peuvent se r√©v√©ler √™tre un processus monotone avec beaucoup de modulo arithm√©tique et divisant les changements en plusieurs parties.  C'est le principal probl√®me que la classe de plans directeurs g√®re avec brio. <br><br>  Je l'utilise activement au stade de la g√©n√©ration mondiale pour √©largir le ¬´goulot d'√©tranglement¬ª de l'√©criture des modifications dans un fichier. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  La classe mondiale stocke son propre plan des modifications apport√©es au monde, de sorte que lorsque bufferChunks () est appel√©, toutes les modifications sont √©crites sur le disque dur en une seule passe, puis supprim√©es de la m√©moire virtuelle. <br><br><h3>  Rendu </h3><br>  Le rendu dans sa structure n'est pas tr√®s compliqu√©, mais il n√©cessite une connaissance d'OpenGL pour comprendre.  Toutes ses parties ne sont pas int√©ressantes, ce sont principalement des wrappers de fonctionnalit√©s OpenGL.  J'ai exp√©riment√© la visualisation pendant un certain temps pour obtenir ce que j'aime. <br><br>  La simulation n'√©tant pas de la premi√®re personne, j'ai choisi la projection orthographique.  Il pouvait √™tre impl√©ment√© au format pseudo-3D (c'est-√†-dire pour pr√©-projeter des tuiles et les superposer dans un logiciel de rendu), mais cela me semblait idiot.  Je suis content d'avoir opt√© pour OpenGL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  La classe de base pour le rendu est appel√©e View, elle contient la plupart des variables importantes qui contr√¥lent la visualisation de la simulation: <br><br><ul><li>  Taille de l'√©cran et texture de l'ombre </li><li>  Objets shader, cam√©ra, matrice, etc. facteurs de zoom </li><li>  Valeurs bool√©ennes pour presque toutes les fonctions de rendu <ul><li>  Menu, brouillard, profondeur de champ, texture du grain, etc. </li></ul></li><li>  Couleurs pour l'√©clairage, le brouillard, le ciel, la s√©lection des fen√™tres, etc. </li></ul><br>  De plus, il existe plusieurs classes d'assistance qui effectuent le rendu et le wrapper d'OpenGL lui-m√™me! <br><br><ul><li>  Shader de classe <ul><li>  Charge, compile, compile et utilise des shaders GLSL </li></ul></li><li>  Classe de mod√®le <ul><li>  Contient des fragments de donn√©es VAO (Vertex Arrays Object) pour le rendu, la fonction de cr√©ation de maillages et la m√©thode de rendu. </li></ul></li><li>  Panneau d'affichage de classe <ul><li>  Contient le FBO (FrameBuffer Object) pour le rendu - utile pour cr√©er des effets de post-traitement et d'ombrage. </li></ul></li><li>  Classe Sprite <ul><li>  Dessine un quadrilat√®re orient√© par rapport √† la cam√©ra, charg√© √† partir d'un fichier de texture (pour les robots et les objets).  Peut √©galement g√©rer des animations! </li></ul></li><li>  Classe d'interface <ul><li>  Pour travailler avec ImGUI </li></ul></li><li>  Classe audio <ul><li>  Prise en charge sonore tr√®s rudimentaire (si vous compilez le moteur, appuyez sur "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Haute profondeur de champ (DOF).</i>  <i>√Ä de grandes distances de rendu, cela peut √™tre lent, mais j'ai fait tout cela sur mon ordinateur portable.</i>  <i>Peut-√™tre que sur un bon ordinateur, les freins seront invisibles.</i>  <i>Je comprends que cela me fatigue les yeux et je l'ai fait juste pour le plaisir.</i> <br><br>  L'image ci-dessus montre certains param√®tres qui peuvent √™tre modifi√©s pendant la manipulation.  J'ai √©galement mis en place le passage en mode plein √©cran.  L'image montre un exemple d'un sprite de bot rendu comme un quadrilat√®re textur√© dirig√© vers la cam√©ra.  Les maisons et les cactus de l'image sont construits √† l'aide d'un plan. <br><br><h4>  Cr√©ation de maillages de fragments </h4><br>  Au d√©part, j'ai utilis√© la version na√Øve de cr√©ation de maillages: j'ai simplement cr√©√© un cube et jet√© les sommets qui ne touchaient pas l'espace vide.  Cependant, cette solution √©tait lente et lors du chargement de nouveaux fragments, la cr√©ation de maillages s'est av√©r√©e √™tre des ¬´goulots d'√©tranglement¬ª encore plus √©troits que l'acc√®s au fichier. <br><br>  Le principal probl√®me √©tait la cr√©ation efficace de VBO rendus √† partir de fragments, mais j'ai r√©ussi √† impl√©menter en C ++ ma propre version de ¬´maillage gourmand¬ª, compatible avec OpenGL (sans structures √©tranges avec boucles).  Vous pouvez utiliser mon code en toute conscience. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  En g√©n√©ral, la transition vers un maillage gourmand a r√©duit le nombre de quadrangles dessin√©s de 60% en moyenne.  Ensuite, apr√®s d'autres optimisations mineures (indexation VBO), le nombre a √©t√© r√©duit d'un autre 1/3 (de 6 sommets au bord √† 4 sommets). <br><br>  Lors du rendu d'une sc√®ne de fragments 5x1x5 dans une fen√™tre qui n'est pas maximis√©e, j'obtiens une moyenne d'environ 140 FPS (avec VSYNC d√©sactiv√©). <br><br>  Bien que je sois assez satisfait de ce r√©sultat, j'aimerais toujours proposer un syst√®me de rendu de mod√®les non cubiques √† partir de donn√©es mondiales.  Ce n'est pas si facile √† int√©grer avec un maillage gourmand, donc √ßa vaut la peine d'√™tre consid√©r√©. <br><br><h4>  Shaders et surbrillance voxel </h4><br>  L'impl√©mentation des shaders GLSL est l'une des parties les plus int√©ressantes et en m√™me temps les plus ennuyeuses de l'√©criture du moteur en raison de la complexit√© du d√©bogage sur le GPU.  Je ne suis pas un sp√©cialiste GLSL, j'ai donc d√ª apprendre beaucoup en d√©placement. <br><br>  Les effets que j'ai mis en ≈ìuvre utilisent activement le FBO et l'√©chantillonnage de texture (par exemple, le flou, l'ombrage et l'utilisation des informations de profondeur). <br><br>  Je n'aime toujours pas le mod√®le d'√©clairage actuel, car il ne g√®re pas tr√®s bien le ¬´sombre¬ª.  J'esp√®re que cela sera corrig√© √† l'avenir lorsque je travaillerai sur le cycle de changement du jour et de la nuit. <br><br>  J'ai √©galement impl√©ment√© une fonction de s√©lection de voxels simple en utilisant l'algorithme de Bresenham modifi√© (c'est un autre avantage de l'utilisation de voxels).  Il est utile pour obtenir des informations spatiales lors de la simulation.  Mon impl√©mentation ne fonctionne que pour les projections orthographiques, mais vous pouvez l'utiliser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>Citrouille "surlign√©e".</i> <br><br><h3>  Cours de jeu </h3><br>  Plusieurs classes auxiliaires ont √©t√© cr√©√©es pour le traitement des entr√©es, des messages de d√©bogage, ainsi qu'une classe Item distincte avec des fonctionnalit√©s de base (qui seront encore d√©velopp√©es). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Mon gestionnaire d'√©v√©nements est moche, mais fonctionnel.  J'accepterai volontiers des recommandations pour son am√©lioration, en particulier sur l'utilisation de SDL Poll Event. <br><br><h2>  Derni√®res notes </h2><br>  Le moteur lui-m√™me est juste un syst√®me dans lequel je mets mes t√¢ches-bots (je vais en parler en d√©tail dans le prochain post).  Mais si vous avez trouv√© mes m√©thodes int√©ressantes et que vous voulez en savoir plus, √©crivez-moi. <br><br>  Ensuite, j'ai port√© le syst√®me de robots de t√¢ches (le v√©ritable c≈ìur de ce projet) dans le monde 3D et j'ai consid√©rablement √©largi ses capacit√©s, mais plus √† ce sujet plus tard (cependant, le code a d√©j√† √©t√© mis en ligne)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474414/">https://habr.com/ru/post/fr474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474400/index.html">Mythes sur la disponibilit√© du contraste des couleurs</a></li>
<li><a href="../fr474402/index.html">Guide de l'API Vavr Collections</a></li>
<li><a href="../fr474404/index.html">Analyse des probl√®mes r√©solus du championnat de programmation de Yandex (d√©veloppement front-end) 2019</a></li>
<li><a href="../fr474406/index.html">La premi√®re apparition de BlueKeep √† l'√©tat sauvage enregistr√©e</a></li>
<li><a href="../fr474408/index.html">R√©volution ou √©volution du mod√®le objet page?</a></li>
<li><a href="../fr474418/index.html">Conf√©rence DEFCON 27. B√©n√©ficier des produits de piratage pour macOS. Partie 1</a></li>
<li><a href="../fr474420/index.html">Formation du thermostat: comment c'est arriv√©</a></li>
<li><a href="../fr474422/index.html">Des plateformes open source passionnantes pour le d√©veloppement d'applications mobiles</a></li>
<li><a href="../fr474424/index.html">Formation mixte - qu'est-ce que c'est et comment √ßa marche</a></li>
<li><a href="../fr474426/index.html">La s√©rie anim√©e "Cercle math√©matique"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>