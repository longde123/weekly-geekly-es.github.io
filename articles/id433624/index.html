<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèæ üßñ üíó Learning Rust: Bagaimana saya melakukan UDP mengobrol dengan Azul üñïüèΩ üë®‚Äçüë®‚Äçüëß üõÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya terus belajar Rust. Saya masih belum tahu banyak, jadi saya membuat banyak kesalahan. Terakhir kali saya mencoba membuat game Snake . Saya mencob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning Rust: Bagaimana saya melakukan UDP mengobrol dengan Azul</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433624/"><img src="https://habrastorage.org/webt/zl/na/ih/zlnaihhfzb9dcso-bkwp_extqd4.jpeg"><br><br>  Saya terus belajar Rust.  Saya masih belum tahu banyak, jadi saya membuat banyak kesalahan.  Terakhir kali saya mencoba membuat game <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Snake</a> .  Saya mencoba siklus, koleksi, bekerja dengan 3D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Three.rs</a> .  Belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ggez</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amethyst</a> .  Kali ini saya mencoba membuat klien dan server untuk mengobrol.  Untuk GUI digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Azul</a> .  Juga menyaksikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conrod</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yew</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Orbtk</a> .  Saya mencoba multithreading, saluran, dan jaringan.  Saya memperhitungkan kesalahan-kesalahan dari artikel sebelumnya dan mencoba membuatnya lebih terperinci.  Untuk detailnya, selamat datang di kucing. <a name="habracut"></a><br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber, bekerja di Windows 10 x64</a> <br><br>  Untuk jaringan, saya menggunakan UDP karena saya ingin membuat proyek saya berikutnya menggunakan protokol ini dan saya ingin berlatih dengannya di sini.  Untuk GUI, saya segera membuka proyek Google di Rust, melihat contoh dasar untuk mereka dan Azul mengaitkan saya karena menggunakan Model Objek Dokumen dan mesin gaya CSS, dan saya terlibat dalam pengembangan web untuk waktu yang lama.  Secara umum, saya memilih Framework secara subyektif.  Sejauh ini, dalam alfa dalam: pengguliran tidak bekerja, fokus input tidak berfungsi, tidak ada kursor.  Untuk memasukkan data dalam bidang teks, Anda harus mengarahkan kursor dan memegangnya langsung di atasnya saat Anda mengetik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lebih detail ...</a> <br><br>  Sebenarnya, sebagian besar artikel adalah komentar kode. <br><br><h2>  Azul </h2><br>  Kerangka kerja GUI menggunakan gaya fungsional, DOM, CSS.  Antarmuka Anda terdiri dari elemen root, yang memiliki banyak keturunan, yang dapat memiliki keturunan sendiri, seperti dalam HTML dan XML.  Seluruh antarmuka dibuat berdasarkan data dari satu DataModel tunggal.  Di dalamnya, semua data ditransfer ke presentasi secara umum.  Jika ada yang akrab dengan ASP.NET, maka Azul dan DataModelnya seperti Razor dan ViewModel-nya.  Seperti dalam HTML, Anda dapat mengikat fungsi ke acara elemen DOM.  Anda bisa mendesain elemen menggunakan kerangka CSS.  Ini bukan CSS yang sama dengan HTML, tetapi sangat mirip dengannya.  Ada juga penjilidan dua arah seperti pada Angular atau MVVM di WPF, UWP.  Informasi lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs</a> . <br><br><h2>  Tinjauan singkat tentang sisa kerangka kerja </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Orbtk</a> - Hampir sama dengan Azul dan juga dalam alpha yang dalam </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conrod</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> Anda dapat membuat aplikasi desktop lintas platform. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yew</a> adalah WebAssembly dan mirip dengan Bereaksi.  Untuk pengembangan web. </li></ul><br><h2>  Pelanggan </h2><br><h3>  Struktur di mana fungsi bantu untuk membaca dan menulis ke soket dikelompokkan </h3><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ChatService { <span class="hljs-comment"><span class="hljs-comment">//1 fn read_data(socket: &amp;Option&lt;UdpSocket&gt;) -&gt; Option&lt;String&gt; { //2 let mut buf = [0u8; 4096]; match socket { Some(s) =&gt; { //3 match s.recv(&amp;mut buf) { //4 Ok(count) =&gt; Some(String::from_utf8(buf[..count].into()) .expect("can't parse to String")), Err(e) =&gt; { //5 println!("Error {}", e); None } } } _ =&gt; None, } } //6 fn send_to_socket(message: String, socket: &amp;Option&lt;UdpSocket&gt;) { match socket { //7 Some(s) =&gt; { s.send(message.as_bytes()).expect("can't send"); } _ =&gt; return, } } }</span></span></code> </pre> <br><ol><li>  Baca data dari soket </li><li>  Buffer agar data dapat dibaca dari soket. </li><li>  Memblokir panggilan.  Di sini, utas eksekusi berhenti sampai data dibaca atau terjadi timeout. </li><li>  Kami mendapatkan string dari array byte dalam pengkodean UTF8. </li><li>  Kami tiba di sini jika koneksi terputus oleh batas waktu atau kesalahan lain terjadi. </li><li>  Mengirim string ke soket. </li><li>  Konversi string ke byte dalam pengkodean UTF8 dan kirim data ke soket.  Menulis data ke soket tidak menghalangi, mis.  utas eksekusi akan melanjutkan pekerjaannya.  Jika data tidak dapat dikirim, maka kami mengganggu program dengan pesan "tidak dapat mengirim". </li></ol><br><h3>  Struktur yang mengelompokkan fungsi untuk menangani acara dari pengguna dan memodifikasi DataModel kami </h3><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span> {} <span class="hljs-comment"><span class="hljs-comment">//1 const TIMEOUT_IN_MILLIS: u64 = 2000; impl Controller { //2 fn send_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //3 let data = app_state.data.lock().unwrap(); //4 let message = data.messaging_model.text_input_state.text.clone(); data.messaging_model.text_input_state.text = "".into(); //5 ChatService::send_to_socket(message, &amp;data.messaging_model.socket); //6 azul::prelude::UpdateScreen::Redraw } //7 fn login_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //8 use std::time::Duration; //9 if let Some(ref _s) = app_state.data.clone().lock().unwrap().messaging_model.socket { return azul::prelude::UpdateScreen::DontRedraw; } //10 app_state.add_task(Controller::read_from_socket_async, &amp;[]); //11 app_state.add_daemon(azul::prelude::Daemon::unique(azul::prelude::DaemonCallback(Controller::redraw_daemon))); //12 let mut data = app_state.data.lock().unwrap(); //13 let local_address = format!("127.0.0.1:{}", data.login_model.port_input.text.clone().trim()); //14 let socket = UdpSocket::bind(&amp;local_address) .expect(format!("can't bind socket to {}", local_address).as_str()); //15 let remote_address = data.login_model.address_input.text.clone().trim().to_string(); //16 socket.connect(&amp;remote_address) .expect(format!("can't connect to {}", &amp;remote_address).as_str()); //17 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); // 18 data.logged_in = true; // 19 data.messaging_model.socket = Option::Some(socket); //20 azul::prelude::UpdateScreen::Redraw } //21 fn read_from_socket_async(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;, _: Arc&lt;()&gt;) { //22 let socket = Controller::get_socket(app_data.clone()); loop { //23 if let Some(message) = ChatService::read_data(&amp;socket) { //24 app_data.modify(|state| { //25 state.messaging_model.has_new_message = true; //26 state.messaging_model.messages.push(message); }); } } } //27 fn redraw_daemon(state: &amp;mut ChatDataModel, _repres: &amp;mut azul::prelude::Apprepres) -&gt; (azul::prelude::UpdateScreen, azul::prelude::TerminateDaemon) { //28 if state.messaging_model.has_new_message { state.messaging_model.has_new_message = false; (azul::prelude::UpdateScreen::Redraw, azul::prelude::TerminateDaemon::Continue) } else { (azul::prelude::UpdateScreen::DontRedraw, azul::prelude::TerminateDaemon::Continue) } } //29 fn get_socket(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;) -&gt; Option&lt;UdpSocket&gt; { //30 let ref_model = &amp;(app_data.lock().unwrap().messaging_model.socket); //31 match ref_model { Some(s) =&gt; Some(s.try_clone().unwrap()), _ =&gt; None } } }</span></span></code> </pre><br><ol><li>  Batas waktu dalam milidetik setelah itu operasi pemblokiran pembacaan dari soket akan terputus. </li><li>  Fungsi terpenuhi ketika pengguna ingin mengirim pesan baru ke server. </li><li>  Kami memiliki mutex dengan model data kami.  Ini memblok antarmuka redraw thread sampai mutex dibebaskan. </li><li>  Kami membuat salinan teks yang dimasukkan oleh pengguna untuk mentransfernya lebih lanjut dan menghapus bidang input teks. </li><li>  Kami mengirim pesan. </li><li>  Kami memberi tahu Kerangka bahwa setelah memproses acara ini, kami perlu menggambar ulang antarmuka. </li><li>  Fungsi ini berfungsi ketika pengguna ingin terhubung ke server. </li><li>  Kami menghubungkan struktur untuk mewakili lamanya waktu dari perpustakaan standar. </li><li>  Jika kami sudah terhubung ke server, kami mengganggu pelaksanaan fungsi dan memberi tahu Kerangka bahwa tidak perlu menggambar ulang antarmuka. </li><li>  Tambahkan tugas yang akan dijalankan secara asinkron di utas dari kumpulan utas dari Azul Framework.  Mengakses mutex dengan blok data model memperbarui UI sampai mutex dibebaskan. </li><li>  Tambahkan tugas berulang yang berjalan di utas utama.  Setiap perhitungan panjang dalam daemon ini diblokir oleh pembaruan antarmuka. </li><li>  Kami masuk ke kepemilikan mutex. </li><li>  Kami membaca port yang dimasukkan oleh pengguna dan membuat alamat lokal berdasarkan itu, kami akan mendengarkan. </li><li>  Buat soket UDP yang bertuliskan paket yang tiba di alamat lokal. </li><li>  Kami membaca alamat server yang dimasukkan oleh pengguna. </li><li>  Kami memberi tahu soket UDP kami untuk membaca paket hanya dari server ini. </li><li>  Atur batas waktu untuk operasi baca dari soket.  Menulis ke soket terjadi tanpa menunggu, yaitu, kami hanya menulis data dan tidak mengharapkan apa-apa, dan operasi membaca dari soket memblokir aliran dan menunggu sampai data yang dapat dibaca tiba.  Jika Anda tidak menetapkan batas waktu, maka operasi baca dari soket akan menunggu tanpa batas waktu. </li><li>  Tetapkan tanda yang menunjukkan bahwa pengguna telah terhubung ke server. </li><li>  Kami meneruskan soket yang dibuat ke model data. </li><li>  Kami memberi tahu Kerangka bahwa setelah memproses acara ini, kami perlu menggambar ulang antarmuka. </li><li>  Operasi asinkron yang berjalan di kumpulan utas dari Azul Framework. </li><li>  Dapatkan salinan soket dari model data kami. </li><li>  Mencoba membaca data dari soket.  Jika Anda tidak membuat salinan soket dan langsung menunggu di sini sampai pesan datang dari soket yang ada di mutex dalam model data kami, maka seluruh antarmuka akan berhenti diperbarui hingga kami merilis mutex. </li><li>  Jika kami mendapatkan beberapa jenis pesan, kemudian mengubah model data kami, modifikasi melakukan hal yang sama dengan kunci (). Lepaskan () dengan meneruskan hasilnya ke lambda dan melepaskan mutex setelah kode lambda berakhir. </li><li>  Tetapkan bendera untuk menunjukkan bahwa kami memiliki pesan baru. </li><li>  Tambahkan pesan ke larik semua pesan obrolan. </li><li>  Operasi sinkron berulang yang berjalan di utas utama. </li><li>  Jika kami memiliki pesan baru, kami memberi tahu Kerangka Kerja bahwa kami perlu menggambar ulang antarmuka dari awal dan terus bekerja dengan daemon ini; jika tidak, kami tidak akan menggambar antarmuka dari awal, tetapi masih memanggil Fungsi ini di siklus berikutnya. </li><li>  Membuat salinan soket kami agar tidak menjaga mutex terkunci dengan model data kami. </li><li>  Kami mendapatkan mutex dan mendapatkan tautan ke soket. </li><li>  Buat salinan soket.  Mutex akan dibebaskan secara otomatis saat keluar dari suatu Fungsi. </li></ol><br><h3>  Pemrosesan data dan dasmon asinkron di Azul </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Problem - blocks UI :( fn start_connection(app_state: &amp;mut AppState&lt;MyDataModel&gt;, _event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { //   app_state.add_task(start_async_task, &amp;[]); //  app_state.add_daemon(Daemon::unique(DaemonCallback(start_daemon))); UpdateScreen::Redraw } fn start_daemon(state: &amp;mut MyDataModel, _repres: &amp;mut Apprepres) -&gt; (UpdateScreen, TerminateDaemon) { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; (UpdateScreen::Redraw, TerminateDaemon::Continue) } fn start_async_task(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { // simulate slow load app_data.modify(|state| { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; }); }</span></span></code> </pre><br>  Daemon selalu dieksekusi di utas utama, jadi penguncian tidak bisa dihindari di sana.  Dengan tugas yang tidak sinkron, jika Anda melakukannya, misalnya, seperti ini, tidak akan ada kunci selama 10 detik. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_async_task</span></span></span></span>(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  UI.  . thread::sleep(Duration::from_secs(10)); app_data.modify(|state| { state.counter += 10000; }); }</span></span></code> </pre><br>  Fungsi panggilan memodifikasi kunci () dan mutex dengan model data karena itu memblokir memperbarui antarmuka selama pelaksanaannya. <br><br><h3>  Gaya kami </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CUSTOM_CSS: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">" .row { height: 50px; } .orange { background: linear-gradient(to bottom, #f69135, #f37335); font-color: white; border-bottom: 1px solid #8d8d8d; }"</span></span>;</code> </pre><br><h3>  Sebenarnya, Fungsi untuk membuat DOM kami ditampilkan kepada penggunanya </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> azul::prelude::Layout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ChatDataModel { <span class="hljs-comment"><span class="hljs-comment">//1 fn layout(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //2 if self.logged_in { self.chat_form(info) } else { self.login_form(info) } } } impl ChatDataModel { //3 fn login_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //4 let button = azul::widgets::button::Button::with_label("Login") //5 .dom() //6 .with_class("row") //7 .with_class("orange") //8 .with_callback( azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::login_pressed)); //9 let port_label = azul::widgets::label::Label::new("Enter port to listen:") .dom() .with_class("row"); //10 let port = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.port_input, &amp;self) .dom(&amp;self.login_model.port_input) .with_class("row"); // 9 let address_label = azul::widgets::label::Label::new("Enter server address:") .dom() .with_class("row"); //10 let address = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.address_input, &amp;self) .dom(&amp;self.login_model.address_input) .with_class("row"); //12 azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(port_label) .with_child(port) .with_child(address_label) .with_child(address) .with_child(button) } //13 fn chat_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //14 let button = azul::widgets::button::Button::with_label("Send") .dom() .with_class("row") .with_class("orange") .with_callback(azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::send_pressed)); //15 let text = azul::widgets::text_input::TextInput::new() .bind(info.window, &amp;self.messaging_model.text_input_state, &amp;self) .dom(&amp;self.messaging_model.text_input_state) .with_class("row"); //12 let mut dom = azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(text) .with_child(button); //16 for i in &amp;self.messaging_model.messages { dom.add_child(azul::widgets::label::Label::new(i.clone()).dom().with_class("row")); } dom } }</span></span></code> </pre><br><ol><li>  Fungsi yang menciptakan DOM terakhir, dan dipanggil setiap kali Anda perlu menggambar ulang antarmuka. </li><li>  Jika kami sudah terhubung ke server, maka kami menunjukkan formulir untuk mengirim dan membaca pesan, kalau tidak, kami menampilkan formulir untuk menghubungkan ke server. </li><li>  Membuat formulir untuk memasukkan data yang diperlukan untuk terhubung ke server. </li><li>  Buat tombol dengan tulisan tulisan Login. </li><li>  Konversikan ke objek DOM. </li><li>  Tambahkan kelas baris ke sana. </li><li>  Tambahkan oranye kelas css ke dalamnya. </li><li>  Tambahkan pengendali acara untuk mengklik tombol. </li><li>  Buat label teks dengan teks untuk ditampilkan kepada pengguna dan baris kelas css. </li><li>  Kami membuat kotak teks untuk memasukkan teks dengan teks dari properti model kami dan baris kelas css. </li><li>  Ikatkan bidang teks ke properti DataModel kami.  Ini mengikat dua arah.  Sekarang mengedit TextInput secara otomatis mengubah teks di properti model kami dan sebaliknya juga benar.  Jika kita mengubah teks dalam model kita, teks dalam TextInput akan berubah. </li><li>  Kami membuat elemen DOM root di mana kami menempatkan elemen UI kami. </li><li>  Membuat formulir untuk mengirim dan membaca pesan. </li><li>  Buat tombol dengan teks "Kirim" dan css dengan kelas "baris", "oranye" dan pengendali acara saat diklik. </li><li>  Buat bidang input teks dua arah dengan properti model self.messaging_model.text_input_state dan css dengan kelas "baris". </li><li>  Tambahkan label teks yang menampilkan pesan yang ditulis dalam obrolan. </li></ol><br><h3>  Model kami yang menyimpan keadaan antarmuka kami </h3><br>  Dokumentasi Azul mengatakan bahwa ia harus menyimpan semua data aplikasi, termasuk koneksi ke database, jadi saya memasukkan soket UDP ke dalamnya. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//1 #[derive(Debug)] //2 struct ChatDataModel { //3 logged_in: bool, //4 messaging_model: MessagingDataModel, //5 login_model: LoginDataModel, } #[derive(Debug, Default)] struct LoginDataModel { //6 port_input: azul::widgets::text_input::TextInputState, //7 address_input: azul::widgets::text_input::TextInputState, } #[derive(Debug)] struct MessagingDataModel { //8 text_input_state: azul::widgets::text_input::TextInputState, //9 messages: Vec&lt;String&gt;, //10 socket: Option&lt;UdpSocket&gt;, //11 has_new_message: bool, }</span></span></code> </pre><br><ol><li>  Ini akan memungkinkan kami untuk menampilkan struktur kami sebagai string di templat formulir {:?} </li><li>  Model data kami.  Sehingga bisa digunakan di Azul.  Dia harus menerapkan sifat Tata Letak. </li><li>  Bendera untuk memeriksa apakah pengguna terhubung ke server atau tidak. </li><li>  Model untuk menampilkan formulir untuk mengirim pesan ke server dan menyimpan pesan yang diterima dari server. </li><li>  Model untuk menampilkan formulir untuk menghubungkan ke server. </li><li>  Port yang dimasukkan pengguna.  Kami akan mendengarkannya dengan soket kami. </li><li>  Alamat server yang dimasukkan pengguna.  Kami akan terhubung dengannya. </li><li>  Pesan pengguna.  Kami akan mengirimkannya ke server. </li><li>  Array pesan yang datang dari server. </li><li>  Soket tempat kami berkomunikasi dengan server. </li><li>  Bendera untuk memeriksa apakah pesan baru telah tiba dari server. </li></ol><br><h3>  Dan akhirnya, titik masuk utama ke aplikasi.  Mulai siklus dari gambar GUI dan pemrosesan input pengguna </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let app = azul::prelude::App::new(ChatDataModel { logged_in: false, messaging_model: MessagingDataModel { text_input_state: azul::widgets::text_input::TextInputState::new(""), messages: Vec::new(), socket: None, has_new_message: false, }, login_model: LoginDataModel::default(), }, azul::prelude::AppConfig::default()); // 2 let mut style = azul::prelude::css::native(); //3 style.merge(azul::prelude::css::from_str(CUSTOM_CSS).unwrap()); //4 let window = azul::prelude::Window::new(azul::prelude::WindowCreateOptions::default(), style).unwrap(); //5 app.run(window).unwrap(); }</span></span></code> </pre><br><ol><li>  Kami membuat aplikasi dengan data awal. </li><li>  Gaya yang digunakan oleh aplikasi secara default. </li><li>  Tambahkan gaya kita sendiri ke mereka. </li><li>  Kami membuat jendela di mana aplikasi kami akan ditampilkan. </li><li>  Luncurkan aplikasi di jendela ini. </li></ol><br><h2>  Server </h2><br><h3>  Titik masuk utama ke aplikasi </h3><br>  Di sini kita biasanya memiliki aplikasi konsol. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let socket = create_socket(); //2 let (sx, rx) = mpsc::channel(); //3 start_sender_thread(rx, socket.try_clone().unwrap()); loop { //4 sx.send(read_data(&amp;socket)).unwrap(); } }</span></span></code> </pre><br><ol><li>  Buat soket. </li><li>  Kami membuat saluran satu arah dengan satu pengirim pesan sx dan banyak penerima rx. </li><li>  Kami mulai mengirim pesan ke semua penerima dalam aliran terpisah. </li><li>  Kami membaca data dari soket dan mengirimkannya ke aliran, yang mengirim pesan ke klien yang terhubung ke server. </li></ol><br><h3>  Berfungsi untuk membuat aliran untuk mengirim pesan ke klien </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_sender_thread</span></span></span></span>(rx: mpsc::Receiver&lt;(<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr)&gt;, socket: UdpSocket) { <span class="hljs-comment"><span class="hljs-comment">//1 thread::spawn(move || { //2 let mut addresses = Vec::&lt;SocketAddr&gt;::new(); //3 loop { //4 let (bytes, pre) = rx.recv().unwrap(); // 5 if !addresses.contains(&amp;pre) { println!(" {} connected to server", pre); addresses.push(pre.clone()); } //6 let result = String::from_utf8(bytes) .expect("can't parse to String") .trim() .to_string(); println!("received {} from {}", result, pre); //7 let message = format!("FROM: {} MESSAGE: {}", pre, result); let data_to_send = message.as_bytes(); //8 addresses .iter() .for_each(|s| { //9 socket.send_to(data_to_send, s) //10 .expect(format!("can't send to {}", pre).as_str()); }); } }); }</span></span></code> </pre><br><ol><li>  Mulai utas baru.  move berarti bahwa masing-masing variabel mengambil alih lambda dan aliran.  Lebih khusus lagi, utas baru kami akan "menyerap" variabel rx dan socket. </li><li>  Kumpulan alamat yang terhubung dengan kami oleh pelanggan.  Kami akan mengirim mereka semua pesan kami.  Secara umum, dalam proyek nyata akan diperlukan untuk melakukan pemrosesan pemutusan klien dari kami dan menghapus alamatnya dari array ini. </li><li>  Kami memulai loop tak terbatas. </li><li>  Kami membaca data dari saluran.  Di sini aliran akan diblokir sampai data baru tiba. </li><li>  Jika tidak ada alamat seperti itu di array kami, maka tambahkan di sana. </li><li>  Dekode string UTF8 dari array byte. </li><li>  Kami membuat array byte yang akan kami kirim ke semua pelanggan kami. </li><li>  Kami melalui pengumpulan alamat dan mengirim data ke semua orang. </li><li>  Operasi tulis ke soket UDP adalah non-pemblokiran, jadi di sini Fungsi tidak akan menunggu sampai pesan tiba di penerima dan dijalankan hampir secara instan. </li><li>  berharap jika terjadi kesalahan akan membuat keluar darurat dari program dengan pesan yang diberikan. </li></ol><br><h3>  Fungsi membuat soket berdasarkan input pengguna </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMEOUT_IN_MILLIS: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_socket</span></span></span></span>() -&gt; UdpSocket { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter port to listen"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 let local_port: String = read!("{}\n"); let local_address = format!("127.0.0.1:{}", local_port.trim()); println!("server address {}", &amp;local_address); //2 let socket = UdpSocket::bind(&amp;local_address.trim()) .expect(format!("can't bind socket to {}", &amp;local_address).as_str()); //3 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); //4 socket }</span></span></code> </pre><br><ol><li>  Kami membaca port yang akan didengarkan server kami dan membuat alamat server lokal berdasarkan itu. </li><li>  Buat soket UDP mendengarkan pada alamat ini. </li><li>  Atur batas waktu untuk operasi baca.  Operasi baca memblokir dan akan memblokir aliran sampai data baru tiba atau waktu habis terjadi. </li><li>  Kami mengembalikan soket yang dibuat dari Function. </li><li>  Fungsi membaca data dari soket dan mengembalikannya bersama dengan alamat pengirim. </li></ol><br><h3>  Berfungsi untuk membaca data dari soket </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span></span>(socket: &amp;UdpSocket) -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr) { <span class="hljs-comment"><span class="hljs-comment">//1 let mut buf = [0u8; 4096]; //2 loop { match socket.recv_from(&amp;mut buf) { //3 Ok((count, address)) =&gt; { //4 return (buf[..count].into(), address); } //5 Err(e) =&gt; { println!("Error {}", e); continue; } }; } }</span></span></code> </pre><br><ol><li>  Buffer adalah tempat di mana kita akan membaca data. </li><li>  Mulai loop yang akan berjalan hingga data yang valid dibaca. </li><li>  Kami mendapatkan jumlah byte yang dibaca dan alamat pengirim. </li><li>  Kami memotong array dari awal hingga jumlah byte yang dibaca dan mengubahnya menjadi vektor byte. </li><li>  Jika terjadi timeout atau kesalahan lainnya, maka lanjutkan ke iterasi loop berikutnya. </li></ol><br><h2>  Tentang lapisan dalam aplikasi </h2><br><div class="spoiler">  <b class="spoiler_title">Offtopic: Program pendidikan kecil untuk dua Juni di tempat kerja.</b>  <b class="spoiler_title">Saya memutuskan untuk meletakkannya di sini, mungkin seseorang akan berguna.</b>  <b class="spoiler_title">Penajam-Juni Juni adalah contoh dalam C # dan kita berbicara tentang ASP.NET</b> <div class="spoiler_text">  Jadi, tidak ada yang bisa dilakukan, itu di malam hari, dan saya memutuskan untuk menulis program pendidikan kecil tentang arsitektur untuk Artem dan Victor.  Baiklah, ayo pergi. <br><br>  Sebenarnya, saya menambahkan di sini karena pemulihan mode dan saya hanya bisa menulis artikel seminggu sekali, dan materi sudah ada di sana dan minggu depan saya ingin mengunggah sesuatu yang lain ke Habr. <br><br>  Biasanya, aplikasi berlapis.  Setiap lapisan berisi objek yang menerapkan karakteristik perilaku lapisan di mana mereka berada.  Dan begitulah.  Ini adalah lapisan-lapisannya. <br><br><ol><li>  Lapisan presentasi. </li><li>  Logika bisnis lapisan. </li><li>  Lapisan akses data. </li><li>  Entitas (Pengguna, Hewan, dll.) </li></ol><br><br>  Setiap layer dapat berisi DTO sendiri dan kelas yang sepenuhnya arbitrer dengan metode arbitrer.  Yang utama adalah mereka melakukan fungsionalitas yang terkait dengan lapisan di mana mereka berada.  Dalam aplikasi sederhana, beberapa layer mungkin hilang.  Sebagai contoh, tampilan layer dapat diimplementasikan melalui pola MVC, MVP, MVVM.  Yang sepenuhnya opsional.  Hal utama adalah bahwa kelas-kelas yang ada di lapisan ini mengimplementasikan fungsi yang ditugaskan ke lapisan.  Ingat, pola dan arsitektur hanyalah rekomendasi, bukan arah.  Pola dan arsitektur bukan hukum, ini saran. <br><br>  Jadi, kami akan mempertimbangkan setiap lapisan pada contoh aplikasi ASP.NET standar menggunakan Kerangka Entitas standar. <br><br><h3>  Lapisan presentasi </h3><br>  Kami punya MVC di sini.  Ini adalah lapisan yang menyediakan interaksi pengguna.  Perintah datang ke sini dan pengguna mendapatkan data dari sini.  Belum tentu orang, jika kita memiliki API, maka pengguna kita adalah program yang berbeda.  Mobil berkomunikasi dengan mobil. <br><br><h3>  Lapisan logika bisnis </h3><br>  Di sini, biasanya, kelas disebut Layanan, misalnya, UserService, meskipun dapat berupa apa saja.  Hanya seperangkat kelas dengan metode.  Yang utama adalah bahwa perhitungan dan perhitungan aplikasi kita terjadi di sini.  Ini adalah lapisan paling tebal dan paling tebal.  Ada sebagian besar kode dan berbagai kelas.  Ini sebenarnya adalah aplikasi kita. <br><br><h3>  Lapisan akses data </h3><br>  Biasanya di sini EF menerapkan pola Unit Kerja dan Repositori.  Jadi ya, DbContext adalah, Anda dapat mengatakan, Unit Kerja, dan DB mengaturnya sebagai Repositori.  Ini, pada kenyataannya, adalah tempat di mana kita menyimpan data dan dari mana kita mendapatkannya.  Terlepas dari apakah sumber data adalah database, API dari aplikasi lain, cache dalam memori, atau hanya beberapa jenis pembangkit angka acak.  Sumber data apa saja. <br><br><h3>  Entitas </h3><br>  Ya, hanya segala macam Pengguna, Hewan, dan banyak lagi.  Satu poin penting - mereka mungkin hanya memiliki karakteristik perilaku tertentu.  Sebagai contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FullName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FirstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + LastName; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FullName == user.FullName; } }</code> </pre> <br><h3>  Nah, dan contoh yang sangat sederhana.  Shoba dulu </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-comment"><span class="hljs-comment">//Entities class User { public int Id { get; set; } public string Name { get; set; } } //Data Access Layer class UserRepository { private readonly Dictionary&lt;int, User&gt; _db; public UserRepository() { _db = new Dictionary&lt;int, User&gt;(); } public User Get(int id) { return _db[id]; } public void Save(User user) { _db[user.Id] = user; } } //Business Logic Layer class UserService { private readonly UserRepository _repo; private int _currentId = 0; public UserService() { _repo = new UserRepository(); } public void AddNew() { _currentId++; var user = new User { Id = _currentId, Name = _currentId.ToString() }; _repo.Save(user); } public string GetAll() { StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= _currentId; i++) { sb.AppendLine($"Id: {i} Name: {_repo.Get(i).Name}"); } return sb.ToString(); } } //presentation Layer aka Application Layer class UserController { private readonly UserService _service; public UserController() { _service = new UserService(); } public string RunExample() { _service.AddNew(); _service.AddNew(); return _service.GetAll(); } } namespace ConsoleApp1 { class Program { static void Main(string[] args) { var controller = new UserController(); Console.WriteLine(controller.RunExample()); Console.ReadLine(); } } }</span></span></code> </pre> <br></div></div><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya ampun, saya ingin mengucapkan terima kasih kepada Nastya saya untuk memperbaiki kesalahan tata bahasa dalam artikel ini. </font><font style="vertical-align: inherit;">Jadi iya, Nastya kamu tidak sia-sia dengan ijazah merah dan umumnya keren. </font><font style="vertical-align: inherit;">Aku mencintaimu &lt;3.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433624/">https://habr.com/ru/post/id433624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433610/index.html">Catatan seorang phytochemist. Kesemek</a></li>
<li><a href="../id433612/index.html">FCC: Satelit SpaceX di orbit - sumber puing yang berbahaya bagi penduduk Bumi</a></li>
<li><a href="../id433614/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Satu Retensi</a></li>
<li><a href="../id433618/index.html">Suara "tabung hangat" dengan tangan Anda sendiri. Bagaimana jika Anda menyeberangi toko, klub, dan bengkel?</a></li>
<li><a href="../id433620/index.html">Bagaimana SystemUI bekerja di Android</a></li>
<li><a href="../id433628/index.html">Budaya umpan balik: bagaimana tidak masuk ke dalam tuduhan</a></li>
<li><a href="../id433630/index.html">Satu Langkah Lebih Dekat dengan Vaksin HIV: Monyet titer antibodi penawar serum</a></li>
<li><a href="../id433632/index.html">Aplikasi seluler lain "membocorkan" data penggunanya</a></li>
<li><a href="../id433634/index.html">Pemantauan Sarang Lebah | Saya Dadan dan setengah-Ukraina | Redundansi data</a></li>
<li><a href="../id433636/index.html">Lantern-charging-kubotan: ide bagus atau boneka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>