<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ¤³ğŸ¼ ğŸ‘©ğŸ¾â€ğŸ”§ SmartCard I2C Protocol. Tukar perintah APDU melalui antarmuka I2C ğŸ‚ ğŸ’¤ ğŸ‘¨ğŸ¾â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Beberapa waktu yang lalu, saya ambil bagian dalam pengembangan perangkat yang mengharuskan penerapan kriptografi Rusia. Karena di masa d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SmartCard I2C Protocol. Tukar perintah APDU melalui antarmuka I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439574/"><h2>  Pendahuluan </h2><br>  Beberapa waktu yang lalu, saya ambil bagian dalam pengembangan perangkat yang mengharuskan penerapan kriptografi Rusia.  Karena di masa depan itu harus mengesahkan keputusan ini, persyaratan tertentu diajukan untuk implementasi kriptografi.  Dan sebagai salah satu opsi untuk menyederhanakan penerapan persyaratan ini, kami mempertimbangkan kemungkinan mengintegrasikan pembaca kartu pintar ke dalam perangkat atau memasang chip kartu pintar, di mana banyak skenario yang diperlukan untuk bekerja dengan informasi kunci telah diterapkan. <br><br>  Sayangnya, solusi seperti itu tidak cocok untuk beberapa alasan, meskipun jika dimungkinkan untuk menggunakan kriptografi perangkat keras Rusia yang sudah jadi, ini seharusnya secara signifikan mempercepat pengembangan dan sertifikasi berikutnya dari produk akhir.  Dan alasan ketidakmungkinan menggunakan token USB atau kartu pintar cukup umum: perangkat seharusnya cukup kompak (modul kecil untuk perangkat M2M atau IoT), dioperasikan terutama dalam mode bebas perawatan dan dioperasikan dalam kisaran suhu yang luas. <br><br>  Pada artikel ini saya ingin berbicara tentang kemungkinan solusi untuk kasus seperti itu menggunakan chip A7001, yang terhubung ke sistem melalui antarmuka I2C. <br><br><img src="https://habrastorage.org/webt/e5/bw/lh/e5bwlh2fhtuxpwj7cdmmt7ujtjc.png"><br><a name="habracut"></a><br><h2>  Masalah penerapan kriptografi di PAC </h2><br>  Saya tidak ingin memikirkan masalah sertifikasi kriptografi.  Siapa pun yang bekerja dengan ini sadar akan hal ini, tetapi sisanya tampaknya tidak membutuhkannya.  Tetapi tentang beberapa poin penting masih layak untuk dikatakan. <br><br>  Secara teori, seharusnya tidak ada masalah khusus dengan kriptografi.  Bagaimanapun, cukup untuk mengambil salah satu pustaka kriptografi, misalnya, OpenSSL, atau yang lainnya dari banyak pustaka yang ada. <br><br>  Masalah dimulai ketika solusi ini harus disertifikasi.  Dan implementasi perangkat lunak murni dari kriptografi dalam firmware mengubah perangkat menjadi perangkat perlindungan informasi kriptografi lengkap, yang memerlukan studi dekat di laboratorium pengujian.  Lagi pula, ketika mengembangkan solusi menggunakan kriptografi, cepat atau lambat Anda harus memikirkan hal-hal seperti skema kunci, menyimpan kunci, menghasilkan angka acak dan hal-hal halus lainnya. <br><br>  Ada metode yang elegan untuk menerapkan algoritma kriptografi Rusia bersertifikat untuk beberapa solusi, yang memungkinkan kami untuk sedikit menyederhanakan proses pembuatan perangkat akhir dan mengurangi waktu pengembangan dan sertifikasi selanjutnya.  Cukup dengan menanamkan kartu pintar atau chip kartu pintar ke dalam perangkat, menggunakannya sebagai semacam "akar kepercayaan", dan dengan demikian menyelesaikan sejumlah besar masalah menyakitkan yang memerlukan penelitian dan konfirmasi panjang di laboratorium pengujian. <br><br><img src="https://habrastorage.org/webt/e2/iq/6i/e2iq6i49c7ber2rkbgu6sv8fl3u.png"><br><br><h2>  Mikrokontroler kartu pintar dengan antarmuka I2C </h2><br>  Untuk menulis artikel ini, saya menggunakan chip A7001, yang terhubung ke perangkat akhir melalui bus I2C, yang tersedia di hampir semua perangkat.  Chip ini disediakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aladdin RD</a> , yang sudah memiliki firmware terpasang yang mendukung kriptografi Rusia. <br><br>  Mikrokontroler A7001AG (Mikrokontroler otentikasi aman) dibuat oleh NXP.  Menurut datasheet pada chip, <b>A7001AG</b> adalah mikrokontroler yang dilindungi dari akses tidak sah berdasarkan arsitektur 80C51 klasik dengan coprocessor kriptografi. <br><br>  Dalam mode hemat daya, mikrokontroler mengkonsumsi 50 Î¼A.  Ini mendukung tegangan suplai dalam kisaran dari 1,62V hingga 5,5V dan dapat dioperasikan pada suhu dari âˆ’25 Â° C hingga + 85 Â° C. <br><br>  Untuk berinteraksi dengan perangkat eksternal, antarmuka budak I2C digunakan dengan kecepatan hingga 100 kbit / dtk. <br><br>  Mikrokontroler tersedia dalam beberapa opsi perumahan.  Saya berakhir dalam format HVQFN32.  Ini adalah kasus plastik berukuran 5x5x0.85 mm dengan 32 kontak dan pitch 0,5 mm. <br><br>  Penampilan kasus: <br><br><img src="https://habrastorage.org/webt/tn/7r/mz/tn7rmzk8pbzw1ezupbdv7fxvqhm.png"><br><br>  Pinout-nya: <br><br><img src="https://habrastorage.org/webt/tr/bo/5r/trbo5rlj2_q0v-lxbs7wbqevlu0.png"><br><br><h2>  Sistem host untuk menghubungkan chip A7001 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EST32 WiFi Kit 32</a> board <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heltec</a> diambil sebagai tata letak sistem host dengan antarmuka I2C.  Harganya kurang dari 1000 rubel, memiliki semua antarmuka kabel dan nirkabel yang diperlukan, ada konektor untuk menghubungkan baterai lithium dengan sirkuit pengisian daya, serta layar OLED 0,96 inci. <br><br><img src="https://habrastorage.org/webt/uf/kq/li/ufkqlihfpi9w0692rq8junv0ybo.jpeg"><br><br>  Sistem yang hampir sempurna untuk membuat prototipe berbagai perangkat IoT dan M2M, yang sudah lama ingin saya mainkan. <br><br>  Papan dapat diprogram baik di lingkungan pengembangan asli maupun di Arduino IDE.  Ada banyak contoh untuk bekerja dengannya.  Untuk kesederhanaan, saya memilih IDE Arduino standar. <br><br><h2>  Diagram sirkuit </h2><br>  Diagram sirkuit untuk menghubungkan chip A7001 ditunjukkan pada gambar.  <s>Ini sedikit berbeda dari lembar data yang direkomendasikan.</s>  <s>Menurut deskripsi pabrikan, terminal 22 (sinyal reset RST_N) seharusnya memiliki potensi tinggi, tetapi sirkuit tidak dimulai sesuai dengan skema ini.</s>  <s>Sebagai hasil dari "poke ilmiah", operabilitas dicapai dengan menghubungkan resistor pull-up R4 ke konduktor daya negatif.</s> <br><br>  <i>UPDATE: Seperti yang disarankan dalam komentar, skema sesuai dengan lembar data, sedangkan deskripsi output membingungkan saya</i> <blockquote>  RST_N - Reset input, <b>LOW aktif</b> </blockquote><br><br><img src="https://habrastorage.org/webt/ud/l3/nd/udl3nd7nz2ck8gtwkb3dhdudzqy.png"><br><br>  Sirkuit dipasang di papan tempat memotong roti kecil.  Sinyal daya dan I2C dihubungkan oleh empat kabel penghubung, dan modul ESP32 itu sendiri terhubung ke komputer melalui USB untuk menerima daya ke seluruh rangkaian dan mengisi firmware. <br><br><img src="https://habrastorage.org/webt/de/xz/w1/dexzw1kvlnoixvk0ko-9svuvkbg.png"><br><br><h2>  Protokol I2C Kartu Cerdas </h2><br>  Ketika saya pertama kali mendengar tentang menghubungkan mikrokontroler kartu pintar melalui bus I2C, mereka menjelaskan kepada saya bahwa lapisan fisik antarmuka kartu pintar (GOST R ISO / IEC 7816-3-2013) diganti dengan I2C (SMBus), dan semuanya berjalan seperti biasa kartu pintar menurut GOST R ISO / IEC 7816-4-2013 menggunakan perintah APDU. <br><br>  Ternyata ini tidak sepenuhnya benar, atau lebih tepatnya tidak sama sekali.  Interaksi dengan mikrokontroler di tingkat tinggi memang terjadi menggunakan perintah APDU konvensional, tetapi ada beberapa "tetapi" juga. <br><br><ol><li>  Antarmuka I2C (SMBus) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ru.wikipedia.org/wiki/I%C2%B2C</a> adalah bus dengan pengalamatan slave, yang secara fundamental berbeda dari antarmuka serial UART, yang dirancang untuk berkomunikasi dua perangkat secara point-to-point dan tidak menggunakan pengalamatan .  Ini berarti bahwa semua data yang dikirimkan (perintah APDU) harus "dikemas" ke dalam format data bus I2C. </li><li>  Bekerja dengan kartu pintar dimulai dengan setel ulang, biasanya dengan mematikan daya, misalnya, mengeluarkan kartu secara fisik dari pembaca kartu.  Setelah reset, kartu pintar pertama kali mengirim blok data ATR (Jawab Untuk Reset), yang berisi informasi konfigurasi yang diperlukan untuk mengkonfigurasi interaksi dengan kartu pintar. <br>  Dan chip pada bus I2C tidak terkecuali, tetapi dalam kasus di mana mikrokontroler harus disolder ke papan sirkuit cetak, mungkin tidak memiliki sirkuit daya untuk sirkuit mikro atau kontrol perangkat lunak dari output reset.  Oleh karena itu, reset chip diimplementasikan, termasuk, pada tingkat perintah protokol I2C. </li></ol><br>  Masalah-masalah ini dan lainnya dibahas melalui Protokol I2C Kartu Cerdas, deskripsi yang dapat ditemukan di situs web NXP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.nxp.com/docs/en/supporting-information/AN12207.pdf</a> . <br><br><h2>  Bagian perangkat lunak </h2><br>  Pencarian pustaka dengan implementasi <i>protokol Smart Card I2C Protocol</i> tidak memberikan hasil apa pun.  Oleh karena itu, saya harus memahami spesifikasi dan membuat implementasi fungsi dasar apa yang ada di tangan. <br><br><div class="spoiler">  <b class="spoiler_title">Sumber sketsa untuk Arduino IDE</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;vector&gt; // I2C address on chip A7001 #define ADDR_A7001 static_cast&lt;uint16_t&gt;(0x48) using namespace std; typedef std::vector&lt;uint8_t&gt; vect; //-------------------------------------------------------------------------- // Output dump data by serial port void vect_dump(const char * prefix, const vect &amp; v, const size_t start = 0, const size_t count = 0) { if(prefix) { Serial.print(prefix); } if(v.size() &lt; start) { Serial.println("Empty"); return; } for(size_t i=0; i &lt; (v.size()-start) &amp;&amp; (count == 0 || i &lt; count); i++) { uint8_t b = v[start + i]; // Format output HEX data if(i) Serial.print(" "); if(b &lt; 0x0F) Serial.print("0"); Serial.print(b, HEX); } Serial.println(""); } //-------------------------------------------------------------------------- // Send array bytes by I2C to address A7001 and read response result_size bytes vect sci2c_exchange(const vect data, const uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(data.data(), data.size()); Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); //delay(1); vect result(result_size, 0); if(result_size &gt;= 2) { result[0] = Wire.read(); // Data size CDB result[1] = Wire.read(); // PCB for(size_t i=2; i&lt;result.size()-2 &amp;&amp; Wire.available(); i++) { result[i+2] = Wire.read(); } } return result; } //-------------------------------------------------------------------------- // Read Status Code uint8_t sci2c_status(const char * msg = nullptr) { vect v = sci2c_exchange({0b0111}, 2); uint8_t status = v[1] &gt;&gt; 4; if(msg) { Serial.print(msg); // Prefix switch(status) { case 0b0000: Serial.println("OK (Ready)"); break; case 0b0001: Serial.println("OK (Busy)"); break; case 0b1000: Serial.println("ERROR (Exception raised)"); break; case 0b1001: Serial.println("ERROR (Over clocking)"); break; case 0b1010: Serial.println("ERROR (Unexpected Sequence)"); break; case 0b1011: Serial.println("ERROR (Invalid Data Length)"); break; case 0b1100: Serial.println("ERROR (Unexpected Command)"); break; case 0b1101: Serial.println("ERROR (Invalid EDC)"); break; default: Serial.print("ERROR (Other Exception "); Serial.print(status, BIN); Serial.println("b)"); break; } } return status; } static uint8_t apdu_master_sequence_counter = 0; // Sequence Counter Master, Master to Slave //-------------------------------------------------------------------------- // Send APDU void sci2c_apdu_send(const vect apdu) { vect_dump("C-APDU =&gt; ", apdu); vect data(2, 0); // 0x00 - Master to Slave Data Transmission command + reserve to length data.insert(data.end(), std::begin(apdu), std::end(apdu)); data[0] |= (apdu_master_sequence_counter &lt;&lt; 4); if(++apdu_master_sequence_counter &gt; 0b111) { apdu_master_sequence_counter = 0; } data[1] = data.size() - 2; sci2c_exchange(data, 2); delay(10); sci2c_status(""); } //-------------------------------------------------------------------------- // Receive APDU vect sci2c_apdu_recv(uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(0b0010); // 0010b - Slave to Master Data Transmission command Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); vect result(result_size, 0); for(size_t i=0; i&lt;result.size() &amp;&amp; Wire.available(); i++) { result[i] = Wire.read(); } vect_dump("R-APDU &lt;= ", result); return result; } //-------------------------------------------------------------------------- void setup(){ Wire.begin(); Serial.begin(9600); while (!Serial); Serial.println(""); Serial.println("Smart Card I2C Protocol Arduino demo on A7001"); Serial.println(""); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); // Soft Reset sci2c_exchange({0b00011111}, 2); //The bits b0 to b5 set to 011111b indicate the Soft Reset command. delay(5); // Wait at least tRSTG (time, ReSeT Guard) sci2c_status("Status SoftReset: "); // Read ATR vect ATR = sci2c_exchange({0b101111}, 29+2); //The bits b0 to b5 set to 101111b indicate the Read Answer to Reset command. sci2c_status("Status ATR: "); vect_dump("ATR: ", ATR, 2); // Parameter Exchange // The bits b0 to b5 set to 111111b of the PCB send by the master device indicate the Parameter Exchange command. // The bits b6 and b7 of the PCB send by the master device code the CDBIsm,max(Command Data Bytes Integer, Slave to Master, MAXimum) vect CDB = sci2c_exchange({0b11111111}, 2); sci2c_status("Status CDB: "); vect_dump("CDB: ", CDB, 1); // Further examples of the exchange of APDU // Exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); // Read Card Production Life Cycle sci2c_apdu_send({0x80, 0xCA, 0x9F, 0x7F, 0x00}); sci2c_status("Status card LC send: "); sci2c_apdu_recv(0x30+1); // R-APDU size + 1 byte PBC sci2c_status("Status card LC recv: "); // Read Card Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0x66, 0x00}); sci2c_status("Status card info send: "); sci2c_apdu_recv(0x51+1); // R-APDU size + 1 byte PBC sci2c_status("Status card info recv: "); // Read Key Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0xE0, 0x00}); sci2c_status("Status key send: "); sci2c_apdu_recv(0x17+1); // R-APDU size + 1 byte PBC sci2c_status("Status key recv: "); // Again exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); Serial.println("Done!\n"); } //-------------------------------------------------------------------------- void loop() { delay(100); }</span></span></span></span></code> </pre> <br></div></div><br>  Untuk bekerja dengan port I2C, saya menggunakan perpustakaan Wire standar.  Saya harus mengatakan segera bahwa perpustakaan ini tidak cocok untuk implementasi penuh Protokol Kartu I2C Smart, karena  itu tidak memungkinkan untuk mengontrol ACK dan NACK ketika mentransmisikan dan membaca masing-masing byte, yang diperlukan untuk mengimplementasikan penerimaan data panjang variabel yang benar dari kartu pintar. <br><br>  Ya, dan contoh biasa kode Kawat tidak berfungsi pertama kali, tetapi setelah beberapa menari dengan keyboard <s>rebana</s> , beberapa liter kopi, googling di Yandex dan Yandex di google, solusinya ditemukan. <br><br><pre> <code class="cpp hljs">Wire.write ( ); Wire.endTransmission (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Wire.requestFrom (ADDR_A7001, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Dilihat oleh dokumentasi perpustakaan, desain ini tidak melepaskan bus I2C setelah memanggil <i>endTransmission</i> .  Tetapi ternyata untuk modul berbasis ESP32 yang saya gunakan, transfer data tidak terjadi secara fisik selama panggilan ke <i>endTransmisi (salah)</i> , seperti yang tertulis dalam dokumentasi untuk perpustakaan Wire, tetapi selama panggilan untuk <i>memintaDari (benar)</i> , sementara sebelumnya data tersebut hanya diantrekan untuk mentransfer. <br><br>  Mengingat keterbatasan seperti itu, saya harus membuat "kruk", tetapi saya benar-benar ingin meluncurkan chip A7001 tanpa menulis ulang pustaka standar.  Karena itu, penanganan kesalahan protokol tidak diimplementasikan, dan juga tidak mungkin untuk menerima data dengan panjang variabel (yaitu, Anda selalu perlu menentukan jumlah byte yang tepat untuk dibaca). <br><br>  Pembatasan seperti itu tidak diperbolehkan dalam sistem nyata, tetapi tidak penting untuk menunjukkan penggunaan perintah APDU ketika bekerja pada bus I2C.  Oleh karena itu, jika terjadi kesalahan dalam protokol pertukaran saat bertukar data melalui port I2C, maka sakelar sakelar daya adalah milik kita. <br>  Dengan kata lain, jika selama pengulangan percobaan ini semuanya bekerja dan tiba-tiba berhenti sebelum mencari kesalahan dalam kode, matikan daya dan nyalakan.  Dengan tingkat probabilitas tinggi ini dapat memperbaiki masalah. <br><br><h2>  Contoh kode untuk bekerja dengan chip A7001 </h2><br>  Dalam contoh, saya menggunakan beberapa fungsi pembantu: <br><br>  <b>vect_dump</b> - output data dump dalam format HEX ke port debug; <br>  <b>sci2c_exchange</b> - mengirim array data melalui I2C dan membaca jumlah byte respons yang ditentukan; <br>  <b>sci2c_status</b> - baca status respons dari rangkaian mikro dan, jika perlu, tampilkan statusnya di port debug; <br>  <b>sci2c_apdu_send</b> - kirim perintah APDU; <br>  <b>sci2c_apdu_recv</b> - baca respons terhadap perintah APDU. <br><br><h3>  Inisialisasi microchip </h3><br>  Menurut uraian <i>Protokol Kartu I2C Smart</i> , sebelum mulai bekerja dengan chip, tiga perintah harus dijalankan secara berurutan: Reboot (Cold atau Soft Reset), Baca ATR (Read Answer to Reset) dan Siapkan parameter pertukaran (Parameter pertukaran Perangkat Utama).  Dan hanya setelah itu chip siap menerima perintah APDU. <br><br><h3>  Reset lunak </h3><br>  Semuanya sederhana di sini, kami mengirim perintah reboot dan menunggu waktu yang ditentukan: <br><br><pre> <code class="cpp hljs">sci2c_exchange ({<span class="hljs-number"><span class="hljs-number">0b00011111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); delay(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      (tRSTG, time, ReSeT Guard)</span></span></code> </pre><br><h3>  Baca Jawaban untuk Mengatur Ulang </h3><br>  Membaca ATR sedikit lebih rumit, seperti  Anda tidak hanya perlu mengirim perintah, tetapi juga membaca data respons.  Menurut uraian protokol, ukuran maksimum dari data yang dikembalikan CDBATS, MAX (Command Data Bytes, Answer To Reset, MAXimum) dapat menjadi 29 byte. <br><br><pre> <code class="cpp hljs">vect ATR = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b101111</span></span>}, <span class="hljs-number"><span class="hljs-number">29</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 29  + 1  PCB + 1  â€”   vect_dump("ATR: ", ATR);</span></span></code> </pre><br>  Baca data ATR: <b>1E 00 00 00 B8 03 11 01 05 B9 02 01 01 BA 01 01 BB 0D 41 37 30 30 31 43 47 20 32 34 32 52 31</b> <br><br>  Di mana 1E adalah ukuran data yang dikembalikan (29 byte + 1 byte PCB) dan 00 adalah PCB (Protocol Control Byte), yang harus sama dengan 0 dan, dalam contoh ini, data tidak dibaca dengan benar (harus ada satu byte dari PCB, dan mereka bertiga). <br><br>  Berikut ini adalah data yang disandikan dalam format TLV: <br><br>  <b>B8h</b> - <i>Objek data level rendah</i> , ukuran 3 byte ( <b>11j 01j 05j</b> ); <br>  <b>B9h</b> - <i>Protokol pengikat objek data</i> , berukuran 2 byte ( <b>01j 01j</b> ); <br>  <b>BAh</b> - <i>Objek data lapisan yang lebih tinggi</i> , berukuran 1 byte ( <i>01h</i> ); <br>  <b>BBh</b> - <i>Objek data sistem operasi</i> , 13 byte ( <i>41 37 30 30 31 43 47 20 32 34 32 52 31</i> ). <br><br>  <b>Dekripsi konfigurasi read dari chip</b> <br>  <i>Objek data tingkat rendah</i> : <b>11h</b> - versi <b>utama</b> dan kecil dari protokol yang didukung. <br><br>  <i>Kode Deteksi Kesalahan</i> : <b>01h</b> - mendukung deteksi kesalahan dan kontrol integritas data yang dikirimkan menggunakan LRC (Longitudinal Redundancy Code). <br><br>  <i>Frame waiting integer (FWI)</i> : <b>05h</b> - penundaan maksimum antara dua perintah.  Kisaran nilai dapat dari 10 ms hingga 5120 ms, standarnya adalah 5120 ms.  Nilai tersebut dihitung dengan rumus T = 10ms x 2 ^ FWI.  Yang dalam hal ini memberi kita penundaan 320 ms (10ms x 2 ^ 5). <br><br>  <i>Objek data yang mengikat protokol</i> - terdiri dari dua nilai, <b>01 jam 01 jam</b> , yang menyandikan protokol yang didukung dan protokol default.  Nilai-nilai ini berarti dukungan untuk protokol APDU [GOST R ISO / IEC 7816-3-2013], dan, seperti yang Anda duga, protokol yang sama diinstal secara default. <br><br>  <i>Objek data lapisan yang lebih tinggi</i> - angka <b>01j</b> berarti dukungan untuk format APDU pendek dan diperpanjang. <br><br>  <i>Objek data sistem operasi</i> adalah pengidentifikasi hingga 15 byte dalam ukuran, sebagaimana didefinisikan dalam standar [GOST R ISO / IEC 7816-4-2013].  Dalam kasus kami, ini adalah string " <i>A7001CG 242R1</i> ". <br><br><h3>  Perangkat Utama bertukar Parameter </h3><br>  Perintah terakhir untuk menginisialisasi pengaturan pertukaran: <br><br><pre> <code class="cpp hljs">vect CDB = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b11111111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); sci2c_status(<span class="hljs-string"><span class="hljs-string">"Status CDB: "</span></span>); vect_dump(<span class="hljs-string"><span class="hljs-string">"CDB: "</span></span>, CDB, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Nilai kembali: <b>CCh</b> - (11001100b) menurut datasheet, 4 dan 5 bit harus negasi bitwise dari bit 2 dan 3 (NNb mengkode bitbegated CDBIMS, MAX) dan, menurut nilai yang disandikan, chip mendukung ukuran perintah maksimum yang mungkin dari 252 byte CDBIMS , MAX (Command Bytes Integer Data, nilai Master to Slave, MAXimum). <br><br>  Menurut uraian protokol, setelah mengeksekusi ketiga perintah ini dan dalam urutan itu, rangkaian mikro siap untuk mengeksekusi perintah APDU biasa (meskipun tampaknya berfungsi tanpa mengatur parameter pertukaran, mis. Itu sudah cukup untuk melakukan Soft Reset dan membaca ATR). <br><br><h2>  Melaksanakan Perintah APDU </h2><br>  <b>Setiap siklus menjalankan perintah APDU terdiri dari langkah-langkah berikut:</b> <br><br><ol><li>  Kirim APDU (perintah Master to Slave Data Transmission). </li><li>  Tunggu waktu perlindungan untuk menerima dan memproses perintah. </li><li>  Tunggu pemrosesan perintah untuk membaca status (perintah Status). </li><li>  Baca data respons (perintah Transmisi Budak ke Data Master). </li></ol><br>  Logika ini diimplementasikan dalam fungsi <b>sci2c_apdu_send</b> dan <b>sci2c_apdu_recv</b> , dan ada poin penting di sini: dalam format Smart Card I2C Protocol, ada counter dari perintah APDU yang dikirimkan.  Penghitung ini harus mengontrol Master dan perangkat Slave dan mereka dirancang untuk mengontrol urutan data yang dikirimkan, sehingga jika terjadi kesalahan penerimaan, Anda dapat mengirim atau meminta data APDU lagi. <br><br>  Contoh penerapan fungsi-fungsi ini dapat ditemukan dalam kode, dan di bawah ini hanya perintah dan data respon APDU. <br><br><h3>  Contoh dari lembar data: </h3><br>  C-APDU =&gt; <b>00 A4 04 04 04 54 65 73 74 00</b> - baca file dengan nama "Test". <br>  R-APDU &lt;= <b>6A 86</b> - menurut datasheet, jawabannya harus <b>64 82</b> ( <i>File atau aplikasi tidak ditemukan</i> ), tetapi dalam kasus kami firmware diunggah ke sirkuit mikro, dan jawabannya berbeda dari contoh yang dijelaskan dalam dokumentasi. <br><br><h3>  Daur Hidup Produksi Kartu Bacaan </h3><br>  C-APDU =&gt; <b>80 CA 9F 7F 00</b> <br>  R-APDU &lt;= <b>9F 7F 2A 47 90 51 67 47 91 12 10 38 00 53 56 00 40 39 93 73 50 48 12 53 63 00 00 00 13 13C 19 30 34 30 33 39 00 00 00 00 00 00 00 90 00</b> <br><br><h3>  Baca Baca Info Kartu </h3><br><br>  C-APDU =&gt; <b>80 CA 00 66 00</b> <br>  R-APDU &lt;= <b>66 4C 73 4A 06 07 2A 86 48 86 FC 6B 01 60 0C 06 0A 2A 86 48 86 FC 6B 02 02 01 01 63 09 06 07 2A 86 48 86 FC 6B 03 64 0B 06 09 2A 86 48 86 FC 6B 04 02 55 65 0B 06 09 2B 85 10 86 48 64 02 01 03 66 0C 06 0A 2B 06 01 04 01 2A 02 6E 01 02 90 00</b> <br><br><h3>  Baca Baca Info Utama </h3><br>  C-APDU =&gt; <b>80 CA 00 E0 00</b> <br>  R-APDU &lt;= <b>E0 12 C0 04 01 FF 80 10 C0 04 02 FF 80 10 C0 04 03 FF 80 10 90 00</b> <br><br><h2>  Kesimpulannya </h2><br>  Pengalaman menerapkan pertukaran tim APDU melalui antarmuka I2C sangat menarik.  Saya bahkan mendapati diri saya berpikir beberapa kali bahwa saya menikmati menyelesaikan berbagai masalah dari bidang sirkuit, dan dari penyolderan biasa juga, sejak terakhir kali saya harus mengambil besi solder lebih dari 5 tahun yang lalu. <br><br>  Semoga artikel ini bermanfaat dan membantu memahami mereka yang tertarik dengan topik ini.  Tulis jika materi yang Anda minati.  Saya akan mencoba menjawab semua pertanyaan pada artikel ini, dan jika topik menggunakan Smart Card I2C Protocol menarik, maka saya akan mencoba untuk mengungkapkannya secara lebih rinci dalam publikasi berikut. <br><br><h2>  Referensi: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskripsi Antarmuka I2C (SMBus)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lembar data pada mikrokontroler A7001AG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskripsi Smart Card I2C Protocol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GOST R ISO / IEC 7816-3-2013</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GOST R ISO / IEC 7816-4-2013</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439574/">https://habr.com/ru/post/id439574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439564/index.html">Aplikasi Praktis Transformasi Pohon AST Menggunakan Putout sebagai Contoh</a></li>
<li><a href="../id439566/index.html">Mengapa dokumentasi SRE penting? Bagian 3</a></li>
<li><a href="../id439568/index.html">SSD berbasis QLC - pembunuh hard drive? Tidak juga</a></li>
<li><a href="../id439570/index.html">IPython magic untuk mengedit tag sel Jupyter</a></li>
<li><a href="../id439572/index.html">Desain peralatan elektronik berbantuan komputer</a></li>
<li><a href="../id439576/index.html">Tinjauan luas wawancara Python. Kiat & Trik</a></li>
<li><a href="../id439578/index.html">Untuk pertanyaan transformasi dan operasi lainnya</a></li>
<li><a href="../id439580/index.html">Membuat Git untuk Windows berfungsi di ReactOS</a></li>
<li><a href="../id439584/index.html">Proyek energi sebagai memikirkan kembali pasokan daya portabel</a></li>
<li><a href="../id439586/index.html">Protokol SPBm sebagai dasar Extreme Automated Campus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>