<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèª ‚òÑÔ∏è üåπ AsyncIO Micropython: metode sinkronisasi dalam pemrograman asinkron üßîüèΩ üíÜüèæ üòä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam pemrograman berurutan, saya terus-menerus menghadapi keinginan yang jelas untuk tidak menghentikan program pada saat tujuan tugas tertentu (pros...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AsyncIO Micropython: metode sinkronisasi dalam pemrograman asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442268/">  Dalam pemrograman berurutan, saya terus-menerus menghadapi keinginan yang jelas untuk tidak menghentikan program pada saat tujuan tugas tertentu (proses) adalah tindakan berkala - misalnya, menghitung nilai sensor, atau mentransmisikan data sesuai jadwal ke server, atau input / output sejumlah besar data.  Hal yang paling sederhana, tentu saja, adalah menunggu selesainya acara berkala dan kemudian, perlahan, terus melakukan tugas-tugas lain. <br><a name="habracut"></a><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: do_ext_proc_before() do_internal_proc() sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) do_ext_proc_after()</code> </pre> <cut><br>  Anda dapat mengabaikan 'sleep ()' dan mengaktifkan pengecekan untuk beberapa kondisi dalam loop, yang memungkinkan Anda untuk tidak menunda loop utama setidaknya sampai peristiwa periodik terjadi: <br><br><pre> <code class="python hljs"> start = time() set_timer(start,wait=<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   set_timeout(start,wait_to=7) #   set_irq(alarm) #    while True: curTime = time() do_ext_proc_before() if timer(curTime) or timeout(curTime) or alarm: # if all events crazy start simultaneously - reset all start = time() set_timer(start,wait=5) #   set_timeout(start,wait_to=7) #   set_irq(alarm) #    do_internal_proc() do_ext_proc_after()</span></span></code> </pre><br>  Dalam pemrograman asinkron, setiap tugas menjadi proses independen dan dieksekusi, tergantung pada implementasi spesifik, secara paralel atau pseudo-paralel, menggunakan pemahaman internal tentang kondisi menunggu yang dibuat secara alami atau buatan atau penggunaan sumber daya terbatas, misalnya, disk atau saluran komunikasi. <br><br><pre> <code class="python hljs"> setTask(do_ext_proc_before()) setTask(do_internal_proc(),timer=<span class="hljs-number"><span class="hljs-number">5</span></span>,timeout=<span class="hljs-number"><span class="hljs-number">7</span></span>,alarm_handler=alarm) setTask(do_ext_proc_after()) runTasks()</code> </pre><br>  Sekarang muncul masalah yang tidak ada dalam pemrograman berurutan - apa yang harus dilakukan jika perlu menyinkronkan beberapa proses dengan asinkronnya <br>  lakukan?  Misalnya, setelah menerima data dari sensor, memulai proses pengiriman data ke server atau merespons keadaan darurat.  Selain itu, dalam pemrograman asinkron, organisasi input / output asinkron secara organik diselesaikan dalam standar bahasa, dan situasi lain diselesaikan di perpustakaan. <br><br>  Saya mempelajari pertanyaan ini menggunakan asyncio Micropython extended library yang diterbitkan <br>  Peter Hinch ( <a href="">https://github.com/peterhinch/micropython-async/blob/master/TUTORIAL.md</a> ) <br>  Solusi paling sederhana adalah memberi sinyal acara ke proses yang tertarik.  Untuk melakukan ini, gunakan kelas Event (), yang berisi beberapa modul <br><br><pre> <code class="python hljs"> Event.Set( timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -    (Event = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>), ,     , Event.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Event.Wait() -   ,     - Done,Timeout,Cancel Event.Data() -  ,     Event.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>).</code> </pre><br>  Penyelesaian dicatat, sebagai suatu peraturan, oleh proses yang menunggu peristiwa terjadi, misalnya, proses menampilkan di layar atau proses menyimpan data ke disk, atau batas waktu, maka tidak perlu memperbarui atau menyimpan data, karena mereka tidak diperbarui karena alasan apa pun, atau karena gangguan pada kejadian peristiwa penting lainnya, misalnya, transisi ke mode tidur atau reboot, yang mungkin memerlukan pelepasan semua proses yang tertunda dengan mengatur ulang acara yang sesuai. <br><br>  Harus diingat bahwa disarankan untuk membuat Event.Clear () dengan hanya satu proses, jika ini tidak bertentangan dengan algoritma yang diberikan.  Jika tidak, jika beberapa proses sedang menunggu acara Event.Set () terjadi, diasumsikan bahwa Event.Clear () harus dilakukan oleh salah satu proses yang tertarik, hanya memastikan bahwa semua proses yang tertarik telah merespons acara tersebut.  Ini menyulitkan logika keputusan ketika menggunakan Event-Class ketika menunggu suatu peristiwa dengan beberapa proses.  Situasi ini diselesaikan dengan menetapkan sejumlah Clear () dari peristiwa yang terjadi. <br><br><pre> <code class="python hljs"> Barrier.Set( quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) - quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>  Event.Set() Barrier.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Barrier.Wait() -   ,     - Done,Timeout,Cancel Barrier.Data() -  ,     Barrier.qty -      Barrier.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>),        Barrier.quantity  ,    ,    </code> </pre><br>  Pada saat yang sama, tidak ada akuntansi yang disimpan - proses spesifik mana yang telah merespons, dan yang belum, yang dapat menimbulkan masalah reaksi berulang terhadap peristiwa tersebut, jika ini penting untuk algoritma yang diberikan.  Jika alih-alih Barrier.quantity Anda melewati daftar nama proses yang diminati, konflik ini dapat dihindari.  Juga, dalam hal timeout atau gangguan acara, Anda dapat menentukan proses tertunda tertentu yang belum berfungsi.  Semua hal di atas berlaku untuk situasi di mana satu atau lebih proses menunggu terjadinya peristiwa tertentu, atau situasi satu-ke-banyak.  Ini terjadi ketika proses atau proses do_ext_proc_after () selama pemrograman berurutan akan dieksekusi hanya setelah penyelesaian do_internal_proc ().  Untuk kenyamanan pemahaman lebih lanjut, kami akan memperluas Kelas Acara dan Kelas Penghalang ke dalam Kelas EEvent baru dan menjadikannya atau objek yang dihasilkannya - global.  Di sini 'pencipta' adalah nama atau daftar nama proses yang memicu acara atau membuka sumber daya, 'pengikut' adalah nama atau daftar nama proses yang menunggu acara atau membuka kunci sumber daya <br><br><pre> <code class="python hljs"> EEvent.Set (creators, folowers, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,        EEvent.IsSet( procName ) - procName -   ID   EEvent.Wait( procName ) EEvent.Clear( procName ) EEvent.Folowers() -    ,      . Barrier.qty = len(EEvent.List()) EEvent.Creators() -   ,    </code> </pre><br>  Dengan menggunakan modul EEvent-Class, kita dapat menggambarkan solusi untuk masalah yang telah dibahas sebelumnya. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Set (<span class="hljs-string"><span class="hljs-string">'p_Creator'</span></span>,(<span class="hljs-string"><span class="hljs-string">'p_Folwer1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Folwer2'</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer1') def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer2')</span></span></code> </pre><br>  Pertimbangkan situasi yang berlawanan - ketika satu proses sedang menunggu penyelesaian beberapa peristiwa, atau situasi 'banyak ke satu'.  Dengan kata lain, bahwa jika eksekusi do_internal_proc () dapat dilakukan hanya setelah eksekusi do_ext_proc_before (). Dalam kasus ekstrem, ketika satu proses menunggu penyelesaian / terjadinya satu peristiwa, tugas dapat diselesaikan menggunakan kelas-Acara.  Ketika penyelesaian beberapa peristiwa diharapkan, misalnya, hanya setelah menampilkan data yang diterima dan mengirimkannya ke server, menyimpannya ke disk, perlu bahwa setiap proses yang dieksekusi menetapkan partisipasinya dalam acara yang diharapkan dan menunggu sampai semua proses selesai. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator1'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator2'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Wait((<span class="hljs-string"><span class="hljs-string">'p_Creator1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Creator2'</span></span>)) ... EEvent.Clear(<span class="hljs-string"><span class="hljs-string">'p_Folwer'</span></span>)</code> </pre><br>  Aspek penting lain dari pemrograman asinkron adalah berbagi sumber daya yang terbatas.  Misalnya, pemutakhiran data harus dilakukan hanya oleh satu proses, sisa proses yang mengklaim tindakan serupa harus mengantri atau menunggu hingga data diperbarui.  Pada saat yang sama, ada kemungkinan bahwa membaca data untuk tampilan atau penerusan tidak akan menjadi kritis.  Oleh karena itu, perlu mengetahui daftar proses yang bersaing ketika mengatur acara yang relevan. <br><br>  Dalam standar pemrograman asinkron, tugas ini diselesaikan oleh modul Lock-Class.  Dalam kasus umum, masalahnya juga dapat diselesaikan dengan cara yang sama dengan situasi satu-ke-banyak. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># lock activity all 'followers' in list ... EEvent.Set ('p_Creator',('p_Folwer1','p_Folwer2')) # exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') # waiting for recourse releale if ( EEvent.Set ('p_Folwer1','p_Folwer2')): # lock resource 'p_Folower1' now is 'p_Creator' ... else: EEvent.Wait('p_Folower2') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer1') # releafe recourse def do_ext_proc_after1() ... EEvent.Wait('p_Creator') if ( EEvent.Set ('p_Folwer2','p_Folwer1')): # lock resource 'p_Folower2' now is 'p_Creator' ... else: EEvent.Wait('p_Folower1') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer2') # releafe recourse</span></span></code> </pre><br>  Selain opsi yang dipertimbangkan, ada solusi yang membatasi throughput, mengatur antrian dan penjadwalan proses yang terkontrol, tetapi dalam aktivitas saya belum ada kebutuhan untuk ini dan, sebagai hasilnya, kebutuhan untuk pemahaman yang cukup untuk diri saya sendiri, meskipun saya tidak mengecualikan bahwa ada yang lebih elegan atau keputusan ekonomis. <br><br>  Sebagai kesimpulan, saya ingin mengatakan bahwa pendekatan sekuensial dan tidak sinkron memiliki hak yang sama untuk ada dan berhasil mengimplementasikan algoritma yang diberikan.  Oleh karena itu, penerapan pendekatan ini atau itu ditentukan oleh prioritas pencipta - yang lebih penting baginya ketika menerapkan algoritma yang diberikan - transparansi dan keterbacaan, kecepatan atau volume kode yang dihasilkan. </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442268/">https://habr.com/ru/post/id442268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442258/index.html">Pengikisan web untuk pengembang web: ringkasan singkat</a></li>
<li><a href="../id442260/index.html">10 Perintah Git Yang Harus Diketahui Pengembang</a></li>
<li><a href="../id442262/index.html">Rahasia firmware</a></li>
<li><a href="../id442264/index.html">Menghilangkan peluang untuk pembajakan lalu lintas</a></li>
<li><a href="../id442266/index.html">Delta Chat - messenger terdesentralisasi di atas email</a></li>
<li><a href="../id442270/index.html">5 Kesalahan yang Harus Dihindari Saat Membuat Model 3D untuk Pencetakan 3D</a></li>
<li><a href="../id442272/index.html">Go + = versi paket</a></li>
<li><a href="../id442274/index.html">Dart 2. Pemrograman Asinkron: Aliran Data</a></li>
<li><a href="../id442278/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 6</a></li>
<li><a href="../id442280/index.html">Pembelajaran Mesin di Dodo. Cara meluncurkan arah baru jika Anda seorang pengembang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>