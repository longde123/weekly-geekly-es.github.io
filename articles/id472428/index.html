<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏽 🚻 ⛩️ Operator kubernet Tarantool 👏🏾 👏🏾 🙇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes telah menjadi standar de-facto untuk menjalankan aplikasi stateless, terutama karena dapat mengurangi waktu ke pasar untuk fitur baru. Melu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Operator kubernet Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/472428/"><img src="https://habrastorage.org/getpro/habr/post_images/550/d23/612/550d23612db44d65216aff9caf75403a.jpg"><br><br>  Kubernetes telah menjadi standar de-facto untuk menjalankan aplikasi stateless, terutama karena dapat mengurangi waktu ke pasar untuk fitur baru.  Meluncurkan aplikasi stateful, seperti database atau microservices stateful, masih merupakan tugas yang kompleks, tetapi perusahaan harus memenuhi kompetisi dan mempertahankan tingkat pengiriman yang tinggi.  Jadi mereka menciptakan permintaan untuk solusi semacam itu. <br><br>  Kami ingin memperkenalkan solusi kami untuk meluncurkan kluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Cartridge</a> stateful <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">state</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Kubernetes Operator</a> , lebih di bawah potongan. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alih-alih Seribu Kata</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang Sebenarnya Dilakukan oleh Operator</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedikit Tentang Perincian</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara operator bekerja</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang Diciptakan Operator</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> <br></li></ol><br>  Tarantool adalah DBMS open-source dan server aplikasi all-in-one.  Sebagai basis data, ia memiliki banyak karakteristik unik: efisiensi tinggi pemanfaatan perangkat keras, skema data yang fleksibel, dukungan untuk memori dan penyimpanan disk, dan kemungkinan ekstensi menggunakan bahasa Lua.  Sebagai server aplikasi, ini memungkinkan Anda untuk memindahkan kode aplikasi sedekat mungkin dengan data dengan waktu respons minimum dan throughput maksimum.  Selain itu, Tarantool memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekosistem yang luas yang</a> menyediakan modul yang siap digunakan untuk menyelesaikan masalah aplikasi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sharding</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antrian</a> , modul untuk pengembangan mudah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cartridge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luatest</a> ), solusi untuk operasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metrik</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mungkin</a> ), hanya untuk beberapa nama. <br><br>  Untuk semua kelebihannya, kemampuan turunan Tarantool tunggal selalu terbatas.  Anda harus membuat puluhan dan ratusan instance untuk menyimpan terabyte data dan memproses jutaan permintaan, yang sudah menyiratkan sistem terdistribusi dengan semua masalah khasnya.  Untuk mengatasinya, kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Cartridge</a> , yang merupakan kerangka kerja yang dirancang untuk menyembunyikan segala macam kesulitan saat menulis aplikasi terdistribusi.  Ini memungkinkan pengembang untuk berkonsentrasi pada nilai bisnis aplikasi.  Cartridge menyediakan serangkaian komponen yang kuat untuk orkestrasi klaster otomatis, distribusi data otomatis, WebUI untuk operasi, dan alat pengembang. <br><br>  Tarantool tidak hanya tentang teknologi, tetapi juga tentang tim insinyur yang bekerja pada pengembangan sistem turnkey enterprise, solusi out-of-the-box, dan dukungan untuk komponen open-source. <br><br>  Secara global, semua tugas kita dapat dibagi menjadi dua area: pengembangan sistem baru dan peningkatan solusi yang ada.  Misalnya, ada basis data yang luas dari vendor terkenal.  Untuk skala untuk membaca, cache konsisten akhirnya berbasis Tarantool ditempatkan di belakangnya.  Atau sebaliknya: untuk skala penulisan, Tarantool diinstal dalam konfigurasi panas / dingin: saat data “dingin”, data itu dibuang ke penyimpanan dingin dan pada saat yang sama masuk ke antrian analitik.  Atau versi ringan dari sistem yang ada ditulis (cadangan fungsional) untuk membuat cadangan data "panas" dengan menggunakan replikasi data dari sistem utama.  Pelajari lebih lanjut dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan konferensi T + 2019</a> . <br><br>  Semua sistem ini memiliki satu kesamaan: mereka agak sulit dioperasikan.  Nah, ada banyak hal yang menarik: untuk dengan cepat membuat sekelompok 100+ contoh yang didukung di 3 pusat data;  untuk memperbarui aplikasi yang menyimpan data tanpa downtime atau drawdown pemeliharaan;  untuk membuat cadangan dan memulihkan untuk mempersiapkan kemungkinan kecelakaan atau kesalahan manusia;  untuk memastikan kegagalan komponen yang tersembunyi;  untuk mengatur manajemen konfigurasi ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Cartridge</a> yang baru saja dirilis ke open source secara signifikan menyederhanakan pengembangan sistem terdistribusi: ia mendukung pengelompokan komponen, penemuan layanan, manajemen konfigurasi, deteksi kegagalan instance dan failover otomatis, manajemen topologi replikasi, dan komponen sharding. <br>  Akan sangat bagus jika kita bisa mengoperasikan semua ini secepat mengembangkannya.  Kubernet memungkinkan, tetapi operator khusus akan membuat hidup lebih nyaman. <br><br>  Hari ini kami memperkenalkan versi alpha Operator Tarantool Kubernetes. <br><br><a name="1"></a><h2>  Alih-alih Seribu Kata </h2><br>  Kami telah menyiapkan contoh kecil berdasarkan Tarantool Cartridge, dan kami akan bekerja dengannya.  Ini adalah aplikasi sederhana yang disebut penyimpanan nilai kunci terdistribusi dengan antarmuka HTTP.  Setelah start-up, kami memiliki yang berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/235/2c7/c242352c708a0e0dfa8fc0896bbb986d.png"><br><br>  Dimana <br><br><ul><li>  Router adalah bagian dari gugus yang bertanggung jawab untuk menerima dan memproses permintaan HTTP yang masuk; <br></li><li>  Penyimpanan adalah bagian dari cluster yang bertanggung jawab untuk menyimpan dan memproses data;  tiga pecahan dipasang di luar kotak, masing-masing memiliki master dan replika. <br></li></ul><br>  Untuk menyeimbangkan lalu lintas HTTP yang masuk pada router, Kubernetes Ingress digunakan.  Data didistribusikan dalam penyimpanan di tingkat Tarantool sendiri menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen vshard</a> . <br><br>  Kita membutuhkan Kubernet 1.14+, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minikube</a> akan melakukannya.  Sangat menyenangkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubectl</a> .  Untuk memulai operator, buat ServiceAccount, Role, dan RoleBinding: <br><br><pre><code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/service_account.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role_binding.yaml</code> </pre> <br>  Operator Tarantool memperluas API Kubernetes dengan definisi sumber dayanya, jadi mari kita buat mereka: <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_cluster_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_role_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_replicasettemplate_crd.yaml</code> </pre> <br>  Semuanya siap untuk memulai operator, jadi begini: <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/operator.yaml</code> </pre> <br>  Kami menunggu operator untuk memulai, dan kemudian kami dapat melanjutkan dengan memulai aplikasi: <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/examples/kv/deployment.yaml</code> </pre> <br>  Ingress dideklarasikan pada UI web dalam file YAML dengan contoh;  ini tersedia di <code>cluster_ip/admin/cluster</code> .  Ketika setidaknya satu Ingress Pod siap dan berjalan, Anda dapat pergi ke sana untuk melihat bagaimana instance baru ditambahkan ke cluster dan bagaimana topologi berubah. <br>  Kami menunggu cluster untuk digunakan: <br><br><pre> <code class="plaintext hljs">$ kubectl describe clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Kami sedang menunggu Status klaster berikut: <br><br><pre> <code class="plaintext hljs">… Status: State: Ready …</code> </pre> <br>  Itu saja, dan aplikasi siap digunakan! <br><br>  Apakah Anda memerlukan lebih banyak ruang penyimpanan?  Lalu, mari kita tambahkan beberapa pecahan: <br><br><pre> <code class="plaintext hljs">$ kubectl scale roles.tarantool.io storage --replicas=3</code> </pre> <br>  Jika pecahan tidak dapat menangani beban, maka mari kita tambahkan jumlah instance dalam pecahan dengan mengedit templat set replika: <br><br><pre> <code class="plaintext hljs">$ kubectl edit replicasettemplates.tarantool.io storage-template</code> </pre> <br>  Mari kita atur nilai <code>.spec.replicas</code> menjadi dua untuk meningkatkan jumlah instance dalam setiap replika yang disetel menjadi dua. <br><br>  Jika sebuah cluster tidak lagi diperlukan, hapus saja bersama dengan semua sumber daya: <br><br><pre> <code class="plaintext hljs">$ kubectl delete clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Apakah ada yang salah?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buat tiket</a> , dan kami akan segera mengerjakannya. <br><br><a name="2"></a><h2>  Apa yang Sebenarnya Dilakukan oleh Operator </h2><br>  Start-up dan pengoperasian cluster Tarantool Cartridge adalah kisah melakukan tindakan spesifik dalam urutan tertentu pada waktu tertentu. <br><br>  Cluster itu sendiri dikelola terutama melalui API admin: GraphQL melalui HTTP.  Anda tidak diragukan lagi dapat naik level lebih rendah dan memberikan perintah langsung melalui konsol, tetapi ini tidak sering terjadi. <br>  Sebagai contoh, ini adalah bagaimana cluster dimulai: <br><br><ol><li>  Kami menggunakan jumlah instance Tarantool yang diperlukan, misalnya, menggunakan systemd. </li><li>  Kemudian kami menghubungkan instance ke keanggotaan: <br><br><pre> <code class="plaintext hljs">mutation { probe_instance: probe_server(uri: "storage:3301") }</code> </pre> </li><li>  Kemudian kami menetapkan peran ke instance dan menentukan instance dan replika set pengidentifikasi.  API GraphQL digunakan untuk tujuan ini: <br><br><pre> <code class="plaintext hljs">mutation { join_server( uri:"storage:3301", instance_uuid: "cccccccc-cccc-4000-b000-000000000001", replicaset_uuid: "cccccccc-0000-4000-b000-000000000000", roles: ["storage"], timeout: 5 ) }</code> </pre> </li><li>  secara internal, kami mem-bootstrap komponen yang bertanggung jawab untuk sharding menggunakan API: <br><br><pre> <code class="plaintext hljs">mutation { bootstrap_vshard cluster { failover(enabled:true) } }</code> </pre> </li></ol><br>  Mudah kan? <br><br>  Semuanya lebih menarik ketika datang ke ekspansi cluster.  Peran Router dari skala contoh dengan mudah: membuat lebih banyak contoh, bergabung dengan mereka ke cluster yang ada, dan Anda selesai!  Peran Storages agak rumit.  Penyimpanan itu terbengkalai, jadi ketika menambahkan / menghapus instance, perlu menyeimbangkan kembali data dengan memindahkannya ke / dari instance baru / yang dihapus masing-masing.  Gagal melakukan hal itu akan menghasilkan instance yang kurang beban, atau kehilangan data.  Bagaimana jika tidak hanya satu, tetapi selusin cluster dengan topologi yang berbeda? <br><br>  Secara umum, ini semua yang ditangani oleh Operator Tarantool.  Pengguna menggambarkan keadaan yang diperlukan dari kluster Tarantool Cartridge, dan operator menerjemahkannya ke dalam serangkaian tindakan yang diterapkan pada sumber daya K8s dan ke panggilan tertentu ke API administrator klaster Tarantool dalam urutan tertentu pada waktu tertentu.  Itu juga mencoba untuk menyembunyikan semua detail dari pengguna. <br><br><a name="3"></a><h2>  Sedikit Tentang Perincian </h2><br>  Saat bekerja dengan administrator API cluster Tarantool Cartridge, urutan panggilan dan tujuannya sangat penting.  Kenapa begitu? <br><br>  Tarantool Cartridge berisi penyimpanan topologi, komponen penemuan layanan, dan komponen konfigurasi.  Setiap instance dari cluster menyimpan salinan topologi dan konfigurasi dalam file YAML. <br><br><pre> <code class="plaintext hljs">servers: d8a9ce19-a880-5757-9ae0-6a0959525842: uri: storage-2-0.examples-kv-cluster:3301 replicaset_uuid: 8cf044f2-cae0-519b-8d08-00a2f1173fcb 497762e2-02a1-583e-8f51-5610375ebae9: uri: storage-0-0.examples-kv-cluster:3301 replicaset_uuid: 05e42b64-fa81-59e6-beb2-95d84c22a435 … vshard: bucket_count: 30000 ...</code> </pre> <br>  Pembaruan diterapkan secara konsisten menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komitmen dua fase</a> .  Pembaruan yang berhasil membutuhkan kuorum 100%: setiap contoh harus merespons.  Kalau tidak, ia akan berputar kembali.  Apa artinya ini dalam hal operasi?  Dalam hal keandalan, semua permintaan ke API administrator yang mengubah keadaan kluster harus dikirim ke satu instance, atau leader, karena jika tidak, kita berisiko mendapatkan konfigurasi yang berbeda pada instance yang berbeda.  Tarantool Cartridge tidak tahu bagaimana melakukan pemilihan pemimpin (belum dulu), tetapi Operator Tarantool dapat, dan bagi Anda, ini hanya fakta yang menyenangkan, karena operator melakukan segalanya. <br><br>  Setiap instance juga harus memiliki identitas tetap, yaitu serangkaian <code>instance_uuid</code> dan <code>replicaset_uuid</code> , serta <code>advertise_uri</code> .  Jika tiba-tiba sebuah penyimpanan dinyalakan kembali, dan salah satu dari parameter ini berubah, maka Anda berisiko melanggar kuorum, dan operator bertanggung jawab untuk ini. <br><br><a name="4"></a><h2>  Cara operator bekerja </h2><br>  Tujuan operator adalah untuk membawa sistem ke status yang ditentukan pengguna dan mempertahankan sistem dalam keadaan ini sampai petunjuk baru diberikan.  Agar operator dapat bekerja, perlu: <br><br><ol><li>  Deskripsi status sistem. </li><li>  Kode yang akan membawa sistem ke keadaan ini. </li><li>  Mekanisme untuk mengintegrasikan kode ini ke k8s (misalnya, untuk menerima pemberitahuan perubahan status). </li></ol><br>  Cluster Tarantool Cartridge dijelaskan dalam istilah k8s menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Custom Resource Definition (CRD)</a> .  Operator akan membutuhkan tiga sumber daya khusus yang disatukan di bawah grup tarantool.io/v1alpha: <br><br><ul><li>  Cluster adalah sumber daya tingkat atas yang sesuai dengan satu kluster Tarantool Cartridge. </li><li>  Peran adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peran pengguna</a> dalam hal Tarantool Cartridge. </li><li>  Template Replicaset adalah template untuk membuat StatefulSets (saya akan memberitahu Anda sedikit kemudian mengapa mereka stateful; jangan dikacaukan dengan ReplicaSet K8s). </li></ul><br>  Semua sumber daya ini secara langsung mencerminkan model deskripsi klaster Tarantool Cartridge.  Memiliki kamus umum memudahkan berkomunikasi dengan pengembang dan memahami apa yang ingin mereka lihat dalam produksi. <br><br>  Kode yang membawa sistem ke status yang diberikan adalah Controller dalam hal K8s.  Dalam hal Operator Tarantool, ada beberapa pengontrol: <br><br><ul><li>  Cluster Controller bertanggung jawab untuk berinteraksi dengan cluster Cartridge Tarantool;  itu menghubungkan instance ke cluster dan memutus instance dari cluster. </li><li>  Pengontrol Peran adalah pengontrol peran pengguna yang bertanggung jawab untuk membuat StatefulSets dari template dan mempertahankan jumlah yang telah ditentukan sebelumnya. </li></ul><br>  Seperti apa pengontrolnya?  Ini adalah seperangkat kode yang secara bertahap menempatkan dunia di sekitar dirinya sendiri.  Pengontrol Cluster secara skematis akan terlihat seperti: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/048/fbd/e9c/048fbde9c799c900b74df1669d3d760e.png"><br><br>  Titik masuk adalah tes untuk melihat apakah ada sumber daya Cluster yang sesuai untuk suatu acara.  Apakah itu ada  "Tidak" berarti berhenti.  "Ya" berarti pindah ke blok berikutnya dan mengambil Kepemilikan peran pengguna.  Ketika Kepemilikan suatu peran diambil, ia berhenti dan pergi untuk yang kedua kalinya.  Terus dan terus sampai dibutuhkan Kepemilikan semua peran.  Ketika kepemilikan diambil, saatnya untuk pindah ke blok operasi berikutnya.  Dan prosesnya berlangsung sampai blok terakhir.  Setelah itu, kita dapat mengasumsikan bahwa sistem yang dikendalikan dalam keadaan yang ditentukan. <br><br>  Secara umum, semuanya cukup sederhana.  Namun, penting untuk menentukan kriteria keberhasilan untuk melewati setiap tahap.  Misalnya, operasi penggabungan kluster tidak dianggap berhasil ketika mengembalikan hipotetis sukses = benar, tetapi ketika mengembalikan kesalahan seperti "sudah bergabung". <br><br>  Dan bagian terakhir dari mekanisme ini adalah integrasi controller dengan K8s.  Dari pandangan mata burung, seluruh K8 terdiri dari satu set pengontrol yang menghasilkan peristiwa dan meresponsnya.  Acara-acara ini disusun dalam antrian yang dapat kami langgani.  Secara skematis akan terlihat seperti: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51f/aac/8cd/51faac8cdbbc04ec81b0f383313369df.jpg"><br><br>  Pengguna memanggil <code>kubectl create -f tarantool_cluster.yaml</code> , dan sumber daya Cluster yang sesuai dibuat.  Pengontrol Cluster diberitahu tentang penciptaan sumber daya Cluster.  Dan hal pertama yang coba dilakukan adalah menemukan semua sumber daya Peran yang seharusnya menjadi bagian dari klaster ini.  Jika ya, maka menetapkan Cluster sebagai Pemilik untuk Peran dan memperbarui sumber daya Peran.  Pengendali Peran menerima pemberitahuan pembaruan Peran, memahami bahwa sumber daya memiliki Pemiliknya, dan mulai membuat StatefulSets.  Begini caranya: peristiwa pertama memicu yang kedua, peristiwa kedua memicu yang ketiga, dan seterusnya sampai salah satu dari mereka berhenti.  Anda juga dapat mengatur pemicu waktu, misalnya, setiap 5 detik. <br><br>  Beginilah cara operator mengatur: kami membuat sumber daya khusus dan menulis kode yang merespons peristiwa yang terkait dengan sumber daya. <br><br><a name="5"></a><h2>  Apa yang Diciptakan Operator </h2><br>  Tindakan operator pada akhirnya menghasilkan pembuatan K8s Pods dan wadah.  Di Tarantool Cartridge cluster yang digunakan pada K8, semua Pod terhubung ke StatefulSets. <br><br>  Mengapa StatefulSet?  Seperti yang saya sebutkan sebelumnya, setiap instance Tarantool Cluster menyimpan salinan topologi dan konfigurasi cluster.  Dan sesekali server aplikasi memiliki beberapa ruang khusus, misalnya, untuk antrian atau data referensi, dan ini sudah merupakan keadaan penuh.  StatefulSet juga menjamin bahwa identitas Pod dipertahankan, yang penting ketika mengelompokkan instance: instance harus memiliki identitas tetap, jika tidak kita berisiko kehilangan kuorum saat dimulai ulang. <br><br>  Ketika semua sumber daya cluster siap dan dalam keadaan yang diinginkan, mereka mencerminkan hierarki berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51f/aac/8cd/51faac8cdbbc04ec81b0f383313369df.jpg"><br><br>  Tanda panah menunjukkan hubungan Pemilik-Tanggungan antara sumber daya.  Perlu, misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengumpul Sampah</a> untuk membersihkan setelah penghapusan Cluster. <br><br>  Selain StatefulSets, Operator Tarantool menciptakan Layanan Tanpa Kepala untuk pemilihan pemimpin, dan mesin virtual berkomunikasi satu sama lain melalui layanan ini. <br><br>  Operator Tarantool didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Operator</a> , dan kode operator ditulis dalam Golang, jadi tidak ada yang istimewa di sini. <br><br><a name="6"></a><h2>  Ringkasan </h2><br>  Cukup banyak yang ada untuk itu.  Kami menunggu tanggapan dan tiket Anda.  Kita tidak bisa melakukannya tanpa mereka - itu adalah versi alfa.  Apa selanjutnya?  Langkah selanjutnya adalah banyak pemolesan: <br><br><ul><li>  Unit, tes E2E; <br></li><li>  Tes Chaos Monkey; <br></li><li>  tes stres; <br></li><li>  backup / restore; <br></li><li>  penyedia topologi eksternal. <br></li></ul><br>  Masing-masing topik ini bersifat luas sendiri dan layak mendapatkan artikel terpisah, jadi harap tunggu pembaruan! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472428/">https://habr.com/ru/post/id472428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472416/index.html">ZeroNights Hackquest 2019. Hasil & Tulisan</a></li>
<li><a href="../id472418/index.html">Bagaimana cara menjaga hak untuk pengembangan kustom</a></li>
<li><a href="../id472420/index.html">Membuat antarmuka lebih responsif berkat Promise yang ditangguhkan</a></li>
<li><a href="../id472422/index.html">Sber X RamblerFront & Meet Up</a></li>
<li><a href="../id472426/index.html">Security Week 43: Kehidupan Rahasia IoT Hanipots</a></li>
<li><a href="../id472430/index.html">Bagaimana kami memilih basis komponen untuk rumah pintar: tentang sensor dan pengontrol</a></li>
<li><a href="../id472432/index.html">Python 3.8: Apa yang Baru dan Cara Menggunakannya?</a></li>
<li><a href="../id472434/index.html">Tingkatkan rilis Anda</a></li>
<li><a href="../id472438/index.html">Bagaimana proxy digunakan dalam keamanan informasi: 6 kasus penggunaan praktis</a></li>
<li><a href="../id472440/index.html">Suatu hari di Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>