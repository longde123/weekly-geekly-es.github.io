<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ“ Multimodularitas dan Belati 2. Kuliah Yandex ğŸšº ğŸ˜ª ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika aplikasi Anda dibangun pada arsitektur multi-modul, Anda harus mencurahkan banyak waktu untuk memastikan bahwa semua komunikasi antara modul di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multimodularitas dan Belati 2. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/419295/">  Ketika aplikasi Anda dibangun pada arsitektur multi-modul, Anda harus mencurahkan banyak waktu untuk memastikan bahwa semua komunikasi antara modul ditulis dengan benar dalam kode.  Setengah dari pekerjaan ini dapat dipercayakan pada kerangka Dagger 2. Kepala grup Yandex.Map untuk Android Vladimir Tagakov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Noxa</a> berbicara tentang pro dan kontra multi- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">modularitas</a> dan pengaturan modul DI yang nyaman dengan menggunakan Dagger 2. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pMEAD6jjbaI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Nama saya Vladimir, saya sedang mengembangkan Yandex.Maps dan hari ini saya akan memberi tahu Anda tentang modularitas dan belati kedua. <a name="habracut"></a><br><br>  Saya mengerti bagian terpanjang ketika saya mempelajarinya sendiri, yang tercepat.  Bagian kedua, di mana saya duduk selama beberapa minggu, saya akan memberitahu Anda dengan sangat cepat dan ringkas. <br><br><img src="https://habrastorage.org/webt/t5/2r/s5/t52rs5gcestw_7jvexuardxaaus.jpeg"><br><br>  Mengapa kami memulai proses yang sulit untuk membagi ke dalam modul di Maps?  Kami hanya ingin meningkatkan kecepatan build, semua orang tahu tentang itu. <br><br>  Poin kedua dari tujuannya adalah untuk mengurangi kait kode.  Saya mengambil perlengkapan dari Wikipedia.  Ini berarti bahwa kami ingin mengurangi interkoneksi antar modul sehingga modul terpisah dan dapat digunakan di luar aplikasi.  Pernyataan awal masalah: proyek Yandex lainnya harus dapat menggunakan bagian dari fungsi Maps persis seperti yang kita lakukan.  Dan untuk mengembangkan fungsi ini, kami terlibat dalam pengembangan proyek. <br><br>  Saya ingin melempar sandal yang terbakar ke arah [k] apt, yang memperlambat kecepatan perakitan.  Aku tidak membencinya, tapi aku sangat mencintainya.  Dia mengizinkan saya menggunakan Belati. <br><br><img src="https://habrastorage.org/webt/9c/bz/iv/9cbzivba2osslltalebrdwqfsre.jpeg"><br><br>  Kelemahan utama dari proses pemisahan modul adalah, secara paradoksal, penurunan kecepatan perakitan.  Terutama di awal, ketika Anda mengeluarkan dua modul pertama, Umum dan beberapa fitur Anda, kecepatan build keseluruhan proyek menurun, tidak peduli bagaimana Anda mencoba.  Pada akhirnya, karena semakin sedikit kode yang tersisa di modul utama Anda, kecepatan build akan meningkat.  Dan tetap saja, ini tidak berarti bahwa semuanya sangat buruk, ada cara untuk menyiasatinya dan bahkan mendapat untung dari modul pertama. <br><br>  Kelemahan kedua adalah sulitnya memisahkan kode menjadi modul.  Siapa yang mencoba, tahu bahwa Anda mulai menarik semacam dependensi, beberapa klasik, dan semuanya berakhir ketika Anda menyalin seluruh modul utama Anda ke modul lain dan memulai dari awal.  Karena itu, Anda perlu memahami dengan jelas saat ketika Anda perlu menghentikan dan memutuskan koneksi menggunakan semacam abstraksi.  Kerugiannya adalah lebih banyak abstraksi.  Lebih banyak abstraksi - desain yang lebih kompleks - lebih banyak abstraksi. <br><br>  Sulit untuk menambahkan modul Gradle baru.  Mengapa  Misalnya, seorang pengembang datang, mengambil fitur baru dalam pengembangan, segera melakukannya dengan baik, membuat modul terpisah.  Apa masalahnya?  Dia harus mengingat semua kode yang tersedia, yang ada di modul utama, sehingga, jika ada, menggunakannya kembali dan memasukkannya ke Common.  Karena proses mengeluarkan beberapa modul di Common adalah konstan sampai modul App utama Anda berubah menjadi lapisan tipis. <br><br>  Modul, modul, modul ... Modul gradasi, modul belati, modul antarmuka mengerikan. <br><br><img src="https://habrastorage.org/webt/2b/nj/x2/2bnjx25ooi8xw2exdinm5yfmmys.jpeg"><br><br>  Laporan ini akan terdiri dari tiga bagian: kecil, besar dan kompleks.  Pertama, perbedaan antara Implementasi dan API di AGP.  Android Gradle Plugin 3.0 telah muncul relatif baru-baru ini.  Bagaimana segalanya sebelum dia? <br><br><img src="https://habrastorage.org/webt/qc/oa/fw/qcoafwzux6royjdv11tr0sqvmug.jpeg"><br><br>  Berikut ini adalah proyek khas pengembang yang sehat, yang terdiri dari tiga modul: modul Aplikasi, yang merupakan modul utama, dirakit dan diinstal dalam aplikasi, dan dua modul Fitur. <br><br>  Segera bicarakan panah.  Ini adalah rasa sakit yang besar, semua orang menarik ke arah yang nyaman baginya untuk menggambar.  Bagi saya maksud mereka bahwa dari Core ada panah ke Fitur.  Jadi, Fitur tahu tentang Core, bisa menggunakan kelas dari Core.  Seperti yang Anda lihat, tidak ada panah antara Core dan App, yang berarti App tampaknya tidak menggunakan Core.  Core bukan modul umum, itu adalah, semua orang bergantung padanya, itu terpisah, ada sedikit kode di dalamnya.  Meskipun kami tidak akan mempertimbangkannya. <br><br>  Modul inti kami telah berubah, kami harus mengulanginya entah bagaimana.  Kami mengubah kode di dalamnya.  Warna kuning - perubahan kode. <br><br><img src="https://habrastorage.org/webt/l4/b1/5w/l4b15wdqsgukdttudzee9vbxne0.jpeg"><br><br>  Setelah memasang kembali proyek.  Jelas bahwa setelah mengubah modul, modul harus dibangun kembali, dikompilasi ulang.  Baiklah <br><br><img src="https://habrastorage.org/webt/_q/jo/mh/_qjomhp4-vkpioy_0ai112zuam0.jpeg"><br><br>  Setelah modul Fitur juga dirakit, yang tergantung padanya.  Jelas juga, ketergantungannya telah dipasang kembali, dan Anda perlu memperbarui diri.  Siapa tahu apa yang berubah di sana. <br><br>  Dan di sini hal yang paling tidak menyenangkan terjadi.  Modul Aplikasi berjalan, meskipun tidak jelas mengapa.  Saya tahu pasti bahwa saya tidak menggunakan Core dengan cara apa pun, dan mengapa Aplikasi sedang dibangun tidak jelas.  Dan dia sangat besar, karena pada awal jalan, dan ini adalah rasa sakit yang sangat besar. <br><br><img src="https://habrastorage.org/webt/hu/j8/la/huj8larhnqmhr6dq7qhp2etnkc8.jpeg"><br><br>  Selain itu, jika beberapa fitur, banyak modul bergantung pada Core, maka seluruh dunia akan dipasang kembali, itu membutuhkan waktu yang sangat lama. <br><br>  Mari tingkatkan ke AGP versi baru dan ganti, seperti yang dikatakan manual, semua kompilasi dengan API, dan bukan dengan Implementasi, seperti yang Anda pikirkan.  Tidak ada yang berubah.  Skema itu identik.  Apa cara baru dalam menentukan dependensi Implementasi?  Bayangkan skema yang sama hanya menggunakan kata kunci ini, tanpa API?  Ini akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/nj/ns/fg/njnsfgghg9om12lpwlu5yh21hmu.jpeg"><br><br>  Di sini dalam implementasinya, terlihat jelas bahwa ada koneksi antara Core dan App.  Di sini kita dapat dengan jelas memahami bahwa kita tidak membutuhkannya, kita ingin menyingkirkannya, jadi hapus saja.  Segalanya menjadi lebih mudah. <br><br><img src="https://habrastorage.org/webt/rp/lx/xr/rplxxrfrsee28vucqevngre8xq4.jpeg"><br><br>  Sekarang hampir semuanya baik, bahkan lebih dari itu.  Jika kami mengubah beberapa API di Core, tambahkan kelas baru, metode publik atau paket pribadi baru, maka Core dan Fitur akan dibangun kembali.  Jika Anda mengubah implementasi di dalam metode atau menambahkan metode pribadi, maka secara teoritis membangun kembali Fitur tidak boleh terjadi sama sekali, karena tidak ada yang berubah. <br><br><img src="https://habrastorage.org/webt/mk/ub/1e/mkub1ect0enydqitlermncinoyk.jpeg"><br><br>  Mari kita melangkah lebih jauh.  Kebetulan banyak yang bergantung pada Core kami.  Core mungkin semacam jaringan atau pemrosesan data pengguna.  Karena ini adalah Network, semuanya berubah cukup sering, semuanya dibangun kembali, dan kami mendapat rasa sakit yang sama dari mana kami dengan hati-hati melarikan diri. <br>  Mari kita lihat dua cara untuk mengatasi ini. <br><br><img src="https://habrastorage.org/webt/um/_d/c-/um_dc-9rumfh-vyvlqdavr6zvgg.jpeg"><br><br>  Kami hanya dapat mentransfer API dari modul Core kami ke modul terpisah, API-nya, yang kami gunakan.  Dan dalam modul terpisah kita dapat mengambil implementasi antarmuka ini. <br><br><img src="https://habrastorage.org/webt/eu/o8/0-/euo80-48enzm_rvppcwmb1qbjca.jpeg"><br><br>  Anda dapat melihat koneksi di layar.  Implan Inti tidak akan tersedia untuk fitur.  Artinya, tidak akan ada koneksi antara fitur dan implementasi Core.  Dan modul, yang disorot dengan warna kuning, hanya akan menyediakan pabrik yang akan menyediakan semacam implementasi antarmuka Anda yang tidak diketahui siapa pun. <br><br>  Setelah konversi seperti itu, saya ingin menarik perhatian pada fakta bahwa API Inti, karena fakta bahwa kata kunci API berdiri, akan tersedia untuk semua fitur secara transitif. <br><br><img src="https://habrastorage.org/webt/7a/lq/iu/7alqiukvhfpie8_olsuekuczfgi.jpeg"><br><br>  Setelah transformasi ini, kami mengubah sesuatu dalam implementasi yang paling sering Anda lakukan, dan hanya modul dengan pabrik yang akan dibangun kembali, ini sangat ringan, kecil, Anda bahkan tidak perlu mempertimbangkan berapa lama. <br><br><img src="https://habrastorage.org/webt/8p/ri/ah/8priahixb3prj9of3cqpzqjxaeg.jpeg"><br><br>  Pilihan lain tidak selalu berhasil.  Sebagai contoh, jika ini semacam Jaringan, maka saya hampir tidak bisa membayangkan bagaimana ini bisa terjadi, tetapi jika ini adalah semacam layar login pengguna, maka mungkin saja. <br><br><img src="https://habrastorage.org/webt/eu/rf/cs/eurfcs3tlrk9jasm6fqphr5lb4y.jpeg"><br><br>  Kita dapat membuat Sampel, modul root lengkap yang sama dengan App, dan hanya mengumpulkan satu fitur di dalamnya, itu akan sangat cepat, dan dapat dikembangkan dengan cepat secara iteratif.  Di akhir presentasi, saya akan menunjukkan kepada Anda berapa lama untuk membangun dan membangun sampel. <br><br>  Dengan bagian pertama selesai.  Modul apa yang ada? <br><br><img src="https://habrastorage.org/webt/sv/jm/xk/svjmxkqxazeydcsinvypfuh_-24.jpeg"><br><br>  Ada tiga jenis modul.  Biasa, tentu saja, harus seringan mungkin, dan seharusnya tidak mengandung fitur apa pun, tetapi hanya fungsionalitas yang digunakan oleh semua orang.  Bagi kami di tim kami ini sangat penting.  Jika kami menyediakan modul Fitur kami ke aplikasi lain, kami akan memaksa mereka untuk menyeret Common dalam keadaan apa pun.  Jika dia sangat gemuk, maka tidak ada yang akan mencintai kita. <br><br><img src="https://habrastorage.org/webt/bd/n-/1s/bdn-1si0fx1fxre86gldhgepx34.jpeg"><br><br>  Jika Anda memiliki proyek yang lebih kecil, maka dengan Common Anda dapat merasa lebih santai, maka Anda juga tidak harus sangat bersemangat. <br><br><img src="https://habrastorage.org/webt/ah/jj/fi/ahjjfiyfzltnadyswlalhsoeh-u.jpeg"><br><br>  Jenis modul berikutnya adalah Standalone.  Modul paling umum dan intuitif yang berisi fitur tertentu: semacam layar, semacam skrip pengguna, dan sebagainya.  Itu harus independen mungkin, dan untuk itu paling sering Anda dapat membuat Aplikasi sampel dan mengembangkannya di dalamnya.  Aplikasi Sampel sangat penting pada awal proses pemisahan, karena semuanya masih berjalan lambat, dan Anda ingin mendapatkan keuntungan secepat mungkin.  Pada akhirnya, ketika semuanya dipukuli menjadi modul, Anda dapat membangun kembali semuanya, itu akan cepat.  Karena itu tidak akan dibangun kembali. <br><br><img src="https://habrastorage.org/webt/sz/la/p5/szlap5ot3jnjdtvsj5roegwlboy.jpeg"><br><br>  Modul selebriti.  Saya sendiri datang dengan kata itu.  Intinya dia sangat terkenal untuk semua orang, dan banyak yang bergantung padanya.  Jaringan yang sama.  Saya sudah mengatakan, jika Anda sering memasang kembali, bagaimana Anda bisa menghindari kenyataan bahwa semuanya dipasang kembali dari Anda.  Ada cara lain yang dapat digunakan untuk proyek-proyek kecil yang tidak sepadan dengan tujuan memberikan semuanya sebagai kecanduan yang terpisah, artefak yang terpisah. <br><br><img src="https://habrastorage.org/webt/pk/yq/u8/pkyqu8xflbfu40ufwly3wr4rgzi.jpeg"><br><br>  Seperti apa bentuknya?  Kami ulangi yang mengeluarkan API dari Selebriti, menghapus implementasinya, dan sekarang perhatikan tangan Anda, perhatikan panah dari Fitur hingga Selebriti.  Ini sedang terjadi  API modul Anda jatuh ke Common, implementasinya tetap di dalamnya, dan pabrik yang menyediakan implementasi API ini muncul di modul utama Anda.  Jika seseorang menyaksikan Mobius, maka Denis Neklyudov membicarakannya.  Skema yang sangat mirip. <br><br>  Kami menggunakan Dagger dalam proyek ini, kami menyukainya, dan kami ingin mendapatkan hasil maksimal dari manfaat ini dalam konteks modul yang berbeda. <br><br><img src="https://habrastorage.org/webt/kr/ak/xu/krakxunqnjjjoinel9yk0sfbemc.jpeg"><br><br>  Kami ingin setiap modul memiliki grafik dependensi independen, untuk memiliki komponen root spesifik dari mana Anda dapat melakukan apa saja, kami ingin memiliki kode yang kami buat sendiri untuk setiap modul Gradle.  Kami tidak ingin kode yang dihasilkan masuk ke kode utama.  Kami ingin sebanyak mungkin validasi waktu kompilasi.  Kami menderita [k] apt, setidaknya kami harus mendapatkan keuntungan dari apa yang diberikan belati.  Dan dengan semua ini, kami tidak ingin memaksa siapa pun untuk menggunakan Belati.  Baik orang yang mengimplementasikan modul fitur baru secara terpisah, maupun orang yang kemudian mengkonsumsinya, adalah kolega kami yang meminta beberapa fitur untuk diri mereka sendiri. <br><br>  Bagaimana cara mengatur grafik ketergantungan yang terpisah di dalam modul fitur kami? <br><br><img src="https://habrastorage.org/webt/9p/-u/im/9p-uimpq3hakpiwmedw-kinrsai.jpeg"><br><br>  Anda dapat mencoba menggunakan Subkomponen, dan itu bahkan akan berfungsi.  Tetapi ini memiliki beberapa kekurangan.  Anda dapat melihat bahwa dalam Subkomponen tidak jelas dependensi mana yang digunakannya dari Komponen.  Untuk memahami ini, Anda harus merakit ulang proyek dengan panjang dan menyakitkan, lihat apa yang Dagger sumpah dan tambahkan. <br>  Selain itu, subkomponen diatur sedemikian rupa sehingga mereka memaksa orang lain untuk menggunakan Belati, dan itu tidak akan berhasil dengan mudah untuk klien Anda dan diri Anda sendiri jika Anda memutuskan untuk menolak dalam beberapa modul. <br><br><img src="https://habrastorage.org/webt/d3/wz/vj/d3wzvj5_hjyy31e9rl-6hlo36ck.jpeg"><br><br>  Salah satu hal yang paling menjijikkan adalah ketika menggunakan Subkomponen, semua dependensi ditarik ke modul utama.  Belati dirancang sedemikian rupa sehingga subkomponen dihasilkan oleh kelas tertanam dari komponen pembingkaiannya, induknya.  Mungkin seseorang melihat kode yang dihasilkan dan ukurannya pada komponen yang dihasilkan?  Kami memiliki 20 ribu baris di dalamnya.  Karena subkomponen selalu bersarang kelas untuk komponen, ternyata subkomponen dari subkomponen juga bersarang, dan semua kode yang dihasilkan jatuh ke modul utama, file dua puluh baris ini yang perlu dikompilasi dan perlu di refactored, Studio mulai melambat - sakit. <br><br>  Tapi ada solusinya.  Anda dapat menggunakan hanya Komponen. <br><br><img src="https://habrastorage.org/webt/dr/1b/lc/dr1blc8pj2qzzhxs3pnnu7lbqui.jpeg"><br><br>  Dalam belati, komponen dapat menentukan dependensi.  Ini ditunjukkan dalam kode, dan ditunjukkan dalam gambar.  Ketergantungan tempat Anda menentukan metode Penyediaan, metode pabrik yang menunjukkan entitas mana yang menjadi tempat bergantung komponen Anda.  Dia menginginkan mereka pada saat penciptaan. <br>  Sebelumnya, saya selalu berpikir bahwa hanya komponen lain yang dapat ditentukan dalam dependensi ini, dan itulah sebabnya - dokumentasi mengatakan demikian. <br><br><img src="https://habrastorage.org/webt/gk/us/45/gkus45n1uhs0jhqjojmciaa3y48.jpeg"><br><br>  Sekarang saya mengerti apa artinya menggunakan antarmuka komponen, tetapi sebelum saya pikir itu hanya komponen.  Bahkan, Anda perlu menggunakan antarmuka yang disusun sesuai dengan aturan untuk membuat antarmuka untuk komponen.  Singkatnya, cukup metode Penyediaan, ketika Anda hanya memiliki getter untuk beberapa jenis dependensi.  Anda juga dapat menemukan kode sampel dalam dokumentasi Belati. <br><br><img src="https://habrastorage.org/webt/ry/jo/63/ryjo63y8bfqo1a5kfkgeff4iv10.jpeg"><br><br>  Komponen OtherComponent juga ditulis di sana, dan ini membingungkan, karena pada kenyataannya, Anda tidak bisa hanya memasukkan komponen di sana. <br><br>  Bagaimana kita ingin menggunakan bisnis ini dalam kenyataan? <br><br><img src="https://habrastorage.org/webt/sy/v1/r_/syv1r_5jzsr7i8vkniesru582gg.jpeg"><br><br>  Pada kenyataannya, ada modul Fitur, ia memiliki paket API yang terlihat, terletak dekat dengan akar semua paket, dan dikatakan ada titik masuk - FeatureActivity.  Tidak perlu menggunakan typealias, hanya untuk membuatnya jelas.  Ini bisa berupa fragmen, bisa berupa ViewController - tidak masalah.  Dan ada dependensinya, FeatureDeps, di mana diindikasikan bahwa ia membutuhkan konteks, beberapa layanan Jaringan, dari Common beberapa hal yang ingin Anda dapatkan dari App, dan setiap klien berkewajiban untuk memenuhi ini.  Ketika dia melakukannya, semuanya akan bekerja. <br><br><img src="https://habrastorage.org/webt/tu/rl/yk/turlykyi-zrmheakatdmpasqqr4.jpeg"><br><br>  Bagaimana kita menggunakan semua ini dalam modul Fitur?  Di sini saya menggunakan Activity, ini opsional.  Seperti biasa, kami membuat komponen Root Dagger kami sendiri dan menggunakan metode magic findComponentDependencies, sangat mirip dengan Dagger untuk Android, tetapi kami tidak dapat menggunakannya terutama karena kami tidak ingin menyeret subkomponen.  Kalau tidak, kita bisa mengambil semua logika dari mereka. <br><br>  Pada awalnya saya mencoba untuk mengetahui cara kerjanya, tetapi Anda dapat melihatnya di proyek sampel pada hari Jumat.  Bagaimana ini harus digunakan oleh klien perpustakaan Anda di modul utama Anda? <br><br><img src="https://habrastorage.org/webt/ui/nk/mj/uinkmj6kxqhr3218cfbo_y8v9uk.jpeg"><br><br>  Pertama-tama, itu hanya typealias.  Sebenarnya, ia memiliki nama yang berbeda, tetapi untuk singkatnya.  Kelas antarmuka MapOfDepth by Dependency memberi Anda implementasinya.  Di App, kami mengatakan bahwa kami dapat membuat dependensi dengan cara yang sama seperti di Dagger untuk Android, dan sangat penting bahwa komponen mewarisi antarmuka ini dan secara otomatis menerima metode Provision.  Belati mulai saat ini mulai memaksa kita untuk memberikan ketergantungan ini.  Sampai Anda memberikannya, itu tidak akan dikompilasi.  Ini adalah kenyamanan utama: Anda memutuskan untuk mengatur fitur, memperluas komponen Anda dengan antarmuka ini - semuanya sampai Anda melakukan sisanya, tidak hanya mengkompilasi, tetapi akan menghasilkan pesan kesalahan yang jelas.  Modul ini sederhana, intinya adalah bahwa ia mengikat komponen Anda ke implementasi antarmuka.  Kira-kira sama dengan di Dagger untuk Android. <br><br>  Mari beralih ke hasil. <br><br><img src="https://habrastorage.org/webt/hs/gv/0o/hsgv0oyk_v-jbzjk8lono2uepju.jpeg"><br><br>  Saya memeriksa mainframe kami dan laptop lokal saya, sebelum itu saya mematikan semua yang mungkin terjadi.  Jika kita menambahkan metode publik ke Fitur, maka waktu pembuatannya sangat berbeda.  Di sini saya menunjukkan perbedaan ketika saya sedang membangun proyek sampel.  Ini 16 detik.  Atau ketika saya mengumpulkan semua kartu - itu berarti dua menit untuk duduk dan menunggu setiap, bahkan perubahan minimal.  Oleh karena itu, banyak fitur yang kami kembangkan dan akan kami kembangkan dalam proyek sampel.  Pada mainframe, waktunya sebanding. <br><br><img src="https://habrastorage.org/webt/ey/ou/va/eyouvaxzp3kw8cl0eb3jznokvpe.jpeg"><br><br>  Hasil penting lainnya.  Sebelum menyoroti modul Fitur, tampilannya seperti ini: pada mainframe itu 28 detik, sekarang 49 detik.  Kami telah mengalokasikan modul pertama, dan sudah menerima perlambatan perakitan hampir dua kali. <br><br><img src="https://habrastorage.org/webt/f2/px/_o/f2px_oqd8uktolgh3-f2ae8j6to.jpeg"><br><br>  Dan opsi lain adalah perakitan tambahan sederhana dari modul kami, bukan fitur, seperti pada yang sebelumnya.  28 detik sampai modul dialokasikan.  Ketika kami mengalokasikan kode yang tidak perlu dibangun kembali setiap kali, dan [k] apt, yang tidak perlu dilakukan setiap kali, kami memenangkan tiga detik.  Tuhan tahu apa, tetapi saya berharap bahwa dengan setiap modul baru, waktu hanya akan berkurang. <br><br>  Berikut ini tautan yang bermanfaat untuk artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API versus implementasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel dengan pengukuran waktu pembuatan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul sampel</a> .  Presentasi akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia</a> .  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419295/">https://habr.com/ru/post/id419295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419279/index.html">Intisari materi menarik untuk pengembang seluler # 264 (30 Juli - 5 Agustus)</a></li>
<li><a href="../id419281/index.html">rcm - rc-file manager: tuning dan gunakan</a></li>
<li><a href="../id419283/index.html">Bezos melempar uang dan insinyur untuk mengembangkan roket sehubungan dengan percepatan perlombaan ruang angkasa</a></li>
<li><a href="../id419289/index.html">Dengar dan bicara: Pengumuman HolyJS 2018 Moskow</a></li>
<li><a href="../id419291/index.html">Pengumuman Heisenbug 2018 Moskow: jawaban untuk semua pertanyaan</a></li>
<li><a href="../id419297/index.html">Melihat komentar tentang HabrÃ© dalam urutan penambahan</a></li>
<li><a href="../id419299/index.html">Lampu pintar yang menunjukkan suasana di kota Anda</a></li>
<li><a href="../id419303/index.html">Laporan Tesla menunjukkan kerugian dan pendapatan yang lebih tinggi dari yang diharapkan investor</a></li>
<li><a href="../id419305/index.html">Spy Toy or Find: Mesin Tik Barbie â„¢</a></li>
<li><a href="../id419307/index.html">Roskomnadzor menaruh minat pada koneksi bisnis Facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>