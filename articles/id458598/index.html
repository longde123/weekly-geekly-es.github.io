<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏽 👇🏼 👨‍👩‍👧 Pengakuan sumber cahaya pada peta lingkungan 👱🏿 🚆 🔋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menyajikan implementasi algoritma Python untuk mengenali sumber cahaya pada peta lingkungan (LDR atau HDR) menggunakan proyeksi equirectan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengakuan sumber cahaya pada peta lingkungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458598/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png" alt="gambar"></div><br>  Artikel ini menyajikan implementasi algoritma Python untuk mengenali sumber cahaya pada peta lingkungan (LDR atau HDR) menggunakan proyeksi equirectangular.  Namun, setelah melakukan perubahan kecil, itu juga dapat digunakan dengan gambar latar belakang sederhana atau peta kubik.  Contoh penerapan algoritma yang mungkin: program penelusuran sinar di mana diperlukan untuk mengenali sumber cahaya primer agar dapat memancarkan sinar darinya;  pada penyaji raster, ini dapat digunakan untuk melemparkan bayangan menggunakan peta lingkungan;  selain itu, algoritme juga dapat digunakan dalam program penghapusan sorotan, misalnya dalam AR. <br><br>  Algoritme terdiri dari langkah-langkah berikut: <br><br><ol><li>  Penurunan resolusi gambar asli, misalnya, ke 1024. </li><li>  Konversikan gambar menjadi kecerahan (luminance), jika perlu, dengan gambar buram. </li><li>  Penerapan metode quasi-Monte Carlo. </li><li>  Transformasi dari koordinat bola ke koordinat yang sama. </li><li>  Memfilter sampel berdasarkan kecerahan tetangga. </li><li>  Sortir sampel berdasarkan kecerahannya. </li><li>  Memfilter sampel berdasarkan metrik Euclidean. </li><li>  Menggabungkan sampel menggunakan algoritma Bresenham. </li><li>  Perhitungan posisi cluster pencahayaan berdasarkan kecerahannya. </li></ol><br>  Ada banyak algoritma untuk mengurangi resolusi gambar.  Pemfilteran bilinear adalah yang tercepat atau termudah untuk diimplementasikan, dan selain itu, paling cocok dalam banyak kasus.  Untuk mengonversi kecerahan di gambar LDR dan HDR, Anda dapat menggunakan rumus standar: <br><br><pre><code class="python hljs">lum = img[:, :, <span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">0.2126</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">0.7152</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">0.0722</span></span></code> </pre> <br>  Selain itu, Anda dapat menerapkan sedikit kekaburan pada gambar kecerahan, misalnya, 1-2 piksel untuk gambar dengan resolusi 1024, untuk menghilangkan semua detail frekuensi tinggi (khususnya, yang disebabkan oleh penurunan resolusi). <br><a name="habracut"></a><br><h3>  Proyeksi yang Sama </h3><br>  Proyeksi yang paling umum di peta lingkungan adalah proyeksi yang sama rata <sup>3</sup> .  Algoritme saya dapat bekerja dengan proyeksi lain, misalnya, dengan panorama dan peta kubik, namun, dalam artikel ini kami hanya akan mempertimbangkan proyeksi dengan jarak yang sama.  Pertama, Anda perlu menormalkan koordinat gambar: <br><br><pre> <code class="python hljs">pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = x / width pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = y / height</code> </pre> <br>  Maka kita perlu mengkonversi dari dan ke koordinat Cartesian menggunakan koordinat bola, mis.  θ dan φ, di mana θ = x * 2π, dan φ = y * π. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereToEquirectangular</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> invAngles = (<span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) xy = (math.atan2(pos[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos[<span class="hljs-number"><span class="hljs-number">0</span></span>]), math.asin(pos[<span class="hljs-number"><span class="hljs-number">2</span></span>])) xy = (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">0</span></span>], xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equirectangularToSphere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> angles = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) thetaPhi = (pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) thetaPhi = (thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">0</span></span>], thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) length = math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><h3>  Hammersley Sampling </h3><br>  Langkah selanjutnya adalah menerapkan metode quasi-Monte Carlo, misalnya, sampel Hammersley <sup>2</sup> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f9/b07/70f/4f9b0770f72e69ede59e56a25258343d.png"></div><br>  Anda dapat menggunakan metode pengambilan sampel lainnya, seperti Holton <sup>4</sup> , tetapi Hammersley lebih cepat dan memberikan distribusi sampel yang baik di seluruh bidang.  Holton akan menjadi pilihan yang baik untuk sampel bidang jika gambar sederhana digunakan sebagai pengganti peta lingkungan.  Persyaratan wajib untuk pengambilan sampel Hammersley adalah pembalikan akar (baris) van der Corpute, untuk lebih jelasnya lihat tautan <sup>2</sup> .  Berikut ini adalah implementasinya yang cepat: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vdcSequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> bits = (bits &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (bits &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xAAAAAAAA</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xCCCCCCCC</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xF0F0F0F0</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float(bits) * <span class="hljs-number"><span class="hljs-number">2.3283064365386963e-10</span></span> <span class="hljs-comment"><span class="hljs-comment"># / 0x100000000 def hammersleySequence(i, N): return (float(i) / float(N), vdcSequence(i))</span></span></code> </pre> <br>  Lalu kami menggunakan overlay seragam di bola: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span> phi = v * <span class="hljs-number"><span class="hljs-number">2.0</span></span> * PI cosTheta = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * u - <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment"># map to -1,1 sinTheta = math.sqrt(1.0 - cosTheta * cosTheta); return (math.cos(phi) * sinTheta, math.sin(phi) * sinTheta, cosTheta)</span></span></code> </pre> <br>  Untuk mengambil sampel Hammersley, kami menggunakan jumlah sampel tetap, tergantung pada resolusi gambar, dan mengkonversi dari koordinat bola ke Cartesian, dan kemudian ke jarak yang sama: <br><br><pre> <code class="python hljs"> samplesMultiplier = <span class="hljs-number"><span class="hljs-number">0.006</span></span> samples = int(samplesMultiplier * width * height) samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos[0] * width, imagePos[1] * height]</span></span></code> </pre> <br>  Ini akan memberi kami distribusi sampel yang baik yang akan diperiksa keberadaan sumber cahaya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/0a6/470/aa80a64703ef6e38cd0b73f9b02a5852.png"></div><br><h3>  Memfilter sumber cahaya </h3><br>  Pada penyaringan pertama, kami mengabaikan semua sampel yang tidak melebihi ambang kecerahan (untuk kartu HDR, mungkin lebih tinggi), dan kemudian mengurutkan semua sampel berdasarkan kecerahannya: <br><br><pre> <code class="python hljs"> localSize = int(float(<span class="hljs-number"><span class="hljs-number">12</span></span>) * (width / <span class="hljs-number"><span class="hljs-number">1024.0</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span> samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos [0] * width, imagePos [1] * height] sample = Sample(luminance, imagePos , xyz) luminanceThreshold = 0.8 #do a neighbour search for the maximum luminance nLum = computeNeighborLuminance(lum, width, height, sample.imagePos, localSize) if nLum &gt; luminanceThreshold: samplesList.append(sample) samplesList = sorted(samplesList, key=lambda obj: obj.luminance, reverse=True)</span></span></code> </pre> <br>  Lulus berikutnya akan melakukan penyaringan berdasarkan metrik Euclidean dan jarak ambang antara piksel (tergantung pada resolusi gambar) - ini adalah struktur data spasial yang dapat digunakan untuk menghilangkan kompleksitas O (N <sup>2</sup> ): <br><br><pre> <code class="python hljs"> euclideanThreshold = int(float(euclideanThresholdPixel) * (width / <span class="hljs-number"><span class="hljs-number">2048.0</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># filter based euclidian distance filteredCount = len(samplesList) localIndices = np.empty(filteredCount); localIndices.fill(-1) for i in range(0, filteredCount): cpos = samplesList[i].pos if localIndices[i] == -1: localIndices[i] = i for j in range(0, filteredCount): if i != j and localIndices[j] == -1 and distance2d(cpos, samplesList[j].pos) &lt; euclideanThreshold: localIndices[j] = i</span></span></code> </pre> <br>  Sampel yang dihasilkan melewati tahap penggabungan untuk lebih mengurangi jumlah sumber cahaya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/152/e1e/d39152e1e587c40c3ed29888faf02120.png"></div><br><h3>  Menggabungkan sumber cahaya </h3><br>  Pada tahap terakhir, penggabungan sampel milik cluster pencahayaan yang sama dilakukan.  Untuk melakukan ini, kita dapat menggunakan algoritma Bresenham dan mulai dengan sampel dengan kecerahan tertinggi, karena sudah dipesan.  Ketika kami menemukan sumber cahaya yang memenuhi tes Bresenham, kami menggunakan posisinya untuk mengubah posisi sumber berdasarkan pada bobot pelarian: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># apply bresenham check and compute position of the light clusters lights = [] finalIndices = np.empty(filteredCount); finalIndices.fill(-1) for i in localIndices: sample = samplesList[i] startPos = sample.pos if finalIndices[i] == -1: finalIndices[i] = i light = Light() light.originalPos = np.array(sample.pos) # position of the local maxima light.worldPos = np.array(sample.worldPos) light.pos = np.array(sample.pos) light.luminance = sample.luminance for j in localIndices: if i != j and finalIndices[j] == -1: endPos = samplesList[j].pos if bresenhamCheck(lum, width, height, startPos[0], startPos[1], endPos[0], endPos[1]): finalIndices[j] = i # compute final position of the light source sampleWeight = samplesList[j].luminance / sample.luminance light.pos = light.pos + np.array(endPos) * sampleWeight light.pos = light.pos / (1.0 + sampleWeight) imagePos = light.pos * np.array([1.0 / width, 1.0 / height) light.worldPos = equirectangularToSphere(imagePos) lights.append(light)</span></span></code> </pre> <br>  Fungsi Bresenham memeriksa garis kontinu yang memiliki kecerahan yang sama.  Jika delta dalam piksel saat ini melebihi batas tertentu, maka pemeriksaan gagal: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bresenhamCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lum, imageSize, x0, y0, x1, y1)</span></span></span><span class="hljs-function">:</span></span> dX = int(x1 - x0) stepX = int((dX &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dX = abs(dX) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> dY = int(y1 - y0) stepY = int((dY &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dY = abs(dY) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> luminanceThreshold = <span class="hljs-number"><span class="hljs-number">0.15</span></span> prevLum = lum[x0][y0] sumLum = <span class="hljs-number"><span class="hljs-number">0.0</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt;= dY): <span class="hljs-comment"><span class="hljs-comment"># delta may go below zero delta = int (dY - (dX &gt;&gt; 1)) while (x0 != x1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepX &gt; 0))): delta -= dX y0 += stepY delta += dY x0 += stepX sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 else: # delta may go below zero delta = int(dX - (dY &gt;&gt; 1)) while (y0 != y1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepY &gt; 0))): delta -= dY x0 += stepX delta += dX y0 += stepY sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 return 1</span></span></code> </pre> <br>  Perlu dicatat bahwa, jika perlu, perbaikan dapat dilakukan pada uji Bresenham, yang akan mengarah pada penggabungan sampel yang lebih baik, misalnya, dapat memperhitungkan transfer horizontal sumber cahaya yang terletak di tepi gambar.  Selain itu, fungsinya dapat dengan mudah diperluas sehingga mendekati area sumber cahaya.  Peningkatan lainnya: Anda bisa menambahkan ambang jarak sehingga Anda tidak menggabungkan sampel yang terlalu jauh.  Hasil akhir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/4a8/fd9/4224a8fd98cec4203235bb4678ee6826.png"></div><br>  Biru menunjukkan maksimum lokal dari cluster pencahayaan, biru menunjukkan posisi akhir sumber cahaya, dan merah menunjukkan sampel yang merupakan bagian dari cluster pencahayaan yang sama dan dihubungkan oleh garis. <br><br>  Contoh hasil lainnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png"></div><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deteksi sumber cahaya dalam foto digital oleh Maciej Laskowski</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Poin Hammersley di Belahan Bumi oleh Holger Dammertz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyeksi Equirectangular oleh Paul Reed</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sampling dengan Poin Hammersley dan Halton oleh Tien-Tsin Wong</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458598/">https://habr.com/ru/post/id458598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458582/index.html">Insinyur Amazon telah menciptakan perangkat pemblokiran AI yang menjaga kucing keluar dari jalan</a></li>
<li><a href="../id458584/index.html">11 Juli, Group-IB Webinar “Analisis Malware untuk Pemula: Pendekatan Dasar”</a></li>
<li><a href="../id458592/index.html">Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC</a></li>
<li><a href="../id458594/index.html">Jangan lupa untuk meningkatkan kemungkinan respons terhadap klien menggunakan permintaan berulang dalam penyeimbangan L7</a></li>
<li><a href="../id458596/index.html">Petty little joy # 6: OpenAI Gym - mainkan game dan kendalikan robot</a></li>
<li><a href="../id458602/index.html">Bagaimana kami menembus Great Chinese Firewall (Bagian 1)</a></li>
<li><a href="../id458604/index.html">Mengapa dua produsen elektronik terbesar bergabung dalam proyek GPU baru</a></li>
<li><a href="../id458606/index.html">Jalankan OpenVPN di Docker dalam 2 detik</a></li>
<li><a href="../id458608/index.html">Alat Pengembang Node.js Antrian pekerjaan</a></li>
<li><a href="../id458612/index.html">Kosmos 7 tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>