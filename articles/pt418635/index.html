<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüåæ üèë üë®üèª‚Äçüîß Criando uma m√°quina de arcade emulador. Parte 1 üêà üë©üèΩ üë¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escrever um emulador de m√°quina de arcade √© um √≥timo projeto educacional e, neste tutorial, analisaremos detalhadamente todo o processo de desenvolvim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando uma m√°quina de arcade emulador. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="imagem"></div><br>  Escrever um emulador de m√°quina de arcade √© um √≥timo projeto educacional e, neste tutorial, analisaremos detalhadamente todo o processo de desenvolvimento.  Deseja realmente colocar as m√£os no processador?  Em seguida, criar um emulador √© a melhor maneira de aprend√™-lo. <br><br>  Voc√™ precisar√° de conhecimento de C, bem como de montador.  Se voc√™ n√£o conhece a linguagem assembly, escrever um emulador √© a melhor maneira de aprend√™-lo.  Voc√™ tamb√©m precisar√° dominar a matem√°tica hexadecimal (tamb√©m conhecida como base 16 ou apenas "hex").  Vou falar sobre esse t√≥pico. <br><br>  Decidi escolher um emulador para a m√°quina Space Invaders, que usa o processador 8080. Este jogo e esse processador s√£o muito populares, porque na Internet voc√™ pode encontrar muitas informa√ß√µes sobre eles.  Voc√™ precisar√° dele para concluir o projeto. <br><br>  Todo o c√≥digo fonte do tutorial √© carregado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  Se voc√™ n√£o domina o trabalho com o git, na p√°gina do github h√° um bot√£o "Download ZIP" que permite baixar o arquivo com todo o c√≥digo. <br><a name="habracut"></a><br><h1>  Introdu√ß√£o aos n√∫meros bin√°rios e hexadecimais </h1><br>  Na matem√°tica "comum", o sistema de n√∫meros decimais √© usado.  Cada d√≠gito do n√∫mero pode ter um valor de zero a nove e, quando excedermos 9, adicionamos um ao n√∫mero no pr√≥ximo d√≠gito e recome√ßamos do zero.  Tudo isso √© bastante simples e direto, e voc√™ provavelmente nunca pensou nisso. <br><br>  Voc√™ pode saber ou ouvir falar que os computadores funcionam com dados bin√°rios.  Os geeks dos computadores chamam matem√°tica decimal de base 10 e chamada bin√°ria de base 2.  Em nota√ß√£o bin√°ria, cada d√≠gito de um n√∫mero pode ter apenas dois valores, zero ou um.  No c√≥digo bin√°rio, a contagem √© a seguinte: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Esses n√£o s√£o n√∫meros decimais, portanto, voc√™ n√£o pode cham√°-los de "zero, um, dez, onze, cem, cento e um".  Eles s√£o pronunciados como "zero, um, um-zero, um-um, um-zero-zero", etc.  Eu raramente leio n√∫meros bin√°rios em voz alta, mas se necess√°rio, voc√™ precisa indicar claramente o sistema de n√∫meros usado.  Dez, onze e cem n√£o t√™m significado em nota√ß√£o bin√°ria. <br><br>  Na nota√ß√£o decimal, um n√∫mero tem os seguintes d√≠gitos: unidades, dezenas, centenas, milhares, dezenas de milhares, etc.  No sistema bin√°rio, os seguintes d√≠gitos: unidades, duques, quatros, oito, etc.  <strong>Na ci√™ncia da computa√ß√£o, o valor de cada bit bin√°rio √© chamado de bit.</strong>  <strong>8 bits comp√µem um byte.</strong> <br><br>  Em termos bin√°rios, uma s√©rie de n√∫meros rapidamente se torna muito longa.  Para representar o n√∫mero decimal 20.000 em termos bin√°rios, s√£o necess√°rios 16 d√≠gitos: 0b100111000100000.  Para corrigir esse problema, √© conveniente usar um sistema de n√∫meros hexadecimais, tamb√©m conhecido como base 16 (ou hex).  Na base 16, cada d√≠gito cont√©m 16 valores.  Para valores de zero a nove, os mesmos caracteres s√£o usados ‚Äã‚Äãna base 10, mas para os 6 valores restantes, as substitui√ß√µes s√£o usadas na forma das 6 primeiras letras do alfabeto, de A a F. <br><br>  A conta no sistema hexadecimal √© realizada da seguinte forma: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12, etc.  No hexadecimal, dezenas, centenas e assim por diante n√£o t√™m o mesmo significado que no decimal; portanto, as pessoas pronunciam n√∫meros separadamente.  Por exemplo, $ A57 √© pronunciado em voz alta como "A-cinco-sete".  Para maior clareza, voc√™ tamb√©m pode adicionar hexadecimal, por exemplo, "A-cinco-sete-hex".  No sistema num√©rico hexadecimal, o equivalente ao n√∫mero decimal 20.000 √© $ 4E20 - uma forma muito mais compacta em compara√ß√£o com 16 bits do sistema bin√°rio. <br><br>  Eu acho que o sistema hexadecimal foi escolhido devido a uma convers√£o muito natural de bin√°rio para hexadecimal e vice-versa.  Cada d√≠gito hexadecimal corresponde a 4 bits (4 bits) de um n√∫mero bin√°rio semelhante.  <strong>2 d√≠gitos hexadecimais comp√µem um byte (8 bits).</strong>  Um √∫nico d√≠gito hexadecimal pode ser chamado de nibble, e algumas pessoas at√© escrevem atrav√©s de y como "nybble". <br><br><table><tbody><tr><th colspan="4">  Cada d√≠gito hexadecimal √© de 4 d√≠gitos bin√°rios </th></tr><tr><td>  Hex </td><td>  Um </td><td>  5 </td><td>  7 </td></tr><tr><td>  Bin√°rio </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Ao escrever o c√≥digo C, acredita-se que o n√∫mero seja decimal (base 10), a menos que esteja marcado de outra forma.  Para dizer ao compilador C que o n√∫mero √© bin√°rio, adicionamos o n√∫mero zero e a letra b em letras min√∫sculas, assim: <code>0b1101101</code> .  O n√∫mero hexadecimal pode ser escrito no c√≥digo C adicionando no in√≠cio de zero <code>0xA57</code> em letras min√∫sculas: <code>0xA57</code> .  Algumas linguagens assembly usam o cifr√£o $: <code>$A57</code> para indicar um n√∫mero hexadecimal. <br><br>  Se voc√™ pensar bem, a conex√£o entre n√∫meros bin√°rios, hexadecimais e decimais √© bastante √≥bvia, mas para o primeiro engenheiro, que pensara nisso antes da inven√ß√£o do computador, isso deveria ter se tornado um momento de insight. <br><br>  Entendeu tudo isso?  √ìtimo. <br><br><h1>  Uma breve introdu√ß√£o ao processador </h1><br>  <em>Se voc√™ j√° sabe disso, pode pular com seguran√ßa a se√ß√£o.</em> <br><br>  Uma unidade central de processamento (CPU) √© uma m√°quina projetada para executar programas.  Os blocos fundamentais da CPU s√£o registros e instru√ß√µes.  Como desenvolvedor de software, voc√™ pode tratar esses registros como vari√°veis.  Em nosso processador 8080, entre outros registros, existem registros de 8 bits chamados A, B, C, D e E. Esses registros podem ser interpretados como o seguinte c√≥digo C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Todos os processadores tamb√©m possuem um contador de programa (contador de programa, PC).  Voc√™ pode tom√°-lo como um ponteiro. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Para uma CPU, um programa √© uma sequ√™ncia de n√∫meros hexadecimais.  Cada instru√ß√£o de linguagem assembly em 8080 corresponde a 1-3 bytes no programa.  Para descobrir qual comando corresponde a qual n√∫mero, o manual do processador (ou qualquer outra informa√ß√£o sobre o processador 8080 da Internet) √© √∫til. <br><br>  Os nomes dos comandos (instru√ß√µes) geralmente s√£o mnem√¥nicos das opera√ß√µes executadas por esses comandos.  O mnem√¥nico para carregamento no 8080 √© MOV (movimento) e o ADD √© usado para executar a adi√ß√£o. <br><br><h4>  Exemplos </h4><br>  O valor atual da mem√≥ria indicado pelo contador de instru√ß√µes √© 0x79.  Isso est√° de acordo com a instru√ß√£o <code>MOV A,C</code> processador 8080. Esse c√≥digo de montagem no c√≥digo C se parece com <code>A=C;</code>  . <br><br>  Se, em vez disso, o valor no PC for 0x80, o processador executar√° <code>ADD B</code>  Em C, isso corresponde √† string <code>A = A + B;</code>  . <br><br>  Uma lista completa das instru√ß√µes do processador 8080 pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Para implementar nosso emulador, usaremos essas informa√ß√µes. <br><br><h4>  Hor√°rios </h4><br>  Na CPU, a execu√ß√£o de cada instru√ß√£o requer uma certa quantidade de tempo (tempo), medido em ciclos.  Nos processadores modernos, essas informa√ß√µes podem ser dif√≠ceis de obter, porque os tempos dependem de muitos aspectos diferentes.  Por√©m, em processadores mais antigos como o 8080, os tempos s√£o constantes e essas informa√ß√µes s√£o geralmente fornecidas pelo fabricante do processador.  Por exemplo, uma instru√ß√£o de transfer√™ncia do registro para o registro MOV leva 1 ciclo. <br><br>  As informa√ß√µes de tempo s√£o √∫teis para escrever c√≥digo eficiente no processador.  Um programador pode tentar evitar instru√ß√µes que levam muitos ciclos para serem conclu√≠das. <br><br>  Mais importante para n√≥s √© que usaremos informa√ß√µes de tempo para emular o processador.  Para que o jogo funcione da mesma maneira que no original, as instru√ß√µes devem ser executadas na velocidade correta.  Alguns emuladores se esfor√ßam muito para isso, mas quando chegarmos a isso, teremos que decidir qual precis√£o queremos obter. <br><br><h1>  Opera√ß√µes l√≥gicas </h1><br>  Antes de fechar o t√≥pico de n√∫meros bin√°rios e hexadecimais, devemos falar sobre opera√ß√µes l√≥gicas.  Voc√™ provavelmente j√° est√° acostumado a usar l√≥gica no seu c√≥digo, por exemplo, em constru√ß√µes como <code>if ((conditionA) and (conditionB))</code> .  Nos programas que funcionam diretamente com o hardware, voc√™ geralmente precisa manipular bits individuais de n√∫meros. <br><br><h3>  E opera√ß√£o </h3><br>  Aqui est√£o todos os resultados poss√≠veis da opera√ß√£o AND (AND) (tabela verdade) entre dois n√∫meros de um √∫nico bit. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  O resultado de AND √© igual √† unidade somente quando ambos os valores s√£o iguais √† unidade.  Quando combinamos dois n√∫meros com a opera√ß√£o AND, AND para cada bit de um n√∫mero √© AND com o bit correspondente do outro n√∫mero.  O resultado √© armazenado neste bit do n√∫mero de destino.  Provavelmente √© melhor apenas ver um exemplo: <br><br><table><tbody><tr><td></td><td colspan="8">  bin√°rio </td><td>  hex </td></tr><tr><td>  fonte x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  US $ 6 bilh√µes </td></tr><tr><td>  fonte y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x AND </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ 42 </td></tr></tbody></table><br>  Em C, a opera√ß√£o AND l√≥gica √© um "e" comercial simples. <br><br><h3>  Opera√ß√£o OR (OR) </h3><br>  A opera√ß√£o OR funciona de maneira semelhante.  A √∫nica diferen√ßa √© que o resultado ser√° igual a um se pelo menos um dos valores de x ou y for igual a um. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  bin√°rio </td><td>  hex </td></tr><tr><td>  fonte x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  US $ 6 bilh√µes </td></tr><tr><td>  fonte y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x OU y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  Em C, uma opera√ß√£o l√≥gica OU √© indicada por uma barra vertical "|". <br><br><h3>  Por que isso √© importante? </h3><br>  Em muitos processadores mais antigos, e especialmente em m√°quinas de fliperama, o jogo geralmente requer trabalho com apenas um bit do n√∫mero.  Muitas vezes, existe um c√≥digo semelhante: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  No exemplo 1, o endere√ßo $ 2043 alocado na mem√≥ria √© o endere√ßo dos bot√µes no painel de controle.  Este c√≥digo l√™ e responde ao bot√£o pressionado.  (Obviamente, no Space Invaders esse c√≥digo estar√° em linguagem assembly!) <br><br>  No exemplo 2, o jogo deseja acender um indicador LED, localizado no bit 6 do endere√ßo de US $ 2089 alocado na mem√≥ria.  O c√≥digo deve ler o valor existente, alterar apenas um bit e escrev√™-lo novamente. <br><br>  No exemplo 3, voc√™ precisa desativar o indicador do exemplo 2, portanto, o c√≥digo deve redefinir o bit 6 do endere√ßo $ 2089.  Isso pode ser feito executando a opera√ß√£o AND para o byte de controle do indicador com um valor em que apenas o bit 6. √© zero, portanto, afetamos apenas 6, mantendo os bits restantes inalterados. <br><br>  Isso geralmente √© chamado de "m√°scara".  Em C, uma m√°scara geralmente √© escrita usando o operador NOT, indicado por um til ("~").  Portanto, em vez de escrever <code>0xBF</code> , eu apenas escrevo <code>~0x40</code> e obtenho o mesmo n√∫mero, mas sem colocar muito esfor√ßo. <br><br><h1>  Introdu√ß√£o √† linguagem assembly </h1><br>  Se voc√™ ler este tutorial, provavelmente est√° familiarizado com a programa√ß√£o de computadores, por exemplo, em Java ou Python.  Esses idiomas permitem que voc√™ trabalhe bastante em apenas algumas linhas de c√≥digo.  O c√≥digo √© considerado habilmente escrito, se fizer o m√°ximo de trabalho poss√≠vel no menor n√∫mero poss√≠vel de linhas, possivelmente at√© usando a funcionalidade das bibliotecas internas.  Esses idiomas s√£o chamados de "idiomas de alto n√≠vel". <br><br>  Em linguagem assembly, por outro lado, n√£o h√° recursos internos para salvar vidas, e muitas linhas simples de c√≥digo podem ser necess√°rias para concluir tarefas simples.  A linguagem assembly √© considerada uma linguagem de baixo n√≠vel.  Nele, voc√™ precisa se acostumar a pensar no estilo de "que sequ√™ncia espec√≠fica de etapas deve ser executada para concluir esta tarefa?" <br><br>  A coisa mais importante que voc√™ precisa saber sobre o idioma do assembler √© que cada linha √© traduzida em um comando do processador. <br><br>  Considere essa constru√ß√£o da linguagem C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Na linguagem assembly, esta tarefa dever√° ser executada na seguinte sequ√™ncia: <br><br><ol><li>  Carrega o endere√ßo da vari√°vel B no registrador 1 </li><li>  Carregue o conte√∫do deste endere√ßo de mem√≥ria no registro 2 </li><li>  Adicione valor direto 0x64 ao registro 2 </li><li>  Carregue o endere√ßo da vari√°vel A no registro 1 </li><li>  Escreva o conte√∫do do registro 2 no endere√ßo armazenado no registro 1 </li></ol><br>  No c√≥digo, ser√° algo parecido com isto: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Vale ressaltar o seguinte: <br><br><ul><li>  Em uma linguagem de alto n√≠vel, o compilador decide onde colocar as vari√°veis ‚Äã‚Äãna mem√≥ria.  Ao escrever c√≥digo no assembler, voc√™ √© respons√°vel por cada endere√ßo de mem√≥ria que usar√°. </li><li>  Na maioria das linguagens assembly, colchetes significam "mem√≥ria neste endere√ßo". </li><li>  Na maioria das linguagens assembler, # denota um n√∫mero alg√©brico, tamb√©m chamado de valor imediato.  Por exemplo, na linha 1 do exemplo acima, o c√≥digo realmente grava o valor # 0x1000 no registro a1.  Se o c√≥digo parecer <code>move.l a1, ($1000)</code> , a1 receber√° o conte√∫do da mem√≥ria no endere√ßo 0x1000. </li><li>  Cada processador possui sua pr√≥pria linguagem assembly, e a transfer√™ncia de c√≥digo de um processador para outro pode ser dif√≠cil. </li><li>  Esta n√£o √© uma linguagem de montagem de processador real, eu vim com ela como exemplo. </li></ul><br>  No entanto, h√° algo em comum entre programadores inteligentes de alto n√≠vel e assistentes de montagem.  Os programadores do Assembler consideram uma honra concluir a tarefa da maneira mais eficiente poss√≠vel e minimizar o n√∫mero de instru√ß√µes usadas.  O c√≥digo para m√°quinas de arcade geralmente √© altamente otimizado e todos os sucos s√£o extra√≠dos de cada byte e ciclo extras. <br><br><h1>  Pilhas </h1><br>  Vamos falar um pouco mais sobre a linguagem assembly.  Em qualquer programa de computador bastante complexo nas sub-rotinas assembler s√£o usadas.  A maioria das CPUs possui uma estrutura chamada pilha. <br><br>  Imagine uma pilha na forma de uma pilha.  Se precisarmos salvar um n√∫mero, colocamos no topo da pilha.  Quando precisamos traz√™-lo de volta, tiramos do topo da pilha.  Os programadores de assembler chamam de "empurrar" o n√∫mero da pilha e o de pop-up √© chamado de "pop". <br><br>  Digamos que meu programa precise chamar uma sub-rotina.  Eu posso escrever c√≥digo semelhante: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  O c√≥digo mostrado acima coloca os valores d0, d1, a0 e a1 na pilha.  A maioria dos processadores usa um ponteiro de pilha.  Este pode ser um registro regular, por conven√ß√£o, usado como ponteiro de pilha ou um registro especial com fun√ß√µes para determinadas instru√ß√µes. <br><br>  Nos processadores da s√©rie 68K, o ponteiro da pilha √© determinado apenas por conven√ß√£o; caso contr√°rio, √© um registro regular.  No nosso processador 8080, o registro SP √© um registro especial.  Possui comandos PUSH e POP que gravam e saem da pilha em apenas um comando. <br><br>  Em nosso projeto emulador, n√£o escreveremos c√≥digo do zero.  Mas se voc√™ precisar analisar programas em linguagem assembly, √© bom aprender a reconhecer essas constru√ß√µes. <br><br><h4>  Linguagens de alto n√≠vel </h4><br>  Ao gravar um programa em um idioma de alto n√≠vel, todas as opera√ß√µes de salvamento e restaura√ß√£o de registros s√£o executadas a cada chamada de fun√ß√£o.  N√£o pensamos neles, porque o compilador lida com eles.  As chamadas de fun√ß√£o em um idioma de alto n√≠vel podem consumir muita mem√≥ria e tempo do processador. <br><br>  Voc√™ j√° experimentou um travamento de programa ao chamar uma sub-rotina em um loop infinito?  Isso pode acontecer porque cada chamada de fun√ß√£o colocou valores de registro na pilha e, em algum momento, a mem√≥ria ficou sem pilha.  (Se a pilha ficar muito grande, isso ser√° chamado de estouro de pilha ou estouro de pilha). <br><br>  Voc√™ pode ter ouvido falar de fun√ß√µes em linha.  Eles evitam salvar e restaurar registros incluindo o c√≥digo de rotina na fun√ß√£o de chamada.  O c√≥digo fica maior, mas, gra√ßas a isso, v√°rios comandos e opera√ß√µes de leitura / grava√ß√£o na mem√≥ria s√£o salvos. <br><br><h4>  Conven√ß√µes de chamada </h4><br>  Ao escrever um programa assembler que chama apenas seu c√≥digo, voc√™ pode decidir por si mesmo como as rotinas se comunicar√£o.  Por exemplo, como fa√ßo para retornar √† fun√ß√£o de chamada ap√≥s a conclus√£o da rotina?  Uma maneira √© escrever o endere√ßo de retorno em um registro espec√≠fico.  O outro √© colocar o endere√ßo de retorno no topo da pilha.  Muitas vezes, a decis√£o depende do que o processador suporta.  O 8080 possui um comando CALL que envia o endere√ßo de retorno de uma fun√ß√£o para a pilha.  Talvez voc√™ use este comando 8080 para implementar chamadas de sub-rotina. <br><br>  Mais uma decis√£o precisa ser tomada.  A preserva√ß√£o do registro √© de responsabilidade da fun√ß√£o ou sub-rotina de chamada?  No exemplo acima, os registradores s√£o armazenados pela fun√ß√£o de chamada.  Mas e se tivermos 32 registros?  Salvar e restaurar 32 registros quando uma rotina usa apenas uma pequena fra√ß√£o deles ser√° uma perda de tempo. <br><br>  O trade-off pode ser uma abordagem mista.  Suponha que escolhemos uma pol√≠tica na qual uma rotina possa usar os registradores r10-r32 sem salvar seu conte√∫do, mas n√£o possa destruir r1-r9.  Em uma situa√ß√£o semelhante, a fun√ß√£o de chamada sabe o seguinte: <br><br><ul><li>  Ao retornar de uma fun√ß√£o, o conte√∫do de r1-r9 permanecer√° inalterado </li><li>  N√£o posso depender do conte√∫do de r10-r32 </li><li>  Se eu precisar de um valor em r10-r32 depois de chamar uma sub-rotina, antes de cham√°-lo, preciso salv√°-lo em algum lugar </li></ul><br>  Da mesma forma, cada rotina sabe o seguinte: <br><br><ul><li>  Eu posso destruir r10-r32 </li><li>  Se eu quiser usar r1-r9, preciso salvar o conte√∫do e restaur√°-lo antes de retornar √† fun√ß√£o que me chamou </li></ul><br><h4>  Abi </h4><br>  Na maioria das plataformas modernas, essas pol√≠ticas s√£o criadas por engenheiros e publicadas em documentos chamados ABI (Application Binary Interface).  Gra√ßas a este documento, os criadores do compilador sabem como compilar c√≥digo que pode chamar c√≥digo compilado por outros compiladores.  Se voc√™ deseja escrever um c√≥digo assembler que possa funcionar em um ambiente assim, precisar√° conhecer a ABI e escrever um c√≥digo de acordo com ele. <br><br>  Conhecer a ABI tamb√©m ajuda na depura√ß√£o do c√≥digo quando voc√™ n√£o tem acesso √† fonte.  A ABI define a localiza√ß√£o dos par√¢metros para fun√ß√µes, portanto, ao considerar qualquer subprograma, voc√™ pode examinar esses endere√ßos para entender o que √© passado para as fun√ß√µes. <br><br><h4>  Voltar ao emulador </h4><br>  A maioria dos c√≥digos de montagem escritos √† m√£o, especialmente para processadores mais antigos e jogos arcade, n√£o segue a ABI.  Os programas s√£o montados e podem n√£o ter muitas rotinas.  Cada rotina salva e restaura registros apenas em caso de emerg√™ncia. <br><br>  Se voc√™ quiser entender o que o programa faz, seria bom come√ßar marcando os endere√ßos direcionados aos comandos CALL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418635/">https://habr.com/ru/post/pt418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418625/index.html">Chamada secreta para Andy Grove, que ajudou a Apple a comprar o NeXT</a></li>
<li><a href="../pt418627/index.html">Mais sobre m√©todos para resolver sistemas de equa√ß√µes alg√©bricas lineares</a></li>
<li><a href="../pt418629/index.html">Como verificar independentemente se voc√™ pode patentear seu produto e realizar uma pesquisa de patentes</a></li>
<li><a href="../pt418631/index.html">7 diretrizes de c√≥digo javascript</a></li>
<li><a href="../pt418633/index.html">Reatividade JavaScript: um exemplo simples e intuitivo</a></li>
<li><a href="../pt418637/index.html">Kubernetes para as massas: Slurm come√ßa em 3 de agosto</a></li>
<li><a href="../pt418639/index.html">Akka Streams para meros mortais</a></li>
<li><a href="../pt418641/index.html">Um erro que impede um designer de crescer</a></li>
<li><a href="../pt418643/index.html">Sit vs stand: como trabalhar melhor?</a></li>
<li><a href="../pt418645/index.html">Artigos da confer√™ncia de primavera C ++ R√∫ssia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>