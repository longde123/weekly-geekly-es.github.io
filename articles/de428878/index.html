<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚒 🐘 💾 Schweineflug oder Optimierung von Bytecode-Interpreten 👩🏾‍💻 🌭 🤦🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Egal wie sehr Sie es versuchen, Sie können aus einem Schwein kein Rennpferd machen. Sie können jedoch ein schnelleres Schwein machen" (Kommentar im Q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schweineflug oder Optimierung von Bytecode-Interpreten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "Egal wie sehr Sie es versuchen, Sie können aus einem Schwein kein Rennpferd machen. Sie können jedoch ein schnelleres Schwein machen" (Kommentar im Quellcode von Emax) </blockquote><p>  Jeder kennt die Tatsache, dass Schweine nicht fliegen.  Nicht weniger beliebt ist die Meinung, dass Bytecode-Interpreter als Technik zur Ausführung von Hochsprachen ohne die Verwendung einer zeitaufwändigen dynamischen Kompilierung nicht beschleunigt werden können. </p><br><p>  Im zweiten Teil einer Reihe von Artikeln über Bytecode-Interpreter am Beispiel einer kleinen gestapelten virtuellen FDA-Maschine (Pig Virtual Machine) werde ich versuchen zu zeigen, dass für fleißige Ferkel mit Ambitionen nicht alles verloren geht und dass es möglich ist, im Rahmen von (meistens) Standard C zu beschleunigen Die Arbeit solcher Dolmetscher ist mindestens eineinhalb Mal. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil, Einführung</a> <br>  Teil zwei, Optimierung (aktuell) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil, Angewandt</a> </p><br><h1 id="porosenokvm">  Ferkel </h1><br><p>  Lass uns kennenlernen. </p><br><p>  <a href="">Piglet</a> VM ist eine gewöhnliche gestapelte Maschine, die auf einem <a href="">Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil einer</a> Artikelserie basiert.  Unser Schwein kennt nur einen Datentyp - ein 64-Bit-Maschinenwort, und alle (ganzzahligen) Berechnungen werden auf dem Stapel mit einer maximalen Tiefe von 256 Maschinenwörtern ausgeführt.  Zusätzlich zum Stapel hat dieses Ferkel einen Arbeitsspeicher von 65.536 Maschinenwörtern.  Das Ergebnis der Programmausführung - ein Maschinenwort - kann entweder in das Ergebnisregister gestellt oder einfach in die Standardausgabe (stdout) ausgegeben werden. </p><br><p>  Der gesamte Status in der Piglet VM-Maschine wird in einer einzigen Struktur gespeichert: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  Das oben Gesagte ermöglicht es uns, diese Maschine virtuellen Maschinen auf niedriger Ebene zuzuordnen, wobei fast der gesamte Aufwand für die Wartung des Hauptprogrammzyklus anfällt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  Der Code zeigt, dass für jeden Opcode das Schweinchen: </p><br><ol><li>  Rufen Sie den Opcode aus dem Anweisungsstrom ab. </li><li>  Stellen Sie sicher, dass der Opcode im gültigen Bereich der Opcode-Werte liegt (diese Logik wird vom C-Compiler beim Generieren des Switch-Codes hinzugefügt). </li><li>  Gehen Sie zu den Körperanweisungen. </li><li>  Extrahieren Sie Befehlsargumente aus dem Stapel oder dekodieren Sie ein Befehlsargument, das sich direkt im Bytecode befindet. </li><li>  Führen Sie eine Operation durch. </li><li>  Wenn es ein Berechnungsergebnis gibt, legen Sie es auf den Stapel. </li><li>  Bewegen Sie den Zeiger von der aktuellen Anweisung zur nächsten. </li></ol><br><p>  Die Nutzlast befindet sich hier nur im fünften Absatz, der Rest ist Overhead: Decodieren oder Abrufen von Anweisungen vom Stapel (Absatz 4), Überprüfen des Opcode-Werts (Absatz 2), wiederholtes Zurückkehren zum Anfang der Hauptschleife und dem anschließenden schwer vorhergesagten bedingten Übergang (Absatz 3). </p><br><p>  Kurz gesagt, das Schwein hat den empfohlenen Body-Mass-Index deutlich überschritten, und wenn wir ihn in Form bringen wollen, müssen wir uns mit all diesen Exzessen auseinandersetzen. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Schwein Assemblersprache und Sieb von Eratosthenes </h1><br><p>  Lassen Sie uns zunächst die Spielregeln festlegen. </p><br><p>  Das Schreiben von Programmen für eine virtuelle Maschine direkt in C ist eine schlechte Idee, aber das Erstellen einer Programmiersprache ist eine lange Zeit, daher haben wir uns entschlossen, uns auf eine Piggy-Assemblersprache zu beschränken. </p><br><p>  Ein Programm, das die Summe der Zahlen von 1 bis 65.536 in diesem Assembler berechnet, sieht ungefähr so ​​aus: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  Natürlich nicht Python, aber es gibt alles, was Sie für das Glück von Schweinen benötigen: Kommentare, Tags, bedingte und bedingungslose Sprünge zu ihnen, Mnemonik für Anweisungen und die Möglichkeit, direkte Argumente für Anweisungen anzugeben. </p><br><p>  Komplett mit der Maschine "Piglet VM" sind Assembler und Disassembler, die mutig im Geist sind und viel Freizeit haben, können die Leser unabhängig im Kampf testen. </p><br><p>  Die Zahlen summieren sich sehr schnell, daher habe ich zum Testen der Leistung ein anderes Programm geschrieben - eine naive Implementierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Eratosthenes-Siebs</a> . </p><br><p>  Tatsächlich läuft das Ferkel sowieso ziemlich schnell (seine Anweisungen entsprechen denen der Maschine). Um klare Ergebnisse zu erhalten, werde ich jede Messung für hundert Programmstarts durchführen. </p><br><p>  Die erste Version unseres nicht optimierten Schweins läuft folgendermaßen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  Eine halbe Sekunde!  Der Vergleich ist sicherlich unehrlich, aber der gleiche Python-Algorithmus macht hundert Läufe etwas langsamer: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4,5 Sekunden oder neunmal langsamer.  Wir müssen dem Ferkel Tribut zollen - er hat die Fähigkeit!  Nun wollen wir sehen, ob unser Schwein die Presse aufpumpen kann. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  Übung 1: Statische Superanweisungen </h1><br><p>  Die erste Regel für schnellen Code ist, nicht zu viel Arbeit zu erledigen.  Die zweite Regel für schnellen Code lautet, niemals zusätzliche Arbeit zu leisten.  Welche zusätzliche Arbeit leistet Piglet VM? </p><br><p>  Beobachtung eins: Die Profilerstellung unseres Programms zeigt, dass es Sequenzen von Anweisungen gibt, die häufiger vorkommen als andere.  Wir werden unser Schwein nicht viel quälen und uns auf ein paar Anweisungen beschränken: </p><br><ol><li>  LOADI 0, ADD - Legen Sie eine Nummer aus dem Speicher unter der Adresse 0 auf den Stapel und fügen Sie sie der Nummer oben auf dem Stapel hinzu. </li><li>  PUSHI 65536, GREATER_OR_EQUAL - Legen Sie eine Zahl auf den Stapel und vergleichen Sie sie mit der Zahl, die zuvor oben auf dem Stapel lag. Legen Sie das Ergebnis des Vergleichs (0 oder 1) wieder auf den Stapel. </li><li>  PUSHI 1, ADD - Legen Sie eine Zahl auf den Stapel, fügen Sie sie zu der Zahl hinzu, die zuvor oben auf dem Stapel lag, und legen Sie das Ergebnis der Addition wieder auf den Stapel. </li></ol><br><p>  Es gibt etwas mehr als 20 Anweisungen in der Piglet VM-Maschine, und ein ganzes Byte wird zum Codieren verwendet - 256 Werte.  Das Einführen neuer Anweisungen ist kein Problem.  Was wir tun werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Nichts kompliziertes.  Mal sehen, was daraus wurde: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Wow!  Der Code ist nur für drei neue Anweisungen und wir haben eineinhalb hundert Millisekunden gewonnen! </p><br><p>  Der Gewinn wird hier dadurch erzielt, dass unser Schweinchen beim Ausführen solcher Anweisungen keine unnötigen Bewegungen ausführt: Der Ausführungsthread fällt nicht in die Hauptschleife heraus, nichts wird dekodiert und die Argumente der Anweisungen durchlaufen den Stapel nicht erneut. </p><br><p>  Dies wird als statische Superbefehle bezeichnet, da zusätzliche Anweisungen statisch definiert werden, dh vom Programmierer der virtuellen Maschine in der Entwicklungsphase.  Dies ist eine einfache und effektive Technik, die alle virtuellen Maschinen von Programmiersprachen in der einen oder anderen Form verwenden. </p><br><p>  Das Hauptproblem bei statischen Superbefehlen besteht darin, dass ohne ein bestimmtes Programm nicht festgelegt werden kann, welche Anweisungen kombiniert werden sollen.  Verschiedene Programme verwenden unterschiedliche Befehlssequenzen, und Sie können diese Sequenzen erst beim Starten eines bestimmten Codes herausfinden. </p><br><p>  Der nächste Schritt könnte die dynamische Kompilierung von Superbefehlen im Kontext eines bestimmten Programms sein, dh dynamische Superbefehle (in den 90er und frühen 2000er Jahren spielte diese Technik die Rolle einer primitiven JIT-Kompilierung). </p><br><p>  Es ist unmöglich, im Rahmen des normalen C spontan Anweisungen zu erstellen, und unser Ferkel betrachtet dies zu Recht nicht als ehrlichen Wettbewerb.  Zum Glück habe ich ein paar bessere Übungen für ihn. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  Übung zwei: Überprüfen des Bereichs der Opcode-Werte </h1><br><p>  Nach unseren schnellen Code-Regeln stellen wir uns erneut die ewige Frage: Was können Sie nicht tun? </p><br><p>  Als wir uns mit dem Gerät der Piglet VM-Maschine vertraut machten, listete ich alle Aktionen auf, die die virtuelle Maschine für jeden Opcode ausführt.  Und Punkt 2 (Überprüfen des Werts des Opcodes, um in den gültigen Bereich der Schalterwerte zu passen) ist am verdächtigsten. </p><br><p>  Schauen wir uns an, wie GCC das Switch-Konstrukt kompiliert: </p><br><ol><li>  Eine Übergangstabelle wird erstellt, dh eine Tabelle, die den Wert des Opcodes an die Adresse des Codes anzeigt, der den Hauptteil des Befehls ausführt. </li><li>  Es wird ein Code eingefügt, der prüft, ob der empfangene Opcode in den Bereich aller möglichen Schalterwerte fällt, und ihn an das Standardetikett sendet, wenn kein Handler für den Opcode vorhanden ist. </li><li>  Der Code, der an den Handler geht, wird eingefügt. </li></ol><br><p>  Aber warum wird das Werteintervall für jede Anweisung überprüft?  Wir glauben, dass der Opcode entweder korrekt ist - die Ausführung durch die Anweisung OP_DONE wird beendet oder falsch - und über den Bytecode hinausgeht.  Das Ende des Streams von Opcodes ist mit Null markiert, und Null ist der Opcode des Befehls OP_ABORT, der die Ausführung des Bytecodes mit einem Fehler abschließt. </p><br><p>  Es stellt sich heraus, dass diese Prüfung überhaupt nicht benötigt wird!  Und das Ferkel sollte diese Idee dem Compiler vermitteln können.  Versuchen wir, den Hauptschalter ein wenig zu reparieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Da wir wissen, dass wir nur 26 Befehle haben, legen wir dem Opcode eine Bitmaske auf (der Oktalwert 0x1f ist eine binäre 0b11111, die den Wertebereich von 0 bis 31 abdeckt) und fügen Handler zu nicht verwendeten Werten im Bereich von 26 bis 31 hinzu. </p><br><p>  Bitbefehle gehören zu den billigsten in der x86-Architektur, und sie sind sicherlich billiger als problematische bedingte Zweige wie der, der die Intervallprüfung verwendet.  Theoretisch sollten wir mehrere Zyklen für jede ausführbare Anweisung gewinnen, wenn der Compiler unseren Hinweis versteht. </p><br><p>  Übrigens ist die Art und Weise, den Wertebereich für den Fall anzugeben, nicht Standard C, sondern eine GCC-Erweiterung.  Für unsere Zwecke ist dieser Code jedoch geeignet, zumal es nicht schwierig ist, ihn für jeden der unnötigen Werte in mehrere Handler umzuwandeln. </p><br><p>  Wir versuchen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  Weitere 50 Millisekunden!  Ferkel, es ist, als hättest du dich in deinen Schultern gehört! </p><br><h1 id="uprazhnenie-trete-trassy">  Übung Drei: Trails </h1><br><p>  Welche anderen Übungen können unserem Ferkel helfen?  Die größte Zeitersparnis haben wir dank super Anweisungen bekommen.  Und sie reduzieren die Anzahl der Ausgänge zum Hauptzyklus und ermöglichen es Ihnen, die entsprechenden Gemeinkosten loszuwerden. </p><br><p>  Der zentrale Schalter ist der Hauptproblempunkt für jeden Prozessor mit einer außergewöhnlichen Ausführung von Anweisungen.  Moderne Verzweigungsvorhersagen haben gelernt, selbst solche komplexen indirekten Übergänge gut vorherzusagen, aber das „Verschmieren“ von Verzweigungspunkten entlang des Codes kann dem Prozessor helfen, schnell von Befehl zu Befehl zu wechseln. </p><br><p>  Ein weiteres Problem ist das byteweise Lesen von Befehls-Opcodes und direkten Argumenten aus dem Bytecode.  Physische Maschinen arbeiten mit einem 64-Bit-Maschinenwort und mögen es nicht wirklich, wenn der Code mit niedrigeren Werten arbeitet. </p><br><p>  Compiler arbeiten häufig mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisblöcken</a> , dh Befehlssequenzen ohne Verzweigungen und Beschriftungen.  Der Basisblock beginnt entweder am Anfang des Programms oder am Label und endet mit dem Ende des Programms, der bedingten Verzweigung oder einem direkten Sprung zum Label, das den nächsten Basisblock startet. </p><br><p>  Die Arbeit mit Basiseinheiten bietet viele Vorteile, aber unser Schwein interessiert sich für die Hauptfunktion: Anweisungen innerhalb der Basiseinheit werden nacheinander ausgeführt.  Es wäre großartig, diese Basisblöcke irgendwie zu isolieren und den Anweisungen darin zu folgen, ohne Zeit damit zu verschwenden, in die Hauptschleife zu gelangen. </p><br><p>  In unserem Fall können Sie die Definition der Basiseinheit sogar auf die Spur erweitern.  Die Spur in Bezug auf die Piglet VM-Maschine enthält alle nacheinander verbundenen Basisblöcke (dh unter Verwendung bedingungsloser Sprünge). </p><br><p>  Neben der sequentiellen Ausführung von Anweisungen wäre es schön, die direkten Argumente der Anweisungen im Voraus zu dekodieren. </p><br><p>  Das klingt alles ziemlich beängstigend und ähnelt einer dynamischen Zusammenstellung, die wir nicht verwenden wollten.  Das Schwein zweifelte sogar ein wenig an seiner Stärke, aber in der Praxis stellte sich heraus, dass es nicht so schlimm war. </p><br><p>  Lassen Sie uns zunächst darüber nachdenken, wie Sie sich die in der Spur enthaltene Anweisung vorstellen können: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Hier ist arg das vordecodierte Argument der Anweisung, und der Handler ist ein Zeiger auf eine Funktion, die die Logik der Anweisung ausführt. </p><br><p>  Jetzt sieht die Ansicht jeder Spur folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Das heißt, eine Spur ist eine Folge von S-Codes begrenzter Länge.  Der Trace-Cache selbst in der virtuellen Maschine sieht folgendermaßen aus: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Dies ist nur ein Array von Traces mit einer Länge, die die mögliche Bytecode-Länge nicht überschreitet.  Die Lösung ist faul. Um Speicherplatz zu sparen, ist es sinnvoll, eine Hash-Tabelle zu verwenden. </p><br><p>  Zu Beginn des Interpreters kompiliert sich der erste Handler jedes Trace selbst: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  Die Hauptinterpreterschleife sieht nun folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Ein Trace-Compiler ist etwas komplizierter und führt zusätzlich zum Erstellen eines Trace ausgehend von der aktuellen Anweisung Folgendes aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Normaler Anweisungshandler: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Ein Handler, der am Ende der Funktion keine Aufrufe ausführt, beendet jede Ablaufverfolgung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  All dies ist natürlich komplizierter als das Hinzufügen von Superanweisungen, aber mal sehen, ob es uns etwas gegeben hat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  Hurra, noch 30 Millisekunden! </p><br><p>  Wie so?  Anstatt einfach durch Beschriftungen zu navigieren, erstellen wir Anrufketten von Anweisungshandlern, verbringen Zeit mit Aufrufen und Übergeben von Argumenten, aber unser Schweinchen läuft immer noch schneller auf den Spuren als ein einfacher Schalter mit seinen Beschriftungen. </p><br><p>  Dieser Gewinn an Streckenleistung wird durch drei Faktoren erreicht: </p><br><ol><li>  Das Vorhersagen von Zweigen, die an verschiedenen Stellen im Code verstreut sind, ist einfach. </li><li>  Die Argumente der Handler werden immer in ein vollständiges Maschinenwort vorcodiert, und dies erfolgt nur einmal - während der Kompilierung des Trace. </li><li>  Der Compiler wandelt die Funktionsketten in einen einzigen Aufruf der ersten Handlerfunktion um, was aufgrund der Optimierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail-Aufrufs möglich ist</a> . </li></ol><br><p>  Bevor wir die Ergebnisse unseres Trainings zusammenfassen, haben das Ferkel und ich beschlossen, eine andere alte Technik zur Interpretation von Programmen auszuprobieren - genähten Code. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  Übung 4: "genähter" Code </h1><br><p>  Jedes Schwein, das sich für die Geschichte der Dolmetscher interessierte, hörte einen Thread-Code.  Es gibt viele Optionen für diese Technik, aber alle beschränken sich darauf, anstatt ein Array von Opcodes zu durchlaufen, z. B. Zeiger auf Funktionen oder Beschriftungen, die direkt ohne Zwischen-Opcode folgen. </p><br><p>  Das Aufrufen von Funktionen ist heutzutage ein teures und bedeutungsloses Geschäft.  Die meisten anderen Versionen von genähtem Code sind im Rahmen von Standard C nicht realisierbar. Selbst die Technik, die weiter unten erläutert wird, verwendet die weit verbreiteten, aber nicht standardmäßigen Erweiterungs-C-Zeiger auf Beschriftungen. </p><br><p>  In der Version des genähten Codes (englischer Token-Thread-Code), die ich ausgewählt habe, um unsere Schweineziele zu erreichen, speichern wir den Bytecode, aber bevor wir mit der Interpretation beginnen, erstellen wir eine Tabelle, in der die Anweisungs-Opcodes an die Adresse der Anweisungshandler-Labels angezeigt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Achten Sie auf die Symbole &amp;&amp; - dies sind Zeiger auf Beschriftungen mit den Anweisungen, der nicht standardmäßigen Erweiterung von GCC. </p><br><p>  Um mit der Ausführung des Codes zu beginnen, klicken Sie einfach auf den Zeiger, der dem ersten Opcode des Programms entspricht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  Hier gibt es keinen Zyklus und es wird keinen geben, jede der Anweisungen selbst macht einen Sprung zum folgenden Handler: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  Das Fehlen eines Schalters „verteilt“ Verzweigungspunkte entlang der Befehlskörper, was theoretisch dem Verzweigungsprädiktor bei außergewöhnlicher Ausführung von Befehlen helfen sollte.  Es ist, als hätten wir den Schalter direkt in die Anweisungen eingebaut und manuell eine Übergangstabelle erstellt. </p><br><p>  Das ist die ganze Technik.  Sie mochte das Ferkel wegen seiner Einfachheit.  Mal sehen, was in der Praxis passiert: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  Ups!  Dies ist die langsamste aller unserer Techniken!  Was ist passiert?  Lassen Sie uns dieselben Tests durchführen und alle GCC-Optimierungen deaktivieren: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Hier ist genähter Code besser. </p><br><p>  Drei Faktoren spielen hier eine Rolle: </p><br><ol><li>  Der optimierende Compiler selbst erstellt eine Konvertierungstabelle, die nicht schlechter ist als unser manuelles Typenschild. </li><li>  Moderne Compiler verzichten bemerkenswerterweise auf zusätzliche Funktionsaufrufe. </li><li>  Ausgehend von der Haswell-Generation von Intel-Prozessoren haben Verzweigungsprädiktoren gelernt, Übergänge über einen einzelnen Verzweigungspunkt genau vorherzusagen. </li></ol><br><p>  Laut altem Speicher wird diese Technik immer noch im Code des Python VM-Interpreters verwendet, aber ehrlich gesagt ist sie heutzutage bereits Archaismus. </p><br><p>  Lassen Sie uns abschließend die Erfolge unseres Schweins zusammenfassen und bewerten. </p><br><h1 id="razbor-porosyachih-poletov">  Nachbesprechung </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  Ich bin mir nicht sicher, was dies als Flug bezeichnet werden kann, aber seien wir ehrlich, unser Schweinchen hat einen langen Weg von 550 Millisekunden für hundert Läufe auf dem "Sieb" bis zu den letzten 370 Millisekunden zurückgelegt.  Wir haben verschiedene Techniken verwendet: Super-Anweisungen, das Entfernen von Wertintervallen, die komplizierte Mechanik von Spuren und schließlich sogar das Nähen von Code.  Gleichzeitig haben wir im Allgemeinen im Rahmen der in allen gängigen C-Compilern implementierten Dinge gehandelt. Eine Beschleunigung um das Eineinhalbfache, wie es mir scheint, ist ein gutes Ergebnis, und das Ferkel verdient eine zusätzliche Portion Kleie im Trog. </p><br><p>  Eine der impliziten Bedingungen, die wir für uns mit dem Schwein festlegen, ist die Beibehaltung der Stapelarchitektur der Piglet VM-Maschine.  Der Übergang zur Registerarchitektur reduziert in der Regel die Anzahl der Befehle, die für die Logik von Programmen erforderlich sind, und kann dementsprechend dazu beitragen, unnötige Exits zum Befehlsmanager zu vermeiden.  Ich denke, weitere 10-20% der Zeit könnten abgeschnitten werden. </p><br><p>  Unsere Hauptbedingung - das Fehlen einer dynamischen Zusammenstellung - ist ebenfalls kein Naturgesetz.  Das Pumpen eines Schweins mit Steroiden in Form einer JIT-Zusammenstellung ist heutzutage sehr einfach: In Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Lightning</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibJIT wurde die</a> ganze Drecksarbeit bereits erledigt.  Aber die Entwicklungszeit und die Gesamtmenge an Code, selbst wenn Bibliotheken verwendet werden, wachsen enorm. </p><br><p>  Es gibt natürlich noch andere Tricks, bei denen unser kleines Schwein den Huf nicht erreicht hat.    ,     —       - —    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">true-grue</a> -           — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428878/">https://habr.com/ru/post/de428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428866/index.html">7 Designprinzipien, Einstellung zu Designtrends, UX-Designer-Portfolio, ...</a></li>
<li><a href="../de428868/index.html">Multi-Release-JARs - schlecht oder gut?</a></li>
<li><a href="../de428870/index.html">Mrr: Gesamt-FRP für React</a></li>
<li><a href="../de428872/index.html">Die Geschichte von einem Auge und 20 Operationen (nicht lesbar) oder er wollte Pilot werden, aber er durfte nicht in den Himmel</a></li>
<li><a href="../de428876/index.html">Es gibt kein Zurück: die persönliche Erfahrung des Testers</a></li>
<li><a href="../de428880/index.html">Neue Authentifizierungsmethoden - eine Bedrohung für die Privatsphäre?</a></li>
<li><a href="../de428882/index.html">Mobile Yandex. Blitz: Wir analysieren Aufgaben</a></li>
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428890/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung für Anfänger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>