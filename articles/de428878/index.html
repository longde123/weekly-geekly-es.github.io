<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüöí üêò üíæ Schweineflug oder Optimierung von Bytecode-Interpreten üë©üèæ‚Äçüíª üå≠ ü§¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Egal wie sehr Sie es versuchen, Sie k√∂nnen aus einem Schwein kein Rennpferd machen. Sie k√∂nnen jedoch ein schnelleres Schwein machen" (Kommentar im Q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schweineflug oder Optimierung von Bytecode-Interpreten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "Egal wie sehr Sie es versuchen, Sie k√∂nnen aus einem Schwein kein Rennpferd machen. Sie k√∂nnen jedoch ein schnelleres Schwein machen" (Kommentar im Quellcode von Emax) </blockquote><p>  Jeder kennt die Tatsache, dass Schweine nicht fliegen.  Nicht weniger beliebt ist die Meinung, dass Bytecode-Interpreter als Technik zur Ausf√ºhrung von Hochsprachen ohne die Verwendung einer zeitaufw√§ndigen dynamischen Kompilierung nicht beschleunigt werden k√∂nnen. </p><br><p>  Im zweiten Teil einer Reihe von Artikeln √ºber Bytecode-Interpreter am Beispiel einer kleinen gestapelten virtuellen FDA-Maschine (Pig Virtual Machine) werde ich versuchen zu zeigen, dass f√ºr flei√üige Ferkel mit Ambitionen nicht alles verloren geht und dass es m√∂glich ist, im Rahmen von (meistens) Standard C zu beschleunigen Die Arbeit solcher Dolmetscher ist mindestens eineinhalb Mal. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil, Einf√ºhrung</a> <br>  Teil zwei, Optimierung (aktuell) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil, Angewandt</a> </p><br><h1 id="porosenokvm">  Ferkel </h1><br><p>  Lass uns kennenlernen. </p><br><p>  <a href="">Piglet</a> VM ist eine gew√∂hnliche gestapelte Maschine, die auf einem <a href="">Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil einer</a> Artikelserie basiert.  Unser Schwein kennt nur einen Datentyp - ein 64-Bit-Maschinenwort, und alle (ganzzahligen) Berechnungen werden auf dem Stapel mit einer maximalen Tiefe von 256 Maschinenw√∂rtern ausgef√ºhrt.  Zus√§tzlich zum Stapel hat dieses Ferkel einen Arbeitsspeicher von 65.536 Maschinenw√∂rtern.  Das Ergebnis der Programmausf√ºhrung - ein Maschinenwort - kann entweder in das Ergebnisregister gestellt oder einfach in die Standardausgabe (stdout) ausgegeben werden. </p><br><p>  Der gesamte Status in der Piglet VM-Maschine wird in einer einzigen Struktur gespeichert: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  Das oben Gesagte erm√∂glicht es uns, diese Maschine virtuellen Maschinen auf niedriger Ebene zuzuordnen, wobei fast der gesamte Aufwand f√ºr die Wartung des Hauptprogrammzyklus anf√§llt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  Der Code zeigt, dass f√ºr jeden Opcode das Schweinchen: </p><br><ol><li>  Rufen Sie den Opcode aus dem Anweisungsstrom ab. </li><li>  Stellen Sie sicher, dass der Opcode im g√ºltigen Bereich der Opcode-Werte liegt (diese Logik wird vom C-Compiler beim Generieren des Switch-Codes hinzugef√ºgt). </li><li>  Gehen Sie zu den K√∂rperanweisungen. </li><li>  Extrahieren Sie Befehlsargumente aus dem Stapel oder dekodieren Sie ein Befehlsargument, das sich direkt im Bytecode befindet. </li><li>  F√ºhren Sie eine Operation durch. </li><li>  Wenn es ein Berechnungsergebnis gibt, legen Sie es auf den Stapel. </li><li>  Bewegen Sie den Zeiger von der aktuellen Anweisung zur n√§chsten. </li></ol><br><p>  Die Nutzlast befindet sich hier nur im f√ºnften Absatz, der Rest ist Overhead: Decodieren oder Abrufen von Anweisungen vom Stapel (Absatz 4), √úberpr√ºfen des Opcode-Werts (Absatz 2), wiederholtes Zur√ºckkehren zum Anfang der Hauptschleife und dem anschlie√üenden schwer vorhergesagten bedingten √úbergang (Absatz 3). </p><br><p>  Kurz gesagt, das Schwein hat den empfohlenen Body-Mass-Index deutlich √ºberschritten, und wenn wir ihn in Form bringen wollen, m√ºssen wir uns mit all diesen Exzessen auseinandersetzen. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Schwein Assemblersprache und Sieb von Eratosthenes </h1><br><p>  Lassen Sie uns zun√§chst die Spielregeln festlegen. </p><br><p>  Das Schreiben von Programmen f√ºr eine virtuelle Maschine direkt in C ist eine schlechte Idee, aber das Erstellen einer Programmiersprache ist eine lange Zeit, daher haben wir uns entschlossen, uns auf eine Piggy-Assemblersprache zu beschr√§nken. </p><br><p>  Ein Programm, das die Summe der Zahlen von 1 bis 65.536 in diesem Assembler berechnet, sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  Nat√ºrlich nicht Python, aber es gibt alles, was Sie f√ºr das Gl√ºck von Schweinen ben√∂tigen: Kommentare, Tags, bedingte und bedingungslose Spr√ºnge zu ihnen, Mnemonik f√ºr Anweisungen und die M√∂glichkeit, direkte Argumente f√ºr Anweisungen anzugeben. </p><br><p>  Komplett mit der Maschine "Piglet VM" sind Assembler und Disassembler, die mutig im Geist sind und viel Freizeit haben, k√∂nnen die Leser unabh√§ngig im Kampf testen. </p><br><p>  Die Zahlen summieren sich sehr schnell, daher habe ich zum Testen der Leistung ein anderes Programm geschrieben - eine naive Implementierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Eratosthenes-Siebs</a> . </p><br><p>  Tats√§chlich l√§uft das Ferkel sowieso ziemlich schnell (seine Anweisungen entsprechen denen der Maschine). Um klare Ergebnisse zu erhalten, werde ich jede Messung f√ºr hundert Programmstarts durchf√ºhren. </p><br><p>  Die erste Version unseres nicht optimierten Schweins l√§uft folgenderma√üen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  Eine halbe Sekunde!  Der Vergleich ist sicherlich unehrlich, aber der gleiche Python-Algorithmus macht hundert L√§ufe etwas langsamer: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4,5 Sekunden oder neunmal langsamer.  Wir m√ºssen dem Ferkel Tribut zollen - er hat die F√§higkeit!  Nun wollen wir sehen, ob unser Schwein die Presse aufpumpen kann. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  √úbung 1: Statische Superanweisungen </h1><br><p>  Die erste Regel f√ºr schnellen Code ist, nicht zu viel Arbeit zu erledigen.  Die zweite Regel f√ºr schnellen Code lautet, niemals zus√§tzliche Arbeit zu leisten.  Welche zus√§tzliche Arbeit leistet Piglet VM? </p><br><p>  Beobachtung eins: Die Profilerstellung unseres Programms zeigt, dass es Sequenzen von Anweisungen gibt, die h√§ufiger vorkommen als andere.  Wir werden unser Schwein nicht viel qu√§len und uns auf ein paar Anweisungen beschr√§nken: </p><br><ol><li>  LOADI 0, ADD - Legen Sie eine Nummer aus dem Speicher unter der Adresse 0 auf den Stapel und f√ºgen Sie sie der Nummer oben auf dem Stapel hinzu. </li><li>  PUSHI 65536, GREATER_OR_EQUAL - Legen Sie eine Zahl auf den Stapel und vergleichen Sie sie mit der Zahl, die zuvor oben auf dem Stapel lag. Legen Sie das Ergebnis des Vergleichs (0 oder 1) wieder auf den Stapel. </li><li>  PUSHI 1, ADD - Legen Sie eine Zahl auf den Stapel, f√ºgen Sie sie zu der Zahl hinzu, die zuvor oben auf dem Stapel lag, und legen Sie das Ergebnis der Addition wieder auf den Stapel. </li></ol><br><p>  Es gibt etwas mehr als 20 Anweisungen in der Piglet VM-Maschine, und ein ganzes Byte wird zum Codieren verwendet - 256 Werte.  Das Einf√ºhren neuer Anweisungen ist kein Problem.  Was wir tun werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Nichts kompliziertes.  Mal sehen, was daraus wurde: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Wow!  Der Code ist nur f√ºr drei neue Anweisungen und wir haben eineinhalb hundert Millisekunden gewonnen! </p><br><p>  Der Gewinn wird hier dadurch erzielt, dass unser Schweinchen beim Ausf√ºhren solcher Anweisungen keine unn√∂tigen Bewegungen ausf√ºhrt: Der Ausf√ºhrungsthread f√§llt nicht in die Hauptschleife heraus, nichts wird dekodiert und die Argumente der Anweisungen durchlaufen den Stapel nicht erneut. </p><br><p>  Dies wird als statische Superbefehle bezeichnet, da zus√§tzliche Anweisungen statisch definiert werden, dh vom Programmierer der virtuellen Maschine in der Entwicklungsphase.  Dies ist eine einfache und effektive Technik, die alle virtuellen Maschinen von Programmiersprachen in der einen oder anderen Form verwenden. </p><br><p>  Das Hauptproblem bei statischen Superbefehlen besteht darin, dass ohne ein bestimmtes Programm nicht festgelegt werden kann, welche Anweisungen kombiniert werden sollen.  Verschiedene Programme verwenden unterschiedliche Befehlssequenzen, und Sie k√∂nnen diese Sequenzen erst beim Starten eines bestimmten Codes herausfinden. </p><br><p>  Der n√§chste Schritt k√∂nnte die dynamische Kompilierung von Superbefehlen im Kontext eines bestimmten Programms sein, dh dynamische Superbefehle (in den 90er und fr√ºhen 2000er Jahren spielte diese Technik die Rolle einer primitiven JIT-Kompilierung). </p><br><p>  Es ist unm√∂glich, im Rahmen des normalen C spontan Anweisungen zu erstellen, und unser Ferkel betrachtet dies zu Recht nicht als ehrlichen Wettbewerb.  Zum Gl√ºck habe ich ein paar bessere √úbungen f√ºr ihn. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  √úbung zwei: √úberpr√ºfen des Bereichs der Opcode-Werte </h1><br><p>  Nach unseren schnellen Code-Regeln stellen wir uns erneut die ewige Frage: Was k√∂nnen Sie nicht tun? </p><br><p>  Als wir uns mit dem Ger√§t der Piglet VM-Maschine vertraut machten, listete ich alle Aktionen auf, die die virtuelle Maschine f√ºr jeden Opcode ausf√ºhrt.  Und Punkt 2 (√úberpr√ºfen des Werts des Opcodes, um in den g√ºltigen Bereich der Schalterwerte zu passen) ist am verd√§chtigsten. </p><br><p>  Schauen wir uns an, wie GCC das Switch-Konstrukt kompiliert: </p><br><ol><li>  Eine √úbergangstabelle wird erstellt, dh eine Tabelle, die den Wert des Opcodes an die Adresse des Codes anzeigt, der den Hauptteil des Befehls ausf√ºhrt. </li><li>  Es wird ein Code eingef√ºgt, der pr√ºft, ob der empfangene Opcode in den Bereich aller m√∂glichen Schalterwerte f√§llt, und ihn an das Standardetikett sendet, wenn kein Handler f√ºr den Opcode vorhanden ist. </li><li>  Der Code, der an den Handler geht, wird eingef√ºgt. </li></ol><br><p>  Aber warum wird das Werteintervall f√ºr jede Anweisung √ºberpr√ºft?  Wir glauben, dass der Opcode entweder korrekt ist - die Ausf√ºhrung durch die Anweisung OP_DONE wird beendet oder falsch - und √ºber den Bytecode hinausgeht.  Das Ende des Streams von Opcodes ist mit Null markiert, und Null ist der Opcode des Befehls OP_ABORT, der die Ausf√ºhrung des Bytecodes mit einem Fehler abschlie√üt. </p><br><p>  Es stellt sich heraus, dass diese Pr√ºfung √ºberhaupt nicht ben√∂tigt wird!  Und das Ferkel sollte diese Idee dem Compiler vermitteln k√∂nnen.  Versuchen wir, den Hauptschalter ein wenig zu reparieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Da wir wissen, dass wir nur 26 Befehle haben, legen wir dem Opcode eine Bitmaske auf (der Oktalwert 0x1f ist eine bin√§re 0b11111, die den Wertebereich von 0 bis 31 abdeckt) und f√ºgen Handler zu nicht verwendeten Werten im Bereich von 26 bis 31 hinzu. </p><br><p>  Bitbefehle geh√∂ren zu den billigsten in der x86-Architektur, und sie sind sicherlich billiger als problematische bedingte Zweige wie der, der die Intervallpr√ºfung verwendet.  Theoretisch sollten wir mehrere Zyklen f√ºr jede ausf√ºhrbare Anweisung gewinnen, wenn der Compiler unseren Hinweis versteht. </p><br><p>  √úbrigens ist die Art und Weise, den Wertebereich f√ºr den Fall anzugeben, nicht Standard C, sondern eine GCC-Erweiterung.  F√ºr unsere Zwecke ist dieser Code jedoch geeignet, zumal es nicht schwierig ist, ihn f√ºr jeden der unn√∂tigen Werte in mehrere Handler umzuwandeln. </p><br><p>  Wir versuchen: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  Weitere 50 Millisekunden!  Ferkel, es ist, als h√§ttest du dich in deinen Schultern geh√∂rt! </p><br><h1 id="uprazhnenie-trete-trassy">  √úbung Drei: Trails </h1><br><p>  Welche anderen √úbungen k√∂nnen unserem Ferkel helfen?  Die gr√∂√üte Zeitersparnis haben wir dank super Anweisungen bekommen.  Und sie reduzieren die Anzahl der Ausg√§nge zum Hauptzyklus und erm√∂glichen es Ihnen, die entsprechenden Gemeinkosten loszuwerden. </p><br><p>  Der zentrale Schalter ist der Hauptproblempunkt f√ºr jeden Prozessor mit einer au√üergew√∂hnlichen Ausf√ºhrung von Anweisungen.  Moderne Verzweigungsvorhersagen haben gelernt, selbst solche komplexen indirekten √úberg√§nge gut vorherzusagen, aber das ‚ÄûVerschmieren‚Äú von Verzweigungspunkten entlang des Codes kann dem Prozessor helfen, schnell von Befehl zu Befehl zu wechseln. </p><br><p>  Ein weiteres Problem ist das byteweise Lesen von Befehls-Opcodes und direkten Argumenten aus dem Bytecode.  Physische Maschinen arbeiten mit einem 64-Bit-Maschinenwort und m√∂gen es nicht wirklich, wenn der Code mit niedrigeren Werten arbeitet. </p><br><p>  Compiler arbeiten h√§ufig mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisbl√∂cken</a> , dh Befehlssequenzen ohne Verzweigungen und Beschriftungen.  Der Basisblock beginnt entweder am Anfang des Programms oder am Label und endet mit dem Ende des Programms, der bedingten Verzweigung oder einem direkten Sprung zum Label, das den n√§chsten Basisblock startet. </p><br><p>  Die Arbeit mit Basiseinheiten bietet viele Vorteile, aber unser Schwein interessiert sich f√ºr die Hauptfunktion: Anweisungen innerhalb der Basiseinheit werden nacheinander ausgef√ºhrt.  Es w√§re gro√üartig, diese Basisbl√∂cke irgendwie zu isolieren und den Anweisungen darin zu folgen, ohne Zeit damit zu verschwenden, in die Hauptschleife zu gelangen. </p><br><p>  In unserem Fall k√∂nnen Sie die Definition der Basiseinheit sogar auf die Spur erweitern.  Die Spur in Bezug auf die Piglet VM-Maschine enth√§lt alle nacheinander verbundenen Basisbl√∂cke (dh unter Verwendung bedingungsloser Spr√ºnge). </p><br><p>  Neben der sequentiellen Ausf√ºhrung von Anweisungen w√§re es sch√∂n, die direkten Argumente der Anweisungen im Voraus zu dekodieren. </p><br><p>  Das klingt alles ziemlich be√§ngstigend und √§hnelt einer dynamischen Zusammenstellung, die wir nicht verwenden wollten.  Das Schwein zweifelte sogar ein wenig an seiner St√§rke, aber in der Praxis stellte sich heraus, dass es nicht so schlimm war. </p><br><p>  Lassen Sie uns zun√§chst dar√ºber nachdenken, wie Sie sich die in der Spur enthaltene Anweisung vorstellen k√∂nnen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Hier ist arg das vordecodierte Argument der Anweisung, und der Handler ist ein Zeiger auf eine Funktion, die die Logik der Anweisung ausf√ºhrt. </p><br><p>  Jetzt sieht die Ansicht jeder Spur folgenderma√üen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Das hei√üt, eine Spur ist eine Folge von S-Codes begrenzter L√§nge.  Der Trace-Cache selbst in der virtuellen Maschine sieht folgenderma√üen aus: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Dies ist nur ein Array von Traces mit einer L√§nge, die die m√∂gliche Bytecode-L√§nge nicht √ºberschreitet.  Die L√∂sung ist faul. Um Speicherplatz zu sparen, ist es sinnvoll, eine Hash-Tabelle zu verwenden. </p><br><p>  Zu Beginn des Interpreters kompiliert sich der erste Handler jedes Trace selbst: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  Die Hauptinterpreterschleife sieht nun folgenderma√üen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Ein Trace-Compiler ist etwas komplizierter und f√ºhrt zus√§tzlich zum Erstellen eines Trace ausgehend von der aktuellen Anweisung Folgendes aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Normaler Anweisungshandler: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Ein Handler, der am Ende der Funktion keine Aufrufe ausf√ºhrt, beendet jede Ablaufverfolgung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  All dies ist nat√ºrlich komplizierter als das Hinzuf√ºgen von Superanweisungen, aber mal sehen, ob es uns etwas gegeben hat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  Hurra, noch 30 Millisekunden! </p><br><p>  Wie so?  Anstatt einfach durch Beschriftungen zu navigieren, erstellen wir Anrufketten von Anweisungshandlern, verbringen Zeit mit Aufrufen und √úbergeben von Argumenten, aber unser Schweinchen l√§uft immer noch schneller auf den Spuren als ein einfacher Schalter mit seinen Beschriftungen. </p><br><p>  Dieser Gewinn an Streckenleistung wird durch drei Faktoren erreicht: </p><br><ol><li>  Das Vorhersagen von Zweigen, die an verschiedenen Stellen im Code verstreut sind, ist einfach. </li><li>  Die Argumente der Handler werden immer in ein vollst√§ndiges Maschinenwort vorcodiert, und dies erfolgt nur einmal - w√§hrend der Kompilierung des Trace. </li><li>  Der Compiler wandelt die Funktionsketten in einen einzigen Aufruf der ersten Handlerfunktion um, was aufgrund der Optimierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail-Aufrufs m√∂glich ist</a> . </li></ol><br><p>  Bevor wir die Ergebnisse unseres Trainings zusammenfassen, haben das Ferkel und ich beschlossen, eine andere alte Technik zur Interpretation von Programmen auszuprobieren - gen√§hten Code. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  √úbung 4: "gen√§hter" Code </h1><br><p>  Jedes Schwein, das sich f√ºr die Geschichte der Dolmetscher interessierte, h√∂rte einen Thread-Code.  Es gibt viele Optionen f√ºr diese Technik, aber alle beschr√§nken sich darauf, anstatt ein Array von Opcodes zu durchlaufen, z. B. Zeiger auf Funktionen oder Beschriftungen, die direkt ohne Zwischen-Opcode folgen. </p><br><p>  Das Aufrufen von Funktionen ist heutzutage ein teures und bedeutungsloses Gesch√§ft.  Die meisten anderen Versionen von gen√§htem Code sind im Rahmen von Standard C nicht realisierbar. Selbst die Technik, die weiter unten erl√§utert wird, verwendet die weit verbreiteten, aber nicht standardm√§√üigen Erweiterungs-C-Zeiger auf Beschriftungen. </p><br><p>  In der Version des gen√§hten Codes (englischer Token-Thread-Code), die ich ausgew√§hlt habe, um unsere Schweineziele zu erreichen, speichern wir den Bytecode, aber bevor wir mit der Interpretation beginnen, erstellen wir eine Tabelle, in der die Anweisungs-Opcodes an die Adresse der Anweisungshandler-Labels angezeigt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Achten Sie auf die Symbole &amp;&amp; - dies sind Zeiger auf Beschriftungen mit den Anweisungen, der nicht standardm√§√üigen Erweiterung von GCC. </p><br><p>  Um mit der Ausf√ºhrung des Codes zu beginnen, klicken Sie einfach auf den Zeiger, der dem ersten Opcode des Programms entspricht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  Hier gibt es keinen Zyklus und es wird keinen geben, jede der Anweisungen selbst macht einen Sprung zum folgenden Handler: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  Das Fehlen eines Schalters ‚Äûverteilt‚Äú Verzweigungspunkte entlang der Befehlsk√∂rper, was theoretisch dem Verzweigungspr√§diktor bei au√üergew√∂hnlicher Ausf√ºhrung von Befehlen helfen sollte.  Es ist, als h√§tten wir den Schalter direkt in die Anweisungen eingebaut und manuell eine √úbergangstabelle erstellt. </p><br><p>  Das ist die ganze Technik.  Sie mochte das Ferkel wegen seiner Einfachheit.  Mal sehen, was in der Praxis passiert: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  Ups!  Dies ist die langsamste aller unserer Techniken!  Was ist passiert?  Lassen Sie uns dieselben Tests durchf√ºhren und alle GCC-Optimierungen deaktivieren: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Hier ist gen√§hter Code besser. </p><br><p>  Drei Faktoren spielen hier eine Rolle: </p><br><ol><li>  Der optimierende Compiler selbst erstellt eine Konvertierungstabelle, die nicht schlechter ist als unser manuelles Typenschild. </li><li>  Moderne Compiler verzichten bemerkenswerterweise auf zus√§tzliche Funktionsaufrufe. </li><li>  Ausgehend von der Haswell-Generation von Intel-Prozessoren haben Verzweigungspr√§diktoren gelernt, √úberg√§nge √ºber einen einzelnen Verzweigungspunkt genau vorherzusagen. </li></ol><br><p>  Laut altem Speicher wird diese Technik immer noch im Code des Python VM-Interpreters verwendet, aber ehrlich gesagt ist sie heutzutage bereits Archaismus. </p><br><p>  Lassen Sie uns abschlie√üend die Erfolge unseres Schweins zusammenfassen und bewerten. </p><br><h1 id="razbor-porosyachih-poletov">  Nachbesprechung </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  Ich bin mir nicht sicher, was dies als Flug bezeichnet werden kann, aber seien wir ehrlich, unser Schweinchen hat einen langen Weg von 550 Millisekunden f√ºr hundert L√§ufe auf dem "Sieb" bis zu den letzten 370 Millisekunden zur√ºckgelegt.  Wir haben verschiedene Techniken verwendet: Super-Anweisungen, das Entfernen von Wertintervallen, die komplizierte Mechanik von Spuren und schlie√ülich sogar das N√§hen von Code.  Gleichzeitig haben wir im Allgemeinen im Rahmen der in allen g√§ngigen C-Compilern implementierten Dinge gehandelt. Eine Beschleunigung um das Eineinhalbfache, wie es mir scheint, ist ein gutes Ergebnis, und das Ferkel verdient eine zus√§tzliche Portion Kleie im Trog. </p><br><p>  Eine der impliziten Bedingungen, die wir f√ºr uns mit dem Schwein festlegen, ist die Beibehaltung der Stapelarchitektur der Piglet VM-Maschine.  Der √úbergang zur Registerarchitektur reduziert in der Regel die Anzahl der Befehle, die f√ºr die Logik von Programmen erforderlich sind, und kann dementsprechend dazu beitragen, unn√∂tige Exits zum Befehlsmanager zu vermeiden.  Ich denke, weitere 10-20% der Zeit k√∂nnten abgeschnitten werden. </p><br><p>  Unsere Hauptbedingung - das Fehlen einer dynamischen Zusammenstellung - ist ebenfalls kein Naturgesetz.  Das Pumpen eines Schweins mit Steroiden in Form einer JIT-Zusammenstellung ist heutzutage sehr einfach: In Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Lightning</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibJIT wurde die</a> ganze Drecksarbeit bereits erledigt.  Aber die Entwicklungszeit und die Gesamtmenge an Code, selbst wenn Bibliotheken verwendet werden, wachsen enorm. </p><br><p>  Es gibt nat√ºrlich noch andere Tricks, bei denen unser kleines Schwein den Huf nicht erreicht hat.    ,     ‚Äî       - ‚Äî    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">true-grue</a> -           ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428878/">https://habr.com/ru/post/de428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428866/index.html">7 Designprinzipien, Einstellung zu Designtrends, UX-Designer-Portfolio, ...</a></li>
<li><a href="../de428868/index.html">Multi-Release-JARs - schlecht oder gut?</a></li>
<li><a href="../de428870/index.html">Mrr: Gesamt-FRP f√ºr React</a></li>
<li><a href="../de428872/index.html">Die Geschichte von einem Auge und 20 Operationen (nicht lesbar) oder er wollte Pilot werden, aber er durfte nicht in den Himmel</a></li>
<li><a href="../de428876/index.html">Es gibt kein Zur√ºck: die pers√∂nliche Erfahrung des Testers</a></li>
<li><a href="../de428880/index.html">Neue Authentifizierungsmethoden - eine Bedrohung f√ºr die Privatsph√§re?</a></li>
<li><a href="../de428882/index.html">Mobile Yandex. Blitz: Wir analysieren Aufgaben</a></li>
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428890/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung f√ºr Anf√§nger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>