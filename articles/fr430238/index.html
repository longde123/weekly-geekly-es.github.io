<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📟 🐸 👨🏾‍🎤 Un autre DSL sur Kotlin ou comment j'ai imprimé un PDF à partir de React 👨🏾‍🤝‍👨🏼 🕧 🎱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous ne pouvez pas simplement prendre et imprimer une page écrite en React: il y a des séparateurs de page, des champs de saisie. De plus, je veux écr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un autre DSL sur Kotlin ou comment j'ai imprimé un PDF à partir de React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430238/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ir/d8/d4/ird8d4jfijzncjzyjbubqxjoaiw.jpeg"></a> <br><br>  Vous ne pouvez pas simplement prendre et imprimer une page écrite en React: il y a des séparateurs de page, des champs de saisie.  De plus, je veux écrire une fois un rendu afin qu'il génère à la fois ReactDom et du HTML simple, qui peut être converti en PDF. <br><br>  La partie la plus difficile est que React a son propre dsl, et html a le sien.  Comment résoudre ce problème?  Écrivez-en un autre! <br><br>  J'ai presque oublié, tout sera écrit en Kotlin, donc c'est en fait un article sur Kotlin dsl. <br><a name="habracut"></a><br><h3>  Pourquoi avons-nous besoin de notre propre Uruk-hai? </h3><br>  Il y a beaucoup de rapports dans mon projet et tous doivent pouvoir être imprimés.  Il existe plusieurs options pour ce faire: <br><br><ul><li>  Jouez avec les styles d'impression, cachez tout ce dont vous n'avez pas besoin et espérez que tout ira bien.  Seuls les boutons, filtres et similaires seront imprimés tels quels.  Et aussi, s'il y a beaucoup de tableaux, il faut que chacun soit sur une page distincte.  Et personnellement, les liens ajoutés, les dates, etc. qui sortent lors de l'impression à partir du site me rendent furieux </li><li> Essayez d'utiliser une bibliothèque spécialisée sur react, qui peut rendre le PDF.  J'ai trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celui-ci</a> , il s'agit de la version bêta et il semble que vous ne puissiez pas réutiliser les composants de réaction ordinaires. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformez HTML en canevas</a> et faites-en un PDF.  Mais pour cela, nous avons besoin de HTML, sans boutons et similaires.  Il devra être rendu dans un élément caché afin de l'imprimer plus tard.  Mais il ne semble pas que cette option vous permette de contrôler les sauts de page. </li></ul><br>  Au final, j'ai décidé d'écrire du code capable de générer à la fois ReactDom et HTML.  J'enverrai le code HTML au backend pour imprimer le PDF en insérant des balises spéciales sur les sauts de page en cours de route. <br><br>  Kotlin possède une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque de couches</a> pour travailler avec React qui fournit un dsl de type sécurisé pour travailler avec React.  À quoi cela ressemble en général peut être trouvé dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> précédent. <br><br>  JetBrains a également écrit une bibliothèque pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générer du HTML</a> .  Il est multiplateforme, c'est-à-dire  il peut être utilisé à la fois en Java et en JS.  C'est aussi dsl, très similaire dans la structure. <br><br>  Nous devons trouver un moyen de basculer entre les bibliothèques selon que nous avons besoin de ReactDom ou de HTML pur. <br><br><h3>  Quel matériel avons-nous? </h3><br>  Par exemple, prenez un tableau avec un champ de recherche dans l'en-tête.  Voici à quoi ressemble le rendu des tableaux sur React et HTML: <br><table><tbody><tr><th>  réagir <br></th><th>  html <br></th></tr><tr><td><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> RBuilder.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderReactTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, onChangeSearch: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) { table { thead { tr { th { attrs.colSpan = <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-comment"><span class="hljs-comment">//(1) attrs.style = js { border = "solid" borderColor = "red" } //(2) +":" search(search, onChangeSearch) //(3) } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } } }</span></span></code> </pre> <br></td><td><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> TagConsumer</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;*&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderHtmlTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span> { table { thead { tr { th { colSpan = <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-comment"><span class="hljs-comment">//(1) style = """ border: solid; border-color: red; """ //(2) +": " +(search?:"") //(3) } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } } }</span></span></code> </pre><br></td></tr></tbody></table><br><br>  Notre tâche consiste à combiner les côtés gauche et droit de la table. <br><br>  Voyons d'abord quelle est la différence: <br><br><ol><li>  En html, les <code>colSpan</code> <code>style</code> et <code>colSpan</code> affectées au niveau supérieur, dans React, sur l'objet imbriqué attr </li><li>  Le style se remplit différemment.  Si, en HTML, il s'agit d'un CSS standard sous forme de chaîne, alors dans React, il s'agit d'un objet js dont les noms de champ sont légèrement différents du CSS standard en raison des limitations de JS. </li><li>  Dans la version React, nous utilisons l'entrée pour la recherche, en HTML nous affichons simplement le texte.  Cela commence déjà à partir de l'énoncé du problème. </li></ol><br>  Eh bien et le plus important: ce sont des DSL différents avec différents consommateurs et différentes API.  Pour le compilateur, ils sont complètement différents.  Il est impossible de les croiser directement, vous devrez donc écrire un calque qui aura presque le même aspect, mais qui pourra fonctionner avec React api et HTML api. <br><br><h3>  Assembler le squelette </h3><br>  Pour l'instant, il suffit de dessiner une tablette à partir d'une cellule vide: <br><br><pre> <code class="kotlin hljs">table { thead { tr { th { } } } }</code> </pre><br>  Nous avons une arborescence HTML et deux façons de la traiter.  La solution classique consiste à implémenter des modèles composites et visiteurs.  Seulement, nous n'aurons pas d'interface pour les visiteurs.  Pourquoi - cela sera vu plus tard. <br><br>  Les unités principales seront ParentTag et TagWithParent.  ParentTag est généré par la balise HTML de l'API Kotlin (Dieu merci, il est utilisé à la fois en HTML et dans l'API React), et TagWithParent stocke la balise elle-même et deux fonctions qui l'insèrent dans le parent dans deux variantes d'api. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : HTMLTag</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tags: MutableList&lt;TagWithParent&lt;*, T&gt;&gt; = mutableListOf() <span class="hljs-comment"><span class="hljs-comment">//     protected fun RDOMBuilder&lt;T&gt;.withChildren() { ... } //  reactAppender    protected fun T.withChildren() { ... } //  htmlAppender    } class TagWithParent&lt;T, P : HTMLTag&gt;( val tag: T, val htmlAppender: (T, P) -&gt; Unit, val reactAppender: (T, RDOMBuilder&lt;P&gt;) -&gt; Unit )</span></span></code> </pre><br>  Pourquoi avez-vous besoin de tant de génériques?  Le problème est que dsl pour HTML est très strict lors de la compilation.  Si dans React vous pouvez appeler td de n'importe où, même à partir d'un div, alors dans le cas de HTML, vous ne pouvez l'appeler qu'à partir du contexte de tr.  Par conséquent, nous devrons faire glisser le contexte de compilation sous forme de générique partout. <br><br>  La plupart des balises sont orthographiées à peu près de la même manière: <br><br><ol><li>  Nous mettons en œuvre deux méthodes de visite.  Un pour React, un pour HTML.  Ils sont responsables du rendu final.  Ces méthodes ajoutent des styles, des classes et similaires. </li><li>  Nous écrivons une extension qui insère la balise dans le parent. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Voici un exemple de thead</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THead</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ParentTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">THEAD</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TABLE</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.thead { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TABLE</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.thead { withChildren() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Table.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THead</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { tags += TagWithParent(THead().also(block), THead::visit, THead::visit) }</code> </pre><br></div></div><br>  Enfin, vous pouvez expliquer pourquoi l'interface pour visiteur n'a pas été utilisée.  Le problème est que tr peut être inséré à la fois dans la tête et dans le corps.  Je ne pouvais pas l'exprimer dans le cadre d'une interface.  Quatre surcharges de la fonction de visite sont sorties. <br><br><div class="spoiler">  <b class="spoiler_title">Un tas de duplication qui ne peut être évitée</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tr</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classes: String? ) : ParentTag&lt;TR&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THEAD</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">THEAD</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RDOMBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TBODY</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { builder.tr(classes) { withChildren() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TBODY</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { builder.tr(classes) { withChildren() } } }</code> </pre><br></div></div><br><h3>  Construire de la viande </h3><br>  Ajoutez du texte à la cellule: <br><br><pre> <code class="kotlin hljs"> table { thead { tr { th { +<span class="hljs-string"><span class="hljs-string">": "</span></span> } } } }</code> </pre><br>  La mise au point avec '+' est assez simple: il suffit de redéfinir unaryPlus dans les balises, qui peut inclure du texte, est suffisant. <br><br><pre> <code class="plaintext hljs">abstract class TableCell&lt;T : HTMLTag&gt; : ParentTag&lt;T&gt;() { operator fun String.unaryPlus() { ... } }</code> </pre><br>  Cela vous permet d'appeler '+' dans le contexte de td ou th, ce qui ajoutera une balise avec du texte à l'arborescence. <br><br><h3>  Scalp la peau </h3><br>  Maintenant, nous devons traiter des endroits qui diffèrent dans le html et réagir à l'api.  Une petite différence avec colSpan est résolue par elle-même, mais la différence dans la formation du style est plus compliquée.  Si quelqu'un ne le sait pas, dans React, le style est un objet JS et vous ne pouvez pas utiliser de trait d'union dans le nom du champ.  Donc, camelCase est utilisé à la place.  Dans l'API HTML, nous voulons des CSS réguliers de notre part.  Nous avons encore besoin de ceci et de cela en même temps. <br><br>  Je pourrais essayer de mettre automatiquement camelCase en trait d'union et de le laisser comme dans React api, mais je ne sais pas si cela fonctionnera toujours.  Par conséquent, j'ai écrit une autre couche: <br><br><div class="spoiler">  <b class="spoiler_title">Qui n'est pas paresseux, peut voir à quoi ça ressemble</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Style</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> border: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> padding: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> background: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Style</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { callback() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toHtmlStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = properties .map { it.html to it.property(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } .filter { (_, value) -&gt; value != <span class="hljs-literal"><span class="hljs-literal">null</span></span> } .joinToString(<span class="hljs-string"><span class="hljs-string">"; "</span></span>) { (name, value) -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$value</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toReactStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = js(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>) properties .map { it.react to it.property(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } .filter { (_, value) -&gt; value != <span class="hljs-literal"><span class="hljs-literal">null</span></span> } .forEach { (name, value) -&gt; result[name] = value.toString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.unsafeCast&lt;String&gt;() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StyleProperty</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> html: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> react: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> property: Style.() -&gt; Any? ) <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> properties = listOf( StyleProperty(<span class="hljs-string"><span class="hljs-string">"border"</span></span>, <span class="hljs-string"><span class="hljs-string">"border"</span></span>) { border }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"border-color"</span></span>, <span class="hljs-string"><span class="hljs-string">"borderColor"</span></span>) { borderColor }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"width"</span></span>, <span class="hljs-string"><span class="hljs-string">"width"</span></span>) { width }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"padding"</span></span>, <span class="hljs-string"><span class="hljs-string">"padding"</span></span>) { padding }, StyleProperty(<span class="hljs-string"><span class="hljs-string">"background"</span></span>, <span class="hljs-string"><span class="hljs-string">"background"</span></span>) { background } ) } }</code> </pre><br></div></div><br>  Oui, je sais si vous voulez une propriété CSS supplémentaire - ajoutez à cette classe.  Oui, et une carte avec un convertisseur serait plus facile à mettre en œuvre.  Mais sans danger pour les caractères.  J'utilise même des énumérations à certains endroits.  Peut-être que si je n’écrivais pas pour moi, je résoudrais la question différemment. <br><br>  J'ai un peu triché et autorisé cette utilisation de la classe résultante: <br><br><pre> <code class="kotlin hljs">th { attrs.style { border = <span class="hljs-string"><span class="hljs-string">"solid"</span></span> borderColor = <span class="hljs-string"><span class="hljs-string">"red"</span></span> } }</code> </pre><br>  Comment ça se passe: dans le champ attr.style, par défaut, il y a déjà un Style () vide.  Si vous définissez l'opérateur fun invoke, l'objet peut être utilisé comme une fonction, c'est-à-dire  vous pouvez appeler <code>attrs.style()</code> , bien que le style soit un champ, pas une fonction.  Dans un tel appel, les paramètres spécifiés dans l'opérateur fun invoke doivent être passés.  Dans ce cas, il s'agit d'un paramètre - rappel: Style. () -&gt; Unité.  Comme il s'agit d'un lambda, les (crochets) sont facultatifs. <br><br><h3>  Essayer différentes armures </h3><br>  Reste à apprendre comment dessiner des entrées dans React, et juste du texte en HTML.  Je voudrais obtenir cette syntaxe: <br><br><pre> <code class="kotlin hljs">react { search(search, onChangeSearch) } html { +(search?:<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre><br>  Comment ça marche: La fonction react prend un lambda pour l'api Rreact et retourne la balise insérée.  Sur la balise, vous pouvez appeler la fonction infixe et passer le lambda à l'api HTML.  Le modificateur infix permet d'appeler html sans point.  Très similaire à if {} else {}.  Et comme dans if-else, l'appel html est facultatif, il a été utile plusieurs fois. <br><br><div class="spoiler">  <b class="spoiler_title">Implémentation</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReactTag</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : HTMLTag</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> block: RBuilder.() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {} ) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> htmlAppender: (T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">html</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>.() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { htmlAppender = block } ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : HTMLTag&gt;</span></span></span><span class="hljs-function"> ParentTag</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">react</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): ReactTag&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> reactTag = ReactTag&lt;T&gt;(block) tags += TagWithParent&lt;ReactTag&lt;T&gt;, T&gt;(reactTag, ReactTag&lt;T&gt;::visit, ReactTag&lt;T&gt;::visit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reactTag }</code> </pre><br></div></div><br><h3>  Marque de Saroumane </h3><br>  Une autre touche.  Il est nécessaire d'hériter de ParentTag et TagWithParent d'une interface spécialement enroulée avec une annotation spécialement enroulée sur laquelle se trouve une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annotation</a> spéciale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@DslMarker</a> , déjà du cœur du langage: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@DslMarker</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StyledTableMarker</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@StyledTableMarker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tag</span></span></span></span></code> </pre><br>  Ceci est nécessaire pour que le compilateur ne permette pas d'écrire des appels étranges comme ceux-ci: <br><br><pre> <code class="kotlin hljs">td { td { } } tr { thead { } }</code> </pre><br>  On ne sait cependant pas qui penserait à écrire une telle chose ... <br><br><h3>  À la bataille! </h3><br>  Tout est prêt pour que nous puissions dessiner un tableau depuis le début de l'article, mais ce code va déjà générer à la fois ReactDom et HTML.  Écrivez une fois n'importe où! <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Table.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderUniversalTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(search: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, onChangeSearch: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { thead { tr { th { attrs.colSpan = <span class="hljs-number"><span class="hljs-number">2</span></span> attrs.style { border = <span class="hljs-string"><span class="hljs-string">"solid"</span></span> borderColor = <span class="hljs-string"><span class="hljs-string">"red"</span></span> } +<span class="hljs-string"><span class="hljs-string">":"</span></span> react { search(search, onChangeSearch) <span class="hljs-comment"><span class="hljs-comment">//(*) } html { +(search?:"") } } } tr { th { +"" } th { +"" } } } tbody { tr { td { +"" } td { +"" } } tr { td { +"" } td { +"" } } } }</span></span></code> </pre><br>  Faites attention à (*) - c'est exactement la même fonction de recherche que dans la version originale du tableau pour React.  Il n'est pas nécessaire de tout transférer vers le nouveau dsl, uniquement des balises courantes. <br><br>  Quel pourrait être le résultat d'un tel code?  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple d'impression PDF d'un</a> rapport de mon projet.  Naturellement, j'ai remplacé tous les nombres et noms par des nombres aléatoires.  A titre de comparaison, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impression PDF de</a> la même page, mais par le navigateur.  Artefacts de rupture d'un tableau entre les pages à superposition de texte. <br><br>  Lors de l'écriture de dsl, vous obtenez beaucoup de code supplémentaire axé uniquement sur la forme d'utilisation.  De plus, de nombreuses fonctionnalités de Kotlin sont utilisées, auxquelles vous ne pensez même pas dans la vie quotidienne. <br><br>  Peut-être que dans d'autres cas, ce sera différent, mais il y a eu beaucoup de duplication, dont je n'ai pas pu me débarrasser (à ma connaissance, JetBarins utilise la génération de code pour écrire la bibliothèque HTML). <br><br>  Mais il s'est avéré que je construisais dsl presque similaire en apparence à l'API React et HTML (je n'ai presque pas jeté un coup d'œil).  Fait intéressant, avec la commodité de dsl, nous avons un contrôle total sur le rendu.  Vous pouvez ajouter une balise de page à des pages distinctes.  Vous pouvez étendre "l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">accordéon</a> " lors de l'impression.  Et vous pouvez essayer de trouver un moyen de réutiliser ce code sur le serveur et de générer déjà du code HTML pour les moteurs de recherche. <br><br>  PS Il y a sûrement des moyens d'imprimer des PDF plus facilement <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Navet avec source pour l'article</a> <br><br><div class="spoiler">  <b class="spoiler_title">Autres articles sur Kotlin:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'arrière-goût de Kotlin, partie 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'arrière-goût de Kotlin, partie 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arrière-goût de Kotlin, partie 3. Coroutines - partager le temps processeur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kotlin + React contre Javasript + React</a> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430238/">https://habr.com/ru/post/fr430238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430226/index.html">De la var b à l'interview</a></li>
<li><a href="../fr430228/index.html">Marques en forme de X comme méthode d'identification radar utilisant l'analyse de données ouvertes de deux satellites scientifiques SENTINEL-1</a></li>
<li><a href="../fr430230/index.html">Comment garder sa place dans une startup en pleine croissance</a></li>
<li><a href="../fr430232/index.html">Génération de Close call dans les jeux: «Au bord de la défaite» ou «Presque gagné»</a></li>
<li><a href="../fr430236/index.html">La NASA annonce un nouveau vol lunaire</a></li>
<li><a href="../fr430240/index.html">Vulnérabilité liée au nombre pseudo-aléatoire de Bitcoin</a></li>
<li><a href="../fr430242/index.html">OpenSceneGraph: Nœuds de groupe, nœuds de transformation et nœuds de commutation</a></li>
<li><a href="../fr430244/index.html">SpaceX a reçu l'autorisation de déployer un réseau de satellites de 11943 satellites</a></li>
<li><a href="../fr430246/index.html">Délocalisation vers le socialisme autrichien</a></li>
<li><a href="../fr430252/index.html">Ennemi à l'intérieur: comment je suis entré dans le délit d'initié</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>