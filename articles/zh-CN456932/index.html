<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 💛 🍤 超现代的OpenGL。 第一部分 ❣️ 🎭 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 稍微了解OpenGL主题的每个人都知道有很多关于该主题的文章和课程，但是许多文章和课程都不会影响现代API，其中有些通常谈论glBegin和glEnd 。 从版本4开始，我将尝试介绍新API的一些细微差别。 链接到文章的第二部分 

 这次，我将尝试写一篇有趣且内容丰富的文章，而所发生的一切...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>超现代的OpenGL。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456932/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br> 大家好 稍微了解OpenGL主题的每个人都知道有很多关于该主题的文章和课程，但是许多文章和课程都不会影响现代API，其中有些通常谈论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBegin</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glEnd</a> 。 从版本4开始，我将尝试介绍新API的一些细微差别。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到文章的第二部分</a> <br><a name="habracut"></a><br> 这次，我将尝试写一篇有趣且内容丰富的文章，而所发生的一切取决于好哈勃拉居民的决定。 请原谅我的语法不佳（我将感谢您的更正）。 <br><br> 如果您愿意，我将写有关优化OpenGL和减少DrawCalls的文章。 <br><br> 让我们开始吧！ <br><br>  <font color="#008000">本文的内容-现代OpenGL的功能</font> <br>  <font color="#FF0000">本文不做的事情-在OpenGL上渲染的现代方法</font> <br><br><div class="spoiler">  <b class="spoiler_title">内容：</b> <div class="spoiler_text"><ul><li> 直接状态访问 </li><li> 除错 </li><li> 单独的着色器对象 </li><li> 纹理数组 </li><li> 纹理视图 </li><li> 索引和顶点的单个缓冲区 </li><li> 镶嵌和计算着色 </li><li> 路径渲染 </li></ul><br></div></div><br><h3>  <font color="#4682B4">DSA（直接状态访问）</font> </h3><br> 直接状态访问-直接访问状态。 用于修改OpenGL对象而无需将其捕捉到上下文的工具。 这使您可以在本地上下文中更改对象的状态，而不会影响应用程序所有部分共享的全局状态。 这也使API更加面向对象，因为可以清楚地定义更改对象状态的函数。 这就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenGL Wiki</a>告诉我们的。 <br><br> 众所周知，OpenGL是具有许多单选按钮的API- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glActiveTexture</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindTexture</a>等。 <br><br> 从这里我们有一些<font color="#DC143C">问题</font> ： <br><br><ul><li> 选择器和当前状态可以使状态发生更深的变化。 </li><li> 可能需要绑定/更改活动单元以设置纹理过滤器 </li><li> 状态管理成为问题，结果导致应用程序的复杂性增加 </li><li> 状态未知会导致其他设置 </li><li> 尝试保存/恢复状态可能会出现问题 </li></ul><br>  Khronos小组为我们提供了什么？DSA有何帮助？ <br><br><ul><li> 添加直接与一个或多个对象一起使用的功能 </li><li> 为指定的纹理对象而不是当前对象设置纹理过滤器。 </li><li> 将纹理绑定到特定单元，而不是活动对象 </li><li> 添加了大量新功能 </li><li> 涵盖OpenGL 1.x之前的内容 </li><li> 添加了额外的功能。 </li></ul><br> 从理论上讲，DSA可以帮助将非渲染和状态更改操作的数量减少到零...但这是不准确的。 <br><br> 现在，我将简要介绍一些新功能，不再详细介绍参数，而是将链接留在Wiki上。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glCreateTextures</a>替换了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glGenTextures</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindTexture</a> （初始化）。 <br> 那是： <br><pre><code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;name); glBindTexture(GL_TEXTURE_2D, name);</code> </pre> 它变成了： <br><pre> <code class="cpp hljs">glCreateTextures(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;name);</code> </pre> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glTextureParameterX</a>等效于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glTexParameterX</a> <pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;name); glBindTexture(GL_TEXTURE_2D, name); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexStorage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA8, width, height); glTexSubImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> 现在，我们将这样编写它： <br><pre> <code class="cpp hljs">glCreateTextures(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;name); glTextureParameteri(name, GL_TEXTURE_WRAP_S, GL_CLAMP); glTextureParameteri(name, GL_TEXTURE_WRAP_T, GL_CLAMP); glTextureParameteri(name, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTextureParameteri(name, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTextureStorage2D(name, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA8, width, height); glTextureSubImage2D(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindTextureUnit</a>替换<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glActiveTexture</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindTexture</a> <br> 这是我们的操作方式： <br><pre> <code class="cpp hljs">glActiveTexture(GL_TEXTURE0 + <span class="hljs-number"><span class="hljs-number">3</span></span>); glBindTexture(GL_TEXTURE_2D, name);</code> </pre> 现在： <br><pre> <code class="cpp hljs">glBindTextureUnit(<span class="hljs-number"><span class="hljs-number">3</span></span>, name);</code> </pre> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所做</a>的更改也影响了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glTextureImage</a> ，它不再使用，这是为什么： <br><br>  glTexImage是相当不安全的，很容易获得无效的纹理，因为该函数在调用时不检查值，驱动程序在绘制时执行此操作。 添加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GlTexStorage</a>来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">替换它</a> 。 <br><br>  glTexStorage提供了一种通过调用过程中执行的检查来创建纹理的方法，从而最大程度地减少了错误。 尽管可变纹理更可靠，但大多数（即使不是全部）由可变纹理引起的问题也可以解决纹理存储库。 <br><br> 更改还影响了帧缓冲区： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glCreateFramebuffers</a>代替<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glGenFramebuffers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glNamedFramebufferTexture</a>替换<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glFramebufferTexture</a> </li></ul><br> 这些并非全部已更改的功能。 下一行是缓冲区的功能： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glCreateBuffers</a>代替<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glGenBuffers</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindBuffer</a> （初始化） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glNamedBufferData</a>替换<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBufferData</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glVertexAttribFormat</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindVertexBuffer</a>代替<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glVertexAttribPointer</a> </li></ul><br> 以下是DSA支持中现在包含的内容的列表： <br><br><ul><li> 顶点数组对象 </li><li> 帧缓冲对象 </li><li> 程序对象 </li><li> 缓冲对象 </li><li> 矩阵堆栈 </li><li> 很多过时的东西 </li></ul><br><h3>  <font color="#4682B4">除错</font> </h3><br> 从4.3版开始，我认为调试已添加了新功能，非常有用和方便。 现在，OpenGL将调用我们的回调以获取错误和调试消息，我们可以对其进行调整。 <br><br><img src="https://habrastorage.org/webt/t-/m7/1n/t-m71nmkhv4-khfdlpb99wekjxq.jpeg"><br><br> 我们只需要调用两个函数即可启用它们： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glEnable</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glDebugMessageCallback</a> ，再简单不过了。 <br><br><pre> <code class="cpp hljs">glEnable(GL_DEBUG_OUTPUT); glDebugMessageCallback(message_callback, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>);</code> </pre> <br> 现在，我们将编写一个回调函数来获取消息： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLchar </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* user_param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> source_str = [source]() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (source) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_API: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"API"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_WINDOW_SYSTEM: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"WINDOW SYSTEM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_SHADER_COMPILER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SHADER COMPILER"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_THIRD_PARTY: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"THIRD PARTY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_APPLICATION: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"APPLICATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SOURCE_OTHER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OTHER"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"UNKNOWN"</span></span>; } }(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type_str = [type]() { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ERROR"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DEPRECATED_BEHAVIOR"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"UNDEFINED_BEHAVIOR"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_PORTABILITY: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"PORTABILITY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_PERFORMANCE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"PERFORMANCE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_MARKER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"MARKER"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_TYPE_OTHER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OTHER"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"UNKNOWN"</span></span>; } }(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> severity_str = [severity]() { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (severity) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SEVERITY_NOTIFICATION: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NOTIFICATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SEVERITY_LOW: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"LOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SEVERITY_MEDIUM: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"MEDIUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_DEBUG_SEVERITY_HIGH: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"HIGH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"UNKNOWN"</span></span>; } }(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; source_str &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; type_str &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; severity_str &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; message &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br> 我们还可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glDebugMessageControl</a>配置过滤器。 过滤器可以按源/类型/重要性或使用其标识符的一组消息在过滤模式下工作。 <br><br> 过滤特定范围内的消息： <br><br><pre> <code class="cpp hljs">glPushDebugGroup( GL_DEBUG_SOURCE_APPLICATION, DEPTH_FILL_ID, <span class="hljs-number"><span class="hljs-number">11</span></span>, “Depth Fill”); <span class="hljs-comment"><span class="hljs-comment">//  Render_Depth_Only_Pass(); //  glPopDebugGroup(); // </span></span></code> </pre> <br> 禁用异步调用非常有用，这样我们可以确定函数调用的顺序，以及在调试时在堆栈上查找错误的位置。 这很简单地完成： <br><br><pre> <code class="cpp hljs">glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);</code> </pre> <br> 值得记住的是，在包装的调用函数中调用OpenGL或窗口函数并不安全，并且回调函数不是免费的，因此您不应将其包含在发行版本中。 <br> 有关这些以及其他小事情的更多详细信息-mm头，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读。 <br><br><h3>  <font color="#4682B4">SSO（单独的着色器对象）</font> </h3><br> 一旦OpenGL成为“固定管道”，这意味着预编程处理将应用于为可视化传输的所有数据。 下一步是“可编程流水线”-可编程部分实现以GLSL编写的着色器，经典的GLSL程序由顶点和片段着色器组成，但是在现代OpenGL中添加了一些新类型的着色器，即几何形状，权重和计算的着色器（关于它们我将在下一部分中讲述）。 <br><br><img src="https://habrastorage.org/webt/lg/or/rg/lgorrggfshrf8xdb6vbwu4fw-so.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSO</a>允许我们即时更改着色器步骤，而无需重新链接它们。 创建和设置简单的软件管道而不进行调试如下： <br><br><pre> <code class="cpp hljs">GLuint pipe = GL_NONE; <span class="hljs-comment"><span class="hljs-comment">// Create shaders GLuint fprog = glCreateShaderProgramv( GL_FRAGMENT_SHADER, 1, &amp;text); GLuint vprog = glCreateShaderProgramv( GL_VERTEX_SHADER, 1, &amp;text); // Bind pipeline glGenProgramPipelines( 1, &amp;pipe); glBindProgramPipelines( pipe); // Bind shaders glUseProgramStages( pipe, GL_FRAGMENT_SHADER_BIT, fprog); glUseProgramStages( pipe, GL_VERTEX_SHADER_BIT, vprog);</span></span></code> </pre> <br> 如我们所见， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glCreateProgramPipelines</a>生成描述符并初始化对象， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glCreateShaderProgramv</a>使用指定的源生成，初始化，编译和链接着色器程序， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glUseProgramStages</a>将程序步骤附加到管道对象。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">glBindProgramPipeline-将</a>管道与上下文关联。 <br><br> 但是有一个警告，现在着色器的输入和输出参数必须匹配。 我们可以使用相同的名称，相同的顺序声明输入/输出参数，或者在限定符的帮助下使它们的位置明显一致。 <br> 我建议使用后一种选项，这将使我们能够配置清晰定义的界面，并且在名称和顺序方面具有灵活性。 <br><br> 为了提供更严格的接口，我们还需要声明要在每个阶段使用的内置输入和输出块。 <br><br> 内置的块接口定义为（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来自wiki</a> ）： <br> 顶点： <br><br><pre> <code class="cpp hljs">out gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; };</code> </pre> <br> 镶嵌控制： <br><pre> <code class="cpp hljs">out gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_out[];</code> </pre> <br> 镶嵌评估： <br><pre> <code class="cpp hljs">out gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; };</code> </pre> <br> 几何形状： <br><pre> <code class="cpp hljs">out gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; };</code> </pre> <br> 重新声明内置模块并在常规顶点着色器中使用属性位置的示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 out gl_PerVertex { vec4 gl_Position; }; layout (location = 0) in vec3 position; layout (location = 1) in vec3 color; layout (location = 0) out v_out { vec3 color; } v_out; void main() { v_out.color = color; gl_Position = vec4(position, 1.0); }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456932/">https://habr.com/ru/post/zh-CN456932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456920/index.html">俄罗斯的Sony Xperia 1-价格和预购奖金</a></li>
<li><a href="../zh-CN456922/index.html">处理器的设计和制造方式：计算机体系结构的基础</a></li>
<li><a href="../zh-CN456926/index.html">我们如何做Sportmaster</a></li>
<li><a href="../zh-CN456928/index.html">JMeter-瑞士测试仪刀（第1部分）</a></li>
<li><a href="../zh-CN456930/index.html">将物联网带给大众：GeekBrains和Rostelecom的首次物联网黑客马拉松的成果</a></li>
<li><a href="../zh-CN456936/index.html">SwiftUI上的动画卡</a></li>
<li><a href="../zh-CN456938/index.html">在东京启动出租车叫车应用程序：索尼如何与S. Ride配合使用？</a></li>
<li><a href="../zh-CN456942/index.html">期限众多或分析的广泛使用</a></li>
<li><a href="../zh-CN456944/index.html">3个在JavaScript中使用解构的实际示例</a></li>
<li><a href="../zh-CN456946/index.html">用于Kubernetes管理的Grafana面板</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>