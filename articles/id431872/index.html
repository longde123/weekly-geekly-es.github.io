<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöí ‚óºÔ∏è ‚òéÔ∏è Panduan JavaScript Bagian 9: Tinjauan Umum tentang Standar ES7, ES8, dan ES9 üßõüèΩ üï≥Ô∏è üë®üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, di bagian kesembilan dari terjemahan manual JavaScript, tinjauan umum akan dibuat dari fitur-fitur yang muncul dalam bahasa berkat standar E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan JavaScript Bagian 9: Tinjauan Umum tentang Standar ES7, ES8, dan ES9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431872/">  Hari ini, di bagian kesembilan dari terjemahan manual JavaScript, tinjauan umum akan dibuat dari fitur-fitur yang muncul dalam bahasa berkat standar ES7, ES8, dan ES9. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: program pertama, fitur bahasa, standar</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: gaya kode dan struktur program</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: variabel, tipe data, ekspresi, objek</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: fungsi</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: array dan loop</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 6: pengecualian, titik koma, literal wildcard</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 7: mode ketat, kata kunci ini, acara, modul, perhitungan matematis</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8: Gambaran Umum Fitur ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 9: Gambaran Umum Standar ES7, ES8, dan ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Standar ES7</font> </h2><br>  Standar ES7, yang, sesuai dengan terminologi resmi, disebut ES2016, dirilis pada musim panas 2016.  Dia, dibandingkan dengan ES6, dibawa ke bahasa tidak banyak yang baru.  Secara khusus, kita berbicara tentang hal-hal berikut: <br><br><ul><li> <code>Array.prototype.includes()</code> . </li><li>  Operator eksponensial. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Metode Array.prototype.includes ()</font> </h3><br>  Metode <code>Array.prototype.includes()</code> dirancang untuk memeriksa keberadaan elemen dalam array.  Menemukan yang diinginkan dalam array, mengembalikan <code>true</code> , bukan menemukan - <code>false</code> .  Sebelum ES7, metode <code>indexOf()</code> digunakan untuk melakukan operasi yang sama, yang mengembalikan, jika elemen ditemukan, indeks pertama yang dapat ditemukan dalam array.  Jika <code>indexOf()</code> tidak menemukan elemen, ia mengembalikan angka <code>-1</code> . <br><br>  Menurut aturan konversi tipe JavaScript, angka <code>-1</code> dikonversi menjadi <code>true</code> .  Sebagai hasilnya, untuk memeriksa hasil operasi <code>indexOf()</code> seseorang harus menggunakan konstruksi yang tidak nyaman dari bentuk berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  Jika dalam situasi yang sama, dengan asumsi <code>indexOf()</code> , tanpa menemukan elemen, mengembalikan <code>false</code> , menggunakan sesuatu seperti yang ditunjukkan di bawah ini, kode tidak akan berfungsi dengan benar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// console.log('Not found') }</span></span></code> </pre> <br>  Dalam kasus ini, ternyata konstruksi <code>![1,2].indexOf(3)</code> <code>false</code> . <br><br>  Menggunakan metode <code>includes()</code> , perbandingan seperti itu terlihat jauh lebih logis. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].includes(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  Dalam hal ini, konstruksi <code>[1,2].includes(3)</code> mengembalikan <code>false</code> , nilai ini adalah operator <code>!</code>  berubah menjadi <code>true</code> dan konsol menerima pesan yang menyatakan bahwa item dalam array tidak ditemukan. <br><br><h3>  <font color="#3AC1EF">‚ñç operator eksponensial</font> </h3><br>  Operator eksponensial melakukan fungsi yang sama dengan metode <code>Math.pow()</code> , tetapi lebih nyaman untuk menggunakannya daripada fungsi perpustakaan, karena merupakan bagian dari bahasa. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Operator ini dapat dianggap sebagai tambahan yang menyenangkan untuk JS, yang berguna dalam aplikasi yang melakukan perhitungan tertentu.  Operator serupa ada dalam bahasa pemrograman lain. <br><br><h2>  <font color="#3AC1EF">Standar ES8</font> </h2><br>  Standar ES8 (ES2017) dirilis pada tahun 2017.  Dia, seperti ES7, tidak membawa banyak ke bahasa.  Yaitu, kita berbicara tentang fitur-fitur berikut: <br><br><ul><li>  Menambahkan string ke panjang tertentu. </li><li>  Metode <code>Object.values()</code> . </li><li>  Metode <code>Object.entries()</code> . </li><li>  Metode <code>Object.getOwnPropertyDescriptors()</code> . </li><li>  Membuntuti koma dalam parameter fungsi. </li><li>  Fungsi asinkron. </li><li>  Bekerja dengan memori bersama dan operasi atom. </li></ul><br><h3>  <font color="#3AC1EF">‚ñçMenambahkan garis dengan panjang tertentu</font> </h3><br>  ES8 memperkenalkan dua metode objek <code>String</code> baru - <code>padStart()</code> dan <code>padEnd()</code> . <br><br>  Metode <code>padStart()</code> mengisi baris saat ini dengan baris lain sampai garis akhir mencapai panjang yang diinginkan.  Pengisian terjadi di awal baris (kiri).  Inilah cara menggunakan metode ini. <br><br><pre> <code class="javascript hljs">str.padStart(targetLength [, padString])</code> </pre> <br>  Di sini <code>str</code> adalah garis saat ini, <code>targetLength</code> adalah panjang dari garis akhir (jika kurang dari panjang garis saat ini, garis ini akan dikembalikan tanpa perubahan), <code>padString</code> adalah parameter opsional - garis yang digunakan untuk mengisi garis saat ini.  Jika <code>padString</code> tidak ditentukan, karakter spasi digunakan untuk <code>padString</code> garis saat ini dengan panjang yang ditentukan. <br><br>  Metode <code>padEnd()</code> mirip dengan <code>padStart()</code> , tetapi baris diisi di sebelah kanan. <br><br>  Pertimbangkan contoh penggunaan metode ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">'`</span></span>) <span class="hljs-comment"><span class="hljs-comment">//'      test' console.log(`'${str1}'`) //'test******'</span></span></code> </pre> <br>  Di sini, ketika menggunakan <code>padStart()</code> dengan hanya panjang yang diinginkan dari string yang dihasilkan, spasi ditambahkan ke awal string asli.  Saat menggunakan <code>padEnd()</code> dengan panjang baris terakhir dan baris untuk mengisinya, karakter <code>*</code> ditambahkan ke akhir baris asli. <br><br><h3>  <font color="#3AC1EF">‚ñç Metode Object.values ‚Äã‚Äã()</font> </h3><br>  Metode ini mengembalikan array yang berisi nilai properti objek sendiri, yaitu properti yang berisi objek itu sendiri, dan bukan yang dapat diakses melalui rantai prototipe. <br><br>  Inilah cara menggunakannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// ['Fred', 87]</span></span></code> </pre> <br>  Metode ini juga berlaku untuk array. <br><br><h3>  <font color="#3AC1EF">‚ñç Metode Object.entries ()</font> </h3><br>  Metode ini mengembalikan array, masing-masing elemen yang juga merupakan array yang mengandung, dalam format <code>[key, value]</code> , kunci dan nilai properti objek sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// [['name', 'Fred'], ['age', 87]]</span></span></code> </pre> <br>  Saat menerapkan metode ini ke array, indeks elemen ditampilkan sebagai kunci, dan apa yang disimpan dalam array di indeks terkait ditampilkan sebagai nilai. <br><br><h3>  <font color="#3AC1EF">‚ñç metode getOwnPropertyDescriptors ()</font> </h3><br>  Metode ini mengembalikan informasi tentang semua properti objek itu sendiri.  Set atribut (deskriptor) dikaitkan dengan properti objek.  Secara khusus, kita berbicara tentang atribut-atribut berikut: <br><br><ul><li>  <code>value</code> - nilai properti dari objek. </li><li>  <code>writable</code> - berisi <code>true</code> jika properti dapat diubah. </li><li>  <code>get</code> - berisi fungsi getter yang terkait dengan properti, atau, jika tidak ada fungsi seperti itu, <code>undefined</code> . </li><li>  <code>set</code> - berisi fungsi setter untuk properti atau <code>undefined</code> . </li><li>  <code>configurable</code> - jika <code>false</code> - properti tidak dapat dihapus, atributnya tidak dapat diubah kecuali untuk nilainya. </li><li>  <code>enumerable</code> - jika benar terkandung dalam properti ini - <code></code> itu enumerable. </li></ul><br>  Inilah cara menggunakan metode ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj)</code> </pre> <br>  Dibutuhkan objek yang informasinya perlu Anda ketahui, dan mengembalikan objek yang berisi informasi ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propDescr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(propDescr) <span class="hljs-comment"><span class="hljs-comment">/* { name:  { value: 'Fred',    writable: true,    enumerable: true,    configurable: true }, age:  { value: 87,    writable: true,    enumerable: true,    configurable: true } } */</span></span></code> </pre> <br>  Mengapa metode ini dibutuhkan?  Faktanya adalah memungkinkan Anda untuk membuat salinan kecil objek, menyalin, di samping properti lainnya, getter dan setter.  Ini tidak dapat dilakukan dengan menggunakan metode <code>Object.assign()</code> , yang muncul dalam standar ES6, untuk menyalin objek. <br><br>  Contoh berikut memiliki objek dengan setter yang menampilkan, menggunakan <code>console.log()</code> , apa yang mereka coba tulis ke properti terkait. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person1 = { set name(newName) {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newName) } } person1.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">// x</span></span></code> </pre> <br>  Mari kita coba salin objek ini menggunakan metode <code>assign()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person2 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(person2, person1) person2.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   </span></span></code> </pre> <br>  Seperti yang Anda lihat, pendekatan ini tidak berhasil.  Properti <code>name</code> , yang merupakan setter pada objek asli, sekarang direpresentasikan sebagai properti biasa. <br><br>  Sekarang kita akan menyalin objek menggunakan metode <code>Object.defineProperties()</code> (muncul di ES5.1) dan <code>Object.getOwnPropertyDescriptors()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person3 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(person3, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person1)) person3.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//x</span></span></code> </pre> <br>  Di sini, penyetel tetap dalam salinan objek. <br><br>  Perlu dicatat bahwa batasan khusus untuk <code>Object.assign()</code> juga merupakan karakteristik dari metode <code>Object.create()</code> ketika digunakan untuk mengkloning objek. <br><br><h3>  <font color="#3AC1EF">‚ñçCompletion koma pada parameter fungsi</font> </h3><br>  Fitur ini memungkinkan Anda untuk meninggalkan koma di akhir daftar parameter atau argumen, masing-masing, ketika mendeklarasikan dan ketika memanggil fungsi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> var1, var2, </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } doSomething( 'test1', 'test2', )</span></span></code> </pre> <br>  Ini meningkatkan kegunaan sistem kontrol versi.  Yaitu, kita berbicara tentang fakta bahwa ketika menambahkan parameter baru ke suatu fungsi, Anda tidak perlu mengubah kode yang ada hanya untuk memasukkan koma. <br><br><h3>  <font color="#3AC1EF">‚ñçFungsi Asinkron</font> </h3><br>  Konstruksi <code>async/await</code> wait telah muncul dalam standar ES2017, yang dapat dianggap sebagai inovasi terpenting dari versi bahasa ini. <br><br>  Fungsi asinkron adalah kombinasi dari janji dan generator, mereka menyederhanakan konstruksi yang sebelumnya membutuhkan sejumlah besar kode templat dan rantai janji yang tidak nyaman untuk dijelaskan.  Bahkan, kita berbicara tentang abstraksi tingkat tinggi atas janji. <br><br>  Ketika janji muncul dalam standar ES2015, mereka dirancang untuk memecahkan masalah yang ada dengan kode asinkron, yang mereka lakukan.  Tetapi selama dua tahun yang berbagi standar ES2015 dan ES2017, menjadi jelas bahwa janji tidak dapat dianggap sebagai solusi akhir untuk masalah ini. <br><br>  Secara khusus, janji-janji itu ditujukan untuk memecahkan masalah "panggilan balik neraka", tetapi, setelah menyelesaikan masalah ini, mereka sendiri tidak menunjukkan sisi terbaiknya karena kompleksitas kode yang digunakan.  Faktanya, konstruksi <code>async/await</code> menyelesaikan masalah janji dan meningkatkan kegunaan kode asinkron. <br><br>  Pertimbangkan sebuah contoh. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Kode ini akan menampilkan yang berikut ke konsol. <br><br><pre> <code class="javascript hljs">Before After I did something</code> </pre> <br>  Seperti yang Anda lihat, setelah memanggil <code>doSomething()</code> program terus berjalan, setelah <code>Before</code> , <code>After</code> ditampilkan di konsol, dan setelah tiga detik berlalu, <code>I did something</code> . <br><br><h4>  Panggilan fungsi asinkron serial </h4><br>  Jika perlu, fungsi asinkron dapat membentuk sesuatu seperti serangkaian panggilan.  Desain seperti itu dibedakan oleh keterbacaan yang lebih baik daripada yang serupa, hanya berdasarkan janji.  Ini bisa dilihat pada contoh berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promiseToDoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)=&gt;</span></span>{     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneWatchingSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">// I did something and I watched and I watched as well })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Memori bersama dan operasi atom</font> </h3><br>  Di sini kita berbicara tentang objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SharedArrayBuffer</a> , yang memungkinkan kita untuk menggambarkan area memori bersama, dan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atomics</a> , yang berisi serangkaian operasi atom dalam bentuk metode statis.  Rincian tentang kemungkinan yang diberikan benda-benda ini kepada programmer dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Standar ES9</font> </h2><br>  ES9 (ES2018) adalah versi terbaru dari standar pada saat publikasi materi ini.  Berikut adalah fitur utamanya: <br><br><ul><li>  Terapkan pernyataan spread dan rest ke objek. </li><li>  Iterator Asinkron. </li><li>  Metode <code>Promise.prototype.finally()</code> . </li><li>  Peningkatan ekspresi reguler. </li></ul><br><h3>  <font color="#3AC1EF">‚ñçAplikasi operator penyebaran dan istirahat ke objek</font> </h3><br>  Kami telah berbicara tentang operator lain dan yang menyebar yang muncul di ES6 dan dapat digunakan untuk bekerja dengan array.  Keduanya terlihat seperti tiga titik.  Operator sisanya, dalam contoh berikut ini merusak array, memungkinkan Anda untuk menempatkan elemen pertama dan kedua dalam konstanta <code>first</code> dan <code>second</code> , dan semua sisanya di konstanta yang <code>others</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, ...others] = numbers <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //[ 3, 4, 5 ]</span></span></code> </pre> <br>  Operator <code>spread</code> memungkinkan Anda meneruskan array ke fungsi yang mengharapkan daftar parameter reguler. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c, d, e</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b + c + d + e <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = sum(...numbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">//15</span></span></code> </pre> <br>  Sekarang, menggunakan pendekatan yang sama, Anda bisa bekerja dengan objek.  Berikut adalah contoh penggunaan pernyataan lainnya dalam operasi penugasan yang merusak. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { first, second, ...others } = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fourth</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">fifth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //{ third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br>  Berikut adalah pernyataan spread yang digunakan saat membuat objek baru berdasarkan yang sudah ada.  Contoh ini melanjutkan yang sebelumnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = { first, second, ...others } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(items) <span class="hljs-comment"><span class="hljs-comment">//{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">ItAkron sinkron</font> </h3><br>  Konstruksi <code>for-await-of</code> memungkinkan Anda untuk memanggil fungsi asinkron yang mengembalikan janji dalam loop.  Loop semacam itu menunggu resolusi janji sebelum melanjutkan ke langkah berikutnya.  Ini tampilannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> readLines(filePath)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(line) }</code> </pre> <br>  Pada saat yang sama, perlu dicatat bahwa loop tersebut harus digunakan dalam fungsi asinkron - cara yang sama seperti ketika bekerja dengan <code>async/await</code> konstruksi. <br><br><h3>  <font color="#3AC1EF">‚ñç Metode Promise.prototype.finally ()</font> </h3><br>  Jika janji berhasil diselesaikan, metode selanjutnya <code>then()</code> dipanggil.  Jika terjadi kesalahan, metode <code>catch()</code> dipanggil.  Metode <code>finally()</code> memungkinkan Anda untuk mengeksekusi beberapa kode terlepas dari apa yang terjadi sebelumnya. <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'file.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error)) .finally(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'finished'</span></span>))</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Peningkatan Ekspresi Reguler</font> </h3><br>  Ekspresi reguler memiliki kemampuan untuk memeriksa string secara retrospektif ( <code>?&lt;=</code> ).  Ini memungkinkan Anda untuk mencari konstruksi tertentu di baris sebelum yang ada beberapa konstruksi lainnya. <br><br>  Kemampuan untuk mendahului pemeriksaan menggunakan <code>?=</code> Konstruksikan hadir dalam ekspresi reguler yang diterapkan dalam JavaScript sebelum standar ES2018.  Cek tersebut memberi tahu Anda apakah fragmen lain mengikuti fragmen tertentu dari suatu garis. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?= Waters)/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  Konstruksi <code>?!</code>  melakukan operasi yang berlawanan - kecocokan hanya akan ditemukan jika garis lain tidak mengikuti garis yang diberikan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?! Waters)/g</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br>  Dalam verifikasi retrospektif, sebagaimana telah disebutkan, konstruksinya <code>?&lt;=</code> digunakan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  Operasi yang berlawanan dengan yang dijelaskan dapat dilakukan menggunakan konstruksi <code>?&lt;!</code>  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br><h4>  Unicode regex escape sequence </h4><br>  Dalam ekspresi reguler, Anda bisa menggunakan kelas <code>\d</code> yang cocok dengan digit apa pun, kelas <code>\s</code> yang cocok dengan karakter spasi apa pun, kelas <code>\w</code> yang cocok dengan karakter alfanumerik apa pun, dan sebagainya.  Fitur yang dipermasalahkan memperluas serangkaian kelas yang dapat digunakan dalam ekspresi reguler, memungkinkan Anda untuk bekerja dengan urutan Unicode.  Kita berbicara tentang kelas <code>\p{}</code> dan kebalikan dari kelas <code>\P{}</code> . <br><br>  Dalam Unicode, setiap karakter memiliki seperangkat properti.  Properti ini ditunjukkan dalam kurung grup <code>\p{}</code> .  Jadi, misalnya, properti <code>Script</code> menentukan keluarga bahasa yang dimiliki karakter, properti <code>ASCII</code> , logis, <code>true</code> untuk karakter ASCII, dan sebagainya.  Misalnya, kami akan mencari tahu apakah beberapa baris hanya berisi karakter ASCII. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('ABC@')) //true console.log(r.test('ABC')) //false</span></span></code> </pre> <br>  Properti <code>ASCII_Hex_Digit</code> <code>true</code> hanya untuk karakter yang dapat digunakan untuk menulis angka heksadesimal. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{ASCII_Hex_Digit}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'0123456789ABCDEF'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('H')) //false</span></span></code> </pre> <br>  Ada banyak properti serupa lainnya yang digunakan dengan cara yang sama seperti yang dijelaskan di atas.  Diantaranya adalah <code>Uppercase</code> , <code>Lowercase</code> , <code>White_Space</code> , <code>Alphabetic</code> , <code>Emoji</code> . <br><br>  Misalnya, inilah cara menggunakan properti <code>Script</code> untuk menentukan alfabet mana yang digunakan dalam sebuah string.  Di sini kita memeriksa string untuk penggunaan alfabet Yunani. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{Script=Greek}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('hey')) //false</span></span></code> </pre> <br>  Detail tentang properti ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h4>  Grup Bernama </h4><br>  Grup karakter yang diambil di ES2018 dapat diberi nama.  Ini tampilannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: { year: '2015', month: '01', day: '02' } ] */</span></span></code> </pre> <br>  Tanpa menggunakan grup bernama, data yang sama hanya akan tersedia sebagai elemen array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: undefined ] */</span></span></code> </pre> <br><h4>  Bendera regex s </h4><br>  Menggunakan flag <code>s</code> menghasilkan karakter <code>.</code>  (titik) akan, antara lain, cocok dengan karakter baris baru.  Tanpa tanda ini, suatu periode cocok dengan karakter apa pun kecuali untuk baris baru. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/hi.welcome/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'hi\nwelcome'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// false console.log(/hi.welcome/s.test('hi\nwelcome')) // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dengan materi ini, kami menyelesaikan publikasi terjemahan manual JavaScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Kami berharap publikasi ini membantu mereka yang belum pernah menggunakan JavaScript sebelumnya untuk mengambil langkah pertama dalam pemrograman dalam bahasa ini. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda belum pernah menulis JS sebelumnya dan menguasai bahasa ini dalam panduan ini, silakan bagikan tayangan Anda. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431872/">https://habr.com/ru/post/id431872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431862/index.html">Mitap Sbertekh di Yekaterinburg</a></li>
<li><a href="../id431864/index.html">PVS-Studio ROI: bagaimana tidak kehilangan jutaan (draft versi artikel)</a></li>
<li><a href="../id431866/index.html">Pemrogram kesalahpahaman tentang nama - dengan contoh</a></li>
<li><a href="../id431868/index.html">Jam pada lampu pelepasan gas (GRI), mereka adalah jam Nixie</a></li>
<li><a href="../id431870/index.html">Pengembang buku interaktif dengan LED mengeluh tentang pencurian ide oleh karyawan Google</a></li>
<li><a href="../id431874/index.html">Imba: Bahasa yang kompatibel dengan JavaScript untuk kerja cepat dengan DOM</a></li>
<li><a href="../id431876/index.html">Optimalisasi aplikasi Angular</a></li>
<li><a href="../id431878/index.html">Fitur JavaScript yang kurang dikenal</a></li>
<li><a href="../id431880/index.html">Doom of SceneKit. Pengalaman Yandex dengan grafik 3D di iOS</a></li>
<li><a href="../id431884/index.html">Microsoft melampaui Apple dalam kapitalisasi pasar: bagaimana ini terjadi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>