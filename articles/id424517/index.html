<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💼 🏼 🛌 Implementasi minimalisasi fungsi logis oleh metode Quine \ McCluskey dengan set input yang tidak lengkap 🤰🏼 🙅🏽 🌲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini, sampai batas tertentu, merupakan kelanjutan dari artikel saya tentang meminimalkan fungsi logis dengan metode Quine-Mac'Klaski ( https://...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi minimalisasi fungsi logis oleh metode Quine \ McCluskey dengan set input yang tidak lengkap</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424517/">  Artikel ini, sampai batas tertentu, merupakan kelanjutan dari artikel saya tentang meminimalkan fungsi logis dengan metode Quine-Mac'Klaski ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/328506</a> ).  Ini dianggap sebagai kasus dengan fungsi logis yang sepenuhnya didefinisikan (walaupun ini tidak secara langsung disebutkan di dalamnya, tetapi hanya tersirat).  Pada kenyataannya, kasus seperti itu sangat jarang terjadi ketika jumlah variabel input kecil.  Didefinisikan sebagian atau tidak lengkap adalah fungsi logis yang nilainya hanya diberikan untuk bagian Q dari set lengkap P = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ N </script>  set yang mungkin (istilah) dari argumen mereka (variabel) dari nomor <i>N</i> , yaitu, Q &lt;P. Situasi ini ditemui dalam prakteknya dalam kebanyakan kasus penerapan algoritma untuk mengoptimalkan fungsi logis.  Memang, misalnya, jika jumlah variabel input adalah <i>N</i> = 30, yang merupakan kasus biasa, misalnya, di pasar keuangan, maka volume sampel pelatihan input harus dalam urutan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>30</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>30</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {30} </script>  &gt; <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mn>9</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.379ex" height="2.419ex" viewBox="0 -935.7 1454.9 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-39" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-3"> 10 ^ 9 </script>  istilah unik yang unik.  Array data seperti itu tidak ditemukan di setiap organisasi yang sangat besar, belum lagi individu, yaitu, ini sudah menjadi ranah BigData, penggunaan pusat data, dll. <br><br>  Oleh karena itu, dalam praktiknya, fungsi logis yang paling sering diminimalkan tidak akan sepenuhnya ditentukan hanya karena kurangnya jumlah akumulasi data yang diperlukan atau karena berbagai alasan objektif lainnya (misalnya, tidak ada cukup ruang untuk menyimpannya).  Pertanyaan muncul tentang kemungkinan "pengelakan" dari masalah ini ketika menggunakan suatu algoritma yang bekerja dengan satu set yang lengkap dari istilah fungsi logis, seperti, misalnya, dari artikel saya sebelumnya. <br><a name="habracut"></a><br><br>  Praktik standar dalam hal ini adalah untuk menentukan set input variabel (istilah) nilai yang tidak lengkap ke yang lengkap sehingga memberikan hasil yang optimal untuk set data yang ada.  Tetapi, dalam kasus ini, ada masalah dalam menyebutkan semua varian yang mungkin dari definisi tambahan, jumlah totalnya adalah V = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>P</mi><mo>&amp;#x2212;</mo><mi>Q</mi></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.207ex" height="2.539ex" viewBox="0 -987.6 2242 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMATHI-50" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-2212" x="751" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMATHI-51" x="1530" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>P</mi><mo>−</mo><mi>Q</mi></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-4"> 2 ^ {P-Q} </script>  untuk memilih opsi terbaik untuk definisi tambahan sesuai dengan kriteria yang diberikan.  Jelas, untuk nilai Q dan P yang benar-benar digunakan, jumlah opsi yang diurutkan untuk definisi tambahan sangat besar dan pendekatan ini tidak dapat diimplementasikan dalam praktik karena biaya komputasi yang sangat besar. <br><br>  Dengan demikian, pendekatan yang berbeda diperlukan yang akan menghilangkan kebutuhan untuk menyebutkan berbagai opsi untuk definisi tambahan.  Oleh karena itu, perlu untuk memodernisasi algoritma asli, yang awalnya hanya bekerja dengan set input yang terdefinisi penuh, sehingga dapat juga bekerja dengan set terpotong.  Ini adalah implementasi dari algoritma yang diusulkan dalam artikel ini, berdasarkan pada fakta bahwa selama proses minimalisasi dua daftar istilah yang tidak lengkap diproses secara bersamaan, di mana fungsi tersebut ditentukan sebagai FALSE (0) dan TRUE (1). <br><br>  Dari sudut pandang pembelajaran mesin, algoritma Quine-Mac'Klaski mengimplementasikan paradigma pembelajaran dengan guru ketika nilai-nilai output yang sesuai dari fungsi tujuan terlibat dalam proses pembelajaran (dalam hal ini, minimalisasi) secara bersamaan.  Biarkan saya mengingatkan Anda bahwa prinsip pengoperasian metode Quine-Mac'Klaski dasar menurut teori terdiri dari dua tahap utama: <br><ol><li>  Panggung.  Menemukan semua istilah LF sederhana menggunakan aturan perekatan (hukum): <br>  a) (A &amp; B)?  (A &amp;! B)?  A; <br>  b) (A? B) &amp; (A ?! B)?  A; <br>  di mana &amp; adalah operasi AND logis;  - operasi logis "ATAU";!  - operasi negasi logis "TIDAK".  Dari rumus-rumus ini dapat disimpulkan bahwa dua istilah dilem bersama jika mereka berbeda satu sama lain hanya di salah satu posisi variabel.  Di posisi di mana kedua istilah berbeda satu sama lain, tanda "*" diletakkan.  Dengan demikian, alfabet dalam istilah terpaku dibandingkan dengan aslinya memperluas ke tiga nilai: <br>  • 0 =&gt; salah; <br>  • 1 =&gt; benar; <br>  • 2 =&gt; variabel terpaku (*). </li><li>  Panggung.  Meminimalkan jumlah terpaku-dalam istilah yang diperoleh setelah tahap pertama, sebagai masalah menemukan cakupan optimal dari ketentuan awal dengan kuantitas Q. Artinya, karena masing-masing istilah output hanya mencakup subset tertentu dari istilah awal, maka perlu untuk memilih satu set minimal persyaratan istilah yang diidentifikasi dengan dengan mereka, himpunan bagian panjang yang berbeda dalam agregat sepenuhnya mencakup semua istilah input awal.  Pelapisan dalam hal ini berarti bahwa operasi bitwise disjungsi dari istilah output selama istilah input memberikan nilai sebenarnya.  Katakanlah istilah keluaran terpaku memiliki bentuk berikut: 10 * 0110 *. <br>  Maka itu mencakup istilah 10101100: <br>  10 * 0110 * &amp; 10101100 = BENAR <br>  tetapi tidak mencakup istilah 00101100: <br>  10 * 0110 * &amp; 00101100 = SALAH <br>  Artinya, istilah input dan output harus bertepatan di mana-mana kecuali untuk posisi di mana ada simbol "*" - di posisi ini variabel istilah input dapat mengambil nilai apa pun, karena  dalam posisi ini variabel dikecualikan dari pertimbangan. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Kode implementasi adalah sebagai berikut (klik untuk melihat):</b> <div class="spoiler_text"><pre><code class="plaintext hljs">using System; using System.Collections.Generic; using System.Linq; #region   /// &lt;summary&gt; ///      /// &lt;/summary&gt; public abstract class LogicFunction { // ""  public const byte cStarSymb = 2; //    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;(); //   public abstract bool Calculate(bool[] X); //   public abstract bool Calculate(char[] X); //   public abstract bool Calculate(byte[] X); } /// &lt;summary&gt; ///    /// &lt;/summary&gt; public class Dnf : LogicFunction { public static bool Calculate(byte[] X, byte[] term) { bool bResult = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] == cStarSymb) || (term[i] == X[i])) continue; bResult = false; break; } return bResult; } public override bool Calculate(byte[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(char[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(bool[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } } #endregion /// &lt;summary&gt; ///   /// &lt;/summary&gt; public class TreeFuncTerm { /// &lt;summary&gt; ///     /// &lt;/summary&gt; public class TreeNodeEnd { } //    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd(); //  private readonly object[] rootNode = new object[3]; // ()  private int _rang = 0; public int Rang { get { return _rang; } } //    private int enumerationPos = 0; private object[][] enumerationBuf; //,     private byte[] enumerationTerm; public byte[] EnumerationTerm { get { return enumerationTerm; } } //     private UInt32 _count = 0; public UInt32 Count { get { return _count; } } // public TreeFuncTerm() { Clear(); } //  public void Clear() { _count = 0; _rang = 0; enumerationPos = 0; enumerationBuf = null; enumerationTerm = null; rootNode[0] = rootNode[1] = rootNode[2] = null; } //      public TreeNodeEnd EnumerationInit() { enumerationPos = 0; enumerationTerm = new byte[_rang]; enumerationTerm[0] = 0; enumerationBuf = new object[_rang][]; enumerationBuf[0] = rootNode; //    return EnumerationNextNode(); } //     public TreeNodeEnd EnumerationNextNode() { int iIsNext = (enumerationPos &gt; 0 ? 1 : 0); TreeNodeEnd pRetTreeNode = null; while ((pRetTreeNode == null) &amp;&amp; (enumerationPos &gt;= 0)) { object[] pCurrNodes = enumerationBuf[enumerationPos]; object pNextNode = null; int i = enumerationTerm[enumerationPos] + iIsNext; for (; i &lt; 3; i++) if ((pNextNode = pCurrNodes[i]) != null) break; if (pNextNode == null) { //    enumerationPos--; iIsNext = 1; } else { enumerationTerm[enumerationPos] = (byte)i; if (pNextNode is object[]) { //    enumerationPos++; enumerationBuf[enumerationPos] = (object[])pNextNode; enumerationTerm[enumerationPos] = 0; iIsNext = 0; } else //if (pNextNode is TreeNodeEnd) { //   pRetTreeNode = (TreeNodeEnd)pNextNode; } } } return pRetTreeNode; } //     public void AddTerm(byte[] term) { _rang = Math.Max(_rang, term.Length); object[] pCurrNode = rootNode; int iTermLength1 = term.Length - 1; for (int j = 0; j &lt; iTermLength1; j++) { byte cSymb = term[j]; object item = pCurrNode[cSymb]; if (item == null) { item = new object[3]; pCurrNode[cSymb] = item; } pCurrNode = (object[])item; } if (pCurrNode[term[iTermLength1]] == null) { //    pCurrNode[term[iTermLength1]] = pCommonTreeNodeEnd; _count++; } } //      public TreeNodeEnd Remove(byte[] term) { int iTermLength1 = term.Length - 1; object[] pCurrNode = rootNode; for (int i = 0; i &lt; iTermLength1; i++) { pCurrNode = (object[])pCurrNode[term[i]]; if (pCurrNode == null) break; } TreeNodeEnd pRemovedNode = null; if (pCurrNode != null) { //      pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]]; if (pRemovedNode != null) { //     pCurrNode[term[iTermLength1]] = null; // -  _count--; } } return pRemovedNode; } //     public bool Contains(byte[] term) { object pCurrNode = rootNode; foreach (byte cSymb in term) { pCurrNode = ((object[])pCurrNode)[cSymb]; if (pCurrNode == null) break; } return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd)); } } /// &lt;summary&gt; ///     ---- /// &lt;/summary&gt; public class Quine_McCluskey { //    private readonly Dnf _result = new Dnf(); public Dnf Result { get { return _result; } } //    private readonly Dnf _resultNeg = new Dnf(); public Dnf ResultNeg { get { return _resultNeg; } } //     private static void Skleivanie(TreeFuncTerm X1Tree, TreeFuncTerm X2Tree, TreeFuncTerm NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit(); x1 != null; x1 = X1Tree.EnumerationNextNode()) { bool bIsSkleiv = false; byte[] pCurrTerm = X1Tree.EnumerationTerm; for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++) { byte cSymbSav = pCurrTerm[iPos]; if (cSymbSav == LogicFunction.cStarSymb) continue; //      pCurrTerm[iPos] = (byte)(1 - cSymbSav); if (X1Tree.Contains(pCurrTerm)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { pCurrTerm[iPos] = LogicFunction.cStarSymb; //  X2Tree.AddTerm(pCurrTerm); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.AddTerm(pCurrTerm); } } pCurrTerm[iPos] = cSymbSav; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //     private static UInt64 GetTermCode(byte[] pTerm) { UInt64 iMultip = 1, iCode = 0; for (int i = 0; i &lt; pTerm.Length; i++) { iCode += (iMultip * pTerm[i]); iMultip *= 3; } return iCode; } //     private static byte[] GetTermByCode(UInt64 iCode, int iTermLength, byte[] pTerm = null) { if (pTerm == null) pTerm = new byte[iTermLength]; int iCounter = 0; while (iCode != 0) { pTerm[iCounter++] = (byte)(iCode % 3); iCode /= 3; } while (iCounter &lt; iTermLength) pTerm[iCounter++] = 0; return pTerm; } //     private static void Skleivanie(ICollection&lt;UInt64&gt; X1Tree, ICollection&lt;UInt64&gt; X2Tree, ICollection&lt;UInt64&gt; NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel, int iTermLength) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); byte[] pCurrTerm = new byte[iTermLength]; bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); foreach (UInt64 x1 in X1Tree) { GetTermByCode(x1, iTermLength, pCurrTerm); bool bIsSkleiv = false; UInt64 iMultip = 1; for (int iPos = 0; iPos &lt; iTermLength; iPos++) { byte cSymbSav = pCurrTerm[iPos]; //(byte)((x1 / iMultip) % 3); if (cSymbSav != LogicFunction.cStarSymb) { UInt64 iCode = (cSymbSav == 0 ? x1 + iMultip : x1 - iMultip); //      if (X1Tree.Contains(iCode)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { X2Tree.Add(x1 + iMultip); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(iCode)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } pCurrTerm[iPos] = cSymbSav; if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.Add(x1 + (byte)(LogicFunction.cStarSymb - cSymbSav) * iMultip); } } } iMultip *= 3; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, ICollection&lt;UInt64&gt; OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) { UInt64 iCode = GetTermCode(x1); if (OutX2Tree.Contains(iCode)) continue; OutX2Tree.Add(iCode); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) OutX2Tree.AddTerm(x1); } //    private static bool IsEqualTerms(byte[] pTermC, byte[] pTermB) { if ((pTermC == null) || (pTermB == null) || (pTermC.Length != pTermB.Length)) return false; bool bIsEqual = false; int iLength = Math.Min(pTermC.Length, pTermB.Length); for ( int i = 0; i &lt; iLength; i++) { if (!(bIsEqual = (pTermB[i] == pTermC[i]))) break; } return bIsEqual; } //            private static void ReduceRedundancyTerms(LinkedList&lt;byte[]&gt; InpTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivTerms, ICollection&lt;byte[]&gt; ResultTerms) { if ((InpTerms == null) || (SkleivTerms == null) || (ResultTerms == null)) return; //   ResultTerms.Clear(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Outputs2Inputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Inputs2Outputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //    foreach (int iLevel in SkleivTerms.Keys.OrderByDescending(p =&gt; p).AsEnumerable()) { //       foreach (byte[] outTerm in SkleivTerms[iLevel]) { //  ,      term HashSet&lt;byte[]&gt; InpTermsLst = new HashSet&lt;byte[]&gt;(); //     foreach (byte[] inpTerm in InpTerms) { if (Dnf.Calculate(inpTerm, outTerm)) { InpTermsLst.Add(inpTerm); if (!Inputs2Outputs.ContainsKey(inpTerm)) Inputs2Outputs.Add(inpTerm, new HashSet&lt;byte[]&gt;()); Inputs2Outputs[inpTerm].Add(outTerm); } } Outputs2Inputs.Add(outTerm, InpTermsLst); } } //      -    Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value); //   ,   -    while (Inputs2Outputs.Count &gt; 0) { byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First(); ResultTerms.Add(outTerm); foreach (byte[] inpTerm in Outputs2Inputs[outTerm].ToArray()) { foreach (byte[] outTerm2Del in Inputs2Outputs[inpTerm]) Outputs2Inputs[outTerm2Del].Remove(inpTerm); Inputs2Outputs.Remove(inpTerm); } } } //    public static void LogicFuncMinimize(IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos, IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg) { int iTotalLevels = (PositivTerms.Count() &gt; 0 ? PositivTerms.First().Length : (NegativTerms != null &amp;&amp; NegativTerms.Count() &gt; 0 ? NegativTerms.First().Length : 0)); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivPosTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivNegTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); LinkedList&lt;byte[]&gt; InpPosTerms = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; InpNegTerms = new LinkedList&lt;byte[]&gt;(); if (iTotalLevels &lt; 40) { HashSet&lt;UInt64&gt; X1PositivTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); HashSet&lt;UInt64&gt; X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //        foreach(UInt64 iNumb in X1PositivTree.Intersect(X1NegativTree)) { // -    X1   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; GetTermCode(p) == iNumb); int iNeg_Count = NegativTerms.Count(p =&gt; GetTermCode(p) == iNumb); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(iNumb); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(iNumb); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(iNumb); X1NegativTree.Remove(iNumb); } } //           foreach (UInt64 code in X1NegativTree) { InpNegTerms.AddLast(GetTermByCode(code, iTotalLevels)); } } //          foreach (UInt64 code in X1PositivTree) { InpPosTerms.AddLast(GetTermByCode(code, iTotalLevels)); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { HashSet&lt;UInt64&gt; X2PositivTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter, iTotalLevels); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { HashSet&lt;UInt64&gt; X2NegativTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter, iTotalLevels); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } else { TreeFuncTerm X1PositivTree = new TreeFuncTerm(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); TreeFuncTerm X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new TreeFuncTerm(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //         for (TreeFuncTerm.TreeNodeEnd x1 = X1PositivTree.EnumerationInit(); x1 != null; x1 = X1PositivTree.EnumerationNextNode()) { if (!X1NegativTree.Contains(X1PositivTree.EnumerationTerm)) continue; // -    PositivTerms   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); int iNeg_Count = NegativTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } } //           for (TreeFuncTerm.TreeNodeEnd x1 = X1NegativTree.EnumerationInit(); x1 != null; x1 = X1NegativTree.EnumerationNextNode()) { InpNegTerms.AddLast((byte[])X1NegativTree.EnumerationTerm.Clone()); } } //          for (TreeFuncTerm.TreeNodeEnd X1Term = X1PositivTree.EnumerationInit(); X1Term != null; X1Term = X1PositivTree.EnumerationNextNode()) { InpPosTerms.AddLast((byte[])X1PositivTree.EnumerationTerm.Clone()); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { TreeFuncTerm X2PositivTree = new TreeFuncTerm(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { TreeFuncTerm X2NegativTree = new TreeFuncTerm(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } //       ReduceRedundancyTerms(InpPosTerms, SkleivPosTerms, OutPos); //       ReduceRedundancyTerms(InpNegTerms, SkleivNegTerms, OutNeg); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput) { LogicFuncMinimize(TermsInput, _result.Terms, null, null); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms) { LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } public void PrintResult() { Console.WriteLine("--------Otvet-------"); char[] pTermSymbs = new char[] { '0', '1', '*' }; foreach (byte[] Term in _result.Terms) { for (int j = 0; j &lt; Term.Length; j++) { Console.Write(pTermSymbs[Term[j]].ToString() + " "); } Console.WriteLine(); } } }</code> </pre> <br></div></div><br><br>  Kelas Quine_McCluskey adalah implementasi dari algoritma ini yang menggunakan kelas dan antarmuka lain: Dnf, TreeNodeBase, TreeNodeMiddle, TreeNodeEnd, TreeFuncTerm.  Untuk memulai optimasi, Anda perlu memanggil salah satu metode Mulai yang kelebihan beban, yang memanggil fungsi LogicFuncMinimize, di mana, pada kenyataannya, algoritma minimisasi diterapkan.  Mekanisme minimisasi diterapkan dalam dua versi: <br>  • Menggunakan wadah .NET SortedSet untuk menyimpan dan mencari istilah. <br>  • tanpa menggunakan wadah .NET berdasarkan pohon ternary TreeFuncTerm. <br><br>  Dalam hal kecepatan, kedua opsi ini kira-kira sama (dengan wadah .NET, mungkin sedikit lebih cepat, tetapi tidak selalu), tetapi kebutuhan untuk mengimplementasikan TreeFuncTerm disebabkan oleh beberapa faktor: <br>  • Opsi pertama, berdasarkan kode hash integer 64-bit dan pencarian dalam kamus .NET SortedSet. Bekerja dengan benar hanya dengan jumlah variabel input hingga 40, dan dengan jumlah yang lebih besar melampaui grid kode hash integer 64-bit, digunakan untuk operasi kontainer.  Memang, karena logika ternary digunakan dalam istilah terpaku di dalam algoritma, maka dengan jumlah variabel input sama dengan 41, nilai maksimum dari kode hash <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>3</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>41</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,392)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-34"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>3</mn><mrow class="MJX-TeXAtom-ORD"><mn>41</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-5"> 3 ^ {41} </script>  sudah melebihi nilai maksimum <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>64</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-36"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-34" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>64</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-6"> 2 ^ {64} </script>  -1, yang dapat ditulis ke variabel 64 bit.  Dengan lebih banyak variabel, opsi digunakan berdasarkan pohon pencarian ternary penulis TreeFuncTerm. <br>  • Diperlukan untuk memeriksa operasi implementasi pada wadah .NET dengan implementasi lain yang independen darinya, bebas dari itu. <br>  • Anda hanya perlu opsi yang bebas dari wadah .NET, yang dapat dengan mudah diimplementasikan pada platform di mana tidak ada platform .NET (misalnya, dalam mikrokontroler, FPGA, dll.). <br>  Pengoperasian pohon pencarian TreeFuncTerm didasarkan pada konfigurasi tautan ke kelas TreeNodeMiddle dan TreeNodeEnd, yang merupakan implementasi dari antarmuka TreeNodeBase.  Kelas TreeNodeMiddle adalah simpul tengah dari pohon, dan kelas TreeNodeEnd adalah ujung daun pohon.  Menggunakan fungsi EnumerationInit () dan EnumerationNextNode (), mekanisme non-rekursif untuk enumerasi semua daun daun TreeNodeEnd diimplementasikan di pohon.  Fungsi EnumerationInit () menginisialisasi enumerasi dan mengembalikan daun pertama di pohon.  Fungsi EnumerationNextNode () mengembalikan daun pohon berikutnya atau NULL jika tidak ada lagi daun untuk pemilihan.  Selain itu, struktur internal tambahan EnumerationTerm, yang mencerminkan posisi pencarian "kursor" di dalam pohon, juga merupakan kode istilah dari lembar yang ditemukan dalam logika ternary {0,1,2}.  Perlu dicatat bahwa urutan pemilihan daun dari pohon tidak sesuai dengan urutan penambahannya. <br><br>  Algoritma untuk tujuan fungsional dapat dibagi menjadi tiga tahap. <br><ol><li>  <b>Persiapan.</b>  Untuk memecahkan masalah di atas dalam menghilangkan enumerasi opsi untuk definisi tambahan dalam implementasi yang dipertimbangkan, fungsi LogicFuncMinimize menerima dua dataset awal PositivTerms dan NegativTerms, di mana fungsi yang dioptimalkan masing-masing menerima nilai true (TRUE, 1) dan false (FALSE, 0).  Pertama-tama, daftar ini diperiksa untuk konsistensi dari sumber data.  Adalah perlu bahwa setiap set data dijamin hanya berisi istilah unik yang hanya ada di salah satu daftar.  Untuk menjamin ini, setiap istilah input unik dipindai dan jumlah entri di setiap daftar sumber ditemukan.  Jika istilah tersebut muncul di kedua daftar, maka hanya tinggal dalam daftar di mana ia muncul lebih banyak, dan dihapus dari yang lain.  Jika istilah tersebut muncul di masing-masing daftar dengan frekuensi yang sama, maka dihapus dari kedua daftar, yang memastikan keunikan. </li><li>  <b>Ikatan.</b>  Selanjutnya, siklus berulang untuk menempelkan istilah input dilakukan.  Pada setiap iterasi, dalam istilah terpaku, satu tanda * dari posisi terpaku ditambahkan.  Oleh karena itu, jumlah iterasi tidak boleh lebih besar dari jumlah variabel <i>N.</i>  Berbeda dengan implementasi sebelumnya, fungsi Skleivanie untuk menempelkan istilah input memiliki kemampuan untuk merekatkan tidak hanya dengan istilah dari daftar, tetapi juga dengan tidak adanya istilah dengan satu perbedaan juga dengan apa yang disebut istilah "virtual".  Yang dimaksud dengan istilah "virtual" adalah istilah yang didefinisikan secara artifisial yang tidak ditemukan dalam daftar istilah dari set level saat ini.  Tetapi menempel hanya mungkin jika istilah "virtual" tidak mencakup satu istilah dari set awal dari daftar yang berlawanan. <br>  Fungsi Skleivanie dipanggil untuk memproses daftar pada setiap iterasi dua kali sehingga dalam panggilan pertama, makna menggunakan daftar PositivTerms dan NegativTerms bertepatan dengan konten aktualnya, dan pada panggilan kedua, daftar PositivTerms dan NegativTerms dipertukarkan dalam hal penggunaan, mis. Dianggap bahwa Daftar PositivTerms berisi istilah negatif, dan daftar NegativTerms berisi istilah positif: <br>  Skleivanie (X1PositivTree, ..., X1NegativTree, ..., SkleivTerms, ...); <br>  Skleivanie (X1NegativTree, ..., X1PositivTree, ..., null, ...); <br>  Dengan demikian, pengelompokan saling bergantung secara simultan dari ketentuan dua daftar terjadi. <br>  Jika untuk istilah tidak ada istilah lain yang berbeda dari itu hanya dalam satu posisi, baik nyata maupun virtual, yaitu, istilah tersebut tidak menempel bersama siapa pun, maka dianggap sebagai salah satu hasil langkah 1 dari algoritma, itu dikecualikan dari pekerjaan lebih lanjut di dalamnya dan pergi ke input tahap 2 dari algoritma yang diterapkan dalam prosedur ReduceRedundancyTerms.  Istilah-istilah yang tidak dilem dikirim ke output algoritma hanya pada panggilan itu ke fungsi Skleivanie, yang artinya menggunakan daftar PositivTerms dan NegativTerms bertepatan dengan pengisian aktualnya, yaitu, pada panggilan pertama. </li><li>  <b>Singkatan.</b>  Istilah terpaku yang terputus-putus dibuang di ReduceRedundancyTerms menggunakan algoritme untuk perkiraan penyelesaian masalah yang meliputi set asli dengan subset panjang variabel.  Cakupan, yang dekat dengan yang terpendek, disediakan oleh algoritma untuk mengonversi tabel cakupan (TP), berdasarkan metode "kolom minimum - baris maksimum" (yang dapat dilihat, misalnya, di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.studfiles.ru/preview/5175815/page:4</a> ) . <br>  Perkiraan logika karyanya adalah sebagai berikut: <br>  0. Tabel asli dianggap sebagai TP yang diubah saat ini, rangkaian garis cakupan kosong; <br>  1. Kolom dengan unit paling sedikit disorot dalam tabel saat ini.  Di antara baris yang berisi unit dalam kolom ini, satu dengan jumlah unit terbesar disorot.  Baris ini termasuk dalam cakupan, tabel saat ini dikurangi dengan menghapus semua kolom di mana baris yang dipilih memiliki unit. <br>  2. Jika tidak ada kolom dicoret dalam tabel, maka langkah 1 dilakukan, jika tidak, cakupan dibangun.  Catatan: Saat menghitung jumlah unit dalam satu baris, unit dalam kolom yang tidak ditandai diperhitungkan. <br>  Algoritma ini bekerja cukup cepat dan memberikan hasil mendekati optimal. <br>  Untuk menguji operasi algoritme, diusulkan untuk menggunakan fungsi tes TestQuineMcCluskeyRandomPart, yang, dari total kumpulan istilah yang mungkin, adalah <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhjyIxwyMJVwVWsKZR8DQ5qQNGHBhQ#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-7"> 2 ^ N </script>  secara acak memilih hanya bagian yang diberikan 0 &lt;dPart &lt;= 1 (merupakan parameter fungsi), yang untuknya optimasi dilakukan.  Dengan parameter dPart &lt;1, satu set istilah input terpotong akan diperoleh, dan dengan dPart = 1, satu set data input yang lengkap akan diperoleh. </li></ol><br><div class="spoiler">  <b class="spoiler_title">TestQuineMcCluskeyRandomPart (klik untuk melihat)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">public static void TestQuineMcCluskeyRandomPart(int iVariableAmount, double dPart=1) { if (dPart &lt; 0) throw new ArgumentException(" dPart    0   1"); if (dPart &gt; 1) dPart = 1; //   ulong iTotalCombines = (ulong)1 &lt;&lt; iVariableAmount; LinkedList&lt;byte[]&gt; pTrueCol = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; pFalseCol = new LinkedList&lt;byte[]&gt;(); HashSet&lt;ulong&gt; pUsedTerms = new HashSet&lt;ulong&gt;(); Random rnd = new Random(); byte[] buf = new byte[8]; while (pUsedTerms.LongCount() &lt; (iTotalCombines * dPart)) { rnd.NextBytes(buf); ulong iCurValue = (ulong)BitConverter.ToInt64(buf, 0) % iTotalCombines; if (pUsedTerms.Contains(iCurValue)) { //  -     do { iCurValue = ++iCurValue % iTotalCombines; } while (pUsedTerms.Contains(iCurValue)); } pUsedTerms.Add(iCurValue); byte[] sLine = new byte[iVariableAmount]; for (int i = 0; i &lt; iVariableAmount; i++) { sLine[i] += (byte)(iCurValue % 2); iCurValue &gt;&gt;= 1; } if (rnd.Next(2) != 0) { pTrueCol.AddLast(sLine); } else { pFalseCol.AddLast(sLine); } } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = new Quine_McCluskey(); Logic.Start(pTrueCol, pFalseCol); DateTime DtEnd = DateTime.Now; Logic.PrintResult(); Console.WriteLine(" - " + DtStart.ToLongTimeString()); Console.WriteLine(" - " + DtEnd.ToLongTimeString()); TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  int iErrorsCounter = 0; foreach (byte[] kvp in pTrueCol) { if (Logic.Result.Calculate(kvp) != true) iErrorsCounter++; } foreach (byte[] kvp in pFalseCol) { if (Logic.Result.Calculate(kvp) != false) iErrorsCounter++; } Console.WriteLine("-   = " + pUsedTerms.Count); Console.WriteLine("-   = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br><br>  Sebagai hasil dari fungsi pengujian, jumlah istilah dalam bentuk normal disjungtif minimum dan jumlah kesalahan yang menutupinya dengan kumpulan istilah asli dihitung. <br><br>  Sebagai kesimpulan, saya ingin mencatat bahwa dalam praktiknya implementasi algoritma ini telah terbukti menjadi cara yang efektif dan dapat diandalkan untuk meminimalkan fungsi logis yang didefinisikan oleh dua set istilah yang tidak lengkap di mana fungsi logis mengambil nilai TRUE dan FALSE, masing-masing.  Tentu saja, implementasi ini juga dapat digunakan dalam bentuk klasik dalam kasus fungsi logis input yang sepenuhnya didefinisikan, ketika hanya satu atau beberapa daftar istilah yang dimasukkan.  Sebagai kelemahan, perlu untuk memeriksa dalam fungsi Skleivanie bahwa tidak ada kesalahan cakupan untuk setiap istilah virtual dari seluruh daftar istilah sumber pada setiap iterasi algoritma, yang mengarah ke biaya waktu yang signifikan dengan sejumlah besar istilah input. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424517/">https://habr.com/ru/post/id424517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424505/index.html">“Kami punya ide untuk Maven 4 dan bahkan Maven 5” - sebuah wawancara dengan Robert Scholte, peserta kunci dalam proyek Maven</a></li>
<li><a href="../id424507/index.html">VI JetBrains Tahunan Hackathon: Shiftius Altius Ctrlius</a></li>
<li><a href="../id424509/index.html">Bekerja dengan API KOMPAS-3D → Pelajaran 12 → Garis Majemuk</a></li>
<li><a href="../id424511/index.html">Alat untuk menemukan kelas beranotasi di Jawa</a></li>
<li><a href="../id424513/index.html">Tentang pusat data murah, perlindungan ILV dan DDoS</a></li>
<li><a href="../id424519/index.html">Bisakah Beethoven mengirim permintaan penghapusan?</a></li>
<li><a href="../id424525/index.html">Kontrol kecepatan bor mini</a></li>
<li><a href="../id424531/index.html">Layanan Mikro: ukuran penting meskipun Anda memiliki Kubernet</a></li>
<li><a href="../id424533/index.html">"Setiap orang IT yang menghargai diri sendiri terlibat dalam teknologi di waktu luangnya" - 10 pertanyaan untuk programmer, edisi 6</a></li>
<li><a href="../id424537/index.html">Sberbank meluncurkan operator sendiri SberMobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>