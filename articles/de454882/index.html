<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèº üë®‚Äçüåæ ‚èÆÔ∏è Die Architektur einer Ausnahmesituation: Punkt 2 von 4 üëô üë©üèº‚Äçüöí üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich denke, eines der wichtigsten Probleme in diesem Thema ist das Erstellen einer Architektur f√ºr die Ausnahmebehandlung in Ihrer Anwendung. Das ist a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Architektur einer Ausnahmesituation: Punkt 2 von 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454882/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Ich denke, eines der wichtigsten Probleme in diesem Thema ist das Erstellen einer Architektur f√ºr die Ausnahmebehandlung in Ihrer Anwendung.  Das ist aus vielen Gr√ºnden interessant.  Und der Hauptgrund, denke ich, ist eine offensichtliche Einfachheit, mit der man nicht immer umgehen kann.  Alle grundlegenden Konstrukte wie <code>IEnumerable</code> , <code>IDisposable</code> , <code>IObservable</code> usw.  habe diese Eigenschaft und benutze sie √ºberall.  Einerseits versucht ihre Einfachheit, diese Konstrukte in verschiedenen Situationen zu verwenden.  Andererseits sind sie voller Fallen, die Sie m√∂glicherweise nicht herausholen.  Wenn Sie sich die Menge an Informationen ansehen, die wir behandeln, haben Sie m√∂glicherweise eine Frage: Was ist das Besondere an Ausnahmesituationen? </p><br><p>  Um jedoch Schlussfolgerungen zum Aufbau der Architektur von Ausnahmeklassen zu ziehen, sollten wir einige Details zu deren Klassifizierung erfahren.  Denn bevor ein Programmiersystem erstellt wird, das f√ºr den Codebenutzer klar ist, sollte ein Programmierer festlegen, wann der Fehlertyp ausgew√§hlt und wann Ausnahmen abgefangen oder √ºbersprungen werden sollen.  Lassen Sie uns also die Ausnahmesituationen (nicht die Arten von Ausnahmen) anhand verschiedener Funktionen klassifizieren. </p><a name="habracut"></a><br><h3 id="based-on-a-theoretical-possibility-to-catch-a-future-exception">  Basierend auf einer theoretischen M√∂glichkeit, eine zuk√ºnftige Ausnahme zu erwischen. </h3><br><p>  Basierend auf dieser Funktion k√∂nnen wir Ausnahmen in solche unterteilen, die definitiv gefangen werden, und solche, die h√∂chstwahrscheinlich nicht gefangen werden.  Warum sage ich <em>sehr wahrscheinlich</em> ?  Weil es immer jemanden gibt, der versucht, eine Ausnahme abzufangen, w√§hrend dies nicht notwendig ist. </p><br><p>  Beschreiben wir zun√§chst die erste Gruppe von Ausnahmen - diejenigen, die abgefangen werden sollten. </p><br><p>  Im Falle solcher Ausnahmen sagen wir einerseits unserem Subsystem, dass wir in einen Zustand geraten sind, in dem es keinen Sinn macht, mit unseren Daten weiter zu handeln.  Auf der anderen Seite meinen wir, dass nichts Katastrophales passiert ist und wir den Ausweg aus der Situation finden k√∂nnen, indem wir einfach die Ausnahme abfangen.  Diese Eigenschaft ist sehr wichtig, da sie die Kritikalit√§t eines Fehlers definiert und die Gewissheit gibt, dass wir, wenn wir eine Ausnahme abfangen und Ressourcen l√∂schen, einfach mit dem Code fortfahren k√∂nnen. </p><br><p>  Die zweite Gruppe befasst sich mit Ausnahmen, die zwar seltsam klingen m√∂gen, aber nicht abgefangen werden m√ºssen.  Sie k√∂nnen nur zur Fehlerprotokollierung verwendet werden, nicht jedoch zur Korrektur einer Situation.  Das einfachste Beispiel ist <code>ArgumentException</code> und <code>NullReferenceException</code> .  In einer normalen Situation m√ºssen Sie beispielsweise <code>ArgumentNullException</code> nicht abfangen, da in diesem Fall genau Sie die Fehlerquelle sind.  Wenn Sie eine solche Ausnahme feststellen, geben Sie zu, dass Sie einen Fehler gemacht und etwas Unannehmbares an eine Methode √ºbergeben haben: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  In dieser Methode versuchen wir, <code>ArgumentNullException</code> .  Aber ich denke, das ist seltsam, da es ganz unser Anliegen ist, richtige Argumente an eine Methode weiterzugeben.  Nach dem Ereignis zu reagieren w√§re falsch: Das Beste, was Sie in einer solchen Situation tun k√∂nnen, ist, die √ºbergebenen Daten vor dem Aufrufen einer Methode im Voraus zu √ºberpr√ºfen oder sogar solchen Code zu erstellen, bei dem es unm√∂glich ist, falsche Parameter zu erhalten. </p><br><p>  Eine weitere Gruppe von Ausnahmesituationen sind schwerwiegende Fehler.  Wenn ein Cache fehlerhaft ist und die Arbeit eines Subsystems ohnehin nicht korrekt ist, handelt es sich um einen schwerwiegenden Fehler, und der n√§chste Code auf dem Stapel erkennt ihn nicht mit Sicherheit: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } cache (CacheCorruptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  <code>CacheCorruptedException</code> ist eine Ausnahme, die bedeutet, dass "der Festplatten-Cache inkonsistent ist".  Wenn die Ursache eines solchen Fehlers f√ºr das Cache-Subsystem schwerwiegend ist (z. B. gibt es keine Zugriffsrechte f√ºr Cache-Dateien), kann der folgende Code den Cache nicht mit der Anweisung <code>RecreateCache</code> neu erstellen. Daher ist das Abfangen dieser Ausnahme selbst ein Fehler. </p><br><h3 id="based-on-the-area-where-an-exceptional-situation-is-actually-catched">  Basierend auf dem Gebiet, in dem tats√§chlich eine Ausnahmesituation erfasst wird </h3><br><p>  Ein weiteres Problem ist, ob wir einige Ausnahmen abfangen oder an jemanden weitergeben sollten, der die Situation besser versteht.  Mit anderen Worten, wir sollten Verantwortungsbereiche festlegen.  Lassen Sie uns den folgenden Code untersuchen: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Welche der beiden Strategien ist besser geeignet?  Der Verantwortungsbereich ist sehr wichtig.  Zun√§chst scheint es, dass die Arbeit und Konsistenz von <code>WildInvestment</code> vollst√§ndig von <code>WildStrategy</code> .  Wenn <code>WildInvestment</code> diese Ausnahme einfach ignoriert, wird sie in die obere Ebene <code>WildInvestment</code> und wir sollten nichts tun.  Beachten Sie jedoch, dass die <code>Main</code> Methode in Bezug auf die Architektur eine Ausnahme von einer Ebene abf√§ngt, w√§hrend die Methode von einer anderen aufgerufen wird.  Wie sieht es in Bezug auf die Nutzung aus?  So sieht es aus: </p><br><ul><li>  Die Verantwortung f√ºr diese Ausnahme wurde uns √ºbertragen. </li><li>  Der Benutzer dieser Klasse ist sich nicht sicher, ob diese Ausnahme zuvor absichtlich durch eine Reihe von Methoden √ºbergeben wurde. </li><li>  Wir beginnen neue Abh√§ngigkeiten zu erstellen, die wir durch Aufrufen einer Zwischenschicht beseitigt haben. </li></ul><br><p>  Daraus ergibt sich jedoch eine andere Schlussfolgerung: Wir sollten <code>catch</code> in der <code>DoSomethingWild</code> Methode verwenden.  Und das ist f√ºr uns etwas seltsam: <code>WildInvestment</code> ist kaum von etwas abh√§ngig.  Ich meine, wenn <code>PlayRussianRoulette</code> nicht funktioniert hat, passiert dasselbe mit <code>DoSomethingWild</code> : Es hat keine R√ºckkehrcodes, aber es muss Roulette spielen.  Was k√∂nnen wir also in einer scheinbar hoffnungslosen Situation tun?  Die Antwort ist eigentlich einfach: Auf einer anderen Ebene zu sein <code>DoSomethingWild</code> sollte eine eigene Ausnahme <code>DoSomethingWild</code> , die zu dieser Ebene geh√∂rt, und sie in <code>InnerException</code> als urspr√ºngliche <code>InnerException</code> eines Problems <code>InnerException</code> : </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Indem wir eine Ausnahme in eine andere einschlie√üen, √ºbertragen wir das Problem von einer Anwendungsebene auf eine andere und machen seine Arbeit f√ºr einen Verbraucher dieser Klasse vorhersehbarer: die <code>Main</code> Methode. </p><br><h3 id="based-on-reuse-issues">  Basierend auf Wiederverwendungsproblemen </h3><br><p>  Oft f√ºhlen wir uns zu faul, um eine neue Art von Ausnahme zu erstellen, aber wenn wir uns dazu entschlie√üen, ist nicht immer klar, auf welche Art wir uns st√ºtzen sollen.  Aber genau diese Entscheidungen bestimmen die gesamte Architektur von Ausnahmesituationen.  Schauen wir uns einige beliebte L√∂sungen an und ziehen wir einige Schlussfolgerungen. </p><br><p>  Bei der Auswahl des Ausnahmetyps k√∂nnen wir eine zuvor erstellte L√∂sung verwenden, dh eine Ausnahme mit dem Namen suchen, der einen √§hnlichen Sinn enth√§lt, und diese verwenden.  Wenn wir beispielsweise eine Entit√§t √ºber einen Parameter erhalten haben und diese Entit√§t nicht gef√§llt, k√∂nnen wir eine <code>InvalidArgumentException</code> , die die Ursache eines Fehlers in der Nachricht angibt.  Dieses Szenario sieht gut aus, insbesondere da sich <code>InvalidArgumentException</code> in der Gruppe der Ausnahmen befindet, die m√∂glicherweise nicht abgefangen werden.  Die Auswahl von <code>InvalidDataException</code> ist jedoch falsch, wenn Sie mit einigen Datentypen arbeiten.  Dies liegt daran, dass sich dieser Typ im Bereich <code>System.IO</code> befindet, mit dem Sie wahrscheinlich nicht zu tun haben.  Daher ist es fast immer falsch, nach einem vorhandenen Typ zu suchen, anstatt selbst einen zu entwickeln.  Es gibt fast keine Ausnahmen f√ºr ein allgemeines Aufgabenspektrum.  Praktisch alle sind f√ºr bestimmte Situationen vorgesehen. Wenn Sie sie in anderen F√§llen wiederverwenden, wird die Architektur von Ausnahmesituationen erheblich verletzt.  Dar√ºber hinaus kann eine Ausnahme eines bestimmten Typs (z. B. <code>System.IO.InvalidDataException</code> ) einen Benutzer verwirren: Einerseits wird er sehen, dass die Ausnahme zum <code>System.IO</code> Namespace geh√∂rt, andererseits wird sie ausgel√∂st ein v√∂llig anderer Namespace.  Wenn dieser Benutzer √ºber die Regeln zum Ausl√∂sen dieser Ausnahme nachdenkt, kann er unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">referenceource.microsoft.com</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alle Stellen finden, an denen sie ausgel√∂st wird</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  Der Benutzer wird das verstehen <del>  Jemand ist alle Daumen </del>  Diese Art von Ausnahme verwirrte ihn, da die Methode, die diese Ausnahme ausl√∂ste, sich nicht mit Komprimierung befasste. </p><br><p>  In Bezug auf die Wiederverwendung k√∂nnen Sie einfach eine Ausnahme erstellen und das Feld <code>ErrorCode</code> deklarieren.  Das scheint eine gute Idee zu sein.  Sie l√∂sen einfach dieselbe Ausnahme aus, legen den Code fest und verwenden nur einen <code>catch</code> , um Ausnahmen zu behandeln, wodurch die Stabilit√§t einer Anwendung erh√∂ht wird.  Ich glaube jedoch, dass Sie diese Position √ºberdenken sollten.  Nat√ºrlich erleichtert dieser Ansatz einerseits das Leben.  Auf der anderen Seite schlie√üen Sie jedoch die M√∂glichkeit aus, eine Untergruppe von Ausnahmen abzufangen, die einige gemeinsame Merkmale aufweisen.  Beispiel: <code>ArgumentException</code> , die eine Reihe von Ausnahmen durch Vererbung vereint.  Ein weiterer schwerwiegender Nachteil ist ein √ºberm√§√üig gro√üer und nicht lesbarer Code, der eine fehlercodebasierte Filterung veranlassen muss.  Die Einf√ºhrung eines umfassenden Typs mit einem Fehlercode ist jedoch besser geeignet, wenn sich ein Benutzer nicht um die Angabe eines Fehlers k√ºmmern muss. </p><br><pre> <code class="plaintext hljs">public class ParserException { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Dem Code, der den Parser-Aufruf sch√ºtzt, ist es egal, warum das Parsen fehlgeschlagen ist: Er ist an dem Fehler als solchem ‚Äã‚Äãinteressiert.  Wenn jedoch die Fehlerursache wichtig wird, kann ein Benutzer den Fehlercode immer von der <code>ErrorCode</code> Eigenschaft <code>ErrorCode</code> .  Und Sie m√ºssen wirklich nicht nach den erforderlichen W√∂rtern in einer Teilzeichenfolge von <code>Message</code> suchen. </p><br><p>  Wenn wir uns nicht f√ºr eine Wiederverwendung entscheiden, k√∂nnen wir f√ºr jede Situation eine Art Ausnahme erstellen.  Einerseits klingt es logisch: eine Art von Fehler - eine Art von Ausnahme.  √úbertreiben Sie jedoch nicht: Wenn zu viele Arten von Ausnahmen vorhanden sind, tritt das Problem auf, dass sie abgefangen werden, da der Code einer aufrufenden Methode mit <code>catch</code> Bl√∂cken √ºberladen wird.  Weil es alle Arten von Ausnahmen verarbeiten muss, die Sie an es √ºbergeben m√∂chten.  Ein weiterer Nachteil ist rein architektonisch.  Wenn Sie keine Ausnahmen verwenden, verwirren Sie diejenigen, die diese Ausnahmen verwenden: Sie haben m√∂glicherweise viele Gemeinsamkeiten, werden jedoch separat abgefangen. </p><br><p>  Es gibt jedoch gro√üartige Szenarien, um separate Typen f√ºr bestimmte Situationen einzuf√ºhren.  Zum Beispiel, wenn der Fehler nicht eine ganze Entit√§t betrifft, sondern eine bestimmte Methode.  Dann sollte dieser Fehlertyp einen solchen Platz in der Hierarchie der Vererbung einnehmen, dass niemand jemals daran denken w√ºrde, ihn zusammen mit etwas anderem zu erfassen: zum Beispiel durch einen separaten Vererbungszweig. </p><br><p>  Wenn Sie beide Ans√§tze kombinieren, erhalten Sie eine Reihe leistungsstarker Instrumente, mit denen Sie mit einer Gruppe von Fehlern arbeiten k√∂nnen: Sie k√∂nnen einen gemeinsamen abstrakten Typ einf√ºhren und bestimmte F√§lle davon erben.  Die Basisklasse (unser allgemeiner Typ) muss eine abstrakte Eigenschaft erhalten, die zum Speichern eines Fehlercodes ausgelegt ist, w√§hrend Erben diesen Code durch √úberschreiben dieser Eigenschaft angeben. </p><br><pre> <code class="plaintext hljs">public abstract class ParserException { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Mit diesem Ansatz erhalten wir einige wunderbare Eigenschaften: </p><br><ul><li>  Einerseits fangen wir immer wieder Ausnahmen mit einem Basistyp (allgemein) ab. </li><li>  Auf der anderen Seite k√∂nnen wir selbst bei Ausnahmen mit diesem Basistyp eine bestimmte Situation identifizieren. </li><li>  Au√üerdem k√∂nnen wir Ausnahmen √ºber einen bestimmten Typ anstelle eines Basistyps abfangen, ohne die flache Struktur von Klassen zu verwenden. </li></ul><br><p>  Ich finde es sehr praktisch. </p><br><h3 id="based-on-belonging-to-a-specific-group-of-behavioral-situations">  Basierend auf der Zugeh√∂rigkeit zu einer bestimmten Gruppe von Verhaltenssituationen </h3><br><p>  Welche Schlussfolgerungen k√∂nnen wir aus den vorherigen √úberlegungen ziehen?  Versuchen wir, sie zu definieren. </p><br><p>  Lassen Sie uns zun√§chst entscheiden, was eine Situation bedeutet.  Normalerweise sprechen wir √ºber Klassen und Objekte in Bezug auf Entit√§ten mit einem internen Status und k√∂nnen Aktionen f√ºr diese Entit√§ten ausf√ºhren.  Daher umfasst die erste Art von Verhaltenssituation Aktionen f√ºr eine Entit√§t.  Wenn wir als n√§chstes einen Objektgraphen von au√üen betrachten, werden wir sehen, dass er logisch als eine Kombination von Funktionsgruppen dargestellt wird: Die erste Gruppe befasst sich mit dem Caching, die zweite mit Datenbanken, die dritte f√ºhrt mathematische Berechnungen durch.  Verschiedene Ebenen k√∂nnen verschiedene diese Gruppen durchlaufen, z. B. Ebenen der internen Statusprotokollierung, Prozessprotokollierung und Ablaufverfolgung von Methodenaufrufen.  Schichten k√∂nnen mehrere Funktionsgruppen umfassen.  Beispielsweise kann es eine Ebene eines Modells, eine Ebene von Controllern und eine Pr√§sentationsebene geben.  Diese Gruppen k√∂nnen sich in einer Baugruppe oder in verschiedenen befinden, aber jede Gruppe kann ihre eigenen Ausnahmesituationen erstellen. </p><br><p>  Auf diese Weise k√∂nnen wir eine Hierarchie f√ºr die Arten von Ausnahmesituationen erstellen, die auf der Zugeh√∂rigkeit dieser Typen zu der einen oder anderen Gruppe oder Schicht basiert.  Daher erlauben wir einem abfangenden Code, einfach zwischen diesen Typen in der Hierarchie zu navigieren. </p><br><p>  Lassen Sie uns den folgenden Code untersuchen: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Wie ist es  Ich denke, der Namespace ist eine perfekte M√∂glichkeit, die Arten von Ausnahmen basierend auf den Verhaltenssituationen auf nat√ºrliche Weise zu gruppieren: Alles, was zu bestimmten Gruppen geh√∂rt, sollte dort bleiben, einschlie√ülich Ausnahmen.  Wenn Sie eine bestimmte Ausnahme erhalten, sehen Sie au√üerdem den Namen ihres Typs und auch den Namespace, der eine Gruppe angibt, zu der sie geh√∂rt.  Erinnern Sie sich an die fehlerhafte Wiederverwendung von <code>InvalidDataException</code> die tats√§chlich im <code>System.IO</code> Namespace definiert ist?  Die Tatsache, dass es zu diesem Namespace geh√∂rt, bedeutet, dass diese Art von Ausnahme von Klassen ausgel√∂st werden kann, die sich im <code>System.IO</code> Namespace oder in einem verschachtelten befinden.  Die eigentliche Ausnahme wurde jedoch aus einem v√∂llig anderen Bereich geworfen, was eine Person verwirrte, die das Problem behandelt.  Wenn Sie jedoch die Ausnahmetypen und die Typen, die diese Ausnahmen ausl√∂sen, in dieselben Namespaces einf√ºgen, behalten Sie die Architektur der Typen bei und erleichtern Entwicklern das Verst√§ndnis der Gr√ºnde f√ºr das, was passiert. </p><br><p>  Was ist der zweite Weg zur Gruppierung auf Codeebene?  Vererbung: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerException(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Beachten Sie, dass normale Anwendungsentit√§ten sowohl Verhalten als auch Daten und Gruppentypen erben, die zu einer <em>einzelnen Gruppe von Entit√§ten geh√∂ren</em> .  F√ºr Ausnahmen erben sie jedoch und werden basierend auf einer <em>einzelnen Gruppe von Situationen</em> gruppiert, da das Wesentliche einer Ausnahme keine Entit√§t, sondern ein Problem ist. </p><br><p>  Wenn wir diese beiden Gruppierungsmethoden kombinieren, k√∂nnen wir die folgenden Schlussfolgerungen ziehen: </p><br><ul><li>  Innerhalb der <code>Assembly</code> sollte es einen Basistyp von Ausnahmen geben, die von dieser Assembly ausgel√∂st werden.  Diese Art von Ausnahmen sollte sich in einem Root-Namespace der Assembly befinden.  Dies ist die erste Gruppierungsebene. </li><li>  Dar√ºber hinaus k√∂nnen sich in einer Assembly ein oder mehrere Namespaces befinden.  Jeder von ihnen unterteilt die Baugruppe in Funktionszonen und definiert die Gruppen von Situationen, die in dieser Baugruppe angezeigt werden.  Dies k√∂nnen Zonen von Controllern, Datenbankentit√§ten, Datenverarbeitungsalgorithmen usw. sein.  F√ºr uns bedeuten diese Namespaces Gruppierungstypen basierend auf ihrer Funktion.  In Bezug auf Ausnahmen werden sie jedoch basierend auf Problemen innerhalb derselben Baugruppe gruppiert. </li><li>  Ausnahmen m√ºssen von Typen im selben Namespace der oberen Ebene geerbt werden.  Dies stellt sicher, dass der Endbenutzer Situationen eindeutig versteht und keine <em>falschen</em> typbasierten Ausnahmen abf√§ngt.  Zugegeben, es w√§re seltsam, <code>global::Finiki.Logistics.OhMyException</code> durch <code>catch(global::Legacy.LoggerExeption exception)</code> , w√§hrend der folgende Code absolut angemessen aussieht: </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something is wrong in the parser } catch (FinancialPipeExceptionBase exception) { // Something else is wrong. Looks critical because we don't know the real reason }</code> </pre><br><p>  Hier ruft der Benutzercode eine Bibliotheksmethode auf, die <code>XmlParserServiceException</code> in bestimmten Situationen eine <code>XmlParserServiceException</code> kann.  Und wie wir wissen, bezieht sich diese Ausnahme auf den geerbten Namespace <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> bedeutet, dass es m√∂glicherweise einige andere Ausnahmen gibt - diesmal erstellt der <code>XmlParserService</code> Mikroservice nur eine Ausnahme, andere Ausnahmen k√∂nnen jedoch in Zukunft auftreten.  Da wir eine Konvention zum Erstellen von Ausnahmetypen haben, wissen wir, von welcher Entit√§t diese neue Ausnahme geerbt wird, und setzen im Voraus einen umfassenden <code>catch</code> .  Dadurch k√∂nnen wir alle f√ºr uns irrelevanten Dinge √ºberspringen. </p><br><p>  Wie baut man eine solche Hierarchie von Typen auf? </p><br><ul><li>  Zun√§chst sollten wir eine Basisklasse f√ºr eine Dom√§ne erstellen.  Nennen wir es eine Domain-Basisklasse.  In diesem Fall ist eine Dom√§ne ein Wort, das eine Reihe von Assemblys umfasst und diese basierend auf einer Funktion kombiniert: Protokollierung, Gesch√§ftslogik, Benutzeroberfl√§che.  Ich meine Funktionszonen einer Anwendung, die so gro√ü wie m√∂glich sind. </li><li>  Als n√§chstes sollten wir eine zus√§tzliche Basisklasse f√ºr Ausnahmen einf√ºhren, die abgefangen werden m√ºssen: Alle Ausnahmen, die mit dem Schl√ºsselwort <code>catch</code> abgefangen werden, werden von dieser Basisklasse geerbt. </li><li>  Alle Ausnahmen, die auf schwerwiegende Fehler hinweisen, sollten direkt von einer Dom√§nenbasisklasse geerbt werden.  So werden wir sie von denen trennen, die auf der Architekturebene gefangen wurden; <br>  - Teilen Sie die Dom√§ne basierend auf Namespaces in Funktionsbereiche auf und deklarieren Sie den Basistyp der Ausnahmen, die aus jedem Bereich ausgel√∂st werden.  Hier muss der gesunde Menschenverstand verwendet werden: Wenn eine Anwendung einen hohen Grad an Namespace-Verschachtelung aufweist, sollten Sie nicht f√ºr jede Verschachtelungsebene einen Basistyp erstellen.  Wenn jedoch eine Verzweigung auf Verschachtelungsebene erfolgt, wenn eine Gruppe von Ausnahmen in einen Namespace und eine andere Gruppe in einen anderen Namespace wechselt, m√ºssen f√ºr jede Untergruppe zwei Basistypen verwendet werden. </li><li>  Besondere Ausnahmen sollten von den Arten von Ausnahmen geerbt werden, die zu Funktionsbereichen geh√∂ren </li><li>  Wenn eine Gruppe von speziellen Ausnahmen kombiniert werden kann, ist es erforderlich, dies in einem weiteren Basistyp zu tun: So k√∂nnen Sie sie leichter abfangen; </li><li>  Wenn Sie annehmen, dass die Gruppe h√§ufiger mit einer Basisklasse abgefangen wird, f√ºhren Sie den gemischten Modus mit ErrorCode ein. </li></ul><br><h3 id="based-on-the-source-of-an-error">  Basierend auf der Fehlerquelle </h3><br><p>  Die Fehlerquelle kann eine weitere Grundlage sein, um Ausnahmen in einer Gruppe zu kombinieren.  Wenn Sie beispielsweise eine Klassenbibliothek entwerfen, k√∂nnen die folgenden Dinge Gruppen von Quellen bilden: </p><br><ul><li>  unsicherer Code-Aufruf mit einem Fehler.  Diese Situation kann behoben werden, indem eine Ausnahme oder ein Fehlercode in einen eigenen Ausnahmetyp eingeschlossen wird, w√§hrend zur√ºckgegebene Daten (z. B. der urspr√ºngliche Fehlercode) in einer √∂ffentlichen Eigenschaft der Ausnahme gespeichert werden. </li><li>  Ein Code-Aufruf durch externe Abh√§ngigkeiten, der Ausnahmen ausgel√∂st hat, die von unserer Bibliothek nicht abgefangen werden k√∂nnen, da sie au√üerhalb ihres Verantwortungsbereichs liegen.  Diese Gruppe kann Ausnahmen von den Methoden der Entit√§ten enthalten, die als Parameter einer aktuellen Methode akzeptiert wurden, oder Ausnahmen vom Konstruktor einer Klasse, deren Methode eine externe Abh√§ngigkeit genannt hat.  Beispielsweise hat eine Methode unserer Klasse eine Methode einer anderen Klasse aufgerufen, deren Instanz √ºber Parameter einer anderen Methode zur√ºckgegeben wurde.  Wenn eine Ausnahme anzeigt, dass wir die <code>InnerExcepton</code> eines Problems sind, sollten wir unsere eigene Ausnahme generieren und dabei die urspr√ºngliche in <code>InnerExcepton</code> .  Wenn wir jedoch verstehen, dass das Problem durch eine externe Abh√§ngigkeit verursacht wurde, ignorieren wir diese Ausnahme als zu einer Gruppe externer Abh√§ngigkeiten geh√∂rend, die au√üerhalb unserer Kontrolle liegen. </li><li>  unser eigener Code, der versehentlich in einen inkonsistenten Zustand versetzt wurde.  Ein gutes Beispiel ist das Parsen von Text - keine externen Abh√§ngigkeiten, keine √úbertragung in eine <code>unsafe</code> Welt, aber es tritt ein Problem beim Parsen auf. </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454882/">https://habr.com/ru/post/de454882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
<li><a href="../de454874/index.html">Ein bisschen √ºber Multitasking in Mikrocontrollern</a></li>
<li><a href="../de454876/index.html">√úber das Entwerfen eines flexiblen Systems von Charakterf√§higkeiten in Spielen</a></li>
<li><a href="../de454878/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 3</a></li>
<li><a href="../de454880/index.html">"Nebensaison" im Leben eines Freiberuflers: Wie kann man √ºberleben und √ºberleben?</a></li>
<li><a href="../de454884/index.html">Lesbare Testnamen in JS und im Verhaltensmuster</a></li>
<li><a href="../de454886/index.html">In der Leber sitzen. Warum die Entfernung von Lebertumoren ein Indikator f√ºr die √ºberlegenen F√§higkeiten des Chirurgen ist</a></li>
<li><a href="../de454892/index.html">Moto. Mock aws</a></li>
<li><a href="../de454894/index.html">WWDC 2019 :: was zu sehen</a></li>
<li><a href="../de454896/index.html">Warum ich freiberuflich zu einem Remote-Team gewechselt bin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>