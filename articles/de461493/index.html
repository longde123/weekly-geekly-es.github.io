<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüè≠ üë®üèæ‚Äçüîß ‚ùì Django 3.0 wird asynchron sein ‚òùÔ∏è üï¥üèΩ üë®üèº‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrew Godwin ver√∂ffentlichte am 9. Mai DEP 0009: Async-f√§higes Django und wurde am 21. Juli vom Django Technical Council genehmigt. Es ist also zu ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Django 3.0 wird asynchron sein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461493/"><p>  <em>Andrew Godwin ver√∂ffentlichte am 9. Mai <a href="">DEP 0009: Async-f√§higes Django</a> und wurde am 21. Juli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom</a> Django <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technical Council</a> genehmigt. Es ist also zu hoffen, dass sie bis zur Ver√∂ffentlichung von Django 3.0 etwas Interessantes tun k√∂nnen.</em>  <em>Es wurde bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">irgendwo in den Kommentaren von Habr erw√§hnt</a> , aber ich beschloss, diese Nachricht einem breiteren Publikum zu √ºbermitteln, indem ich sie √ºbersetzte - vor allem f√ºr diejenigen, die wie ich die Nachrichten von Django nicht besonders verfolgen.</em> </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1153030952915890177"></twitter-widget>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Asynchrones Python wurde seit vielen Jahren entwickelt und im Django-√ñkosystem haben wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels damit</a> experimentiert, wobei der Schwerpunkt auf der Unterst√ºtzung von Web-Sockets lag. </p><br><p>  Als sich das √ñkosystem entwickelte, stellte sich heraus, dass Django nicht dringend auf die Unterst√ºtzung von Nicht-HTTP-Protokollen wie Web-Sockets erweitert werden musste, die asynchrone Unterst√ºtzung jedoch viele Vorteile f√ºr das traditionelle Django-Framework f√ºr Modellansichtsvorlagen bieten w√ºrde. </p><br><p>  Die Vorteile werden im Abschnitt Motivation unten beschrieben, aber die allgemeine Schlussfolgerung, zu der ich gekommen bin, ist, dass wir so viel von asynchronem Django bekommen, dass es die harte Arbeit wert ist, die es kostet.  Ich glaube auch, dass es sehr wichtig ist, √Ñnderungen auf iterative, von der Community unterst√ºtzte Weise vorzunehmen, die nicht von einem oder zwei alten Mitwirkenden abh√§ngen, die m√∂glicherweise ausbrennen. <a name="habracut"></a></p><br><p>  Obwohl das Dokument als "Feature" -DEP bezeichnet wird, bedeutet dies, dass es teilweise auch eine Prozess-DEP ist.  Der Umfang der unten vorgeschlagenen √Ñnderungen ist unglaublich gro√ü, und das Starten als traditioneller Einzelfunktionsprozess wird wahrscheinlich fehlschlagen. </p><br><p>  Nat√ºrlich ist es in diesem Dokument wichtig, sich an die Django-Philosophie zu erinnern, die darin besteht, alles sicher und abw√§rtskompatibel zu halten.  Der Plan ist nicht, synchrones Django zu entfernen - es ist geplant, es in seiner aktuellen Form beizubehalten, sondern Asynchronit√§t als Option f√ºr diejenigen hinzuzuf√ºgen, die glauben, zus√§tzliche Leistung oder Flexibilit√§t zu ben√∂tigen. </p><br><p>  Ist das ein gigantischer Job?  Nat√ºrlich.  Ich bin jedoch der Meinung, dass dies die Zukunft von Django erheblich ver√§ndern kann - wir haben die M√∂glichkeit, einen bew√§hrten Rahmen und eine unglaubliche Community zu nutzen und eine v√∂llig neue Reihe von Optionen einzuf√ºhren, die zuvor unm√∂glich waren. </p><br><p>  Das Web hat sich ge√§ndert, und Django sollte sich damit √§ndern, aber gem√§√ü unseren Idealen erschwinglich, standardm√§√üig sicher und flexibel sein, wenn Projekte wachsen und sich ihre Anforderungen √§ndern.  In der Welt des Cloud Data Warehousing, der serviceorientierten Architektur und des Backends als Grundlage komplexer Gesch√§ftslogik ist die F√§higkeit, wettbewerbsf√§hig zu arbeiten, von entscheidender Bedeutung. </p><br><p>  Diese DEP skizziert einen Plan, von dem ich denke, dass er uns dorthin f√ºhren wird.  Dies ist eine Vision, an die ich wirklich glaube und mit der ich daran arbeiten werde, alles M√∂gliche zu tun.  Gleichzeitig sind sorgf√§ltige Analyse und Skepsis gerechtfertigt;  Ich bitte um Ihre konstruktive Kritik sowie um Ihr Vertrauen.  Django ist auf eine Community von Menschen und die von ihnen erstellten Anwendungen angewiesen. Wenn wir den Weg in die Zukunft bestimmen m√ºssen, m√ºssen wir dies gemeinsam tun. </p><br><h2 id="kratkoe-opisanie">  Kurzbeschreibung </h2><br><p>  Wir werden Django um Unterst√ºtzung f√ºr asynchrone Darstellungen, Middleware, ORM und andere wichtige Elemente erweitern. </p><br><p>  Dazu wird synchroner Code in Threads ausgef√ºhrt und schrittweise durch asynchronen Code ersetzt.  Synchrone APIs bleiben bestehen und werden vollst√§ndig unterst√ºtzt. Im Laufe der Zeit werden sie zu synchronen Wrappern f√ºr anf√§nglich asynchronen Code. </p><br><p>  Im ASGI-Modus wird Django als native asynchrone Anwendung gestartet.  Der WSGI-Modus l√∂st bei jedem Zugriff auf Django eine separate Ereignisschleife aus, sodass die asynchrone Schicht mit dem synchronen Server kompatibel ist. </p><br><p>  Multithreading um ORMs ist komplex und erfordert ein neues Konzept von Verbindungskontexten und Sticky Threads, um synchronen ORM-Code auszuf√ºhren. </p><br><p>  Viele Teile von Django werden weiterhin synchron arbeiten. Unsere Priorit√§t wird darin bestehen, Benutzer beim Schreiben von Ansichten in beiden Stilen zu unterst√ºtzen, damit sie den besten Stil f√ºr die Pr√§sentation ausw√§hlen k√∂nnen, an der sie arbeiten. </p><br><p>  Einige Funktionen, wie Vorlagen und Caching, ben√∂tigen separate DEPs und Studien, wie sie vollst√§ndig asynchron gemacht werden k√∂nnen.  Diese DEP konzentriert sich haupts√§chlich auf den HTTP-Middleware-View-Flow und ORM. </p><br><p>  Es wird volle Abw√§rtskompatibilit√§t geben.  Ein Standard-Django 2.2-Projekt sollte unver√§ndert in asynchronem Django (sei es 3.0 oder 3.1) ausgef√ºhrt werden. </p><br><p>  Dieser Vorschlag konzentriert sich auf die Implementierung kleiner, iterativer Teile mit ihrer schrittweisen Platzierung in der Hauptniederlassung, um Probleme mit der langlebigen Gabel zu vermeiden und es uns zu erm√∂glichen, den Kurs zu √§ndern, wenn wir Probleme erkennen. </p><br><p>  Dies ist eine gute Gelegenheit, neue Mitglieder zu gewinnen.  Wir m√ºssen das Projekt finanzieren, damit dies schneller geschieht.  Die Finanzierung sollte in einem Umfang erfolgen, an den wir nicht gew√∂hnt sind. </p><br><h2 id="specifikaciya">  Spezifikation </h2><br><p>  Das √ºbergeordnete Ziel besteht darin, jeden einzelnen Teil von Django, der blockiert werden kann, dh nicht nur CPU-gebundene Berechnungen, asynchron zu machen (in einer asynchronen Ereignisschleife ohne Sperren auszuf√ºhren). </p><br><p>  Dies umfasst die folgenden Funktionen: </p><br><ul><li>  Zwischenschichten (Middleware) </li><li>  Ansichten </li><li>  ORM </li><li>  Muster </li><li>  Testen </li><li>  Caching </li><li>  Formularvalidierung </li><li>  E-Mail </li></ul><br><p>  Dies schlie√üt jedoch Dinge wie Internationalisierung nicht ein, die keinen Leistungsgewinn bringen, da dies eine CPU-gebundene Aufgabe ist, die ebenfalls schnell ausgef√ºhrt wird, oder Migrationen, die beim Starten √ºber den Verwaltungsbefehl Single-Threaded sind. </p><br><p>  Jede einzelne Funktion, die im Inneren asynchron wird, bietet auf absehbare Zeit auch eine synchrone Schnittstelle, die abw√§rtskompatibel mit der aktuellen API (in 2.2) ist. Wir k√∂nnten sie im Laufe der Zeit √§ndern, um sie zu verbessern, aber synchrone APIs werden nirgendwo hingehen. </p><br><p>  Im Folgenden wird ein √úberblick dar√ºber gegeben, wie dies technisch erreicht wird, und anschlie√üend werden spezifische Implementierungsdetails f√ºr bestimmte Bereiche angegeben.  Es ist nicht f√ºr alle Funktionen von Django ersch√∂pfend, aber wenn wir dieses urspr√ºngliche Ziel erreichen, werden wir fast alle Anwendungsf√§lle einbeziehen. </p><br><p>  Im letzten Teil dieses Abschnitts, ‚ÄûVorgehensweise‚Äú, wird auch erl√§utert, wie diese √Ñnderungen schrittweise und von mehreren Entwicklergruppen parallel implementiert werden k√∂nnen. Dies ist wichtig, um diese √Ñnderungen mithilfe von Freiwilligen in angemessener Zeit durchzuf√ºhren. </p><br><h3 id="tehnicheskiy-obzor">  Technische √úberpr√ºfung </h3><br><p>  Das Prinzip, das es uns erm√∂glicht, synchrone und asynchrone Implementierungen parallel zu verwalten, ist die F√§higkeit, einen Stil in einem anderen auszuf√ºhren. </p><br><p>  Jede Funktion durchl√§uft drei Implementierungsstufen: </p><br><ul><li>  Nur synchron (wir sind hier) </li><li>  Synchrone Implementierung mit asynchronem Wrapper </li><li>  Asynchrone Implementierung mit synchronem Wrapper </li></ul><br><h4 id="asinhronnaya-obyortka">  Asynchroner Wrapper </h4><br><p>  Zun√§chst wird der vorhandene synchrone Code in eine asynchrone Schnittstelle eingeschlossen, die den synchronen Code im Thread-Pool ausf√ºhrt.  Auf diese Weise k√∂nnen wir relativ schnell eine asynchrone Schnittstelle entwerfen und bereitstellen, ohne den gesamten verf√ºgbaren Code f√ºr die Asynchronit√§t neu schreiben zu m√ºssen. </p><br><p> Das Toolkit hierf√ºr ist bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asgiref</a> als Funktion <code>sync_to_async</code> , die Dinge wie Ausnahmebehandlung oder Threadlocals unterst√ºtzt (mehr dazu weiter unten). </p><br><p>  Das Ausf√ºhren von Code in Threads f√ºhrt h√∂chstwahrscheinlich nicht zu einer Steigerung der Produktivit√§t - der auftretende Overhead verlangsamt ihn wahrscheinlich ein wenig, wenn Sie nur normalen linearen Code ausf√ºhren -, aber dies erm√∂glicht Entwicklern, wettbewerbsf√§hig etwas auszuf√ºhren und sich an neue Funktionen zu gew√∂hnen. </p><br><p>  Dar√ºber hinaus gibt es mehrere Teile von Django, die bei wiederholtem Zugriff empfindlich darauf reagieren, im <em>selben</em> Thread zu beginnen.  Zum Beispiel das Verarbeiten von Transaktionen in der Datenbank.  Wenn wir einen Code in <code>atomic()</code> einschlie√üen w√ºrden, der dann √ºber zuf√§llige Threads aus dem Pool auf das ORM zugreifen w√ºrde, h√§tte die Transaktion keine Auswirkung, da sie an die Verbindung innerhalb des Threads gebunden ist, in dem die Transaktion gestartet wurde. </p><br><p>  In solchen Situationen ist ein ‚Äûklebriger Thread‚Äú erforderlich, in dem der asynchrone Kontext den gesamten synchronen Code im selben Thread nacheinander aufruft, anstatt ihn in den Thread-Pool zu verschieben, w√§hrend das korrekte Verhalten von ORM und anderen threadempfindlichen Teilen beibehalten wird.  Alle Teile von Django, von denen wir vermuten, dass sie ben√∂tigt werden, einschlie√ülich des gesamten ORM, verwenden die Version <code>sync_to_async</code> , die dies ber√ºcksichtigt, sodass standardm√§√üig alles sicher ist.  Benutzer k√∂nnen dies f√ºr die Ausf√ºhrung wettbewerbsf√§higer Abfragen selektiv deaktivieren. Weitere Informationen finden Sie unter "ORM" weiter unten. </p><br><h4 id="asinhronnaya-realizaciya">  Asynchrone Implementierung </h4><br><p>  Der n√§chste Schritt besteht darin, die Implementierung der Funktion in asynchronen Code umzuschreiben und dann die synchrone Schnittstelle √ºber einen Wrapper zu pr√§sentieren, der asynchronen Code in einer einmaligen Ereignisschleife ausf√ºhrt.  Dies ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asgiref bereits</a> als <code>async_to_sync</code> Funktion verf√ºgbar. </p><br><p>  Es ist nicht erforderlich, alle Funktionen gleichzeitig neu zu schreiben, um schnell zur dritten Stufe zu gelangen.  Wir k√∂nnen unsere Bem√ºhungen auf die Teile konzentrieren, die wir gut k√∂nnen und die von Bibliotheken von Drittanbietern unterst√ºtzt werden, w√§hrend wir dem Rest des Python-√ñkosystems bei Dingen helfen, die mehr Arbeit erfordern, um native Asynchronit√§t zu implementieren.  Dies wird unten diskutiert. </p><br><p>  Diese allgemeine √úbersicht funktioniert mit fast allen Django-Funktionen, die asynchron werden sollen, mit Ausnahme der Stellen, f√ºr die Python keine bereits verwendeten asynchronen Funktions√§quivalente bereitstellt.  Das Ergebnis wird entweder eine √Ñnderung in der Darstellung der API von Django im asynchronen Modus sein oder die Zusammenarbeit mit Python-Kernentwicklern, um die Entwicklung asynchroner Python-Funktionen zu unterst√ºtzen. </p><br><h3 id="threadlocals">  Threadlocals </h3><br><p>  Eines der grundlegenden Details der Django-Implementierung, die getrennt von den meisten der unten beschriebenen Funktionen erw√§hnt werden m√ºssen, sind Threadlocals.  Wie der Name schon sagt, funktionieren Threadlocals innerhalb eines Threads, und obwohl Django das <code>HttpRequest</code> Objekt au√üerhalb von threadlocal h√§lt, f√ºgen wir einige andere Dinge hinzu - zum Beispiel Datenbankverbindungen oder die aktuelle Sprache. </p><br><p>  Die Verwendung von Threadlocals kann in zwei Optionen unterteilt werden: </p><br><ul><li>  "Kontext-Lokale", bei denen ein Wert in einem stapelbasierten Kontext ben√∂tigt wird, z. B. eine Anforderung.  Dies ist erforderlich, um die aktuelle Sprache einzustellen. </li><li>  "True Threadlocals", bei denen der gesch√ºtzte Code f√ºr den Aufruf von einem anderen Thread aus nicht sicher ist.  Dies dient zum Herstellen einer Verbindung mit der Datenbank. </li></ul><br><p>  Auf den ersten Blick scheint es, dass "Kontextlokale" mit dem neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextvars-</a> Modul in Python aufgel√∂st werden k√∂nnen, aber Django 3.0 muss weiterhin Python 3.6 unterst√ºtzen, w√§hrend dieses Modul in 3.7 erschien.  Dar√ºber hinaus wurde <code>contextvars</code> speziell entwickelt, um den Kontext zu <code>contextvars</code> wenn beispielsweise zu einem neuen Thread <code>sync_to_async</code> Diese Werte m√ºssen jedoch <code>sync_to_async</code> werden, damit die Funktionen <code>sync_to_async</code> und <code>async_to_sync</code> normal als Wrapper fungieren k√∂nnen.  Wenn Django nur 3.7 und h√∂her unterst√ºtzt, k√∂nnten wir die Verwendung von <code>contextvars</code> Betracht <code>contextvars</code> , aber dies w√ºrde erhebliche Arbeit in Django erfordern. </p><br><p>  Dies wurde bereits mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asgiref</a> <code>Local</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">behoben</a> , das mit Coroutinen und Threads kompatibel ist.  Jetzt werden keine <code>contextvars</code> , aber wir k√∂nnen es nach einigen Tests auf Backport f√ºr 3.6 umstellen. </p><br><p>  Echte Threadlocals hingegen k√∂nnen im aktuellen Thread einfach weiterarbeiten.  Wir m√ºssen jedoch vorsichtiger sein, um zu verhindern, dass solche Objekte in einen anderen Strom gelangen.  Wenn die Pr√§sentation nicht mehr im selben Thread ausgef√ºhrt wird, sondern f√ºr jeden ORM-Aufruf einen Thread erzeugt (w√§hrend der Phase ‚ÄûSynchrone Implementierung, asynchroner Wrapper‚Äú), sind einige Dinge, die im synchronen Modus m√∂glich waren, im asynchronen Modus nicht m√∂glich. </p><br><p>  Dies erfordert besondere Aufmerksamkeit und das Verbot einiger zuvor m√∂glicher Operationen im asynchronen Modus.  Die uns bekannten F√§lle werden im Folgenden in bestimmten Abschnitten beschrieben. </p><br><h3 id="odnovremennaya-podderzhka-sinhronnogo-i-asinhronnogo-interfeysov">  Gleichzeitige Unterst√ºtzung f√ºr synchrone und asynchrone Schnittstellen </h3><br><p>  Eines der gro√üen Probleme beim Portieren von Django ist, dass Sie mit Python keine synchronen und asynchronen Versionen einer Funktion mit demselben Namen erstellen k√∂nnen. </p><br><p>  Dies bedeutet, dass Sie nicht einfach eine API erstellen k√∂nnen, die wie folgt funktioniert: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   value = cache.get("foo") #   value = await cache.get("bar")</span></span></code> </pre> <br><p>  Dies ist eine ungl√ºckliche Einschr√§nkung der asynchronen Implementierung von Python, und es gibt keine offensichtliche Problemumgehung.  Wenn etwas angerufen wird, wissen Sie nicht, ob Sie erwartet werden oder nicht. Daher k√∂nnen Sie nicht feststellen, was zur√ºckgegeben werden muss. </p><br><p>  (Hinweis: Dies liegt daran, dass Python asynchrone Funktionen als "synchrones aufrufbares <code>__acall__</code> , das eine Coroutine zur√ºckgibt" und nicht als "Aufrufen der <code>__acall__</code> Methode f√ºr ein Objekt" <code>__acall__</code> . Asynchrone Kontextmanager und Iteratoren haben dieses Problem nicht, da Sie haben getrennte Methoden <code>__aiter__</code> und <code>__aenter__</code> .) </p><br><p>  In diesem Sinne m√ºssen wir die Namespaces von synchronen und asynchronen Implementierungen getrennt voneinander platzieren, damit sie nicht in Konflikt geraten.  Wir k√∂nnten dies mit dem genannten Argument <code>sync=True</code> tun, aber dies f√ºhrt zu verwirrenden Funktionsk√∂rpern / Methoden und verhindert die Verwendung von <code>async def</code> und erm√∂glicht es Ihnen auch, versehentlich zu vergessen, dieses Argument zu schreiben.  Ein zuf√§lliger Aufruf einer synchronen Methode, wenn Sie sie asynchron aufrufen m√∂chten, ist gef√§hrlich. </p><br><p>  Die vorgeschlagene L√∂sung f√ºr die meisten Stellen in der Django-Codebasis besteht darin, ein Suffix f√ºr Namen von asynchronen Implementierungen von Funktionen <code>cache.get_async</code> - beispielsweise <code>cache.get_async</code> zus√§tzlich zu synchronem <code>cache.get</code> .  Obwohl dies eine h√§ssliche L√∂sung ist, ist es sehr einfach, Fehler beim Anzeigen von Code zu erkennen (Sie sollten <code>_async</code> mit der Methode <code>_async</code> verwenden). </p><br><h3 id="predstavleniya-i-obrabotka-http">  Ansichten und HTTP-Behandlung </h3><br><p>  Ansichten sind wahrscheinlich der Grundstein f√ºr die N√ºtzlichkeit der Asynchronit√§t, und wir erwarten, dass die meisten Benutzer zwischen asynchronem und synchronem Code w√§hlen. </p><br><p>  Django wird zwei Arten von Ansichten unterst√ºtzen: </p><br><ul><li>  Synchrone Darstellungen, definiert wie bisher durch eine synchrone Funktion oder Klasse mit synchronem <code>__call__</code> </li><li>  Asynchrone Darstellungen, die durch eine asynchrone Funktion (R√ºckgabe einer Coroutine) oder eine Klasse mit asynchronem <code>__call__</code> . </li></ul><br><p>  Sie werden von <code>BaseHandler</code> , der die vom URL-Resolver empfangene Ansicht √ºberpr√ºft und entsprechend <code>BaseHandler</code> .  Der Basishandler sollte der erste Teil von Django sein, der asynchron wird, und wir m√ºssen den WSGI-Handler so √§ndern, dass er mit <code>async_to_sync</code> in einer eigenen Ereignisschleife <code>async_to_sync</code> . </p><br><p>  Zwischenebenen (Middleware) oder Einstellungen wie <code>ATOMIC_REQUESTS</code> , die die Ansichten in nicht asynchronen sicheren Code <code>ATOMIC_REQUESTS</code> (z. B. den <code>atomic()</code> Block), funktionieren weiterhin, ihre Geschwindigkeit wird jedoch beeintr√§chtigt (z. B. das Verbot paralleler ORM-Aufrufe in der Ansicht mit <code>atomic()</code> ) </p><br><p>  Die vorhandene <code>StreamingHttpResponse</code> Klasse wird so ge√§ndert, dass sie entweder einen synchronen oder einen asynchronen Iterator akzeptiert. Die interne Implementierung erfolgt dann immer asynchron.  √Ñhnliches gilt f√ºr <code>FileResponse</code> .  Da dies ein potenzieller <code>__iter__</code> f√ºr Code von Drittanbietern ist, der direkt auf <code>__iter__</code> zugreift, m√ºssen wir f√ºr die √úbergangszeit weiterhin einen synchronen <code>__iter__</code> bereitstellen. </p><br><p>  WSGI wird weiterhin auf unbestimmte Zeit von Django unterst√ºtzt, aber der WSGI-Handler wird weiterhin asynchrone Middleware und Ansichten in einer eigenen einmaligen Ereignisschleife ausf√ºhren.  Dies f√ºhrt wahrscheinlich zu einem leichten Leistungsabfall, hatte jedoch in den ersten Experimenten keine allzu gro√üen Auswirkungen. </p><br><p>  Alle asynchronen HTTP-Funktionen funktionieren in WSGI, einschlie√ülich langer Abfragen und langsamer Antworten. Sie sind jedoch genauso ineffizient wie jetzt und belegen f√ºr jede Verbindung einen Thread / Prozess.  ASGI-Server sind die einzigen, die viele gleichzeitige Anforderungen effizient unterst√ºtzen und Nicht-HTTP-Protokolle wie WebSocket f√ºr die Verwendung durch Erweiterungen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels verarbeiten k√∂nnen</a> . </p><br><h3 id="promezhutochnye-sloi">  Zwischenschichten </h3><br><p>  W√§hrend sich der vorherige Abschnitt haupts√§chlich auf den Anforderungs- / Antwortpfad konzentrierte, ben√∂tigt Middleware aufgrund der Komplexit√§t ihres aktuellen Designs einen separaten Abschnitt. </p><br><p>  Django-Middlewares sind jetzt in Form eines Stapels angeordnet, in dem jede Middleware <code>get_response</code> erh√§lt, um die n√§chste Middleware in der angegebenen Reihenfolge auszuf√ºhren (oder die Ansicht f√ºr die niedrigste Middleware auf dem Stack).  Aus Gr√ºnden der Abw√§rtskompatibilit√§t m√ºssen wir jedoch eine Mischung aus synchroner und asynchroner Middleware beibehalten, und diese beiden Typen k√∂nnen nicht nativ aufeinander zugreifen. </p><br><p>  Um sicherzustellen, dass die Middleware funktioniert, m√ºssen wir stattdessen jede Middleware mit dem Platzhalter get_response initialisieren, der stattdessen die Kontrolle an den Handler zur√ºckgibt und sowohl die Daten√ºbertragung zwischen der Middleware und der Ansicht als auch einen Ausnahmefall √ºbernimmt.  In gewisser Weise wird es aus interner Sicht irgendwann wie Middleware der Django 1.0-√Ñra aussehen, obwohl die Benutzer-API nat√ºrlich dieselbe bleibt. </p><br><p>  Wir k√∂nnen synchrone Middleware f√ºr veraltet erkl√§ren, aber ich empfehle, dies nicht bald zu tun.  Wenn wir am Ende des Zyklus ihrer Veralterung angelangt sind, k√∂nnten wir die Middleware-Implementierung auf ein rein rekursives Stack-Modell zur√ºckf√ºhren, wie es jetzt ist. </p><br><h3 id="orm">  ORM </h3><br><p>  ORM ist der gr√∂√üte Teil von Django in Bezug auf die Codegr√∂√üe und am schwierigsten in asynchron zu konvertieren. </p><br><p>  Dies ist haupts√§chlich auf die Tatsache zur√ºckzuf√ºhren, dass die zugrunde liegenden Datenbanktreiber vom Design her synchron sind und nur langsam Fortschritte bei einer Reihe ausgereifter, standardisierter, asynchroner Datenbanktreiber erzielt werden.  Stattdessen m√ºssen wir eine Zukunft entwerfen, in der Datenbanktreiber zun√§chst synchron sein werden, und den Grundstein f√ºr Mitwirkende legen, die asynchrone Treiber iterativ weiterentwickeln. </p><br><p>  Probleme mit ORM lassen sich in zwei Hauptkategorien einteilen: Threads und implizites Blockieren. </p><br><h4 id="potoki">  Streams </h4><br><p>  Das Hauptproblem bei ORM besteht darin, dass Django um ein einzelnes globales <code>connections</code> herum entworfen wurde, wodurch Sie auf magische Weise die richtige Verbindung f√ºr Ihren aktuellen Thread erhalten. </p><br><p>  In einer asynchronen Welt, in der alle Coroutinen im selben Thread arbeiten, ist dies nicht nur √§rgerlich, sondern einfach gef√§hrlich.  Ohne zus√§tzliche Sicherheit kann ein Benutzer, der wie gewohnt auf ein ORM zugreift, Verbindungsobjekte besch√§digen, indem er von mehreren verschiedenen Stellen aus darauf zugreift. </p><br><p>  Gl√ºcklicherweise sind Verbindungsobjekte zumindest zwischen Threads portierbar, obwohl sie nicht von zwei Threads gleichzeitig aufgerufen werden k√∂nnen.  Django k√ºmmert sich bereits im ORM-Code um die Thread-Sicherheit f√ºr Datenbanktreiber. Daher k√∂nnen wir das Verhalten √§ndern, damit es ordnungsgem√§√ü funktioniert. </p><br><p>  Wir werden das <code>connections</code> so √§ndern, dass es sowohl Coroutinen als auch Threads versteht. Dabei wird Code aus <code>asgiref.local</code> , jedoch mit zus√§tzlicher Logik.  Verbindungen werden in asynchronem und synchronem Code geteilt, der sich gegenseitig aufruft - wobei der Kontext <code>sync_to_async</code> und <code>async_to_sync</code> - und der synchrone Code wird gezwungen, nacheinander in einem Sticky-Thread ausgef√ºhrt zu werden, sodass dies nicht funktioniert gleichzeitig Fadensicherheit brechen. </p><br><p>  Dies impliziert, dass wir eine L√∂sung wie einen Kontextmanager ben√∂tigen, um eine Datenbankverbindung wie <code>atomic()</code> zu √∂ffnen und zu schlie√üen.  Auf diese Weise k√∂nnen wir in diesem Kontext einen konsistenten Aufruf und Sticky-Threads bereitstellen und Benutzer k√∂nnen mehrere Kontexte erstellen, wenn sie mehrere Verbindungen √∂ffnen m√∂chten.  Es gibt uns auch eine M√∂glichkeit, magische globale <code>connections</code> loszuwerden, wenn wir dies weiterentwickeln wollen. </p><br><p>  Derzeit verf√ºgt Django nicht √ºber ein Verbindungslebenszyklusmanagement, das unabh√§ngig von den Signalen der Handlerklasse ist. Daher werden wir sie verwenden, um diese ‚ÄûVerbindungskontexte‚Äú zu erstellen und zu l√∂schen.  Die Dokumentation wird ebenfalls aktualisiert, um zu verdeutlichen, wie Verbindungen au√üerhalb des Anforderungs- / Antwortzyklus ordnungsgem√§√ü behandelt werden.  Selbst im aktuellen Code wissen viele Benutzer nicht, dass ein langj√§hriges Management-Team regelm√§√üig <code>close_old_connections</code> aufrufen muss, um <code>close_old_connections</code> zu funktionieren. </p><br><p>  Abw√§rtskompatibilit√§t bedeutet, dass wir Benutzern jederzeit den Zugriff auf <code>connections</code> von jedem beliebigen Code aus erlauben m√ºssen, dies jedoch nur f√ºr synchronen Code zulassen.  Wir werden sicherstellen, dass der Code vom ersten Tag an in einen ‚ÄûVerbindungskontext‚Äú eingeschlossen wird, wenn er asynchron ist. </p><br><p>  Es scheint, als w√§re es sch√∂n, zus√§tzlich zu <code>transaction.atomic()</code> Datei <code>transaction.atomic()</code> hinzuzuf√ºgen und den Benutzer zu verpflichten, den gesamten Code in einem von ihnen auszuf√ºhren. Dies kann jedoch zu Verwirrung dar√ºber f√ºhren, was beim Anh√§ngen passiert einer von ihnen ist im anderen. </p><br><p>  Stattdessen schlage ich vor, einen neuen Kontextmanager <code>db.new_connections()</code> erstellen, der dieses Verhalten <code>db.new_connections()</code> , und bei jedem Aufruf eine neue Verbindung zu erstellen und eine beliebige Verschachtelung von <code>atomic()</code> zuzulassen. </p><br><p>  Jedes Mal, wenn Sie <code>new_connections()</code> Block <code>new_connections()</code> , richtet Django einen neuen Kontext mit neuen Datenbankverbindungen ein.  Alle Transaktionen, die au√üerhalb des Blocks ausgef√ºhrt wurden, werden fortgesetzt.  Alle ORM-Aufrufe innerhalb des Blocks arbeiten mit einer neuen Verbindung zur Datenbank und sehen die Datenbank unter diesem Gesichtspunkt.  Wenn die Transaktionsisolation in der Datenbank aktiviert ist, wie dies normalerweise standardm√§√üig der Fall ist, bedeutet dies, dass bei neuen Verbindungen innerhalb des Blocks m√∂glicherweise nicht die √Ñnderungen angezeigt werden, die von nicht festgeschriebenen Transaktionen au√üerhalb des Blocks vorgenommen wurden. </p><br><p>  Dar√ºber hinaus k√∂nnen die Verbindungen in diesem Block <code>new_connections</code> selbst <code>atomic()</code> , um zus√§tzliche Transaktionen f√ºr diese neuen Verbindungen auszul√∂sen.  Jede Verschachtelung dieser beiden Kontextmanager ist zul√§ssig, aber jedes Mal, <code>new_connections</code> verwendet wird, werden zuvor ge√∂ffnete Transaktionen "angehalten" und wirken sich nicht auf ORM-Aufrufe aus, bis ein neuer <code>new_connections</code> Block <code>new_connections</code> . </p><br><p>  Ein Beispiel daf√ºr, wie diese API aussehen k√∂nnte: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_authors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pattern)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Create a new context to call concurrently async with db.new_connections(): return [ author.name async for author in Authors.objects.filter(name__icontains=pattern) ] async def get_books(pattern): # Create a new context to call concurrently async with db.new_connections(): return [ book.title async for book in Book.objects.filter(name__icontains=pattern) ] async def my_view(request): # Query authors and books concurrently task_authors = asyncio.create_task(get_authors("an")) task_books = asyncio.create_task(get_books("di")) return render( request, "template.html", { "books": await task_books, "authors": await task_authors, }, )</span></span></code> </pre> <br><p>  Dies ist etwas ausf√ºhrlich, aber das Ziel besteht auch darin, Verkn√ºpfungen auf hoher Ebene hinzuzuf√ºgen, um dieses Verhalten zu erm√∂glichen (und auch den √úbergang von <code>asyncio.ensure_future</code> in Python 3.6 zu <code>asyncio.create_task</code> in 3.7 <code>asyncio.create_task</code> ). </p><br><p>  Mit diesem Kontextmanager und Sticky Streams im selben Verbindungskontext garantieren wir, dass der gesamte Code standardm√§√üig so sicher wie m√∂glich ist.  Es besteht die M√∂glichkeit, dass der Benutzer die Verbindung in einem Thread f√ºr zwei verschiedene Teile der Anforderung mithilfe von <code>yield</code> kann. Dies ist jedoch <code>yield</code> jetzt m√∂glich. </p><br><h4 id="neyavnye-blokirovki">  Implizite Sperren </h4><br><p>  Ein weiteres Problem des aktuellen ORM-Entwurfs besteht darin, dass in Modellinstanzen blockierende (netzwerkbezogene) Operationen, insbesondere lesebezogene Felder, auftreten. </p><br><p>  Wenn Sie eine Modellinstanz nehmen und dann auf <code>model_instance.related_field</code> zugreifen, <code>model_instance.related_field</code> Django den Inhalt des zugeordneten Modells transparent und gibt ihn an Sie zur√ºck.  Dies ist jedoch im asynchronen Code nicht m√∂glich. Blockierungscode sollte nicht im Hauptthread ausgef√ºhrt werden, und es gibt keinen asynchronen Zugriff auf Attribute. </p><br><p>  Gl√ºcklicherweise hat Django bereits einen Ausweg: <code>select_related</code> , das die zugeh√∂rigen Felder im Voraus l√§dt, und <code>prefetch_related</code> f√ºr viele-zu-viele-Beziehungen.  Wenn Sie ORM asynchron verwenden, verbieten wir implizit blockierende Vorg√§nge, z. B. den Hintergrundzugriff auf Attribute, und geben stattdessen einen Fehler zur√ºck, der angibt, dass Sie das Feld zuerst abrufen m√ºssen. </p><br><p>  Dies hat den zus√§tzlichen Vorteil, dass langsamer Code verhindert wird, der N Anforderungen in einer <code>for</code> Schleife ausf√ºhrt, was ein h√§ufiger Fehler vieler neuer Django-Programmierer ist.  Dies erh√∂ht die Eintrittsbarriere, aber denken Sie daran, dass asynchrones Django optional ist - Benutzer k√∂nnen weiterhin synchronen Code schreiben, wenn sie dies w√ºnschen (und dies wird im Tutorial empfohlen, da es viel schwieriger ist, synchronen Code zu machen). </p><br><p>  Gl√ºcklicherweise kann <code>QuerySet</code> problemlos asynchrone Generatoren implementieren und sowohl Synchronisation als auch Asynchronit√§t transparent unterst√ºtzen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> User.objects.all(): data.append(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> extract_important_info(user)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> render(<span class="hljs-string"><span class="hljs-string">"template.html"</span></span>, data)</code> </pre> <br><h4 id="drugoe">  Andere </h4><br><p>  Teile von ORM, die mit Schema√§nderungen verkn√ºpft sind, sind nicht asynchron.  Sie sollten nur von Managementteams aufgerufen werden.  Einige Projekte nennen sie bereits in Einsendungen, aber das ist sowieso keine gute Idee. </p><br><h3 id="shablony">  Muster </h3><br><p>  Die Vorlagen sind jetzt vollst√§ndig synchron, und es ist geplant, sie im ersten Schritt so zu belassen.     ,      ,     DEP. </p><br><p>  ,  Jinja2   ,              . </p><br><p>  ,         Django     ,       .  Jinja2       ,    ,        ,    . </p><br><p>       ,     <code>render_async</code> ,   <code>render</code> ;      ,   ,        . </p><br><h3 id="keshirovanie">  </h3><br><p>    Django      ‚Äî     <code>_async</code> -  (, <code>get_async</code> , <code>set_async</code> ). </p><br><p>   ,       API  <code>sync_to_async</code> ,    <code>BaseCache</code> . </p><br><p> ,     thread-safety   API ,   Django,        ,       .    ,     ORM, ,      . </p><br><h3 id="formy">  </h3><br><p>         ,        ,    ,     <code>ModelForm</code>  ORM     . </p><br><p>  ,   -   <code>clean</code>  <code>save</code> ,  ,   . ,      ,  ,                         DEP. </p><br><h3 id="email">  E-Mail </h3><br><p>         Django,      .    <code>send_mail_async</code>  <code>send_mail</code> ,   <code>async</code> -        (, <code>mail_admins</code> ). </p><br><p>         Django  ,    -  SMTP,     .  , ,      ,      ,   . </p><br><h3 id="testirovanie">  Testen </h3><br><p>     ,      Django  . </p><br><p>     ASGI-     <code>asgiref.testing.ApplicationCommunicator</code> .             assert'  . </p><br><p>    Django        ,    ,      .  ,      ‚Äî     ,    ,        HTTP    event loop,    WSGI. </p><br><p>                .  ,      ,      . </p><br><p>   ,     ,      .       <code>async def</code>    <code>@async_to_sync</code> ,       , ,    Django test runner. </p><br><p>        asyncio (   loop'  ,    )   , , ,   <code>DEBUG=True</code> .          ‚Äî   ,       ,       . </p><br><h3 id="websockets"> WebSockets </h3><br><p>       Django;      ,   Channels   ,        ASGI,      . </p><br><p>    ,         Channels,        ,     ASGI. </p><br><h3 id="poryadok-deystviy">   </h3><br><p>      ,     ,   .       ,          . </p><br><p>   ,                .         ,       ‚Äî         . </p><br><p>  ,      ,              .    ,   ORM,       ,  ,          . </p><br><p>   : </p><br><ul><li><p>   (  3.0) </p><br><ul><li>  HTTP,     (    ) </li><li>  async       ORM </li><li>    </li></ul><br></li><li><p>   (  3.1) </p><br><ul><li> ORM (     ) </li><li>  (     ) </li><li>  (     ) </li></ul><br></li><li><p>    </p><br><ul><li> ORM (       ) </li><li>  (    ) </li><li>  E-Mail </li><li>  </li></ul><br></li></ul><br><p>          ;      ,    .     ,   ,       , ,            . </p><br><p>   ,      -   ;            ,     ,        .    ,      ,  Django,     Django  async-only . </p><br><p>    ,  ,    DEP  ,   , , email  .         DBAPI ‚Äî  ,        core Python , , PEP,         . </p><br><h2 id="motivaciya">  </h2><br><p>     ,  , ,    .   Django      ,   -       ,    -;             . </p><br><p>          ,      - .         ,   ‚Äî  ,       ,       . </p><br><p>          Python ‚Äî   . -  Python       ,     ,       . </p><br><p>  Python            <code>asyncio</code> ,       ,         .     ,     ,     ,  ,      Django-size   . </p><br><h3 id="chto-eto-dayot">    </h3><br><p>       Django,     ¬´¬ª;    ,    ,      ‚Äî ,      Django ‚Äî     . </p><br><p>     ,       .      ,    API     ,   Django      -   . </p><br><p>      ,      ,  Django     .             ,    Django ORM ,     ,    ,      -. </p><br><p>  ,   , ‚Äî             .    -   long-poll   server-sent events.  Django          ,    -      . </p><br><h3 id="sinhronnost-vsyo-eschyo-imeet-znachenie">      </h3><br><p>     <em></em>    Django;         .   ,  ,             ,          . </p><br><p> Django          ,    .    ;  Django-   ,         ,  ,     ,     ,     . </p><br><p>      ,       --  Django      . </p><br><h3 id="obratnaya-sovmestimost">   </h3><br><p>  ,    .      ¬´ Django¬ª,       ;     ,        ,          . </p><br><p>  ,      ,     ,        ,    API Django,      ,      ,    Python 3,        API,        Django  Python. </p><br><h3 id="pomosch-python">  Python </h3><br><p> Python     .           Python,  ,    ,     . </p><br><p>   , Django ‚Äî   - Python   ‚Äî   ,    Python,        Python   .      ,       ,    ,        . </p><br><h3 id="privlechenie-novyh-uchastnikov">    </h3><br><p>      ,   Django,              .   ,  Django   ,       . </p><br><p>                   ‚Äî  ,  ,    ,   ,        . </p><br><p>  ,      ‚Äî      ,   , ‚Äî               Django (     ,       Python  ). </p><br><h3 id="chto-takoe-django">   Django? </h3><br><p>      ,   Django.   ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lawrence Journal-World</a>    ‚Äî    ,  , SPA ‚Äî  , ,    .  , ,   ,     ,     . </p><br><p>    ,   Django   ,   - ,    ‚Äî        ‚Äî     . , ,        ; ,     Django    , . </p><br><p>   ,     Django     .     ,       .    ,         ,    ,    ‚Äî ,        ,   . </p><br><h2 id="obosnovanie">  </h2><br><p>    Django       django-developers   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    ,        ,  ,   ,   DEP. </p><br><p>      , ,   ,      : </p><br><ul><li> :       master-        Django    . </li><li>  :     Django    ,    ,    ,     ,      Django       . </li><li> :    ,    ,      Django,   ,  Django.     ,   ,   ,      ,  . </li></ul><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels</a>          DEP ;        Django      ,  . </p><br><p>   ,   ,     .  DEP    ,   ,       ‚Äî      Django           . </p><br><p>                 .     Django, ,     ,    WSGI    ,    event loop     ,      .         10%   ‚Äî     ,      .     ,      . </p><br><p>     ,  ,      (-  ,   Python    ).    ,     Django      ;     ,   ,     ,   Django   master-    . </p><br><p>  ,           ( ORM,    ..),      ;                 Python. </p><br><p>        ,      ,        Django,     ¬´¬ª  .   ,      ,              ,  ,     . </p><br><h3 id="alternativy">  Alternativen </h3><br><p>       ,   ,  , . </p><br><h4 id="asinhronnye-moduli-vmesto-_async-funkciy">    _async  </h4><br><p>        ,    ,     (, <code>django.core.cache.cache.get_async</code> ),               : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core.cache_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache cache.get(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>)</code> </pre> <br><p>   ,           ;   ,    ,        . </p><br><p>   ,    ,      ;       . </p><br><h4 id="fork-django">  Django </h4><br><p> -   ,      ;  ,        ,       ,       ‚Äî  . </p><br><p>           ,   ,     , ‚Äî   ,      . </p><br><h4 id="rasshirenie-channels">  Channels </h4><br><p>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels</a>      , ¬´¬ª  Django. ,     -     ,  ,         Django;      ORM,   HTTP/middleware flow    . </p><br><h4 id="ne-asyncio">  asyncio </h4><br><p>      event loop'  Python,   <code>asyncio</code>          ,   Django.   <code>await</code>  <code>async</code>  Python     event loop   . </p><br><p>   ,   <code>asyncio</code> ,     ; Django     ,        ,   .         Django        ;    , ,      async runtime,    ,    . </p><br><h4 id="greenletsgevent"> Greenlets/Gevent </h4><br><p>       Gevent,      ,      Python. </p><br><p>        ,       .   <code>yield</code>  <code>await</code> ,   API,    Django,       ,         .               ,     . </p><br><p>   ,      ,  ,     .      greenlet-safe   Django ORM   -   new-connection-context,  . </p><br><p>  ,      .   Django     ¬´ ¬ª    gevent, , ,      ,   . </p><br><h2 id="finansirovanie">  </h2><br><p>             DEP. </p><br><p>   ,        ‚Äî        , ‚Äî     ,             (   ). </p><br><p>  ,       ,  -           .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Django Fellows</a>  ;     ‚Äî   ,           (  ), ,   ,  - . </p><br><p>       ‚Äî ,   Kickstarter  <code>migrations</code>  <code>contrib.postgres</code> ,    MOSS (Mozilla)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels</a> .   ,   Django,  ,          . </p><br><p>     , <em></em>     .  ‚Äî      Python,    Django ‚Äî    ‚Äî       .        ,     Django/async,        . </p><br><p>                HTTP/middleware/view flow,     ,  ,  ,      ¬´ ¬ª,      . </p><br><p>     ,     ,     ,            (   ,  Fellows, /     ,     Channels,       ,   ),   ,       . </p><br><p>         ,         ,   ,        ,       Django,      . </p><br><h2 id="obratnaya-sovmestimost-1">   </h2><br><p> , ,   ,       ,            API. </p><br><p>   , ,        ,  , HTTP/middleware flow. ,    API,       APM,     . </p><br><p>  ,  ,   Django     ,     ,      .  ,   ORM  , ,   ‚Äî      ,  ORM             . </p><br><h2 id="etalonnaya-realizaciya">   </h2><br><p>  DEP  ,    ;       Django      . </p><br><p>   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asgiref</a> ,       ,         .      Django         Django. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Channels</a> ,         Django,          Django. </p><br><h2 id="avtorskie-prava">   </h2><br><p>   <em>(  )</em>       <a href="">CC0 1.0 Universal</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461493/">https://habr.com/ru/post/de461493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461471/index.html">.NET - Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 2</a></li>
<li><a href="../de461473/index.html">Debugging-Algorithmen f√ºr Grafiken - jetzt mit Bildern</a></li>
<li><a href="../de461475/index.html">AMA mit Habr. 1011</a></li>
<li><a href="../de461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../de461487/index.html">Mini-CTF-Aufgaben</a></li>
<li><a href="../de461497/index.html">Modernes Text-Rendering unter Linux: Teil 1</a></li>
<li><a href="../de461499/index.html">Welche Sprachen soll Ihr Spiel 2019 √ºbersetzen?</a></li>
<li><a href="../de461501/index.html">Warum untersuchen sie in den USA die Arbeit gro√üer IT-Unternehmen?</a></li>
<li><a href="../de461503/index.html">Bereitstellung der Datenbank f√ºr die Remoteverbindung</a></li>
<li><a href="../de461505/index.html">8 Fehler von unerfahrenen JavaScript-Entwicklern, die Sie daran hindern, professionell zu werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>