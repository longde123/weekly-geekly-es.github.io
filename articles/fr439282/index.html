<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏾 👐🏼 📧 Effets de filtrage SVG. Partie 1. Filtres SVG 101 👌🏽 🚛 🎱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La série d'articles proposée, " SVG Filtering Effects ", par Sara Soueidan, développeur d'interface UI / UX indépendant et auteur de nombreux articles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effets de filtrage SVG. Partie 1. Filtres SVG 101</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439282/"><p>  La série d'articles proposée, " <strong>SVG Filtering Effects</strong> ", par Sara Soueidan, développeur d'interface UI / UX indépendant et auteur de nombreux articles techniques basés au Liban, se concentre sur le travail des filtres SVG et se compose des articles suivants: </p><br><h1 id="effekty-filtracii-svg">  Effets de filtrage SVG </h1><br><ol><li>  Effets des filtres SVG.  Partie 1. Filtres SVG 101. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Effets des filtres SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Texte de contour utilisant feMorphology</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Effets de filtrage SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3. L'effet de la postérisation d'images à l'aide de feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Effets de filtrage SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4. Images bicolores avec <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Effets de filtrage SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5. Correspondance du texte à la texture de la surface avec <strong>feDisplacementMap</strong></a> </li></ol><br><hr><br><p>  Ceci est le premier article d'une série sur les filtres SVG.  Ce guide vous aidera à comprendre de quoi il s'agit et vous montrera comment les utiliser pour créer vos propres effets visuels. </p><br><p><img src="https://habrastorage.org/webt/_8/ka/is/_8kaisnavnh_qmr3tvdsxofq0ii.png"></p><a name="habracut"></a><br><p>  <strong>CSS</strong> nous fournit actuellement un moyen d'appliquer des effets de couleur aux images, tels que la saturation, la luminosité et le contraste, entre autres effets, en utilisant la propriété de <strong>filtre</strong> et ses fonctions qui l'accompagnent. </p><br><p>  Nous avons maintenant 11 fonctions de filtre en CSS qui effectuent un certain nombre d'effets, du flou au changement de contraste et de saturation des couleurs, et bien plus encore.  Pour plus d'informations à ce sujet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consultez la référence CSS</a> . </p><br><p>  Bien que puissants et très pratiques, les filtres CSS sont également très limités.  Les effets que nous pouvons créer avec eux sont souvent applicables aux images et se limitent à la manipulation des couleurs et au simple flou.  Ainsi, pour créer des effets plus puissants que nous pouvons appliquer à une plus large gamme d'éléments, nous avons besoin d'une plus large gamme de fonctions.  Ces fonctionnalités sont disponibles aujourd'hui et sont disponibles depuis plus de dix ans en SVG.  Dans cet article, qui est le premier d'une série sur les filtres SVG, vous découvrirez les fonctions des filtres SVG, appelés «primitives», et comment les utiliser. </p><br><p>  Les filtres CSS sont importés de SVG.  Ce sont des versions assez bien optimisées d'un sous-ensemble des effets de filtrage introduits dans SVG et existant dans la spécification SVG depuis de nombreuses années. </p><br><p>  SVG a plus d'effets de filtrage que CSS, et les versions SVG sont plus puissantes et effectuent des effets beaucoup plus complexes que leurs raccourcis CSS.  Par exemple, vous pouvez actuellement flouter un élément à l'aide de la fonction de filtre CSS <strong>blur ()</strong> .  L'application de l'effet de flou avec cette fonction créera un flou gaussien uniforme de l'élément auquel il est appliqué.  La figure suivante montre le résultat de l'application d'un flou 6px à une image en CSS: </p><br><p><img src="https://habrastorage.org/webt/b0/qa/fy/b0qafyst_uc08euvuxzilp13-wi.png" alt="Effet de l'application de la fonction ** blur () ** - Flou gaussien"><br>  <em>Fig_1.</em>  <em>L'effet de l'application de la fonction CSS <strong>blur ()</strong> est un flou gaussien.</em> </p><br><p>  La fonction <strong>flou ()</strong> crée un effet de flou qui est appliqué uniformément dans les deux directions (X et Y) dans l'image.  Mais cette fonction est simplement une réduction simplifiée et limitée de la primitive de filtre de flou disponible en SVG, ce qui nous permet de flouter l'image de manière uniforme ou d'appliquer un effet de flou unidirectionnel le long des axes X ou Y. </p><br><p><img src="https://habrastorage.org/webt/e5/gp/rr/e5gprr6riymt0ede8sxusumcyfk.png" alt="L'effet de l'application de la fonction SVG ** flou () ** séparément le long des axes"><br>  <em>Fig_2.</em>  <em>L'effet de l'application de la fonction SVG <strong>blur ()</strong> séparément le long des axes.</em> </p><br><p>  Les filtres SVG peuvent être appliqués à la fois aux éléments HTML et aux éléments SVG.  L'effet de filtrage SVG peut être appliqué à un élément HTML en CSS à l'aide de la fonction de filtre url ().  Par exemple, si vous avez un effet de filtre avec l'identifiant <strong>myAwesomeEffect</strong> défini dans SVG (nous parlerons de la définition des effets de filtre dans SVG dans un proche avenir), vous pouvez appliquer cet effet à un élément ou une image HTML comme celui-ci: </p><br><pre><code class="plaintext hljs">.el { filter: url(#myAwesomeEffect); }</code> </pre> <br><p>  Mieux encore, comme vous le verrez dans cette série d'articles, les filtres SVG sont capables de créer des effets de niveau Photoshop dans un navigateur en utilisant quelques lignes de code.  J'espère que cette série contribuera à dissiper le halo du secret et à libérer une partie du potentiel des filtres SVG, ce qui vous incitera à les utiliser dans vos propres projets. </p><br><p>  Mais qu'en est-il du support du navigateur, demandez-vous ..? </p><br><h2 id="podderzhka-brauzerami">  Prise en charge du navigateur </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La prise en charge du navigateur pour la</a> plupart des filtres SVG est impressionnante.  Cependant, la méthode d'application de l'effet peut différer dans certains navigateurs en fonction de leur prise en charge des primitives de filtre individuelles utilisées dans l'effet de filtrage SVG, ainsi que des erreurs de navigateur possibles.  La prise en charge du navigateur peut également différer lorsqu'un filtre SVG est appliqué aux éléments SVG ou aux éléments HTML. </p><br><p>  Je vous recommande de considérer le filtrage des effets comme une extension: vous pouvez presque toujours appliquer un effet comme une amélioration en plus d'une expérience complètement utile sans filtre.  Beaucoup de gens savent que je soutiens l'approche progressive de création d'interface utilisateur dans la mesure du possible.  Ainsi, nous ne nous soucierons pas trop de la prise en charge du navigateur dans cette série d'articles. </p><br><p>  Enfin, bien que la prise en charge des filtres SVG soit généralement bonne, gardez à l'esprit que certains des effets dont nous parlerons plus tard peuvent être considérés comme expérimentaux.  J'indiquerai tout problème majeur ou erreur, si et quand ils le feront. </p><br><p>  Alors, comment définir et créer un effet de filtrage en SVG? </p><br><h2 id="element--filter">  Élément &lt;Filter&gt; </h2><br><p>  Comme les dégradés linéaires, les masques, les motifs et autres effets graphiques dans les SVG, les filtres ont un élément spécialisé nommé de manière pratique: <strong>&lt;filtre&gt;</strong> . </p><br><p>  Il n'est jamais affiché directement, mais est utilisé uniquement comme un objet qui peut être référencé à l'aide de l'attribut <strong>filter</strong> en SVG ou de la fonction <strong>url ()</strong> en CSS.  Les éléments qui ne sont pas affichés sans référence explicite sont généralement définis en tant que modèles dans les éléments <strong>&lt;defs&gt;</strong> dans SVG.  Mais SVG <strong>&lt;filter&gt;</strong> n'a pas besoin d'être enveloppé dans un élément <strong>defs</strong> .  Que vous enveloppiez le filtre dans un élément <strong>defs</strong> ou non, il ne sera pas affiché de toute façon. </p><br><p>  La raison en est que le <strong>filtre nécessite le traitement de l'image d'origine</strong> .  Et si vous ne définissez pas explicitement cette image source en appelant le filtre dessus, le filtre n'aura rien à rendre, et par conséquent cela ne fonctionnera pas. </p><br><p>  Un exemple de code minimal très simple qui définit un filtre SVG et l'applique à l'image originale en SVG ressemblera à ceci: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;!-- filter effects go in here --&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Le filtre dans l'exemple de code ci-dessus ne fait rien pour le moment, car il est vide.  Pour créer un effet de filtre, vous devez définir une série d'une ou plusieurs opérations de filtrage qui créent cet effet à l'intérieur du filtre.  En d'autres termes, l'élément <strong>&lt;filter&gt;</strong> est un conteneur pour une série d'opérations de filtrage qui, ensemble, créent un effet de filtre.  Ces opérations de filtrage en SVG sont appelées « <strong>primitives de filtrage</strong> ». </p><br><h2 id="primitivy-filtra">  Filtrer les primitives </h2><br><p>  Ainsi, en SVG, chaque élément <strong>&lt;filter&gt;</strong> contient un ensemble de primitives de filtre en tant qu'éléments enfants.  Chaque primitive de filtre effectue une opération graphique élémentaire sur une ou plusieurs entrées, créant un résultat graphique. </p><br><p>  Les primitives de filtrage sont nommées de manière pratique d'après les opérations graphiques qu'elles effectuent.  Par exemple, une primitive qui applique l'effet de flou gaussien à une source graphique s'appelle <strong>feGaussianBlur</strong> .  Toutes les primitives ont le même préfixe: fe, abréviation de « <em>filter effect</em> ».  Encore une fois, les noms en SVG sont pratiques pour choisir de comprendre ce qu'est cet élément ou ce qu'il fait. </p><br><p>  L'extrait de code suivant montre à quoi ressemblera un filtre simple si vous appliquez un flou gaussien de 5 pixels à l'image: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;feGaussianBlur stDeviation="5"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Actuellement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la</a> spécification <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>SVG Filter</strong></a> définit 17 primitives de filtre qui sont capables de créer des effets graphiques extrêmement puissants, y compris, mais sans s'y limiter, la génération de bruit et de texture, les effets d'éclairage, la manipulation des couleurs (canal à canal), et bien plus encore. </p><br><p>  La primitive de filtrage fonctionne en acceptant une source graphique pour l'entrée et la sortie vers une autre.  Et la sortie d'un effet de filtre peut être utilisée comme entrée pour un autre.  Ceci est très important et très efficace, car avec presque d'innombrables combinaisons d'effets de filtrage, vous pouvez créer presque d'innombrables effets graphiques. </p><br><p>  Chaque primitive de filtre peut accepter une ou deux entrées et produire un seul résultat.  L'entrée de la primitive de filtre est définie dans l'attribut in.  Le résultat de l'opération est défini dans l'attribut <strong>result</strong> .  Si l'effet de filtre nécessite une deuxième entrée, il est spécifié dans l'attribut <strong>in2</strong> .  Le résultat de l'opération peut être utilisé comme entrée pour toute autre opération, mais si l'entrée de l'opération n'est pas spécifiée dans l'attribut in, le résultat de l'opération précédente est automatiquement utilisé comme entrée.  Si vous ne spécifiez pas le <strong>résultat de la</strong> primitive, son résultat sera automatiquement utilisé comme entrée pour la primitive suivante.  Cela deviendra plus clair lorsque nous commencerons à étudier des exemples de code. </p><br><p>  La primitive de filtrage peut utiliser d'autres types de données en entrée, dont les plus importants sont: </p><br><ul><li>  <strong>SourceGraphic</strong> : élément auquel l'ensemble du filtre est appliqué;  par exemple, une image ou un morceau de texte. </li><li>  <strong>SourceAlpha</strong> : c'est la même chose que <strong>SourceGraphic</strong> , sauf que ce graphique ne contient que le canal alpha de l'élément.  Par exemple, pour une image JPEG, il s'agit d'un rectangle noir de la taille de l'image elle-même. </li></ul><br><p>  Vous constaterez que parfois vous souhaitez utiliser la source graphique comme entrée, et parfois uniquement son canal alpha.  Les exemples que nous couvrirons dans cet article et les articles suivants permettront de comprendre clairement quand et quoi utiliser. </p><br><p>  Cet extrait de code est un exemple de ce à quoi pourrait ressembler un filtre avec un paquet de primitives de filtre en tant qu'enfants.  Ne vous inquiétez pas des primitives et de ce qu'elles font.  À ce stade, faites juste attention à la façon dont les entrées et sorties de certaines primitives sont définies et utilisées.  J'ai ajouté quelques commentaires pour de l'aide. </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="filter"&gt; &lt;feOffset in="SourceAlpha" dx="20" dy="20"&gt;&lt;/feOffset&gt; &lt;!-- since the previous filter did not have a result defined and this following one does not have the input set, the result of the above primitive is automatically used as input to the following filter --&gt; &lt;feGaussianBlur stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- setting/defining the result names in all caps is a good way to make them more distinguishable and the overall code more readable --&gt; &lt;feFlood flood-color="#000" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- This primitive is using the outputs of the previous two primitives as input, and outputting a new effect --&gt; &lt;feComposite in="DROP" in2="COLOR" operator="in" result="SHADOW1"&gt;&lt;/feComposite&gt; &lt;feComponentTransfer in="SHADOW1" result="SHADOW"&gt; &lt;feFuncA type="table" tableValues="0 0.5"&gt;&lt;/feFuncA&gt; &lt;/feComponentTransfer&gt; &lt;!-- You can use ANY two results as inputs to any primitive, regardless of their order in the DOM.--&gt; &lt;feMerge&gt; &lt;feMergeNode in="SHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#filter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Maintenant, le dernier concept que je veux expliquer brièvement avant de passer à notre premier exemple de filtre est le concept de la <strong>région de filtre</strong> . </p><br><h2 id="oblast-filtracii">  Zone de filtration </h2><br><p>  Un ensemble d'opérations de filtrage nécessite une zone à traiter, une zone à laquelle elles peuvent être appliquées.  Par exemple, vous pouvez avoir un SVG complexe avec de nombreux éléments et vous souhaitez appliquer l'effet de filtrage uniquement à une zone spécifique ou à un ou un groupe d'éléments au sein du même SVG. </p><br><p>  En SVG, les éléments ont des «régions» dont les limites sont définies par les bords du rectangle délimitant l'élément.  Un cadre englobant (également abrégé en «bbox») est le plus petit rectangle englobant autour d'un élément.  Par exemple, dans la figure suivante, pour un morceau de texte, un tel rectangle est surligné en rose. </p><br><p><img src="https://habrastorage.org/webt/hu/uy/i1/huuyi1kr0i8ldvfpggxgwpdi6sm.png" alt="Le plus petit rectangle entourant un morceau de texte"><br>  <em>Fig_3.</em>  <em>Le plus petit rectangle englobant autour d'un morceau de texte.</em> </p><br><p>  Veuillez noter que ce rectangle peut contenir quelques espaces verticaux supplémentaires, car la hauteur de la ligne de texte est prise en compte lors du calcul de la hauteur du rectangle de délimitation. </p><br><p>  Par défaut, la zone de filtre d'élément est le cadre d'élément bordant.  Par conséquent, si vous appliquez un effet de filtre à notre fragment de texte, l'effet sera limité à ce rectangle et tout résultat de filtrage en dehors de celui-ci sera coupé.  Bien que cela soit raisonnable, ce n'est pas très pratique, car de nombreux filtres affecteront certains pixels en dehors de la zone de délimitation et, par défaut, ces pixels seront finalement coupés. </p><br><p>  Par exemple, si vous appliquez un effet de flou à notre fragment de texte, vous pouvez voir qu'il est rogné le long des bords gauche et droit du rectangle délimitant le texte: </p><br><p><img src="https://habrastorage.org/webt/ll/ih/e4/llihe4hbwx94zl3xk-w9zmcmmkq.png" alt="L'effet de flou appliqué au texte est rogné sur les côtés droit et gauche du rectangle délimitant le texte."><br>  <em>Fig_4.</em>  <em>L'effet de flou appliqué au texte est rogné sur les côtés droit et gauche du rectangle délimitant le texte.</em> </p><br><p>  Alors, comment pouvons-nous empêcher cela?  La réponse est: en élargissant la zone de filtrage.  Nous pouvons étendre la portée à laquelle le filtre est appliqué en modifiant les attributs <strong>x</strong> , <strong>y</strong> , <strong>width</strong> et <strong>height</strong> de l'élément &lt;filter&gt;. </p><br><p>  Selon la spécification, </p><br><blockquote>  Il est souvent nécessaire de fournir des champs dans la zone de filtre, car l'effet de filtre peut affecter certains bits en dehors de la zone de délimitation pour un objet donné.  Pour ce faire, vous pouvez attribuer des valeurs négatives en pourcentage aux propriétés <strong>X</strong> et <strong>Y</strong> et des valeurs supérieures à 100% aux propriétés <strong>largeur</strong> et <strong>hauteur</strong> . </blockquote><p>  Par défaut, les filtres ont des zones qui s'étendent sur 10% de la largeur et de la hauteur du cadre de sélection dans les quatre directions.  En d'autres termes, les valeurs par défaut pour les attributs <strong>x</strong> , <strong>y</strong> , <strong>largeur</strong> et <strong>hauteur</strong> sont: </p><br><pre> <code class="plaintext hljs">&lt;filter x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"&gt; &lt;!-- filter operations here --&gt; &lt;/filter&gt;</code> </pre> <br><p>  Si vous n'incluez pas ces attributs dans l'élément <strong>&lt;filter&gt;</strong> , les valeurs par défaut seront utilisées.  Vous pouvez également les remplacer pour agrandir ou réduire la zone selon vos besoins. </p><br><p>  Gardez à l'esprit que les unités utilisées dans les attributs <strong>x</strong> , <strong>y</strong> , <strong>width</strong> et <strong>height</strong> dépendent de la <strong>valeur d'</strong> attribut <strong>filterUnits</strong> utilisée.  Il définit le système de coordonnées des attributs <strong>x</strong> , <strong>y</strong> , <strong>largeur</strong> et <strong>hauteur</strong> et peut prendre l'une des deux valeurs suivantes: </p><br><ul><li>  <strong>objectBoundingBox</strong> .  Il s'agit de la valeur par défaut.  Lorsque <strong>filterUnits</strong> est défini sur <strong>objectBoundingBox</strong> , les valeurs d'attribut <strong>x</strong> , <strong>y</strong> , <strong>width</strong> et <strong>height</strong> sont des pourcentages ou des fractions de la taille du cadre de sélection de l'élément.  Cela signifie également que vous pouvez utiliser des valeurs fractionnaires au lieu de pourcentages si vous préférez. </li><li>  <strong>userSpaceOnUse</strong> Si <strong>filterUnits</strong> est défini sur <strong>userSpaceOnUse</strong> , les coordonnées des attributs x, y, largeur et hauteur sont relatives au système de coordonnées actuel utilisé par l'utilisateur.  En d'autres termes, cela est relatif au système de coordonnées actuel utilisé dans le SVG, qui utilise les pixels comme unité de mesure, et généralement relatif à la taille du SVG lui-même, en supposant que les valeurs de <strong>viewBox</strong> correspondent aux valeurs du système de coordonnées d'origine. </li></ul><br><blockquote>  Tout ce que vous devez savoir sur les systèmes de coordonnées en SVG se trouve dans cet article, que j'ai écrit il y a plusieurs années. </blockquote><br><pre> <code class="plaintext hljs">&lt;!-- Using objectBoundingBox units --&gt; &lt;filter id="filter" x="5%" y="5%" width="100%" height="100%"&gt; &lt;!-- Using userSpaceOnUse units --&gt; &lt;filter id="filter" filterUnits="userSpaceOnUse" x="5px" y="5px" width="500px" height="350px"&gt;</code> </pre> <br><h3 id="bystryy-sovet-vizualizaciya-tekuschey-oblasti-filtra-s-pomoschyu-feflood">  Astuce rapide: visualiser la zone de filtre actuelle avec feFlood </h3><br><p>  Si vous avez besoin de voir les limites d'une zone de filtre, vous pouvez la visualiser en la remplissant de couleur.  Idéalement, il existe une primitive de filtre appelée <strong>feFlood</strong> , dont le seul but est précisément ceci: remplir la zone de filtre actuelle avec la couleur spécifiée dans l'attribut <strong>flood-color</strong> . </p><br><p>  Donc, si nous supposons que nous avons un morceau de texte dont nous voulons voir la zone de filtre, le code peut ressembler à ceci: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder" x="0" y="0" width="100%" height="100%"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9"&gt;&lt;/feFlood&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Comme vous pouvez le voir dans l'extrait de code ci-dessus, la primitive <strong>feFlood</strong> accepte également l'attribut <strong>flood-opacity</strong> , qui peut être utilisé pour créer la transparence du calque de couleur de remplissage. </p><br><p>  L'extrait ci-dessus remplit la zone de filtre de rose.  Mais voici le problème: lorsque vous remplissez la zone de couleur, vous la remplissez littéralement de couleur, ce qui signifie que la couleur couvrira tout dans la zone de filtre, y compris tous les éléments et effets que vous avez créés précédemment, ainsi que le texte lui-même.  Après tout, c'est le concept de remplissage, non? </p><br><p><img src="https://habrastorage.org/webt/aj/pc/qc/ajpcqctctaikdiirvjexjeuh6yg.png" alt="Avant et après avoir rempli la zone de texte du filtre avec de la couleur"><br>  <em>Fig_5.</em>  <em>Avant et après avoir rempli la zone de texte du filtre avec de la couleur.</em> </p><br><p>  Pour changer cela, nous devons déplacer le calque de couleur ci-dessous et afficher le calque de texte d'origine en haut. </p><br><p>  Si vous avez plusieurs couches de contexte qui doivent être affichées les unes sur les autres dans le filtre SVG, vous pouvez utiliser la primitive de filtre <strong>&lt;feMerge&gt;</strong> .  Comme son nom l'indique, la primitive <strong>feMerge est</strong> utilisée pour combiner des couches d'éléments ou d'effets. </p><br><p>  La primitive <strong>n'a pas d'attribut in.</strong>  <strong>Pour fusionner les couches à l'intérieur de <strong>&lt;feMerge&gt;</strong> , deux ou plusieurs <strong>&lt;feMergeNode&gt; sont utilisés</strong> , chacun ayant son propre attribut <strong>dans</strong> , qui représente la couche que nous voulons ajouter.</strong> <br></p><p>  La pose de la couche (ou «nœud») dépend de l'ordre de la source <strong>&lt;feMergeNode&gt;</strong> - le premier <strong>&lt;feMergeNode&gt; est</strong> affiché «derrière» ou «en dessous» du second.  Le dernier <strong>&lt;feMergeNode&gt;</strong> représente la couche supérieure.  Et ainsi de suite. </p><br><p>  Ainsi, dans notre exemple avec du texte, le remplissage de couleur est un calque et la source de texte (source graphique) est un calque différent, et nous voulons placer le texte au-dessus du remplissage de couleur.  Notre code ressemblera à ceci: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9" result="FLOOD"&gt;&lt;/feFlood&gt; &lt;feMerge&gt; &lt;feMergeNode in="FLOOD" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Remarquez comment j'ai nommé le résultat de <strong>feFlood</strong> dans l'attribut <strong>result</strong> , afin de pouvoir utiliser ce nom dans la couche <strong>&lt;feMergeNode&gt;</strong> en entrée.  Puisque nous voulons afficher le texte source au-dessus de la couleur du flux, nous référençons ce texte à l'aide de <strong>SourceGraphic</strong> .  La démo suivante montre le résultat: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/SaraSoueidan/embed/preview/dJddbK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="primenenie-teni-k-izobrazheniyu">  Appliquer une ombre à une image </h2><br><p>  Permettez-moi de commencer par un bref avertissement: vous feriez mieux de créer une ombre simple à l'aide de la fonction de filtrage CSS <strong>drop-shadow ()</strong> .  Le chemin du filtre SVG est beaucoup plus détaillé.  Après tout, comme nous l'avons mentionné précédemment, les fonctions de filtre CSS sont des raccourcis pratiques.  Mais je veux toujours considérer cet exemple comme un simple point d'entrée vers des effets de filtre plus complexes, que nous aborderons dans les prochains articles. </p><br><p>  Alors, comment l'ombre est-elle créée? </p><br><p>  Une ombre est généralement une couche gris clair derrière ou au-dessous d'un élément qui a la même forme (ou forme) que l'élément lui-même.  En d'autres termes, vous pouvez considérer cela comme une copie grise floue de l'élément. </p><br><p>  Lors de la création de filtres SVG, vous devez raisonner par étapes.  Quelles sont les étapes nécessaires pour atteindre tel ou tel effet?  Pour une ombre, une copie grise floue d'un élément peut être créée en brouillant une copie noire de l'élément puis en coloriant cette copie noire, c'est-à-dire  la rendre grise.  Ensuite, cette copie grise floue nouvellement créée est placée derrière l'élément d'origine et est légèrement décalée dans les deux sens. </p><br><p>  Donc, nous <strong>allons commencer par obtenir une copie noire de notre élément et le brouiller</strong> .  Une copie noire peut être créée en utilisant le canal alpha de l'élément, en utilisant <strong>SourceAlpha</strong> comme entrée de filtre. </p><br><p>  La primitive <strong>feGaussianBlur</strong> sera utilisée pour appliquer un flou gaussien à cette couche SourceAlpha.  La quantité de flou requise est définie dans l'attribut <strong>stdDeviation</strong> (abréviation de Standard Deviation).  Si vous définissez une valeur de l'attribut <strong>stdDeviation</strong> , cette valeur sera utilisée pour appliquer un flou uniforme des données d'entrée.  Vous pouvez également spécifier deux valeurs numériques, puis la première sera utilisée pour flouter l'élément dans le sens horizontal et la seconde pour le flou vertical.  Pour l'ombre, nous devons appliquer un flou uniforme, donc notre code commencera par ceci: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;-- Grab a blakc copy of the source image and blur it by 10 --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  L'extrait de code ci-dessus conduit à l'effet suivant, où seul le canal alpha flou de l'image est actuellement affiché: </p><br><p><img src="https://habrastorage.org/webt/zd/e9/ye/zde9ye5ycftyjmi_cru94ty3jde.png" alt="Image de copie noire créée avec flou (ombre)"><br>  <em>Fig_6.</em>  <em>Création d'une copie noire de l'image avec flou (ombre).</em> </p><br><p>  Ensuite, nous voulons <strong>changer la couleur de l'ombre et la rendre grise</strong> .  Nous le ferons en appliquant un remplissage de couleur à la zone de filtre, puis en combinant ce calque de remplissage de couleur avec le calque d'ombre que nous avons créé. </p><br><p>  L'alignement est la connexion d'un élément graphique avec un arrière-plan flou.  L'arrière-plan flou est le contenu derrière l'élément avec lequel l'élément est aligné.  Dans notre filtre, la couleur de remplissage est la couche supérieure et l'ombre floue est son arrière-plan, car elle se trouve derrière.  Nous examinerons la primitive <strong>feComposite</strong> plus en détail dans les articles suivants, donc si vous n'êtes pas familier avec la composition et comment cela fonctionne, alors je vous recommande de lire un <strong>article détaillé</strong> sur ce sujet dans mon blog. </p><br><p>  La primitive <strong>feComposite</strong> a un attribut <strong>opérateur</strong> , qui est utilisé pour indiquer quelle opération composée nous voulons utiliser. </p><br><p>  En utilisant l'opérateur <strong>in composite</strong> , le calque de remplissage de couleur sera «découpé» et seule la région de couleur correspondant à notre calque d'ombre sera affichée.  Les deux couches seront mélangées là où elles se croisent, c'est-à-dire  la couleur grise sera utilisée pour colorer notre ombre noire. </p><br><p>  <strong>feComposite</strong>      ,    <strong>in</strong>  <strong>in2</strong> .   —    ,   —   .    ,    <strong>operator</strong> ,      : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  ,   <strong>feGaussianBlur</strong>   <strong>feFlood</strong>       .     : </p><br><p><img src="https://habrastorage.org/webt/_c/c7/an/_cc7an_zj43v7gv4jka--6mpnpi.png" alt="Maintenant, l'ombre est grise"><br> <em>_7.   .</em> </p><br><p>  ,        ,       / .          .     ,      ,       ,          . </p><br><p>     SVG   <strong>feOffset</strong> .    <strong>in</strong>  <strong>result</strong>      : <strong>dx</strong>  <strong>dy</strong> ,   ,         X  Y . </p><br><p>   ,       ,  <strong>feMerge</strong> ,  ,           —  <strong>mergeNode</strong>       ,    <strong>mergeNode</strong>    ,  <strong>SourceGraphic</strong>    .     : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;!-- Get the source alpha and blur it; we'll name the result "DROP" --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- flood the region with a ligh grey color; we'll name this layer "COLOR" --&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- Composite the DROP and COLOR layers together to colorize the shadow. The result is named "SHADOW" --&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;!-- Move the SHADOW layer 20 pixels down and to the right. The new layer is now called "DROPSHADOW" --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- Layer the DROPSHADOW and the Source Image, ensuring the image is positioned on top (remember: MergeNode order matters) --&gt; &lt;feMerge&gt; &lt;feMergeNode in="DROPSHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- Apply the filter to the source image in the `filter` attribute --&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/SaraSoueidan/embed/preview/qpoqwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         SVG,   SVG.  ,        . </p><br><h2 id="est-drugoy-sposob">   … </h2><br><p>  ,     .  ,         ,    ,      ,    , , . </p><br><p>     ,     ,  <strong>feFlood</strong> ,  ,  , ,      .    ,    .    ,    ,     , ,  - ,  , ,    . </p><br><p>         <strong>feColorMatrix</strong> ,  <strong>feComponentTransfer</strong> .   <strong>feComponentTransfer</strong>       ,    <strong>feColorMatrix</strong> ,     . </p><br><p>  <strong>feColorMatrix</strong>   .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Una Kravet</a> ,        . </p><br><p>  ,        R(), G(), B()  A()              -.  ,       .     : </p><br><pre> <code class="plaintext hljs">&lt;filter id="myFilter"&gt; &lt;feColorMatrix type="matrix" values="R 0 0 0 0 0 G 0 0 0 0 0 B 0 0 0 0 0 A 0 "/&gt; &lt;/feColorMatrix&gt; &lt;/filter&gt;</code> </pre> <br><p>      ,      . </p><br><p>        ,     ,     RGB,     -   : </p><br><pre> <code class="plaintext hljs">&lt;filter id="filter"&gt; &lt;!-- Get the source alpha and blur it, --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- offset the drop shadow --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- make the shadow translucent by reducing the alpha channel value to 0.3 --&gt; &lt;feColorMatrix type="matrix" in="DROPSHADOW" result="FINALSHADOW" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"&gt; &lt;/feColorMatrix&gt; &lt;!-- Merge the shadow and the source image --&gt; &lt;feMerge&gt; &lt;feMergeNode in="FINALHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt;</code> </pre> <br><p>     : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/SaraSoueidan/embed/preview/opEZee" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>                   .         ,    .         ,         .  ,       ,   ,   ,   ,    .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .   ,     ,  ,         .             . </p><br><p> ,     SVG-      ,            .  Reste avec nous. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439282/">https://habr.com/ru/post/fr439282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439268/index.html">Comment VR, AR et l'impression 3D fonctionnent ensemble: expérience VR Concept</a></li>
<li><a href="../fr439270/index.html">Un exemple d'analyse de code C ++ à l'aide de libclang en Python</a></li>
<li><a href="../fr439272/index.html">Notebook Jupyter sur Netflix</a></li>
<li><a href="../fr439278/index.html">ACS de mon LCD - sécurité sur deux boulons</a></li>
<li><a href="../fr439280/index.html">Trautonium: la vague allemande dans l'histoire des synthétiseurs</a></li>
<li><a href="../fr439286/index.html">À propos de l'analyse statique en toute honnêteté</a></li>
<li><a href="../fr439288/index.html">SciPy, optimisation</a></li>
<li><a href="../fr439290/index.html">Accélérez la compilation dans Xcode sur Swift</a></li>
<li><a href="../fr439294/index.html">Révision de la traduction "Si un logiciel est créé avec de l'argent public, le code doit être ouvert"</a></li>
<li><a href="../fr439296/index.html">Plaque d'immatriculation soviétique et complexité de Kolmogorov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>