<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ· ğŸŒ“ ğŸ›… Menulis Jaringan Saraf Sederhana Menggunakan Matematika dan Numpy ğŸŒ ğŸŒ  â˜€ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa artikel selanjutnya tentang cara menulis jaringan saraf dari awal? Sayangnya, saya tidak dapat menemukan artikel di mana teori dan kode dijela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis Jaringan Saraf Sederhana Menggunakan Matematika dan Numpy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460589/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5_/h5/0t/5_h50teeaqngyx0ccp8cqjqfumm.jpeg" width="350"></div><br>  Mengapa artikel selanjutnya tentang cara menulis jaringan saraf dari awal?  Sayangnya, saya tidak dapat menemukan artikel di mana teori dan kode dijelaskan dari awal hingga model yang berfungsi penuh.  Saya segera memperingatkan bahwa akan ada banyak matematika.  Saya berasumsi bahwa pembaca akrab dengan dasar-dasar aljabar linier, turunan parsial, dan setidaknya sebagian, dengan teori probabilitas, serta Python dan Numpy.  Kami akan berurusan dengan jaringan saraf yang terhubung penuh dan MNIST. <br><a name="habracut"></a><br><h2>  Matematika  Bagian 1 (sederhana) </h2><br>  Apa itu lapisan yang terhubung penuh (lapisan FC)?  Biasanya mereka mengatakan sesuatu seperti "Lapisan yang sepenuhnya terhubung adalah lapisan, masing-masing neuron yang terhubung ke semua neuron dari lapisan sebelumnya".  Hanya tidak jelas apa itu neuron, bagaimana mereka terhubung, terutama dalam kode.  Sekarang saya akan mencoba menguraikan ini dengan sebuah contoh.  Biarkan ada lapisan 100 neuron.  Saya tahu bahwa saya belum menjelaskan apa itu, tetapi mari kita bayangkan bahwa ada 100 neuron dan mereka memiliki input dari mana data dikirim, dan output dari mana mereka memberikan data.  Dan gambar hitam-putih 28x28 piksel diumpankan ke input - hanya 784 nilai, jika Anda merentangkannya menjadi vektor.  Gambar dapat disebut lapisan input.  Kemudian, untuk masing-masing dari 100 neuron untuk terhubung dengan setiap "neuron" atau, jika Anda suka, nilai dari lapisan sebelumnya (yaitu, gambar), perlu bahwa masing-masing dari 100 neuron menerima 784 nilai dari gambar asli.  Sebagai contoh, untuk masing-masing dari 100 neuron itu akan cukup untuk melipatgandakan nilai 784 gambar dengan sekitar 784 angka dan menambahkannya bersama-sama, sebagai hasilnya, satu angka keluar.  Artinya, ini adalah neuron: <br><p><math> </math> $$ menampilkan $$ \ teks {Output neuron} = \ teks {beberapa angka} _ {1} \ cdot \ teks {nilai gambar} _1 ~ + \\ + ~ ... ~ + ~ \ teks {some- angka itu} _ {784} \ cdot \ text {nilai gambar} _ {784} $$ menampilkan $$ </p><br>  Kemudian ternyata setiap neuron memiliki 784 angka, dan semua angka ini: (jumlah neuron pada lapisan ini) x (jumlah neuron pada lapisan sebelumnya) = <math> </math> $ inline $ 100 \ times784 $ inline $   = 78.400 digit.  Angka-angka ini biasa disebut layer weight.  Setiap neuron akan memberikan jumlahnya dan sebagai hasilnya kita mendapatkan vektor 100 dimensi, dan pada kenyataannya kita dapat menulis bahwa vektor 100 dimensi ini diperoleh dengan mengalikan vektor 784 dimensi (gambar asli kita) dengan ukuran matriks ukuran <math> </math> $ inline $ 100 \ times784 $ inline $   : <br><p><math> </math> $$ tampilkan $$ \ boldsymbol {x} ^ {100} = W_ {100 \ times784} \ cdot \ boldsymbol {x} ^ {784} $$ tampilkan $$ </p><br><br>  Selanjutnya, 100 nomor yang dihasilkan diteruskan, ke fungsi aktivasi - beberapa fungsi non-linear - yang mempengaruhi masing-masing nomor secara terpisah.  Misalnya sigmoid, singgung hiperbolik, ReLU dan lainnya.  Fungsi aktivasi tentu non-linear, jika tidak, jaringan saraf akan belajar hanya transformasi sederhana. <br><br><img src="https://habrastorage.org/webt/0j/rl/ba/0jrlbaqv0486mryhqj32u8et0cw.png"><br><br>  Kemudian, data yang dihasilkan diumpankan kembali ke lapisan yang sepenuhnya terhubung, tetapi dengan jumlah neuron yang berbeda, dan lagi ke fungsi aktivasi.  Ini terjadi beberapa kali.  Lapisan terakhir dari jaringan adalah lapisan yang menghasilkan jawaban.  Dalam hal ini, jawabannya adalah informasi tentang nomor dalam gambar. <br><br><img src="https://habrastorage.org/webt/9f/73/q-/9f73q-feve3kb5k9u5fxvmz4kxk.png"><br><br>  Selama pelatihan jaringan, kita perlu tahu angka apa yang ditunjukkan pada gambar.  Yaitu, bahwa dataset ditandai.  Kemudian Anda dapat menggunakan elemen lain - fungsi kesalahan.  Dia melihat respon dari jaringan saraf dan membandingkannya dengan jawaban yang sebenarnya.  Berkat ini, jaringan saraf sedang belajar. <br><br><h2>  Pernyataan umum masalah </h2><br>  Seluruh dataset adalah tensor besar (kami akan memanggil array data multidimensi tensor) <math> </math> $ sebaris $ \ boldsymbol {X} = \ kiri [\ boldsymbol {x} _1, \ boldsymbol {x} _2, \ ldots, \ boldsymbol {x} _n \ kanan] $ inline $   dimana <math> </math> $ inline $ \ boldsymbol {x} _i $ inline $   - Objek ke-i, misalnya, gambar, yang juga merupakan tensor.  Untuk setiap objek ada <math> </math> $ inline $ y_i $ inline $   - jawaban yang benar pada objek ke-i.  Dalam hal ini, jaringan saraf dapat direpresentasikan sebagai beberapa fungsi yang mengambil objek sebagai input dan memberikan beberapa jawaban padanya: <br><p><math> </math> $$ menampilkan $$ F (\ boldsymbol {x} _i) = \ hat {y} _i $$ menampilkan $$ </p><br>  Sekarang mari kita lihat lebih dekat fungsi <math> </math> $ inline $ F (\ boldsymbol {x} _i) $ inline $   .  Karena jaringan saraf terdiri dari lapisan, setiap lapisan individu adalah fungsi.  Dan itu artinya <br><p><math> </math> $$ menampilkan $$ F (\ boldsymbol {x} _i) = f_k (f_ {k-1} (\ ldots (f_1 (\ boldsymbol {x} _i)))) = \ hat {y} _i $$ display $ $ </p><br>  Artinya, pada fungsi paling pertama - lapisan pertama - gambar disajikan dalam bentuk tensor.  Fungsi <math> </math> $ inline $ f_1 $ inline $   memberikan beberapa jawaban - juga tensor, tetapi dari dimensi yang berbeda.  Tensor ini akan disebut representasi internal.  Sekarang representasi internal ini diumpankan ke input fungsi <math> </math> $ inline $ f_2 $ inline $   , yang memberikan representasi internal.  Begitu seterusnya, hingga fungsinya <math> </math> $ inline $ f_k $ inline $   - lapisan terakhir - tidak akan memberikan jawaban <math> </math> $ inline $ \ hat {y} _i $ inline $   . <br><br>  Sekarang, tugasnya adalah melatih jaringan - untuk membuat jawaban jaringan cocok dengan jawaban yang benar.  Pertama, Anda perlu mengukur seberapa salah jaringan saraf itu.  Mengukur ini adalah fungsi kesalahan. <math> </math> $ inline $ L (\ hat {y} _i, y_i) $ inline $   .  Dan kami memberlakukan batasan: <br><br>  1. <math> </math> $ inline $ \ hat {y} _i \ xrightarrow {} y_i \ Rightarrow L (\ hat {y} _i, y_i) \ xrightarrow {} 0 $ inline $ <br>  2. <math> </math> $ inline $ \ exist ~ dL (\ hat {y} _i, y_i) $ inline $ <br>  3. <math> </math> $ inline $ L (\ hat {y} _i, y_i) \ geq 0 $ inline $ <br><br>  Pembatasan 2 dikenakan pada semua fungsi lapisan <math> </math> $ inline $ f_j $ inline $   - biarkan semuanya dibedakan. <br><br>  Selain itu, pada kenyataannya (saya tidak menyebutkan ini) beberapa fungsi ini tergantung pada parameter - bobot jaringan saraf - <math> </math> $ inline $ f_j (\ boldsymbol {x} _i | \ boldsymbol {\ omega} _j) $ inline $   .  Dan seluruh idenya adalah untuk mengambil bobot tersebut sehingga <math> </math> $ inline $ \ hat {y} _i $ inline $   bertepatan dengan <math> </math> $ inline $ y_i $ inline $   pada semua objek dataset.  Saya perhatikan bahwa tidak semua fungsi memiliki bobot. <br><br>  Jadi, di mana kita berhenti?  Semua fungsi jaringan saraf dapat dibedakan, fungsi kesalahan juga dapat dibedakan.  Ingat salah satu sifat gradien - tunjukkan arah pertumbuhan fungsi.  Kami menggunakan ini, pembatasan 1 dan 3, fakta itu <br><p><math> </math> $$ menampilkan $$ L (F (\ boldsymbol {x} _i)) = L (f_k (f_ {k-1} (\ ldots (f_1 (\ boldsymbol {x} _i)))))) = L (\ hat {y} _i) $$ tampilkan $$ </p><br>  dan fakta bahwa saya dapat mempertimbangkan turunan parsial dan turunan dari fungsi yang kompleks.  Sekarang ada semua yang Anda butuhkan untuk menghitung <br><p><math> </math> $$ tampilkan $$ \ frac {\ partial L (F (\ boldsymbol {x} _i))} {\ partial \ boldsymbol {\ omega_j}} $$ tampilkan $$ </p><br>  untuk i dan j.  Derivatif parsial ini menunjukkan arah perubahan <math> </math> $ inline $ \ boldsymbol {\ omega_j} $ inline $   untuk memperbesar <math> </math> $ inline $ L $ inline $   .  Untuk mengurangi Anda perlu mengambil langkah ke samping <math> </math> $ inline $ - \ frac {\ partial L (F (\ boldsymbol {x} _i))} {\ partial \ boldsymbol {\ omega_j}} $ inline $   tidak ada yang rumit. <br><br>  Jadi proses pelatihan jaringan dibangun sebagai berikut: beberapa kali dalam satu siklus kita melewati seluruh dataset (ini disebut era), untuk setiap objek dataset yang kita pertimbangkan <math> </math> $ inline $ L (\ hat {y} _i, y_i) $ inline $   (ini disebut forward pass) dan pertimbangkan turunan parsial <math> </math> $ inline $ \ partial L $ inline $   untuk semua bobot <math> </math> $ inline $ \ boldsymbol {\ omega_j} $ inline $   , lalu perbarui bobot (ini disebut backward pass). <br><br>  Saya perhatikan bahwa saya belum memperkenalkan fungsi dan lapisan tertentu.  Jika pada tahap ini tidak jelas apa yang harus dilakukan dengan semua ini, saya usulkan untuk terus membaca - akan ada lebih banyak matematika, tetapi sekarang akan dilanjutkan dengan contoh. <br><br><h2>  Matematika  Bagian 2 (sulit) </h2><br><h3>  Fungsi kesalahan </h3><br>  Saya akan mulai dari akhir dan menampilkan fungsi kesalahan untuk masalah klasifikasi.  Untuk masalah regresi, derivasi dari fungsi kesalahan dijelaskan dengan baik dalam buku "Belajar Dalam.  Perendaman dalam dunia jaringan saraf. " <br><br>  Untuk kesederhanaan, ada jaringan saraf (NN) yang memisahkan foto kucing dari foto anjing, dan ada satu set foto kucing dan anjing yang ada jawaban yang benar <math> </math> $ inline $ y_ {true} $ inline $   . <br><p><math> </math> $$ menampilkan $$ NN (gambar | \ Omega) = y_ {pred} $$ menampilkan $$ </p><br>  Semua yang akan saya lakukan selanjutnya sangat mirip dengan metode kemungkinan maksimum.  Oleh karena itu, tugas utama adalah menemukan fungsi kemungkinan.  Jika kita menghilangkan detail, maka fungsi yang membandingkan prediksi jaringan saraf dan jawaban yang benar, dan jika mereka bertepatan, memberikan nilai yang besar, jika tidak, sebaliknya.  Peluang jawaban yang benar muncul di benak Anda dengan parameter yang diberikan: <br><p><math> </math> $$ menampilkan $$ p (y_ {pred} = y_ {true} | \ Omega) $$ menampilkan $$ </p><br>  Dan sekarang kita akan membuat tipuan, yang, sepertinya, tidak mengikuti dari mana saja.  Biarkan jaringan saraf memberikan jawaban dalam bentuk vektor dua dimensi, jumlah nilai-nilainya adalah 1. Elemen pertama dari vektor ini dapat disebut ukuran keyakinan bahwa kucing ada di foto, dan elemen kedua adalah ukuran keyakinan bahwa anjing ada di foto.  Ya, ini hampir merupakan probabilitas! <br><p><math> </math> $$ menampilkan $$ NN (gambar | \ Omega) = \ kiri [\ mulai {matrix} p_0 \\ p_1 \\ end {matrix} \ kanan] $$ menampilkan $$ </p><br>  Sekarang fungsi likelihood dapat ditulis ulang sebagai: <br><p><math> </math> $$ menampilkan $$ p (y_ {pred} = y_ {true} | \ Omega) = p_ \ Omega (y_ {pred}) ^ t_ {0} * (1 - p_ \ Omega (y_ {pred})) ^ t_ {1} = \\ p_0 ^ {t_0} * p_1 ^ {t_1} $$ menampilkan $$ </p><br>  Dimana <math> </math> $ inline $ t_0, t_1 $ inline $   label dari kelas yang benar, misalnya, jika <math> </math> $ inline $ y_ {true} = cat $ inline $   lalu <math> </math> $ inline $ t_0 == 1, t_1 == $ $ inline $   jika <math> </math> $ inline $ y_ {true} = dog $ inline $   lalu <math> </math> $ inline $ t_0 == 0, t_1 == 1 $ inline $   .  Dengan demikian, probabilitas kelas yang seharusnya diprediksi oleh jaringan saraf (tetapi tidak harus diprediksi olehnya) selalu dipertimbangkan.  Sekarang ini dapat digeneralisasi ke sejumlah kelas (misalnya, kelas m): <br><p><math> </math> $$ menampilkan $$ p (y_ {pred} = y_ {true} | \ Omega) = \ prod_0 ^ m p_i ^ {t_i} $$ menampilkan $$ </p><br>  Namun, dalam dataset apa pun ada banyak objek (misalnya, objek N).  Saya ingin jaringan saraf untuk memberikan jawaban yang benar pada masing-masing atau sebagian besar objek.  Dan untuk ini, Anda perlu mengalikan hasil rumus di atas untuk setiap objek dari dataset. <br><p><math> </math> $$ tampilkan $$ MaximumLikelyhood = \ prod_ {j = 0} ^ N \ prod_ {i = 0} ^ m p_ {i, j} ^ {t_ {i, j}} $$ display $$ </p><br>  Untuk mendapatkan hasil yang baik, fungsi ini perlu dimaksimalkan.  Tapi, pertama, lebih curam untuk meminimalkan, karena kami memiliki keturunan gradien stokastik dan semua roti untuk itu - hanya menetapkan minus, dan kedua, sulit untuk bekerja dengan pekerjaan besar - itu logaritma. <br><p><math> </math> $$ tampilkan $$ CrossEntropyLoss = - \ jumlah \ limit_ {j = 0} ^ {N} \ jumlah \ limit_ {i = 0} ^ {m} t_ {i, j} \ cdot \ log (p_ {i, j }) $$ menampilkan $$ </p><br>  Hebat!  Hasilnya adalah entropi silang atau, dalam kasus biner, logloss.  Fungsi ini mudah untuk dihitung dan bahkan lebih mudah untuk dibedakan: <br><p><math> </math> $$ tampilkan $$ \ frac {\ partial CrossEntropyLoss} {\ partial p_j} = - \ frac {\ boldsymbol {t_j}} {\ boldsymbol {p_ {j}}} $$ display $$ </p><br>  Anda perlu membedakan untuk algoritma backpropagation.  Saya perhatikan bahwa fungsi kesalahan tidak mengubah dimensi vektor.  Jika, seperti dalam kasus MNIST, outputnya adalah vektor jawaban 10-dimensi, maka ketika menghitung turunannya, kita mendapatkan vektor turunan 10-dimensi.  Hal lain yang menarik adalah bahwa hanya satu elemen turunan tidak akan nol, di mana <math> </math> $ inline $ t_ {i, j} \ neq 0 $ inline $   , yaitu, dengan jawaban yang benar.  Dan semakin kecil kemungkinan jawaban yang benar diprediksi oleh jaringan saraf pada objek yang diberikan, semakin banyak fungsi kesalahan di dalamnya. <br><br><h3>  Fitur aktivasi </h3><br>  Pada output dari setiap lapisan yang terhubung penuh dari jaringan saraf, fungsi aktivasi nonlinier harus ada.  Tanpa itu, tidak mungkin untuk melatih jaringan saraf yang bermakna.  Ke depan, lapisan jaringan neural yang terhubung sepenuhnya hanyalah perkalian dari data input dengan matriks bobot.  Dalam aljabar linier, ini disebut peta linier - fungsi linier.  Kombinasi fungsi linier juga merupakan fungsi linier.  Tetapi ini berarti bahwa fungsi seperti itu hanya dapat mendekati fungsi linear.  Sayangnya, ini bukan mengapa jaringan saraf diperlukan. <br><br><h4>  Softmax </h4><br>  Biasanya fungsi ini digunakan pada lapisan terakhir jaringan, karena ia mengubah vektor dari lapisan terakhir menjadi vektor "probabilitas": setiap elemen vektor terletak dari 0 hingga 1 dan jumlahnya adalah 1. Tidak mengubah dimensi vektor. <br><p><math> </math> $$ menampilkan $$ Softmax_i = \ frac {e ^ {x_i}} {\ jumlah \ limit_ {j} e ^ {x_j}} $$ menampilkan $$ </p><br>  Sekarang mari kita beralih ke pencarian turunan.  Sejak <math> </math> $ inline $ \ boldsymbol {x} $ inline $   Merupakan vektor, dan semua elemennya selalu ada dalam penyebutnya, maka ketika mengambil turunannya kita mendapatkan Jacobian: <br><p><math> </math> $$ menampilkan $$ J_ {Softmax} = \ mulai {kas} x_i - x_i \ cdot x_j, i = j \\ - x_i \ cdot x_j, i \ neq j \ end {kas} $$ menampilkan $$ </p><br>  Sekarang tentang backpropagation.  Vektor turunan berasal dari lapisan sebelumnya (biasanya ini adalah fungsi kesalahan) <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   .  Dalam kasus <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   berasal dari fungsi kesalahan pada mnist, <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   - Vektor 10 dimensi.  Kemudian Jacobian memiliki dimensi 10x10.  Untuk mendapatkan <math> </math> $ inline $ \ boldsymbol {dz_ {new}} $ inline $   , yang melangkah lebih jauh ke lapisan sebelumnya (jangan lupa bahwa kita pergi dari ujung ke awal jaringan ketika kesalahan menyebar kembali), kita perlu memperbanyak <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   pada <math> </math> $ inline $ J_ {Softmax} $ inline $   (baris per kolom): <br><p><math> </math> $$ menampilkan $$ dz_ {baru} = \ boldsymbol {dz} \ kali J_ {Softmax} $$ menampilkan $$ </p><br>  Pada output, kita mendapatkan vektor turunan 10 dimensi <math> </math> $ inline $ \ boldsymbol {dz_ {new}} $ inline $   . <br><br><h4>  Relu </h4><br><p><math> </math> $$ menampilkan $$ ReLU (x) = \ mulai {kas} x, x&gt; 0 \\ 0, x &lt;0 \ akhir {kas} $$ menampilkan $$ </p><br>  ReLU mulai digunakan secara besar-besaran setelah 2011, ketika artikel "Deep Sparse Rectifier Neural Networks" diterbitkan.  Namun, fungsi seperti itu sebelumnya diketahui.  Konsep "kekuatan aktivasi" berlaku untuk ReLU (untuk lebih jelasnya, lihat buku "Deep Learning. Immersion in the World of Neural Networks").  Tetapi fitur utama yang membuat ReLU lebih menarik daripada fungsi aktivasi lainnya adalah perhitungan turunannya yang sederhana: <br><p><math> </math> $$ menampilkan $$ d (ReLU (x)) = \ mulai {kas} 1, x&gt; 0 \\ 0, x &lt;0 \ akhir {kas} $$ menampilkan $$ </p><br>  Dengan demikian, ReLU secara komputasi lebih efisien daripada fungsi aktivasi lainnya (sigmoid, hiperbolik tangen, dll.). <br><br><h3>  Lapisan sepenuhnya terhubung </h3><br>  Sekarang saatnya untuk membahas lapisan yang terhubung sepenuhnya.  Yang paling penting dari semua yang lain, karena pada lapisan inilah semua bobot berada, yang harus disesuaikan agar jaringan saraf dapat bekerja dengan baik.  Lapisan yang terhubung sepenuhnya hanyalah matriks berat: <br><p><math> </math> $$ display $$ W = | w_ {i, j} | $$ display $$ </p><br>  Representasi internal baru diperoleh ketika matriks bobot dikalikan dengan kolom input: <br><p><math> </math> $$ menampilkan $$ \ boldsymbol {x} _ {baru} = W \ cdot \ boldsymbol {x} $$ menampilkan $$ </p><br>  Dimana <math> </math> $ inline $ \ boldsymbol {x} $ inline $   memiliki ukuran <math> </math> $ inline $ input \ _shape $ inline $   , dan <math> </math> $ inline $ x_ {new} $ inline $   - <math> </math> $ inline $ output \ _shape $ inline $   .  Sebagai contoh <math> </math> $ inline $ \ boldsymbol {x} $ inline $   - Vektor 784 dimensi, dan <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   Merupakan vektor 100 dimensi, maka matriks W memiliki ukuran 100x784.  Ternyata pada layer ini adalah 100x784 = 78.400 bobot. <br><br>  Dengan propagasi belakang kesalahan, kita perlu mengambil turunan sehubungan dengan setiap bobot matriks ini.  Sederhanakan masalahnya dan ikuti turunannya saja <math> </math> $ inline $ w_ {1,1} $ inline $   .  Saat mengalikan matriks dan vektor, elemen pertama dari vektor baru <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   sama dengan <math> </math> $ sebaris $ x_ {baru ~ 1} = w_ {1,1} \ cdot x_1 + ... + w_ {1,784} \ cdot x_ {784} $ sebaris $   , dan turunannya <math> </math> $ sebaris $ x_ {baru ~ 1} $ sebaris $   oleh <math> </math> $ inline $ w_ {1,1} $ inline $   akan sederhana <math> </math> $ inline $ x_1 $ inline $   , Anda hanya perlu mengambil turunan dari jumlah di atas.  Demikian pula yang terjadi untuk semua bobot lainnya.  Tapi ini bukan algoritma propagasi kesalahan kembali, asalkan itu hanya matriks turunan.  Anda harus ingat bahwa dari lapisan berikutnya ke ini (kesalahan beranjak dari ujung ke awal) menghasilkan vektor gradien 100-dimensi <math> </math> $ inline $ d \ boldsymbol {z} $ inline $   .  Elemen pertama dari vektor ini <math> </math> $ inline $ dz_1 $ inline $   akan dikalikan dengan semua elemen dari matriks turunan yang "berpartisipasi" dalam penciptaan <math> </math> $ sebaris $ x_ {baru ~ 1} $ sebaris $   , mis. aktif <math> </math> $ sebaris $ x_1, x_2, ..., x_ {784} $ sebaris $   .  Begitu pula dengan elemen yang tersisa.  Jika Anda menerjemahkan ini ke dalam bahasa aljabar linier, maka itu ditulis seperti ini: <br><p><math> </math> $$ menampilkan $$ \ frac {\ partial L} {\ partial W} = (d \ boldsymbol {z}, ~ dW) = \ kiri (\ begin {matrix} dz_ {1} \ cdot \ boldsymbol {x} \ \ ... \\ dz_ {100} \ cdot \ boldsymbol {x} \ end {matrix} \ kanan) _ {100} $$ tampilkan $$ </p><br>  Outputnya adalah matriks 100x784. <br><img src="https://habrastorage.org/webt/1m/8_/hl/1m8_hljpr28gm3dikkgpsk4zss8.png"><br><br>  Sekarang Anda perlu memahami apa yang harus ditransfer ke lapisan sebelumnya.  Untuk ini dan untuk pemahaman yang lebih baik tentang apa yang terjadi sekarang, saya ingin menuliskan apa yang terjadi ketika mengambil turunan pada lapisan ini dalam bahasa yang sedikit berbeda, untuk menjauh dari spesifik "apa yang dikalikan dengan" ke fungsi (lagi). <br><br>  Ketika saya ingin menyesuaikan bobot, saya ingin mengambil turunan dari fungsi kesalahan untuk bobot ini: <math> </math> $ inline $ \ frac {\ partial L} {\ partial W} $ inline $   .  Itu ditunjukkan di atas cara mengambil turunan dari fungsi kesalahan dan fungsi aktivasi.  Oleh karena itu, kita dapat mempertimbangkan kasus seperti itu (dalam bahasa Indonesia) <math> </math> $ inline $ d \ boldsymbol {z} $ inline $   semua turunan dari fungsi kesalahan dan fungsi aktivasi sudah ada): <br><p><math> </math> $$ menampilkan $$ \ frac {\ partial L} {\ partial W} = d \ boldsymbol {z} \ cdot \ frac {\ partial \ boldsymbol {x} _ {baru} (W)} {\ partial W} $ $ display $$ </p><br>  Ini bisa dilakukan, karena bisa Anda pertimbangkan <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   sebagai fungsi dari W: <math> </math> $ inline $ \ boldsymbol {x} _ {new} = W \ cdot \ boldsymbol {x} $ inline $   . <br>  Anda dapat menggantinya dengan formula di atas: <br><br><p><math> </math> $$ menampilkan $$ \ frac {\ partial L} {\ partial W} = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot \ boldsymbol {x}} {\ partial W} = d \ boldsymbol { z} \ cdot E \ cdot \ boldsymbol {x} $$ menampilkan $$ </p><br>  Di mana E adalah matriks yang terdiri dari unit (BUKAN matriks unit). <br><br>  Sekarang ketika Anda perlu mengambil turunan dari lapisan sebelumnya (bahkan jika untuk kesederhanaan perhitungan itu juga akan menjadi lapisan yang terhubung penuh, tetapi dalam kasus umum itu tidak mengubah apa pun), maka Anda perlu mempertimbangkan <math> </math> $ inline $ \ boldsymbol {x} $ inline $   sebagai fungsi dari layer sebelumnya <math> </math> $ inline $ \ boldsymbol {x} (W_ {old}) $ inline $   : <br><p><math> </math> $$ tampilan $$ \ begin {collected} \ frac {\ partial L} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot \ frac {\ partial \ boldsymbol {x} _ {baru} (W )} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot \ boldsymbol {x} (W_ {old})} {\ partial W_ {old}} = \\ = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot W_ {old} \ cdot \ boldsymbol {x} _ {old}} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot W \ cdot E \ cdot \ boldsymbol {x} _ {old} = \\ = d \ boldsymbol {z} _ {baru} \ cdot E \ cdot \ boldsymbol {x} _ {old} \ end {berkumpul} $$ tampilkan $$ </p><br>  Tepat <math> </math> $ inline $ d \ boldsymbol {z} _ {new} = d \ boldsymbol {z} \ cdot W $ inline $   dan Anda perlu mengirim ke lapisan sebelumnya. <br><br><h2>  Kode </h2><br><blockquote>  Artikel ini terutama bertujuan menjelaskan matematika jaringan saraf.  Saya akan mencurahkan sedikit waktu untuk kode. </blockquote><br>  Ini adalah contoh implementasi dari fungsi kesalahan: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrossEntropy</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, y_true, y_hat)</span></span></span><span class="hljs-function">:</span></span> self.y_hat = y_hat self.y_true = y_true self.loss = -np.sum(self.y_true * np.log(y_hat)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.loss <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> dz = -self.y_true / self.y_hat <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dz</code> </pre> <br>  Kelas memiliki metode untuk lulus langsung dan mundur.  Pada saat pass langsung, instance kelas menyimpan data di dalam layer, dan pada saat pass kembali itu menggunakan mereka untuk menghitung gradien.  Lapisan yang tersisa dibangun dengan cara yang sama.  Berkat ini, menjadi mungkin untuk menulis saraf yang terhubung sepenuhnya dalam gaya ini: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MnistNet</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.d1_layer = Dense(<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) self.a1_layer = ReLu() self.drop1_layer = Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) self.d2_layer = Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) self.a2_layer = ReLu() self.drop2_layer = Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) self.d3_layer = Dense(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) self.a3_layer = Softmax() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, train=True)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dz, learning_rate=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, mini_batch=True, update=False, len_mini_batch=None)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre><br>  Kode lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Saya juga menyarankan untuk mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di HabrÃ©</a> . <br><br><h2>  Kesimpulan </h2><br>  Saya harap saya dapat menjelaskan dan menunjukkan bahwa matematika yang cukup sederhana ada di belakang jaringan saraf dan ini sama sekali tidak menakutkan.  Namun demikian, untuk pemahaman yang lebih dalam, ada baiknya mencoba menulis "sepeda" Anda sendiri.  Koreksi dan saran dengan senang hati dibaca di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460589/">https://habr.com/ru/post/id460589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460567/index.html">Bereaksi Asli: buat daftar yang bisa diseret & digesek</a></li>
<li><a href="../id460569/index.html">Menulis perangkat lunak dengan fungsi utilitas klien-server Windows, bagian 01</a></li>
<li><a href="../id460573/index.html">Google menyatakan bahwa "reCAPTCHA" tidak menyalahgunakan data pengguna. Apakah layak untuk percaya?</a></li>
<li><a href="../id460577/index.html">Hidup sang raja: dunia hirarki yang kejam dalam sekawanan anjing liar</a></li>
<li><a href="../id460587/index.html">Modul nirkabel untuk sensor kelembaban tanah kapasitif pada nRF52832</a></li>
<li><a href="../id460591/index.html">Memperoleh root pada router Tenda Nova MW6</a></li>
<li><a href="../id460593/index.html">"Universal" dalam tim pengembangan: manfaat atau bahaya?</a></li>
<li><a href="../id460597/index.html">Cara mendiagnosis masalah integrasi SDK. Pengalaman tim pengembangan SDK Iklan Seluler Yandex</a></li>
<li><a href="../id460599/index.html">Berita dari dunia OpenStreetMap No. 468 (07/02/2019 - 08/07/2019)</a></li>
<li><a href="../id460603/index.html">V2G. Mobil listrik akan membantu menyeimbangkan produksi dan konsumsi listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>