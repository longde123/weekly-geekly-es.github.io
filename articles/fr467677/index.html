<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ”§ ğŸ™ŒğŸ½ ğŸ§™ğŸ» Tests ou types ğŸšš ğŸ‘¨ğŸ»â€ğŸ³ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. L'autre jour, je cherchais comment faire quelque chose dans Idris, et je suis tombÃ© sur un bon article, dont une traduction gratuite semb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests ou types</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Salut, Habr.</em>  <em>L'autre jour, je cherchais comment faire quelque chose dans Idris, et je suis tombÃ© sur un bon article, dont une traduction gratuite semble tout Ã  fait appropriÃ©e.</em>  <em>LibertÃ©s et bÃ¢illon, le cas Ã©chÃ©ant, je dÃ©signerai Â«ici par de tels gribouillis au dÃ©but et Ã  la finÂ».</em> </p><br><p>  Quand utiliser les tests et quand - types?  Quelles informations et quelles garanties recevons-nous en Ã©change de nos efforts pour les rÃ©diger? </p><br><p>  Nous examinerons un exemple simple et lÃ©gÃ¨rement artificiel exprimÃ© en Python, C, Haskell et Idris.  Nous verrons Ã©galement ce qui peut Ãªtre dit sur la mise en Å“uvre sans aucune connaissance supplÃ©mentaire Ã  ce sujet, dans chaque cas. </p><br><p> Nous ne prendrons pas en compte les divers backdoors qui nous permettent de violer explicitement les garanties de langage (par exemple, extensions C, <code>unsafePerformIO</code> dans Haskell, conversions de type dangereuses), sinon il serait impossible de tirer des conclusions du tout, et ce message serait assez court.  `` En outre, le mÃªme Haskell possÃ¨de un sous-ensemble de Safe Haskell qui interdit explicitement et transitoirement l'utilisation de ces derniers et d'un certain nombre d'autres astuces qui pourraient violer l'intÃ©gritÃ© de la langue. '' </p><a name="habracut"></a><br><h2>  SpÃ©cification </h2><br><blockquote>  Qu'une liste et un sens soient donnÃ©s.  Il est nÃ©cessaire de renvoyer l'index de cette valeur dans la liste ou d'indiquer que cette valeur n'est pas dans la liste. </blockquote><p>  L'implÃ©mentation de cette spÃ©cification est triviale, il est donc naturel de demander, et voici gÃ©nÃ©ralement des tests ou des types.  Cependant, ces propriÃ©tÃ©s et mÃ©thodes de raisonnement, dont nous parlerons aujourd'hui, sont applicables Ã  un code beaucoup plus complexe.  Laissez l'implÃ©mentation prendre dix mille lignes de code spaghetti illisible, si cela aide Ã  voir leur utilitÃ©. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Nous notons tout de suite que nous ne sommes pas intÃ©ressÃ©s par les propriÃ©tÃ©s non contrÃ´lÃ©es et n'affectant pas la sÃ©mantique d'un programme comme la dÃ©nomination des variables et la documentation de texte, donc je n'ai intentionnellement pas Ã©crit de code qui aide Ã  la perception.  Nous ne sommes intÃ©ressÃ©s que par le fait que, sous rÃ©serve de rÃ©ussite aux tests et aux vÃ©rifications de type, <em>cela ne peut pas Ãªtre faux</em> . </p><br><p>  Dans le code ci-dessus, il n'y a pratiquement aucune information utile autre que le fait que nous ayons une fonction qui accepte deux arguments.  Cette fonction peut Ã©galement trouver l'index de la valeur dans la liste ou envoyer une lettre insultante Ã  votre grand-mÃ¨re. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Non seulement nous obtenons du code fragile sans tests ni types, mais notre seule faÃ§on de comprendre ce que fait une fonction est la documentation.  Et comme la documentation est vÃ©rifiÃ©e par des personnes et non par des machines, elle peut facilement se rÃ©vÃ©ler obsolÃ¨te Â«ou initialement incorrecteÂ». </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  âœ— Nous connaissons le comportement attendu <br>  Nous n'avons rien Ã  nous dire sur le comportement de cette fonction.  Tu dÃ©testes ta grand-mÃ¨re.  Tu es un monstre. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  âœ“ SÃ©curitÃ© de la mÃ©moire <br>  Python est un langage de rÃ©cupÃ©ration de place qui nous supprime cette prÃ©occupation.  OwCependant, pour autant que je sache, rien ne vous empÃªche de tirer des bibliothÃ¨ques dangereuses ou C FFI Ã  l'intÃ©rieur de cette fonction. function </li></ul></li></ul><br><h2>  Python avec tests </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Maintenant, nous savons que notre fonction fonctionne, et si l'Ã©lÃ©ment est manquant, le rÃ©sultat est <code>None</code> ? </p><br><p>  Et bien non.  Ce n'est qu'un exemple.  Malheureusement, la portÃ©e de notre fonction est infinie, et aucun nombre d'exemples ne peut prouver le bon fonctionnement de notre fonction.  Plus de tests - plus de confiance, mais aucun nombre de tests ne rÃ©soudra tous les doutes. </p><br><p>  La possibilitÃ© que cette fonction renvoie <code>None</code> pour <code>4</code> , mais pas pour <code>5</code> , semble assez fou, et dans ce cas particulier, c'est trÃ¨s probablement un non-sens.  Nous pouvons Ãªtre satisfaits de notre niveau de foi et nous attarder sur un certain nombre d'exemples.  Mais lÃ  encore, la publication sera courte, alors imaginons que la mise en Å“uvre n'est pas si Ã©vidente. </p><br><p>  Ã‰tant donnÃ© que les tests ne peuvent pas prouver quelque chose dans le cas gÃ©nÃ©ral, mais ne montrent que le comportement avec des exemples spÃ©cifiques, les tests <em>ne peuvent pas</em> montrer l'absence d'erreurs.  Par exemple, aucun test ne montre que notre fonction ne lÃ¨ve jamais d'exception ou n'entre jamais dans le cycle Ã©ternel, ou ne contient pas de liens invalides.  Il ne peut s'agir que d'une analyse statique. </p><br><p>  Cependant, mÃªme si les exemples ne sont pas trÃ¨s bons dans le rÃ´le de preuve, ils constituent au moins une bonne documentation.  Ã€ partir de ces deux exemples, nous pouvons dÃ©river la spÃ©cification complÃ¨te âŸ¦sous quelques hypothÃ¨ses a priori supplÃ©mentaires - ces deux exemples satisfont Ã©galement, par exemple, le Â«counterspecÂ» Â«trouver l'Ã©lÃ©ment dans le tableau et retourner le prÃ©cÃ©dent, le cas Ã©chÃ©antÂ», ce qui m'a pris dix secondes pour inventer . </p><br><p>  <strong>Analyse</strong> </p><br><p>  Bien que les tests puissent montrer comment utiliser notre fonction, et donnent Ã©galement un peu d'assurance que cette fonction fonctionne correctement avec au moins quelques exemples, ils ne peuvent rien <em>prouver</em> sur notre code dans le cas gÃ©nÃ©ral.  Malheureusement, cela signifie que les tests ne contribuent que partiellement Ã  Ã©viter les erreurs. </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  âœ“ <strong>Nous avons un exemple d'utilisation</strong> </li><li>  âœ“ <strong>Nous connaissons certaines classes de valeurs qui seront traitÃ©es correctement</strong> </li><li>  âœ— Nous connaissons tous les types de valeurs qui seront traitÃ©es correctement <br>  Nous n'avons aucune restriction sur les types d'arguments, donc malgrÃ© l'existence d'exemples de ce que la fonction peut gÃ©rer, nous ne savons pas quels types n'ont pas Ã©tÃ© testÃ©s. </li><li>  âœ— Nous connaissons le comportement attendu <br>  âŸ¦L'auteur de l'article original cochÃ© ici, je me permettrai de mettre une croix, compte tenu du commentaire ci-dessusâŸ§ </li></ul></li><li>  <strong>SpÃ©cification</strong> <br><ul><li>  âœ“ <strong>Fonctionne dans au moins un cas</strong> </li><li>  âœ— L'index retournÃ© est toujours un index valide </li><li>  âœ— L'index renvoyÃ© indique toujours une valeur appropriÃ©e </li><li>  Item L'Ã©lÃ©ment manquant renvoie toujours <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  âœ— Pas de fautes de frappe ou de noms incorrects <br>  L'analyse statique peut aider, mais comme Python est un langage dynamique avec la possibilitÃ© de remplacer diverses choses au moment de l'exÃ©cution, nous ne pouvons jamais prouver qu'il n'y a pas d'erreur. <br>  En particulier, il peut Ãªtre trÃ¨s difficile, voire impossible, de dÃ©terminer si le nom de la mÃ©thode est correct, car la validitÃ© de l'appel de mÃ©thode dÃ©pend du type d'exÃ©cution de l'objet sur lequel l'appel est effectuÃ©. </li><li>  âœ— Pas de <code>null</code> inattendu </li><li>  âœ— Le cas d'erreur est toujours traitÃ© <br>  D'aprÃ¨s mon expÃ©rience, c'est l'une des sources d'erreurs les plus courantes: dans notre exemple, la fonction retourne <code>None</code> en cas d'Ã©lÃ©ment manquant, mais le code utilisant cette fonction peut supposer, par exemple, qu'elle retournera toujours un nombre.  En outre, cela peut Ã©galement entraÃ®ner une exception non gÃ©rÃ©e. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  âœ“ SÃ©curitÃ© de la mÃ©moire </li><li>  âœ— La fonction ne peut pas Ãªtre appelÃ©e avec le mauvais type </li><li>  âœ— Aucun effet secondaire </li><li>  âœ— Aucune exception </li><li>  âœ— Aucune erreur </li><li>  âœ— Pas de cycles perpÃ©tuels </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Si vous n'Ãªtes pas familier avec la syntaxe: c'est la dÃ©finition d'une fonction <code>x</code> avec les paramÃ¨tres <code>y</code> et <code>z</code> .  Dans Haskell, vous pouvez omettre les types, car ils seront dÃ©duits de l'implÃ©mentation Â«Ã  moins, bien sÃ»r, que vous n'utilisiez des fonctionnalitÃ©s avancÃ©es diffÃ©rentes des extensions modernes du systÃ¨me de typesÂ». </p><br><p>  Il peut sembler que ce n'est pas trÃ¨s diffÃ©rent de la version Python, mais seulement parce que nous avons Ã©crit notre fonction en Haskell et qu'elle est en mosaÃ¯que, nous pouvons dÃ©jÃ  parler de certaines propriÃ©tÃ©s intÃ©ressantes. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Ã‰videmment, nous ne pouvons pas tirer autant de conclusions ici, mais voici quelques points Ã  noter: </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  âœ— Nous connaissons le comportement attendu </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  âœ“ <strong>Pas de fautes de frappe ou de noms incorrects</strong> <br>  Ã‰tant donnÃ© que Haskell est un langage compilÃ©, tous les noms doivent Ãªtre rÃ©solus au moment de la compilation.  Le programme ne compilera tout simplement pas s'il y a cette erreur. </li><li>  âœ“ <strong>Pas de <code>null</code> inattendu</strong> <br>  Haskell n'a tout simplement pas <code>null</code> .  Le problÃ¨me est rÃ©solu! </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  âœ“ SÃ©curitÃ© de la mÃ©moire </li><li>  âœ“ <strong>La fonction ne peut pas Ãªtre appelÃ©e avec le mauvais type</strong> </li><li>  âœ“ <strong>Aucun effet secondaire <em>inattendu</em></strong> <br>  âŸ¦L'auteur de l'article d'origine n'a pas prÃ©cisÃ© cet Ã©lÃ©ment, mais je me permettrai de noter que s'il y a des effets secondaires, le type dÃ©duit de cette fonction indiquera leur prÃ©sence, afin que le code appelant connaisse leurs capacitÃ©s.âŸ§ </li></ul></li></ul><br><h2>  Type Haskell spÃ©cifiant </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Plus tÃ´t, nous avons parlÃ© d'une attitude plutÃ´t complice Ã  l'Ã©gard de la sÃ©curitÃ© des grands-mÃ¨res: il Ã©tait clair d'aprÃ¨s les tests que la fonction n'allait nuire Ã  personne, mais <em>la</em> grand <em>-</em> mÃ¨re <em>Ã©tait</em> -elle <em>vraiment en</em> sÃ©curitÃ©?  Cette fonction n'envoie-t-elle avec prÃ©cision aucune lettre de serment? </p><br><p>  Haskell est connu pour Ãªtre un pur langage fonctionnel.  Cela ne signifie pas que le code ne peut pas avoir d'effets secondaires, mais tous les effets secondaires doivent Ãªtre prÃ©sents dans le type.  Nous connaissons le type de cette fonction, nous voyons qu'elle est propre, donc nous sommes sÃ»rs que cette fonction ne modifie aucun Ã©tat externe. </p><br><p>  C'est une propriÃ©tÃ© trÃ¨s intÃ©ressante pour d'autres raisons: comme nous savons qu'il n'y a pas d'effets secondaires, nous pouvons comprendre ce que fait cette fonction, en se basant uniquement sur sa signature!  Recherchez simplement cette signature <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoogle</a> et regardez le premier rÃ©sultat.  Bien sÃ»r, ce n'est pas la seule fonction possible qui aurait un tel type, mais le type nous donne suffisamment de confiance pour les besoins de la documentation. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  âœ“ <strong>Nous connaissons le comportement attendu</strong> </li><li>  âœ— Nous avons un exemple d'utilisation </li><li>  âœ“ Nous connaissons certaines classes de valeurs qui seront traitÃ©es correctement </li><li>  âœ“ <strong>Nous connaissons tous les types de valeurs qui seront traitÃ©es correctement</strong> </li></ul></li><li>  <strong>SpÃ©cification</strong> <br><ul><li>  âœ— Fonctionne dans au moins un cas. <br>  En l'absence de tests ou de preuves, nous ne savons pas si notre fonction fonctionne du tout comme nous l'attendons! </li><li>  âœ— L'index renvoyÃ© est toujours un index valide. </li><li>  âœ— L'index renvoyÃ© indique toujours une valeur appropriÃ©e. </li><li>  âœ— Un Ã©lÃ©ment manquant renvoie toujours <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  âœ“ Pas de fautes de frappe ou de noms incorrects </li><li>  âœ“ Pas de <code>null</code> inattendu </li><li>  âœ“ Le <strong>cas d'erreur est toujours traitÃ©</strong> <br>  Si notre fonction retourne <code>Nothing</code> , le systÃ¨me de type s'assure que ce cas est correctement gÃ©rÃ© par le code appelant.  Bien sÃ»r, ce cas peut Ãªtre ignorÃ©, mais cela doit Ãªtre fait explicitement. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  âœ“ SÃ©curitÃ© de la mÃ©moire </li><li>  âœ“ La fonction ne peut pas Ãªtre appelÃ©e avec le mauvais type </li><li>  âœ“ <strong>Pas d'effets secondaires</strong> </li><li>  âœ— Aucune exception <br>  Je partage des exceptions et des erreurs, croyant qu'aprÃ¨s des exceptions, il est possible de rÃ©cupÃ©rer, et aprÃ¨s des erreurs (par exemple, des fonctions partiellement dÃ©finies) - non. <br>  Pour la plupart, les exceptions sont dÃ©crites dans les types (par exemple, dans la monade IO).  Dans le bon sens, nous devons savoir qu'une fonction ne lÃ¨vera pas d'exception, uniquement sur la base de son type.  Cependant, Haskell rompt cette attente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">permettant</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lever des exceptions Ã  partir de code pur</a> . <br>  `` De plus, il convient de noter que dans Haskell, des erreurs comme l'appel incorrect de fonctions partiellement dÃ©finies sont Ã©galement prÃ©sentÃ©es comme des exceptions qui peuvent Ãªtre interceptÃ©es et traitÃ©es, de sorte que la diffÃ©rence entre les deux catÃ©gories est lÃ©gÃ¨rement moins Ã©vidente. </li><li>  âœ— Aucune erreur <br>  Nous pouvons toujours utiliser des fonctions partiellement dÃ©finies, par exemple, la division par zÃ©ro. </li><li>  âœ— Pas de cycles perpÃ©tuels </li></ul></li></ul><br><h2>  Haskell avec tests </h2><br><p>  Rappelez-vous, j'ai dit plus tÃ´t que les tests ne peuvent pas prouver l'absence d'erreurs?  J'ai menti.  Lorsque les Ã©toiles convergent correctement, et si les tests sont combinÃ©s avec des types, alors cela devient possible!  La premiÃ¨re Ã©toile est la finitude du domaine de notre fonction.  DeuxiÃ¨mement, le domaine de la dÃ©finition doit Ãªtre non seulement limitÃ©, mais Ã©galement pas trÃ¨s Ã©tendu, sinon un tel test sera difficile Ã  mettre en pratique. </p><br><p>  Par exemple: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  L'entrÃ©e peut Ãªtre <code>True</code> ou <code>False</code> .  Il suffit de tester ces deux options, et le voici, le Saint Graal!  Aucune exception, cycles perpÃ©tuels, rÃ©sultats incorrects, aucune erreur.  OwCependant, pour une fonction un peu plus complexe, il peut ne pas Ãªtre clair combien de temps est consacrÃ© aux tests: s'ils prennent beaucoup de temps, alors nous sommes-nous retrouvÃ©s dans un cycle Ã©ternel, ou est-ce juste lourd?  Le problÃ¨me de l'arrÃªter.âŸ§ </p><br><p>  En fait, cela n'est pas non plus entiÃ¨rement vrai dans le cas de Haskell: dans chaque type de Haskell, il y a aussi une valeur âŠ¥ (qui peut Ãªtre obtenue comme <code>undefined</code> , <code>error</code> ou, dans un certain sens, comme rÃ©cursion infinie), mais les Haskellistes ferment traditionnellement les yeux et croient que cela n'existe pas. </p><br><p>  Lecture parascolaire: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il n'y a que quatre milliards de flotteurs - alors testez-les tous!</a> </p><br><p>  Dans tous les cas, dans notre exemple d'origine, la portÃ©e est infinie, donc les tests ne peuvent montrer que notre code fonctionne pour un ensemble fini d'exemples. </p><br><p>  <strong>Analyse</strong> <br>  Dans ce cas, les tests complÃ¨tent les types et bouchent certains trous dans le systÃ¨me de type Haskell.  Nous avons beaucoup plus confiance en notre code que d'utiliser uniquement des tests ou des types. </p><br><h2>  C </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Nous considÃ©rons C par intÃ©rÃªt pour les systÃ¨mes de type ancien.  En C, en particulier, les types sont trÃ¨s probablement nÃ©cessaires non pas au programmeur, mais au compilateur pour l'aider Ã  gÃ©nÃ©rer du code plus rapidement. </p><br><p>  Dans notre exemple, nous ne savons pas ce que la fonction retournera si l'Ã©lÃ©ment n'est pas trouvÃ©.  Nous devrons nous fier Ã  la tradition ou Ã  la documentation (par exemple, dans ce cas, il peut Ãªtre <code>-1</code> ). </p><br><p>  Nous pourrions Ã©galement utiliser des arguments out: de cette faÃ§on, nous pouvons retourner une erreur et stocker la valeur de retour dans cet argument out.  C'est une option un peu plus expressive, mais nous devons encore nous fier Ã  la documentation pour comprendre quels paramÃ¨tres sont lus et lesquels sont Ã©crits.  Dans les deux cas, il est difficile de comprendre le comportement en examinant les types. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>Analyse</strong> <br>  Le systÃ¨me de typage lui-mÃªme ne nous donne pas autant de garanties.  Bien sÃ»r, nous obtenons des informations de ces types, mais il suffit de les comparer avec l'affaire Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Cette fonction est du mÃªme type que dans le cas de Haskell.  Cependant, avec un systÃ¨me de type plus expressif, nous pouvons faire plus.  Le choix des types peut parler de l'implÃ©mentation. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Ce type peut Ãªtre lu comme Â«donnez-moi une liste de taille <code>n</code> et une certaine valeur, et je vous retournerai soit un nombre infÃ©rieur Ã  <code>n</code> ou <code>Nothing</code> Â».  Cela garantit que la fonction renvoie un index qui ne dÃ©passe Ã©videmment pas les limites. </p><br><p>  De plus, cette fonction est totale, c'est-Ã -dire que la minuterie a vÃ©rifiÃ© qu'elle se termine toujours.  Cela Ã©limine les cycles perpÃ©tuels et les erreurs. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>SpÃ©cification</strong> <br><ul><li>  âœ— Fonctionne dans au moins un cas. </li><li>  âœ“ L' <strong>index retournÃ© est toujours l'index correct</strong> </li><li>  âœ— L'index renvoyÃ© indique toujours une valeur appropriÃ©e </li><li>  Item L'Ã©lÃ©ment manquant renvoie toujours <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  âœ“ SÃ©curitÃ© de la mÃ©moire </li><li>  âœ“ La fonction ne peut pas Ãªtre appelÃ©e avec le mauvais type </li><li>  âœ“ Pas d'effets secondaires </li><li>  âœ— Aucune exception </li><li>  âœ“ <strong>Aucune erreur</strong> </li><li>  âœ“ <strong>Pas de cycles perpÃ©tuels</strong> </li></ul></li></ul><br><h2>  Idris avec tests </h2><br><p>  Puisque le langage de type d'Idris est aussi expressif que le langage de ses termes âŸ¦(ou plutÃ´t, sa partie prouvÃ©e totale)âŸ§, la distinction entre test et type est floue: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Cette fonction a un type plutÃ´t Ã©trange <code>x [1, 2, 3] 2 = Just 1</code> .  Ce type signifie que pour une vÃ©rification de type rÃ©ussie, le typer doit prouver que <code>x [1, 2, 3] 2</code> structurellement Ã©gal Ã  <code>Just 1</code> .  âŸ¦Dans ce cas, la preuve est triviale, car il suffit que le basculeur normalise les termes des deux cÃ´tÃ©s du signe Ã©gal, ce qui se fera en temps fini en raison de la totalitÃ© de toutes les fonctions utilisÃ©es, et qui conduira Ã  un rÃ©sultat unique grÃ¢ce Ã  Church-Rosser.  AprÃ¨s cela, on peut utiliser la rÃ©flexivitÃ© de l'Ã©galitÃ©, qui est ce que <code>Refl</code> .âŸ§ </p><br><p>  En fait, nous avons Ã©crit un test de niveau type. </p><br><h2>  Idris avec des preuves </h2><br><p>  Pour l'exhaustivitÃ© de l'analyse, nous pouvons utiliser toute la puissance des types dÃ©pendants et <em>prouver</em> notre implÃ©mentation (puisque les types dÃ©pendants dans Idris sont Ã©quivalents Ã  un systÃ¨me logique qui inclut une logique constructive de premier ordre). </p><br><p>  En particulier, nous pouvons prouver des propriÃ©tÃ©s qui nous Ã©taient auparavant inaccessibles: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  Le type <code>findIndexOk</code> peut Ãªtre lu comme Â«pour tout type <code>a</code> tel qu'il ait une comparaison algorithmiquement dÃ©cidable ( <code>DecEq</code> ) pour lui, pour tout vecteur <code>y</code> Ã©lÃ©ments de type <code>a</code> n'importe quelle longueur <code>n</code> et de toute valeur <code>z</code> type <code>a</code> : si <code>xyz</code> renvoie l'index <code>i</code> , alors cet index se trouve <code>z</code> , mais si <code>xyz</code> <code>Nothing</code> renvoie <code>Nothing</code> , alors il n'y a pas un tel Ã©lÃ©ment dans le vecteur. " </p><br><p>  `` Il est intÃ©ressant de noter que l'auteur de l'article original donne un type lÃ©gÃ¨rement plus faible que celui donnÃ© ci-dessus. '' </p><br><p>  Maintenant, nous avons tout capturÃ©!  Quels sont les inconvÃ©nients?  Eh bien, Ã©crire toutes ces preuves peut Ãªtre assez difficile. </p><br><h2>  Comparaison </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  tests </th><th>  Haskell </th><th>  Haskell <br>  types </th><th>  Haskell <br>  types <br>  tests </th><th>  Idris </th><th>  Idris <br>  tests </th><th>  Idris <br>  preuves </th></tr><tr><th>  La documentation </th></tr><tr><td>  Nous connaissons le comportement attendu </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Il y a un exemple d'utilisation </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Nous connaissons certains types de valeurs appropriÃ©es. </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Nous connaissons tous les types de valeurs appropriÃ©es. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><th>  SpÃ©cification </th></tr><tr><td>  Fonctionne dans au moins un cas </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  L'index retournÃ© est toujours valide. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  L'index retournÃ© est toujours valide. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td></tr><tr><td>  L'Ã©lÃ©ment manquant donne `None` /` Nothing` </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td></tr><tr><th>  Erreurs courantes </th></tr><tr><td>  Pas de fautes de frappe ou de noms incorrects </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Pas de Â«nulÂ» soudain </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Le cas d'erreur est toujours traitÃ©. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><th>  Garanties </th></tr><tr><td>  SÃ©curitÃ© de la mÃ©moire </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Ne peut pas Ãªtre appelÃ© avec le mauvais type. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Pas d'effets secondaires </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Aucune exception </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Aucune erreur </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Pas de cycles perpÃ©tuels </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr></tbody></table></div><br><h2>  Opinion </h2><br><p>  Ã€ mon avis, l'utilisation d'un systÃ¨me de type moderne est en soi la plus efficace en termes de relation entre les informations reÃ§ues et les garanties des efforts dÃ©ployÃ©s.  Si vous voulez Ã©crire du code assez fiable, les types peuvent Ãªtre assaisonnÃ©s avec des tests.  IdÃ©alement - dans le style de QuickCheck. </p><br><p>  Avec les types dÃ©pendants, la ligne entre les tests et les types devient moins Ã©vidente.  Si vous Ã©crivez un logiciel pour Boeing ou pour stimulateurs cardiaques, il peut Ãªtre utile de rÃ©diger des preuves. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467677/">https://habr.com/ru/post/fr467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467667/index.html">Planification de projet d'organisation (partie 4)</a></li>
<li><a href="../fr467669/index.html">Regardez-moi en entier: tirez le meilleur parti de la vidÃ©o en direct sur les plateformes mobiles</a></li>
<li><a href="../fr467671/index.html">NLX Retro Computer</a></li>
<li><a href="../fr467673/index.html">FonctionnalitÃ©s Go intÃ©grÃ©es</a></li>
<li><a href="../fr467675/index.html">ModÃ©lisation de l'Ã©tat de l'application Ã  l'aide d'objets Store dans SwiftUI</a></li>
<li><a href="../fr467679/index.html">PyCrunch - ExÃ©cution intelligente des tests et couverture visuelle du code dans l'IDE</a></li>
<li><a href="../fr467681/index.html">VulnÃ©rabilitÃ© de dÃ©tournement de routage SOAP</a></li>
<li><a href="../fr467683/index.html">Essayer de composer le non-composable: schÃ©mas d'ancrage</a></li>
<li><a href="../fr467689/index.html">Un petit aperÃ§u de SIMD en .NET / C #</a></li>
<li><a href="../fr467691/index.html">Intel Nervana NNP-T et NNP-I - puces spÃ©cialisÃ©es pour l'IA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>