<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔧 🙌🏽 🧙🏻 Tests ou types 🚚 👨🏻‍🍳 🐞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. L'autre jour, je cherchais comment faire quelque chose dans Idris, et je suis tombé sur un bon article, dont une traduction gratuite semb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests ou types</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Salut, Habr.</em>  <em>L'autre jour, je cherchais comment faire quelque chose dans Idris, et je suis tombé sur un bon article, dont une traduction gratuite semble tout à fait appropriée.</em>  <em>Libertés et bâillon, le cas échéant, je désignerai «ici par de tels gribouillis au début et à la fin».</em> </p><br><p>  Quand utiliser les tests et quand - types?  Quelles informations et quelles garanties recevons-nous en échange de nos efforts pour les rédiger? </p><br><p>  Nous examinerons un exemple simple et légèrement artificiel exprimé en Python, C, Haskell et Idris.  Nous verrons également ce qui peut être dit sur la mise en œuvre sans aucune connaissance supplémentaire à ce sujet, dans chaque cas. </p><br><p> Nous ne prendrons pas en compte les divers backdoors qui nous permettent de violer explicitement les garanties de langage (par exemple, extensions C, <code>unsafePerformIO</code> dans Haskell, conversions de type dangereuses), sinon il serait impossible de tirer des conclusions du tout, et ce message serait assez court.  `` En outre, le même Haskell possède un sous-ensemble de Safe Haskell qui interdit explicitement et transitoirement l'utilisation de ces derniers et d'un certain nombre d'autres astuces qui pourraient violer l'intégrité de la langue. '' </p><a name="habracut"></a><br><h2>  Spécification </h2><br><blockquote>  Qu'une liste et un sens soient donnés.  Il est nécessaire de renvoyer l'index de cette valeur dans la liste ou d'indiquer que cette valeur n'est pas dans la liste. </blockquote><p>  L'implémentation de cette spécification est triviale, il est donc naturel de demander, et voici généralement des tests ou des types.  Cependant, ces propriétés et méthodes de raisonnement, dont nous parlerons aujourd'hui, sont applicables à un code beaucoup plus complexe.  Laissez l'implémentation prendre dix mille lignes de code spaghetti illisible, si cela aide à voir leur utilité. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Nous notons tout de suite que nous ne sommes pas intéressés par les propriétés non contrôlées et n'affectant pas la sémantique d'un programme comme la dénomination des variables et la documentation de texte, donc je n'ai intentionnellement pas écrit de code qui aide à la perception.  Nous ne sommes intéressés que par le fait que, sous réserve de réussite aux tests et aux vérifications de type, <em>cela ne peut pas être faux</em> . </p><br><p>  Dans le code ci-dessus, il n'y a pratiquement aucune information utile autre que le fait que nous ayons une fonction qui accepte deux arguments.  Cette fonction peut également trouver l'index de la valeur dans la liste ou envoyer une lettre insultante à votre grand-mère. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Non seulement nous obtenons du code fragile sans tests ni types, mais notre seule façon de comprendre ce que fait une fonction est la documentation.  Et comme la documentation est vérifiée par des personnes et non par des machines, elle peut facilement se révéler obsolète «ou initialement incorrecte». </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  ✗ Nous connaissons le comportement attendu <br>  Nous n'avons rien à nous dire sur le comportement de cette fonction.  Tu détestes ta grand-mère.  Tu es un monstre. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  ✓ Sécurité de la mémoire <br>  Python est un langage de récupération de place qui nous supprime cette préoccupation.  OwCependant, pour autant que je sache, rien ne vous empêche de tirer des bibliothèques dangereuses ou C FFI à l'intérieur de cette fonction. function </li></ul></li></ul><br><h2>  Python avec tests </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Maintenant, nous savons que notre fonction fonctionne, et si l'élément est manquant, le résultat est <code>None</code> ? </p><br><p>  Et bien non.  Ce n'est qu'un exemple.  Malheureusement, la portée de notre fonction est infinie, et aucun nombre d'exemples ne peut prouver le bon fonctionnement de notre fonction.  Plus de tests - plus de confiance, mais aucun nombre de tests ne résoudra tous les doutes. </p><br><p>  La possibilité que cette fonction renvoie <code>None</code> pour <code>4</code> , mais pas pour <code>5</code> , semble assez fou, et dans ce cas particulier, c'est très probablement un non-sens.  Nous pouvons être satisfaits de notre niveau de foi et nous attarder sur un certain nombre d'exemples.  Mais là encore, la publication sera courte, alors imaginons que la mise en œuvre n'est pas si évidente. </p><br><p>  Étant donné que les tests ne peuvent pas prouver quelque chose dans le cas général, mais ne montrent que le comportement avec des exemples spécifiques, les tests <em>ne peuvent pas</em> montrer l'absence d'erreurs.  Par exemple, aucun test ne montre que notre fonction ne lève jamais d'exception ou n'entre jamais dans le cycle éternel, ou ne contient pas de liens invalides.  Il ne peut s'agir que d'une analyse statique. </p><br><p>  Cependant, même si les exemples ne sont pas très bons dans le rôle de preuve, ils constituent au moins une bonne documentation.  À partir de ces deux exemples, nous pouvons dériver la spécification complète ⟦sous quelques hypothèses a priori supplémentaires - ces deux exemples satisfont également, par exemple, le «counterspec» «trouver l'élément dans le tableau et retourner le précédent, le cas échéant», ce qui m'a pris dix secondes pour inventer . </p><br><p>  <strong>Analyse</strong> </p><br><p>  Bien que les tests puissent montrer comment utiliser notre fonction, et donnent également un peu d'assurance que cette fonction fonctionne correctement avec au moins quelques exemples, ils ne peuvent rien <em>prouver</em> sur notre code dans le cas général.  Malheureusement, cela signifie que les tests ne contribuent que partiellement à éviter les erreurs. </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  ✓ <strong>Nous avons un exemple d'utilisation</strong> </li><li>  ✓ <strong>Nous connaissons certaines classes de valeurs qui seront traitées correctement</strong> </li><li>  ✗ Nous connaissons tous les types de valeurs qui seront traitées correctement <br>  Nous n'avons aucune restriction sur les types d'arguments, donc malgré l'existence d'exemples de ce que la fonction peut gérer, nous ne savons pas quels types n'ont pas été testés. </li><li>  ✗ Nous connaissons le comportement attendu <br>  ⟦L'auteur de l'article original coché ici, je me permettrai de mettre une croix, compte tenu du commentaire ci-dessus⟧ </li></ul></li><li>  <strong>Spécification</strong> <br><ul><li>  ✓ <strong>Fonctionne dans au moins un cas</strong> </li><li>  ✗ L'index retourné est toujours un index valide </li><li>  ✗ L'index renvoyé indique toujours une valeur appropriée </li><li>  Item L'élément manquant renvoie toujours <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  ✗ Pas de fautes de frappe ou de noms incorrects <br>  L'analyse statique peut aider, mais comme Python est un langage dynamique avec la possibilité de remplacer diverses choses au moment de l'exécution, nous ne pouvons jamais prouver qu'il n'y a pas d'erreur. <br>  En particulier, il peut être très difficile, voire impossible, de déterminer si le nom de la méthode est correct, car la validité de l'appel de méthode dépend du type d'exécution de l'objet sur lequel l'appel est effectué. </li><li>  ✗ Pas de <code>null</code> inattendu </li><li>  ✗ Le cas d'erreur est toujours traité <br>  D'après mon expérience, c'est l'une des sources d'erreurs les plus courantes: dans notre exemple, la fonction retourne <code>None</code> en cas d'élément manquant, mais le code utilisant cette fonction peut supposer, par exemple, qu'elle retournera toujours un nombre.  En outre, cela peut également entraîner une exception non gérée. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  ✓ Sécurité de la mémoire </li><li>  ✗ La fonction ne peut pas être appelée avec le mauvais type </li><li>  ✗ Aucun effet secondaire </li><li>  ✗ Aucune exception </li><li>  ✗ Aucune erreur </li><li>  ✗ Pas de cycles perpétuels </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Si vous n'êtes pas familier avec la syntaxe: c'est la définition d'une fonction <code>x</code> avec les paramètres <code>y</code> et <code>z</code> .  Dans Haskell, vous pouvez omettre les types, car ils seront déduits de l'implémentation «à moins, bien sûr, que vous n'utilisiez des fonctionnalités avancées différentes des extensions modernes du système de types». </p><br><p>  Il peut sembler que ce n'est pas très différent de la version Python, mais seulement parce que nous avons écrit notre fonction en Haskell et qu'elle est en mosaïque, nous pouvons déjà parler de certaines propriétés intéressantes. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Évidemment, nous ne pouvons pas tirer autant de conclusions ici, mais voici quelques points à noter: </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  ✗ Nous connaissons le comportement attendu </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  ✓ <strong>Pas de fautes de frappe ou de noms incorrects</strong> <br>  Étant donné que Haskell est un langage compilé, tous les noms doivent être résolus au moment de la compilation.  Le programme ne compilera tout simplement pas s'il y a cette erreur. </li><li>  ✓ <strong>Pas de <code>null</code> inattendu</strong> <br>  Haskell n'a tout simplement pas <code>null</code> .  Le problème est résolu! </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  ✓ Sécurité de la mémoire </li><li>  ✓ <strong>La fonction ne peut pas être appelée avec le mauvais type</strong> </li><li>  ✓ <strong>Aucun effet secondaire <em>inattendu</em></strong> <br>  ⟦L'auteur de l'article d'origine n'a pas précisé cet élément, mais je me permettrai de noter que s'il y a des effets secondaires, le type déduit de cette fonction indiquera leur présence, afin que le code appelant connaisse leurs capacités.⟧ </li></ul></li></ul><br><h2>  Type Haskell spécifiant </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Plus tôt, nous avons parlé d'une attitude plutôt complice à l'égard de la sécurité des grands-mères: il était clair d'après les tests que la fonction n'allait nuire à personne, mais <em>la</em> grand <em>-</em> mère <em>était</em> -elle <em>vraiment en</em> sécurité?  Cette fonction n'envoie-t-elle avec précision aucune lettre de serment? </p><br><p>  Haskell est connu pour être un pur langage fonctionnel.  Cela ne signifie pas que le code ne peut pas avoir d'effets secondaires, mais tous les effets secondaires doivent être présents dans le type.  Nous connaissons le type de cette fonction, nous voyons qu'elle est propre, donc nous sommes sûrs que cette fonction ne modifie aucun état externe. </p><br><p>  C'est une propriété très intéressante pour d'autres raisons: comme nous savons qu'il n'y a pas d'effets secondaires, nous pouvons comprendre ce que fait cette fonction, en se basant uniquement sur sa signature!  Recherchez simplement cette signature <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoogle</a> et regardez le premier résultat.  Bien sûr, ce n'est pas la seule fonction possible qui aurait un tel type, mais le type nous donne suffisamment de confiance pour les besoins de la documentation. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>La documentation</strong> <br><ul><li>  ✓ <strong>Nous connaissons le comportement attendu</strong> </li><li>  ✗ Nous avons un exemple d'utilisation </li><li>  ✓ Nous connaissons certaines classes de valeurs qui seront traitées correctement </li><li>  ✓ <strong>Nous connaissons tous les types de valeurs qui seront traitées correctement</strong> </li></ul></li><li>  <strong>Spécification</strong> <br><ul><li>  ✗ Fonctionne dans au moins un cas. <br>  En l'absence de tests ou de preuves, nous ne savons pas si notre fonction fonctionne du tout comme nous l'attendons! </li><li>  ✗ L'index renvoyé est toujours un index valide. </li><li>  ✗ L'index renvoyé indique toujours une valeur appropriée. </li><li>  ✗ Un élément manquant renvoie toujours <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Erreurs courantes</strong> <br><ul><li>  ✓ Pas de fautes de frappe ou de noms incorrects </li><li>  ✓ Pas de <code>null</code> inattendu </li><li>  ✓ Le <strong>cas d'erreur est toujours traité</strong> <br>  Si notre fonction retourne <code>Nothing</code> , le système de type s'assure que ce cas est correctement géré par le code appelant.  Bien sûr, ce cas peut être ignoré, mais cela doit être fait explicitement. </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  ✓ Sécurité de la mémoire </li><li>  ✓ La fonction ne peut pas être appelée avec le mauvais type </li><li>  ✓ <strong>Pas d'effets secondaires</strong> </li><li>  ✗ Aucune exception <br>  Je partage des exceptions et des erreurs, croyant qu'après des exceptions, il est possible de récupérer, et après des erreurs (par exemple, des fonctions partiellement définies) - non. <br>  Pour la plupart, les exceptions sont décrites dans les types (par exemple, dans la monade IO).  Dans le bon sens, nous devons savoir qu'une fonction ne lèvera pas d'exception, uniquement sur la base de son type.  Cependant, Haskell rompt cette attente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">permettant</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lever des exceptions à partir de code pur</a> . <br>  `` De plus, il convient de noter que dans Haskell, des erreurs comme l'appel incorrect de fonctions partiellement définies sont également présentées comme des exceptions qui peuvent être interceptées et traitées, de sorte que la différence entre les deux catégories est légèrement moins évidente. </li><li>  ✗ Aucune erreur <br>  Nous pouvons toujours utiliser des fonctions partiellement définies, par exemple, la division par zéro. </li><li>  ✗ Pas de cycles perpétuels </li></ul></li></ul><br><h2>  Haskell avec tests </h2><br><p>  Rappelez-vous, j'ai dit plus tôt que les tests ne peuvent pas prouver l'absence d'erreurs?  J'ai menti.  Lorsque les étoiles convergent correctement, et si les tests sont combinés avec des types, alors cela devient possible!  La première étoile est la finitude du domaine de notre fonction.  Deuxièmement, le domaine de la définition doit être non seulement limité, mais également pas très étendu, sinon un tel test sera difficile à mettre en pratique. </p><br><p>  Par exemple: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  L'entrée peut être <code>True</code> ou <code>False</code> .  Il suffit de tester ces deux options, et le voici, le Saint Graal!  Aucune exception, cycles perpétuels, résultats incorrects, aucune erreur.  OwCependant, pour une fonction un peu plus complexe, il peut ne pas être clair combien de temps est consacré aux tests: s'ils prennent beaucoup de temps, alors nous sommes-nous retrouvés dans un cycle éternel, ou est-ce juste lourd?  Le problème de l'arrêter.⟧ </p><br><p>  En fait, cela n'est pas non plus entièrement vrai dans le cas de Haskell: dans chaque type de Haskell, il y a aussi une valeur ⊥ (qui peut être obtenue comme <code>undefined</code> , <code>error</code> ou, dans un certain sens, comme récursion infinie), mais les Haskellistes ferment traditionnellement les yeux et croient que cela n'existe pas. </p><br><p>  Lecture parascolaire: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il n'y a que quatre milliards de flotteurs - alors testez-les tous!</a> </p><br><p>  Dans tous les cas, dans notre exemple d'origine, la portée est infinie, donc les tests ne peuvent montrer que notre code fonctionne pour un ensemble fini d'exemples. </p><br><p>  <strong>Analyse</strong> <br>  Dans ce cas, les tests complètent les types et bouchent certains trous dans le système de type Haskell.  Nous avons beaucoup plus confiance en notre code que d'utiliser uniquement des tests ou des types. </p><br><h2>  C </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Nous considérons C par intérêt pour les systèmes de type ancien.  En C, en particulier, les types sont très probablement nécessaires non pas au programmeur, mais au compilateur pour l'aider à générer du code plus rapidement. </p><br><p>  Dans notre exemple, nous ne savons pas ce que la fonction retournera si l'élément n'est pas trouvé.  Nous devrons nous fier à la tradition ou à la documentation (par exemple, dans ce cas, il peut être <code>-1</code> ). </p><br><p>  Nous pourrions également utiliser des arguments out: de cette façon, nous pouvons retourner une erreur et stocker la valeur de retour dans cet argument out.  C'est une option un peu plus expressive, mais nous devons encore nous fier à la documentation pour comprendre quels paramètres sont lus et lesquels sont écrits.  Dans les deux cas, il est difficile de comprendre le comportement en examinant les types. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>Analyse</strong> <br>  Le système de typage lui-même ne nous donne pas autant de garanties.  Bien sûr, nous obtenons des informations de ces types, mais il suffit de les comparer avec l'affaire Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Cette fonction est du même type que dans le cas de Haskell.  Cependant, avec un système de type plus expressif, nous pouvons faire plus.  Le choix des types peut parler de l'implémentation. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Ce type peut être lu comme «donnez-moi une liste de taille <code>n</code> et une certaine valeur, et je vous retournerai soit un nombre inférieur à <code>n</code> ou <code>Nothing</code> ».  Cela garantit que la fonction renvoie un index qui ne dépasse évidemment pas les limites. </p><br><p>  De plus, cette fonction est totale, c'est-à-dire que la minuterie a vérifié qu'elle se termine toujours.  Cela élimine les cycles perpétuels et les erreurs. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>Spécification</strong> <br><ul><li>  ✗ Fonctionne dans au moins un cas. </li><li>  ✓ L' <strong>index retourné est toujours l'index correct</strong> </li><li>  ✗ L'index renvoyé indique toujours une valeur appropriée </li><li>  Item L'élément manquant renvoie toujours <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garanties</strong> <br><ul><li>  ✓ Sécurité de la mémoire </li><li>  ✓ La fonction ne peut pas être appelée avec le mauvais type </li><li>  ✓ Pas d'effets secondaires </li><li>  ✗ Aucune exception </li><li>  ✓ <strong>Aucune erreur</strong> </li><li>  ✓ <strong>Pas de cycles perpétuels</strong> </li></ul></li></ul><br><h2>  Idris avec tests </h2><br><p>  Puisque le langage de type d'Idris est aussi expressif que le langage de ses termes ⟦(ou plutôt, sa partie prouvée totale)⟧, la distinction entre test et type est floue: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Cette fonction a un type plutôt étrange <code>x [1, 2, 3] 2 = Just 1</code> .  Ce type signifie que pour une vérification de type réussie, le typer doit prouver que <code>x [1, 2, 3] 2</code> structurellement égal à <code>Just 1</code> .  ⟦Dans ce cas, la preuve est triviale, car il suffit que le basculeur normalise les termes des deux côtés du signe égal, ce qui se fera en temps fini en raison de la totalité de toutes les fonctions utilisées, et qui conduira à un résultat unique grâce à Church-Rosser.  Après cela, on peut utiliser la réflexivité de l'égalité, qui est ce que <code>Refl</code> .⟧ </p><br><p>  En fait, nous avons écrit un test de niveau type. </p><br><h2>  Idris avec des preuves </h2><br><p>  Pour l'exhaustivité de l'analyse, nous pouvons utiliser toute la puissance des types dépendants et <em>prouver</em> notre implémentation (puisque les types dépendants dans Idris sont équivalents à un système logique qui inclut une logique constructive de premier ordre). </p><br><p>  En particulier, nous pouvons prouver des propriétés qui nous étaient auparavant inaccessibles: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  Le type <code>findIndexOk</code> peut être lu comme «pour tout type <code>a</code> tel qu'il ait une comparaison algorithmiquement décidable ( <code>DecEq</code> ) pour lui, pour tout vecteur <code>y</code> éléments de type <code>a</code> n'importe quelle longueur <code>n</code> et de toute valeur <code>z</code> type <code>a</code> : si <code>xyz</code> renvoie l'index <code>i</code> , alors cet index se trouve <code>z</code> , mais si <code>xyz</code> <code>Nothing</code> renvoie <code>Nothing</code> , alors il n'y a pas un tel élément dans le vecteur. " </p><br><p>  `` Il est intéressant de noter que l'auteur de l'article original donne un type légèrement plus faible que celui donné ci-dessus. '' </p><br><p>  Maintenant, nous avons tout capturé!  Quels sont les inconvénients?  Eh bien, écrire toutes ces preuves peut être assez difficile. </p><br><h2>  Comparaison </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  tests </th><th>  Haskell </th><th>  Haskell <br>  types </th><th>  Haskell <br>  types <br>  tests </th><th>  Idris </th><th>  Idris <br>  tests </th><th>  Idris <br>  preuves </th></tr><tr><th>  La documentation </th></tr><tr><td>  Nous connaissons le comportement attendu </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Il y a un exemple d'utilisation </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Nous connaissons certains types de valeurs appropriées. </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Nous connaissons tous les types de valeurs appropriées. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Spécification </th></tr><tr><td>  Fonctionne dans au moins un cas </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  L'index retourné est toujours valide. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  L'index retourné est toujours valide. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><td>  L'élément manquant donne `None` /` Nothing` </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><th>  Erreurs courantes </th></tr><tr><td>  Pas de fautes de frappe ou de noms incorrects </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Pas de «nul» soudain </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Le cas d'erreur est toujours traité. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Garanties </th></tr><tr><td>  Sécurité de la mémoire </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Ne peut pas être appelé avec le mauvais type. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Pas d'effets secondaires </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Aucune exception </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Aucune erreur </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Pas de cycles perpétuels </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr></tbody></table></div><br><h2>  Opinion </h2><br><p>  À mon avis, l'utilisation d'un système de type moderne est en soi la plus efficace en termes de relation entre les informations reçues et les garanties des efforts déployés.  Si vous voulez écrire du code assez fiable, les types peuvent être assaisonnés avec des tests.  Idéalement - dans le style de QuickCheck. </p><br><p>  Avec les types dépendants, la ligne entre les tests et les types devient moins évidente.  Si vous écrivez un logiciel pour Boeing ou pour stimulateurs cardiaques, il peut être utile de rédiger des preuves. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467677/">https://habr.com/ru/post/fr467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467667/index.html">Planification de projet d'organisation (partie 4)</a></li>
<li><a href="../fr467669/index.html">Regardez-moi en entier: tirez le meilleur parti de la vidéo en direct sur les plateformes mobiles</a></li>
<li><a href="../fr467671/index.html">NLX Retro Computer</a></li>
<li><a href="../fr467673/index.html">Fonctionnalités Go intégrées</a></li>
<li><a href="../fr467675/index.html">Modélisation de l'état de l'application à l'aide d'objets Store dans SwiftUI</a></li>
<li><a href="../fr467679/index.html">PyCrunch - Exécution intelligente des tests et couverture visuelle du code dans l'IDE</a></li>
<li><a href="../fr467681/index.html">Vulnérabilité de détournement de routage SOAP</a></li>
<li><a href="../fr467683/index.html">Essayer de composer le non-composable: schémas d'ancrage</a></li>
<li><a href="../fr467689/index.html">Un petit aperçu de SIMD en .NET / C #</a></li>
<li><a href="../fr467691/index.html">Intel Nervana NNP-T et NNP-I - puces spécialisées pour l'IA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>