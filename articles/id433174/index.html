<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¼ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ½ ğŸ‘©ğŸ»â€ğŸ’» Tidak semua tambalan sama-sama bermanfaat. ğŸ›¢ï¸ ğŸ‘‡ğŸ¿ ğŸ”¹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini melanjutkan diskusi tentang peningkatan kinerja yang dapat menjadi kenyataan jika bukan karena perbedaan tetapi. Bagian sebelumnya tentang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tidak semua tambalan sama-sama bermanfaat.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433174/"><p> Posting ini melanjutkan diskusi tentang peningkatan kinerja yang dapat menjadi kenyataan jika bukan karena perbedaan tetapi.  Bagian sebelumnya tentang <code>StringBuilder</code> ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Di sini kita melihat beberapa "perbaikan" ditolak karena kurangnya pemahaman tentang seluk-beluk spesifikasi bahasa, kasus sudut tidak jelas, dan alasan lainnya.  Ayo pergi! </p><a name="habracut"></a><br><h4 id="kogda-nichto-ne-predveschaet-bedy">  Ketika tidak ada yang menandakan masalah </h4><br><p>  Saya pikir kita masing-masing bekerja dengan metode <code>Collections.emptySet()</code> / <code>Collections.emptyList()</code> .  Ini adalah metode yang sangat berguna yang memungkinkan Anda untuk mengembalikan koleksi kosong yang kosong tanpa membuat objek baru.  Melihat ke dalam kelas <code>EmptyList</code> kita akan melihat ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyIterator(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] toArray() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } }</code> </pre> <br><p>  Lihat potensi kuat untuk peningkatan?  Metode <code>EmptyList.iterator()</code> mengembalikan iterator kosong dari hadapan, mengapa tidak membuat tipuan yang sama dengan telinga Anda untuk array yang dikembalikan oleh metode <code>toArray()</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">Ada satu tapi, dan itu disebut dokumentasi</b> <div class="spoiler_text"><blockquote>  Array yang dikembalikan akan "aman" karena tidak ada referensi yang dipertahankan oleh daftar ini.  (Dengan kata lain, metode ini harus mengalokasikan array baru meskipun daftar ini didukung oleh array).  Penelepon bebas untuk memodifikasi array yang dikembalikan. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049170.html</a> <br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk12/file/ffac5eabbf28/src/java.base/share/classes/java/util/List.java#l185</a> </p></div></div><br><p>  Dengan kata lain, metode ini harus selalu mengembalikan array <strong>baru</strong> . </p><br><p>  Anda akan berkata: "Dia tidak bisa diubah! Apa yang salah?" </p><br><p>  Hanya ahli yang berpengalaman yang dapat menjawab pertanyaan ini: </p><br><blockquote>  - Siapa yang bertanggung jawab? <br>  - Pakar yang bertanggung jawab Paul Sandoz dan Tagir Valeev </blockquote><br><div class="spoiler">  <b class="spoiler_title">Jawaban para ahli</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049171.html</a> </p><br><blockquote>  Perhatikan juga bahwa ini mengubah perilaku yang terlihat.  E. g.  seseorang mungkin menyinkronkan objek array yang dikembalikan oleh panggilan toArray, jadi perubahan ini dapat menyebabkan <strong>berbagi kunci yang</strong> tidak diinginkan. <br><br>  Setelah saya menyarankan perbaikan serupa: untuk mengembalikan EMPTY_LIST dari Arrays.asList () ketika array yang disediakan memiliki panjang nol.  Itu ditolak dengan alasan yang sama [1]. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-September/035197.html</a> <br><br>  Ngomong-ngomong, mungkin masuk akal jika bagi Arrays.asList untuk memeriksa panjang array seperti: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T... a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(a); }</code> </pre> <br><br>  Kedengarannya masuk akal, bukan?  Mengapa membuat daftar baru untuk array kosong jika Anda dapat mengambil yang sudah jadi secara gratis? <br>  Ada alasan untuk tidak melakukan ini.  Saat ini Arrays.asList tidak menetapkan batasan pada identitas Daftar yang dikembalikan.  Menambahkan optimasi mikro akan mengubahnya.  Ini adalah kasus tepi dan kasus penggunaan yang dipertanyakan juga, tetapi mengingat bahwa saya akan secara konservatif meninggalkan hal-hal sebagaimana adanya. </blockquote></div></div><br><p>  Pernyataan ini mungkin akan menyebabkan Anda bingung: </p><br><blockquote>  E. g.  seseorang mungkin menyinkronkan objek array yang dikembalikan oleh panggilan toArray, jadi perubahan ini dapat menyebabkan berbagi kunci yang tidak diinginkan. </blockquote><p>  Anda akan berkata: "Siapa yang waras akan disinkronkan pada array (!) Dikembalikan (!!!) dari koleksi!?" </p><br><p>  Kedengarannya tidak terlalu bisa dipercaya, tetapi bahasa tersebut memberikan peluang seperti itu, yang berarti ada kemungkinan pengguna tertentu akan melakukan ini (atau bahkan sudah melakukannya).  Kemudian perubahan yang diajukan akan mengubah perilaku kode, dan paling buruk, itu akan menyebabkan gangguan dalam sinkronisasi (lanjutkan, tangkap).  Risiko itu sangat tidak bisa dibenarkan, dan keuntungan yang diharapkan sangat kecil sehingga lebih baik meninggalkan semuanya apa adanya. </p><br><p>  Secara umum, kemampuan untuk melakukan sinkronisasi pada objek apa pun, kmk, adalah kesalahan pengembang bahasa.  Pertama, tajuk setiap objek berisi struktur yang bertanggung jawab untuk sinkronisasi, dan kedua, kita menemukan diri kita dalam situasi yang dijelaskan di atas ketika objek yang tampaknya tidak dapat dikembalikan beberapa kali, karena dapat disinkronkan. </p><br><p>  Moral dari dongeng ini adalah ini: spesifikasi dan kompatibilitas mundur adalah sapi suci Jawa.  Jangan coba-coba merambahnya: penjaga menembak tanpa peringatan. </p><br><h4 id="staraeshsya-staraeshsya">  Mencoba, mencoba ... </h4><br><p>  Ada beberapa kelas berbasis array di JDK sekaligus, dan semuanya menerapkan metode <code>List.indexOf()</code> dan <code>List.lastIndexOf()</code> : </p><br><ul><li>  java.util.ArrayList </li><li>  java.util.Arrays $ ArrayList </li><li>  java.util.Vector </li><li>  java.util.concurrent.CopyOnWriteArrayList </li></ul><br><p>  Kode metode ini di kelas-kelas ini diulang hampir satu lawan satu.  Banyak aplikasi dan kerangka kerja juga menawarkan solusi mereka untuk masalah yang sama: </p><br><ul><li>  <a href="" rel="nofollow">org.hibernate.bytecode.enhance.internal.tracker.SimpleFieldTracker</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtil</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtilRt</a> </li><li>  <a href="" rel="nofollow">org.springframework.oxm.jibx.JibxMarshaller</a> </li></ul><br><p>  Akibatnya, kami memiliki kode nyasar yang perlu dikompilasi (kadang-kadang kadang beberapa kali), yang terjadi di ReserverCodeCache, yang perlu diuji, dan yang hanya berkeliaran dari kelas ke kelas tanpa perubahan. </p><br><p>  Pengembang, pada gilirannya, sangat suka menulis sesuatu seperti </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Arrays.asList(array).indexOf(obj); <span class="hljs-comment"><span class="hljs-comment">//  boolean contains = Arrays.asList(array).contains(obj); //    boolean contains = Arrays.stream(names).anyMatch(nm -&gt; nm.equals(name));</span></span></code> </pre> <br><p>  Saya ingin memperkenalkan metode utilitas umum di JDK, dan menggunakannya di mana-mana, seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">disarankan</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Tambalannya</a> sesederhana dua uang: </p><br><p>  1) implementasi <code>List.indexOf()</code> dan <code>List.lastIndexOf()</code> pindah ke <code>java.util.Arrays</code> <br>  2) sebagai gantinya, <code>Arrays.indexOf()</code> dan <code>Arrays.lastIndexOf()</code> dipanggil, masing-masing </p><br><p>  Tampaknya apa yang salah?  Keuntungan dari pendekatan ini [tampaknya] jelas.  Tetapi artikel itu tentang kegagalan, jadi pikirkan apa yang salah. </p><br><blockquote>  - Siapa yang bertanggung jawab? <br>  - Pakar yang bertanggung jawab Martin Buchholz dan Paul Sandoz </blockquote><br><div class="spoiler">  <b class="spoiler_title">IMHO, sedikit kencang, tapi tetap saja</b> <div class="spoiler_text"><p>  Martin Buchholz: </p><br><blockquote>  Sergey, saya semacam mempertahankan semua kelas koleksi itu, dan kadang-kadang saya juga ingin memiliki metode indexOf di Array.java.  Tapi: <br><br>  Array umumnya tidak disarankan.  Setiap metode statis baru pada Array (atau, di mana saya benar-benar menginginkannya, pada objek array itu sendiri! Membutuhkan perubahan bahasa java!) Akan menemui perlawanan. <br><br>  Kami menyesal menyesali null dalam koleksi, jadi kelas koleksi baru seperti ArrayDeque tidak mendukungnya. <br><br>  Varian lain yang mungkin diinginkan pengguna adalah perbandingan kesetaraan seperti apa yang digunakan. <br><br>  Kami menyesal memiliki ArrayList dengan indeks awal berbasis nol - akan lebih baik untuk memiliki perilaku array array ArrayDeque sejak hari pertama. <br><br>  Kode untuk mencari irisan array sangat kecil, jadi Anda tidak banyak menghemat.  Sangat mudah untuk membuat kesalahan off-by-one, tetapi itu berlaku untuk API Array juga. </blockquote><p>  Paul Sandoz: </p><br><blockquote>  Saya tidak akan pergi sejauh mengatakan array tidak disarankan, saya positif akan memutarnya sebagai "gunakan dengan hati-hati" karena mereka berduri misalnya selalu bisa berubah. Mereka pasti bisa ditingkatkan. Saya akan sangat senang melihat array mengimplementasikan array yang umum 'Antarmuka ish, kita mungkin dapat membuat beberapa kemajuan setelah sedimen tipe nilai. <br><br>  Setiap penambahan baru pada Array akan menemui beberapa perlawanan, setidaknya bagi saya :-) Ini tidak pernah menambahkan hanya satu atau dua metode, banyak yang lain ingin ikut dalam perjalanan juga (semua primitif ditambah varian rentang).  Jadi setiap fitur baru harus cukup menguntungkan dan dalam hal ini saya tidak berpikir manfaatnya cukup kuat (seperti tekanan cache kode reduksi yang mungkin). </blockquote><p>  Paul. </p></div></div><br><p>  Korespondensi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-March/051968.html</a> </p><br><p>  Moral dari dongeng ini adalah ini: tambalan Anda yang cerdik dapat dibantai untuk diperiksa hanya karena mereka tidak akan melihat nilai khusus di dalamnya.  Ya, ada kode duplikat, tetapi tidak mengganggu siapa pun, jadi biarkan itu hidup. </p><br><h4 id="uluchsheniya-dlya-arraylist-a-ih-est-u-menya">  Perbaikan untuk ArrayList?  Saya memilikinya </h4><br><p><del>  Moped </del>  tambalan itu bukan milik saya, saya hanya akan mempostingnya untuk Anda pikirkan.  Proposal itu sendiri disuarakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> , dan itu terlihat sangat menarik.  Lihat sendiri: </p><br><div class="spoiler">  <b class="spoiler_title">Usulan Perubahan</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Tautan</a> </p></div></div><br><p>  Dengan mata telanjang, proposal itu sangat, sangat logis.  Anda dapat mengukur kinerja menggunakan <a href="" rel="nofollow">tolok ukur</a> sederhana: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayListBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; ArrayList&lt;Integer&gt; arrayRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(size); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span>(Level.Invocation) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initArrayList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Random rand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); rand.setSeed(System.currentTimeMillis()); <span class="hljs-comment"><span class="hljs-comment">// Populate the ArrayList with size-5 elements for (int i = 0; i &lt; size - 5; i++) { Integer r = rand.nextInt() % 256; arrayRandom.add(r); } } } @Benchmark public ArrayList construct_new_array_list(Data d) { ArrayList al = new ArrayList(d.arrayRandom); // once a new ArrayList is created add a new element al.add(new Integer(900)); return al; } }</span></span></code> </pre> <br><p>  Ringkasan: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Mode Cnt Score Error Units  construct_new_array_list 10 thrpt 25 388.212 Â± 23.110 ops/s construct_new_array_list 100 thrpt 25 90.208 Â± 7.995 ops/s construct_new_array_list 1000 thrpt 25 23.289 Â± 1.687 ops/s construct_new_array_list 10000 thrpt 25 7.659 Â± 0.560 ops/s  construct_new_array_list 10 thrpt 25 562.678 Â± 37.370 ops/s construct_new_array_list 100 thrpt 25 119.791 Â± 13.232 ops/s construct_new_array_list 1000 thrpt 25 33.811 Â± 3.812 ops/s construct_new_array_list 10000 thrpt 25 10.889 Â± 0.564 ops/s</code> </pre> <br><p>  Tidak buruk sama sekali untuk perubahan sederhana.  Yang utama adalah sepertinya tidak ada tangkapan.  Jujur buat sebuah array, jujur â€‹â€‹salin data dan jangan lupa tentang ukurannya.  Sekarang mereka pasti harus menerima tambalan! </p><br><div class="spoiler">  <b class="spoiler_title">Tapi itu dia</b> <div class="spoiler_text"><p>  Martin Buchholz: </p><br><blockquote>  Ini bukan pertanyaan bahwa kita dapat mengoptimalkan kasus ArrayList -&gt; ArrayList, tetapi bagaimana dengan semua implementasi Koleksi lainnya?  ArrayDeque dan CopyOnWriteArrayList datang ke pikiran. <br>  ArrayList adalah kelas populer yang digunakan untuk membuat salinan Koleksi.  Di mana Anda berhenti? <br><br>  Subclass patologis dari ArrayList dapat memutuskan untuk tidak menyimpan elemen dalam array dukungan, dengan kerusakan berikutnya. <br><br>  Solusi terberkati untuk masalah penyalinan daftar mungkin adalah List.copyOf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html#copyOf(java .util.Collection</a> ) yang mungkin melakukan optimasi yang Anda harapkan. </blockquote><p>  Alan Bateman </p><br><blockquote>  ArrayList belum final sehingga mungkin seseorang telah memperluasnya untuk menggunakan sesuatu selain elementData.  Mungkin lebih aman untuk menggunakan identitas kelas daripada instanceof. </blockquote></div></div><br><p>  Tidak ada yang melarang saya untuk keluar dari <code>ArrayList</code> , dan untuk menyimpan data dalam daftar tertaut.  Kemudian <code>c instanceof ArrayList</code> akan mengembalikan kebenaran, kita akan sampai ke area copy dan jatuh dengan aman. </p><br><p>  Moral dari dongeng ini adalah ini: <em>kemungkinan</em> perubahan perilaku dapat menjadi penyebab kegagalan.  Dengan kata lain, seseorang harus mengingat kemungkinan bahkan perubahan yang paling tidak masuk akal, jika diizinkan dengan cara bahasa.  Dan ya, itu bisa berhasil jika <code>ArrayList</code> telah menyatakan <code>final</code> dari awal. </p><br><h4 id="snova-specifikaciya">  Spesifikasi lagi </h4><br><p>  Saat debug aplikasi saya, saya tidak sengaja jatuh ke nyali Spring dan menemukan <a href="" rel="nofollow">kode</a> berikut: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      paramTypes for (Constructor&lt;?&gt; candidate : candidates) { Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) { // Already found greedy constructor that can be satisfied -&gt; // do not look any further, there are only less greedy constructors left. break; } if (paramTypes.length &lt; minNrOfArgs) { continue; }</span></span></code> </pre> <br><p>  Untungnya, dengan masuk ke dalam <code>java.lang.reflect.Constructor.getParameterTypes()</code> saya menggulirkan kode sedikit lebih rendah dan menemukan yang indah: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;?&gt;[] getParameterTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.clone(); } <span class="hljs-comment"><span class="hljs-comment">/** * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.8 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.length; }</code> </pre> <br><p>  Anda mengerti, ya?  Jika kita perlu mengetahui jumlah argumen konstruktor / metode, maka panggil saja <code>java.lang.reflect.Method.getParameterCount()</code> dan lakukan tanpa menyalin array.  Periksa apakah game bernilai lilin dalam kasus paling sederhana, di mana metode ini tidak memiliki parameter: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodToStringBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Method method; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ method = getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"toString"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterCount(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterTypes().length; } }</code> </pre> <br><p>  Di komputer saya dan dengan JDK 11 ternyata seperti ini: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units getParameterCount avgt 25 2,528 Â± 0,085 ns/op getParameterCount:Â·gc.alloc.rate avgt 25 â‰ˆ 10â»â´ MB/sec getParameterCount:Â·gc.alloc.rate.norm avgt 25 â‰ˆ 10â»â· B/op getParameterCount:Â·gc.count avgt 25 â‰ˆ 0 counts getParameterTypes avgt 25 7,299 Â± 0,410 ns/op getParameterTypes:Â·gc.alloc.rate avgt 25 1999,454 Â± 89,929 MB/sec getParameterTypes:Â·gc.alloc.rate.norm avgt 25 16,000 Â± 0,001 B/op getParameterTypes:Â·gc.churn.G1_Eden_Space avgt 25 2003,360 Â± 91,537 MB/sec getParameterTypes:Â·gc.churn.G1_Eden_Space.norm avgt 25 16,030 Â± 0,045 B/op getParameterTypes:Â·gc.churn.G1_Old_Gen avgt 25 0,004 Â± 0,001 MB/sec getParameterTypes:Â·gc.churn.G1_Old_Gen.norm avgt 25 â‰ˆ 10â»âµ B/op getParameterTypes:Â·gc.count avgt 25 2380,000 counts getParameterTypes:Â·gc.time avgt 25 1325,000 ms</code> </pre> <br><p>  Apa yang bisa kita lakukan?  Kita dapat mencari penggunaan <code>Method.getParameterTypes().length</code> antipattern.getParameterTypes <code>Method.getParameterTypes().length</code> di JDK (setidaknya di <code>java.base</code> ) dan ganti di tempat yang masuk akal: </p><br><p> <code>java.lang.invoke.MethodHandleProxies</code> </p> <br><p><img src="https://habrastorage.org/webt/l_/3j/h1/l_3jh1hu3swdedxqktlxboz0tu0.png"></p><br><p> <code>java.util.concurrent.ForkJoinTask</code> </p> <br><p><img src="https://habrastorage.org/webt/0o/rt/q7/0ortq71mnf3-bwsa4wyi-jmzf5y.png"></p><br><p> <code>java.lang.reflect.Executable</code> </p> <br><p><img src="https://habrastorage.org/webt/sm/_h/pm/sm_hpm8eahlmqavobjqg9gejvse.png"></p><br><p> <code>sun.reflect.annotation.AnnotationType</code> </p> <br><p><img src="https://habrastorage.org/webt/yw/bv/il/ywbvil_doi3fzy6uzkpcm42g6zu.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Tambalan</a> itu dikirim bersama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">surat pengantar</a> . </p><br><p>  Tiba-tiba, ternyata selama beberapa tahun telah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">tugas yang serupa,</a> dan bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">perubahan telah</a> disiapkan untuk itu.  Komentar mencatat peningkatan kinerja yang lumayan untuk perubahan sederhana seperti itu.  Namun, keduanya dan patch saya sudah dibersihkan sejauh ini dan tidak bergerak.  Mengapa  Mungkin karena pengembang terlalu sibuk dengan hal-hal yang lebih penting dan mereka dengan bodohnya tidak mendapatkannya. </p><br><p>  Moral dari dongeng ini adalah ini: perubahan cerdik Anda dapat membeku hanya karena kurangnya pekerja. </p><br><p>  Tetapi ini bukan akhir!  Selama diskusi tentang rasionalitas penggantian yang dijelaskan dalam proyek lain, kawan yang lebih berpengalaman mengajukan proposal balasan: mungkin Anda tidak boleh melakukan penggantian <code>Method.getParameterTypes().length -&gt; Method.getParameterCount()</code> dengan tangan Anda, tetapi percayakan ini ke kompiler?  Apakah ini mungkin dan apakah akan "sah"? </p><br><p>  Mari kita coba periksa menggunakan tes: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">3</span></span>]; objects[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"azaza"</span></span>; objects[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">365</span></span>; objects[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">9876L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] clone = objects.clone(); assertEquals(objects.length, clone.length); assertSame(objects[<span class="hljs-number"><span class="hljs-number">0</span></span>], clone[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">1</span></span>], clone[<span class="hljs-number"><span class="hljs-number">1</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">2</span></span>], clone[<span class="hljs-number"><span class="hljs-number">2</span></span>]); }</code> </pre> <br><p>  yang lewat, dan yang menunjukkan bahwa jika array yang dikloning tidak meninggalkan ruang lingkup, maka itu dapat dihapus, karena akses ke elemen apa pun dari sel-selnya atau bidang <code>length</code> dapat diperoleh dari aslinya. </p><br><p>  Bisakah JDK melakukan ini?  Kami memeriksa: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayAllocationEliminationBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].length; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baselineClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].clone().length; } }</code> </pre> <br><p>  Output untuk JDK 13: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 50 6,135 Â± 0,140 ns/op baseline:Â·gc.alloc.rate.norm avgt 50 56,000 Â± 0,001 B/op clone avgt 50 18,359 Â± 0,619 ns/op clone:Â·gc.alloc.rate.norm avgt 50 112,000 Â± 0,001 B/op</code> </pre> <br><p>  Ternyata openjdk tidak tahu cara membuang <code>new int[length]</code> , tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Grail</a> , hehe: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 25 2,470 Â± 0,156 ns/op baseline:Â·gc.alloc.rate.norm avgt 25 0,005 Â± 0,008 B/op lone avgt 25 13,086 Â± 1,059 ns/op lone:Â·gc.alloc.rate.norm avgt 25 112,113 Â± 0,115 B/op</code> </pre> <br><p>  Ternyata Anda dapat men-tweak kompiler optimisasi openjdk sedikit sehingga dapat melakukan apa yang dapat dilakukan Grail.  Karena tidak hanya semua orang dapat masuk ke iklan positif dalam kode VM dan mengajukan sesuatu yang bermakna, saya membatasi diri pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">surat</a> yang menyatakan pengamatan saya. </p><br><p>  Ternyata, dan ada beberapa kehalusan.  Vladimir Ivanov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">menunjukkan</a> bahwa: </p><br><blockquote>  Mempertimbangkan tidak ada cara untuk menumbuhkan / mengecilkan susunan Java, <br>  "cloned_array.length =&gt; original_array.length" transformasi benar <br>  terlepas dari apakah varian yang dikloning lolos atau tidak. <br><br>  Selain itu, transformasi sudah ada di sana: <br><br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk/file/tip/src/hotspot/share/opto/memnode.cpp#l2388</a> <br><br>  Saya belum melihat tolok ukur yang Anda sebutkan, tetapi sepertinya <br>  akses cloned_array.length bukan alasan mengapa array kloning masih <br>  disana <br><br>  Mengenai ide-ide Anda yang lain, pengalihan akses dari turunan kloning ke <br>  asli bermasalah (dalam kasus umum) karena kompiler harus membuktikan <br>  tidak ada perubahan pada kedua versi dan akses yang diindeks membuatnya genap <br>  lebih sulit.  Dan titik aman menyebabkan masalah juga (untuk rematerialisasi). <br><br>  Tetapi saya setuju bahwa akan lebih baik untuk meliput (setidaknya) kasus sederhana <br>  menyalin defensif. </blockquote><p>  Yaitu, membenturkan klon sepertinya mungkin, dan tidak terlalu sulit.  Tetapi dengan pertobatan </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[arrayLength].length;</code> </pre> <br><p>  -&gt; </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = arrayLength;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kesulitan</a> muncul: </p><br><blockquote>  Kami tidak menghilangkan alokasi array yang tidak diketahui panjangnya <br>  karena mereka dapat menyebabkan Pengecualian NegatifArraySize.  Dalam hal ini kita <br>  harus bisa membuktikan bahwa panjangnya positif. <br><br>  Pokoknya - Saya memiliki patch yang hampir selesai yang menggantikan array yang tidak digunakan <br>  alokasi dengan penjaga yang tepat. </blockquote><p>  Dengan kata lain, Anda tidak bisa begitu saja mengambil dan membuang pembuatan array, karena sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi,</a> eksekusi <em>harus</em> membuang <code>NegativeArraySizeException</code> dan tidak ada yang bisa kita lakukan tentang itu: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayWithNwgativeSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = -<span class="hljs-number"><span class="hljs-number">3</span></span>; length = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[newLen].length; <span class="hljs-comment"><span class="hljs-comment">//  new Object[newLen]  fail(); } catch (NegativeArraySizeException e) { assert length == 0; } }</span></span></code> </pre> <br><p>  Mengapa Cawan bisa?  Saya pikir alasannya adalah bahwa nilai bidang <code>length</code> pada tolok ukur di atas adalah konstan dan selalu sama dengan 10, yang memungkinkan profiler untuk menyimpulkan bahwa memeriksa nilai negatif tidak diperlukan, yang berarti dapat dihapus bersamaan dengan pembuatan array itu sendiri.  Benar dalam komentar jika saya melakukan kesalahan. </p><br><p>  Itu saja untuk hari ini :) Tambahkan contoh Anda di komentar, kami akan mengerti. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433174/">https://habr.com/ru/post/id433174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433164/index.html">Fast and the Furious: Forza Horizon 4 Mempercepat dengan Window Shaders</a></li>
<li><a href="../id433166/index.html">Memprediksi Solusi Tiket Waktu Menggunakan Machine Learning</a></li>
<li><a href="../id433168/index.html">Mengapa seorang programmer memiliki magang di dapur - percakapan dengan Dodo Pizza tentang gemba, .NET, dan keterbukaan</a></li>
<li><a href="../id433170/index.html">Bagaimana kami tidak bisa mengulang arsitektur perusahaan</a></li>
<li><a href="../id433172/index.html">Kami kencangkan multipemain ke game seluler "Buat kata-kata dari kata-kata" di iOS dan Android, ditulis dalam C ++</a></li>
<li><a href="../id433176/index.html">Certificate Remote Authentication Docker Remote dengan verifikasi pencabutan</a></li>
<li><a href="../id433178/index.html">Bagaimana kami memulihkan file .wav yang rusak</a></li>
<li><a href="../id433180/index.html">Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan</a></li>
<li><a href="../id433182/index.html">Apakah mungkin untuk melatih agen untuk perdagangan di pasar saham dengan bala bantuan? Implementasi bahasa R</a></li>
<li><a href="../id433184/index.html">ASP.NET Core 2.2 dirilis. Apa yang baru? (2 dari 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>