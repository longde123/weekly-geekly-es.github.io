<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 💢 🥡 Wie wir IoT-Zahlungen bei einem Hackathon in Hongkong gesehen haben 👲🏼 🔒 🧑🏿‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der 10. Juni war der dritte Tag unserer Akklimatisation in Hongkong. Und die letzten 26 Stunden haben wir fast ohne Schlaf verbracht und in der ersten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir IoT-Zahlungen bei einem Hackathon in Hongkong gesehen haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mixbytes/blog/414803/"><p><img src="https://habrastorage.org/webt/fs/nm/lj/fsnmljsf_fjfqn0eqomgc9yyswi.jpeg"></p><br><p>  Der 10. Juni war der dritte Tag unserer Akklimatisation in Hongkong.  Und die letzten 26 Stunden haben wir fast ohne Schlaf verbracht und in der ersten Phase des EOS Global Hackathons ein Prototypprojekt unter dem Arbeitsnamen SensorPay mit einem Gesamtpreispool von eineinhalb Millionen Dollar entwickelt.  Der Moment der Demonstration des Projekts vor den Richtern rückte näher. </p><br><p>  Wenn Sie wissen möchten, wie diese Geschichte endete, schauen Sie sich gleich den letzten Teil an.  In der Zwischenzeit werden wir systematisch über EOS-Technologien sprechen und wie wir auf die Idee gekommen sind, Zahlungen für IoT mit EOS zu verknüpfen.  Gleich danach wird es eine detaillierte Beschreibung der technischen Füllung des Projekts geben. </p><a name="habracut"></a><br><h1 id="0-predystoriya">  0. Hintergrund </h1><br><p>  EOS ist eine Blockchain der neuen Generation, manche halten sie sogar für einen Ethereum-Killer.  Wenn Sie plötzlich nicht mehr wissen, was eine Blockchain oder ein Ethereum ist, hilft Google.  Und wir haben vor ungefähr einem Jahr angefangen, EOS auszugraben, unter anderem indem wir die früheren Produkte der Autoren BitShares und Steem studiert haben. </p><br><p>  Die Vorteile von EOS gegenüber Ethereum: Der Transaktionsdurchsatz ist um drei Größenordnungen höher.  entwickeltes Genehmigungssystem für intelligente Verträge;  die Fähigkeit, verlorenen Zugriff wiederherzustellen und Fehler in der Blockchain zu beheben;  Onchain-Netzwerkverwaltung.  Schwächen: Bedenken hinsichtlich der Zentralisierung, potenziell anfälligerer DPoS-Konsens, Rohcode und eine steilere Lernkurve für Entwickler. </p><br><p>  Da wir diese Technologie schon lange lieben und für vielversprechend halten, konnten wir die Reihe von Hackathons, die von den Autoren von EOS unterstützt wird, nicht außer Acht lassen.  Wir wollten einfach nur da sein, unsere Ideen in diesem inspirierenden Umfeld verwirklichen und sie einem breiten Publikum zugänglich machen.  Natürlich wurde die Möglichkeit, gutes Geld zu gewinnen, auch zu einem zusätzlichen angenehmen Motivator. </p><br><p>  Daher ist EOS die einzige funktionierende Lösung für die öffentliche Blockchain, von der wir wissen, wo Sie VIELE Transaktionen ausführen können.  Wo ist es erforderlich?  Natürlich im IoT!  In der Tat, wenn jeder Toaster zu Mikrozahlungen wird, zahlt er für jedes Stück Brot an den Kühlschrank (und dies ist, wie Sie verstehen, standardmäßig cool), wird es viele Transaktionen geben.  Ganz zu schweigen von allen möglichen anderen Anwendungen in Medizin, Industrie und Alltag. </p><br><p>  Einige Wochen vor dem Hackathon tauchten regelmäßig alternative Ideen auf und es fanden kleine Brainstorms statt.  Wir haben Ideen anhand bekannter Schiedsrichterkriterien verglichen: Nutzung von EOS-Funktionen, Kreativität, öffentliche Wirkung und Skalierbarkeit.  Aus diesem Grund haben wir uns für IoT + EOS entschieden - eine Lösung, die Daten von Sensoren übernimmt und viele Zahlungsvorgänge an EOS sendet. </p><br><p>  Übrigens wollten wir hier auch erzählen, wie wir unseren Block Producer für EOS erzogen haben;  wie sie vorhatten, den Konstrukteur von ERC721-ähnlichen Token und die Unterstützung für konstante Funktionen für ihn zu spülen;  Wie haben sie das Merkle Root ACL-Protokoll eingereicht?  All dies passt jedoch nicht in den Artikel, sodass wir zu unserem Hauptprojekt zurückkehren werden. </p><br><p><img src="https://habrastorage.org/webt/9j/mu/uk/9jmuukvwx1e6cav3h59txeywaw0.jpeg"></p><br><h1 id="1-podgotovka">  1. Vorbereitung </h1><br><h2 id="11-iot">  1.1.  IoT </h2><br><p>  Um den IoT-Teil des Projekts vorzubereiten, muss die richtige Hardware ausgewählt werden.  In der Rolle des RFID-Lesegeräts wurde der RC522 ausgewählt, der auf dem SPI-Bus arbeitet: Er ist beliebt und einfach zu bedienen. </p><br><p><img src="https://habrastorage.org/webt/tq/xf/qh/tqxfqh4x5vzlaywel57eqszznpu.jpeg"></p><br><p>  Bei der Suche nach einem Zähler haben wir uns auf das Vorhandensein eines Impulsausgangs konzentriert, da Sie damit Daten sehr einfach lesen können: Ein Impuls ist X kW⋅h (wobei X vom Modell abhängt). Daher haben wir am Mercury 201.5-Zähler angehalten. </p><br><p><img src="https://habrastorage.org/webt/z-/63/sc/z-63scf4m94nnbw30prkmy_nfxa.jpeg"></p><br><p>  Am schwierigsten war es, sich für den Controller zu entscheiden, der Daten von den Sensoren sammelt, eine Transaktion bildet, sie mit Ihrem privaten Schlüssel signiert und an das Netzwerk sendet.  Dementsprechend benötigten wir ein Gerät mit einem Netzwerkmodul, das eine Transaktion mit ECDSA signieren konnte (in diesem Fall auf der elliptischen Kurve secp256k1, da es in EOS zum Signieren verwendet wird). </p><br><p>  Die Wahl fiel zunächst auf den Mikrocontroller ESP8266, der über ein Wi-Fi-Modul und alle erforderlichen Schnittstellen zum Anschluss unserer Sensoren verfügt.  Gleichzeitig ist es sehr kompakt.  Aber keine der Firmware hat eine native Implementierung von elliptischen Grundelementen.  Es ist möglich, eine eigene Implementierung zu schreiben, dies ist jedoch keine Aufgabe für den Hackathon.  Als Ergebnis wurde Raspberry Pi 3 B für den Prototyp ausgewählt und die eosjs-Bibliothek wurde zum Generieren und Signieren von Transaktionen verwendet. </p><br><p><img src="https://habrastorage.org/webt/ww/jo/dg/wwjodgbxktjubpruvb-srqz_9dq.jpeg"></p><br><h2 id="12-infrastruktura">  1.2.  Die Infrastruktur </h2><br><p>  Einige Tage vor dem Hackathon haben wir vor Ort und auf dem Server eos-hackathon.smartz.io eine EOS-Assembly ( <a href="">Quelle</a> ) vorbereitet.  Die Installation, Montage und Tests von Abhängigkeiten verliefen für ein so junges Projekt überraschend reibungslos (mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ).  Es gab nicht genug Zeit für die Vorbereitung anderer Infrastrukturen, und ich musste mich bereits während des Hackathons damit befassen. </p><br><h2 id="13-arhitektura">  1.3.  Architektur </h2><br><p>  Am Vorabend des Hackathons diskutierten wir die Architektur und klärten die Produktdetails.  Wir wollten die folgenden Hauptfälle implementieren: Zahlungen für Strom und Zahlungen für Einkäufe, die mit RFID-Tags gekennzeichnet sind.  Sie planten auch, das Produkt leicht erweiterbar zu machen und es in anderen Bereichen zu verwenden. </p><br><p><img src="https://habrastorage.org/webt/yh/rh/tm/yhrhtm0ildam8hgnnjnpkf4_l7w.jpeg"></p><br><p>  Die Idee der Architektur ist, dass der Dienstleister (Produzent) einen Vertrag erstellt - den zentralen Punkt der Interaktion zwischen Lieferant und Verbraucher.  Jeder Verbraucher hat sein eigenes Guthaben, das aufgefüllt werden kann. Die Gelder werden auf der Grundlage von Sensorsignalen abgebucht.  Alle Daten - Benutzer, Sensoren, Statistiken - werden im Lieferantenvertrag gespeichert. </p><br><p> Benutzereinstellungen sind dem Verbraucher oder Flags (z. B. einer bevorzugten Benutzerkategorie) zugeordnet - <code>user_meta</code> .  Mit dem Verbraucher können mehrere Sensoren verbunden werden, für die jeweils ein Vertrag und Abrechnungseinstellungen ( <code>billing_meta</code> ) angezeigt werden.  So können Sie einen unveränderlichen staatenlosen Abrechnungsvertrag abschließen, der für eine große Anzahl von Verbrauchern verwendet wird.  Die erforderlichen Daten werden während des <code>bill(payload, user_meta, billing_meta)</code> der <code>bill(payload, user_meta, billing_meta)</code> .  Es wird auch die Möglichkeit einer unterschiedlichen Abrechnungslogik, d. H. Unterschiedlicher Verträge, festgelegt: Zum Beispiel betrachtet einer Strom, der andere Waren.  Jeder Sensor hat einen „Zeiger“ auf seinen Abrechnungsvertrag. </p><br><p>  Es wird davon ausgegangen, dass der Verbraucher dem Sensorhersteller vertraut, dem Dienstleister jedoch nicht unbedingt.  Die Schnittstelle zur Interaktion mit dem Sensor ist äußerst einfach: Es handelt sich um einen Aufruf der Lieferantenvertragsmethode mit einem numerischen Parameter, der in die Abrechnung übertragen wird.  Der Dienstleister startet Verbraucher, Sensoren, Abrechnungsverträge und deren Beziehungen in seinem Vertrag mithilfe von Kontrolltransaktionen - primitiven Setzern.  Wenn eine Transaktion vom Sensor empfangen wird, werden Daten überprüft, Daten für die Abrechnung generiert, die Abrechnung aufgerufen, die Zahlung aufgezeichnet und Statistiken aufgezeichnet. </p><br><p>  Vielleicht haben wir vor allem die folgenden Punkte besprochen, die für die Anwendbarkeit des Produkts in der realen Welt wichtig sind: </p><br><ul><li>  Anzahlungen oder Nachzahlung?  Füllen Sie Ihr Konto auf und verwenden Sie es (wie eine Mobilfunkverbindung) - oder verwenden Sie es und zahlen Sie es dann aus (wie AWS)?  Hier gibt es keine richtige oder falsche Antwort: Unterschiedliche Unternehmen bevorzugen unterschiedliche Modelle.  Der Einfachheit halber haben wir uns für Vorauszahlungen entschieden. </li><li>  Sollte der Benutzer für jeden Lieferanten ein separates Konto führen oder stammen alle Gebühren von einem Konto?  Wieder - es gibt keine richtige und falsche Entscheidung;  Darüber hinaus hängt die Antwort eng mit der Antwort auf die vorherige Frage zusammen.  Vorauszahlungen sind gute Freunde mit individuellen Verbraucherkonten - sie wurden genommen. </li><li>  Eine Gebühr in EOS, einem Token eines Dienstleisters oder einer stabilen Münze (gebunden an die Fiat-Währung) erheben?  Andere Optionen als stabile Münzen sind für den Verbraucher natürlich aufgrund der Volatilität unpraktisch, und stabile Münzen im Rahmen von EOS gibt es noch nicht.  Zu diesem Zeitpunkt war noch nicht einmal das Haupt-EOS-Netzwerk vorhanden!  Der Einfachheit halber nahmen sie ein bedingtes Zeichen. </li></ul><br><h1 id="2-koding">  2. Codierung </h1><br><p>  Zunächst haben wir die API und den Rahmen des Lieferantenvertrags festgelegt, um gleichzeitig mit der Entwicklung des Frontends, des Gerätecodes, der Abrechnung und des Hauptvertrags ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ) zu beginnen. </p><br><h2 id="21-iot">  2.1.  IoT </h2><br><p>  Der erste, der einen <a href="">Code</a> zum Lesen von Impulsen von einem Zähler implementiert.  Für die Arbeit mit GPIO (Allzweck-Pins) wurde die Onoff-JS-Bibliothek verwendet.  Später wurden der Schaltung aus Gründen der Übersichtlichkeit zwei LEDs hinzugefügt: Die erste blinkte, wenn ein Signal vom Zähler empfangen wurde, und die zweite, wenn eine Antwort auf eine erfolgreiche Transaktion vom EOS-Knoten kam.  In ähnlicher Weise haben wir ein Schema und einen Code zum Lesen von RFID-Tags entwickelt, mit dem einzigen Unterschied: Das Lesen erfolgte auf dem SPI-Bus unter Verwendung der MFRC522-Python-Bibliothek.  Wie sich herausstellte, unterscheidet sich die SPI-Einstellung für den Raspberry Pi 3 von der Einstellung in früheren Board-Modellen.  Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisung</a> half uns zu verstehen. </p><br><p>  Die Geräte wurden von der Power Bank gespeist, die allen Hackathon-Teilnehmern erfolgreich präsentiert wurde, und sie mussten das Internet selbst mit dem iPhone 5 teilen, da das WLAN des Hackathons ausschließlich mit 5 GHz funktionierte, funktionierte dies beim Raspberry Pi nicht. </p><br><h2 id="22-infrastruktura-i-utility">  2.2.  Infrastruktur und Dienstprogramme </h2><br><p>  Die Organisatoren rieten, das Docker-Bild von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eos-dev aufzunehmen</a> , aber wir waren verwirrt über die fehlende Beschreibung und Dokumentation des Bildes.  Auf dem Server arbeiteten sie weiterhin mit der vorbereiteten Assembly und verwendeten lokal eos-dev, um eine systematische Installation von EOS zu vermeiden. </p><br><p>  Sofort dringend benötigt die Fähigkeit, schnell zu bauen und zu testen.  Ideal: Erstellen und Ausführen einer lokal ausführbaren Datei.  Es war jedoch nicht zu übersehen, dass für die Ausgabe nach der Assembly WebAssembly und in der EOS-Umgebung mit dem entsprechenden Boost Bibliotheken und Systemverträge erforderlich waren.  Die notwendigen Kompilierungsoptionen könnten in <a href="">eosiocpp.in</a> ausspioniert werden. <a href="">Wir</a> haben uns jedoch entschieden, dieses Spiel nicht zu spielen.  Das vorhergesagte Ergebnis ist zwar etwas langsamer, aber wichtiger als eine schnelle Lösung mit einem potenziellen Rechen.  Daher haben wir für die Montage eoscpp genommen, das sich im eos-dev-Container befindet. </p><br><p>  Es stellte sich heraus, dass es mit dem Start schwieriger wurde, ich musste die lokale EOS-Blockchain erhöhen, und wieder gab es keine vorgefertigte Lösung.  Nur Software.  So erschien die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Version</a> der Startinfrastruktur.  Die Idee ist, die Nuancen der Montage und Konfiguration zu verbergen und einen selbstkonsistenten Satz von vier bis fünf "Tasten" für typische Aktionen zu erhalten.  Weniger Kontrolle, aber weniger Fehlerwahrscheinlichkeit und Zeitersparnis. </p><br><p>  Zu den Hauptkomponenten von EOS gehören die Nodeos, Keosd Daemons, das Cleos Console-Dienstprogramm und der Eoscpp-Compiler: </p><br><ul><li>  nodeos - EOS node, Daemon - Netzwerkteilnehmer, bietet Zugriff auf die Blockchain und erzeugt optional neue Blöcke; </li><li>  keosd - ein Daemon zum Verwalten lokaler Brieftaschen, in denen Schlüsselpaare gespeichert sind; </li><li>  cleos bietet Befehle vom Abrufen von Informationen über Transaktionen bis zum Arbeiten mit Schlüsseln. Es wird basierend auf Aufrufen in nodeos und keosd über die HTTP-API implementiert. </li><li>  eoscpp kompiliert Verträge in WebAssembly und ermöglicht es Ihnen, die binäre Anwendungsschnittstelle basierend auf dem Quellcode abzurufen. </li></ul><br><p>  Es wurde sofort klar, dass Cleos-Befehle im Zusammenhang mit Keosd-Aufrufen nicht funktionierten.  Da ein Fehler ausgegeben wurde, der auf die Unzugänglichkeit des Keosd-Netzwerks hinweist, haben wir Zeit damit verbracht, Netzwerkprobleme im Docker-Netzwerk zu diagnostizieren.  Strace zeigte jedoch, dass es sich nicht um das Netzwerk handelte: Cleos hat immer auf localhost auf die falsche Adresse zugegriffen (und im Fall unserer Infrastruktur haben verschiedene Daemons unterschiedliche Netzwerkadressen in einem separaten Docker-Netzwerk).  In cleos wurde ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler</a> diagnostiziert: Bei der Überprüfung der Verfügbarkeit von Keosd, die vor einem Befehl für Brieftaschen ausgeführt wird, wird der in den Argumenten übergebene Port berücksichtigt, die Adresse jedoch nicht.  Im Rahmen des Hackathons haben wir als Workaround auf das Host-Netzwerk in Docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgestellt</a> . </p><br><p>  Der nächste Schritt war das Dienstprogramm zur Vertragskompilierung mit dem Compiler im Container ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ).  Eingabe- und Ausgabeverzeichnisse wurden bereitgestellt.  Und schließlich die Möglichkeit, einen Vertrag in die Blockchain hochzuladen und Transaktionen zu senden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ).  Wieder - Dienstprogramme in einem einheitlichen Stil, einfache "Schaltflächen".  Damit war die Basisinfrastruktur beendet, aber die Überraschungen gingen weiter: Wir stießen auf das Problem der C-Funktionen für die Arbeit mit dem Speicher (ausführlicher unten). </p><br><p>  Abschließend haben sie begonnen, Konten in einer Datei einzurichten (jeder Vertrag und jeder Teilnehmer benötigt separate Konten), zusammen mit Schlüsselpaaren, die beim Start der Blockchain automatisch erstellt werden, damit ein Team die Testumgebung erhöhen kann.  Eine Kopie dieser Umgebung wurde auf eos-hackathon.smartz.io bereitgestellt. </p><br><h2 id="23-smart-kontrakty">  2.3.  Intelligente Verträge </h2><br><h3 id="231-kontrakt-postavschika-i-billing-elektrichestva">  2.3.1.  Lieferantenvertrag und Stromabrechnung </h3><br><p>  Nach dem Start des Hackathons haben wir begonnen, die Vertragsstruktur gemäß dem obigen Schema festzulegen.  Das System bestand aus folgenden Verträgen: </p><br><ul><li>  <code>supplier</code> - <code>supplier</code> ; </li><li>  <code>billing_electricity</code> - ein Vertrag zur Berechnung der <code>billing_electricity</code> für jeden Tick des <code>billing_electricity</code> . </li></ul><br><p>  Im <code>supplier</code> wird der größte Teil der Arbeit von normalen CRUD-Vorgängen ausgeführt: Hinzufügen von Benutzern, Tarifen, Zählern, Erhöhen oder Verringern des Benutzersaldos.  Komplexere Methoden waren dafür verantwortlich, Daten vom Zähler zu empfangen, einen Vertrag zur Berechnung einer Zahlung (Abrechnung) aufzurufen und das persönliche Konto eines Benutzers nach einem Rückruf von einem Abrechnungsvertrag zu belasten.  Der erforderliche Abrechnungsvertrag wurde anhand des Tarifs des Benutzers festgelegt. </p><br><p>  Nach dem Aufruf im Abrechnungsvertrag wurde die Zahlung berechnet und die Methode zum Abbuchen der Zahlung vom persönlichen Konto des Benutzers aufgerufen.  Nachdem wir die Hauptlogik geworfen hatten, dachten wir sogar, wir würden zu einfache Verträge abschließen.  Wenig später, nach der Bereitstellung der Verträge im Knoten und deren Tests, wurde klar, dass die Verträge zwar einfach sind, aber es gibt Nuancen.  :) :) </p><br><p>  Nach der Bereitstellung stellte sich heraus, dass die erwarteten Vertragsaufrufe voneinander nicht funktionierten.  Nicht genug Rechte.  Im Gegensatz zu intelligenten Verträgen in Ethereum, bei denen ein Vertrag aus einem Vertrag im Namen des aufrufenden Vertrags abgerufen wird, beginnt in EOS die gesamte Kette mit dem Initiator der Transaktion.  Wenn ein Vertrag aus einem Vertrag aufgerufen wird, wird geprüft, ob der Initiator dem Vertrag dies erlaubt hat. </p><br><p>  Mentoren schlugen sofort vor, wie man in einem einfachen Fall handeln sollte.  Rechte werden wie folgt hinzugefügt (über den Smart Contract von eosio system): </p><br><pre> <code class="hljs swift">./cleos push action eosio updateauth '{<span class="hljs-string"><span class="hljs-string">"account"</span></span>:<span class="hljs-string"><span class="hljs-string">"electricity"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"active"</span></span>,<span class="hljs-string"><span class="hljs-string">"parent"</span></span>:<span class="hljs-string"><span class="hljs-string">"owner"</span></span>,<span class="hljs-string"><span class="hljs-string">"auth"</span></span>:{<span class="hljs-string"><span class="hljs-string">"keys"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"key"</span></span>:<span class="hljs-string"><span class="hljs-string">"EOS7oPdzdvbHcJ4k9iZaDuG4Foh9YsjQffTGniLP28FC8fbpCDgr5"</span></span>,<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"threshold"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"accounts"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"supplier"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"waits"</span></span>:[]}}' -p electricity</code> </pre> <br><p>  In diesem Fall ermöglicht das <code>electricity</code> dem <code>supplier</code> , andere Verträge in seinem Namen zu kündigen.  Weitere Informationen zu Rechten finden Sie in <a href="">Technical WP EOS</a> .  In unserem Land verursachte der <code>supplier</code> den <code>billing</code> , der wiederum erneut als <code>supplier</code> .  Das analoge Hinzufügen von Rechten in dieser Form hat nicht funktioniert: </p><br><pre> <code class="hljs swift">./cleos push action eosio updateauth '{<span class="hljs-string"><span class="hljs-string">"account"</span></span>:<span class="hljs-string"><span class="hljs-string">"electricity"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"active"</span></span>,<span class="hljs-string"><span class="hljs-string">"parent"</span></span>:<span class="hljs-string"><span class="hljs-string">"owner"</span></span>,<span class="hljs-string"><span class="hljs-string">"auth"</span></span>:{<span class="hljs-string"><span class="hljs-string">"keys"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"key"</span></span>:<span class="hljs-string"><span class="hljs-string">"EOS7oPdzdvbHcJ4k9iZaDuG4Foh9YsjQffTGniLP28FC8fbpCDgr5"</span></span>,<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"threshold"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"accounts"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"supplier"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>},{<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:{<span class="hljs-string"><span class="hljs-string">"actor"</span></span>:<span class="hljs-string"><span class="hljs-string">"billelectro"</span></span>,<span class="hljs-string"><span class="hljs-string">"permission"</span></span>:<span class="hljs-string"><span class="hljs-string">"eosio.code"</span></span>},<span class="hljs-string"><span class="hljs-string">"weight"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}],<span class="hljs-string"><span class="hljs-string">"waits"</span></span>:[]}}' -p electricity</code> </pre> <br><p>  Es wurde ein Fehler ausgegeben: Ungültige Berechtigung.  Hier konnten uns die Mentoren nicht mehr helfen: Sie sagten, dass sie dies selbst nicht getan hätten.  Und wer hat das getan?  Vielleicht nur Dan Larimer.  Wir konnten die Fehlerursache im EOS-Code nicht schnell finden und haben bereits begonnen, alternative Optionen ohne eine Kette von Aufrufen in Betracht zu ziehen.  Es hat wunderbar verhindert, dass sich der Mechanismus zum Aufrufen anderer Verträge in EOS auch vom Äther unterscheidet.  Wenn ein anderer Vertrag angerufen wird, wird dieser Anruf in die Warteschlange gestellt und erst abgeschlossen, nachdem der aktuelle Anruf abgeschlossen wurde.  Es funktioniert nicht, den Vertrag anzurufen und nach dem Anruf die von diesem Vertrag aufgezeichneten Daten zu lesen. </p><br><p>  Schließlich fanden sie später im EOS-Code den Grund für den Fehler beim Festlegen der Rechte für zwei Verträge.  Es stellt sich heraus, dass die Konten in der Liste der Rechte nach Konto sortiert werden sollten: <em>Stellt sicher, dass alle Schlüssel eindeutig und sortiert sind und alle Kontoberechtigungen eindeutig und sortiert sind</em> ( <a href="">Authority.hpp</a> ).  Nachdem die Reihenfolge der Konten geändert wurde, funktionierte die Aktualisierung der Rechte - und unser Vertragssystem begann zu funktionieren. </p><br><h3 id="232-problema-c-funkciy-raboty-s-pamyatyu">  2.3.2.  Das Problem der C-Funktionen mit dem Speicher </h3><br><p>  Es ist lächerlich zu sagen, aber am Ende konnten wir die vorgefertigten Funktionen nicht zum Parsen von Zahlen (!) Verwenden, um die Abrechnungskonfiguration zu lesen.  Nach <code>std::istringstream</code> Funktion <code>std::istringstream</code> , was ziemlich seltsam ist.  Und bei der Verwendung von <code>atof</code> und dergleichen sowie <code>sscanf</code> - <code>env.realloc</code> verschärft.  Aus irgendeinem Grund wurden die genannten Funktionen zum Arbeiten mit dem Speicher der Standard-C-Bibliothek beim Laden des Codes in Nodeos nicht gefunden.  Die C ++ - Funktionen, die mit dem Speicher arbeiten, funktionierten. </p><br><p>  Bei der Ausführung des WebAssembly-Vertrags wird natürlich kein Standardspeicherzuweiser verwendet, sondern eine eigene Sandbox, die unter bestimmten Bedingungen für jede Transaktion bereitgestellt wird.  Auch die Unterstützung für C-Funktionen beim Arbeiten mit Speicher über dieser Sandbox ist seit langem implementiert. Ihre Implementierung erfolgt in <a href="">Standard-EOS-Verträgen</a> .  Wahrscheinlich ist in der Verbindungsphase etwas schief gelaufen. </p><br><p>  Nachdem wir ungefähr eine Stunde lang nach einem Ausweg gesucht hatten, auch mit Hilfe eines der Mentoren, beschlossen wir, nicht fortzufahren und eine Problemumgehung vorzunehmen: Schreiben Sie unseren eigenen Code, der das Problem des Parsens von Zahlen löst.  Der Datenstrom-EOS-Mechanismus passte nicht zu uns: Er erforderte die Fähigkeit, Datenpakete verschiedener Strukturen in einem Feld zu speichern und von Hand zu bilden (genau die Abrechnungskonfigurationen). </p><br><h3 id="233-billing-pokupok">  2.3.3.  Einkaufsabrechnung </h3><br><p>  Im zweiten Wind, der entweder von den Energieingenieuren oder vom frühen Frühstück geöffnet wurde, schrieben sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrechnung</a> für den Einkauf im Laden.  Das allgemeine Arbeitsschema lautet wie folgt: </p><br><ol><li>  Der Lieferant erstellt einen Abrechnungsvertrag und schreibt ihn in seinem Generalvertrag vor. </li><li>  Am Outlet des Geschäfts richtet der Lieferant Frameworks ein, die RFID lesen, mit EOS interagieren und ihre eigenen Konten im Abrechnungsvertrag vorschreiben können. </li><li>  Jedes Produkt im Geschäft ist mit einem RFID-Tag ausgestattet, alle Tags sind im Abrechnungsvertrag eingetragen. </li><li>  Der Käufer bezahlt die Ware durch Scannen seiner RFID und die Ware wird aus dem Abrechnungsvertrag entfernt. </li><li>  Beim Verlassen des Geschäfts lesen die Rahmen zusätzlich RFID-Einkäufe.  Wenn sich die Waren noch im Geschäft befinden, wird die Transaktion nicht bestanden und der Rahmen sollte den Alarm auslösen (ja, Sie können die Transaktion nicht einmal senden, sondern nur die Tabelle lesen). </li></ol><br><p>  Es macht keinen Sinn, sich mit dem Vertragscode selbst zu befassen: Dies ist Standard C ++ 14 mit einigen EOS-spezifischen Konstrukten und Bibliotheken.  Besser gesagt im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EOSIO Wiki</a> und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EOSIO Developer Portal</a> . </p><br><h3 id="234-frontend">  2.3.4.  Frontend </h3><br><p>  Der Frontend-Teil des Projekts wurde mit React implementiert.  Anstelle der üblichen vielen entschieden sich Redux für MobX, was die Entwicklung erheblich beschleunigt und es Ihnen ermöglicht, den globalen Status ohne Kopfschmerzen zu verwalten. </p><br><p>  Die Integrationsphase der Front-Blockchain verlief nicht so reibungslos wie erwartet.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eosjs-</a> Paket wird sehr aktiv finalisiert, gefolgt von der EOS-Brieftasche für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scatter-</a> Browser.  In diesem Haufen verursacht dies oft Probleme.  Und nicht die Tatsache, dass der Code, der gestern funktioniert hat, heute gut funktioniert.  Wir sind auf diesen Rechen getreten (und nicht das erste Mal).  Eine Stunde Versuch und Debugging in einem schläfrigen Zustand - das Problem ist gelöst. </p><br><p>  Betrachten Sie ein vereinfachtes Diagramm der Interaktion der Client-Seite der Anwendung mit eos.  Dazu benötigen Sie die eosjs-Bibliothek und die Scatter-Browser-Erweiterung. </p><br><p>  Wir erinnern Sie daran!  Scatter wird nach eosjs aktiv aktualisiert. Vergessen Sie nicht, die Bibliothek zu aktualisieren. </p><br><p>  Als nächstes ein kurzer Blick auf Lesen und Schreiben.  Es gibt zwei Möglichkeiten, mit intelligenten Verträgen in EOS zu kommunizieren: Senden von Transaktionen (dadurch wird die Blockchain geändert, ohne dass Rückgabewerte angegeben werden) und Lesen von Tabellen (schreibgeschützte Aktion). </p><br><p>  Betrachten Sie den Transaktionssendecode: </p><br><pre> <code class="hljs markdown"> sendTransaction(funcName, data) { return this.scatter .suggestNetwork(this.network) .then(() =&gt; this.scatter.getIdentity({ accounts: [<span class="hljs-string"><span class="hljs-string">this.network</span></span>] })) .then((identity) =&gt; { let accountName = this.getAccountName(identity); // wrap eos instance const eos = this.scatter.eos(this.network, Eos, this.configEosInstance); return eos.transaction(accountName, (contract) =&gt; { contract[<span class="hljs-string"><span class="hljs-string">funcName</span></span>](<span class="hljs-link"><span class="hljs-link">data, { authorization: accountName }</span></span>); }); }); }</code> </pre> <br><p>  Eingabeargumente: Funktionsname und Objekt, seine Werte sind Argumente dieser Funktion.  Dritte Zeile: Wir bestätigen das Netzwerk, über das wir mit EOS interagieren.  Vierte Zeile: Wir erhalten <code>identity</code> , der Parameter ist ein Objekt mit dem <code>accounts</code> (für dieses Netzwerk).  Die Funktion <code>getAccountName</code> gibt das erste Konto aus der empfangenen <code>getAccountName</code> (im <code>identity</code> ) zurück. </p><br><p>  In diesem Beispiel wird Scatter zum Signieren einer Transaktion verwendet.  Scatter ist ein Wrapper über eine Instanz der <code>Eos</code> Klasse.  In Zeile 9 rufen wir die <code>eos</code> Methode mit ihren Parametern auf: </p><br><ol><li>  <code>this.network</code> - ein Objekt mit Netzwerkparametern. </li><li>  <code>Eos</code> ist eine Instanz von eosjs. </li><li>  <code>this.configEosInstance</code> - Ein Objekt mit Parametern für eine Eos-Instanz (siehe Dock-EOSJS). </li></ol><br><p>  Die letzte <code>transaction</code> akzeptiert <code>accountName</code> und <code>callback</code> als Eingabe. Das <code>callback</code> ist ein Vertrag, der sich im <code>accountName</code> .  In <code>callback</code> 'e rufen wir die Methode des empfangenen Vertrags mit dem Objekt auf, seine Schlüssel sind die Argumente der aufgerufenen Methode. </p><br><p>  Betrachten Sie die Methode zum Lesen von Tabellen: </p><br><pre> <code class="hljs kotlin"> readTable(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scatter.eos(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.network, Eos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configEosInstance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eos.getTableRows({ json: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, limit: <span class="hljs-number"><span class="hljs-number">1</span></span>, ...<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, }); }</code> </pre> <br><p>  Hier brauchen wir zum Lesen nur eine <code>eos</code> Instanz. </p><br><p>  Um die Benutzeroberfläche zu entwerfen, haben wir Materialise, Semantic und Ant entfernt und selbst Stile entwickelt.  In den letzten Stunden des Hackathons schien eine Idee die Benutzeroberfläche wiederzubeleben und eine Visualisierung des Prozesses hinzuzufügen.  Markierte die neuen Zeilen der Tabelle für zwei Sekunden in Grün und erhielt einen coolen Effekt a la Stock Quotes.  Die Verbesserung erhöhte die Attraktivität des Projekts erheblich und wurde zur letzten Phase des Aufbaus der Benutzeroberfläche. </p><br><h1 id="3-sborka">  3. Montage </h1><br><p>  Drei Stunden vor Ablauf der Zeit hatten wir einen Raspberry Pi mit dem Mercury-Stromzähler und einem daran angeschlossenen RFID-Lesegerät sowie eine Lichtanzeige.  Der gesamte Tischstrom ging durch den Merkur.  Für jede ausgegebenen 0,3125 Wh / h sowie für jeden „Kauf“ schickte Raspberry Pi Transaktionen an unsere Blockchain, und der Dienstanbieter konnte Benutzer, Sensoren, Abrechnungen verwalten und Verbrauchsstatistiken anzeigen. </p><br><p><img src="https://habrastorage.org/webt/y6/uq/mz/y6uqmz1upvprppiimceoecejewg.jpeg"></p><br><p>  Für eine weitere Stunde beschäftigten wir uns ruhig mit Kontrollen und fügten den letzten Schliff hinzu.  Zwei Stunden vor Ablauf der Zeit haben wir ein vollständiges Produkt mit zwei implementierten Fällen erhalten, das das Konzept vollständig veranschaulicht und in den letzten Minuten sogar keine Commits enthält! </p><br><h1 id="4-demonstraciya">  4. Demonstration </h1><br><p>  Demonstrationen von Projekten (auch bekannt als Stellplätze) bestanden aus zwei Phasen.  In der ersten Phase wurden 69 teilnehmende Teams in vier Gruppen eingeteilt, von denen jede vor zwei Richtern und ohne Zuschauer getrennt gefüttert wurde.  Die Richter gaben Noten (vier Kriterien mit jeweils 5 Punkten) und basierend auf diesen Noten wurden die Top 10 Teams für die zweite Stufe ausgewählt.  Diese Teams hatten die Möglichkeit, ein Projekt auf einer großen Bühne vor dem Publikum und allen acht Richtern zu inszenieren. </p><br><p>  Wir sind in der ersten Gruppe gelandet. Unsere Richter waren der CEO und Präsident (ich frage mich, wie sich diese Positionen unterscheiden) von Everipedia.  Für die Aufführung wurden drei Minuten eingeplant, die vom Timer streng überwacht wurden.  Wir beendeten unsere Inkonsistenz, forderten jedoch auf, die Rede 30 Sekunden vor dem Zeitplan zu beeindrucken.  Die Richter fragten oberflächlich und ziemlich kurz etwas, und die Demonstration war beendet. </p><br><p>  Wir, naive, waren überrascht, dass wir nicht auf die tatsächliche Arbeitsfähigkeit des Produkts und noch mehr auf den Kodex des Richters geachtet haben.  Technische Umsetzungsprobleme interessierten sie nicht im geringsten.  Wir könnten genauso gut die blinkenden Raspberry Pi-Lampen und das Bild auf der Vorderseite zeigen. </p><br><p>  Wir hatten das Gefühl, dass wir bei der Präsentation des Projekts gescheitert sind, weil wir erwartet hatten, mit einer tatsächlichen Lösung, einem Prototyp und nicht nur einer farbenfrohen Beschreibung eines sozial bedeutenden und ehrgeizigen Projekts zu beeindrucken.  Alles wurde wie durch Notizen gespielt: Wir haben das Problem, den Schmerz und unsere Lösung beschrieben, gezeigt, wie es funktioniert, und die Entwicklungspläne des Projekts beschrieben.  Wenn wir im Voraus über die Bewertungsmethoden Bescheid gewusst hätten, hätten wir viel anders gemacht. </p><br><p>  Die Richter aus den vier Streams der ersten Runde reduzierten ihre Punktzahlen und tauschten 15 Minuten nach Ende der Spielfelder ihre Ansichten aus.  Nach der Bekanntgabe der Gewinner begann.  In der Halle herrschte eine nervöse Atmosphäre: Nach dem 26-Stunden-Marathon müde, wollten die Leute gewinnen, es gab viele starke Teams und sie wussten, dass sie den Sieg erringen konnten.  Und das wussten wir - und warteten auf die Ergebnisse. </p><br><p>  Um zu verhindern, dass sich die Zuschauer entspannen, wurden die Ergebnisse in drei Teilen bekannt gegeben.  Die ersten vier Finalisten, dann noch drei, dann noch drei.  Zwischen Ankündigungen und am Ende - Aufführungen.  Wir sind nicht in die Top 10 gekommen und hatten keine Gelegenheit, die große Bühne zu betreten.  Zwei russischsprachige Teams schafften es in die Top Ten, von denen eines schließlich das dritte wurde.  Herzlichen Glückwunsch an die Gewinner, sie haben ihre Preise verdient. </p><br><h1 id="5-zaklyuchenie-i-plany">  5. Schlussfolgerung und Pläne </h1><br><p>    AngelHack    .     ,   .     —  ,  ,      . ,     ,       ,      —   . </p><br><p>  26         IoT-   EOS.         ,   . </p><br><p>    —      UI (  —  -- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smartz</a> ),     .  - ,     blockchain-ready  ,   , —    .  :) :) </p><br><p><img src="https://habrastorage.org/webt/1i/9q/nq/1i9qnqngvpnjizwpepz4n_b4gkc.gif"></p><br><p>   ,    ,         «», «»  . .  5           .   ,         100    ,          .            SensorPay   ! </p><br><p>     : </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Yuvasee</a>  (entrepreneur) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">algs</a>  (hardware &amp; backend developer) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">therealal</a>  (architect, backend developer, devops) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">bolbu</a>  (frontend developer) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">quantum</a>  (blockchain &amp; backend developer) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414803/">https://habr.com/ru/post/de414803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414791/index.html">Seminar "Virtuelle Infrastruktur für Entwickler: Chancen, Anwendungen und Dienste", 28. Juni, St. Petersburg</a></li>
<li><a href="../de414793/index.html">Wie funktionieren Zahlungskanäle und Blitznetzwerke in Bitcoin?</a></li>
<li><a href="../de414797/index.html">Wie wir Open Lines bei Bitrix24 erstellt haben</a></li>
<li><a href="../de414799/index.html">LLTR Teil 0: Automatische Erkennung der Netzwerktopologie und nicht verwaltete Switches. Mission unmöglich?</a></li>
<li><a href="../de414801/index.html">Moscow Vue.js Meetup # 2 bei der Mail.Ru Group</a></li>
<li><a href="../de414805/index.html">Offenes Webinar "Alternative Rekrutierungsmethoden"</a></li>
<li><a href="../de414809/index.html">Swift 4.1: Warum Apple flatMap in compactMap umbenannt hat</a></li>
<li><a href="../de414811/index.html">Integrieren Sie Telegramm und Avaya</a></li>
<li><a href="../de414813/index.html">Erstellen von Vorlagen in der Jetbrains-IDE</a></li>
<li><a href="../de414817/index.html">Cyber-Oma oder wie wir einen Tag gehackt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>