<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº üçÜ üê° Pr√≥prio mapeador ou um pouco sobre ExpressionTrees ‚ö´Ô∏è üñ§ üÜó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje falaremos sobre como escrever seu AutoMapper . Sim, eu realmente gostaria de falar sobre isso, mas n√£o posso. O fato √© que essas solu√ß√µes s√£o mui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pr√≥prio mapeador ou um pouco sobre ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="imagem"><br><br>  Hoje falaremos sobre como escrever seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AutoMapper</a> .  Sim, eu realmente gostaria de falar sobre isso, mas n√£o posso.  O fato √© que essas solu√ß√µes s√£o muito grandes, t√™m um hist√≥rico de tentativa e erro e tamb√©m percorreram um longo caminho at√© o aplicativo.  S√≥ posso entender como isso funciona, dar um ponto de partida para aqueles que gostariam de entender o mecanismo de trabalho dos ‚Äúmapeadores‚Äù.  Voc√™ pode at√© dizer que escreveremos nossa bicicleta. <br><a name="habracut"></a><br><h3>  Isen√ß√£o de responsabilidade </h3><br>  Recordo mais uma vez: escreveremos um mapeador primitivo.  Se voc√™ de repente decidir modific√°-lo e us√°-lo no produto - n√£o fa√ßa isso.  Tome uma solu√ß√£o pronta que conhe√ßa a pilha de problemas nessa √°rea e <i>j√° saiba como</i> resolv√™-los.  Existem v√°rios motivos mais ou menos significativos para escrever e usar o seu mapeador de bicicletas: <br><br><ul><li>  Precisa de alguma personaliza√ß√£o especial. </li><li> Voc√™ precisa de desempenho m√°ximo em suas condi√ß√µes e est√° pronto para encher cones. </li><li>  Voc√™ quer entender como o mapeador funciona. </li><li>  Voc√™ gosta de andar de bicicleta. </li></ul><br><h3>  O que √© chamado a palavra "mapeador"? </h3><br>  Esse √© o subsistema respons√°vel por pegar um objeto e convert√™-lo (copiar seus valores) em outro.  Uma tarefa t√≠pica √© converter um DTO em um objeto da camada de neg√≥cios.  O mapeador mais primitivo "executa" as propriedades da fonte de dados e as compara com as propriedades do tipo de dados que ser√° produzido.  Ap√≥s a correspond√™ncia, os valores s√£o extra√≠dos da fonte e gravados no objeto, que ser√° o resultado da convers√£o.  Em algum lugar ao longo do caminho, provavelmente, ainda ser√° necess√°rio criar esse "resultado". <br><br>  Para o consumidor, o mapeador √© um servi√ßo que fornece a seguinte interface: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Enfatizo: esta √© a interface mais primitiva que, do meu ponto de vista, √© conveniente para explica√ß√£o.  Na realidade, provavelmente estaremos lidando com um mapeador mais espec√≠fico (IMapper &lt;TIn, TOut&gt;) ou com uma fachada mais geral (IMapper), que selecionar√° um mapeador espec√≠fico para os tipos especificados de objetos de entrada e sa√≠da. <br><br><h3>  Implementa√ß√£o ing√™nua </h3><br>  Nota: mesmo a implementa√ß√£o ing√™nua do mapeador requer conhecimentos b√°sicos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reflex√£o</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Express√£o</a> .  Se voc√™ n√£o seguiu os links ou ouviu alguma coisa sobre essas tecnologias - fa√ßa-o, leia-o.  Prometo que o mundo nunca mais ser√° o mesmo. <br><br>  No entanto, estamos escrevendo seu pr√≥prio mapeador.  Para come√ßar, vamos obter todas as propriedades ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PropertyInfo</a> ) do tipo de dados que ser√£o <b>exibidas</b> (daqui em diante vou cham√°-lo de <b>TOut</b> ).  Isso √© bem simples: conhecemos o tipo, pois estamos escrevendo a implementa√ß√£o de uma classe gen√©rica parametrizada com o tipo TOut.  Em seguida, usando uma inst√¢ncia da classe Type, obtemos todas as suas propriedades. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Ao obter propriedades, omito os recursos.  Por exemplo, alguns deles podem estar sem uma fun√ß√£o setter, alguns podem ser marcados como ignorados pelo atributo, outros podem ter acesso especial.  Estamos considerando a op√ß√£o mais simples. <br><br>  N√≥s vamos al√©m.  Seria bom poder criar uma inst√¢ncia do tipo TOut, ou seja, o pr√≥prio objeto no qual "mapeamos" o objeto recebido.  No C #, existem v√°rias maneiras de fazer isso.  Por exemplo, podemos fazer isso: System.Activator.CreateInstance ().  Ou mesmo apenas o novo TOut (), mas para isso voc√™ precisa criar uma restri√ß√£o para o TOut, o que voc√™ n√£o gostaria de fazer na interface generalizada.  No entanto, n√≥s dois sabemos algo sobre ExpressionTrees, o que significa que podemos faz√™-lo assim: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Porque assim?  Como sabemos que uma inst√¢ncia da classe Type pode fornecer informa√ß√µes sobre quais construtores ela possui - isso √© muito conveniente para casos em que decidimos desenvolver nosso mapeador para que passemos quaisquer dados ao construtor.  Al√©m disso, aprendemos um pouco mais sobre o ExpressionTrees, ou seja, eles permitem que a placa crie e compile c√≥digo, que pode ser reutilizado.  Nesse caso, √© uma fun√ß√£o que realmente se parece com () =&gt; new TOut (). <br><br>  Agora voc√™ precisa escrever o m√©todo principal do mapeador, que copiar√° os valores.  Iremos pela maneira mais simples: percorrer as propriedades do objeto que nos chegou na entrada e procurar as propriedades com o mesmo nome entre as propriedades do objeto de sa√≠da.  Se encontrado - copie, se n√£o - siga em frente. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Assim, formamos completamente a classe <a href="">BasicMapper</a> .  Voc√™ pode se familiarizar com os testes dele <a href="">aqui</a> .  Observe que a fonte pode ser um objeto de qualquer tipo espec√≠fico ou um objeto an√¥nimo. <br><br><h3>  Desempenho e boxe </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A reflex√£o √©</a> √≥tima, mas lenta.  Al√©m disso, seu uso frequente aumenta o tr√°fego de mem√≥ria, o que significa que ele carrega o GC, o que significa que diminui ainda mais o aplicativo.  Por exemplo, usamos apenas os m√©todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PropertyInfo.SetValue</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PropertyInfo.GetValue</a> .  O m√©todo GetValue retorna um objeto no qual um determinado valor √© quebrado (boxe).  Isso significa que recebemos uma aloca√ß√£o do zero. <br><br>  Os mapeadores geralmente est√£o localizados onde voc√™ precisa transformar um objeto em outro ... N√£o, n√£o um, mas muitos objetos.  Por exemplo, quando pegamos algo do banco de dados.  Neste local, eu gostaria de ver o desempenho normal e n√£o perder mem√≥ria em uma opera√ß√£o elementar. <br><br>  O que podemos fazer?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ExpressionTrees</a> nos ajudar√° novamente.  O fato √© que o .NET permite criar e compilar c√≥digo "on the fly": n√≥s o descrevemos na representa√ß√£o do objeto, dizemos o que e onde vamos us√°-lo ... e compilamos.  Quase nenhuma m√°gica. <br><br><h3>  Mapeador compilado </h3><br>  De fato, tudo √© relativamente simples: j√° fizemos novas com Expression.New (ConstructorInfo).  Voc√™ provavelmente notou que o m√©todo New est√°tico √© chamado exatamente o mesmo que o operador.  O fato √© que quase toda a sintaxe C # √© refletida na forma de m√©todos est√°ticos da classe Expression.  Se algo estiver faltando, significa que voc√™ est√° procurando o chamado  "A√ß√∫car sint√°tico". <br><br>  Aqui est√£o algumas opera√ß√µes que usaremos em nosso mapeador: <br><br><ul><li>  Declara√ß√£o de vari√°vel - Expression.Variable (Type, string).  O argumento Type diz que tipo de vari√°vel ser√° criada e string √© o nome da vari√°vel. </li><li>  Atribui√ß√£o - Expression.Assign (Express√£o, Express√£o).  O primeiro argumento √© o que atribu√≠mos, e o segundo argumento √© o que atribu√≠mos. </li><li>  O acesso √† propriedade de um objeto √© Expression.Property (Expression, PropertyInfo).  Expression √© o propriet√°rio da propriedade e PropertyInfo √© a representa√ß√£o do objeto da propriedade obtida por meio de Reflection. </li></ul><br>  Com esse conhecimento, podemos criar vari√°veis, acessar propriedades de objetos e atribuir valores a propriedades de objetos.  Provavelmente, tamb√©m entendemos que o ExpressionTree precisa ser compilado em um delegado no formato <b>Func &lt;object, TOut&gt;</b> .  O plano √© este: obtemos uma vari√°vel que cont√©m os dados de entrada, criamos uma inst√¢ncia do tipo TOut e criamos express√µes que atribuem uma propriedade a outra. <br><br>  Infelizmente, o c√≥digo n√£o √© muito compacto, ent√£o sugiro que voc√™ d√™ uma olhada na implementa√ß√£o do <a href="">CompiledMapper</a> imediatamente.  Eu trouxe aqui apenas pontos-chave. <br><br>  Primeiro, criamos uma representa√ß√£o de objeto do par√¢metro de nossa fun√ß√£o.  Como ele recebe um objeto como entrada, o objeto ser√° um par√¢metro. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Em seguida, criamos duas vari√°veis ‚Äã‚Äãe uma lista de Express√µes na qual adicionaremos sequencialmente express√µes de atribui√ß√£o.  A ordem √© importante, porque √© assim que os comandos ser√£o executados quando chamamos o m√©todo compilado.  Por exemplo, n√£o podemos atribuir um valor a uma vari√°vel que ainda n√£o foi declarada. <br><br>  Al√©m disso, da mesma maneira que no caso de implementa√ß√£o ing√™nua, examinamos a lista de propriedades de tipo e tentamos combin√°-las por nome.  No entanto, em vez de atribuir valores imediatamente, criamos express√µes para extrair valores e atribuir valores para cada propriedade associada. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Um ponto importante: depois de termos criado todas as opera√ß√µes de atribui√ß√£o, precisamos retornar o resultado da fun√ß√£o.  Para fazer isso, a √∫ltima express√£o na lista deve ser Expression, contendo a inst√¢ncia da classe que criamos.  Deixei um coment√°rio ao lado desta linha.  Por que o comportamento correspondente √† palavra-chave return no ExpressionTree se parece com isso?  Receio que este seja um problema separado.  Agora eu sugiro que seja f√°cil de lembrar. <br><br>  Bem, no final, temos que compilar todas as express√µes que constru√≠mos.  Em que estamos interessados ‚Äã‚Äãaqui?  A vari√°vel body cont√©m o "corpo" da fun√ß√£o.  ‚ÄúFun√ß√µes normais‚Äù t√™m um corpo, certo?  Bem, que colocamos entre chaves.  Ent√£o, Expression.Block √© exatamente isso.  Como os chavetas tamb√©m s√£o um escopo, precisamos passar as vari√°veis ‚Äã‚Äãque ser√£o usadas l√° - no nosso caso, sourceInstance e outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  Na sa√≠da, obtemos Func &lt;object, TOut&gt;, ou seja,  uma fun√ß√£o que pode converter dados de um objeto para outro.  Por que essas dificuldades, voc√™ pergunta?  Lembro que, em primeiro lugar, quer√≠amos evitar o boxe ao copiar valores ValueType e, em segundo lugar, quer√≠amos abandonar os m√©todos PropertyInfo.GetValue e PropertyInfo.SetValue, porque eles s√£o um pouco lentos. <br><br>  Por que n√£o boxe?  Como o ExpressionTree compilado √© uma IL real e, para o tempo de execu√ß√£o, ele se parece com (quase) com o seu c√≥digo.  Por que o "mapeador compilado" √© mais r√°pido?  Novamente: porque √© simplesmente IL.  A prop√≥sito, podemos confirmar facilmente a velocidade usando a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BenchmarkDotNet</a> , e a pr√≥pria refer√™ncia pode ser visualizada <a href="">aqui</a> . <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Ratio </th><th>  Alocado </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1.291,6 us </td><td>  3.3173 us </td><td>  3.1030 nos </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11.987,0 n√≥s </td><td>  33.8389 nos </td><td>  28.2570 us </td><td>  9,28 </td><td>  3437.5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341.3 us </td><td>  2.8230 n√≥s </td><td>  2.6407 us </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  Na coluna Ratio, "CompiledMapper" (CompiledMapper) mostrou um resultado muito bom, mesmo comparado ao AutoMapper (√© a linha de base, ou seja, 1).  No entanto, n√£o vamos nos alegrar: o AutoMapper possui recursos significativamente maiores em compara√ß√£o com nossa bicicleta.  Com esta placa, eu s√≥ queria mostrar que o ExpressionTrees √© muito mais r√°pido que a "abordagem cl√°ssica de reflex√£o". <br><br><h3>  Sum√°rio </h3><br>  Espero ter conseguido mostrar que escrever o seu mapeador √© bastante simples.  Reflection e ExpressionTrees s√£o ferramentas muito poderosas que os desenvolvedores usam para resolver muitas tarefas diferentes.  Inje√ß√£o de depend√™ncia, serializa√ß√£o / desserializa√ß√£o, reposit√≥rios CRUD, cria√ß√£o de consultas SQL, usando outras linguagens como scripts para aplicativos .NET - tudo isso √© feito usando Reflection, Reflection.Emit e ExpressionTrees. <br><br>  E o mapper?  O Mapper √© um √≥timo exemplo em que voc√™ pode aprender tudo isso. <br><br>  PS: Se voc√™ quiser um pouco mais de ExpressionTrees, sugiro ler sobre como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fazer o seu conversor JSON</a> usando essa tecnologia. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463961/">https://habr.com/ru/post/pt463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463943/index.html">As desventuras do unic√≥rnio preto</a></li>
<li><a href="../pt463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../pt463953/index.html">Implementando o padr√£o de design de comando no Unity</a></li>
<li><a href="../pt463955/index.html">Como desenvolver um conceito para alterar a plataforma IP? Instru√ß√µes de uso</a></li>
<li><a href="../pt463957/index.html">Como implantar uma lista de entrevistas vinculada individualmente</a></li>
<li><a href="../pt463963/index.html">Reconhecimento facial em um canteiro de obras</a></li>
<li><a href="../pt463965/index.html">Aplica√ß√£o tipogr√°fica no LaTeX</a></li>
<li><a href="../pt463969/index.html">Or√ßamento familiar do telegrama</a></li>
<li><a href="../pt463971/index.html">Notas do Pentester: Casos de Ca√ßa</a></li>
<li><a href="../pt463975/index.html">Ambiente moderno para reagir a aplicativos nativos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>