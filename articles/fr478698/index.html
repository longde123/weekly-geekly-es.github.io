<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↔️ 👩🏻‍🤝‍👨🏽 💶 Nous réalisons un plan de terrain interactif en 15 minutes 👎🏼 ✊ 🛌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sur le grille-pain, ils demandent souvent comment créer un diagramme interactif d'une maison, un plan de sa structure interne, la possibilité de sélec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous réalisons un plan de terrain interactif en 15 minutes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478698/"><p><img src="https://habrastorage.org/webt/n0/jb/-9/n0jb-9sfsmw2ewd-etwnl04ayvc.jpeg"></p><br><p> Sur le grille-pain, ils demandent souvent comment créer un diagramme interactif d'une maison, un plan de sa structure interne, la possibilité de sélectionner des étages ou des appartements avec des informations à leur sujet, d'afficher des informations sur les détails d'un produit particulier lorsque vous les survolez sur une photo, etc.  Il ne s'agit pas d'un modèle en trois dimensions, mais d'une image avec la possibilité de mettre en évidence certains détails.  Toutes ces tâches sont similaires et résolues assez simplement, mais néanmoins des questions continuent de se poser, alors aujourd'hui nous allons voir comment ces choses sont faites en utilisant SVG, un éditeur graphique et une pincée de javascript. </p><a name="habracut"></a><br><p>  Le choix de SVG est dû au fait que c'est l'option la plus simple pour le développement et le débogage.  J'ai rencontré des gens qui ont conseillé que tout cela soit fait sur toile, mais il est beaucoup plus difficile de comprendre ce qui se passe, et les coordonnées de tous les points sur les courbes doivent être calculées à l'avance d'une manière ou d'une autre, mais ici j'ai ouvert les outils du développeur et voir immédiatement toute la structure, tous les objets, avec lequel il y a interaction, et tout le reste peut être cliqué avec une souris dans une interface conviviale.  Les performances entre la toile 2D habituelle et SVG ne différeront guère.  WebGL peut donner un certain bonus à cet égard, mais le calendrier de développement augmentera considérablement, sans parler d'un soutien supplémentaire, qui ne correspond pas toujours au budget.  Je dirais même «ne va jamais». </p><br><p>  Dans ce didacticiel, nous allons faire quelque chose comme un widget pour un site fictif pour louer des maisons privées dans une certaine zone, mais il est clair que les principes de création de ces choses en question s'appliquent à n'importe quel sujet. </p><br><h2 id="nachinaem-nachinat">  Pour commencer </h2><br><p>  Je vais tout montrer avec <a href="https://inkscape.org/">Inkscape</a> comme exemple, mais toutes les mêmes actions peuvent être effectuées dans n'importe quel autre éditeur utilisant des fonctions similaires. </p><br><p>  Pour fonctionner, nous avons besoin de deux boîtes de dialogue principales: </p><br><ul><li>  Éditeur XML (Ctrl + Maj + X ou une icône avec des crochets angulaires) - pour afficher la structure du document sous forme de balisage et modifier des éléments individuels. </li><li>  Remplissage et contour (Ctrl + Maj + F ou l'icône avec un pinceau dans le cadre) - principalement pour remplir les contours. </li></ul><br><p>  Lancez-les immédiatement et procédez à la création du document. </p><br><blockquote>  Si vous les avez accidentellement glissés dans une fenêtre distincte, vous pouvez cliquer sous le cadre supérieur de cette fenêtre (là où il n'y a rien) et les faire glisser vers la fenêtre principale.  Ce n'est pas entièrement intuitif, mais plutôt pratique. </blockquote><p>  Ouvrez une photo avec vue sur la région.  Nous pouvons choisir d'insérer l'image elle-même sous la forme d'une chaîne base64 ou d'un lien externe.  Puisqu'il est grand, sélectionnez le lien.  Ensuite, nous changerons le chemin vers l'image avec nos mains lors de l'introduction de tout dans les pages du site.  Un document SVG est créé dans lequel la photo sera intégrée via la balise d'image. </p><br><blockquote>  Pour les images raster incorporées dans SVG, incorporées dans HTML, il sera possible d'utiliser le chargement différé, ainsi que pour les images ordinaires sur les pages.  Dans cet exemple, nous ne nous attarderons pas sur de telles optimisations, mais ne les oubliez pas dans les travaux pratiques. </blockquote><p>  Au stade actuel, nous voyons devant nous quelque chose comme ceci: </p><br><p><img src="https://habrastorage.org/webt/nf/1v/ak/nf1vak7y46k_uto-ov-85ifimrc.jpeg"></p><br><p>  Créez maintenant un nouveau calque (Ctrl + Maj + N ou Menu&gt; Calque&gt; Ajouter un calque).  Dans l'éditeur XML, nous voyons que l'élément g normal est apparu.  Bien que nous ne soyons pas allés loin, nous pouvons lui donner une classe, que nous utiliserons plus tard dans les scripts. </p><br><blockquote>  Ne comptez pas sur id.  Plus l'interface est complexe, plus il est facile de les faire se répéter et d'obtenir des bugs étranges.  Et dans notre tâche, ils n'ont toujours aucun avantage.  Les classes ou les attributs de données sont donc notre choix. </blockquote><p>  Si vous regardez de près la structure du document dans l'éditeur XML, vous remarquerez qu'il y a beaucoup de superflu.  Tout éditeur de graphiques vectoriels plus ou moins complexe ajoutera quelque chose de propre aux documents.  Pour supprimer tout cela avec vos mains est une tâche longue et ingrate, l'éditeur ajoutera constamment quelque chose à nouveau.  Le nettoyage de SVG des ordures n'est donc effectué qu'à la fin du travail.  Et de préférence sous une forme automatisée, car il existe des options toutes faites, le même <a href="https://github.com/svg/svgo">svgo</a> par exemple. </p><br><p>  Trouvez un outil appelé Dessiner des courbes de Bézier et des lignes droites (Maj + F6).  Avec lui, nous allons dessiner des contours fermés autour des objets.  Dans notre tâche, nous devons décrire tous les bâtiments.  Par exemple, nous nous limitons à six, mais en conditions réelles, il serait utile de pré-allouer du temps afin de définir avec précision tous les objets nécessaires.  Bien qu'il arrive souvent qu'il existe de nombreuses entités similaires, les mêmes étages d'un bâtiment peuvent être absolument identiques.  Dans de tels cas, vous pouvez accélérer un peu et copier-coller les courbes. </p><br><p>  Après avoir encerclé les bâtiments nécessaires, nous revenons à l'éditeur XML, ajoutons des classes ou, très probablement, ce sera encore plus pratique, des attributs de données avec des index pour eux (c'est possible avec des adresses, mais comme nous avons une zone fictive, il n'y a que index) et déplacez tout vers le calque créé précédemment pour que tout soit «disposé sur des étagères».  Et l'image, soit dit en passant, sera également utile pour s'y déplacer, afin que tout soit au même endroit, mais ce sont des bagatelles. </p><br><p>  Maintenant, après avoir choisi un chemin - une courbe autour du bâtiment, vous pouvez tous les sélectionner avec Ctrl + A ou Menu&gt; Édition&gt; Tout sélectionner et éditer en même temps.  Vous devez tous les peindre dans la fenêtre Remplissage et contour, et en même temps, supprimer là le trait supplémentaire.  Eh bien, ou ajoutez-le si vous en avez besoin pour des raisons de conception. </p><br><p><img src="https://habrastorage.org/webt/du/qi/7d/duqi7d2_rtovsgoo9osa-vo25-w.jpeg"></p><br><blockquote>  Il est logique de peindre tous les contours avec une certaine couleur avec une valeur d'opacité minimale pour eux, même si cela n'est pas nécessaire en termes de conception.  Le fait est que les navigateurs «intelligents» croient que vous ne pouvez pas cliquer sur un chemin vide, mais sur un chemin inondé - vous pouvez, même si personne ne voit ce remplissage. </blockquote><p>  Dans notre exemple, nous allons laisser une petite surbrillance en blanc pour mieux voir avec quels bâtiments nous travaillons, tout enregistrer et passer en douceur au navigateur et à l'éditeur de code plus familier. </p><br><h2 id="bazovyy-primer">  Exemple de base </h2><br><p>  Créons une page html vide, collez le SVG résultant directement dedans et ajoutons du CSS pour que rien ne sorte de l'écran.  Il n'y a rien à commenter. </p><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.map</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">90%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">max-width</span></span>: <span class="hljs-number"><span class="hljs-number">1300px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">2rem</span></span> auto; <span class="hljs-attribute"><span class="hljs-attribute">border</span></span>: <span class="hljs-number"><span class="hljs-number">1rem</span></span> solid <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">1rem</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">box-shadow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> .<span class="hljs-number"><span class="hljs-number">5rem</span></span> <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(0, 0, 0, .3); } <span class="hljs-selector-class"><span class="hljs-selector-class">.map</span></span> &gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">svg</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: auto; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: .<span class="hljs-number"><span class="hljs-number">5rem</span></span>; }</code> </pre> <br><p>  Nous rappelons que nous avons ajouté des classes aux bâtiments et les utilisons pour que CSS soit plus ou moins structuré. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.building</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transition</span></span>: opacity .<span class="hljs-number"><span class="hljs-number">3s</span></span> ease-in-out; } <span class="hljs-selector-class"><span class="hljs-selector-class">.building</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">cursor</span></span>: pointer; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.building</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.-available</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">fill</span></span>: <span class="hljs-number"><span class="hljs-number">#0f0</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.building</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.-reserved</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">fill</span></span>: <span class="hljs-number"><span class="hljs-number">#f00</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.building</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.-service</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">fill</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre> <br><p>  Puisque nous avons défini des styles en ligne dans Inkscape, nous devons les interrompre en CSS.  Serait-il plus pratique de tout faire en CSS?  Oui et non.  Cela dépend de la situation.  Parfois, il n'y a pas de choix.  Par exemple, si un designer a dessiné beaucoup de tout en couleurs et envelopper tout en CSS et le gonfler à l'impossibilité de ne pas en quelque sorte comme il faut.  Dans cet exemple, j'utilise l'option «peu pratique» pour montrer qu'elle n'est pas particulièrement effrayante dans le contexte du problème résolu. </p><br><p><img src="https://habrastorage.org/webt/t0/r4/nr/t0r4nr0bqr-zyblc_srzafnogis.jpeg"></p><br><p>  Supposons que nous ayons reçu de nouvelles données sur les maisons et ajoutez-leur différentes classes, en fonction de leur statut actuel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">id_0</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'service'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_2</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'reserved'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_3</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_4</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_5</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'reserved'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: { <span class="hljs-string"><span class="hljs-string">'available'</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'reserved'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'service'</span></span>: <span class="hljs-string"><span class="hljs-string">'  1-2 '</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buildings = map.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.building'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (building <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = building.getAttribute(<span class="hljs-string"><span class="hljs-string">'data-building-id'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> status = data[<span class="hljs-string"><span class="hljs-string">`id_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">`</span></span>].status; building.classList.add(<span class="hljs-string"><span class="hljs-string">`-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">`</span></span>); }</code> </pre> <br><p>  Nous obtenons quelque chose comme ça: </p><br><p><img src="https://habrastorage.org/webt/zm/n6/tx/zmn6txixk7isjsgy9hdkukjjyc0.jpeg"></p><br><p>  Quelque chose de similaire à ce dont nous avons besoin est déjà visible.  À ce stade, nous avons mis en évidence des objets sur le terrain qui répondent au survol de la souris.  Et il n’est pas difficile d’ajouter pour eux une réponse à un clic de souris via l’addEventListener standard. </p><br><h2 id="leader-line">  Ligne de leader </h2><br><p>  Souvent, il s'agit de créer des lignes qui relieront les objets sur la carte et certains éléments de la page avec des informations supplémentaires, ainsi que de faire des info-bulles minimales lors du survol de ces mêmes objets.  Pour résoudre ces problèmes, la mini-bibliothèque de <a href="https://github.com/anseki/leader-line">ligne de</a> repère est très bien adaptée, ce qui crée des flèches vectorielles pour tous les goûts et toutes les couleurs. </p><br><p>  Ajoutons les prix des info-bulles aux données et dessinons ces lignes. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">id_0</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'3000'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'service'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'3000'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_2</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'2000'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'reserved'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_3</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'5000'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_4</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'2500'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'available'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">id_5</span></span>: { <span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-string"><span class="hljs-string">'2500'</span></span>, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'reserved'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: { <span class="hljs-string"><span class="hljs-string">'available'</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'reserved'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'service'</span></span>: <span class="hljs-string"><span class="hljs-string">'   (1-2 )'</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buildings = map.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.building'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> info = map.querySelector(<span class="hljs-string"><span class="hljs-string">'.info'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (building <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = building.getAttribute(<span class="hljs-string"><span class="hljs-string">'data-building-id'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> status = data[<span class="hljs-string"><span class="hljs-string">`id_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">`</span></span>].status; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> price = data[<span class="hljs-string"><span class="hljs-string">`id_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">`</span></span>].price; building.classList.add(<span class="hljs-string"><span class="hljs-string">`-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LeaderLine( LeaderLine.pointAnchor(building, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span> }), LeaderLine.pointAnchor(info, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>, <span class="hljs-attr"><span class="hljs-attr">startPlug</span></span>: <span class="hljs-string"><span class="hljs-string">'arrow1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">endPlug</span></span>: <span class="hljs-string"><span class="hljs-string">'behind'</span></span>, <span class="hljs-attr"><span class="hljs-attr">endSocket</span></span>: <span class="hljs-string"><span class="hljs-string">'top'</span></span> } ); lines.push(line); }</code> </pre> <br><p>  Comme vous pouvez le voir, rien de compliqué ne se passe.  La ligne a des «points d'attache» aux éléments.  Les coordonnées de ces points par rapport aux éléments sont généralement pratiques à déterminer en pourcentage.  En général, il existe de nombreuses options différentes, il n'est pas logique de répertorier et de mémoriser, je vous recommande donc de parcourir la documentation.  L'une de ces options - startLabel - nous sera nécessaire pour créer une petite info-bulle avec un prix. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LeaderLine( LeaderLine.pointAnchor(building, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span> }), LeaderLine.pointAnchor(info, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'50%'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">startLabel</span></span>: LeaderLine.captionLabel(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${price}</span></span></span><span class="hljs-string">/`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Rubik Mono One'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-attr"><span class="hljs-attr">offset</span></span>: [<span class="hljs-number"><span class="hljs-number">-30</span></span>, <span class="hljs-number"><span class="hljs-number">-50</span></span>], <span class="hljs-attr"><span class="hljs-attr">outlineColor</span></span>: <span class="hljs-string"><span class="hljs-string">'#555'</span></span> }), <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>, <span class="hljs-attr"><span class="hljs-attr">startPlug</span></span>: <span class="hljs-string"><span class="hljs-string">'arrow1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">endPlug</span></span>: <span class="hljs-string"><span class="hljs-string">'behind'</span></span>, <span class="hljs-attr"><span class="hljs-attr">endSocket</span></span>: <span class="hljs-string"><span class="hljs-string">'top'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hide</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } );</code> </pre> <br><blockquote>  Personne ne se soucie de dessiner toutes les astuces dans un éditeur graphique.  S'ils sont censés avoir un contenu cohérent, cela peut même être pratique.  Surtout s'il y a un désir de leur demander différentes positions pour différents objets. </blockquote><p>  Nous pouvons également ajouter l'option masquer afin que toutes les lignes ne soient pas affichées comme un balai.  Nous leur montrerons un à la fois lorsque vous survolerez les bâtiments auxquels ils correspondent: </p><br><pre> <code class="javascript hljs">building.addEventListener(<span class="hljs-string"><span class="hljs-string">'mouseover'</span></span>, () =&gt; { line.show(); }); building.addEventListener(<span class="hljs-string"><span class="hljs-string">'mouseout'</span></span>, () =&gt; { line.hide(); });</code> </pre> <br><p>  Ici, vous pouvez afficher des informations supplémentaires (dans notre cas, simplement l'état actuel de l'objet) à la place des informations.  Il s'avérera presque ce qui est nécessaire: </p><br><p><img src="https://habrastorage.org/webt/dj/6q/-3/dj6q-39gunb8vxq35elxb0bwse0.jpeg"></p><br><p>  De telles choses sont rarement conçues pour les appareils mobiles, mais il convient de se rappeler qu'elles sont souvent affichées en plein écran sur le bureau, et même avec certains panneaux sur le côté pour des informations supplémentaires et vous devez tout étirer magnifiquement.  Quelque chose comme ça par exemple: </p><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">svg</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; }</code> </pre> <br><p>  Dans ce cas, les proportions de l'élément SVG ne coïncideront certainement pas avec les proportions de l'image à l'intérieur.  Que faire? </p><br><h2 id="nesovpadayuschie-proporcii">  Des proportions inégales </h2><br><p>  La première chose qui me vient à l'esprit est la propriété <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit: cover</a> de CSS.  Mais il y a un point: il n'est absolument pas capable de fonctionner avec SVG.  Et même si cela fonctionnait, les maisons le long des bords du plan pourraient sortir des bords du schéma et devenir complètement inaccessibles.  Donc, ici, vous devez aller un peu plus compliqué. </p><br><p>  Première étape.  SVG a un attribut <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio">preserveAspectRatio</a> , qui est quelque peu similaire à la propriété fit-fit (pas tout à fait, bien sûr, mais ...).  En <code>preserveAspectRatio="xMinYMin slice"</code> pour l'élément SVG principal de notre plan, nous obtenons un circuit étendu sans vides sur les bords et sans distorsion. </p><br><p>  Deuxième étape  Vous devez faire un glisser-déposer avec la souris.  Techniquement, nous avons encore une telle opportunité.  Ici, la tâche est plus compliquée, surtout pour les débutants.  En théorie, nous avons des événements standard pour la souris et l'écran tactile qui peuvent être traités et obtenir la valeur de la quantité de déplacement de la carte.  Mais dans la pratique, vous pouvez vous y retrouver très longtemps.  <a href="https://hammerjs.github.io/">Hammer.js</a> viendra à la <a href="https://hammerjs.github.io/">rescousse</a> - une autre petite bibliothèque qui prend toute la cuisine interne sur elle-même et fournit une interface simple pour travailler par glisser-déposer, glisser, etc. </p><br><p>  Nous devons déplacer le calque avec les bâtiments et l'image dans toutes les directions.  Rendez-le facile: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buildingsLayer = map.querySelector(<span class="hljs-string"><span class="hljs-string">'.buildings_layer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hammertime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hammer(buildingsLayer); hammertime.get(<span class="hljs-string"><span class="hljs-string">'pan'</span></span>).set({ <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: Hammer.DIRECTION_ALL });</code> </pre> <br><p>  Par défaut, hammer.js inclut également la reconnaissance des svaypas, mais nous n'en avons pas besoin sur la carte, alors désactivez-les tout de suite afin de ne pas nous tromper: </p><br><pre> <code class="javascript hljs">hammertime.get(<span class="hljs-string"><span class="hljs-string">'swipe'</span></span>).set({ <span class="hljs-attr"><span class="hljs-attr">enable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre> <br><p>  Vous devez maintenant comprendre en quelque sorte exactement ce que vous devez publier pour déplacer la carte uniquement vers ses bords, mais pas plus loin.  Avec une simple représentation de deux rectangles dans notre tête, nous comprenons que pour cela, nous devons trouver l'indentation de la couche avec les bâtiments de l'élément parent (SVG dans notre cas) des quatre côtés.  GetBoundingClientRect vient à la rescousse: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> layer = buildingsLayer.getBoundingClientRect(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parent = svg.getBoundingClientRect(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offsets = { <span class="hljs-attr"><span class="hljs-attr">top</span></span>: layer.top - parent.top, <span class="hljs-attr"><span class="hljs-attr">bottom</span></span>: layer.bottom - parent.bottom, <span class="hljs-attr"><span class="hljs-attr">right</span></span>: layer.right - parent.right, <span class="hljs-attr"><span class="hljs-attr">left</span></span>: layer.left - parent.left, };</code> </pre> <br><p>  Et pourquoi n'avons-nous toujours pas de façon plus civilisée (et stable) de procéder?  Tirer getBoundingClientRect à chaque fois est très mauvais en termes de performances, mais le choix n'est pas très riche, et il est presque impossible de remarquer une inhibition, donc nous ne proposerons pas d'optimisations prématurées où tout fonctionne très bien.  D'une manière ou d'une autre, cela nous permet de vérifier la position de la couche par rapport aux bâtiments et de tout déplacer uniquement si cela a du sens: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translateX = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translateY = <span class="hljs-number"><span class="hljs-number">0</span></span>; hammertime.on(<span class="hljs-string"><span class="hljs-string">'pan'</span></span>, (e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> layer = buildingsLayer.getBoundingClientRect(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parent = svg.getBoundingClientRect(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offsets = { <span class="hljs-attr"><span class="hljs-attr">top</span></span>: layer.top - parent.top, <span class="hljs-attr"><span class="hljs-attr">bottom</span></span>: layer.bottom - parent.bottom, <span class="hljs-attr"><span class="hljs-attr">right</span></span>: layer.right - parent.right, <span class="hljs-attr"><span class="hljs-attr">left</span></span>: layer.left - parent.left, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> speedX = e.velocityX * <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> speedY = e.velocityY * <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (speedX &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; offsets.left &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } else if (speedX &lt; 0 &amp;&amp; offsets.right &gt; 0) { //  } if (speedY &gt; 0 &amp;&amp; offsets.top &lt; 0) { //  } else if (speedY &lt; 0 &amp;&amp; offsets.bottom &gt; 0) { //   } buildingsLayer.setAttribute('transform', `translate(${translateX} ${translateY})`); });</span></span></code> </pre> <br><p>  Sur les bords, il vaut généralement la peine de ralentir pour éviter les arrêts brusques ou les secousses.  Ainsi, tout va et vient en quelque chose comme ça: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (speedX &lt; -offsets.left) { translateX += speedX; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { translateX += -offsets.left * speedX / <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><p>  Il existe de nombreuses options de ralentissement.  Celui-ci est le plus simple.  Et oui, ce n’est pas très beau, mais c’est stupide comme un bouchon et clair.  Les coefficients de ces exemples sont généralement sélectionnés à l'œil nu, en fonction du comportement souhaité de la carte. </p><br><p>  Si vous ouvrez un navigateur et jouez avec la taille de la fenêtre dans les outils du développeur, vous pouvez constater que quelque chose s'est mal passé ... </p><br><h2 id="nechistye-sily">  Forces impures </h2><br><p>  Sur les appareils de bureau, tout fonctionne, mais sur mobile, la magie opère, à savoir qu'au lieu de déplacer la carte, l'élément corporel se déplace.  Oooooooo!  Seul le casting n'y suffit pas.  Bien que ce soit correct, cela se produit car quelque chose déborde quelque part et certains écrasements n'ont pas été définis comme débordement: caché.  Mais dans notre cas, il peut arriver que rien ne bouge du tout. </p><br><blockquote>  Une énigme pour les typographes verts: il y a l'élément g, à l'intérieur de l'élément svg, à l'intérieur de l'élément div, à l'intérieur de l'élément body, à l'intérieur de l'élément html.  Doctype naturellement html.  Si vous y ajoutez transform: translate (...) pour faire glisser l'élément g, alors sur l'ordinateur portable il se déplacera, comme prévu, mais sur le téléphone il ne bougera même pas.  Il n'y a aucune erreur dans la console.  Mais il y a certainement un bug.  Le navigateur est le dernier Chrome à la fois là et là.  La question est pourquoi? </blockquote><p>  <em>Je vous suggère de penser à environ 10 minutes sans Google avant de regarder la réponse.</em> </p><br><p><img src="https://habrastorage.org/webt/th/ec/yg/thecygjfpw8dtmjtlwtc1ds5x8m.png"></p><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text"><p>  Haha  Je t'ai trompé.  Plus précisément, non.  J'ai décrit ce que nous observerions avec des tests manuels.  Mais en réalité, tout fonctionne comme il se doit.  Ce n'est pas un bug, mais une fonctionnalité liée à la propriété CSS de <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action">touch-action</a> .  Dans le cadre de notre tâche (tout d'un coup!) Il se révèle qu'elle existe, et, en plus, a une certaine valeur qui rompt toute la logique d'interaction avec la carte.  Nous traitons donc très grossièrement avec lui: </p><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">svg</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">touch-action</span></span>: none <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre> </div></div><br><p>  Mais revenons à nos moutons et regardons le résultat (il vaut mieux, bien sûr, ouvrir dans un onglet séparé): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/ZEYYjZL" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  J'ai décidé de ne personnaliser le code pour aucun des frameworks à la mode, afin qu'il reste sous la forme d'un vide neutre sans forme, à partir duquel vous pouvez vous appuyer lors de la création de vos composants. </p><br><h2 id="chto-v-itoge">  Quel est le résultat? </h2><br><p>  Après avoir passé pas mal de temps, nous avons fait un plan sur lequel il y a une image raster, mettant en évidence ses divers détails, connectant des objets sans rapport avec des flèches et des réactions à la souris.  J'espère avoir réussi à transmettre l'idée de base de la façon dont tout cela se fait dans la version «budget».  Comme nous l'avons noté au début de l'article, il existe de nombreuses applications différentes, y compris celles qui ne sont pas liées à une sorte de sites de conception confus (bien que cette approche soit utilisée très souvent sur eux).  Eh bien, si vous cherchez quelque chose à lire sur des choses interactives, mais déjà en trois dimensions, je laisse un lien vers un article sur le sujet - <a href="https://habr.com/ru/post/433876/">Présentations de produits en trois dimensions sur Three.js pour les plus petits</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478698/">https://habr.com/ru/post/fr478698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478688/index.html">Comment c'était d'étudier la science des données en 2019</a></li>
<li><a href="../fr478690/index.html">Assemblage et déploiement dynamiques d'images Docker avec werf en utilisant l'exemple de site de documentation versionnée</a></li>
<li><a href="../fr478692/index.html">Prise en charge de Java 8 sur Android</a></li>
<li><a href="../fr478694/index.html">Comme nous vous recommandons les derniers catalogues du cinéma en ligne ivi (+ code Python)</a></li>
<li><a href="../fr478696/index.html">Comment j'ai visité Urban Tech 2019. Rapport d'événement</a></li>
<li><a href="../fr478702/index.html">Astuces de traitement métrique dans Kapacitor</a></li>
<li><a href="../fr478704/index.html">Que faire si les envois ont déjà atteint le spam: 5 étapes pratiques</a></li>
<li><a href="../fr478706/index.html">Architecte à forte charge. Nouveau cours d'OTUS</a></li>
<li><a href="../fr478708/index.html">Comment les randomiseurs vous permettent de donner un nouveau souffle aux anciens jeux</a></li>
<li><a href="../fr478710/index.html">Déploiement simple et organisé des applications sur la cartouche Tarantool (partie 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>