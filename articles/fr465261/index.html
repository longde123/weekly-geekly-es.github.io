<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ ‚ùï üë©üèæ‚Äçü§ù‚Äçüë®üèº La puissance magique des macros ou comment simplifier la vie d'un programmeur assembleur AVR üëå üî• ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beaucoup de choses ont √©t√© √©crites sur les macros dans l'assembleur. Et dans la documentation, et dans divers articles. Mais dans la plupart des cas, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La puissance magique des macros ou comment simplifier la vie d'un programmeur assembleur AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465261/"><p>  Beaucoup de choses ont √©t√© √©crites sur les macros dans l'assembleur.  Et dans la documentation, et dans divers articles.  Mais dans la plupart des cas, cela se r√©sume soit √† une simple liste de directives avec une br√®ve description de leurs fonctions, soit √† un ensemble d'exemples disparates de macros pr√™tes √† l'emploi. <br>  Le but de cet article est de d√©crire une approche sp√©cifique de la programmation en langage assembleur pour g√©n√©rer le code le plus simple et lisible √† l'aide de macros.  L'article ne d√©crira pas la syntaxe des commandes et directives individuelles.  Une description d√©taill√©e a d√©j√† √©t√© donn√©e par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur</a> .  Nous nous concentrerons sur la fa√ßon d'utiliser ces opportunit√©s pour r√©soudre des probl√®mes sp√©cifiques. </p><a name="habracut"></a><br><p>  √Ä un moment donn√©, ATMEL a essay√© et d√©velopp√© une gamme de microcontr√¥leurs huit bits avec une architecture de tr√®s haute qualit√© et un syst√®me de commande simple, mais en m√™me temps tr√®s puissant.  Mais, comme vous le savez, il n'y a pas de limite √† la perfection, et certaines instructions fr√©quemment utilis√©es ne suffisent pas.  Heureusement, l'assembleur de macros, aimablement et absolument gratuit fourni par le fabricant, peut consid√©rablement simplifier le code gr√¢ce √† l'utilisation de directives.  Avant de passer directement aux macros, nous effectuerons quelques √©tapes pr√©liminaires </p><br><h3 id="opredelenie-konstant">  D√©finition des constantes </h3><br><pre><code class="plaintext hljs">.EQU FOSC = 16000000 .EQU CLK8 = 0</code> </pre> <br><p>  Ces deux d√©finitions vous permettent de vous d√©barrasser des "nombres magiques" dans les macros, o√π les valeurs des registres sont calcul√©es en fonction de la fr√©quence du processeur et de l'√©tat du fusible du diviseur p√©riph√©rique.  La premi√®re d√©finition est la fr√©quence du cristal du processeur en hertz, la seconde est l'√©tat du diviseur de fr√©quence p√©riph√©rique. </p><br><h3 id="imenovanie-registrov">  Enregistrer la d√©nomination </h3><br><pre> <code class="plaintext hljs">.DEF TempL = r16 .DEF TempH = r17 .DEF TempQL = r18 .DEF TempQH = r19 .DEF AL = r0 .DEF AH = r1 .DEF AQL = r2 .DEF AQH = r3</code> </pre> <br><p>  Un registre un peu redondant √† premi√®re vue qui peut √™tre utilis√© dans les macros.  Il suffit de quatre registres pour <em>Temp</em> si nous avons affaire √† des valeurs de 32 bits (par exemple, dans les op√©rations de multiplication de deux nombres de 16 bits).  Si nous sommes s√ªrs que deux registres de stockage temporaires sont suffisants pour nous d'utiliser dans les macros, alors <em>TempQL</em> et <em>TempQH</em> ne peuvent pas √™tre d√©termin√©s.  Les d√©finitions de <em>A</em> sont n√©cessaires pour les macros utilisant des op√©rations de multiplication.  <em>AQ</em> n'est plus n√©cessaire si nous n'utilisons pas l'arithm√©tique 32 bits avec nos macros. </p><br><h3 id="makrosy-dlya-realizacii-prostyh-komand">  Macros pour impl√©menter des commandes simples </h3><br><p>  Maintenant que nous avons compris le nom des registres, nous allons commencer √† impl√©menter les commandes manquantes et commencer par essayer de simplifier celles existantes.  L'assembleur AVR a une caract√©ristique maladroite.  Pour l'entr√©e et la sortie, les 64 premiers ports utilisent les commandes d' <em>entr√©e / sortie</em> et pour les <em>lds / st</em> restants.  Afin de ne pas regarder la documentation √† chaque fois √† la recherche de la commande n√©cessaire pour un port sp√©cifique, nous allons cr√©er un ensemble de commandes universelles qui substitueront ind√©pendamment les valeurs n√©cessaires. </p><br><pre> <code class="plaintext hljs">.MACRO XOUT .IF @0&lt;64 out @0,@1 .ELSE sts @0,@1 .ENDIF .ENDMACRO .MACRO XIN .IF @1&lt;64 in @0,@1 .ELSE lds @0,@1 .ENDIF .ENDMACRO</code> </pre> <br><p>  Pour que la substitution fonctionne correctement, la compilation conditionnelle est utilis√©e dans la macro.  Dans le cas o√π l'adresse du port est inf√©rieure √† 64, la premi√®re section conditionnelle est ex√©cut√©e, sinon la seconde.  Nos macros r√©p√®tent compl√®tement la fonctionnalit√© des commandes standard pour travailler avec les ports d'entr√©e / sortie.Par cons√©quent, pour indiquer que notre √©quipe poss√®de des fonctionnalit√©s avanc√©es, nous ajoutons le pr√©fixe de d√©nomination standard <em>X.</em> <br>  L'une des commandes les plus courantes qui ne sont pas disponibles dans l'assembleur, mais qui sont constamment requises, est la commande pour √©crire des constantes dans les registres d'entr√©e de sortie.  L'impl√©mentation de macro pour cette commande ressemblera √† ceci </p><br><pre> <code class="plaintext hljs">.MACRO OUTI ldi TempL,@1 .IF @0&lt;64 out @0, TempL .ELSE sts @0, TempL .ENDIF .ENDMACRO</code> </pre> <br><p>  Dans ce cas, le nom dans la macro, afin de ne pas violer la logique de d√©nomination des commandes, ajoutez au nom standard le suffixe <em>I</em> , utilis√© par le d√©veloppeur pour d√©signer les commandes de travail avec les constantes.  Dans cette macro, nous utilisons le registre <em>TempL</em> pr√©c√©demment d√©fini pour le <em>fonctionnement</em> . <br>  Dans certains cas, pas un seul registre n'est requis, mais une paire enti√®re stockant une valeur de 16 bits.  Cr√©er une nouvelle macro pour √©crire une valeur 16 bits dans une paire de registres d'E / S </p><br><pre> <code class="plaintext hljs">.MACRO OUTIW ldi TempL,HIGH(@1) .IF @0&lt;64 out @0H, TempL .ELSE sts @0H, TempL .ENDIF ldi TempL,LOW(@1) .IF @0&lt;64 out @0L, TempL .ELSE sts @0L, TempL .ENDIF .ENDMACRO</code> </pre> <br><p>  Dans cette macro, nous utilisons les fonctions <em>LOW</em> et <em>HIGH</em> int√©gr√©es pour extraire l'octet bas et haut d'une valeur 16 bits.  Dans le nom de la macro, ajoutez les suffixes <em>I</em> et <em>W</em> √† la commande pour indiquer que dans ce cas, la commande fonctionne avec une valeur de 16 bits (mot). <br>  Pas moins souvent dans les programmes, il y a chargement de paires de registres, par exemple pour mettre des pointeurs en m√©moire.  Cr√©ons une telle macro </p><br><pre> <code class="plaintext hljs">.MACRO ldiw ldi @0L, LOW(@1) ldi @0H, HIGH(@1) .ENDMACRO</code> </pre> <br><p>  Dans cette macro, nous utilisons le fait que la d√©nomination standard des registres et des ports chez le fabricant implique le postfixe <em>L</em> pour le bas et le postfix <em>H</em> pour la partie sup√©rieure de la valeur √† deux octets.  Si vous suivez cette r√®gle lorsque vous nommez vos propres variables, la macro fonctionnera correctement, y compris avec elles.  La beaut√© des macros r√©side √©galement dans le fait qu'elles fournissent une substitution simple, par cons√©quent, dans le cas o√π le deuxi√®me op√©rande est un nombre, et dans le cas o√π il s'agit du nom de l'√©tiquette, la macro fonctionnera correctement. </p><br><h3 id="makrosy-dlya-realizacii-slozhnyh-komand">  Macros pour impl√©menter des commandes complexes. </h3><br><p>  Lorsqu'il s'agit d'op√©rations plus complexes, les macros ne sont g√©n√©ralement pas utilis√©es, pr√©f√©rant les routines.  Cependant, dans ces cas, les macros peuvent vous faciliter la vie et rendre le code plus lisible.  Dans ce cas, la compilation conditionnelle vient √† la rescousse.  Une approche de programmation pourrait ressembler √† ceci: <br>  Nous <strong>pla√ßons</strong> toutes nos routines dans un fichier s√©par√©, que nous nommerons, par exemple, <strong>Library.inc</strong> .  Chaque sous-programme de ce fichier aura le formulaire suivant </p><br><pre> <code class="plaintext hljs">_sub0: .IFDEF __sub0 ; -----    ----- ret .ENDIF</code> </pre> <br><p>  Dans ce cas, la pr√©sence de la d√©finition __sub0 signifie que le sous-programme doit √™tre inclus dans le code r√©sultant.  Sinon, il est ignor√©. <br>  Ensuite, dans un fichier s√©par√© <strong>Macro.inc, nous</strong> d√©finissons les macros du formulaire </p><br><pre> <code class="plaintext hljs">.MACRO SUB0 .IFNDEF __sub0 .DEF __sub0 .ENDIF ; ---          call _sub0 .ENDMACRO</code> </pre> <br><p>  Lorsque vous utilisez cette macro, nous v√©rifions la d√©finition de __sub0 et, si elle est manquante, nous effectuons la d√©termination.  Par cons√©quent, l'utilisation d'une macro d√©verrouille l'inclusion de code de sous-programme dans le fichier de sortie.  Dans le cas de l'utilisation de routines dans des macros, le code du programme principal prendra la forme suivante </p><br><pre> <code class="plaintext hljs">.INCLUDE ‚ÄúMacro.inc‚Äù ;----    ---- .INCLUDE ‚ÄúLibrary.inc‚Äù</code> </pre> <br><p>  √Ä titre d'exemple, nous donnons une impl√©mentation d'une macro pour diviser des entiers non sign√©s 8 bits.  Nous gardons la logique du constructeur et pla√ßons le r√©sultat en <em>AL (r0)</em> , et le reste de la division en <em>AH (r1)</em> .  Le sous-programme se pr√©sente comme suit </p><br><pre> <code class="plaintext hljs">_div8u: .IFDEF __ div8u ;AH -  ;AL  ;TempL -  ;TempH -  ;TempQL -  clr AL; clr AH; ldi TempQL,9 d8u_1: rol TempL dec TempQL brne d8u_2 ret d8u_2: rol A sub AH, TempH brcc d8u_3 add AH,TempH clc rjmp d8u_1 d8u_3: sec rjmp d8u_1 .ENDIF</code> </pre> <br><p>  La d√©finition de macro pour utiliser cette routine sera la suivante </p><br><pre> <code class="plaintext hljs">.MACRO DIV8U .IFNDEF __div8u .DEF __div8u .ENDIF mov TempL, @0 mov TempH, @1 call _div8u .ENDMACRO</code> </pre> <br><p>  Si vous le souhaitez, vous pouvez ajouter une version pour travailler avec une constante </p><br><pre> <code class="plaintext hljs">.MACRO DIV8UI .IFNDEF __div8u .DEF __div8u .ENDIF mov TempL, @0 ldi TempH, @1 call _div8u .ENDMACRO</code> </pre> <br><p>  Par cons√©quent, l'utilisation de l'op√©ration de division dans le texte du programme est triviale </p><br><pre> <code class="plaintext hljs">DIV8U r10, r11 ; r0 = r10/r11 r1 = r10 % r11 DIV8UI r10, 35 ; r0 = r10/35 r1 = r10 % 35</code> </pre> <br><p>  En utilisant la compilation conditionnelle, nous pouvons placer toutes les routines qui pourraient nous √™tre utiles dans <strong>Library.inc</strong> .  Dans ce cas, seuls ceux qui ont √©t√© appel√©s au moins une fois appara√Ætront dans le code de sortie.  Faites attention √† la position de l'√©tiquette d'entr√©e.  La sortie de l'√©tiquette au-del√† des limites de la condition est due aux fonctionnalit√©s du compilateur.  Si vous placez l'√©tiquette dans le corps du bloc conditionnel, le compilateur peut g√©n√©rer une erreur.  La pr√©sence de balises inutilis√©es dans le code n'est pas effrayante, car la pr√©sence d'un nombre quelconque de balises n'affecte pas le r√©sultat. </p><br><h3 id="makrosy-dlya-raboty-s-periferiey">  Macros p√©riph√©riques </h3><br><p>  L'une des op√©rations o√π il est difficile de se passer de la documentation du fabricant est d'initialiser les p√©riph√©riques.  M√™me avec l'utilisation de d√©signations mn√©moniques de registres et de bits du code, il peut √™tre difficile de comprendre dans quel mode un p√©riph√©rique est configur√©, d'autant plus que parfois le mode est configur√© par une combinaison de valeurs de bits de diff√©rents registres.  Voyons comment les macros peuvent √™tre utilis√©es avec l'exemple <em>USART</em> . <br>  Commen√ßons par la macro d'initialisation en mode asynchrone. </p><br><pre> <code class="plaintext hljs">.MACRO USART_INIT ; speed, bytes, parity, stop-bits .IF CLK8 == 0 .SET DIVIDER = FOSC/16/@0-1 .ELSE .SET DIVIDER = FOSC/128/@0-1 .ENDIF ; Set baud rate to UBRR0 outi UBRR0H, HIGH(DIVIDER) outi UBRR0L, LOW(DIVIDER) ; Enable receiver and transmitter .SET UCSR0B_ = (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0) outi UCSR0B, UCSR0B_ .SET UCSR0C_ = 0 .IF @2 == 'E' .SET UCSR0C_ |= (1&lt;&lt;UPM01) .ENDIF .IF @2 == 'O' .SET UCSR0C_ |= (1&lt;&lt;UPM00) .ENDIF .IF @3== 2 .SET UCSR0C_ |= (1&lt;&lt;USBS0) .ENDIF .IF @1== 6 .SET UCSR0C_ |= (1&lt;&lt;UCSZ00) .ENDIF .IF @1== 7 .SET UCSR0C_ |= (1&lt;&lt;UCSZ01) .ENDIF .IF @1== 8 .SET UCSR0C_ = UCSR0C_ |(1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00) .ENDIF .IF @1== 9 .SET UCSR0C_ |= (1&lt;&lt;UCSZ02)|(1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00) .ENDIF ; Set frame format outi UCSR0C,UCSR0C_ .ENDMACRO</code> </pre> <br><p>  L'utilisation de la macro nous a permis de remplacer l'initialisation des registres de configuration <em>USART</em> par des valeurs incompr√©hensibles sans lire la documentation par une ligne que m√™me ceux qui ont rencontr√© ce contr√¥leur pour la premi√®re fois pouvaient g√©rer.  Dans cette macro, il est √©galement finalement devenu clair pourquoi nous avons d√©termin√© les constantes de fr√©quence et de diviseur.  Eh bien, il convient de noter que malgr√© le code impressionnant de la macro elle-m√™me, celle qui en r√©sulte aura la m√™me apparence que si nous √©crivions l'initialisation de la mani√®re habituelle. <br>  Pour finir avec <em>USART,</em> voici encore quelques petites macros </p><br><pre> <code class="plaintext hljs"> .MACRO USART_SEND_ASYNC outi UDR0, @0 .ENDMACRO</code> </pre> <br><p>  Il n'y a qu'une seule ligne, mais l'utilisation de cette macro vous permettra de mieux voir o√π le programme affiche les donn√©es dans <em>USART</em> .  Si nous supposons travailler en mode synchrone sans utiliser d'interruptions, alors au lieu de <em>USART_SEND_ASYNC,</em> il est pr√©f√©rable d'utiliser la macro ci-dessous </p><br><pre> <code class="plaintext hljs"> .MACRO USART_SEND USART_Transmit: xin TempL, UCSR0A sbrs TempL, UDRE0 rjmp USART_Transmit outi UDR0, @0 .ENDMACRO</code> </pre> <br><p>  Dans ce cas, nous activons la v√©rification de l'occupation du port et affichons les donn√©es uniquement lorsque le port est libre.  De toute √©vidence, cette approche de l'utilisation des p√©riph√©riques fonctionnera pour n'importe quel p√©riph√©rique, et pas seulement pour <em>USART</em> . </p><br><h3 id="sravnenie-programm-bez-i-s-ispolzovaniem-makrosov">  Comparaison de programmes sans et utilisant des macros. </h3><br><p>  Regardons un petit exemple et comparons le code √©crit sans utiliser de macros avec le code o√π elles sont utilis√©es.  Par exemple, prenez un programme qui affiche le classique <strong>"Hello world!"</strong>  au terminal via le mat√©riel <em>UART</em> . </p><br><pre> <code class="plaintext hljs"> RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 USART_Init: out UBRR0H, r17 out UBRR0L, r16 ldi r16, (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0) out UCSRnB,r16 ldi r16, (1&lt;&lt;USBS0)|(3&lt;&lt;UCSZ00) out UCSR0C,r16 ldi ZL, LOW(STR&lt;&lt;1) ldi ZH, HIGH(STR&lt;&lt;1) LOOP: lpm r16, Z+ or r16,r16 breq END USART_Transmit: in r17, UCSR0A sbrs r17, UDRE0 rjmp USART_Transmit out UDR0,r16 rjmp LOOP END: rjmp END STR: .DB ‚ÄúHello world!‚Äù,0</code> </pre> <br><p>  Et voici le m√™me programme, mais √©crit √† l'aide de macros </p><br><pre> <code class="plaintext hljs">.INCLUDE ‚Äúmacro.inc‚Äù .EQU FOSC = 16000000 .EQU CLK8 = 0 RESET: ldiw SP, RAMEND; USART_INIT 19200, 8, "N", 1 ldiw Z, STR&lt;&lt;1 LOOP: lpm TempL, Z+ test TempL breq END USART_SEND TempL rjmp LOOP END: rjmp END STR: .DB ‚ÄúHello world!‚Äù,0</code> </pre> <br><p>  Dans cet exemple, nous avons utilis√© les macros d√©crites ci-dessus, ce qui nous a permis de simplifier consid√©rablement le code du programme et de le rendre plus compr√©hensible.  Le code binaire dans les deux programmes sera absolument identique. </p><br><h3 id="vyvod">  Conclusion </h3><br><p>  L'utilisation de macros peut r√©duire consid√©rablement le code assembleur du programme, pour le rendre plus compr√©hensible et lisible.  La compilation conditionnelle vous permet de cr√©er des commandes universelles et des biblioth√®ques de proc√©dures sans cr√©er de code de sortie redondant.  Comme inconv√©nient, on peut signaler un ensemble tr√®s modeste par rapport aux langages de haut niveau d'op√©rations et de restrictions autoris√©es lors de la d√©claration des donn√©es ¬´en aval¬ª.  Cette restriction ne permet pas, par exemple, d'√©crire au moyen de macros une commande universelle √† part enti√®re pour les <em>transitions jmp / rjmp</em> et gonfle consid√©rablement le code de la macro elle-m√™me lors de l'impl√©mentation d'une logique complexe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465261/">https://habr.com/ru/post/fr465261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465249/index.html">Conf√©rence de Richard Stallman √† l'√âcole polytechnique de Moscou. Ao√ªt 2019</a></li>
<li><a href="../fr465251/index.html">L'√©t√© est presque termin√©. Presque aucune donn√©e n'a √©t√© divulgu√©e</a></li>
<li><a href="../fr465255/index.html">Impl√©mentation du pool de connexions WCF pour .Net Core √† l'aide de HttpClientFactory</a></li>
<li><a href="../fr465257/index.html">"M√©fiez-vous, FAS!": Astuces de McDonald's, shawarma divin, faux Clooney et magie de la rue</a></li>
<li><a href="../fr465259/index.html">ValueTask <TResult> - pourquoi, pourquoi et comment?</a></li>
<li><a href="../fr465263/index.html">Verrous dans PostgreSQL: 3. Verrouille d'autres objets</a></li>
<li><a href="../fr465267/index.html">TypeScript Expression Magic</a></li>
<li><a href="../fr465269/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 26. DNS et DHCP</a></li>
<li><a href="../fr465271/index.html">Les pirates informatiques volent et blanchissent de l'argent gr√¢ce aux services de livraison de nourriture et de r√©servation d'h√¥tel.</a></li>
<li><a href="../fr465273/index.html">Comment les d√©veloppeurs de logiciels Microgaming prot√®gent les utilisateurs contre les hacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>