<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‹ğŸ¿ ğŸ¤²ğŸ¿ ğŸ‘‰ğŸ¾ Go Product Development: Satu Sejarah Proyek ğŸ¿ âšªï¸ ğŸ¤²ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Maxim Ryndin, saya adalah pemimpin tim dari dua tim di Gett - Billing dan Infrastruktur. Saya ingin berbicara tentang pengemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go Product Development: Satu Sejarah Proyek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gett/blog/463097/"><img src="https://habrastorage.org/webt/td/1u/xd/td1uxd-gvg5tcgybfq_fpnt8yu4.jpeg"><br><br>  Halo semuanya!  Nama saya Maxim Ryndin, saya adalah pemimpin tim dari dua tim di Gett - Billing dan Infrastruktur.  Saya ingin berbicara tentang pengembangan web produk, yang kami di Gett terutama gunakan Go.  Saya akan memberi tahu Anda bagaimana pada 2015-2017 kami beralih ke bahasa ini, mengapa kami memilihnya, masalah apa yang kami temui selama masa transisi dan solusi apa yang kami temukan.  Dan saya akan menceritakan tentang situasi saat ini di artikel selanjutnya. <br><br>  Bagi mereka yang tidak tahu: Gett adalah layanan taksi internasional yang didirikan di Israel pada tahun 2011.  Gett sekarang diwakili di 4 negara: Israel, Inggris, Rusia, dan Amerika Serikat.  Produk utama perusahaan kami adalah aplikasi mobile untuk klien dan driver, portal web untuk klien korporat tempat Anda dapat memesan mobil, dan sekelompok panel admin internal yang melaluinya karyawan kami menyiapkan paket tarif, menghubungkan driver baru, memantau kasus penipuan, dan banyak lagi.  Pada akhir 2016, kantor R&amp;D global dibuka di Moskow, yang berfungsi untuk kepentingan seluruh perusahaan. <br><a name="habracut"></a><br><h1>  Bagaimana kami sampai di Go </h1><br>  Pada tahun 2011, produk utama perusahaan adalah aplikasi monolitik pada Ruby on Rails, karena pada saat itu kerangka kerja ini sangat populer.  Ada contoh bisnis yang sukses yang dengan cepat dikembangkan dan diluncurkan di Ruby on Rails, sehingga dikaitkan dengan keberhasilan dalam bisnis tersebut.  Perusahaan berkembang, driver dan pengguna baru datang kepada kami, banyak yang tumbuh.  Dan masalah pertama mulai muncul. <br><br>  Agar aplikasi klien dapat menampilkan lokasi mobil, dan agar pergerakannya terlihat seperti kurva yang halus, pengemudi harus sering mengirim koordinatnya.  Oleh karena itu, titik akhir yang bertanggung jawab untuk menerima koordinat dari driver hampir selalu yang paling banyak dimuat.  Dan kerangka kerja server web di Ruby on Rails melakukan pekerjaan yang buruk ini.  Itu mungkin untuk skala hanya secara luas, menambahkan server aplikasi baru, yang mahal dan tidak efisien.  Sebagai hasilnya, kami mengeluarkan koleksi fungsional koordinat dalam layanan terpisah, yang awalnya ditulis dalam JS.  Untuk sementara, ini menyelesaikan masalah.  Namun, ketika beban bertambah, ketika kami mencapai 80 ribu RPM, layanan di Node.js berhenti menyelamatkan kami. <br><br>  Lalu kami mendeklarasikan hackathon.  Semua karyawan di perusahaan memiliki kesempatan dalam sehari untuk menulis prototipe, yaitu mengumpulkan koordinat pengemudi.  Berikut adalah tolok ukur dari dua versi layanan itu: berjalan di prod dan ditulis ulang di Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/5c8/470/1fc5c847051bc17131587c26f2bb7740.png" width="400"></div><br>  Dalam hampir semua hal, layanan di Go menunjukkan hasil terbaik.  Layanan di Node.js menggunakan sebuah cluster, itu adalah teknologi untuk menggunakan semua inti mesin.  Artinya, eksperimen itu plus atau minus jujur.  Meskipun Node.js memiliki kelemahan dari runtime single-threaded, itu tidak berpengaruh pada hasil. <br><br>  Secara bertahap, permintaan produk kami tumbuh.  Kami mengembangkan lebih banyak fungsionalitas, dan begitu kami menghadapi masalah seperti itu: ketika Anda menambahkan beberapa kode di satu tempat, sesuatu mungkin pecah di tempat lain di mana proyek terhubung dengan kuat.  Kami memutuskan untuk mengatasi momok ini dengan beralih ke arsitektur berorientasi layanan.  Tetapi kinerja menurun sebagai hasilnya: ketika permintaan jaringan ditemui oleh penerjemah Ruby on Rails ketika kode dieksekusi, itu diblokir dan pekerja menganggur.  Dan operasi jaringan I / O menjadi semakin banyak. <br><br>  Sebagai hasilnya, kami memutuskan untuk mengadopsi Go sebagai salah satu bahasa pengembangan utama. <br><br><h1>  Fitur pengembangan produk kami </h1><br>  Pertama, kami memiliki persyaratan produk yang sangat berbeda.  Karena mobil kami berkendara di tiga negara dengan undang-undang yang sama sekali berbeda, maka perlu untuk mengimplementasikan serangkaian fungsi yang sangat berbeda.  Misalnya, di Israel, secara hukum diperlukan bahwa biaya perjalanan dipertimbangkan oleh taksimeter - ini adalah perangkat yang lulus sertifikasi wajib setiap beberapa tahun.  Ketika pengemudi memulai perjalanan, dia menekan tombol "go", dan ketika dia selesai, dia menekan tombol "stop", dan memasukkan harga yang ditunjukkan oleh taksimeter ke dalam aplikasi. <br><br>  Tidak ada hukum yang ketat di Rusia.  Di sini kita dapat mengkonfigurasi kebijakan penetapan harga sendiri.  Misalnya, ikatkan dengan durasi perjalanan atau jarak.  Terkadang, ketika kita ingin menerapkan fungsi yang sama, pertama-tama kita meluncurkannya di satu negara, dan kemudian beradaptasi dan meluncurkannya di negara lain. <br><br>  Manajer produk kami menetapkan persyaratan dalam bentuk cerita produk, kami mencoba mematuhi pendekatan seperti itu saja.  Ini secara otomatis meninggalkan jejak pada pengujian: kami menggunakan metodologi pengembangan yang didorong oleh perilaku sehingga persyaratan produk yang masuk dapat diproyeksikan ke situasi pengujian.  Lebih mudah bagi orang yang jauh dari pemrograman untuk hanya membaca hasil tes dan memahami apa itu. <br><br>  Kami juga ingin menyingkirkan duplikasi beberapa pekerjaan.  Lagi pula, jika kita memiliki layanan yang mengimplementasikan beberapa jenis fungsi, dan kita perlu menulis layanan kedua, menyelesaikan kembali semua masalah yang kita selesaikan di pertama, mengintegrasikan kembali dengan alat pemantauan dan migrasi, maka ini tidak akan efektif. <br><br><h1>  Kami memecahkan masalah </h1><br><h3>  Kerangka kerja </h3><br>  Ruby on Rails dibangun di atas arsitektur MVC.  Pada saat transisi, kami benar-benar tidak ingin menyerah untuk membuat hidup lebih mudah bagi para pengembang yang hanya dapat memprogram pada kerangka kerja ini.  Mengubah alat tidak menambah kenyamanan tanpa itu, dan jika Anda juga mengubah arsitektur aplikasi, itu sama dengan mendorong orang yang tidak tahu cara berenang dari perahu.  Kami tidak ingin menyakiti pengembang dengan cara ini, jadi kami mengambil satu dari beberapa kerangka kerja MVC pada waktu itu yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beego</a> . <br><br>  Kami mencoba menggunakan Beego, seperti pada Ruby on Rails, untuk melakukan rendering sisi server.  Namun, halaman yang diberikan di server tidak benar-benar menyenangkan kami.  Saya harus membuang satu komponen, dan hari ini Beego hanya memproduksi JSON dari backend, dan semua rendering dilakukan oleh React di bagian depan. <br><br>  Beego memungkinkan Anda membangun proyek secara otomatis.  Sangat sulit bagi beberapa pengembang untuk beralih dari bahasa scripting ke kebutuhan untuk dikompilasi.  Ada cerita lucu ketika seseorang menerapkan beberapa fitur, dan hanya dengan review kode atau bahkan secara tidak sengaja menemukan bahwa, ternyata, Anda perlu melakukan Go-build.  Dan tugasnya sudah ditutup. <br><br>  Di Beego, router dihasilkan dari komentar di mana pengembang menulis path ke tindakan controller.  Kami memiliki sikap ambigu terhadap ide ini, karena jika kesalahan ketik, misalnya, router diketik ulang, maka sulit bagi mereka yang tidak canggih dalam pendekatan ini untuk menemukan kesalahan.  Orang-orang, kadang-kadang, tidak dapat menemukan alasannya bahkan setelah beberapa jam debug yang menarik. <br><br><h3>  Basis data </h3><br>  Kami menggunakan PostgreSQL sebagai databasenya.  Ada praktik semacam itu - untuk mengontrol skema database dari kode aplikasi.  Ini nyaman karena beberapa alasan: semua orang tahu tentang mereka;  mereka mudah digunakan, database selalu disinkronkan dengan kode.  Dan kami juga ingin menyimpan roti ini. <br><br>  Ketika Anda memiliki beberapa proyek dan tim, terkadang untuk mengimplementasikan fungsionalitas Anda harus merangkak ke proyek orang lain.  Dan sangat menggoda untuk menambahkan kolom ke tabel, di mana 10 juta catatan mungkin muncul.  Dan orang yang tidak tenggelam dalam proyek ini mungkin tidak menyadari ukuran meja.  Untuk mencegah hal ini, kami mengeluarkan peringatan tentang migrasi berbahaya yang dapat memblokir database untuk direkam, dan memberi pengembang cara untuk menghapus peringatan ini. <br><br><h3>  Migrasi </h3><br>  Kami memutuskan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bermigrasi</a> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swan</a> , yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">angsa yang ditambal</a> , di mana kami membuat beberapa perbaikan.  Keduanya, seperti banyak alat migrasi, ingin melakukan semuanya dalam satu transaksi, sehingga jika terjadi masalah Anda dapat dengan mudah memutar kembali.  Terkadang Anda perlu membuat indeks, dan tabel terkunci.  PostgreSQL memiliki parameter <code>concurrently</code> yang menghindari ini.  Masalahnya adalah jika di PostgreSQL Anda mulai membangun indeks pada <code>concurrently</code> ini <code>concurrently</code> , dan bahkan dalam suatu transaksi, kesalahan akan muncul.  Awalnya kami ingin menambahkan bendera agar tidak membuka transaksi.  Dan pada akhirnya, mereka melakukan ini: <br><br><pre> <code class="plaintext hljs">COMMIT; CREATE INDEX CONCURRENTLY huge_index ON huge_table (column_one, column_two); BEGIN;</code> </pre> <br>  Sekarang, ketika seseorang menambahkan indeks dengan parameter <code>concurrently</code> , dia mendapatkan petunjuk ini.  Perhatikan bahwa <code>commit</code> dan <code>begin</code> tidak bingung.  Kode ini menutup transaksi yang dibuka alat migrasi, lalu menggulung indeks dengan parameter <code>concurrently</code> , lalu membuka transaksi lain sehingga alat menutup sesuatu. <br><br><h3>  Pengujian </h3><br>  Kami berusaha mematuhi perkembangan yang didorong oleh perilaku.  Di Go, ini bisa dilakukan menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ginkgo</a> .  Itu baik karena memiliki kata kunci yang biasa untuk BDD, "jelaskan", "kapan" dan lainnya, dan itu juga memungkinkan Anda untuk hanya memproyeksikan teks yang ditulis oleh manajer produk ke dalam situasi pengujian yang disimpan dalam kode sumber.  Tapi kami dihadapkan dengan masalah: orang-orang yang datang dari dunia Ruby on Rails percaya bahwa dalam bahasa pemrograman apa pun ada sesuatu yang mirip dengan seorang gadis pabrik - sebuah pabrik untuk menciptakan kondisi awal.  Namun, tidak ada yang seperti ini di Go.  Sebagai hasilnya, kami memutuskan bahwa kami tidak akan menemukan kembali roda: tepat sebelum setiap tes, di kait sebelum dan setelah pengujian, kami mengisi database dengan data yang diperlukan, dan kemudian membersihkannya sehingga tidak ada efek samping. <br><br><h3>  Pemantauan </h3><br>  Jika Anda memiliki layanan produksi yang diakses orang, maka Anda perlu melacak pekerjaannya: apakah ada lima ratus kesalahan atau permintaan sedang diproses dengan cepat.  Di dunia Ruby on Rails, NewRelic sangat sering digunakan untuk ini, dan banyak pengembang kami telah memilikinya dengan baik.  Mereka mengerti bagaimana alat itu bekerja, ke mana harus mencari jika ada masalah.  NewRelic memungkinkan Anda untuk menganalisis waktu pemrosesan permintaan melalui HTTP, mengidentifikasi panggilan eksternal yang lambat dan permintaan ke database, memantau aliran data, memberikan analisis kesalahan yang cerdas dan peringatan. <br><br>  NewRelic memiliki fungsi agregat Apdex, yang tergantung pada histogram distribusi durasi jawaban dan beberapa nilai yang Anda anggap normal dan yang ditetapkan di awal.  Fitur ini juga tergantung pada tingkat kesalahan dalam aplikasi.  NewRelic menghitung Apdex dan mengeluarkan peringatan jika nilainya jatuh di bawah level tertentu. <br>  NewRelic juga pandai memiliki agen Go resmi baru-baru ini.  Seperti inilah gambaran umum pemantauan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f58/218/5f5/f582185f5109783ba55323d47a231b8f.png"><br><br>  Di sebelah kiri adalah diagram pemrosesan kueri, yang masing-masing dibagi menjadi beberapa segmen.  Segmen termasuk antrian permintaan, pemrosesan middleware, lama tinggal di interpreter Ruby on Rails, dan akses ke repositori. <br><br>  Grafik Apdex ditampilkan di kanan atas.  Kanan bawah - frekuensi permintaan pemrosesan. <br><br>  Intriknya adalah bahwa di Ruby on Rails untuk menghubungkan NewRelic Anda perlu menambahkan satu baris kode dan menambahkan kredensial Anda ke konfigurasi.  Dan semuanya bekerja secara ajaib.  Hal ini dimungkinkan karena pada kenyataan bahwa di Ruby on Rails ada patching monyet, yang tidak di Go, jadi ada banyak yang harus dilakukan secara manual. <br><br>  Pertama-tama, kami ingin mengukur durasi pemrosesan permintaan.  Ini dilakukan menggunakan kait yang disediakan oleh Beego. <br><br><pre> <code class="plaintext hljs">beego.InsertFilter("*", beego.BeforeRouter, StartTransaction, false) beego.InsertFilter("*", beego.AfterExec, NameTransaction, false) beego.InsertFilter("*", beego.FinishRouter, EndTransaction, false)</code> </pre> <br>  Satu-satunya poin non-sepele adalah bahwa kami berbagi pembukaan transaksi dan penamaannya.  Kenapa kita melakukan ini?  Saya ingin mengukur durasi pemrosesan permintaan dengan mempertimbangkan waktu yang dihabiskan untuk routing.  Pada saat yang sama, kami membutuhkan laporan yang dikumpulkan oleh titik akhir di mana permintaan datang.  Tetapi pada saat membuka transaksi, kami belum menetapkan pola URL yang dengannya kecocokan akan terjadi.  Oleh karena itu, ketika permintaan datang, kami membuka transaksi, lalu di hook, setelah mengeksekusi controller, beri nama, dan setelah diproses, tutuplah.  Karenanya, hari ini laporan kami terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/354/de1/a95354de1b442dd6ed4b51dfcb14d138.png" width="400"></div><br>  Kami menggunakan ORM yang disebut GORM karena kami ingin mempertahankan abstraksi dan tidak memaksa pengembang untuk menulis SQL murni.  Pendekatan ini memiliki kelebihan dan kekurangan.  Di dunia Ruby on Rails, ada ORM Active Record yang benar-benar memanjakan orang.  Pengembang lupa bahwa Anda dapat menulis SQL murni, dan beroperasi hanya dengan panggilan ORM. <br><br><pre> <code class="sql hljs">db.Callback().Create().Before("gorm:begin_transaction"). Register("newrelicStart", startSegment) db.Callback().Create().After("gorm:commit_or_rollback_transaction"). Register("newrelicStop", endSegment)</code> </pre> <br>  Untuk mengukur durasi eksekusi kueri dalam database saat menggunakan GORM, Anda harus mengambil objek <code>db</code> .  Callback mengatakan bahwa kami ingin mendaftarkan panggilan balik.  Itu harus dipanggil saat membuat entitas baru - panggilan untuk <code>Create</code> .  Kemudian kami menunjukkan kapan tepatnya meluncurkan Callback.  <code>Before</code> bertanggung jawab untuk ini dengan argumen <code>begin_transaction</code> : <code>begin_transaction</code> adalah beberapa poin pada saat transaksi dibuka.  Selanjutnya, dengan nama <code>newrelicStart</code> mendaftarkan fungsi <code>startSegment</code> , yang cukup memanggil agen Go dan membuka segmen baru untuk mengakses database. <br><br>  ORM akan memanggil fungsi ini sebelum kita membuka transaksi, dan dengan demikian membuka segmen.  Kita harus melakukan hal yang sama untuk menutup segmen: cukup tutup Callback. <br><br>  Selain PostgreSQL, kami menggunakan Redis, yang juga tidak mulus.  Untuk pemantauan ini, kami menulis pembungkus atas klien standar, dan melakukan hal yang sama untuk memanggil layanan eksternal.  Inilah yang terjadi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/0ea/f22/16f0eaf22037ef6c0265209e19ec205f.png"><br><br>  Seperti inilah pemantauan untuk aplikasi yang ditulis dalam Go.  Di sebelah kiri adalah laporan tentang durasi pemrosesan kueri, yang terdiri dari segmen: eksekusi kode itu sendiri di Go, akses ke database PostgreSQL dan Replica.  Panggilan ke layanan eksternal tidak ditampilkan pada grafik ini, karena jumlahnya sangat sedikit dan tidak terlihat saat dirata-rata.  Kami juga memiliki informasi tentang Apdex dan frekuensi pemrosesan permintaan.  Secara umum, pemantauan itu ternyata cukup informatif dan berguna untuk digunakan. <br><br>  Adapun aliran data, berkat pembungkus kami di atas klien HTTP, kami dapat melacak permintaan ke layanan eksternal.  Skema permintaan layanan promosi ditunjukkan di sini: mengacu pada empat layanan kami yang lain dan dua repositori. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f46/4e6/037/f464e6037f9a0db0cb1e513a319f491d.png"><br><br><h1>  Kesimpulan </h1><br>  Hari ini kami memiliki lebih dari 75% layanan produksi yang ditulis dalam Go, kami tidak melakukan pengembangan aktif di Ruby, tetapi hanya mendukungnya.  Dan dalam hal ini, saya ingin mencatat: <br><br><ul><li>  Kekhawatiran bahwa kecepatan pengembangan akan menurun belum dikonfirmasi.  Pemrogram mencurahkan ke dalam teknologi baru masing-masing dalam mode sendiri, tetapi, rata-rata, setelah beberapa minggu bekerja aktif, pengembangan di Go menjadi dapat diprediksi dan secepat di Ruby on Rails. <br></li><li>  Kinerja aplikasi Go yang sedang dimuat sangat mengejutkan dibandingkan dengan pengalaman sebelumnya.  Kami secara signifikan menghemat penggunaan infrastruktur di AWS, secara signifikan mengurangi jumlah instance yang digunakan. <br></li><li>  Perubahan teknologi telah secara signifikan mendorong programmer, dan ini adalah bagian penting dari proyek yang sukses. <br></li><li>  Hari ini kita telah meninggalkan Beego dan Gorm, lebih lanjut tentang ini di artikel selanjutnya. <br></li></ul><br>  Meringkas, saya ingin mengatakan bahwa jika Anda menulis tidak di Go, Anda menderita masalah beban kerja yang tinggi dan bosan dengan lalu lintas, buka bahasa ini.  Hanya saja, jangan lupa bernegosiasi dengan bisnis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463097/">https://habr.com/ru/post/id463097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463075/index.html">Lisensi Open Source Baru</a></li>
<li><a href="../id463083/index.html">Melindungi cadangan iPhone</a></li>
<li><a href="../id463085/index.html">Sistem Akses File Jarak Jauh Kandang</a></li>
<li><a href="../id463089/index.html">Penerapan sistem pencarian perusahaan untuk desainer mekanik menggunakan platform Low-Code</a></li>
<li><a href="../id463095/index.html">Kenapa tidak SQL?</a></li>
<li><a href="../id463099/index.html">1000 dan 1 umpan balik. Bagaimana memberi umpan balik dan mengajar orang lain, pengalaman Lamoda</a></li>
<li><a href="../id463101/index.html">Mengelola ratusan server untuk pengujian beban: autoscaling, pemantauan khusus, budaya DevOps</a></li>
<li><a href="../id463105/index.html">Hari keempat saya dengan Haiku: masalah instalasi dan boot</a></li>
<li><a href="../id463107/index.html">ShIoTiny: otomatisasi kecil, Internet, atau "enam bulan sebelum liburan"</a></li>
<li><a href="../id463113/index.html">Kontrol Data dan Model Versi dalam pertemuan Visi Komputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>