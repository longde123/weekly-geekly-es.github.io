<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🌆 🧖🏾 Construyendo un servicio de moneda privada usando Exonum 📃 🦉 🍱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pruebas / argumentos de conocimiento cero son una tecnología criptográfica emergente que promete acercarnos al Santo Grial de blockchain: proporci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construyendo un servicio de moneda privada usando Exonum</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/440274/">  Las pruebas / argumentos de conocimiento cero son una tecnología criptográfica emergente que promete acercarnos al Santo Grial de blockchain: proporcionar privacidad y auditabilidad de los datos. <br><br>  Las aplicaciones potenciales para conocimiento cero incluyen, pero no se limitan a: <br><br><ul><li>  Sistemas de transferencia interbancarios (ver un artículo de investigación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Narula et al</a> .) </li><li> Gestión de activos digitales centrada en la privacidad (vea una prueba de concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JP Morgan y zCash</a> ) </li><li>  KYC (ver prueba de concepto por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ING</a> ) </li><li>  Identidad auto soberana (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">credenciales basadas en atributos proyecto de la UE</a> ) </li><li>  Votación (vea un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prototipo de votación por poder del Depósito de Seguridad Nacional de Rusia</a> ) </li></ul><br>  Otra aplicación para pruebas de conocimiento cero es ayudar a las cadenas de bloques a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escalar</a> .  Los ZKP permiten la "compresión" de los cálculos para las transacciones de blockchain sin sacrificar la seguridad. <br><br>  <b><i>En este artículo, describimos cómo se puede aplicar el conocimiento cero (específicamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bulletproofs</a> ) para construir un servicio centrado en la privacidad utilizando la plataforma Exonum de Bitfury.</i></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/67/o0/wt/67o0wt-rl28brd5xywax0ez98x0.png"></a> <a name="habracut"></a><br><br><h2>  Análisis situacional </h2><br>  Es posible lograr <i>cierto</i> nivel de privacidad de datos en las aplicaciones blockchain utilizando el enfoque de "jardín amurallado", donde los datos están ocultos porque el acceso a ellos está restringido con la ayuda de firewalls, control de acceso basado en roles, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fosos</a> y otras medidas de seguridad perimetral .  Los datos confidenciales en la cadena de bloques pueden encriptarse (quizás, con un esquema de encriptación de clave pública, con las claves públicas relevantes administradas por la misma cadena de bloques) y / o almacenarse fuera de la cadena de bloques (en este caso, la cadena de bloques solo almacena huellas digitales hash de los datos)  Este enfoque se utiliza en muchos marcos contables distribuidos autorizados. <br><br>  Sin embargo, las desventajas del enfoque de "jardín amurallado" son cada vez más evidentes.  Para decirlo sin rodeos, el enfoque es antitético a uno de los principales puntos de venta de blockchain: la auditabilidad.  Si los datos en la cadena de bloques no se pueden auditar consultando la lógica del contrato inteligente, la cadena de bloques se convierte en un servicio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marca de tiempo vinculado</a> glorificado.  El hecho de que haya algunos datos en la cadena de bloques ya no significa que estos datos sean válidos según las reglas del contrato inteligente.  La segunda desventaja principal del enfoque de jardín amurallado es que no se escala.  El CTO de R3, Richard Brown, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparó</a> acertadamente el modelo de privacidad de su solución con los canales de Slack: es difícil agregar o eliminar de forma segura a los participantes del jardín, aún más cuando no hay expectativas previas en cuanto al número e identidades de estos participantes <br><br>  Aquí es donde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el conocimiento cero</a> puede ser valioso.  Por diseño, las pruebas y argumentos de conocimiento cero prueban de manera convincente una declaración sobre datos privados sin revelar nada sobre los datos, excepto la declaración que se está probando.  ¡Es fácil hacer que las pruebas de conocimiento cero sean <i>universalmente</i> verificables, sin sacrificar la privacidad! ² Esta característica es exactamente lo que se necesita para construir un sistema que mantenga la privacidad y sea auditable al mismo tiempo. <br><br><h2>  Nuestra investigacion </h2><br>  Para demostrar el uso de pruebas de conocimiento cero, vamos a construir un servicio de criptomonedas con una funcionalidad similar a los servicios de tutoría en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de Exonum</a> .  El servicio permite registrar usuarios y billeteras (proporcionando un saldo inicial de tokens como recompensa) y transferir tokens entre las partes registradas.  Todas las transacciones se autentican con la ayuda de un criptosistema de firma digital, Ed25519, que está integrado en los servicios de Exonum.  No ocultamos las identidades de las partes que realizan transacciones (es decir, sus claves públicas), pero ocultamos la cantidad de tokens que se realizan y el saldo de cada cuenta en el sistema.  También discutimos cómo podríamos mejorar el servicio para ocultar las entidades de transacción al final del artículo. <br><br>  El servicio es de código abierto y se puede acceder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  Fondo de criptografía </h2><br>  Para entender cómo funciona el servicio, primero debemos presentarnos a la primitiva criptográfica central que sustenta Bulletproofs, un concepto llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compromisos de Pedersen</a> .  Un esquema de compromiso criptográfico es algo así como una función hash: alguien ingresa datos secretos (la apertura) y obtiene la salida que está codificada de manera irreconocible (el compromiso).  Entonces se puede revelar la apertura para demostrar que el valor comprometido le corresponde. <br><br>  La diferencia con las funciones hash es que además de ser <i>vinculante</i> (nadie puede idear dos aperturas diferentes que produzcan el mismo compromiso), también se espera que se <i>oculte</i> un esquema de compromiso (es imposible revertir el esquema y producir una apertura dado un compromiso).  Una función hash se oculta si su entrada se distribuye uniformemente sobre todo el espacio de entrada, pero esta suposición con frecuencia no se cumple para los compromisos (de hecho, debe ser posible comprometerse con un valor de un conjunto muy pequeño, como Boolean).  Como tal, la abertura contiene, además de la carga útil, el <i>factor de cegamiento</i> que hace (al menos estadísticamente) improbable adivinar la carga útil dado el compromiso. <br><br>  El esquema de compromiso de Pedersen utiliza un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupo de primer orden</a> , en el que se cree que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de logaritmo discreto</a> (DLP) es difícil, junto con dos generadores, <b>G</b> y <b>H.</b>  <b>G</b> y <b>H</b> deben elegirse de tal manera que se desconozca la relación de registro discreta entre ellos;  en otras palabras, nadie sabe <b>k</b> tal que <b>H = kG</b> .³ La apertura es un par <b>(x, r)</b> , donde <b>x</b> es el valor comprometido y <b>r</b> es el factor de cegamiento;  ambos son escalares grupales (esencialmente, enteros con "desbordamiento" similar a los tipos enteros finitos utilizados en la mayoría de los lenguajes de programación).  El compromiso se calcula como <b>Comm (x; r) = xG + rH</b> .  Se puede demostrar que si DLP en el grupo es difícil, el compromiso de Pedersen es computacionalmente vinculante y perfectamente oculto. <br><br>  La propiedad crucial para los compromisos de Pedersen es que son aditivos: la suma (o diferencia) de 2 compromisos es un compromiso con la suma (o diferencia) de los valores comprometidos.  De hecho, <br><br><pre><code class="cpp hljs">C1 = x1 G + r1 H; C2 = x2 G + r2 H =&gt; C1 + C2 = (x1 + x2) G + (r1 + r2) H = Comm(x1 + x2; r1 + r2).</code> </pre> <br>  No incluimos los detalles aquí sobre cómo se construyen y verifican las balas, pero se puede encontrar más información en los siguientes recursos: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> ] y [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> ].  Es suficiente tener en cuenta que se supone que el límite superior del límite <b>M</b> tiene la forma <b>2 ^ (2 ^ n)</b> , lo que conduce a la construcción de prueba más eficiente. <br><br><h2>  Construyendo un servicio </h2><br>  Con nuestro conocimiento, podemos ocultar de forma segura los saldos de las cuentas y transferir cantidades con la ayuda de los compromisos de Pedersen.  Usando pruebas de rango, podemos probar / verificar que una transferencia es correcta: <br><br><ul><li>  El monto transferido es positivo </li><li>  El remitente tiene saldo suficiente en su cuenta. </li></ul><br>  Para la primera prueba, asumimos el compromiso con el monto de la transferencia, <b>C_a</b> (está directamente presente en la transacción de transferencia), y verificamos que el valor comprometido en <b>C_a-Comm (1; 0) se</b> encuentra en el rango <b>[0, M)</b> .  De hecho, esto es equivalente a probar que <b>C_a</b> corresponde a un valor en el rango <b>[1, M]</b> .  El remitente puede presentar esta prueba, ya que conoce la cantidad transferida <b>a</b> . <br><br>  Para la segunda prueba, debemos asumir el compromiso del saldo actual del remitente, <b>C_s</b> , y verificar que el valor comprometido en <b>C_s-C_a se</b> encuentre en el rango <b>[0, M)</b> .  Nuevamente, el remitente puede producir esta prueba ya que él / ella conoce la apertura a <b>C_s</b> y <b>C_a</b> . <br><br>  Para aplicar la transferencia al estado blockchain, restamos el compromiso de cantidad <b>C_a</b> del compromiso de <b>saldo</b> del remitente (como hemos verificado, no puede conducir a un saldo negativo o al aumento del saldo del remitente), y luego sumamos <b>C_a</b> al receptor equilibrio compromiso <br><br><h2>  Detalles clave </h2><br>  Es importante tener en cuenta que hay algunas condiciones que pueden hacer que el servicio implementado sea más complejo. <br><br>  El receptor de una transferencia debe encontrar la apertura a <b>C_a</b> desde algún lugar;  de lo contrario, deja de conocer la apertura de su equilibrio y ya no puede hacer nada con su billetera.  La apertura no está presente en el texto sin formato de la transacción de transferencia (que es el punto completo).  Podríamos suponer que el receptor obtiene de manera confiable la apertura a través de un canal fuera de la cadena (por ejemplo, enviado por el remitente a través de Telegram), pero ese no es un escenario ilustrativo.  Entonces, en cambio, encriptamos la apertura usando encriptación de clave pública de dos partes basada en el intercambio de claves Diffie-Hellman (libsodium llama a este tipo de <b>caja</b> de encriptación).  Para el beneficio adicional, las claves Curve25519 requeridas para la rutina <b>box</b> se pueden convertir de las claves Ed25519, por lo que podemos continuar usando un solo par de claves para cada usuario en lugar de introducir claves de cifrado separadas. <br><br><img src="https://habrastorage.org/webt/fh/cp/7w/fhcp7wkqik4j4taqoqmavd5aenc.jpeg"><br><br>  Una vez que introducimos el cifrado, ya no podemos aplicar la transferencia atómicamente.  De hecho, el remitente puede proporcionar basura de forma maliciosa o involuntaria en lugar del cifrado de apertura, y la lógica de la cadena de bloques no podrá decir que este es el caso. Por lo tanto, solicitamos al receptor que acepte explícitamente la transferencia a través de una transacción separada. <br><br><img src="https://habrastorage.org/webt/zq/pi/oa/zqpioamqvu-zhws88mphgeqsztk.jpeg"><br><br>  Antes de que se acepte una transferencia, modifica el compromiso de saldo del remitente (de lo contrario, permitiríamos el doble gasto), pero no el del receptor. <br><br><img src="https://habrastorage.org/webt/mt/g8/rk/mtg8rkz7amr5jdzbz9-guhzp0sg.jpeg"><br><br>  Una vez que la red blockchain confirma la transacción de aceptación, se actualiza el saldo del receptor y se completa la transferencia. <br><br><img src="https://habrastorage.org/webt/up/cc/3p/upcc3pqjyy3yar5xaicaxzsu12y.jpeg"><br><br>  Para evitar puntos muertos, una transferencia especifica un retraso de bloqueo de tiempo (en la altura relativa de la cadena de bloques, <i>como</i> el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSV</a> de Bitcoin) para que el receptor indique la aceptación.  Si el bloqueo de tiempo ha expirado, la transferencia se reembolsará automáticamente al remitente (Exonum lo permite a través de <b>Service :: beforeCommit ()</b> hook). <br><br>  Otro problema es más complejo.  Para producir la prueba de un saldo suficiente, el remitente debe conocer su saldo actual, lo que puede no ser siempre el caso.  Una transacción de aceptación perdida o un reembolso pueden aumentar el saldo del remitente sin saberlo;  en este caso, la transferencia fallará en la verificación y el remitente se sentirá razonablemente frustrado. <br><br>  Para aliviar este problema, permitimos que las transferencias hagan referencia a lo que el remitente cree que es su estado actual de billetera (más precisamente, la referencia toma la forma del número de eventos que cambian el saldo de la cuenta: transferencias y reembolsos).  Al verificar la prueba de un saldo suficiente, utilizamos el estado de referencia para obtener el compromiso de saldo del remitente.  Además, verificamos que no se hayan producido transferencias salientes desde el estado de referencia.  Si este es el caso, podemos estar seguros de que si restamos el monto de la transferencia del saldo <i>actual</i> del remitente, terminaremos con un valor no negativo.  De hecho, ¡los eventos en el historial de la cuenta después del punto de referencia (transferencias entrantes y reembolsos) solo pueden aumentar el saldo! ⁷ <br><br>  Con los puntos de referencia en su lugar, el remitente sigue estando algo limitado;  No debe tener transferencias pendientes al crear una nueva transferencia.  Aún así, esta restricción es mucho menos limitante que el requisito de conocer el estado de la cuenta en el momento de la transferencia;  fundamentalmente, hacemos que el remitente dependa de lo <i>que</i> hizo anteriormente, pero no de las acciones de los demás. <br><br><h2>  Implementación </h2><br>  Utilizamos una biblioteca a prueba de balas escrita en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust</a> puro, que recientemente ha alcanzado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la etapa de prelanzamiento</a> .  Dado que la plataforma Exonum está escrita en Rust, se integra perfectamente con la biblioteca.  Como beneficio adicional, a diferencia de la versión de prueba de balas descrita en el documento técnico original (que se está desarrollando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C</a> y utiliza la curva elíptica secp256k1 de Bitcoin), la biblioteca que utilizamos se basa en Curve25519, que ya se usa en Exonum como el componente principal del Ed25519 criptosistema de firma digital. <br><br>  Implementar el servicio basado en la descripción anterior es bastante sencillo.  La parte más difícil fue construir pruebas de Merkle que autentiquen la información devuelta al usuario para que no tenga que confiar ciegamente en los nodos Exonum con los que se comunica.  Mejorar la experiencia de los desarrolladores de servicios a este respecto es uno de los principales objetivos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión Exonum 1.0</a> . <br><br><h2>  Próximos pasos </h2><br>  El servicio que hemos construido no oculta las identidades del remitente y el receptor de las transferencias, lo cual es una limitación importante para las aplicaciones del mundo real.  Afortunadamente, hay formas de resolver este problema. <br><br>  La técnica genérica utilizada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zCash</a> (pero aplicable principalmente a otros casos de uso, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethereum</a> ) se basa en la creación de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árbol Merkle</a> del estado del sistema.  Por ejemplo, zCash construye el <i>árbol de compromiso de notas</i> , que es más o menos equivalente a las salidas de transacciones creadas en Bitcoin.  Las pruebas de conocimiento cero luego abarcan rutas de autenticación (también conocidas como ramas de Merkle) en este árbol, revelan algo sobre un elemento del árbol sin revelar a qué elemento se hace referencia.  La desventaja de este enfoque es que las funciones hash criptográficas utilizadas para construir árboles Merkle son difíciles de transferir al ámbito de conocimiento cero;  las pruebas resultantes se vuelven computacionalmente caras: una sola prueba puede tardar segundos o incluso minutos en crearse.  La búsqueda de más funciones hash criptográficas “compatibles con ZKP” es el área de investigación activa. <br><br>  Si admitimos restricciones adicionales, puede haber una solución más fácil.  Por ejemplo, un artículo reciente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Narula et al</a> .  describe un sistema con un número limitado y a priori conocido de participantes, que puede realizar transacciones entre ellos sin revelar participantes o cantidades transferidas para cualquier transacción.  (Piense en una red blockchain centrada en la privacidad para las transferencias interbancarias). <br><br>  En una nota más prosaica, probablemente haya muchas mejoras técnicas que el servicio desarrollado puede disfrutar: más cobertura de prueba, separación de claves de firma y cifrado, evaluación comparativa, etc.  Una mejora importante para el servicio UX sería permitir el ordenamiento determinista de transacciones que se originan en el mismo usuario, que planeamos resolver no mucho después de lanzar Exonum 1.0. <br><br><h2>  Conclusión </h2><br>  Hemos descrito cómo construir un cryptotoken basado en cuentas con una fuerte privacidad habilitada por pruebas de conocimiento cero (específicamente, a prueba de balas).  La lógica del token se implementó como un servicio Exonum.  Aunque actualmente el servicio es solo una prueba de concepto, muestra cómo la plataforma Exonum se puede utilizar para construir sobre primitivas criptográficas complejas con una sobrecarga muy baja impuesta por el entorno de ejecución. <br><br><hr><br><ol><li>  Existe una distinción intrincada entre pruebas y argumentos, que no abordaremos aquí.  En aras de la simplicidad, nos referiremos a todas las construcciones de conocimiento cero en este artículo como pruebas de conocimiento cero, incluso si esto no siempre es correcto desde el punto de vista teórico. </li><li>  Esto se puede lograr a través de una técnica muy general conocida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transformación Fiat - Shamir</a> , que convierte un protocolo de prueba interactivo en uno no interactivo, universalmente verificable.  Sacrificando el rigor científico una vez más, no aclararemos explícitamente que las pruebas de conocimiento cero que utilizamos no son interactivas. </li><li>  Los generadores generalmente se eligen con el método "nada bajo la manga".  Por ejemplo, G puede ser parte de la especificación del grupo para su uso en criptografía de clave pública, y H se deriva de G a través de una función hash: <b>H ~ hash (G)</b> . </li><li>  Esto último significa que incluso un adversario con potencia informática infinita no puede deducir a qué se compromete el compromiso;  de hecho, si DLP en el grupo se rompe, cada compromiso puede abrirse a cualquier valor posible. </li><li>  Esto es parcialmente una decisión de prueba de concepto;  en general, reutilizar claves para diferentes propósitos es una mala idea. </li><li>  Es teóricamente posible proporcionar una prueba de conocimiento cero para que el valor cifrado sea equivalente al saldo comprometido;  sin embargo, aumentaría prohibitivamente la complejidad del sistema. </li><li>  Vale la pena mencionar que algunas transferencias que rompen la regla "no hay transferencias salientes desde el estado referenciado" aún pueden ser correctas;  simplemente no tenemos forma de verificar esto. </li></ol><br><hr><br><ul><li>  Web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitfury.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exonum.com</a> </li><li>  Redes sociales: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Facebook</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LinkedIn</a> </li><li>  I + D: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">investigación y libros blancos</a> </li></ul><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440274/">https://habr.com/ru/post/440274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440264/index.html">Juegos de Tetris, o qué es la gestión de capacidad en un centro de datos</a></li>
<li><a href="../440266/index.html">Algunas palabras sobre teorías físicas como aproximaciones del mundo real</a></li>
<li><a href="../440268/index.html">Desvío de sonido: mecanismo para generar clics ultrasónicos en polillas nocturnas como protección contra murciélagos</a></li>
<li><a href="../440270/index.html">Consideramos un horario de turnos en la mente</a></li>
<li><a href="../440272/index.html">Mobile Opera tiene una VPN gratis</a></li>
<li><a href="../440276/index.html">Depuración frontal y posterior</a></li>
<li><a href="../440278/index.html">Cambiar Yesca a Kubernetes</a></li>
<li><a href="../440280/index.html">Revisión de software libre de Android</a></li>
<li><a href="../440282/index.html">Los marcos web Python más rápidos en 2019</a></li>
<li><a href="../440284/index.html">Una nueva mirada a la visualización de cuadros de diálogo en Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>