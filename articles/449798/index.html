<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèæ üì≤ ‚ùì Creando Tower Defense en Unity, Parte 1 üéÖüèΩ üç± üíã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El campo 


- Creando un campo de mosaico. 
- Buscar rutas usando la b√∫squeda de amplitud. 
- Implemente soporte para baldosas vac√≠as y finales, as√≠ c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creando Tower Defense en Unity, Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  El campo </h1><br><ul><li>  Creando un campo de mosaico. </li><li>  Buscar rutas usando la b√∫squeda de amplitud. </li><li>  Implemente soporte para baldosas vac√≠as y finales, as√≠ como baldosas de pared. </li><li>  Edici√≥n de contenido en modo juego. </li><li>  Visualizaci√≥n opcional de campos de cuadr√≠cula y caminos. </li></ul><br>  Esta es la primera parte de una serie de tutoriales sobre c√≥mo crear un juego de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">defensa de torre</a> simple.  En esta parte, consideraremos crear un campo de juego, encontrar un camino y colocar las baldosas y paredes finales. <br><br>  El tutorial fue creado en Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Un campo listo para usar en un juego de fichas de g√©nero de defensa de la torre.</i> <br><br><h2>  Juego de Tower Defense </h2><br>  La defensa de la torre es un g√©nero en el que el objetivo del jugador es destruir multitudes de enemigos hasta que alcancen su punto final.  El jugador cumple su objetivo construyendo torres que atacan a los enemigos.  Este g√©nero tiene muchas variaciones.  Crearemos un juego con un campo de mosaico.  Los enemigos se mover√°n por el campo hacia su punto final, y el jugador crear√° obst√°culos para ellos. <br><a name="habracut"></a><br>  Asumir√© que ya has estudiado una serie de tutoriales sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gesti√≥n de objetos</a> . <br><br><h3>  El campo </h3><br>  El campo de juego es la parte m√°s importante del juego, por lo que lo crearemos primero.  Este ser√° un objeto de juego con su propio componente <code>GameBoard</code> , que puede inicializarse configurando el tama√±o en dos dimensiones, para lo cual podemos usar el valor de <code>Vector2Int</code> .  El campo deber√≠a funcionar con cualquier tama√±o, pero elegiremos el tama√±o en otro lugar, por lo que crearemos un m√©todo de <code>Initialize</code> com√∫n para esto. <br><br>  Adem√°s, visualizamos el campo con un cuadr√°ngulo, que denotar√° la tierra.  No haremos que el objeto de campo en s√≠ sea un cuadril√°tero, sino que le agregaremos un objeto quad secundario.  Tras la inicializaci√≥n, haremos que la escala XY de la tierra sea igual al tama√±o del campo.  Es decir, cada mosaico tendr√° un tama√±o de una unidad de medida cuadrada para el motor. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© establecer expl√≠citamente el terreno al valor predeterminado?</b> <div class="spoiler_text">  La idea es que todo lo personalizable a trav√©s del editor de Unity sea accesible a trav√©s de campos ocultos serializados.  Es necesario que estos campos solo se puedan cambiar en el inspector.  Desafortunadamente, el editor de Unity mostrar√° constantemente una advertencia del compilador de que el valor nunca se asigna.  Podemos suprimir esta advertencia estableciendo expl√≠citamente el valor predeterminado para el campo.  Tambi√©n puede asignar <code>null</code> , pero lo hice para mostrar expl√≠citamente que simplemente usamos el valor predeterminado, que no es una referencia verdadera a tierra, por lo que usamos el <code>default</code> . </div></div><br>  Cree un objeto de campo en una nueva escena y agregue un quad secundario con un material que se parezca a la tierra.  Como estamos creando un juego prototipo simple, un material verde uniforme ser√° suficiente.  Gire el quad 90 ¬∞ a lo largo del eje X para que quede en el plano XZ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Campo de juego.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© no posicionar el juego en el plano XY?</b> <div class="spoiler_text">  Aunque el juego tendr√° lugar en el espacio 2D, lo renderizaremos en 3D, con enemigos en 3D y una c√°mara que se puede mover en relaci√≥n con cierto punto.  El plano XZ es m√°s conveniente para esto y corresponde a la orientaci√≥n est√°ndar de skybox utilizada para la iluminaci√≥n ambiental. </div></div><br><h3>  El juego </h3><br>  A continuaci√≥n, cree un componente del <code>Game</code> que ser√° responsable de todo el juego.  En esta etapa, esto significar√° que est√° inicializando el campo.  Solo hacemos que el tama√±o sea personalizable a trav√©s del inspector y forzamos al componente a inicializar el campo cuando se activa.  Usemos el tama√±o predeterminado de 11 √ó 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  Los tama√±os de campo solo pueden ser positivos y tiene poco sentido crear un campo con un √∫nico mosaico.  Entonces limitemos el m√≠nimo a 2 √ó 2.  Esto se puede hacer agregando el m√©todo <code>OnValidate</code> , limitando a la fuerza los valores m√≠nimos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øCu√°ndo se llama a Onvalidate?</b> <div class="spoiler_text">  Si existe, el editor de Unity lo llama para los componentes despu√©s de cambiarlos.  Incluso al agregarlos al objeto del juego, despu√©s de cargar la escena, despu√©s de volver a compilar, despu√©s de cambiar en el editor, despu√©s de cancelar / reintentar y despu√©s de restablecer el componente. <br><br>  <code>OnValidate</code> es el √∫nico lugar en el c√≥digo donde puede asignar valores a los campos de configuraci√≥n de componentes. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Objeto del juego</i> <br><br>  Ahora, cuando inicies el modo de juego, recibiremos un campo con el tama√±o correcto.  Durante el juego, coloque la c√°mara de modo que se vea todo el tablero, copie su componente de transformaci√≥n, salga del modo de juego y pegue los valores del componente.  En el caso de un campo de 11 √ó 11 en el origen, para obtener una vista conveniente desde arriba, puede colocar la c√°mara en posici√≥n (0.10.0) y girarla 90 ¬∞ a lo largo del eje X. Dejaremos la c√°mara en esta posici√≥n fija, pero es posible c√°mbialo en el futuro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>C√°mara sobre el campo.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo copiar y pegar valores de componentes?</b> <div class="spoiler_text">  A trav√©s del men√∫ desplegable que aparece cuando hace clic en el bot√≥n con el engranaje en la esquina superior derecha del componente. </div></div><br><h3>  Azulejo prefabricado </h3><br>  El campo consta de azulejos cuadrados.  Los enemigos podr√°n moverse de una ficha a otra, cruzando los bordes, pero no en diagonal.  El movimiento siempre ocurrir√° hacia el punto final m√°s cercano.  Denotemos gr√°ficamente la direcci√≥n del movimiento a lo largo del mosaico con una flecha.  Puede descargar la textura de la flecha <a href="">aqu√≠</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Flecha sobre un fondo negro.</i> <br><br>  Coloque la textura de la flecha en su proyecto y habilite la opci√≥n <em>Alfa como transparencia</em> .  Luego cree un material para la flecha, que puede ser el material predeterminado para el que se selecciona el modo de recorte, y seleccione la flecha como la textura principal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Material de flecha.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© usar el modo de renderizado recortado?</b> <div class="spoiler_text">  Le permite ocultar la flecha utilizando la canalizaci√≥n de representaci√≥n est√°ndar de Unity. </div></div><br>  Para denotar cada ficha en el juego, utilizaremos el objeto del juego.  Cada uno de ellos tendr√° su propio quad con material de flecha, tal como el campo tiene un quad de tierra.  Tambi√©n agregaremos mosaicos al componente GameTile con un enlace a su flecha. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Cree un objeto de mosaico y convi√©rtalo en un prefabricado.  Los mosaicos estar√°n al ras con el suelo, as√≠ que levante un poco la flecha hacia arriba para evitar problemas de profundidad al renderizar.  Tambi√©n aleja un poco, para que haya poco espacio entre las flechas adyacentes.  Un desplazamiento Y de 0.001 y una escala de 0.8 que sea igual para todos los ejes funcionar√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Azulejo prefabricado.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øD√≥nde est√° la jerarqu√≠a de mosaicos prefabricados?</b> <div class="spoiler_text">  Puede abrir el modo de edici√≥n prefabricado haciendo doble clic en el activo prefabricado, o seleccionando el prefabricado y haciendo clic en el bot√≥n <em>Abrir Prefabricado</em> en el inspector.  Puede salir del modo de edici√≥n prefabricada haciendo clic en el bot√≥n con una flecha en la esquina superior izquierda de su encabezado de jerarqu√≠a. </div></div><br>  Tenga en cuenta que las fichas en s√≠ no tienen que ser objetos del juego.  Solo son necesarios para rastrear el estado del campo.  Podr√≠amos usar el mismo enfoque que para el comportamiento en la serie de tutoriales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object Management</a> .  Pero en las primeras etapas de juegos simples o prototipos de objetos de juego, estamos muy contentos.  Esto se puede cambiar en el futuro. <br><br><h3>  Tenemos azulejos </h3><br>  Para crear mosaicos, el <code>GameBoard</code> debe tener un enlace al mosaico prefabricado. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Enlace al mosaico prefabricado.</i> <br><br>  Luego puede crear sus instancias utilizando un doble bucle sobre dos dimensiones de cuadr√≠cula.  Aunque el tama√±o se expresa como X e Y, organizaremos los mosaicos en el plano XZ, as√≠ como el campo en s√≠.  Dado que el campo est√° centrado en relaci√≥n con el origen, debemos restar el tama√±o correspondiente menos uno dividido por dos de los componentes de la posici√≥n del mosaico.  Tenga en cuenta que esta debe ser una divisi√≥n de coma flotante, de lo contrario no funcionar√° para tama√±os pares. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Instancias creadas de azulejos.</i> <br><br>  M√°s tarde necesitaremos acceso a estos mosaicos, por lo que los rastrearemos en una matriz.  No necesitamos una lista, porque despu√©s de la inicializaci√≥n, el tama√±o del campo no cambiar√°. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); ‚Ä¶ } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo funciona esta tarea?</b> <div class="spoiler_text">  Esta es una tarea vinculada.  En este caso, esto significa que estamos asignando un enlace a la instancia de mosaico tanto al elemento de matriz como a la variable local.  Estas operaciones realizan lo mismo que el c√≥digo que se muestra a continuaci√≥n. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Busca un camino </h2><br>  En esta etapa, cada mosaico tiene una flecha, pero todas apuntan en la direcci√≥n positiva del eje Z, que interpretaremos como norte.  El siguiente paso es determinar la direcci√≥n correcta para el mosaico.  Hacemos esto al encontrar el camino que los enemigos deben seguir hasta el punto final. <br><br><h3>  Vecinos de azulejos </h3><br>  Los caminos van de baldosa en baldosa, en el norte, este, sur u oeste.  Para simplificar la b√∫squeda, haga que <code>GameTile</code> enlaces a sus cuatro vecinos. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Las relaciones entre vecinos son sim√©tricas.  Si el mosaico es el vecino oriental del segundo mosaico, entonces el segundo es el vecino occidental del primero.  Agregue un m√©todo est√°tico general a <code>GameTile</code> para definir esta relaci√≥n entre dos mosaicos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© usar un m√©todo est√°tico?</b> <div class="spoiler_text">  Podemos convertirlo en un m√©todo de instancia con un solo par√°metro, y en este caso lo llamaremos <code>eastTile.MakeEastWestNeighbors(westTile)</code> o algo as√≠.  Pero en los casos en que no est√° claro en cu√°l de los mosaicos se debe invocar el m√©todo, es mejor usar m√©todos est√°ticos.  Los ejemplos son los m√©todos de <code>Distance</code> y <code>Dot</code> de la clase <code>Vector3</code> . </div></div><br>  Una vez conectado, nunca deber√≠a cambiar.  Si esto sucede, cometimos un error en el c√≥digo.  Puede verificar esto comparando ambos enlaces antes de asignar valores <code>null</code> y mostrando un error si es incorrecto.  Puede usar el m√©todo <code>Debug.Assert</code> para <code>Debug.Assert</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øQu√© hace Debug.Assert?</b> <div class="spoiler_text">  Si el primer argumento es <code>false</code> , muestra un error de condici√≥n, utilizando el segundo argumento si se especifica.  Dicha llamada se incluye solo en las versiones de prueba, pero no en las versiones de lanzamiento.  Por lo tanto, esta es una buena manera de agregar comprobaciones durante el proceso de desarrollo que no afectar√°n la versi√≥n final. </div></div><br>  Agregue un m√©todo similar para crear relaciones entre los vecinos del norte y del sur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Podemos establecer esta relaci√≥n al crear mosaicos en <code>GameBoard.Initialize</code> .  Si la coordenada X es mayor que cero, entonces podemos crear una relaci√≥n este-oeste entre los mosaicos actuales y anteriores.  Si la coordenada Y es mayor que cero, entonces podemos crear una relaci√≥n norte-sur entre el mosaico actual y el mosaico de la l√≠nea anterior. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Tenga en cuenta que los mosaicos en los bordes del campo no tienen cuatro vecinos.  Una o dos referencias vecinas permanecer√°n <code>null</code> . <br><br><h3>  Distancia y direcci√≥n </h3><br>  No obligaremos a todos los enemigos a buscar constantemente el camino.  Esto debe hacerse solo una vez por mosaico.  Luego, los enemigos podr√°n solicitar desde la ficha en la que se encuentran d√≥nde avanzar.  Almacenaremos esta informaci√≥n en <code>GameTile</code> agregando un enlace al siguiente mosaico de ruta.  Adem√°s, tambi√©n guardaremos la distancia al punto final, expresada como el n√∫mero de fichas que se deben visitar antes de que el enemigo llegue al punto final.  Para los enemigos, esta informaci√≥n es in√∫til, pero la usaremos para encontrar los caminos m√°s cortos. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Cada vez que decidamos que necesitamos buscar rutas, necesitaremos inicializar los datos de ruta.  Hasta que se encuentre el camino, no hay un mosaico siguiente y la distancia puede considerarse infinita.  Podemos imaginar esto como el valor entero m√°ximo posible de <code>int.MaxValue</code> .  Agregue un m√©todo gen√©rico <code>ClearPath</code> para restablecer <code>GameTile</code> a este estado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Solo se pueden buscar rutas si tenemos un punto final.  Esto significa que el mosaico debe convertirse en el punto final.  Tal mosaico tiene una distancia de cero, y no tiene el √∫ltimo mosaico, porque el camino termina en √©l.  Agregue un m√©todo gen√©rico que convierta un mosaico en un punto final. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  En √∫ltima instancia, todas las fichas deben convertirse en un camino, por lo que su distancia ya no ser√° igual a <code>int.MaxValue</code> .  Agregue una propiedad getter conveniente para verificar si el mosaico actualmente tiene una ruta. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo funciona esta propiedad?</b> <div class="spoiler_text">  Esta es una entrada abreviada para una propiedad getter que contiene solo una expresi√≥n.  Hace lo mismo que el c√≥digo que se muestra a continuaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  El operador de flecha <code>=&gt;</code> tambi√©n se puede usar individualmente para obtener y establecer propiedades, para los cuerpos de m√©todos, constructores y en otros lugares. </div></div><br><h3>  Crecemos un camino </h3><br>  Si tenemos un mosaico con un camino, entonces podemos dejar que crezca un camino hacia uno de sus vecinos.  Inicialmente, el √∫nico mosaico con el camino es el punto final, por lo que comenzamos desde la distancia cero y lo incrementamos desde aqu√≠, movi√©ndonos en la direcci√≥n opuesta al movimiento de los enemigos.  Es decir, todos los vecinos inmediatos del punto final tendr√°n una distancia de 1, y todos los vecinos de estos mosaicos tendr√°n una distancia de 2, y as√≠ sucesivamente. <br><br>  Agregue un m√©todo oculto <code>GameTile</code> para hacer crecer la ruta a uno de sus vecinos, especificado a trav√©s del par√°metro.  La distancia al vecino es uno m√°s que el mosaico actual, y la ruta del vecino indica el mosaico actual.  Este m√©todo solo debe llamarse para los mosaicos que ya tienen una ruta, as√≠ que verifiquemos esto con aserci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  La idea es que llamemos a este m√©todo una vez para cada uno de los cuatro vecinos del mosaico.  Dado que algunos de estos enlaces ser√°n <code>null</code> , lo comprobaremos y detendremos la ejecuci√≥n, si es as√≠.  Adem√°s, si un vecino ya tiene un camino, entonces no debemos hacer nada y tambi√©n dejar de hacerlo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  La forma en que <code>GameTile</code> rastrea a sus vecinos es desconocida para el resto del c√≥digo.  Por lo tanto, <code>GrowPathTo</code> est√° oculto.  <code>GrowPathTo</code> m√©todos generales que le indican al mosaico que haga crecer su camino en una determinada direcci√≥n, llamando indirectamente a <code>GrowPathTo</code> .  Pero el c√≥digo que busca en todo el campo debe realizar un seguimiento de qu√© mosaicos se visitaron.  Por lo tanto, haremos que devuelva un vecino o <code>null</code> si se termina la ejecuci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Ahora agregue m√©todos para cultivar caminos en direcciones espec√≠ficas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Amplia b√∫squeda </h3><br>  <code>GameBoard</code> debe <code>GameBoard</code> que todos los mosaicos contengan los datos de ruta correctos.  Hacemos esto realizando una b√∫squeda de amplitud.  Comencemos con el mosaico de punto final, y luego crezca el camino hacia sus vecinos, luego hacia los vecinos de estos mosaicos, y as√≠ sucesivamente.  Con cada paso, la distancia aumenta en uno, y los caminos nunca crecen en la direcci√≥n de las fichas que ya tienen caminos.  Esto asegura que todos los mosaicos como resultado apunten a lo largo de la ruta m√°s corta al punto final. <br><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© hay de encontrar una ruta usando A *?</b> <div class="spoiler_text">  El algoritmo A <sup>*</sup> es el desarrollo evolutivo de la b√∫squeda de amplitud.  Es √∫til cuando buscamos el √∫nico camino m√°s corto.  Pero necesitamos todos los caminos m√°s cortos, por lo que A <sup>*</sup> no ofrece ninguna ventaja.  Para ver ejemplos de b√∫squeda de amplitud y A <sup>*</sup> en una cuadr√≠cula de hex√°gonos con animaci√≥n, consulte la serie de tutoriales sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mapas de hex√°gonos</a> . </div></div><br>  Para realizar la b√∫squeda, necesitamos rastrear los mosaicos que agregamos a la ruta, pero de los cuales a√∫n no hemos crecido la ruta.  Esta colecci√≥n de azulejos a menudo se llama la frontera de b√∫squeda.  Es importante que los mosaicos se procesen en el mismo orden en que se agregan al borde, as√≠ que usemos la <code>Queue</code> .  M√°s tarde, tendremos que realizar la b√∫squeda varias veces, as√≠ que configur√©moslo como el campo de <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); ‚Ä¶ }</code> </pre> <br>  Para que el estado del campo de juego sea siempre verdadero, debemos encontrar las rutas al final de <code>Initialize</code> , pero poner el c√≥digo en un m√©todo <code>FindPaths</code> separado.  En primer lugar, debe despejar la ruta de todos los mosaicos, luego hacer que un mosaico sea el punto final y agregarlo al borde.  Primero seleccionemos el primer mosaico.  Como los <code>tiles</code> son una matriz, podemos usar el <code>foreach</code> sin temor a la contaminaci√≥n de la memoria.  Si luego pasamos de una matriz a una lista, tambi√©n tendremos que reemplazar los bucles <code>foreach</code> <code>for</code> bucles <code>for</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Luego, necesitamos tomar un mosaico del borde y hacer crecer un camino hacia todos sus vecinos, agreg√°ndolos a todos al borde.  Primero nos moveremos hacia el norte, luego hacia el este, sur y finalmente hacia el oeste. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Repetimos esta etapa, mientras que hay mosaicos en el borde. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Hacer crecer un camino no siempre nos lleva a un nuevo mosaico.  Antes de agregar a la cola, debemos verificar el valor de <code>null</code> , pero podemos posponer la verificaci√≥n de <code>null</code> hasta despu√©s de la salida de la cola. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Mostrar los caminos </h3><br>  Ahora tenemos un campo que contiene las rutas correctas, pero hasta ahora no vemos esto.  Debe configurar las flechas para que apunten a lo largo del camino a trav√©s de sus mosaicos.  Esto se puede hacer gir√°ndolos.  Como estos giros son siempre los mismos, agregamos al <code>GameTile</code> un campo <code>Quaternion</code> est√°tico para cada una de las direcciones. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  Agregue tambi√©n el m√©todo general <code>ShowPath</code> .  Si la distancia es cero, entonces el mosaico es el punto final y no hay nada que se√±alar, as√≠ que desactive su flecha.  De lo contrario, active la flecha y establezca su rotaci√≥n.  La direcci√≥n deseada se puede determinar comparando <code>nextOnPath</code> con sus vecinos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame a este m√©todo para todos los mosaicos al final </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formas encontradas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© no convertimos la flecha directamente en GrowPathTo?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separar la l√≥gica y la visualizaci√≥n de la b√∫squeda. </font><font style="vertical-align: inherit;">M√°s tarde haremos la visualizaci√≥n deshabilitada. </font><font style="vertical-align: inherit;">Si las flechas no aparecen, no necesitamos rotarlas cada vez que llamamos </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar prioridad de b√∫squeda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que cuando el punto final es la esquina suroeste, todos los caminos van exactamente hacia el oeste hasta llegar al borde del campo, despu√©s de lo cual giran hacia el sur. </font><font style="vertical-align: inherit;">Aqu√≠ todo es cierto, porque en realidad no hay caminos m√°s cortos hacia el punto final, porque los movimientos diagonales son imposibles. </font><font style="vertical-align: inherit;">Sin embargo, hay muchos otros caminos m√°s cortos que pueden parecer m√°s bonitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comprender mejor por qu√© se encuentran dichos caminos, mueva el punto final al centro del mapa. </font><font style="vertical-align: inherit;">Con un tama√±o de campo impar, es solo un mosaico en el medio de la matriz.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punto final en el centro.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El resultado parece l√≥gico si recuerda c√≥mo funciona la b√∫squeda. Como agregamos vecinos en el orden noreste-sur-oeste, el norte tiene la m√°xima prioridad. Como estamos haciendo la b√∫squeda en orden inverso, esto significa que la √∫ltima direcci√≥n en la que hemos viajado es hacia el sur. Es por eso que solo unas pocas flechas apuntan hacia el sur y muchas apuntan hacia el este. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede cambiar el resultado estableciendo las prioridades de las direcciones. Cambiemos de este a sur. Entonces tenemos que obtener la simetr√≠a norte-sur y este-oeste.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El orden de b√∫squeda es norte-sur-este-oeste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece m√°s bonito, pero es mejor que los caminos cambien de direcci√≥n, acerc√°ndose al movimiento diagonal donde se ver√° natural. </font><font style="vertical-align: inherit;">Podemos hacer esto invirtiendo las prioridades de b√∫squeda de los mosaicos vecinos en un patr√≥n de tablero de ajedrez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de averiguar qu√© tipo de mosaico estamos procesando durante la b√∫squeda, agregamos a la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad general que indica si el mosaico actual es una alternativa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estableceremos esta propiedad en </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, marque los mosaicos como alternativa si su coordenada X es par.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hace la operaci√≥n (x &amp; 1) == 0?</font></font></b> <div class="spoiler_text">   ‚Äî     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, cambiamos el signo del resultado si su coordenada Y es par. </font><font style="vertical-align: inherit;">Entonces crearemos un patr√≥n de ajedrez.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mantenemos el mismo orden que la b√∫squeda de baldosas alternativa, pero para que sea de nuevo a todos los otros azulejos. </font><font style="vertical-align: inherit;">Esto forzar√° el camino hacia el movimiento diagonal y crear√° zigzags.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orden de b√∫squeda variable.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio de azulejos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, todas las fichas est√°n vac√≠as. </font><font style="vertical-align: inherit;">Un mosaico se usa como punto final, pero adem√°s de la ausencia de una flecha visible, se ve igual que todos los dem√°s. </font><font style="vertical-align: inherit;">Agregaremos la capacidad de cambiar las fichas colocando objetos sobre ellas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contenido del azulejo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos de mosaico en s√≠ mismos son simplemente una forma de rastrear la informaci√≥n de mosaico. </font><font style="vertical-align: inherit;">No modificamos estos objetos directamente. </font><font style="vertical-align: inherit;">En su lugar, agregue contenido separado y col√≥quelo en el campo. </font><font style="vertical-align: inherit;">Por ahora, podemos distinguir entre mosaicos vac√≠os y mosaicos de punto final. </font><font style="vertical-align: inherit;">Para indicar estos casos, cree una enumeraci√≥n </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, cree un tipo de componente </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le permita establecer el tipo de su contenido a trav√©s del inspector, y el acceso al mismo ser√° a trav√©s de una propiedad getter com√∫n.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego crearemos prefabricados para dos tipos de contenido, cada uno de los cuales tiene un componente </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el tipo especificado correspondiente. </font><font style="vertical-align: inherit;">Usemos un cubo aplanado azul para designar mosaicos de punto final. </font><font style="vertical-align: inherit;">Como es casi plano, no necesita un colisionador. </font><font style="vertical-align: inherit;">Para prefabricar contenido vac√≠o, use un objeto de juego vac√≠o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="destino"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="vacio"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefabricados del punto final y contenido vac√≠o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le daremos el objeto de contenido a los mosaicos vac√≠os, porque entonces todos los mosaicos siempre tendr√°n el contenido, lo que significa que no necesitaremos verificar la igualdad de los enlaces a los contenidos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√°brica de contenido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que el contenido sea editable, tambi√©n crearemos una f√°brica para esto, utilizando el mismo enfoque que en el tutorial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesti√≥n de objetos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto significa que </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe realizar un seguimiento de su f√°brica original, que debe configurarse solo una vez, y enviarse de vuelta a la f√°brica en el m√©todo </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto supone la existencia </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo tanto, crearemos un tipo de objeto programable para esto con el m√©todo requerido </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En esta etapa, no nos molestaremos con la creaci√≥n de una f√°brica completamente funcional que utilice los contenidos, por lo que haremos que simplemente destruya los contenidos. </font><font style="vertical-align: inherit;">Posteriormente, ser√° posible agregar la reutilizaci√≥n de objetos a la f√°brica sin cambiar el resto del c√≥digo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo oculto </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la </font><font style="vertical-align: inherit;">f√°brica </font><font style="vertical-align: inherit;">con un prefab como par√°metro. </font><font style="vertical-align: inherit;">Aqu√≠ nuevamente omitimos la reutilizaci√≥n de objetos. </font><font style="vertical-align: inherit;">Crea una instancia del objeto, establece su f√°brica original, lo mueve a la escena de f√°brica y lo devuelve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La instancia se ha movido a la escena de contenido de f√°brica, que se puede crear seg√∫n sea necesario. </font><font style="vertical-align: inherit;">Si estamos en el editor, antes de crear una escena, debemos verificar si existe, en caso de que la perdamos de vista durante un reinicio en caliente.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo tenemos dos tipos de contenido, as√≠ que solo agregue dos campos de configuraci√≥n prefabricados para ellos. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo √∫ltimo que debe hacerse para que la f√°brica funcione es crear un m√©todo general </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un par√°metro </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que reciba una instancia del prefabricado correspondiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs obligatorio agregar una instancia separada de contenido vac√≠o a cada mosaico?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creemos un activo de f√°brica y configuremos sus enlaces a prefabricados. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√°brica de contenido </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego pasa el </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace a la f√°brica.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juego con una f√°brica.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tocando un azulejo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cambiar el campo, debemos poder seleccionar un mosaico. Lo haremos posible en el modo de juego. Emitiremos un rayo en la escena en el lugar donde el jugador hizo clic en la ventana del juego. Si el rayo se cruza con el azulejo, entonces el jugador lo toc√≥, es decir, debe cambiarse. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manejar√° la entrada del jugador, pero ser√° responsable de determinar qu√© mosaico toc√≥ el jugador </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No todos los rayos se cruzan con la baldosa, por lo que a veces no recibiremos nada. Por lo tanto, agregamos al </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que siempre siempre regresa inicialmente </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(esto significa que no se encontr√≥ el mosaico).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar si un rayo ha cruzado un mosaico, necesitamos llamar </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificando el rayo como argumento. </font><font style="vertical-align: inherit;">Devuelve informaci√≥n sobre si hubo una intersecci√≥n. </font><font style="vertical-align: inherit;">Si es as√≠, entonces podemos devolver el mosaico, aunque todav√≠a no sabemos cu√°l, por lo que por ahora lo devolveremos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para saber si hubo una intersecci√≥n con un mosaico, necesitamos m√°s informaci√≥n sobre la intersecci√≥n. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede proporcionar esta informaci√≥n utilizando el segundo par√°metro </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es el par√°metro de salida, que se indica con la palabra que est√° </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delante de √©l. </font><font style="vertical-align: inherit;">Esto significa que una llamada al m√©todo puede asignar un valor a la variable que le pasamos.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos incrustar la declaraci√≥n de las variables utilizadas para los par√°metros de salida, as√≠ que hag√°moslo. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No nos importa con qu√© colisionador se produjo la intersecci√≥n, solo usamos la posici√≥n de intersecci√≥n XZ para determinar el mosaico. </font><font style="vertical-align: inherit;">Obtenemos las coordenadas del mosaico agregando la mitad del tama√±o del campo a las coordenadas del punto de intersecci√≥n y luego convirtiendo los resultados a valores enteros. </font><font style="vertical-align: inherit;">Como resultado, el √≠ndice de mosaico final ser√° su coordenada X m√°s la coordenada Y multiplicada por el ancho del campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto solo es posible cuando las coordenadas del mosaico est√°n dentro del campo, por lo que lo comprobaremos. </font><font style="vertical-align: inherit;">Si este no es el caso, no se devolver√° el mosaico.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio de contenido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que pueda cambiar el contenido del mosaico, agr√©guelo a la </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad general </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Su captador simplemente devuelve los contenidos, y el colocador descarta los contenidos anteriores, si los hay, y coloca los nuevos contenidos.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es el √∫nico lugar en el que necesita verificar el contenido </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque inicialmente no tenemos contenido. </font><font style="vertical-align: inherit;">Para garantizar, ejecutamos afirmar para que no se llame al establecedor con </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y finalmente, necesitamos una entrada del jugador. </font><font style="vertical-align: inherit;">Convertir clic del rat√≥n en el haz se puede hacer llamando </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un argumento. </font><font style="vertical-align: inherit;">La llamada debe realizarse para la c√°mara principal, a la que se puede acceder a trav√©s </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agregue la propiedad c para esto </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego agregamos un m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que verifica si se presion√≥ el bot√≥n principal del mouse durante la actualizaci√≥n. </font><font style="vertical-align: inherit;">Para hacer esto, llame </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con cero como argumento. </font><font style="vertical-align: inherit;">Si la tecla ha sido presionada, procesamos el toque del jugador, es decir, tomamos el mosaico del campo y establecemos el punto final como su contenido, tom√°ndolo de f√°brica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos convertir cualquier mosaico en un punto final presionando el cursor. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios puntos finales.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hacer el campo correcto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque podemos convertir los mosaicos en puntos finales, esto no afecta las rutas hasta ahora. </font><font style="vertical-align: inherit;">Adem√°s, a√∫n no hemos establecido contenido vac√≠o para mosaicos. </font><font style="vertical-align: inherit;">Mantener la correcci√≥n y la integridad del campo es una tarea </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ que vamos a darle la responsabilidad de establecer el contenido del mosaico. </font><font style="vertical-align: inherit;">Para implementar esto, le daremos un enlace a la f√°brica de contenido a trav√©s de su m√©todo </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y lo usaremos para dar a todos los mosaicos una instancia de contenido vac√≠o.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tengo que transferir mi f√°brica al campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© no agregar un campo de configuraci√≥n de f√°brica al GameBoard?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ahora tenemos varios puntos finales, lo cambiamos </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que llame </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada uno y los agregue todos al borde. </font><font style="vertical-align: inherit;">Y eso es todo lo que se necesita para admitir m√∫ltiples puntos finales. </font><font style="vertical-align: inherit;">Todas las dem√°s fichas se borran como de costumbre. </font><font style="vertical-align: inherit;">Luego eliminamos el punto final fijo en el centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero si podemos convertir los mosaicos en puntos finales, entonces deber√≠amos poder realizar la operaci√≥n inversa, convertir los puntos finales en mosaicos vac√≠os. </font><font style="vertical-align: inherit;">Pero entonces podemos obtener un campo sin puntos finales. </font><font style="vertical-align: inherit;">En este caso, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no podr√° realizar su tarea. </font><font style="vertical-align: inherit;">Esto sucede cuando el borde est√° vac√≠o despu√©s de la inicializaci√≥n de la ruta para todas las celdas. </font><font style="vertical-align: inherit;">Denotamos esto como un estado no v√°lido del campo, devolviendo </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y completando la ejecuci√≥n; </font><font style="vertical-align: inherit;">de lo contrario regrese al final </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de implementar soporte para eliminar puntos finales, convirti√©ndolo en una operaci√≥n de cambio. Al hacer clic en los mosaicos vac√≠os, los convertiremos en puntos finales, y al hacer clic en los puntos finales, los eliminaremos. Pero ahora se dedica a cambiar el contenido </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que le daremos un m√©todo general </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cuyo par√°metro es el mosaico. Si el mosaico es el punto final, entonces vac√≠elo y llame </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De lo contrario, lo convertimos en el punto final y tambi√©n lo llamamos </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar un punto final nunca puede crear un estado de campo no v√°lido, y eliminar un punto final puede. </font><font style="vertical-align: inherit;">Por lo tanto, verificaremos si se ejecut√≥ con √©xito </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de vaciar el mosaico. </font><font style="vertical-align: inherit;">De lo contrario, cancele el cambio, volviendo el mosaico al punto final y vuelva </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font><font style="vertical-align: inherit;">llamar </font><font style="vertical-align: inherit;">para volver al estado correcto anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSe puede hacer la validaci√≥n m√°s eficiente?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora al final </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos llamar </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el mosaico central como argumento, en lugar de llamar expl√≠citamente </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta es la √∫nica vez que comenzamos con un estado de campo no v√°lido, pero se garantiza que terminaremos con el estado correcto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, forzamos a </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamar en </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar de configurar el contenido del mosaico.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∫ltiples puntos finales con rutas correctas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠amos prohibirle a Game configurar el contenido del mosaico directamente?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las paredes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de la torre de defensa es evitar que los enemigos lleguen al punto final. </font><font style="vertical-align: inherit;">Este objetivo se logra de dos maneras. </font><font style="vertical-align: inherit;">Primero, los matamos y, en segundo lugar, los ralentizamos para que haya m√°s tiempo para matarlos. </font><font style="vertical-align: inherit;">En el campo de mosaico, el tiempo se puede estirar, aumentando la distancia que los enemigos deben recorrer. </font><font style="vertical-align: inherit;">Esto se puede lograr colocando obst√°culos en el campo. </font><font style="vertical-align: inherit;">Por lo general, estas son torres que tambi√©n matan enemigos, pero en este tutorial nos limitaremos solo a las paredes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contenido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los muros son otro tipo de contenido, as√≠ que agreguemos </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un elemento a ellos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego cree el muro prefabricado. </font><font style="vertical-align: inherit;">Esta vez crearemos un objeto de juego con el contenido del mosaico y le agregaremos un cubo secundario, que estar√° en la parte superior del campo y llenar√° todo el mosaico. </font><font style="vertical-align: inherit;">Haga que tenga una altura de media unidad y guarde el colisionador, porque las paredes pueden superponerse visualmente a parte de las fichas detr√°s de √©l. </font><font style="vertical-align: inherit;">Por lo tanto, cuando un jugador toca una pared, influir√° en la casilla correspondiente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="ra√≠z"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="cubo"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="prefabricado"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muro prefabricado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue la pared prefabricada a la f√°brica, tanto en el c√≥digo como en el inspector.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√°brica con pared prefabricada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enciende y apaga las paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo de encendido / apagado de las paredes, como lo hicimos para el punto final. </font><font style="vertical-align: inherit;">Inicialmente, no verificaremos el estado incorrecto del campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brindaremos soporte para cambiar solo entre mosaicos vac√≠os y mosaicos, sin permitir que los muros reemplacen directamente los puntos finales. </font><font style="vertical-align: inherit;">Por lo tanto, solo crearemos un muro cuando el mosaico est√© vac√≠o. </font><font style="vertical-align: inherit;">Adem√°s, los muros deber√≠an bloquear la b√∫squeda del camino. </font><font style="vertical-align: inherit;">Pero cada ficha debe tener un camino hacia el punto final, de lo contrario los enemigos se atascar√°n. </font><font style="vertical-align: inherit;">Para hacer esto, nuevamente necesitamos usar la validaci√≥n </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y descartar los cambios si crearon un estado de campo incorrecto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encender y apagar paredes se usar√° con mucha m√°s frecuencia que encender y apagar puntos finales, por lo que haremos que las paredes se cambien en el </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toque principal. </font><font style="vertical-align: inherit;">Los puntos finales se pueden cambiar con un toque adicional (generalmente el bot√≥n derecho del mouse), que se puede reconocer pasando a un </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor de 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos las paredes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© obtengo grandes espacios entre las sombras de paredes adyacentes en diagonal?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asegur√©monos tambi√©n de que los puntos finales no puedan reemplazar directamente los muros. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloqueo de b√∫squeda de ruta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que los muros bloqueen la b√∫squeda de la ruta, es suficiente que no agreguemos mosaicos con muros al borde de b√∫squeda. </font><font style="vertical-align: inherit;">Esto se puede hacer obligando a </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no devolver los azulejos con paredes. </font><font style="vertical-align: inherit;">Pero el camino a√∫n debe crecer en la direcci√≥n de la pared, de modo que todas las fichas en el campo tengan un camino. </font><font style="vertical-align: inherit;">Esto es necesario porque es posible que una ficha con enemigos se convierta de repente en una pared.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para asegurarse de que todos los mosaicos tengan una ruta, </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben verificar esto despu√©s de que se complete la b√∫squeda. </font><font style="vertical-align: inherit;">Si este no es el caso, el estado del campo no es v√°lido y debe devolverse </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No es necesario actualizar la visualizaci√≥n de la ruta para estados no v√°lidos, porque el campo volver√° al estado anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los muros afectan el camino. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para asegurarse de que las paredes tengan los caminos correctos, debe hacer que los cubos sean transl√∫cidos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes transparentes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el requisito de correcci√≥n de todos los caminos no permite que los muros encierren una parte del campo en el que no hay un punto final. </font><font style="vertical-align: inherit;">Podemos dividir el mapa, pero solo si hay al menos un punto final en cada parte. </font><font style="vertical-align: inherit;">Adem√°s, cada pared debe estar adyacente a un mosaico vac√≠o o punto final, de lo contrario no podr√° tener una ruta. </font><font style="vertical-align: inherit;">Por ejemplo, es imposible hacer un bloque s√≥lido de paredes de 3 √ó 3.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ocultar el camino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualizaci√≥n de las rutas nos permite ver c√≥mo funciona la b√∫squeda de rutas y asegurarnos de que sea correcta. </font><font style="vertical-align: inherit;">Pero no necesita mostrarse al jugador, o al menos no necesariamente. </font><font style="vertical-align: inherit;">Por lo tanto, proporcionemos la capacidad de apagar las flechas. </font><font style="vertical-align: inherit;">Esto se puede hacer agregando al </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo general </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que simplemente deshabilita su flecha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El estado de asignaci√≥n de ruta es parte del estado del campo. </font><font style="vertical-align: inherit;">Agregue un </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo booleano al valor predeterminado igual </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para rastrear su estado, as√≠ como una propiedad com√∫n como getter y setter. </font><font style="vertical-align: inherit;">El colocador debe mostrar u ocultar rutas en todos los mosaicos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el m√©todo </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a mostrar rutas actualizadas solo si la representaci√≥n est√° habilitada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por defecto, la visualizaci√≥n de ruta est√° deshabilitada. </font><font style="vertical-align: inherit;">Apague la flecha en el mosaico prefabricado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La flecha prefabricada est√° inactiva por defecto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo hacemos para que </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambie el estado de visualizaci√≥n cuando se presiona una tecla. </font><font style="vertical-align: inherit;">Ser√≠a l√≥gico usar la tecla P, pero tambi√©n es una tecla de acceso r√°pido para habilitar / deshabilitar el modo de juego en el editor de Unity. </font><font style="vertical-align: inherit;">Como resultado, la visualizaci√≥n cambiar√° cuando se use la tecla de acceso r√°pido para salir del modo de juego, lo que no se ve muy bien. </font><font style="vertical-align: inherit;">Entonces usemos la tecla V (abreviatura de visualizaci√≥n).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin flechas</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n de cuadr√≠cula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando las flechas est√°n ocultas, se hace dif√≠cil discernir la ubicaci√≥n de cada mosaico. </font><font style="vertical-align: inherit;">Agreguemos las l√≠neas de la cuadr√≠cula. </font><font style="vertical-align: inherit;">Descargue una </font><font style="vertical-align: inherit;">textura de malla de borde cuadrado </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que se puede usar como un contorno de mosaico separado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textura de malla.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No agregaremos esta textura individualmente a cada mosaico, sino que la aplicaremos al suelo. Pero haremos esta cuadr√≠cula opcional, as√≠ como la visualizaci√≥n de rutas. Por lo tanto, agregaremos al </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de configuraci√≥n </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y seleccionaremos una textura de malla para √©l.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campo con textura de malla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue otro campo booleano y una propiedad para controlar el estado de la visualizaci√≥n de la cuadr√≠cula. </font><font style="vertical-align: inherit;">En este caso, el colocador debe cambiar el material de la tierra, que puede implementarse llamando a la </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tierra y obteniendo acceso a la propiedad del </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado. </font><font style="vertical-align: inherit;">Si es necesario mostrar la </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuadr√≠cula </font><font style="vertical-align: inherit;">, asignaremos la </font><font style="vertical-align: inherit;">textura de </font><font style="vertical-align: inherit;">la </font><font style="vertical-align: inherit;">cuadr√≠cula </font><font style="vertical-align: inherit;">a la propiedad del </font><font style="vertical-align: inherit;">material. </font><font style="vertical-align: inherit;">De lo contrario, asign√°rselo </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tenga en cuenta que cuando cambie la textura del material, se crear√°n duplicados de la instancia de material, de modo que se vuelva independiente del activo de material.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiemos </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la visualizaci√≥n de la cuadr√≠cula con la tecla G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, agregue la visualizaci√≥n de malla predeterminada a </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuadr√≠cula sin escala. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora tenemos un borde alrededor de todo el campo. </font><font style="vertical-align: inherit;">Coincide con la textura, pero eso no es lo que necesitamos. </font><font style="vertical-align: inherit;">Necesitamos escalar la textura principal del material para que coincida con el tama√±o de la cuadr√≠cula. </font><font style="vertical-align: inherit;">Puede hacerlo llamando al m√©todo de </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material con el nombre de la propiedad de textura ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y el tama√±o bidimensional. </font><font style="vertical-align: inherit;">Podemos usar directamente el tama√±o del campo, que se convierte indirectamente en un valor </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="sin"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="con"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuadr√≠cula escalada con visualizaci√≥n de ruta activada y desactivada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, en esta etapa, obtuvimos un campo funcional para un juego de fichas del g√©nero de defensa de la torre. </font><font style="vertical-align: inherit;">En el pr√≥ximo tutorial agregaremos enemigos. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositorio </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449798/">https://habr.com/ru/post/449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449784/index.html">En qu√© casos vale la pena usar Django (y en los que no es necesario)</a></li>
<li><a href="../449788/index.html">Brave Browser presenta una plataforma de publicidad basada en recompensas</a></li>
<li><a href="../449790/index.html">Ayuda visual para el desarrollo de productos: dise√±o</a></li>
<li><a href="../449794/index.html">Matrices de antenas adaptativas: ¬øc√≥mo funciona? (B√°sico)</a></li>
<li><a href="../449796/index.html">Acerca de una chica</a></li>
<li><a href="../449802/index.html">Programador de carrera. Parte 1. El primer programa</a></li>
<li><a href="../449804/index.html">Descripci√≥n general de la terapia antienvejecimiento para biohackers</a></li>
<li><a href="../449806/index.html">Programador de carrera. Parte 2. Escuela o autoeducaci√≥n</a></li>
<li><a href="../449808/index.html">Experimento Positivo Hack Days 9: c√≥mo el pensamiento cr√≠tico ayuda en la vida y el trabajo</a></li>
<li><a href="../449814/index.html">Windows XP est√° oficialmente muerto, ahora finalmente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>