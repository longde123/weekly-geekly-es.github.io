<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßì üë©‚ÄçüöÄ üöé GraphQL und Golang ‚óªÔ∏è ü§Ωüèº üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die GraphQL-Technologie ist in den letzten Jahren, nachdem das Unternehmen Facebook sie in die Kategorie Open Source √ºbertragen hat, sehr beliebt gewo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL und Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444346/">  Die GraphQL-Technologie ist in den letzten Jahren, nachdem das Unternehmen Facebook sie in die Kategorie Open Source √ºbertragen hat, sehr beliebt geworden.  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, er habe versucht, mit GraphQL in Node.js zu arbeiten, und war aus eigener Erfahrung davon √ºberzeugt, dass diese Technologie aufgrund ihrer bemerkenswerten F√§higkeiten und Einfachheit nicht versehentlich so viel Aufmerksamkeit erregt.  K√ºrzlich wechselte er bei einem neuen Projekt von Node.js zu Golang.  Dann beschloss er, die Zusammenarbeit von Golang und GraphQL zu testen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jp/qa/qv/jpqaqvlt5xh7d7mlhwpxvvwhptq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vorl√§ufige Informationen</font> </h2><br>  Sie k√∂nnen der offiziellen GraphQL-Definition entnehmen, dass dies eine Abfragesprache f√ºr die API und eine Laufzeit f√ºr die Ausf√ºhrung solcher Abfragen f√ºr vorhandene Daten ist.  GraphQL bietet eine vollst√§ndige und verst√§ndliche Beschreibung der Daten in einer bestimmten API, erm√∂glicht es Kunden, genau die Informationen anzufordern, die sie ben√∂tigen, und nichts weiter vereinfacht die Entwicklung der API im Laufe der Zeit und bietet Entwicklern leistungsstarke Tools. <br><br>  Es gibt nicht viele GraphQL-Bibliotheken f√ºr Golang.  Insbesondere habe ich Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thunder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphql</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphql-go</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gqlgen ausprobiert</a> .  Ich sollte beachten, dass das Beste von allem, was ich versucht habe, die gqlgen-Bibliothek war. <br><br>  Die gqlgen-Bibliothek befindet sich noch in der Beta- <a href="">Phase</a> . <a href="">Zum</a> Zeitpunkt des Schreibens dieses Materials war es Version <a href="">0.7.2</a> .  Die Bibliothek entwickelt sich rasant weiter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> erfahren Sie mehr √ºber Pl√§ne f√ºr die Entwicklung.  Jetzt ist der offizielle Sponsor von gqlgen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">99designs-</a> Projekt, was bedeutet, dass sich diese Bibliothek m√∂glicherweise noch schneller als zuvor entwickeln wird.  Die Hauptentwickler dieser Bibliothek sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vektah</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neelance</a> , w√§hrend neelance zus√§tzlich an der graphql-go-Bibliothek arbeitet. <br><br>  Lassen Sie uns √ºber die gqlgen-Bibliothek sprechen, basierend auf der Annahme, dass Sie bereits Grundkenntnisse in GraphQL haben. <br><br><h2>  <font color="#3AC1EF">Gqlgen Funktionen</font> </h2><br>  In der Beschreibung von gqlgen finden Sie heraus, was wir vor uns haben, eine Bibliothek zum schnellen Erstellen streng typisierter GraphQL-Server in Golang.  Dieser Satz erscheint mir sehr vielversprechend, da er bedeutet, dass ich bei der Arbeit mit dieser Bibliothek nicht auf so etwas wie <code>map[string]interface{}</code> , da hier ein Ansatz verwendet wird, der auf strenger Typisierung basiert. <br><br>  Dar√ºber hinaus verwendet diese Bibliothek einen Ansatz, der auf einem Datenschema basiert.  Dies bedeutet, dass die APIs mithilfe der GraphQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema Definition Language beschrieben werden</a> .  Diese Sprache verf√ºgt √ºber eigene leistungsstarke Tools zur Codegenerierung, die automatisch GraphQL-Code erstellen.  In diesem Fall kann der Programmierer nur die Grundlogik der entsprechenden Schnittstellenmethoden implementieren. <br><br>  Dieser Artikel ist in zwei Teile gegliedert.  Die erste widmet sich den grundlegenden Arbeitsmethoden und die zweite den fortgeschrittenen. <br><br><h2>  <font color="#3AC1EF">Die wichtigsten Arbeitsmethoden: Einrichten, Anforderungen zum Empfangen und √Ñndern von Daten, Abonnements</font> </h2><br>  Als experimentelle Anwendung verwenden wir eine Website, auf der Benutzer Videos ver√∂ffentlichen, Screenshots und Bewertungen hinzuf√ºgen, nach Videos suchen und Listen mit Datens√§tzen anzeigen k√∂nnen, die mit anderen Datens√§tzen verkn√ºpft sind.  Beginnen wir mit der Arbeit an diesem Projekt: <br><br><pre> <code class="go hljs">mkdir -p $GOPATH/src/github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/</code> </pre> <br>  Erstellen Sie die folgende Datenschemadatei ( <code>schema.graphql</code> ) im Stammverzeichnis des Projekts: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User {   id: ID!   name: String!   email: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video {   id: ID!   name: String!   description: String!   user: User!   url: String!   createdAt: Timestamp!   screenshots: [Screenshot]   related(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Screenshot {   id: ID!   videoId: ID!   url: String! } input NewVideo {   name: String!   description: String!   userId: ID!   url: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Query {   Videos(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } scalar Timestamp</code> </pre> <br>  Hier werden die grundlegenden Datenmodelle beschrieben, eine Mutation ( <code>Mutation</code> , Beschreibung der Anforderung zur Daten√§nderung), mit der neue Videodateien auf der Site ver√∂ffentlicht werden, und eine Abfrage ( <code>Query</code> ), um eine Liste aller Videodateien abzurufen.  Lesen Sie hier mehr √ºber das GraphQL-Schema.  Au√üerdem haben wir hier einen unserer eigenen skalaren Datentypen deklariert.  Wir sind mit den 5 standardm√§√üigen skalaren Datentypen ( <code>Int</code> , <code>Float</code> , <code>String</code> , <code>Boolean</code> und <code>ID</code> ) in GraphQL nicht zufrieden. <br><br>  Wenn Sie Ihre eigenen Typen verwenden m√ºssen, k√∂nnen Sie diese in <code>schema.graphql</code> (in unserem Fall ist dieser Typ <code>Timestamp</code> ) und ihre Definitionen im Code <code>schema.graphql</code> .  Wenn Sie die gqlgen-Bibliothek verwenden, m√ºssen Sie Methoden zum Marshalling und Unmarshaling f√ºr alle Ihre eigenen Skalartypen bereitstellen und die Zuordnung mit <code>gqlgen.yml</code> konfigurieren. <br><br>  Es ist zu beachten, dass es in der neuesten Version der Bibliothek eine wichtige √Ñnderung gab.  Die Abh√§ngigkeit von kompilierten Bin√§rdateien wurde n√§mlich entfernt.  Daher sollte die Datei <code>scripts/gqlgen.go</code> folgenden Inhalt zum Projekt hinzugef√ºgt werden: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// +build ignore package main import "github.com/99designs/gqlgen/cmd" func main() { cmd.Execute() }</span></span></code> </pre> <br>  Danach m√ºssen Sie dep initialisieren: <br><br><pre> <code class="go hljs">dep init</code> </pre> <br>  Jetzt ist es Zeit, die Codegenerierungsfunktionen der Bibliothek zu nutzen.  Mit ihnen k√∂nnen Sie den gesamten langweiligen Boilerplate-Code erstellen, der jedoch nicht als v√∂llig uninteressant bezeichnet werden kann.  F√ºhren Sie den folgenden Befehl aus, um den automatischen Codegenerierungsmechanismus zu starten: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> init</code> </pre> <br>  Als Ergebnis seiner Ausf√ºhrung werden die folgenden Dateien erstellt: <br><br><ul><li>  <code>gqlgen.yml</code> : Konfigurationsdatei zum Verwalten der Codegenerierung. <br></li><li>  <code>generated.go</code> : generierter Code. <br></li><li>  <code>models_gen.go</code> : Alle Modelle und Datentypen des bereitgestellten Schemas. <br></li><li>  <code>resolver.go</code> : Hier ist der Code, den der Programmierer erstellt. <br></li><li>  <code>server/server.go</code> : Einstiegspunkt mit <code>http.Handler</code> zum Starten des GraphQL-Servers. <br></li></ul><br>  Sehen Sie sich das generierte Modell f√ºr den <code>Video</code> (Datei <code>generated_video.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> User        User  <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Screenshots []*Screenshot <span class="hljs-string"><span class="hljs-string">`json:"screenshots"`</span></span> Related     []Video  <span class="hljs-string"><span class="hljs-string">`json:"related"`</span></span> }</code> </pre> <br>  Hier k√∂nnen Sie sehen, dass die <code>ID</code> eine Zeichenfolge ist, <code>CreatedAt</code> ist auch eine Zeichenfolge.  Andere verwandte Modelle sind entsprechend konfiguriert.  In realen Anwendungen ist dies jedoch nicht erforderlich.  Wenn Sie einen beliebigen Typ von SQL-Daten verwenden, ben√∂tigen Sie beispielsweise, dass das <code>ID</code> Feld je nach verwendeter Datenbank ein <code>int64</code> oder <code>int64</code> . <br><br>  Zum Beispiel verwende ich PostgreSQL in dieser Demo-Anwendung, daher muss das <code>ID</code> Feld vom Typ <code>int</code> und <code>CreatedAt</code> Typ <code>time.Time</code> .  Dies f√ºhrt dazu, dass wir unser eigenes Modell definieren und gqlgen mitteilen m√ºssen, dass wir unser Modell verwenden m√ºssen, anstatt ein neues zu generieren.  Hier ist der Inhalt der Datei <code>models.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> User        User <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Related     []Video } <span class="hljs-comment"><span class="hljs-comment">//    int  ID func MarshalID(id int) graphql.Marshaler { return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.Quote(fmt.Sprintf("%d", id))) }) } //        func UnmarshalID(v interface{}) (int, error) { id, ok := v.(string) if !ok {   return 0, fmt.Errorf("ids must be strings") } i, e := strconv.Atoi(id) return int(i), e } func MarshalTimestamp(t time.Time) graphql.Marshaler { timestamp := t.Unix() * 1000 return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.FormatInt(timestamp, 10)) }) } func UnmarshalTimestamp(v interface{}) (time.Time, error) { if tmpStr, ok := v.(int); ok {   return time.Unix(int64(tmpStr), 0), nil } return time.Time{}, errors.TimeStampError }</span></span></code> </pre> <br>  Wir teilen der Bibliothek mit, dass sie diese Modelle verwenden soll (Datei <code>gqlgen.yml</code> ): <br><br><pre> <code class="go hljs">schema: - schema.graphql exec: filename: generated.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> model: filename: models_gen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> resolver: filename: resolver.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resolver models: Video:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Video ID:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.ID Timestamp:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Timestamp</code> </pre> <br>  Der Sinn all dessen ist, dass wir jetzt unsere eigenen Definitionen f√ºr <code>ID</code> und <code>Timestamp</code> mit Methoden zum Marshalling und Unmarshaling sowie zur Zuordnung in der Datei <code>gqlgen.yml</code> .  <code>UnmarshalID()</code> der Benutzer die Zeichenfolge als <code>ID</code> , <code>UnmarshalID()</code> die <code>UnmarshalID()</code> -Methode diese Zeichenfolge in eine Ganzzahl.  Beim Senden einer Antwort konvertiert die <code>MarshalID()</code> -Methode die Zahl in eine Zeichenfolge.  Das gleiche passiert mit <code>Timestamp</code> oder einem anderen vom Programmierer deklarierten Skalartyp. <br><br>  Jetzt ist es Zeit, die Anwendungslogik zu implementieren.  √ñffnen Sie die Datei <code>resolver.go</code> und f√ºgen Sie Beschreibungen von Mutationen und Abfragen hinzu.  Es gibt bereits einen automatisch generierten Boilerplate-Code, den wir mit Bedeutung f√ºllen m√ºssen.  Hier ist der Code f√ºr diese Datei: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { newVideo := api.Video{   URL:         input.URL,   Name:        input.Name,   CreatedAt:   time.Now().UTC(), } rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"INSERT INTO videos (name, url, user_id, created_at) VALUES($1, $2, $3, $4) RETURNING id"</span></span>,   input.Name, input.URL, input.UserID, newVideo.CreatedAt) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;newVideo.ID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.IsForeignKeyError(err) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.UserNotExist   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVideo, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *queryResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Videos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, limit *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, offset *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]api.Video, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> video api.Video <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videos []api.Video rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"SELECT id, name, url, created_at, user_id FROM videos ORDER BY created_at desc limit $1 offset $2"</span></span>, limit, offset) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;video.ID, &amp;video.Name, &amp;video.URL, &amp;video.CreatedAt, &amp;video.UserID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {     errors.DebugPrintf(err)     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError   }   videos = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(videos, video) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videos, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Testen wir nun die Mutation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/a2c/01f/f7ba2c01f766ebc31ed90880376136f1.png"></div>  <i><font color="#999999">Mutation createVideo</font></i> <br><br>  Es funktioniert!  Aber warum enth√§lt die Benutzerinformation ( <code>user</code> ) nichts?  Bei der Arbeit mit GraphQL gelten Konzepte, die dem "faulen" (faulen) und "gierigen" (eifrigen) Laden √§hneln.  Da dieses System erweiterbar ist, m√ºssen Sie angeben, welche Felder "gierig" und welche "faul" ausgef√ºllt werden m√ºssen. <br><br>  Ich habe dem Team in der Organisation, in der ich arbeite, die folgende ‚Äûgoldene Regel‚Äú vorgeschlagen, die f√ºr die Arbeit mit gqlgen gilt: ‚ÄûNicht in die Modellfelder aufnehmen, die nur geladen werden m√ºssen, wenn sie vom Kunden angefordert werden.‚Äú <br><br>  In unserem Fall muss ich nur dann Daten zu verwandten Videoclips (und sogar Benutzerinformationen) herunterladen, wenn der Client diese Felder anfordert.  Da wir diese Felder jedoch in das Modell aufgenommen haben, geht gqlgen davon aus, dass wir diese Daten bereitstellen, indem wir Informationen √ºber das Video erhalten.  Als Ergebnis erhalten wir jetzt leere Strukturen. <br><br>  Manchmal kommt es vor, dass jedes Mal ein bestimmter Datentyp ben√∂tigt wird. Daher ist es unpraktisch, ihn √ºber eine separate Anforderung herunterzuladen.  Um die Leistung zu verbessern, k√∂nnen Sie dazu beispielsweise SQL-Joins verwenden.  Einmal (dies gilt jedoch nicht f√ºr das hier betrachtete Beispiel) musste ich seine Metadaten zusammen mit dem Video hochladen.  Diese Entit√§ten wurden an verschiedenen Orten gespeichert.  Wenn mein System eine Anfrage zum Herunterladen eines Videos erhielt, musste ich eine weitere Anfrage stellen, um Metadaten abzurufen.  Da ich jedoch √ºber diese Anforderung Bescheid wusste (dh wusste, dass Client und Video sowie deren Metadaten immer auf der Clientseite ben√∂tigt werden), zog ich es vor, die Technik des gierigen Ladens zu verwenden, um die Leistung zu verbessern. <br><br>  Lassen Sie uns das Modell neu schreiben und den gqlgen-Code erneut generieren.  Um die Geschichte nicht zu komplizieren, schreiben wir nur Methoden f√ºr das <code>user</code> (Datei <code>models.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> UserID      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"-"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> }</code> </pre> <br>  Wir haben eine <code>User</code> <code>UserID</code> hinzugef√ºgt und die <code>User</code> entfernt.  Generieren Sie nun den Code neu: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Dank dieses Befehls werden die folgenden Schnittstellenmethoden erstellt, um undefinierte Strukturen aufzul√∂sen.  Dar√ºber hinaus m√ºssen Sie im Resolver ( <code>generated.go</code> Datei) Folgendes festlegen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> VideoResolver <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { User(ctx context.Context, obj *api.Video) (api.User, error) Screenshots(ctx context.Context, obj *api.Video) ([]*api.Screenshot, error) Related(ctx context.Context, obj *api.Video, limit *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, offset *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ([]api.Video, error) }</code> </pre> <br>  Hier ist die Definition ( <code>resolver.go</code> Datei): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { rows, _ := dal.LogAndQuery(r.db,<span class="hljs-string"><span class="hljs-string">"SELECT id, name, email FROM users where id = $1"</span></span>, obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user api.User <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Die Mutationstestergebnisse sehen nun wie unten gezeigt aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25a/41d/aaa/25a41daaa86b8db5407bd432312c3028.png"></div><br>  <i><font color="#999999">Mutation createVideo</font></i> <br><br>  Was wir gerade besprochen haben, sind die Grundlagen von GraphQL, nachdem Sie diese beherrschen, k√∂nnen Sie bereits etwas Eigenes schreiben.  Bevor Sie jedoch in Experimente mit GraphQL und Golang eintauchen, sollten Sie √ºber Abonnements sprechen, die in direktem Zusammenhang mit dem stehen, was wir hier tun. <br><br><h3>  <font color="#3AC1EF">‚ñç Abonnements</font> </h3><br>  GraphQL bietet die M√∂glichkeit, Daten√§nderungen zu abonnieren, die in Echtzeit auftreten.  Mit der gqlgen-Bibliothek k√∂nnen Sie mithilfe von Web-Sockets in Echtzeit mit Abonnementereignissen arbeiten. <br><br>  Das Abonnement muss in der Datei <code>schema.graphql</code> werden.  Hier ist die Beschreibung des Abonnements f√ºr das Video-Publishing-Ereignis: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subscription {   videoPublished: Video! }</code> </pre> <br>  F√ºhren Sie nun die automatische Codegenerierung erneut aus: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Wie bereits erw√§hnt, wird w√§hrend der automatischen Erstellung von Code in der Datei <code>generated.go</code> eine Schnittstelle erstellt, die im Erkenner implementiert werden muss.  In unserem Fall sieht es so aus ( <code>resolver.go</code> Datei): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videoPublishedChannel <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { videoPublishedChannel = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video{} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subscriptionResolver <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Resolver } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *subscriptionResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VideoPublished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> api.Video, error)</span></span></span></span> { id := randx.String(<span class="hljs-number"><span class="hljs-number">8</span></span>) videoEvent := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   &lt;-ctx.Done() }() videoPublishedChannel[id] = videoEvent <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videoEvent, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ... for _, observer := range videoPublishedChannel {   observer &lt;- newVideo } return newVideo, nil }</span></span></code> </pre> <br>  Wenn Sie jetzt ein neues Video erstellen, m√ºssen Sie ein Ereignis ausl√∂sen.  In unserem Beispiel erfolgt dies in der Zeile <code>for _, observer := range videoPublishedChannel</code> . <br><br>  Jetzt ist es Zeit, Ihr Abonnement zu √ºberpr√ºfen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/d7f/42b/f71d7f42b147f59d227a25e577ef57fb.gif"></div><br>  <i><font color="#999999">Abonnement √ºberpr√ºfen</font></i> <br><br>  GraphQL hat nat√ºrlich einige wertvolle F√§higkeiten, aber wie sie sagen, ist nicht alles, was gl√§nzt, Gold.  Wir sprechen n√§mlich √ºber die Tatsache, dass sich jemand, der GraphQL verwendet, um die Autorisierung, die Komplexit√§t von Anforderungen, das Caching, das Problem von N + 1-Anforderungen, die Begrenzung der Geschwindigkeit der Abfrageausf√ºhrung und einige andere Dinge k√ºmmern muss.  Andernfalls kann ein mit GraphQL entwickeltes System einem erheblichen Leistungsabfall ausgesetzt sein. <br><br><h2>  <font color="#3AC1EF">Fortgeschrittene Techniken: Authentifizierung, Datenlader, Abfragekomplexit√§t</font> </h2><br>  Jedes Mal, wenn ich solche Handb√ºcher lese, habe ich das Gef√ºhl, dass ich, nachdem ich sie beherrsche, alles lerne, was ich √ºber eine bestimmte Technologie wissen muss, und die F√§higkeit bekomme, Probleme jeder Komplexit√§t zu l√∂sen. <br><br>  Wenn ich jedoch anfange, an meinen eigenen Projekten zu arbeiten, gerate ich normalerweise in unvorhergesehene Situationen, die wie Serverfehler oder Anforderungen aussehen, die seit Ewigkeiten ausgef√ºhrt werden, oder wie andere Deadlock-Situationen.  Um dies zu tun, muss ich mich daher besser mit dem befassen, was in letzter Zeit vollkommen verst√§ndlich schien.  In diesem Handbuch hoffe ich, dass dies vermieden werden kann.  Aus diesem Grund werden wir uns in diesem Abschnitt mit einigen fortgeschrittenen Techniken f√ºr die Arbeit mit GraphQL befassen. <br><br><h3>  <font color="#3AC1EF">‚ñç Authentifizierung</font> </h3><br>  Bei der Arbeit mit der REST-API verf√ºgen wir √ºber ein Authentifizierungssystem und Standardautorisierungstools, wenn Sie mit einem bestimmten Endpunkt arbeiten.  Bei Verwendung von GraphQL wird jedoch nur ein Endpunkt verwendet. Daher k√∂nnen Authentifizierungsaufgaben mithilfe von Schemaanweisungen gel√∂st werden.  Bearbeiten Sie die Datei <code>schema.graphql</code> wie folgt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! @isAuthenticated } directive @isAuthenticated on FIELD_DEFINITION</code> </pre> <br>  Wir haben die <code>isAuthenticated</code> Direktive erstellt und auf das <code>createVideo</code> Abonnement <code>createVideo</code> .  Nach der n√§chsten Sitzung zur automatischen Codegenerierung m√ºssen Sie eine Definition f√ºr diese Anweisung definieren.  Jetzt werden Direktiven in Form von Methoden von Strukturen implementiert und nicht in Form von Schnittstellen, daher m√ºssen wir sie beschreiben.  Ich habe den automatisch generierten Code in der Datei <code>server.go</code> bearbeitet und eine Methode erstellt, die die GraphQL-Konfiguration f√ºr die Datei <code>server.go</code> .  Hier ist die Datei <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>  Hier ist die Datei <code>server.go</code> : <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware(   db,   handler.GraphQL(     go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)   ) ) http.Handle(<span class="hljs-string"><span class="hljs-string">"/query"</span></span>, auth.AuthMiddleware(rootHandler))</code> </pre> <br>  Wir lesen die Benutzer- <code>ID</code> aus dem Kontext.  Findest du das nicht seltsam?  Wie kam diese Bedeutung in den Kontext und warum erschien sie √ºberhaupt im Kontext?  Tatsache ist, dass gqlgen Anforderungskontexte nur auf Implementierungsebene bereitstellt, sodass wir keine M√∂glichkeit haben, HTTP-Anforderungsdaten wie Header oder Cookies in Erkennern oder Anweisungen zu lesen.  Daher m√ºssen Sie dem System Ihre eigenen Zwischenmechanismen hinzuf√ºgen, diese Daten empfangen und in einen Kontext setzen. <br><br>  Jetzt m√ºssen wir unseren eigenen Zwischenauthentifizierungsmechanismus beschreiben, um Authentifizierungsdaten aus der Anforderung zu erhalten und diese zu √ºberpr√ºfen. <br><br>  Hier ist keine Logik definiert.  Stattdessen wird zu Berechtigungsdaten zu Demonstrationszwecken die Benutzer- <code>ID</code> einfach hier √ºbergeben.  Dieser Mechanismus wird dann in <code>server.go</code> mit einer neuen Konfigurationslademethode kombiniert. <br><br>  Nun macht die Beschreibung der Richtlinie Sinn.  Wir verarbeiten keine nicht autorisierten Benutzeranfragen im Middleware-Code, da solche Anfragen von der Direktive verarbeitet werden.  So sieht es aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f6/a26/09c/6f6a2609cec8936c024fd68c7ed30096.png"></div><br>  <i><font color="#999999">Arbeiten Sie mit einem nicht autorisierten Benutzer</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/b92/378/267b923783521a82738973f82600a2a4.png"></div><br>  <i><font color="#999999">Arbeiten Sie mit einem autorisierten Benutzer</font></i> <br><br>  Wenn Sie mit Schema-Direktiven arbeiten, k√∂nnen Sie sogar Argumente √ºbergeben: <br><br><pre> <code class="go hljs">directive @hasRole(role: Role!) on FIELD_DEFINITION enum Role { ADMIN USER }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçDatenlader</font> </h3><br>  Es scheint mir, dass das alles ziemlich interessant aussieht.  Sie laden Daten herunter, wenn Sie sie ben√∂tigen.  Clients haben die M√∂glichkeit, Daten zu verwalten. Genau das, was ben√∂tigt wird, wird aus dem Speicher entnommen.  Aber alles hat einen Preis. <br><br>  Was ist der Preis f√ºr diese M√∂glichkeiten?  Schauen Sie sich die Download-Protokolle aller Videos an.  Wir sprechen n√§mlich √ºber die Tatsache, dass wir 8 Videos und 5 Benutzer haben. <br><br><pre> <code class="go hljs">query{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>){   name   user{     name   } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/7c1/b5c/5627c1b5c34f74aec26381f8b0431147.png"></div><br>  <i><font color="#999999">Video-Download-Details</font></i> <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Was ist hier los?  Warum gibt es 9 Anfragen (1 Anfrage ist der Videotabelle zugeordnet und 8 - der Benutzertabelle)?  Es sieht schrecklich aus.  Mein Herz blieb fast stehen, als ich dachte, dass unsere vorhandene API durch diese ersetzt werden m√ºsste ... Richtig, Datenlader k√∂nnen dieses Problem vollst√§ndig bew√§ltigen. <br><br>  Dies ist als N + 1-Problem bekannt. Wir sprechen √ºber die Tatsache, dass es eine Abfrage gibt, um alle Daten abzurufen, und f√ºr jedes Datenelement (N) gibt es eine andere Abfrage an die Datenbank. <br><br>  Dies ist ein sehr ernstes Problem in Bezug auf Leistung und Ressourcen: Obwohl diese Anforderungen parallel sind, belasten sie die Systemressourcen. <br><br>  Um dieses Problem zu l√∂sen, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dataloaden-</a> Bibliothek des Autors der gqlgen-Bibliothek.  Mit dieser Bibliothek k√∂nnen Sie Go-Code generieren.  Generieren Sie zun√§chst einen Datenlader f√ºr die <code>User</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/vektah/dataloaden dataloaden github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.User</code> </pre> <br>  Wir verf√ºgen √ºber die Datei <code>userloader_gen.go</code> , die Methoden wie <code>Fetch</code> , <code>LoadAll</code> und <code>Prime</code> . <br><br>  Um allgemeine Ergebnisse zu erhalten, m√ºssen wir nun die <code>Fetch</code> Methode (Datei <code>dataloader.go</code> ) definieren: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataloaderMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> {   userloader := UserLoader{     wait : <span class="hljs-number"><span class="hljs-number">1</span></span> * time.Millisecond,     maxBatch: <span class="hljs-number"><span class="hljs-number">100</span></span>,     fetch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*api.User, []error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids) == <span class="hljs-number"><span class="hljs-number">1</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id = ?"</span></span>       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id IN (?)"</span></span>       }       sqlQuery, arguments, err := sqlx.In(sqlQuery, ids)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       sqlQuery = sqlx.Rebind(sqlx.DOLLAR, sqlQuery)       rows, err := dal.LogAndQuery(db, sqlQuery, arguments...)       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       userById := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]*api.User{}       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {         user:= api.User{}         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {           errors.DebugPrintf(err)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []error{errors.InternalServerError}         }         userById[user.ID] = &amp;user       }       users := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*api.User, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids))       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, id := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ids {         users[i] = userById[id]         i++       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>     },   }   ctx := context.WithValue(r.Context(), CtxKey, &amp;userloader)   r = r.WithContext(ctx)   next.ServeHTTP(w, r) }) }</code> </pre> <br>  Hier warten wir 1 ms.  bevor Sie die Anforderung ausf√ºhren und die Anforderungen in Paketen mit bis zu 100 Anforderungen sammeln.  Anstatt jetzt eine Anforderung f√ºr jeden Benutzer einzeln auszuf√ºhren, wartet der Loader jetzt auf die angegebene Zeit, bevor er auf die Datenbank zugreift.  Als N√§chstes m√ºssen Sie die Erkennungslogik √§ndern, indem Sie sie mithilfe der Anforderung zur Verwendung des Datenladers (Datei <code>resolver.go</code> ) neu konfigurieren: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { user, err := ctx.Value(dataloaders.CtxKey).(*dataloaders.UserLoader).Load(obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *user, err }</code> </pre> <br>  So sehen die Protokolle danach in einer √§hnlichen Situation wie oben beschrieben aus: <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Dataloader: User : SELECT id, name, email from users WHERE id IN ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, $<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  Hier werden nur zwei Datenbankabfragen ausgef√ºhrt, sodass alle zufrieden sind.  Es ist interessant festzustellen, dass nur 5 Benutzer-IDs an die Anforderung gesendet werden, obwohl Daten f√ºr 8 Videos angefordert werden.  Dies deutet darauf hin, dass der Datenlader doppelte Datens√§tze entfernt. <br><br><h3> <font color="#3AC1EF">‚ñç </font> </h3><br> GraphQL   API  ,    .    ,   API   DOS-. <br><br>     ,     . <br><br>   <code>Video</code>  ,   .      GraphQL  <code>Video</code> .           .   ‚Äî  . <br><br>  ,      ‚Äî   : <br><br><pre> <code class="go hljs">{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){   name   url   related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){     name     url     related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){       name       url       related(limit: <span class="hljs-number"><span class="hljs-number">100</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){         name         url       }     }   } } }</code> </pre> <br>           100,        .  (, , )    ,         . <br><br>  gqlgen      ,     .     ,       ( <code>handler.ComplexityLimit(300)</code>   )   GraphQL     (300   ).  ,     ( <code>server.go</code> ): <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware( db, handler.GraphQL(   go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)),   handler.ComplexityLimit(<span class="hljs-number"><span class="hljs-number">300</span></span>) ), )</code> </pre> <br>       ,   ,        .        12.   ,       ,   ,      ( ,  ,  ,   ,     ).    <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//  countComplexity := func(childComplexity int, limit *int, offset *int) int {   return *limit * childComplexity } c.Complexity.Query.Videos = countComplexity c.Complexity.Video.Related = countComplexity //   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>     ,     ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/702/045/d0a7020450bf5115f69c6a1ba61beca4.png"></div><br> <i><font color="#999999">    </font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/057/fec/7e3/057fec7e30f98b63aed8bbb6aec5193f.png"></div><br> <i><font color="#999999">      </font></i> <br><br>       ,   ,   <code>related</code>  . , , ,      ,             . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br> ,        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> .         .       ,     ,      . <br><br>  <b>Liebe Leser!</b>     GraphQL  ,   Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444346/">https://habr.com/ru/post/de444346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444336/index.html">Schnelle Erfassungslisten: Was ist der Unterschied zwischen schwachen, starken und nicht besessenen Links?</a></li>
<li><a href="../de444338/index.html">Kapselung in Python 3</a></li>
<li><a href="../de444340/index.html">Funktionen zur Verwendung des Symboldatentyps in JavaScript</a></li>
<li><a href="../de444342/index.html">Entwicklung einfacher, moderner JavaScript-Anwendungen mit Webpack und fortschrittlichen Webtechnologien</a></li>
<li><a href="../de444344/index.html">10 Schritte zu einem erfolgreichen Python-Projekt</a></li>
<li><a href="../de444348/index.html">Wie unterscheiden sich funktionale React-Komponenten von klassenbasierten Komponenten?</a></li>
<li><a href="../de444350/index.html">Aus irgendeinem Grund startet MVP (Minimum Viable Product) nicht</a></li>
<li><a href="../de444352/index.html">Kontur.Kampus: Wir laden Sie zu einem kostenlosen Studentenlager f√ºr industrielle Entwicklung in der N√§he von St. Petersburg ein</a></li>
<li><a href="../de444356/index.html">React Tutorial Teil 24: Lektion f√ºr zweite Formen</a></li>
<li><a href="../de444358/index.html">Aufz√§hlbar: So erzielen Sie einen Gesch√§ftswert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>