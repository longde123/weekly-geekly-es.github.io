<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•í ü§ï üå®Ô∏è Le√ßon du soir: √©criture de la coloration syntaxique üå≥ üòπ ü•®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, je me suis int√©ress√© √† la fa√ßon dont la mise en √©vidence du code est organis√©e de l'int√©rieur. Au d√©but, il semblait que tout y √©tait extr√™...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le√ßon du soir: √©criture de la coloration syntaxique</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482884/">  R√©cemment, je me suis int√©ress√© √† la fa√ßon dont la mise en √©vidence du code est organis√©e de l'int√©rieur.  Au d√©but, il semblait que tout y √©tait extr√™mement compliqu√© - un arbre de syntaxe, une r√©cursivit√©, et c'√©tait tout.  Cependant, √† y regarder de plus pr√®s, il s'est av√©r√© qu'il n'y a rien de difficile ici.  Tout le travail peut √™tre effectu√© en un seul cycle avec des allers-retours, de plus, les expressions r√©guli√®res ne sont presque jamais utilis√©es dans le script r√©sultant. <br><br>  Page de d√©monstration: <a href="https://astynk.github.io/highlight.html">Surligneur de code Javascript</a> <br><a name="habracut"></a><br><h2>  Id√©e principale </h2><br>  Nous d√©clarons la variable d' <i>√©tat</i> , qui stockera des informations sur la partie du code dans laquelle nous nous trouvons.  Si, par exemple, l' <i>√©tat</i> est √©gal √† un, cela signifie que nous sommes √† l'int√©rieur d'une cha√Æne avec des guillemets simples.  Le script attendra la citation de cl√¥ture et ignorera tout le reste.  La m√™me chose avec la mise en √©vidence des commentaires, des expressions rationnelles et d'autres √©l√©ments, chacun a sa propre valeur d' <i>√©tat</i> .  Ainsi, diff√©rents caract√®res d'ouverture et de fermeture n'entreront pas en conflit;  en d'autres termes, un code comme celui-ci: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'"\'"'</span></span>;</code> </pre> <br>  seront correctement mis en √©vidence, √† savoir, ces cas ont caus√© le plus de difficult√©s. <br><br><h2>  Pour commencer </h2><br>  Nous d√©terminons les valeurs possibles de la variable d'√©tat, ainsi que la couleur dans laquelle telle ou telle partie du code sera color√©e, ainsi qu'une liste de mots-cl√©s Javascript (qui seront √©galement mis en √©vidence): <br><br><div class="spoiler">  <b class="spoiler_title">√©tats const = {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> states = { <span class="hljs-attr"><span class="hljs-attr">NONE</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">SINGLE_QUOTE</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 'string' DOUBLE_QUOTE : 2, // "string" ML_QUOTE : 3, // `string` REGEX_LITERAL : 4, // /regex/ SL_COMMENT : 5, // // single line comment ML_COMMENT : 6, // /* multiline comment */ NUMBER_LITERAL : 7, // 123 KEYWORD : 8 // function, var etc. }; const colors = { NONE : '#000', SINGLE_QUOTE : '#aaa', // 'string' DOUBLE_QUOTE : '#aaa', // "string" ML_QUOTE : '#aaa', // `string` REGEX_LITERAL : '#707', // /regex/ SL_COMMENT : '#0a0', // // single line comment ML_COMMENT : '#0a0', // /* multiline comment */ NUMBER_LITERAL : '#a00', // 123 KEYWORD : '#00a', // function, var etc. OPERATOR : '#07f' // null, true etc. }; const keywords = 'async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|set|static|super|switch|throw|try|typeof|var|void|while|with|yield|catch|finally'.split('|');</span></span></code> </pre><br></div></div><br>  Ensuite, nous cr√©ons une fonction qui prendra une ligne avec le code et retournera le code HTML fini avec le code en surbrillance.  Pour la mise en √©vidence, les caract√®res seront envelopp√©s dans SPAN avec la couleur sp√©cifi√©e dans la variable de <i>couleurs</i> . <br><br>  La fonction n'aura qu'un seul cycle, qui analyse chaque caract√®re et ajoute des SPAN d'ouverture / fermeture si n√©cessaire. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highlight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = states.NONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; code.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> char = code[i], prev = code[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], next = code[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     } return output; }</span></span></code> </pre> <br>  Tout d'abord, mettez en surbrillance les commentaires: monoligne et multiligne.  Si le caract√®re actuel et suivant est une barre oblique, et qu'ils ne sont pas √† l'int√©rieur de la ligne (l' <i>√©tat</i> est 0, c'est-√†-dire, <i>states.NONE</i> ), alors c'est le d√©but du commentaire.  Changez d' <i>√©tat</i> et ouvrez SPAN avec la couleur souhait√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.SL_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SL_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  <i>continue est</i> n√©cessaire pour que les v√©rifications suivantes ne fonctionnent pas et qu'aucun conflit ne se produise. <br><br>  Ensuite, nous attendons la fin de la ligne: si le caract√®re actuel est un saut de ligne et dans l' <i>√©tat un</i> commentaire sur <i>une</i> seule ligne, fermez le SPAN et changez l' <i>√©tat</i> √† z√©ro: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SL_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  De m√™me, nous recherchons des commentaires sur plusieurs lignes, l'algorithme est exactement le m√™me, seuls les caract√®res que vous recherchez sont diff√©rents: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.ML_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  La mise en surbrillance des cha√Ænes se produit de la m√™me mani√®re, seulement il doit √™tre pris en compte que le guillemet fermant peut √™tre √©chapp√© avec une barre oblique inverse, et ainsi, il cesse d√©j√† d'√™tre une barre oblique de fermeture. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span>) { state = states.SINGLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SINGLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Le code est similaire √† ce qui √©tait d√©j√† ci-dessus, seulement maintenant nous n'enregistrons pas la fin de la ligne s'il y avait une barre oblique inverse avant le devis. <br><br>  La d√©finition des cha√Ænes entre guillemets doubles se produit exactement de la m√™me mani√®re et il est peu logique de les analyser en d√©tail.  Pour compl√©ter l'image, je vais les placer sous le spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">if (state == states.NONE &amp;&amp; char == '' '') {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { state = states.DOUBLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.DOUBLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.DOUBLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span>) { state = states.ML_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br>  Les litt√©raux d'expression r√©guli√®re, qui sont facilement confondus avec le signe de division, m√©ritent une consid√©ration s√©par√©e.  Nous reviendrons sur ce probl√®me √† la fin de l'article, mais pour l'instant nous faisons la m√™me chose avec les regexps qu'avec les cha√Ænes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.REGEX_LITERAL &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Cela met fin √† des cas simples lorsque le d√©but et la fin d'un litt√©ral peuvent √™tre d√©termin√©s par 1 √† 2 caract√®res.  Commen√ßons par mettre en √©vidence les nombres: comme vous le savez, ils commencent toujours par un nombre, mais peuvent avoir des lettres dans la composition ( <i>0xFF</i> , <i>123n</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]/</span></span>.test(char) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-z$_]/i</span></span>.test(prev)) { state = states.NUMBER_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.NUMBER_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NUMBER_LITERAL &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-fnx]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span> }</code> </pre> <br>  Ici, nous recherchons le d√©but d'un nombre: le caract√®re pr√©c√©dent ne doit pas √™tre un chiffre ou une lettre, sinon les chiffres dans les noms de variables seront mis en √©vidence.  D√®s que le caract√®re actuel n'est pas un nombre ou une lettre pouvant √™tre contenu dans le litt√©ral d'un nombre, fermez le SPAN et d√©finissez l' <i>√©tat sur</i> z√©ro. <br><br>  Tous les types de litt√©raux possibles sont mis en √©vidence, la recherche de mots cl√©s reste.  Pour ce faire, vous avez besoin d'une boucle imbriqu√©e qui regarde vers l'avenir et d√©termine si le caract√®re actuel est le d√©but du mot-cl√©. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[a-z0-9$_]/i</span></span>.test(prev)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (code[i + j] &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(code[i + j])) { word += code[i + j]; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keywords.includes(word)) { state = states.KEYWORD; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.KEYWORD + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>; } }</code> </pre> <br>  Ici, nous regardons, le caract√®re pr√©c√©dent ne peut pas √™tre dans le nom de la variable, sinon <i>laissez</i> comme le mot-cl√© sera mis en √©vidence dans le mot <i>sortie</i> .  Ensuite, la boucle imbriqu√©e recueille le mot le plus long possible jusqu'√† ce qu'un caract√®re non alphab√©tique soit rencontr√©.  Si le mot re√ßu se trouve dans le tableau des <i>mots cl√©s</i> , ouvrez l'ENVERGURE et commencez √† mettre le mot en surbrillance.  D√®s qu'un caract√®re non alphab√©tique est rencontr√©, cela signifie la fin du mot - en cons√©quence, fermez le SPAN: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.KEYWORD &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; }</code> </pre> <br>  La chose la plus simple reste - la mise en √©vidence des op√©rateurs, ici vous pouvez simplement comparer avec le jeu de caract√®res qui peut se produire dans les op√©rateurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-string"><span class="hljs-string">'+-/*=&amp;|%!&lt;&gt;?:'</span></span>.indexOf(char) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.OPERATOR + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  √Ä la fin de la boucle, si aucune des conditions qui <i>continuent, la</i> cause n'est d√©clench√©e, nous ajoutons simplement le caract√®re actuel √† la variable r√©sultante.  Lorsque le d√©but ou la fin d'un litt√©ral ou d'un mot cl√© se produit, nous ouvrons / fermons le SPAN avec la couleur;  dans tous les autres cas - par exemple, lorsque la ligne est d√©j√† ouverte, nous ne jetons qu'un caract√®re √† la fois.  Il convient √©galement de prot√©ger les supports d'angle d'ouverture, sinon ils peuvent casser la disposition. <br><br><pre> <code class="javascript hljs">output += char.replace(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + <span class="hljs-string"><span class="hljs-string">'lt;'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  +      &lt;</span></span></code> </pre> <br><h2>  Correction d'un bug </h2><br>  Tout semblait en quelque sorte trop simple, et pas en vain: avec des tests plus approfondis, il y avait des cas o√π le r√©tro-√©clairage ne fonctionnait pas correctement. <br><br>  La division est reconnue comme expression rationnelle, afin de distinguer l'une de l'autre, il sera n√©cessaire de changer la fa√ßon dont l'expression rationnelle est d√©termin√©e.  Nous d√©clarons la variable <i>isRegex = true</i> , apr√®s quoi nous essaierons de ¬´prouver¬ª qu'il ne s'agit pas d'une expression rationnelle, mais d'un signe de division.  Il ne peut pas y avoir de mots cl√©s ou de crochets ouvrants avant l'op√©ration de division - par cons√©quent, nous cr√©ons une boucle imbriqu√©e et voyons √† quoi la barre oblique fait face. <br><br><div class="spoiler">  <b class="spoiler_title">Comme avant</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, isRegex = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i + j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { j--; <span class="hljs-comment"><span class="hljs-comment">//        if ('+/-*=|&amp;&lt;&gt;%,({[?:;'.indexOf(code[i+j]) != -1) break; //   ;   -   if (!/[0-9a-z$_]/i.test(code[i+j]) &amp;&amp; word.length &gt; 0) break; //  ,     if (/[0-9a-z$_]/i.test(code[i+j])) word = code[i+j] + word; //   - ,     if (')]}'.indexOf(code[i+j]) != -1) { isRegex = false; break; } } //      -    //  : return /test/g - , plainWord /test/g -  if (word.length &gt; 0 &amp;&amp; !keywords.includes(word)) isRegex = false; if (isRegex) { state = states.REGEX_LITERAL; output += '&lt;span style="color: ' + colors.REGEX_LITERAL + '"&gt;' + char; continue; } }</span></span></code> </pre> <br>  Bien que cette approche r√©sout le probl√®me, elle n'est toujours pas sans d√©fauts.  Vous pouvez l'ajuster pour que cet algorithme soit √©galement mis en surbrillance de mani√®re incorrecte, par exemple: <i>si (a) / regex /</i> ou alors: <i>1 / / regex / / 2</i> .  Pourquoi une personne qui divise des nombres en expression r√©guli√®re a-t-elle besoin de mettre en √©vidence le code - c'est une autre question;  la conception est syntaxiquement correcte, bien qu'elle ne se produise pas dans la vraie vie. <br><br>  Il y a des probl√®mes avec la coloration regexp dans de nombreux travaux, par exemple dans <a href="https://prismjs.com/test.html">prism.js</a> .  Apparemment, pour la mise en √©vidence correcte des expressions rationnelles, vous devez bien comprendre la syntaxe, comme le font les navigateurs. <br><br>  Le deuxi√®me bug que j'ai d√ª g√©rer √©tait li√© aux barres obliques inverses.  Un guillemet de fermeture n'a pas √©t√© reconnu dans une cha√Æne de la forme <i>¬´test \\¬ª en</i> raison de la pr√©sence d'une barre oblique inverse devant.  Retour √† la condition qui rattrape la fin de la ligne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>)</code> </pre> <br>  La derni√®re partie de la condition doit √™tre modifi√©e: si la barre oblique invers√©e est √©chapp√©e (c'est-√†-dire qu'il y a une autre barre oblique inverse avant), enregistrez la fin de la ligne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> closingCharNotEscaped = prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> || prev == <span class="hljs-string"><span class="hljs-string">'\\'</span></span> &amp;&amp; code[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... if (state == states.SINGLE_QUOTE &amp;&amp; char == '\'' &amp;&amp; closingCharNotEscaped)</span></span></code> </pre> <br>  Les m√™mes remplacements doivent √™tre effectu√©s dans la recherche de cha√Ænes avec des guillemets doubles et inverses, ainsi que dans la recherche d'expressions rationnelles. <br><br>  C'est tout, vous pouvez tester le surlignage par le lien au d√©but de l'article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482884/">https://habr.com/ru/post/fr482884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482872/index.html">Des polygones dans un autre monde</a></li>
<li><a href="../fr482874/index.html">La mort de Koshchei dans la liste des recommandations (pouvez-vous rendre YouTube confortable et s√ªr?)</a></li>
<li><a href="../fr482876/index.html">Calcul du co√ªt de production d'√©lectricit√© solaire pour les besoins propres d'un m√©nage dans le centre de l'Europe</a></li>
<li><a href="../fr482878/index.html">Comment j'ai recherch√© la d√©finition de ¬´produit¬ª</a></li>
<li><a href="../fr482882/index.html">Le moteur comme frein √©lectromagn√©tique</a></li>
<li><a href="../fr482886/index.html">Analyse Habra: la dur√©e de publication est-elle importante?</a></li>
<li><a href="../fr482888/index.html">Lancement d'un serveur VPN derri√®re le fournisseur NAT</a></li>
<li><a href="../fr482892/index.html">Soit vs const - quoi utiliser?</a></li>
<li><a href="../fr482894/index.html">G√©n√©ration proc√©durale adaptative utilisant l'algorithme WaveFunctionCollapse et la distribution de probabilit√© a priori</a></li>
<li><a href="../fr482896/index.html">OSCP - Mon exp√©rience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>