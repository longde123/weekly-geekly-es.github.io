<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ üë©üèª‚Äçü§ù‚Äçüë®üèø üôçüèø Implementierung eines Hot-Reloads von C ++ - Code unter Linux üö∂üèø üÜö üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Link zur Bibliothek am Ende des Artikels. Der Artikel selbst beschreibt die in der Bibliothek implementierten Mechanismen mit mittleren Details. Die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung eines Hot-Reloads von C ++ - Code unter Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="Bild"></p><br><p>  * Link zur Bibliothek am Ende des Artikels.  Der Artikel selbst beschreibt die in der Bibliothek implementierten Mechanismen mit mittleren Details.  Die Implementierung f√ºr macOS ist noch nicht abgeschlossen, unterscheidet sich jedoch nicht wesentlich von der Implementierung f√ºr Linux.  Dies ist haupts√§chlich eine Implementierung f√ºr Linux. </p><br><p>  Als ich an einem Samstagnachmittag √ºber den Github ging, stie√ü ich auf eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> , in der die Aktualisierung von C ++ - Code f√ºr Windows im laufenden Betrieb implementiert wird.  Ich selbst bin vor ein paar Jahren von Windows heruntergekommen, habe es nicht ein bisschen bereut, und jetzt erfolgt die gesamte Programmierung entweder unter Linux (zu Hause) oder unter MacOS (bei der Arbeit).  Beim Googeln stellte ich fest, dass der Ansatz aus der obigen Bibliothek sehr beliebt ist und msvc dieselbe Technik f√ºr die Funktion "Bearbeiten und fortfahren" in Visual Studio verwendet.  Das einzige Problem ist, dass ich unter Nicht-Fenstern keine Implementierungen gefunden habe (habe ich schlecht ausgesehen?).  Auf die Frage an den Autor der Bibliothek oben, ob er einen Port f√ºr andere Plattformen erstellen wird, lautete die Antwort nein. </p><br><p>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">muss sofort sagen,</a> dass ich nur an der Option interessiert war, bei der ich den vorhandenen Projektcode nicht √§ndern m√ºsste (wie zum Beispiel im Fall von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RCCPP</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cr</a> , wo sich der gesamte potenziell neu geladene Code in einer separaten dynamisch geladenen Bibliothek befinden sollte). </p><br><p>  "Wie so?"  - Ich dachte und fing an, Weihrauch anzuz√ºnden. </p><a name="habracut"></a><br><h2 id="zachem">  Warum? </h2><br><p>  Ich mache haupts√§chlich Gamedev.  Die meiste Zeit meiner Arbeit verbringe ich damit, Spielelogik und Layout f√ºr jedes Bild zu schreiben.  Ich benutze imgui auch f√ºr Hilfsdienstprogramme.  Mein Zyklus der Arbeit mit dem Code ist, wie Sie wahrscheinlich vermutet haben, Schreiben -&gt; Kompilieren -&gt; Ausf√ºhren -&gt; Wiederholen.  Alles geschieht ziemlich schnell (inkrementeller Build, alle Arten von Ccache usw.).  Das Problem hierbei ist, dass dieser Zyklus oft genug wiederholt werden muss.  Zum Beispiel schreibe ich eine neue Spielmechanik, sei es "Jump", ein g√ºltiger, kontrollierter Jump: </p><br><p>  1. Schrieb einen Entwurf der Implementierung basierend auf der Dynamik, zusammengestellt, gestartet.  Ich habe gesehen, dass ich versehentlich einen Impuls auf jedes Bild angewendet habe und nicht einmal. </p><br><p>  2. Fest, zusammengebaut, gestartet, jetzt normal.  Aber es w√§re notwendig, den absoluten Wert des Impulses mehr zu nehmen. </p><br><p>  3. Fest, zusammengebaut, gestartet, funktioniert.  Aber irgendwie f√ºhlt es sich falsch an.  Es ist notwendig, auf der Grundlage der St√§rke zu versuchen, zu tun. </p><br><p>  4. Schrieb einen Implementierungsentwurf basierend auf St√§rke, zusammengestellt, gestartet, funktioniert.  Es w√§re nur notwendig, die momentane Geschwindigkeit zum Zeitpunkt des Sprunges zu √§ndern. <br>  ... </p><br><p> 10. Fest, zusammengebaut, gestartet, funktioniert.  Aber immer noch nicht das.  <code>gravityScale</code> m√ºssen Sie eine Implementierung versuchen, die auf einer √Ñnderung der <code>gravityScale</code> . <br>  ... </p><br><p>  20. Gro√üartig, es sieht super aus!  Jetzt nehmen wir alle Parameter im Editor f√ºr das Spiel heraus, testen und f√ºllen. <br>  ... </p><br><p>  30. Der Sprung ist fertig. </p><br><p>  Und bei jeder Iteration m√ºssen Sie den Code sammeln und in der gestarteten Anwendung an die Stelle gelangen, an der ich springen kann.  Dies dauert normalerweise mindestens 10 Sekunden.  Und wenn ich nur in einen offenen Bereich springen kann, der noch erreicht werden muss?  Und wenn ich in der Lage sein muss, auf Bl√∂cke mit einer H√∂he von N Einheiten zu springen?  Hier muss ich bereits eine Testszene sammeln, die ebenfalls debuggt werden muss und die auch Zeit verbringen muss.  F√ºr solche Iterationen w√§re ein Hot-Reload von Code ideal.  Nat√ºrlich ist dies kein Allheilmittel, es ist nicht f√ºr alles geeignet. Nach einem Neustart m√ºssen Sie manchmal einen Teil der Spielwelt neu erstellen, und dies muss ber√ºcksichtigt werden.  In vielen F√§llen kann dies jedoch n√ºtzlich sein und Aufmerksamkeit und viel Zeit sparen. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Anforderungen und Erkl√§rung des Problems </h2><br><ul><li>  Beim √Ñndern des Codes sollte die neue Version aller Funktionen die alten Versionen derselben Funktionen ersetzen </li><li>  Dies sollte unter Linux und MacOS funktionieren </li><li>  Dies sollte keine √Ñnderungen am vorhandenen Anwendungscode erfordern. </li><li>  Im Idealfall sollte dies eine Bibliothek sein, die statisch oder dynamisch mit der Anwendung verkn√ºpft ist und keine Dienstprogramme von Drittanbietern enth√§lt </li><li>  Es ist w√ºnschenswert, dass diese Bibliothek die Anwendungsleistung nicht stark beeinflusst. </li><li>  Genug, wenn dies mit cmake + make / ninja funktioniert </li><li>  Es reicht aus, wenn es mit Debazin-Builds funktioniert (ohne Optimierungen, ohne Zuschneiden von Zeichen usw.). </li></ul><br><p>  Dies ist die Mindestanforderung, die eine Implementierung erf√ºllen muss.  Mit Blick auf die Zukunft werde ich kurz beschreiben, was zus√§tzlich implementiert wurde: </p><br><ul><li>  √úbertragen von Werten statischer Variablen in neuen Code (siehe Abschnitt "√úbertragen statischer Variablen", um herauszufinden, warum dies wichtig ist) </li><li>  Neuladen basierend auf Abh√§ngigkeiten (ge√§nderter Header -&gt; neu erstellt <del>  ein halbes Projekt </del>  alle abh√§ngigen Dateien) </li><li>  Code aus dynamischen Bibliotheken neu laden </li></ul><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Bis zu diesem Moment war ich v√∂llig weit vom Themenbereich entfernt, daher musste ich Informationen von Grund auf sammeln und verarbeiten. </p><br><p>  Auf hoher Ebene sieht der Mechanismus folgenderma√üen aus: </p><br><ul><li>  Wir √ºberwachen das Dateisystem auf √Ñnderungen in der Quelle </li><li>  Wenn sich die Quelle √§ndert, erstellt die Bibliothek sie mithilfe des Kompilierungsbefehls neu, mit dem diese Datei bereits kompiliert wurde </li><li>  Alle gesammelten Objekte sind mit einer dynamisch geladenen Bibliothek verkn√ºpft </li><li>  Die Bibliothek wird in den Prozessadressraum geladen </li><li>  Alle Funktionen aus der Bibliothek ersetzen dieselben Funktionen in der Anwendung. </li><li>  Die Werte statischer Variablen werden von der Anwendung in die Bibliothek √ºbertragen </li></ul><br><p>  Beginnen wir mit dem interessantesten - dem Mechanismus zum erneuten Laden von Funktionen. </p><br><h4 id="perezagruzka-funkciy">  Funktionen zum Nachladen </h4><br><p>  Hier sind 3 mehr oder weniger beliebte M√∂glichkeiten, um Funktionen in (oder fast) zur Laufzeit zu ersetzen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trick mit LD_PRELOAD</a> - Erm√∂glicht es Ihnen, eine dynamisch geladene Bibliothek mit beispielsweise der Funktion <code>strcpy</code> und so zu gestalten, dass beim Starten der Anwendung meine Version von <code>strcpy</code> anstelle der Bibliothek verwendet wird </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PLT- und GOT-Tabellen</a> √§ndern - Erm√∂glicht das "√úberladen" exportierter Funktionen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktions-Hooking</a> - Erm√∂glicht das Umleiten des Ausf√ºhrungsthreads von einer Funktion zur anderen </li></ul><br><p>  Die ersten beiden Optionen sind nat√ºrlich nicht geeignet, da sie nur mit exportierten Funktionen funktionieren und wir nicht alle Funktionen unserer Anwendung mit Attributen markieren m√∂chten.  Daher ist Function Hooking unsere Option! </p><br><p>  Kurz gesagt, das Einhaken funktioniert folgenderma√üen: </p><br><ul><li>  Die Funktionsadresse wird gefunden </li><li>  Die ersten paar Bytes der Funktion werden durch einen bedingungslosen √úbergang zum K√∂rper einer anderen Funktion √ºberschrieben </li><li>  ... </li><li>  Gewinn! <br>  In msvc gibt es 2 Flags f√ºr dieses - <code>/hotpatch</code> und <code>/FUNCTIONPADMIN</code> .  Der erste am Anfang jeder Funktion schreibt 2 Bytes, die nichts tun, f√ºr das anschlie√üende Umschreiben mit einem "kurzen Sprung".  Mit der zweiten Option k√∂nnen Sie vor dem K√∂rper jeder Funktion einen leeren Raum in Form von <code>nop</code> Anweisungen f√ºr einen "Weitsprung" zum gew√ºnschten Ort lassen, sodass Sie in zwei Spr√ºngen von der alten Funktion zur neuen wechseln k√∂nnen.  Weitere Informationen dazu, wie dies beispielsweise in Windows und MSVC implementiert ist, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br><p>  Leider gibt es in clang und gcc nichts Vergleichbares (zumindest unter Linux und macOS).  Eigentlich ist das kein so gro√ües Problem, wir werden direkt √ºber die alte Funktion schreiben.  In diesem Fall besteht die Gefahr, dass wir Probleme bekommen, wenn unsere Anwendung √ºber mehrere Threads verf√ºgt.  Wenn wir normalerweise in einer Umgebung mit mehreren Threads den Zugriff auf Daten durch einen Thread einschr√§nken, w√§hrend ein anderer Thread sie √§ndert, m√ºssen wir die F√§higkeit, Code auszuf√ºhren, auf einen Thread beschr√§nken, w√§hrend ein anderer Thread diesen Code √§ndert.  Ich habe nicht herausgefunden, wie das geht, daher wird sich die Implementierung in einer Multithread-Umgebung unvorhersehbar verhalten. </p><br><p>  Es gibt einen subtilen Punkt.  Auf einem 32-Bit-System reichen 5 Bytes aus, um an einen beliebigen Ort zu "springen".  Wenn wir auf einem 64-Bit-System die Register nicht verderben m√∂chten, ben√∂tigen wir 14 Bytes.  Die Quintessenz ist, dass 14 Bytes in der Skala des Maschinencodes ziemlich viel sind, und wenn der Code eine Stub-Funktion mit einem leeren K√∂rper hat, ist er wahrscheinlich weniger als 14 Bytes lang.  Ich kenne nicht die ganze Wahrheit, aber ich habe einige Zeit hinter dem Disassembler verbracht, w√§hrend ich den Code gedacht, geschrieben und debuggt habe, und festgestellt, dass alle Funktionen an einer 16-Byte-Grenze ausgerichtet sind (Debug-Build ohne Optimierungen, nicht sicher √ºber optimierten Code).  Dies bedeutet, dass zwischen dem Beginn von zwei beliebigen Funktionen mindestens 16 Bytes liegen, was ausreicht, um sie zu ‚Äûst√∂ren‚Äú.  Oberfl√§chliches Googeln f√ºhrte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher</a> , aber ich wei√ü nicht genau, ich hatte einfach Gl√ºck, oder heute tun dies alle Compiler.  In jedem Fall deklarieren Sie im Zweifelsfall einfach einige Variablen am Anfang der Stub-Funktion, damit sie gro√ü genug wird. </p><br><p>  Wir haben also das erste Korn - einen Mechanismus zum Umleiten von Funktionen von der alten zur neuen Version. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Suchen Sie nach Funktionen in einem kopierten Programm </h4><br><p>  Jetzt m√ºssen wir irgendwie die Adressen aller (nicht nur exportierten) Funktionen aus unserem Programm oder einer beliebigen dynamischen Bibliothek abrufen.  Dies kann ganz einfach mit der System-API erfolgen, wenn keine Zeichen aus Ihrer Anwendung ausgeschnitten sind.  Unter Linux sind dies <code>elf.h</code> von <code>elf.h</code> und <code>link.h</code> , unter macOS, <code>loader.h</code> und <code>nlist.h</code> . </p><br><ul><li>  Mit <code>dl_iterate_phdr</code> gehen wir alle geladenen Bibliotheken und sogar das Programm durch </li><li>  Suchen Sie die Adresse, an der die Bibliothek geladen wird </li><li>  Aus dem Abschnitt <code>.symtab</code> alle Informationen zu den Zeichen, n√§mlich Name, Typ, Index des Abschnitts, in dem er liegt, Gr√∂√üe und berechnen auch seine "echte" Adresse basierend auf der virtuellen Adresse und der Ladeadresse der Bibliothek </li></ul><br><p>  Es gibt eine Subtilit√§t.  Beim Herunterladen einer Elf-Datei l√§dt das System den Abschnitt <code>.symtab</code> (richtig, wenn er falsch ist), und der Abschnitt <code>.dynsym</code> passt nicht zu uns, da wir keine Zeichen mit der Sichtbarkeit <code>STV_INTERNAL</code> und <code>STV_HIDDEN</code> .  Einfach ausgedr√ºckt, wir werden solche Funktionen nicht sehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  und solche Variablen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Daher arbeiten wir in Absatz 3 nicht mit dem Programm, das <code>dl_iterate_phdr</code> zur Verf√ºgung gestellt <code>dl_iterate_phdr</code> , sondern mit der Datei, die wir von der Festplatte heruntergeladen und von einem Elfen-Parser (oder auf der nackten API) analysiert haben.  Wir verpassen also nichts.  Unter macOS ist die Vorgehensweise √§hnlich, nur die Namen der Funktionen aus der System-API unterscheiden sich. </p><br><p>  Danach filtern wir alle Zeichen und speichern nur: </p><br><ul><li>  Funktionen, die neu geladen werden k√∂nnen, sind Zeichen vom Typ <code>.text</code> Abschnitt <code>.text</code> , deren Gr√∂√üe ungleich Null ist.  Ein solcher Filter √ºberspringt nur Funktionen, deren Code tats√§chlich in diesem Programm oder dieser Bibliothek enthalten ist </li><li>  Statische Variablen, deren Werte Sie √ºbertragen m√∂chten, sind Zeichen vom Typ <code>STT_OBJECT</code> im Abschnitt <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Broadcast-Einheiten </h2><br><p>  Um den Code neu zu laden, m√ºssen wir wissen, woher die Quellcodedateien stammen und wie sie kompiliert werden. </p><br><p>  In der ersten Implementierung habe ich diese Informationen aus dem Abschnitt <code>.debug_info</code> gelesen, der Debugging-Informationen im DWARF-Format enth√§lt.  Damit jede Kompilierungseinheit (ET) in DWARF eine Kompilierungszeile f√ºr diese ET erh√§lt, m√ºssen Sie w√§hrend der Kompilierung <code>-grecord-gcc-switches</code> .  DWARF selbst, ich habe die libdwarf-Bibliothek analysiert, die im Lieferumfang von <code>libelf</code> .  Zus√§tzlich zum Kompilierungsbefehl von DWARF k√∂nnen Sie Informationen zu den Abh√§ngigkeiten unserer ETs von anderen Dateien abrufen.  Ich habe diese Implementierung jedoch aus mehreren Gr√ºnden abgelehnt: </p><br><ul><li>  Bibliotheken sind ziemlich schwer </li><li>  Das Parsen einer aus ~ 500 ET kompilierten DWARF-Anwendung mit Abh√§ngigkeitsanalyse dauerte etwas mehr als 10 Sekunden </li></ul><br><p>  10 Sekunden zum Starten der Anwendung sind zu viel.  Nach einigem √úberlegen habe ich die Logik des Parsens von DWARF in das Parsen von <code>compile_commands.json</code> .  Diese Datei kann einfach durch Hinzuf√ºgen von <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> zu Ihrer CMakeLists.txt generiert werden.  So erhalten wir alle Informationen, die wir brauchen. </p><br><h2 id="obrabotka-zavisimostey">  Abh√§ngigkeitsbehandlung </h2><br><p>  Da wir DWARF aufgegeben haben, m√ºssen wir eine andere Option finden, wie Abh√§ngigkeiten zwischen Dateien behandelt werden k√∂nnen.  Ich wollte wirklich keine Dateien mit meinen H√§nden analysieren und nach Includes suchen, und wer wei√ü mehr √ºber Abh√§ngigkeiten als der Compiler selbst? </p><br><p>  Es gibt eine Reihe von Optionen in clang und gcc, die fast kostenlos sogenannte Depfiles generieren.  Diese Dateien verwenden die Build- und Ninja-Build-Systeme, um Abh√§ngigkeiten zwischen Dateien aufzul√∂sen.  Depfiles haben ein sehr einfaches Format: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  Der Compiler platziert diese Dateien neben den Objektdateien f√ºr jede ET. Es bleibt uns √ºberlassen, sie zu analysieren und in eine Hashmap einzuf√ºgen.  Das gesamte Parsen von <code>compile_commands.json</code> + depfiles f√ºr dieselben 500 ET dauert etwas mehr als 1 Sekunde.  Damit alles funktioniert, m√ºssen wir das <code>-MD</code> Flag global f√ºr alle Projektdateien in der Kompilierungsoption hinzuf√ºgen. </p><br><p>  Mit Ninja ist eine Subtilit√§t verbunden.  Dieses Build-System generiert Depfiles unabh√§ngig vom Vorhandensein des <code>-MD</code> Flags f√ºr ihre Anforderungen.  Nachdem sie generiert wurden, werden sie in das Bin√§rformat √ºbersetzt und die Quelldateien gel√∂scht.  Daher m√ºssen Sie beim Starten von Ninja das Flag <code>-d keepdepfile</code> .  Aus mir unbekannten Gr√ºnden hei√üt die Datei im Fall von make (mit der Option <code>-MD</code> ) <code>some_file.cpp.d</code> , w√§hrend sie bei ninja <code>some_file.cpp.od</code> hei√üt.  Daher m√ºssen Sie nach beiden Versionen suchen. </p><br><h2 id="perenos-staticheskih-peremennyh">  Statische Variablen√ºbertragung </h2><br><p>  Angenommen, wir haben einen solchen Code (ein sehr synthetisches Beispiel): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Wir m√∂chten die Funktion <code>veryUsefulFunction</code> √§ndern: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Beim erneuten Laden wird in der dynamischen Bibliothek mit neuem Code zus√§tzlich zu <code>veryUsefulFunction</code> die statische Variable <code>static Singleton ins;</code>  und die <code>Singletor::instance</code> Methode.  Infolgedessen ruft das Programm neue Versionen beider Funktionen auf.  Die statischen <code>ins</code> in dieser Bibliothek sind jedoch noch nicht initialisiert. Daher wird beim ersten Zugriff der Konstruktor der <code>Singleton</code> Klasse aufgerufen.  Das wollen wir nat√ºrlich nicht.  Daher √ºbertr√§gt die Implementierung die Werte aller dieser Variablen, die sie in der zusammengestellten dynamischen Bibliothek findet, vom alten Code in diese sehr dynamische Bibliothek mit dem neuen Code zusammen mit ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutzvariablen</a> . </p><br><p>  Es gibt einen subtilen und allgemein unl√∂sbaren Moment. <br>  Angenommen, wir haben eine Klasse: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Die Methode <code>calledEachUpdate</code> 60 Mal pro Sekunde aufgerufen.  Wir √§ndern es, indem wir ein neues Feld hinzuf√ºgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Befindet sich eine Instanz dieser Klasse im dynamischen Speicher oder auf dem Stapel, st√ºrzt die Anwendung nach dem erneuten Laden des Codes wahrscheinlich ab.  Die zugewiesene Instanz enth√§lt nur die Variable <code>m_someVar1</code> . Nach einem Neustart versucht die Methode <code>m_someVar1</code> jedoch, <code>calledEachUpdate</code> zu √§ndern und zu √§ndern, was nicht zu dieser Instanz geh√∂rt, was zu unvorhersehbaren Konsequenzen f√ºhrt.  In diesem Fall wird die Status√ºbertragungslogik an den Programmierer √ºbertragen, der den Status des Objekts irgendwie speichern und das Objekt selbst l√∂schen muss, bevor der Code neu geladen wird, und nach dem Neustart ein neues Objekt erstellen muss.  Die Bibliothek bietet Ereignisse in Form der <code>onCodePreLoad</code> und <code>onCodePostLoad</code> , die die Anwendung verarbeiten kann. </p><br><p>  Ich wei√ü nicht, wie (und ob) es m√∂glich ist, diese Situation allgemein zu l√∂sen, denke ich.  Jetzt funktioniert dieser Fall "mehr oder weniger normal" nur f√ºr statische Variablen. Er verwendet die folgende Logik: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Das ist nicht sehr richtig, aber es ist das Beste, was ich mir ausgedacht habe. </p><br><p>  Infolgedessen verh√§lt sich der Code unvorhersehbar, wenn die Laufzeit die Menge und das Layout der Felder in den Datenstrukturen √§ndert.  Gleiches gilt f√ºr polymorphe Typen. </p><br><h2 id="sobiraem-vse-vmeste">  Alles zusammenf√ºgen </h2><br><p>  Wie das alles zusammenarbeitet. </p><br><ul><li>  Die Bibliothek durchl√§uft die Header aller Bibliotheken, die dynamisch in den Prozess geladen werden, und tats√§chlich analysiert und filtert das Programm selbst Zeichen. </li><li>  Als N√§chstes versucht die Bibliothek, die Datei <code>compile_commands.json</code> rekursiv im Anwendungsverzeichnis und in den √ºbergeordneten Verzeichnissen zu finden, und <code>compile_commands.json</code> von dort aus alle erforderlichen Informationen zu ET ab. </li><li>  Wenn die Bibliothek den Pfad zu Objektdateien kennt, werden Depfiles geladen und analysiert. </li><li>  Danach wird das h√§ufigste Verzeichnis f√ºr alle Quellcodedateien des Programms berechnet und die √úberwachung dieses Verzeichnisses beginnt rekursiv. </li><li>  Wenn sich eine Datei √§ndert, pr√ºft die Bibliothek, ob sie sich in der Hashmap der Abh√§ngigkeiten befindet. Wenn dies der Fall ist, werden mehrere Kompilierungsprozesse der ge√§nderten Dateien und ihrer Abh√§ngigkeiten im Hintergrund mithilfe der Kompilierungsbefehle aus <code>compile_commands.json</code> . </li><li>  Wenn das Programm Sie auffordert, den Code neu zu laden (in meiner Anwendung ist die Kombination <code>Ctrl+r</code> diesem zugewiesen), wartet die Bibliothek auf den Abschluss des Kompilierungsprozesses und verkn√ºpft alle neuen Objekte mit der dynamischen Bibliothek. </li><li>  Diese Bibliothek wird dann <code>dlopen</code> Funktion <code>dlopen</code> in den Prozessadressraum geladen. </li><li>  Informationen zu Symbolen werden aus dieser Bibliothek geladen, und der gesamte Schnittpunkt der Symbolmenge aus dieser Bibliothek und der bereits im Prozess lebenden Symbole wird entweder neu geladen (wenn es sich um eine Funktion handelt) oder √ºbertragen (wenn es sich um eine statische Variable handelt). </li></ul><br><p>  Dies funktioniert sehr gut, insbesondere wenn Sie wissen, was sich unter der Haube befindet und was Sie zumindest auf hohem Niveau erwartet. </p><br><p>  Pers√∂nlich war ich sehr √ºberrascht √ºber das Fehlen einer solchen L√∂sung f√ºr Linux. Interessiert sich jemand wirklich daf√ºr? </p><br><p>  Ich freue mich √ºber jede Kritik, danke! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Link zur Implementierung</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435260/">https://habr.com/ru/post/de435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435250/index.html">So funktioniert die ITMO University: ein Rundgang durch unser cyberphysikalisches Labor</a></li>
<li><a href="../de435252/index.html">Jessica Livingston: ‚ÄûWie wir Y Combinator erstellt haben. Die emotionale Komponente "</a></li>
<li><a href="../de435254/index.html">Funktionsfehlerbehandlung in Kotlin mit Arrow</a></li>
<li><a href="../de435256/index.html">Wir bewerten Personalvermittler anhand kalter Briefe</a></li>
<li><a href="../de435258/index.html">Wir schreiben unsere Programmiersprache, Teil 2: Zwischendarstellung von Programmen</a></li>
<li><a href="../de435262/index.html">Li-Fi: Die Zukunft des Internets</a></li>
<li><a href="../de435264/index.html">Preise in RMK bearbeiten. 1C: Handelsmanagement 11</a></li>
<li><a href="../de435268/index.html">Behandle mich nicht, Doktor</a></li>
<li><a href="../de435270/index.html">Bewahren Sie SSH-Schl√ºssel sicher auf</a></li>
<li><a href="../de435272/index.html">Zyklophobie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>