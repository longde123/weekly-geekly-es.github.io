<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 👩🏻‍🤝‍👨🏿 🙍🏿 Implementierung eines Hot-Reloads von C ++ - Code unter Linux 🚶🏿 🆚 😯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Link zur Bibliothek am Ende des Artikels. Der Artikel selbst beschreibt die in der Bibliothek implementierten Mechanismen mit mittleren Details. Die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung eines Hot-Reloads von C ++ - Code unter Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="Bild"></p><br><p>  * Link zur Bibliothek am Ende des Artikels.  Der Artikel selbst beschreibt die in der Bibliothek implementierten Mechanismen mit mittleren Details.  Die Implementierung für macOS ist noch nicht abgeschlossen, unterscheidet sich jedoch nicht wesentlich von der Implementierung für Linux.  Dies ist hauptsächlich eine Implementierung für Linux. </p><br><p>  Als ich an einem Samstagnachmittag über den Github ging, stieß ich auf eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> , in der die Aktualisierung von C ++ - Code für Windows im laufenden Betrieb implementiert wird.  Ich selbst bin vor ein paar Jahren von Windows heruntergekommen, habe es nicht ein bisschen bereut, und jetzt erfolgt die gesamte Programmierung entweder unter Linux (zu Hause) oder unter MacOS (bei der Arbeit).  Beim Googeln stellte ich fest, dass der Ansatz aus der obigen Bibliothek sehr beliebt ist und msvc dieselbe Technik für die Funktion "Bearbeiten und fortfahren" in Visual Studio verwendet.  Das einzige Problem ist, dass ich unter Nicht-Fenstern keine Implementierungen gefunden habe (habe ich schlecht ausgesehen?).  Auf die Frage an den Autor der Bibliothek oben, ob er einen Port für andere Plattformen erstellen wird, lautete die Antwort nein. </p><br><p>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">muss sofort sagen,</a> dass ich nur an der Option interessiert war, bei der ich den vorhandenen Projektcode nicht ändern müsste (wie zum Beispiel im Fall von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RCCPP</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cr</a> , wo sich der gesamte potenziell neu geladene Code in einer separaten dynamisch geladenen Bibliothek befinden sollte). </p><br><p>  "Wie so?"  - Ich dachte und fing an, Weihrauch anzuzünden. </p><a name="habracut"></a><br><h2 id="zachem">  Warum? </h2><br><p>  Ich mache hauptsächlich Gamedev.  Die meiste Zeit meiner Arbeit verbringe ich damit, Spielelogik und Layout für jedes Bild zu schreiben.  Ich benutze imgui auch für Hilfsdienstprogramme.  Mein Zyklus der Arbeit mit dem Code ist, wie Sie wahrscheinlich vermutet haben, Schreiben -&gt; Kompilieren -&gt; Ausführen -&gt; Wiederholen.  Alles geschieht ziemlich schnell (inkrementeller Build, alle Arten von Ccache usw.).  Das Problem hierbei ist, dass dieser Zyklus oft genug wiederholt werden muss.  Zum Beispiel schreibe ich eine neue Spielmechanik, sei es "Jump", ein gültiger, kontrollierter Jump: </p><br><p>  1. Schrieb einen Entwurf der Implementierung basierend auf der Dynamik, zusammengestellt, gestartet.  Ich habe gesehen, dass ich versehentlich einen Impuls auf jedes Bild angewendet habe und nicht einmal. </p><br><p>  2. Fest, zusammengebaut, gestartet, jetzt normal.  Aber es wäre notwendig, den absoluten Wert des Impulses mehr zu nehmen. </p><br><p>  3. Fest, zusammengebaut, gestartet, funktioniert.  Aber irgendwie fühlt es sich falsch an.  Es ist notwendig, auf der Grundlage der Stärke zu versuchen, zu tun. </p><br><p>  4. Schrieb einen Implementierungsentwurf basierend auf Stärke, zusammengestellt, gestartet, funktioniert.  Es wäre nur notwendig, die momentane Geschwindigkeit zum Zeitpunkt des Sprunges zu ändern. <br>  ... </p><br><p> 10. Fest, zusammengebaut, gestartet, funktioniert.  Aber immer noch nicht das.  <code>gravityScale</code> müssen Sie eine Implementierung versuchen, die auf einer Änderung der <code>gravityScale</code> . <br>  ... </p><br><p>  20. Großartig, es sieht super aus!  Jetzt nehmen wir alle Parameter im Editor für das Spiel heraus, testen und füllen. <br>  ... </p><br><p>  30. Der Sprung ist fertig. </p><br><p>  Und bei jeder Iteration müssen Sie den Code sammeln und in der gestarteten Anwendung an die Stelle gelangen, an der ich springen kann.  Dies dauert normalerweise mindestens 10 Sekunden.  Und wenn ich nur in einen offenen Bereich springen kann, der noch erreicht werden muss?  Und wenn ich in der Lage sein muss, auf Blöcke mit einer Höhe von N Einheiten zu springen?  Hier muss ich bereits eine Testszene sammeln, die ebenfalls debuggt werden muss und die auch Zeit verbringen muss.  Für solche Iterationen wäre ein Hot-Reload von Code ideal.  Natürlich ist dies kein Allheilmittel, es ist nicht für alles geeignet. Nach einem Neustart müssen Sie manchmal einen Teil der Spielwelt neu erstellen, und dies muss berücksichtigt werden.  In vielen Fällen kann dies jedoch nützlich sein und Aufmerksamkeit und viel Zeit sparen. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Anforderungen und Erklärung des Problems </h2><br><ul><li>  Beim Ändern des Codes sollte die neue Version aller Funktionen die alten Versionen derselben Funktionen ersetzen </li><li>  Dies sollte unter Linux und MacOS funktionieren </li><li>  Dies sollte keine Änderungen am vorhandenen Anwendungscode erfordern. </li><li>  Im Idealfall sollte dies eine Bibliothek sein, die statisch oder dynamisch mit der Anwendung verknüpft ist und keine Dienstprogramme von Drittanbietern enthält </li><li>  Es ist wünschenswert, dass diese Bibliothek die Anwendungsleistung nicht stark beeinflusst. </li><li>  Genug, wenn dies mit cmake + make / ninja funktioniert </li><li>  Es reicht aus, wenn es mit Debazin-Builds funktioniert (ohne Optimierungen, ohne Zuschneiden von Zeichen usw.). </li></ul><br><p>  Dies ist die Mindestanforderung, die eine Implementierung erfüllen muss.  Mit Blick auf die Zukunft werde ich kurz beschreiben, was zusätzlich implementiert wurde: </p><br><ul><li>  Übertragen von Werten statischer Variablen in neuen Code (siehe Abschnitt "Übertragen statischer Variablen", um herauszufinden, warum dies wichtig ist) </li><li>  Neuladen basierend auf Abhängigkeiten (geänderter Header -&gt; neu erstellt <del>  ein halbes Projekt </del>  alle abhängigen Dateien) </li><li>  Code aus dynamischen Bibliotheken neu laden </li></ul><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Bis zu diesem Moment war ich völlig weit vom Themenbereich entfernt, daher musste ich Informationen von Grund auf sammeln und verarbeiten. </p><br><p>  Auf hoher Ebene sieht der Mechanismus folgendermaßen aus: </p><br><ul><li>  Wir überwachen das Dateisystem auf Änderungen in der Quelle </li><li>  Wenn sich die Quelle ändert, erstellt die Bibliothek sie mithilfe des Kompilierungsbefehls neu, mit dem diese Datei bereits kompiliert wurde </li><li>  Alle gesammelten Objekte sind mit einer dynamisch geladenen Bibliothek verknüpft </li><li>  Die Bibliothek wird in den Prozessadressraum geladen </li><li>  Alle Funktionen aus der Bibliothek ersetzen dieselben Funktionen in der Anwendung. </li><li>  Die Werte statischer Variablen werden von der Anwendung in die Bibliothek übertragen </li></ul><br><p>  Beginnen wir mit dem interessantesten - dem Mechanismus zum erneuten Laden von Funktionen. </p><br><h4 id="perezagruzka-funkciy">  Funktionen zum Nachladen </h4><br><p>  Hier sind 3 mehr oder weniger beliebte Möglichkeiten, um Funktionen in (oder fast) zur Laufzeit zu ersetzen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trick mit LD_PRELOAD</a> - Ermöglicht es Ihnen, eine dynamisch geladene Bibliothek mit beispielsweise der Funktion <code>strcpy</code> und so zu gestalten, dass beim Starten der Anwendung meine Version von <code>strcpy</code> anstelle der Bibliothek verwendet wird </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PLT- und GOT-Tabellen</a> ändern - Ermöglicht das "Überladen" exportierter Funktionen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktions-Hooking</a> - Ermöglicht das Umleiten des Ausführungsthreads von einer Funktion zur anderen </li></ul><br><p>  Die ersten beiden Optionen sind natürlich nicht geeignet, da sie nur mit exportierten Funktionen funktionieren und wir nicht alle Funktionen unserer Anwendung mit Attributen markieren möchten.  Daher ist Function Hooking unsere Option! </p><br><p>  Kurz gesagt, das Einhaken funktioniert folgendermaßen: </p><br><ul><li>  Die Funktionsadresse wird gefunden </li><li>  Die ersten paar Bytes der Funktion werden durch einen bedingungslosen Übergang zum Körper einer anderen Funktion überschrieben </li><li>  ... </li><li>  Gewinn! <br>  In msvc gibt es 2 Flags für dieses - <code>/hotpatch</code> und <code>/FUNCTIONPADMIN</code> .  Der erste am Anfang jeder Funktion schreibt 2 Bytes, die nichts tun, für das anschließende Umschreiben mit einem "kurzen Sprung".  Mit der zweiten Option können Sie vor dem Körper jeder Funktion einen leeren Raum in Form von <code>nop</code> Anweisungen für einen "Weitsprung" zum gewünschten Ort lassen, sodass Sie in zwei Sprüngen von der alten Funktion zur neuen wechseln können.  Weitere Informationen dazu, wie dies beispielsweise in Windows und MSVC implementiert ist, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br><p>  Leider gibt es in clang und gcc nichts Vergleichbares (zumindest unter Linux und macOS).  Eigentlich ist das kein so großes Problem, wir werden direkt über die alte Funktion schreiben.  In diesem Fall besteht die Gefahr, dass wir Probleme bekommen, wenn unsere Anwendung über mehrere Threads verfügt.  Wenn wir normalerweise in einer Umgebung mit mehreren Threads den Zugriff auf Daten durch einen Thread einschränken, während ein anderer Thread sie ändert, müssen wir die Fähigkeit, Code auszuführen, auf einen Thread beschränken, während ein anderer Thread diesen Code ändert.  Ich habe nicht herausgefunden, wie das geht, daher wird sich die Implementierung in einer Multithread-Umgebung unvorhersehbar verhalten. </p><br><p>  Es gibt einen subtilen Punkt.  Auf einem 32-Bit-System reichen 5 Bytes aus, um an einen beliebigen Ort zu "springen".  Wenn wir auf einem 64-Bit-System die Register nicht verderben möchten, benötigen wir 14 Bytes.  Die Quintessenz ist, dass 14 Bytes in der Skala des Maschinencodes ziemlich viel sind, und wenn der Code eine Stub-Funktion mit einem leeren Körper hat, ist er wahrscheinlich weniger als 14 Bytes lang.  Ich kenne nicht die ganze Wahrheit, aber ich habe einige Zeit hinter dem Disassembler verbracht, während ich den Code gedacht, geschrieben und debuggt habe, und festgestellt, dass alle Funktionen an einer 16-Byte-Grenze ausgerichtet sind (Debug-Build ohne Optimierungen, nicht sicher über optimierten Code).  Dies bedeutet, dass zwischen dem Beginn von zwei beliebigen Funktionen mindestens 16 Bytes liegen, was ausreicht, um sie zu „stören“.  Oberflächliches Googeln führte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher</a> , aber ich weiß nicht genau, ich hatte einfach Glück, oder heute tun dies alle Compiler.  In jedem Fall deklarieren Sie im Zweifelsfall einfach einige Variablen am Anfang der Stub-Funktion, damit sie groß genug wird. </p><br><p>  Wir haben also das erste Korn - einen Mechanismus zum Umleiten von Funktionen von der alten zur neuen Version. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Suchen Sie nach Funktionen in einem kopierten Programm </h4><br><p>  Jetzt müssen wir irgendwie die Adressen aller (nicht nur exportierten) Funktionen aus unserem Programm oder einer beliebigen dynamischen Bibliothek abrufen.  Dies kann ganz einfach mit der System-API erfolgen, wenn keine Zeichen aus Ihrer Anwendung ausgeschnitten sind.  Unter Linux sind dies <code>elf.h</code> von <code>elf.h</code> und <code>link.h</code> , unter macOS, <code>loader.h</code> und <code>nlist.h</code> . </p><br><ul><li>  Mit <code>dl_iterate_phdr</code> gehen wir alle geladenen Bibliotheken und sogar das Programm durch </li><li>  Suchen Sie die Adresse, an der die Bibliothek geladen wird </li><li>  Aus dem Abschnitt <code>.symtab</code> alle Informationen zu den Zeichen, nämlich Name, Typ, Index des Abschnitts, in dem er liegt, Größe und berechnen auch seine "echte" Adresse basierend auf der virtuellen Adresse und der Ladeadresse der Bibliothek </li></ul><br><p>  Es gibt eine Subtilität.  Beim Herunterladen einer Elf-Datei lädt das System den Abschnitt <code>.symtab</code> (richtig, wenn er falsch ist), und der Abschnitt <code>.dynsym</code> passt nicht zu uns, da wir keine Zeichen mit der Sichtbarkeit <code>STV_INTERNAL</code> und <code>STV_HIDDEN</code> .  Einfach ausgedrückt, wir werden solche Funktionen nicht sehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  und solche Variablen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Daher arbeiten wir in Absatz 3 nicht mit dem Programm, das <code>dl_iterate_phdr</code> zur Verfügung gestellt <code>dl_iterate_phdr</code> , sondern mit der Datei, die wir von der Festplatte heruntergeladen und von einem Elfen-Parser (oder auf der nackten API) analysiert haben.  Wir verpassen also nichts.  Unter macOS ist die Vorgehensweise ähnlich, nur die Namen der Funktionen aus der System-API unterscheiden sich. </p><br><p>  Danach filtern wir alle Zeichen und speichern nur: </p><br><ul><li>  Funktionen, die neu geladen werden können, sind Zeichen vom Typ <code>.text</code> Abschnitt <code>.text</code> , deren Größe ungleich Null ist.  Ein solcher Filter überspringt nur Funktionen, deren Code tatsächlich in diesem Programm oder dieser Bibliothek enthalten ist </li><li>  Statische Variablen, deren Werte Sie übertragen möchten, sind Zeichen vom Typ <code>STT_OBJECT</code> im Abschnitt <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Broadcast-Einheiten </h2><br><p>  Um den Code neu zu laden, müssen wir wissen, woher die Quellcodedateien stammen und wie sie kompiliert werden. </p><br><p>  In der ersten Implementierung habe ich diese Informationen aus dem Abschnitt <code>.debug_info</code> gelesen, der Debugging-Informationen im DWARF-Format enthält.  Damit jede Kompilierungseinheit (ET) in DWARF eine Kompilierungszeile für diese ET erhält, müssen Sie während der Kompilierung <code>-grecord-gcc-switches</code> .  DWARF selbst, ich habe die libdwarf-Bibliothek analysiert, die im Lieferumfang von <code>libelf</code> .  Zusätzlich zum Kompilierungsbefehl von DWARF können Sie Informationen zu den Abhängigkeiten unserer ETs von anderen Dateien abrufen.  Ich habe diese Implementierung jedoch aus mehreren Gründen abgelehnt: </p><br><ul><li>  Bibliotheken sind ziemlich schwer </li><li>  Das Parsen einer aus ~ 500 ET kompilierten DWARF-Anwendung mit Abhängigkeitsanalyse dauerte etwas mehr als 10 Sekunden </li></ul><br><p>  10 Sekunden zum Starten der Anwendung sind zu viel.  Nach einigem Überlegen habe ich die Logik des Parsens von DWARF in das Parsen von <code>compile_commands.json</code> .  Diese Datei kann einfach durch Hinzufügen von <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> zu Ihrer CMakeLists.txt generiert werden.  So erhalten wir alle Informationen, die wir brauchen. </p><br><h2 id="obrabotka-zavisimostey">  Abhängigkeitsbehandlung </h2><br><p>  Da wir DWARF aufgegeben haben, müssen wir eine andere Option finden, wie Abhängigkeiten zwischen Dateien behandelt werden können.  Ich wollte wirklich keine Dateien mit meinen Händen analysieren und nach Includes suchen, und wer weiß mehr über Abhängigkeiten als der Compiler selbst? </p><br><p>  Es gibt eine Reihe von Optionen in clang und gcc, die fast kostenlos sogenannte Depfiles generieren.  Diese Dateien verwenden die Build- und Ninja-Build-Systeme, um Abhängigkeiten zwischen Dateien aufzulösen.  Depfiles haben ein sehr einfaches Format: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  Der Compiler platziert diese Dateien neben den Objektdateien für jede ET. Es bleibt uns überlassen, sie zu analysieren und in eine Hashmap einzufügen.  Das gesamte Parsen von <code>compile_commands.json</code> + depfiles für dieselben 500 ET dauert etwas mehr als 1 Sekunde.  Damit alles funktioniert, müssen wir das <code>-MD</code> Flag global für alle Projektdateien in der Kompilierungsoption hinzufügen. </p><br><p>  Mit Ninja ist eine Subtilität verbunden.  Dieses Build-System generiert Depfiles unabhängig vom Vorhandensein des <code>-MD</code> Flags für ihre Anforderungen.  Nachdem sie generiert wurden, werden sie in das Binärformat übersetzt und die Quelldateien gelöscht.  Daher müssen Sie beim Starten von Ninja das Flag <code>-d keepdepfile</code> .  Aus mir unbekannten Gründen heißt die Datei im Fall von make (mit der Option <code>-MD</code> ) <code>some_file.cpp.d</code> , während sie bei ninja <code>some_file.cpp.od</code> heißt.  Daher müssen Sie nach beiden Versionen suchen. </p><br><h2 id="perenos-staticheskih-peremennyh">  Statische Variablenübertragung </h2><br><p>  Angenommen, wir haben einen solchen Code (ein sehr synthetisches Beispiel): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Wir möchten die Funktion <code>veryUsefulFunction</code> ändern: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Beim erneuten Laden wird in der dynamischen Bibliothek mit neuem Code zusätzlich zu <code>veryUsefulFunction</code> die statische Variable <code>static Singleton ins;</code>  und die <code>Singletor::instance</code> Methode.  Infolgedessen ruft das Programm neue Versionen beider Funktionen auf.  Die statischen <code>ins</code> in dieser Bibliothek sind jedoch noch nicht initialisiert. Daher wird beim ersten Zugriff der Konstruktor der <code>Singleton</code> Klasse aufgerufen.  Das wollen wir natürlich nicht.  Daher überträgt die Implementierung die Werte aller dieser Variablen, die sie in der zusammengestellten dynamischen Bibliothek findet, vom alten Code in diese sehr dynamische Bibliothek mit dem neuen Code zusammen mit ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutzvariablen</a> . </p><br><p>  Es gibt einen subtilen und allgemein unlösbaren Moment. <br>  Angenommen, wir haben eine Klasse: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Die Methode <code>calledEachUpdate</code> 60 Mal pro Sekunde aufgerufen.  Wir ändern es, indem wir ein neues Feld hinzufügen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Befindet sich eine Instanz dieser Klasse im dynamischen Speicher oder auf dem Stapel, stürzt die Anwendung nach dem erneuten Laden des Codes wahrscheinlich ab.  Die zugewiesene Instanz enthält nur die Variable <code>m_someVar1</code> . Nach einem Neustart versucht die Methode <code>m_someVar1</code> jedoch, <code>calledEachUpdate</code> zu ändern und zu ändern, was nicht zu dieser Instanz gehört, was zu unvorhersehbaren Konsequenzen führt.  In diesem Fall wird die Statusübertragungslogik an den Programmierer übertragen, der den Status des Objekts irgendwie speichern und das Objekt selbst löschen muss, bevor der Code neu geladen wird, und nach dem Neustart ein neues Objekt erstellen muss.  Die Bibliothek bietet Ereignisse in Form der <code>onCodePreLoad</code> und <code>onCodePostLoad</code> , die die Anwendung verarbeiten kann. </p><br><p>  Ich weiß nicht, wie (und ob) es möglich ist, diese Situation allgemein zu lösen, denke ich.  Jetzt funktioniert dieser Fall "mehr oder weniger normal" nur für statische Variablen. Er verwendet die folgende Logik: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Das ist nicht sehr richtig, aber es ist das Beste, was ich mir ausgedacht habe. </p><br><p>  Infolgedessen verhält sich der Code unvorhersehbar, wenn die Laufzeit die Menge und das Layout der Felder in den Datenstrukturen ändert.  Gleiches gilt für polymorphe Typen. </p><br><h2 id="sobiraem-vse-vmeste">  Alles zusammenfügen </h2><br><p>  Wie das alles zusammenarbeitet. </p><br><ul><li>  Die Bibliothek durchläuft die Header aller Bibliotheken, die dynamisch in den Prozess geladen werden, und tatsächlich analysiert und filtert das Programm selbst Zeichen. </li><li>  Als Nächstes versucht die Bibliothek, die Datei <code>compile_commands.json</code> rekursiv im Anwendungsverzeichnis und in den übergeordneten Verzeichnissen zu finden, und <code>compile_commands.json</code> von dort aus alle erforderlichen Informationen zu ET ab. </li><li>  Wenn die Bibliothek den Pfad zu Objektdateien kennt, werden Depfiles geladen und analysiert. </li><li>  Danach wird das häufigste Verzeichnis für alle Quellcodedateien des Programms berechnet und die Überwachung dieses Verzeichnisses beginnt rekursiv. </li><li>  Wenn sich eine Datei ändert, prüft die Bibliothek, ob sie sich in der Hashmap der Abhängigkeiten befindet. Wenn dies der Fall ist, werden mehrere Kompilierungsprozesse der geänderten Dateien und ihrer Abhängigkeiten im Hintergrund mithilfe der Kompilierungsbefehle aus <code>compile_commands.json</code> . </li><li>  Wenn das Programm Sie auffordert, den Code neu zu laden (in meiner Anwendung ist die Kombination <code>Ctrl+r</code> diesem zugewiesen), wartet die Bibliothek auf den Abschluss des Kompilierungsprozesses und verknüpft alle neuen Objekte mit der dynamischen Bibliothek. </li><li>  Diese Bibliothek wird dann <code>dlopen</code> Funktion <code>dlopen</code> in den Prozessadressraum geladen. </li><li>  Informationen zu Symbolen werden aus dieser Bibliothek geladen, und der gesamte Schnittpunkt der Symbolmenge aus dieser Bibliothek und der bereits im Prozess lebenden Symbole wird entweder neu geladen (wenn es sich um eine Funktion handelt) oder übertragen (wenn es sich um eine statische Variable handelt). </li></ul><br><p>  Dies funktioniert sehr gut, insbesondere wenn Sie wissen, was sich unter der Haube befindet und was Sie zumindest auf hohem Niveau erwartet. </p><br><p>  Persönlich war ich sehr überrascht über das Fehlen einer solchen Lösung für Linux. Interessiert sich jemand wirklich dafür? </p><br><p>  Ich freue mich über jede Kritik, danke! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Link zur Implementierung</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435260/">https://habr.com/ru/post/de435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435250/index.html">So funktioniert die ITMO University: ein Rundgang durch unser cyberphysikalisches Labor</a></li>
<li><a href="../de435252/index.html">Jessica Livingston: „Wie wir Y Combinator erstellt haben. Die emotionale Komponente "</a></li>
<li><a href="../de435254/index.html">Funktionsfehlerbehandlung in Kotlin mit Arrow</a></li>
<li><a href="../de435256/index.html">Wir bewerten Personalvermittler anhand kalter Briefe</a></li>
<li><a href="../de435258/index.html">Wir schreiben unsere Programmiersprache, Teil 2: Zwischendarstellung von Programmen</a></li>
<li><a href="../de435262/index.html">Li-Fi: Die Zukunft des Internets</a></li>
<li><a href="../de435264/index.html">Preise in RMK bearbeiten. 1C: Handelsmanagement 11</a></li>
<li><a href="../de435268/index.html">Behandle mich nicht, Doktor</a></li>
<li><a href="../de435270/index.html">Bewahren Sie SSH-Schlüssel sicher auf</a></li>
<li><a href="../de435272/index.html">Zyklophobie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>