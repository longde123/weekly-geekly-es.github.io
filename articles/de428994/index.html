<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 ⚜️ 🤤 Vernetzung in Android mit Corutin und Retrofit 🧕🏼 👨🏽‍🎓 👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je mehr ich die Berichte über Coroutinen in Kotlin las und sah, desto mehr bewunderte ich dieses Sprachwerkzeug. Ihre stabile Version wurde kürzlich i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vernetzung in Android mit Corutin und Retrofit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428994/"><p>  Je mehr ich die Berichte über Coroutinen in Kotlin las und sah, desto mehr bewunderte ich dieses Sprachwerkzeug.  Ihre stabile Version wurde kürzlich in Kotlin 1.3 veröffentlicht, was bedeutet, dass es Zeit ist, den Tauchgang zu starten und die Coroutinen in Aktion zu testen, wobei mein vorhandener RxJava-Code als Beispiel dient.  In diesem Beitrag konzentrieren wir uns darauf, wie vorhandene Netzwerkanforderungen übernommen und konvertiert werden, indem RxJava durch Coroutinen ersetzt wird. </p><br><p><img src="https://habrastorage.org/webt/h-/7v/mt/h-7vmtalbemnlfsu3g8hto3x2la.png"></p><a name="habracut"></a><br><p> Ehrlich gesagt, bevor ich Coroutinen probierte, dachte ich, dass sie sich sehr von denen unterscheiden, die sie vorher waren.  Das Grundprinzip von Corutin umfasst jedoch dieselben Konzepte, die wir in reaktiven RxJava-Flüssen gewohnt sind.  Nehmen wir als Beispiel eine einfache RxJava-Konfiguration, um eine Netzwerkanforderung aus einer meiner Anwendungen zu erstellen: </p><br><ul><li>  Definieren Sie die Netzwerkschnittstelle für die Nachrüstung mit dem Rx-Adapter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">retrofit2: adapter-rxjava2</a> ).  Funktionen geben Objekte aus einem Rx-Framework zurück, z. B. <strong>Single</strong> oder <strong>Observable</strong> .  (Hier werden Funktionen verwendet und keine Methoden, da davon ausgegangen wird, dass der alte Code auch in Kotlin geschrieben wurde. Nun, oder von Java über Android Studio konvertiert). </li><li>  Wir rufen eine bestimmte Funktion aus einer anderen Klasse auf (z. B. ein Repository oder eine Aktivität). </li><li>  Wir bestimmen für die Threads, auf welchem ​​Scheduler sie ausgeführt werden, und geben das Ergebnis zurück (Methoden <strong>.subscribeOn ()</strong> und <strong>.observeOn ()</strong> ). </li><li>  Speichern Sie den Link zum Objekt zum Abbestellen (z. B. in CompositeObservable). </li><li>  Abonnieren Sie den Veranstaltungsstrom. </li><li>  Abbestellen des Streams abhängig von den Ereignissen des Aktivitätslebenszyklus. </li></ul><br><p>  Dies ist der grundlegende Algorithmus für die Arbeit mit Rx (ohne Berücksichtigung der Zuordnungsfunktionen und der Details anderer Datenmanipulationen).  Was Corutin betrifft, ändert sich an dem Prinzip nicht viel.  Das gleiche Konzept, nur die Terminologie ändert sich. </p><br><ul><li>  Wir definieren die Netzwerkschnittstelle für das Retrofit mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adapters für Coroutine</a> .  Funktionen geben verzögerte Objekte von der Corutin-API zurück. </li><li>  Wir rufen diese Funktionen aus einer anderen Klasse auf (z. B. einem Repository oder einer Aktivität).  Der einzige Unterschied: Jede Funktion sollte als <strong>suspend</strong> markiert sein. </li><li>  Definieren Sie den Dispatcher, der für die Coroutine verwendet wird. </li><li>  Wir speichern den Link zum <strong>Job-</strong> Objekt zum Abbestellen. </li><li>  Führen Sie Coroutine auf jede mögliche Weise aus. </li><li>  Wir stornieren Coroutinen abhängig von den Ereignissen des Aktivitätslebenszyklus. </li></ul><br><p>  Wie Sie aus den obigen Sequenzen sehen können, ist der Ausführungsprozess von Rx und Corutin sehr ähnlich.  Wenn wir die Implementierungsdetails nicht berücksichtigen, bedeutet dies, dass wir unseren Ansatz beibehalten können - wir ersetzen nur einige Dinge, um unsere Implementierung koroutinenfreundlich zu gestalten. </p><br><p><img src="https://habrastorage.org/webt/rx/wm/xt/rxwmxtqqqcz0_wsvmjl8tjmel7m.png"></p><br><p>  Der erste Schritt, den wir unternehmen müssen, besteht darin, Retrofit die Rückgabe von zurückgestellten Objekten zu ermöglichen.  Aufgeschobene Objekte sind nicht blockierende Futures, die bei Bedarf rückgängig gemacht werden können.  Diese Objekte sind im Wesentlichen ein Coroutine-Job, der den Wert für den entsprechenden Job enthält.  Die Verwendung des verzögerten Typs ermöglicht es uns, dieselbe Idee wie Job zu mischen und zusätzlich zusätzliche Status wie Erfolg oder Misserfolg abzurufen. Dies macht ihn ideal für Netzwerkanforderungen. </p><br><p>  Wenn Sie Retrofit mit RxJava verwenden, verwenden Sie wahrscheinlich die RxJava Call Adapter Factory.  Glücklicherweise schrieb Jake Worton ihr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Äquivalent für Coroutine</a> . </p><br><p>  Wir können diesen Aufrufadapter im Retrofit-Builder verwenden und dann unsere Retrofit-Schnittstelle auf dieselbe Weise wie bei RxJava implementieren: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(okHttpClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OkHttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: MyService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retrofit = Retrofit.Builder() .baseUrl(<span class="hljs-string"><span class="hljs-string">"some_api"</span></span>) .client(okHttpClient) .addCallAdapterFactory(CoroutineCallAdapterFactory()) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrofit.create(MyService::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Schauen wir uns nun die oben verwendete MyService-Oberfläche an.  Wir müssen die zurückgegebenen Observable-Typen in der Retrofit-Schnittstelle durch Deferred ersetzen.  Wenn es früher so war: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Jetzt ersetzen wir es durch: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Deferred&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Jedes Mal, wenn wir getData () aufrufen, kehrt das zurückgestellte Objekt zu uns zurück - ein Analogon von Job für Netzwerkanforderungen.  Bisher haben wir diese Funktion mit RxJava irgendwie aufgerufen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myService.getData() .map { result -&gt; result.map { myDataMapper.mapFromRemote(it) } } }</code> </pre> <br><p>  In diesem RxJava-Stream rufen wir unsere Dienstprogrammfunktion auf und wenden dann die Zuordnungsoperation von der RxJava-API mit der anschließenden Zuordnung der von der Anforderung zurückgegebenen Daten zu etwas an, das in der UI-Ebene verwendet wird.  Dies wird sich ein wenig ändern, wenn wir eine Implementierung mit Coroutinen verwenden.  Für den Anfang muss unsere Funktion <strong>ausgesetzt</strong> (zurückgestellt) werden, um eine verzögerte Operation innerhalb des Funktionskörpers durchzuführen.  Und dafür muss auch die aufrufende Funktion verschoben werden.  Eine verzögerte Funktion ist nicht blockierend und kann nach dem ersten Aufruf gesteuert werden.  Sie können es starten, anhalten, fortsetzen oder abbrechen. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { ... }</code> </pre> <br><p>  Jetzt müssen wir unsere Utility-Funktion aufrufen.  Auf den ersten Blick machen wir dasselbe, aber wir müssen uns daran erinnern, dass wir jetzt <strong>verzögert</strong> statt beobachtbar werden. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData() ... }</code> </pre> <br><p>  Aufgrund dieser Änderung können wir die Kartenoperationskette aus der RxJava-API nicht mehr verwenden.  Und selbst zu diesem Zeitpunkt stehen uns keine Daten zur Verfügung - wir haben nur eine verzögerte Instanz.  Jetzt müssen wir die Funktion <strong>await ()</strong> verwenden, um auf das Ergebnis der Abfrage zu warten und dann den Code innerhalb der Funktion weiter auszuführen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() ... }</code> </pre> <br><p>  Zu diesem Zeitpunkt erhalten wir die abgeschlossene Anfrage und die daraus verfügbaren Daten zur Verwendung.  Daher können wir jetzt Mapping-Operationen ausführen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.map { myDataMapper.mapFromRemote(it) } }</code> </pre> <br><p>  Wir haben unsere Retrofit-Schnittstelle zusammen mit der aufrufenden Klasse genommen und Coroutinen verwendet.  Jetzt möchten wir diesen Code aus unserer Aktivität oder aus Fragmenten aufrufen und die Daten verwenden, die wir vom Netzwerk erhalten haben. </p><br><p>  In unserer Aktivität erstellen wir zunächst einen Link zu Job, in den wir unseren Coroutine-Vorgang zuweisen und ihn dann verwenden können, um beispielsweise das Abbrechen einer Anforderung während eines <strong>onDestroy () -Aufrufs</strong> zu steuern. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myJob: Job? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { myJob?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() }</code> </pre> <br><p>  Jetzt können wir der Variablen myJob etwas zuweisen.  Schauen wir uns unsere Anfrage mit Coroutinen an: </p><br><pre> <code class="hljs pgsql">myJob = CoroutineScope(Dispatchers.IO).launch { val result = repo.getLeagues() withContext(Dispatchers.Main) { //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> result } }</code> </pre> <br><p>  In diesem Beitrag möchte ich mich nicht mit Dispatchern befassen oder Operationen innerhalb von Coroutinen ausführen, da dies ein Thema für andere Beiträge ist.  Kurz gesagt, was passiert hier: </p><br><ul><li>  Erstellen Sie eine CoroutineScope-Instanz mit IO Dispatcher als Parameter.  Dieser Dispatcher wird verwendet, um blockierende E / A-Vorgänge auszuführen, z. B. Netzwerkanforderungen. </li><li>  Wir starten unsere Coroutine mit der <strong>Startfunktion</strong> - diese Funktion startet eine neue Coroutine und gibt einen Link zu einer Variablen vom Typ Job zurück. </li><li>  Dann verwenden wir den Link zu unserem Repository, um Daten durch Ausführen einer Netzwerkanforderung zu empfangen. </li><li>  Am Ende verwenden wir den Haupt-Dispatcher, um die Arbeit am UI-Thread zu erledigen.  Hier können wir den Benutzern die empfangenen Daten anzeigen. </li></ul><br><p>  Im nächsten Beitrag verspricht der Autor, etwas tiefer in die Details einzudringen, aber das aktuelle Material sollte ausreichen, um mit dem Studium von Coroutinen zu beginnen. </p><br><p>  In diesem Beitrag haben wir die RxJava-Implementierung von Retrofit-Antworten durch verzögerte Objekte aus der Corutin-API ersetzt.  Wir rufen diese Funktionen auf, um Daten aus dem Netzwerk zu empfangen, und zeigen sie dann in unserer Aktivität an.  Ich hoffe, Sie haben gesehen, wie wenig Änderungen Sie vornehmen müssen, um mit Coroutinen zu beginnen, und die Einfachheit der API geschätzt, insbesondere beim Lesen und Schreiben von Code. </p><br><p>  In den Kommentaren zum ursprünglichen Beitrag habe ich eine traditionelle Anfrage gefunden: Zeige den gesamten Code.  Aus diesem Grund habe ich eine einfache Anwendung erstellt, die beim Start einen Zugfahrplan mit der Yandex. Schedules-API empfängt und in RecyclerView anzeigt.  Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/AndreySBer/RetrofitCoroutinesExample</a> </p><br><p>  Ich möchte auch hinzufügen, dass Coroutinen ein schlechterer Ersatz für RxJava zu sein scheinen, da sie keinen äquivalenten Satz von Operationen zum Synchronisieren von Threads bieten.  In diesem Zusammenhang lohnt es sich, die ReactiveX-Implementierung für Kotlin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxKotlin zu betrachten</a> . </p><br><p>  Wenn Sie Android Jetpack verwenden, habe ich auch ein Beispiel mit Retrofit, Coroutinen, LiveData und MVVM gefunden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codinginfinite.com/kotlin-coroutine-call-adapter-retrofit/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428994/">https://habr.com/ru/post/de428994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428984/index.html">Julia und Phasenporträts dynamischer Systeme</a></li>
<li><a href="../de428986/index.html">ThinkJava-Konferenz Nr. 8 in Charkow</a></li>
<li><a href="../de428988/index.html">Tipps der Natur - Bewölktes Nachtlicht</a></li>
<li><a href="../de428990/index.html">Konfigurationsbeispiele für UIViewController mit RouteComposer</a></li>
<li><a href="../de428992/index.html">Selektiver Bypass von Sperren auf Routern mit Padavan- und Keenetic OS-Firmware</a></li>
<li><a href="../de428996/index.html">Club der anonymen Weihnachtsmänner 2018-2019 auf Habrahabr</a></li>
<li><a href="../de428998/index.html">Verwendung der neuen experimentellen Profiler-Funktion in React</a></li>
<li><a href="../de429000/index.html">Warum Bill Gates die Toilette für 233 Milliarden Dollar erfunden hat</a></li>
<li><a href="../de429006/index.html">China: „World Assembly Shop“ ist nicht so einfach, wie es scheint</a></li>
<li><a href="../de429008/index.html">Alpha Zero, Schach und Englisch lernen: Gegenwart und Zukunft der künstlichen Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>