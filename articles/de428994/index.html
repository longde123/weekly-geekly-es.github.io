<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèø ‚öúÔ∏è ü§§ Vernetzung in Android mit Corutin und Retrofit üßïüèº üë®üèΩ‚Äçüéì üë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je mehr ich die Berichte √ºber Coroutinen in Kotlin las und sah, desto mehr bewunderte ich dieses Sprachwerkzeug. Ihre stabile Version wurde k√ºrzlich i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vernetzung in Android mit Corutin und Retrofit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428994/"><p>  Je mehr ich die Berichte √ºber Coroutinen in Kotlin las und sah, desto mehr bewunderte ich dieses Sprachwerkzeug.  Ihre stabile Version wurde k√ºrzlich in Kotlin 1.3 ver√∂ffentlicht, was bedeutet, dass es Zeit ist, den Tauchgang zu starten und die Coroutinen in Aktion zu testen, wobei mein vorhandener RxJava-Code als Beispiel dient.  In diesem Beitrag konzentrieren wir uns darauf, wie vorhandene Netzwerkanforderungen √ºbernommen und konvertiert werden, indem RxJava durch Coroutinen ersetzt wird. </p><br><p><img src="https://habrastorage.org/webt/h-/7v/mt/h-7vmtalbemnlfsu3g8hto3x2la.png"></p><a name="habracut"></a><br><p> Ehrlich gesagt, bevor ich Coroutinen probierte, dachte ich, dass sie sich sehr von denen unterscheiden, die sie vorher waren.  Das Grundprinzip von Corutin umfasst jedoch dieselben Konzepte, die wir in reaktiven RxJava-Fl√ºssen gewohnt sind.  Nehmen wir als Beispiel eine einfache RxJava-Konfiguration, um eine Netzwerkanforderung aus einer meiner Anwendungen zu erstellen: </p><br><ul><li>  Definieren Sie die Netzwerkschnittstelle f√ºr die Nachr√ºstung mit dem Rx-Adapter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">retrofit2: adapter-rxjava2</a> ).  Funktionen geben Objekte aus einem Rx-Framework zur√ºck, z. B. <strong>Single</strong> oder <strong>Observable</strong> .  (Hier werden Funktionen verwendet und keine Methoden, da davon ausgegangen wird, dass der alte Code auch in Kotlin geschrieben wurde. Nun, oder von Java √ºber Android Studio konvertiert). </li><li>  Wir rufen eine bestimmte Funktion aus einer anderen Klasse auf (z. B. ein Repository oder eine Aktivit√§t). </li><li>  Wir bestimmen f√ºr die Threads, auf welchem ‚Äã‚ÄãScheduler sie ausgef√ºhrt werden, und geben das Ergebnis zur√ºck (Methoden <strong>.subscribeOn ()</strong> und <strong>.observeOn ()</strong> ). </li><li>  Speichern Sie den Link zum Objekt zum Abbestellen (z. B. in CompositeObservable). </li><li>  Abonnieren Sie den Veranstaltungsstrom. </li><li>  Abbestellen des Streams abh√§ngig von den Ereignissen des Aktivit√§tslebenszyklus. </li></ul><br><p>  Dies ist der grundlegende Algorithmus f√ºr die Arbeit mit Rx (ohne Ber√ºcksichtigung der Zuordnungsfunktionen und der Details anderer Datenmanipulationen).  Was Corutin betrifft, √§ndert sich an dem Prinzip nicht viel.  Das gleiche Konzept, nur die Terminologie √§ndert sich. </p><br><ul><li>  Wir definieren die Netzwerkschnittstelle f√ºr das Retrofit mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adapters f√ºr Coroutine</a> .  Funktionen geben verz√∂gerte Objekte von der Corutin-API zur√ºck. </li><li>  Wir rufen diese Funktionen aus einer anderen Klasse auf (z. B. einem Repository oder einer Aktivit√§t).  Der einzige Unterschied: Jede Funktion sollte als <strong>suspend</strong> markiert sein. </li><li>  Definieren Sie den Dispatcher, der f√ºr die Coroutine verwendet wird. </li><li>  Wir speichern den Link zum <strong>Job-</strong> Objekt zum Abbestellen. </li><li>  F√ºhren Sie Coroutine auf jede m√∂gliche Weise aus. </li><li>  Wir stornieren Coroutinen abh√§ngig von den Ereignissen des Aktivit√§tslebenszyklus. </li></ul><br><p>  Wie Sie aus den obigen Sequenzen sehen k√∂nnen, ist der Ausf√ºhrungsprozess von Rx und Corutin sehr √§hnlich.  Wenn wir die Implementierungsdetails nicht ber√ºcksichtigen, bedeutet dies, dass wir unseren Ansatz beibehalten k√∂nnen - wir ersetzen nur einige Dinge, um unsere Implementierung koroutinenfreundlich zu gestalten. </p><br><p><img src="https://habrastorage.org/webt/rx/wm/xt/rxwmxtqqqcz0_wsvmjl8tjmel7m.png"></p><br><p>  Der erste Schritt, den wir unternehmen m√ºssen, besteht darin, Retrofit die R√ºckgabe von zur√ºckgestellten Objekten zu erm√∂glichen.  Aufgeschobene Objekte sind nicht blockierende Futures, die bei Bedarf r√ºckg√§ngig gemacht werden k√∂nnen.  Diese Objekte sind im Wesentlichen ein Coroutine-Job, der den Wert f√ºr den entsprechenden Job enth√§lt.  Die Verwendung des verz√∂gerten Typs erm√∂glicht es uns, dieselbe Idee wie Job zu mischen und zus√§tzlich zus√§tzliche Status wie Erfolg oder Misserfolg abzurufen. Dies macht ihn ideal f√ºr Netzwerkanforderungen. </p><br><p>  Wenn Sie Retrofit mit RxJava verwenden, verwenden Sie wahrscheinlich die RxJava Call Adapter Factory.  Gl√ºcklicherweise schrieb Jake Worton ihr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√Ñquivalent f√ºr Coroutine</a> . </p><br><p>  Wir k√∂nnen diesen Aufrufadapter im Retrofit-Builder verwenden und dann unsere Retrofit-Schnittstelle auf dieselbe Weise wie bei RxJava implementieren: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(okHttpClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OkHttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: MyService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retrofit = Retrofit.Builder() .baseUrl(<span class="hljs-string"><span class="hljs-string">"some_api"</span></span>) .client(okHttpClient) .addCallAdapterFactory(CoroutineCallAdapterFactory()) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrofit.create(MyService::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Schauen wir uns nun die oben verwendete MyService-Oberfl√§che an.  Wir m√ºssen die zur√ºckgegebenen Observable-Typen in der Retrofit-Schnittstelle durch Deferred ersetzen.  Wenn es fr√ºher so war: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Jetzt ersetzen wir es durch: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Deferred&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Jedes Mal, wenn wir getData () aufrufen, kehrt das zur√ºckgestellte Objekt zu uns zur√ºck - ein Analogon von Job f√ºr Netzwerkanforderungen.  Bisher haben wir diese Funktion mit RxJava irgendwie aufgerufen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myService.getData() .map { result -&gt; result.map { myDataMapper.mapFromRemote(it) } } }</code> </pre> <br><p>  In diesem RxJava-Stream rufen wir unsere Dienstprogrammfunktion auf und wenden dann die Zuordnungsoperation von der RxJava-API mit der anschlie√üenden Zuordnung der von der Anforderung zur√ºckgegebenen Daten zu etwas an, das in der UI-Ebene verwendet wird.  Dies wird sich ein wenig √§ndern, wenn wir eine Implementierung mit Coroutinen verwenden.  F√ºr den Anfang muss unsere Funktion <strong>ausgesetzt</strong> (zur√ºckgestellt) werden, um eine verz√∂gerte Operation innerhalb des Funktionsk√∂rpers durchzuf√ºhren.  Und daf√ºr muss auch die aufrufende Funktion verschoben werden.  Eine verz√∂gerte Funktion ist nicht blockierend und kann nach dem ersten Aufruf gesteuert werden.  Sie k√∂nnen es starten, anhalten, fortsetzen oder abbrechen. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { ... }</code> </pre> <br><p>  Jetzt m√ºssen wir unsere Utility-Funktion aufrufen.  Auf den ersten Blick machen wir dasselbe, aber wir m√ºssen uns daran erinnern, dass wir jetzt <strong>verz√∂gert</strong> statt beobachtbar werden. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData() ... }</code> </pre> <br><p>  Aufgrund dieser √Ñnderung k√∂nnen wir die Kartenoperationskette aus der RxJava-API nicht mehr verwenden.  Und selbst zu diesem Zeitpunkt stehen uns keine Daten zur Verf√ºgung - wir haben nur eine verz√∂gerte Instanz.  Jetzt m√ºssen wir die Funktion <strong>await ()</strong> verwenden, um auf das Ergebnis der Abfrage zu warten und dann den Code innerhalb der Funktion weiter auszuf√ºhren: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() ... }</code> </pre> <br><p>  Zu diesem Zeitpunkt erhalten wir die abgeschlossene Anfrage und die daraus verf√ºgbaren Daten zur Verwendung.  Daher k√∂nnen wir jetzt Mapping-Operationen ausf√ºhren: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.map { myDataMapper.mapFromRemote(it) } }</code> </pre> <br><p>  Wir haben unsere Retrofit-Schnittstelle zusammen mit der aufrufenden Klasse genommen und Coroutinen verwendet.  Jetzt m√∂chten wir diesen Code aus unserer Aktivit√§t oder aus Fragmenten aufrufen und die Daten verwenden, die wir vom Netzwerk erhalten haben. </p><br><p>  In unserer Aktivit√§t erstellen wir zun√§chst einen Link zu Job, in den wir unseren Coroutine-Vorgang zuweisen und ihn dann verwenden k√∂nnen, um beispielsweise das Abbrechen einer Anforderung w√§hrend eines <strong>onDestroy () -Aufrufs</strong> zu steuern. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myJob: Job? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { myJob?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() }</code> </pre> <br><p>  Jetzt k√∂nnen wir der Variablen myJob etwas zuweisen.  Schauen wir uns unsere Anfrage mit Coroutinen an: </p><br><pre> <code class="hljs pgsql">myJob = CoroutineScope(Dispatchers.IO).launch { val result = repo.getLeagues() withContext(Dispatchers.Main) { //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> result } }</code> </pre> <br><p>  In diesem Beitrag m√∂chte ich mich nicht mit Dispatchern befassen oder Operationen innerhalb von Coroutinen ausf√ºhren, da dies ein Thema f√ºr andere Beitr√§ge ist.  Kurz gesagt, was passiert hier: </p><br><ul><li>  Erstellen Sie eine CoroutineScope-Instanz mit IO Dispatcher als Parameter.  Dieser Dispatcher wird verwendet, um blockierende E / A-Vorg√§nge auszuf√ºhren, z. B. Netzwerkanforderungen. </li><li>  Wir starten unsere Coroutine mit der <strong>Startfunktion</strong> - diese Funktion startet eine neue Coroutine und gibt einen Link zu einer Variablen vom Typ Job zur√ºck. </li><li>  Dann verwenden wir den Link zu unserem Repository, um Daten durch Ausf√ºhren einer Netzwerkanforderung zu empfangen. </li><li>  Am Ende verwenden wir den Haupt-Dispatcher, um die Arbeit am UI-Thread zu erledigen.  Hier k√∂nnen wir den Benutzern die empfangenen Daten anzeigen. </li></ul><br><p>  Im n√§chsten Beitrag verspricht der Autor, etwas tiefer in die Details einzudringen, aber das aktuelle Material sollte ausreichen, um mit dem Studium von Coroutinen zu beginnen. </p><br><p>  In diesem Beitrag haben wir die RxJava-Implementierung von Retrofit-Antworten durch verz√∂gerte Objekte aus der Corutin-API ersetzt.  Wir rufen diese Funktionen auf, um Daten aus dem Netzwerk zu empfangen, und zeigen sie dann in unserer Aktivit√§t an.  Ich hoffe, Sie haben gesehen, wie wenig √Ñnderungen Sie vornehmen m√ºssen, um mit Coroutinen zu beginnen, und die Einfachheit der API gesch√§tzt, insbesondere beim Lesen und Schreiben von Code. </p><br><p>  In den Kommentaren zum urspr√ºnglichen Beitrag habe ich eine traditionelle Anfrage gefunden: Zeige den gesamten Code.  Aus diesem Grund habe ich eine einfache Anwendung erstellt, die beim Start einen Zugfahrplan mit der Yandex. Schedules-API empf√§ngt und in RecyclerView anzeigt.  Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/AndreySBer/RetrofitCoroutinesExample</a> </p><br><p>  Ich m√∂chte auch hinzuf√ºgen, dass Coroutinen ein schlechterer Ersatz f√ºr RxJava zu sein scheinen, da sie keinen √§quivalenten Satz von Operationen zum Synchronisieren von Threads bieten.  In diesem Zusammenhang lohnt es sich, die ReactiveX-Implementierung f√ºr Kotlin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxKotlin zu betrachten</a> . </p><br><p>  Wenn Sie Android Jetpack verwenden, habe ich auch ein Beispiel mit Retrofit, Coroutinen, LiveData und MVVM gefunden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codinginfinite.com/kotlin-coroutine-call-adapter-retrofit/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428994/">https://habr.com/ru/post/de428994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428984/index.html">Julia und Phasenportr√§ts dynamischer Systeme</a></li>
<li><a href="../de428986/index.html">ThinkJava-Konferenz Nr. 8 in Charkow</a></li>
<li><a href="../de428988/index.html">Tipps der Natur - Bew√∂lktes Nachtlicht</a></li>
<li><a href="../de428990/index.html">Konfigurationsbeispiele f√ºr UIViewController mit RouteComposer</a></li>
<li><a href="../de428992/index.html">Selektiver Bypass von Sperren auf Routern mit Padavan- und Keenetic OS-Firmware</a></li>
<li><a href="../de428996/index.html">Club der anonymen Weihnachtsm√§nner 2018-2019 auf Habrahabr</a></li>
<li><a href="../de428998/index.html">Verwendung der neuen experimentellen Profiler-Funktion in React</a></li>
<li><a href="../de429000/index.html">Warum Bill Gates die Toilette f√ºr 233 Milliarden Dollar erfunden hat</a></li>
<li><a href="../de429006/index.html">China: ‚ÄûWorld Assembly Shop‚Äú ist nicht so einfach, wie es scheint</a></li>
<li><a href="../de429008/index.html">Alpha Zero, Schach und Englisch lernen: Gegenwart und Zukunft der k√ºnstlichen Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>