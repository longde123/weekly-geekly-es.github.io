<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÜ ‚óªÔ∏è ü§ñ NewSQL: SQL geht nirgendwo hin üö¥üèæ üë®‚Äçüç≥ üêï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der NoSQL-Trend ist fast 10 Jahre alt, und Sie k√∂nnen sicher Schlussfolgerungen und Verallgemeinerungen ziehen. Wir werden dies tun und √ºber die Entwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL: SQL geht nirgendwo hin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/413557/"> Der NoSQL-Trend ist fast 10 Jahre alt, und Sie k√∂nnen sicher Schlussfolgerungen und Verallgemeinerungen ziehen.  Wir werden dies tun und √ºber die Entwicklung von NoSQL sprechen. <br><br>  Erinnern Sie sich daran, wie NoSQL geboren wurde.  Mal sehen, was gut und was schlecht daran ist und was den Test der Zeit bestanden hat.  Lassen Sie uns die Funktionen analysieren, die bereits in SQL vorhanden sind und jetzt in NoSQL DBMS angezeigt werden.  Wir heben die einzigartigen Werte von NoSQL hervor und schauen ein wenig voraus, was morgen auf dem Markt passieren wird. <br><br>  Und Konstantin Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@kostja</a> ), der Entwickler und Architekt des Tarantool DBMS, der in seinem Bericht auf der RIT ++ 2017 √ºber NewSQL-Trends sprach, wird uns dabei helfen, denn der Architekt soll zumindest verstehen, was in der Datenbankwelt passiert das Rad neu erfinden. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_8OZcgOKUyk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>√úber den Sprecher</b> : Jetzt arbeitet Konstantin Osipov an Tarantool, war aber zuvor an der Entwicklung von MySQL beteiligt. Als Konstantin anfing, an einer neuen Datenbank zu arbeiten, war er sehr verwirrt, warum dies √ºberhaupt getan werden sollte und warum die n√§chste Datenbank ben√∂tigt wurde.  Insbesondere die Einstellung zu NoSQL war in Bezug auf ‚ÄûUnder-SQL‚Äú sehr skeptisch. <br><br>  Die Entwicklung geht jedoch weiter, einige der urspr√ºnglichen Prinzipien sterben aus, und gleichzeitig √ºbernehmen NoSQL-Datenbanken die Funktionen von klassischem SQL.  Basierend auf den Ergebnissen dieser mehrj√§hrigen schnellen Transformation ist es durchaus m√∂glich, Zwischenergebnisse zu ziehen und sich mehrere Vorhersagen f√ºr die Zukunft zu machen. <br><a name="habracut"></a><br><h2>  Planen <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintergrund</a> .  Erinnern Sie sich daran, wie NoSQL geboren wurde, was gut und was schlecht daran ist. <br></li><li>  Mal sehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was mit NoSQL den Test der Zeit bestanden hat</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NoSQL SQL</a> : N1QL und CQL.  Lassen Sie uns die Funktionen analysieren, die bereits in SQL vorhanden sind und jetzt in NoSQL DBMS angezeigt werden. <br></li><li>  NoSQL ist bereits tot und NewSQL ist noch nicht geboren: Wie warm sich Tube SQL von SQL in NoSQL unterscheidet. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eindeutige Werte von NoSQL</a> .  Wir werden sehen, was in 10 Jahren Anstrengung gut passiert ist und was als n√§chstes passieren wird. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multi-Model-Datenbanken und NewSQL</a> .  Schauen wir uns ein wenig an, was morgen auf dem Markt sein wird. <br></li></ul><br><h2><a name="NoSQL_tenets"></a>  NoSQL-Grunds√§tze <br></h2><br>  Viele Leute versuchen jetzt, sich an den NoSQL-Begriff zu halten, aber er wurde 2009 weitgehend √ºbernommen, als das Hashtag <strong>#nosql</strong> erschien.  Der Entwickler von Last.FM hat dieses Tag f√ºr die verteilten Datenbanken mitap erfunden. <br><br>  Danach wurde das Tag auf Twitter immer beliebter und NoSQL wurde zu einem Abflussbeh√§lter oder Trichter f√ºr Frustration, wie ich es nenne - Frustration, die sich √ºber viele Jahre der Arbeit mit traditionellen Datenbanken angesammelt hat. <br><br><blockquote>  NoSQL ist ein Ausweg f√ºr Frustration, ein Tag, das sich jeder, der nicht √ºber gen√ºgend SQL-Funktionen verf√ºgt, angeeignet hat. <br></blockquote><br>  Diese Frustration muss irgendwie strukturiert und bestimmt sein, was die meisten Menschen in traditionellen DBMS nicht mochten.  Wir k√∂nnen 3 gro√üe Aufgabenbl√∂cke unterscheiden, f√ºr deren L√∂sung NoSQL erstellt wurde: <br><br><ul><li>  <strong>horizontale Skalierung;</strong> <br></li><li>  <strong>neue Datenmodelle;</strong> <br></li><li>  <strong>neue Modelle der Konsistenz.</strong> <br></li></ul><br>  Mal sehen, was diese Bl√∂cke sind.  Nehmen Sie zum Beispiel Schl√ºsselwertdatenbanken.  Die Hauptidee des Schl√ºsselwertdatenmodells besteht darin, dass die Datenbank einfach, aber skalierbar ist.  Eine gro√üe Anzahl von Problemen liegt auf den Schultern des Entwicklers, aber er hat eine strikte Garantie daf√ºr, dass seine Datenbank <strong>unendlich skalierbar ist</strong> .  Aber unendliche Skalierbarkeit ist keine Magie.  Garantien f√ºr Skalierbarkeit werden aufgrund der <strong>extrem einfachen Semantik der</strong> unterst√ºtzten Operationen erreicht: In einer Schl√ºsselwertdatenbank wirkt sich jede Operation ausschlie√ülich auf einen Clusterknoten aus. <br><br>  Anf√§nglich war es f√ºr die Community sehr schwierig, Datenmodelle von Skalenmodellen zu trennen.  Wenn Sie sich dieselbe Cassandra ansehen, wurde ihr Datenmodell in den fr√ºhen Versionen als Wide Column Store bezeichnet - eine breite Spaltendatenbank.  Wenn der Schl√ºsselwert des DBMS einen Index nach Schl√ºssel enth√§lt, werden im breiten Spaltenspeicher immer zwei Indizes automatisch erstellt: nach Schl√ºssel und nach Spaltenfamilie. <br><br>  Dar√ºber hinaus ist der Index nach Schl√ºssel zerlegbar, und der Index nach Spaltenfamilie ist lokal f√ºr einen bestimmten Datenknoten.  Aus diesem Grund haben wir eine horizontale Skalierung erreicht, aber gleichzeitig die M√∂glichkeit erhalten, lokale Abfragen f√ºr die Spaltenfamilie durchzuf√ºhren.  Oldtimer erinnern sich, dass eine √§hnliche Funktion in Oracle unter Beibehaltung des relationalen Modells implementiert und als verkn√ºpfte Tabelle bezeichnet wurde.  Diese Funktion erm√∂glichte es, den physischen Speicherort der beiden Tabellen im verbundenen Formular anzugeben.  Breiter Spaltenspeicher in Cassandra - Implementiert eine verkn√ºpfte Tabelle mit automatischer Verteilung √ºber den Cluster. <br><br><blockquote>  Die Zusammenf√ºhrung des Datenmodells und des Skalenmodells ist genau das Problem, das mit dem relationalen Modell gel√∂st wurde.  Willkommen in den 70ern. </blockquote><br>  Zus√§tzlich zu neuen Datenmodellen hat NoSQL neue Konsistenzmodelle implementiert.  Ja, ja, wieder dieses ber√ºhmte <strong>CAP-Theorem</strong> .  √úber das CAP-Theorem zu sprechen, am√ºsiert mich die ganze Zeit - wer braucht es √ºberhaupt?  Da es keinen St√∂r der zweiten Frische gibt, gibt es keine andere Antwort auf die Frage nach der Konsistenz von Daten als eine: <strong>Die Datenbank muss diese Konsistenz garantieren</strong> .  Daher sind neue Konsistenzmodelle meiner Meinung nach auch ein aussterbender Trend. <br><br><h2><a name="NoSQL_today"></a>  NoSQL heute <br></h2><br>  Die These, die ich zuallererst ausdr√ºcken m√∂chte, ist die der gesamten √ºberlebenden NoSQL-Bewegung: <br><br><ul><li>  horizontale Skalierung; </li><li>  <s>neue Datenmodelle</s> dokumentieren und grafische Datenmodelle; </li><li>  <s>neue Modelle der Konsistenz.</s> </li></ul><br>  Von den Thesen √ºber neue Datenmodelle haben fast eineinhalb √ºberlebt, und die These √ºber Konsistenzmodelle ist vollst√§ndig gestorben. <br><br><h2>  Todesm√ºtze <br></h2><br>  Warum haben einige Konsistenzmodelle nicht √ºberlebt? <br><br>  ‚óè <strong>Eventuelle Konsistenz: Laufzeitinflation</strong> <br>  Wer verwendet eine Datenbank mit einer funktionierenden Vektoruhr und die Gesch√§ftslogik der Anwendung ist darauf ausgerichtet?  - Niemand.  Wer verwendet Datenbanken mit CRDT (konfliktfreie replizierte Datentypen)?  Wer benutzt Riak?  - Niemand.  Was benutzen die Leute?  H√§ufiger PostgreSQL, seltener andere Basen, zum Beispiel MongoDB. <br><br>  ‚óè <strong>MongoDB: Atomic wird durch isoliert ersetzt, Transaktionen werden in 3.xx hinzugef√ºgt</strong> <br>  Diese Datenbank verf√ºgt √ºber eine asynchrone Replikation.  Dies ist sehr einfach zu verstehen, obwohl es tats√§chlich <strong>vier Arten der asynchronen Replikation gibt</strong> .  Die Replikation von Transaktionsdaten kann erfolgen, nachdem eine Transaktion lokal festgeschrieben wurde.  bevor die Transaktion lokal festgeschrieben wird. <br><br>  Das hei√üt, der Festschreibungspunkt f√ºr die Hauptdatenbank kann auch auf verschiedene Weise mit dem Festschreibungspunkt f√ºr das Replikat korreliert werden. <br><br>  Ein Eintrag in das lokale Protokoll wurde bereits vorgenommen, es wurde jedoch noch nicht zum Replikat geflogen.  Angenommen, Sie m√∂chten warten, bis sie zumindest zu einer Replik wegfliegt.  Weggeflogen - hei√üt nicht geflogen.  Angekommen - dies bedeutet nicht, dass es in das lokale Journal auf dem Replikat geschrieben wurde. <br><br>  Anfangs hatte MongoDB einen Modus: Die Anfrage kam auf dem Server an, die Datenbank antwortete mit OK - sie ist noch nicht einmal auf der Festplatte oder im Logbuch angekommen - sie ging nirgendwo hin.  Aus diesem Grund funktioniert alles sehr schnell, aber dann haben sie begonnen, MongoDB daf√ºr zu kritisieren, und standardm√§√üig wurde in sp√§teren Versionen 3+ die Transaktion zun√§chst in das Journal geschrieben und erst danach eine Best√§tigung an den Client gesendet. <br><br>  Das hei√üt, selbst die asynchrone Replikation ist ein Abgrund semantischer Modelle.  Daher sind <strong>Konsistenzmodelle f√ºr einen gro√üen Kreis von Entwicklern zu kompliziert, um sie zu verstehen, und Transaktionen und synchrone Replikation ersetzen das Sortiment exotischer Modelle</strong> . <br><br>  Vor dem Hintergrund des Todes des Konsistenzmodells gibt es immer noch einen interessanten Trend bei der Entwicklung einer tats√§chlich strengeren Konsistenz.  Es gibt Transaktionen in Redis, obwohl ich sie nicht als Transaktionen bezeichnen w√ºrde, aber auf Kosten einer echten Transaktion gibt es Kontroversen ohne diese. <br><br>  Schauen wir uns die Geschichte der Transaktionen in NoSQL an.  Zun√§chst implementierte MongoDB die Atomizit√§t auf Dokumentebene.  Dann wurde ein isolierter Ausf√ºhrungsmodus hinzugef√ºgt, damit Entwickler, wenn sie es wirklich wollen, mehrere Dokumente atomar aktualisieren k√∂nnen. <br><br>  ‚óè <strong>Transaktionen erneut bearbeiten</strong> <br>  Zu Beginn von NoSQL wurde dem Entwickler angeboten, den gesamten Business Case in einem Korbdokument zusammenzufassen.  Es erscheint ein ganzer Fluss, der als dom√§nengesteuertes Design bezeichnet wird, wodurch diese Perversion auf den Rang eines Entwurfsmusters angehoben wird.  Wenn alles in einem Dokument gespeichert ist, wird die Atomizit√§t einfach erreicht: Sie haben eine Transaktion, einen Gesch√§ftsprozess und eine atomare √Ñnderung in einem Dokument vorgenommen. <br><br>  Aber es stellt sich heraus, dass dies nicht funktioniert.  Daten m√ºssen normalisiert werden, um Speicherredundanz zu vermeiden.  Sie m√ºssen f√ºr analytische Abfragen normalisiert werden.  Am Ende entwickelt sich das Datenmodell weiter - und das Dokument, in dem gestern alle f√ºr ein Gesch√§ftsszenario heute erforderlichen Informationen gespeichert werden konnten, muss erweitert und erg√§nzt werden. <br><br>  Zeigen Atomarit√§tsprobleme?  Wie eng Datenmodelle mit Konsistenzmodellen zusammenh√§ngen - das Aufkommen von Transaktionen und die synchrone Replikation machen die meisten Modelle in NoSQL unn√∂tig. <br><br><h2>  Datenmodelle <br></h2><br>  Lassen Sie uns nun √ºber die n√§chste Geschichte sprechen - die Geschichte mit Datenmodellen. <br><br>  Nach SQL erfundene Gruppen von Datenmodellen: <br><br><ul><li>  Schl√ºsselwert <br></li><li>  Dokumentarfilm <br></li><li>  Wide Column Store; <br></li><li>  Datenstruktur-Server (f√ºr Redis); <br></li><li>  Diagrammdatenbanken. <br></li></ul><br>  Cool!  Wir haben so viele Datenmodelle!  Und wie gut skalieren sie? <br><br>  Dies ist eine These, die sich haupts√§chlich auf die sogenannte Hyperkonvergenz bezieht, wenn alle modernen Projekte billige Einzelserver-Server verwenden und Unternehmen aufh√∂ren, vertikal skalierbare Maschinen zu kaufen. <br><br>  Hyperkonvergenz ist so gr√ºndlich in unser Leben getreten, dass es heute sogar in vertikal skalierten Maschinen, falls vorhanden, bereits horizontal skalierbare Software gibt - sehen Sie sich an, wie PureStorage funktioniert, oder, wenn Sie sich erinnern, bei Nacht Nutanix.  Nat√ºrlich verkaufen sie Schr√§nke an Menschen, aber diese Schr√§nke sind wie normale Regale bei einem Hosting-Anbieter angeordnet. <br><br>  Das hei√üt, die horizontale Skalierung ist ein Trend, der Druck auf alle aus√ºbt, einschlie√ülich der Erfinder neuer Datenmodelle.  Welche Datenmodelle eignen sich f√ºr die horizontale Skalierung und welche sind schlecht? <br><br>  Ist es gut oder schlecht f√ºr die horizontale Skalierung?  Die Antwort ist in der Tat ziemlich kontrovers, wir werden sp√§ter darauf zur√ºckkommen. <br><br><h3>  Redis <br></h3><br>  Als Redis den Redis-Cluster hinzuf√ºgte, stellte sich heraus, dass nicht alle Datenmodelloperationen normal horizontal skaliert werden. <br><br><img src="https://habrastorage.org/webt/e9/j_/lu/e9j_lugugsuorakmg8o8qonvqmi.jpeg"><br><br>  Dies ist ein Zitat aus der Dokumentation, in der sie schreiben, dass auf einem bestimmten Shard etwas f√ºr sie funktioniert und etwas wirklich wie in einem echten Cluster. <br><br>  Das grundlegende Problem dieses Ansatzes ist das gleiche wie bei MySQL, das wir aufgegriffen und uns die Hand gesch√ºttelt haben.  Das hei√üt, der Entwickler hat zwei Datenmodelle: <br><br><ol><li>  Zum einen denkt er im Rahmen der relationalen Algebra. <br></li><li>  Wenn er dann √ºber unabh√§ngiges Sharding nachdenkt, denkt er im Datenmodell der Shard-relationalen Algebra. <br></li></ol><br>  <strong>Ein gutes Datenmodell sollte universell sein</strong> .  Was ist sch√∂n an der relationalen Algebra - das Ergebnis einer Projektion ist eine Beziehung, das Ergebnis eines Operators ist eine Beziehung.  Und sobald wir manuell damit beginnen, MySQL auf den Cluster zu √ºbertragen, verlieren wir das. <br><br>  Redis f√ºgt jedoch einen Redis-Cluster hinzu, da <strong>jeder horizontal skalieren m√∂chte</strong> . <br><br><h3>  Diagrammdatenbanken <br></h3><br>  Graphendatenbanken sind ein gutes Beispiel, <strong>um die Konzepte der horizontalen Skalierung von Computer und Speicher</strong> zu <strong>trennen</strong> .  Informationen k√∂nnen immer durch eine beliebige Anzahl von Knoten geteilt werden.  Wenn die Datenbank jedoch von Natur aus darauf ausgelegt ist, die von ihr gespeicherten Daten zu verarbeiten, und diese Berechnungen nicht horizontal skaliert werden, tritt das Problem einer effektiven horizontalen Speicherung auf, mit der die Berechnungen funktionieren k√∂nnen. <br><br>  Betrachten wir das Problem der Skalierung von Diagramm-DBMS - SQL-DBMS sind mit sehr √§hnlichen Skalierungsbarrieren konfrontiert. <br><br><img src="https://habrastorage.org/webt/pc/yp/mm/pcypmmbjtpdrzvgb4yqhwqd5f4g.jpeg"><br><br>  Nehmen Sie die lokale Datenbank, in der das Diagramm gespeichert ist.  Fr√ºher oder sp√§ter wird ein Knoten gef√ºllt, und wir beginnen, andere Knoten zu verwenden.  Sobald wir mehr als einen Knoten verwenden, wird der zentrale Knoten √ºberlastet, da die Lokalit√§t der Anforderungen verloren geht.  Einige Abfragen im Diagramm m√ºssen mehrere physische Knoten durchlaufen, dh es treten Netzwerkverz√∂gerungen auf. <br><br>  Angenommen, wir haben etwas anderes gemacht - sie haben alles mit einer guten Splitterfunktion genommen und zerst√∂rt.  Wir berechnen einen bestimmten Hash, indem wir alle Daten in unserem Cluster zuf√§llig verteilen - und wir bekommen ein weiteres Problem. <br><br><img src="https://habrastorage.org/webt/g_/sh/z5/g_shz5c2avjc9vhwhtyfqmrwgbi.jpeg"><br><br>  Wenn im vorherigen Schema zumindest einige Abfragen einwandfrei funktioniert haben, sind <strong>100% der Abfragen hier dumm</strong> , da die meisten Datenbankabfragen mit der Diagrammdurchquerung verbunden sind.  Jeder Umweg vom Knoten muss irgendwohin f√ºhren, und meistens m√ºssen Sie zur Berechnung der Anforderung zu einem anderen Knoten gehen. <br><br><img src="https://habrastorage.org/webt/hm/sg/hp/hmsghpnyj_w7yzi80oyuc6ecf3s.jpeg"><br><br>  Die Idee entsteht, ungef√§hr zu shardieren, wie in der obigen Abbildung gezeigt: Finden Sie Cluster und platzieren Sie sie auf Ihren Knoten: Eng verbundene Teilmengen werden zusammen platziert, schwach verbundene Teilmengen werden beabstandet. <br><br>  Dies ist eine ideale Option, aber die <strong>ideale Option existiert nur in der Theorie</strong> .  Live-Daten eignen sich nicht f√ºr die statische Partitionierung.  Um diesen Ansatz zu implementieren, m√ºssen wir Cluster auf einer sich dynamisch √§ndernden Menge automatisch erkennen und Knoten abh√§ngig von entstehenden und verschwindenden Bindungen st√§ndig verschieben. <br><br>  Daher sind Neo4j im Gro√üen und Ganzen jetzt wie klassische SQL-Datenbanken skaliert.  Sie arbeiten schon seit einiger Zeit am Sharding und versuchen, die beschriebenen Probleme zu l√∂sen. <br><br>  Die These, die ich vorgebracht habe, ist, dass die <strong>horizontale Skalierung Druck auf alle aus√ºbt</strong> und alle Datenmodelle fr√ºher oder sp√§ter gezwungen sein werden, sie zu implementieren.  Einige Modelle bleiben jedoch bei uns, andere nicht. <br><br>  Wenn wir zum Beispiel die Schl√ºsselwert- und Dokumentdatenbanken in reiner Form betrachten, ist meine Aussage, dass dies nicht der Fall sein wird.  Wenn Sie sich Diagrammdatenbanken ansehen, nehmen diese bereits ein bedeutendes Segment ein, stehen jedoch unter dem Druck der horizontalen Skalierung. <br><br>  Werden Graphendatenbanken verschwinden?  Es ist wahrscheinlicher, dass <strong>Spalten wie Dokumente in allen Produkten enthalten sind</strong> .  Dieser Trend wird als Multi-Modell-Datenbank bezeichnet. Sp√§ter im Bericht werde ich ein Beispiel geben, wie dies in der Praxis funktionieren kann.  Schauen wir uns zun√§chst JSON an, um den Trend der Datenbanken mit mehreren Modellen zu veranschaulichen. <br><br><h3>  Json <br></h3><br>  Im Folgenden finden Sie ein Beispiel daf√ºr, wie ein Trend, der sich zu einem umfassenden Trend entwickelt, funktioniert. <br><br><blockquote>  Ich behaupte, dass jede Datenbank, die JSON in irgendeiner Weise unterst√ºtzen kann, JSON unterst√ºtzt. </blockquote><br>  M√∂glicherweise unterst√ºtzen einige Datenbanken f√ºr Matrix-Computing JSON nicht.  Aber h√∂chstwahrscheinlich wird es dort n√ºtzlich sein.  Und der Rest wird definitiv sein. <br><br><table border="1"><tbody><tr><td width="141"></td><td width="94">  MySQL <br></td><td width="95">  PostgreSQL <br></td><td width="66">  Redis <br></td><td width="85">  Couchbase <br></td><td width="85">  Cassandra <br></td><td width="56">  Neo4j <br></td></tr><tr><td width="141">  JSON-Speicher <br></td><td width="94">  Ja <br></td><td width="95">  Ja <br></td><td width="66">  Ja <br></td><td width="85">  Ja <br></td><td width="85">  Ja <br></td><td width="56">  Ja! <br></td></tr><tr><td width="141">  JSON-Feldoperationen <br></td><td width="94">  Ja <br></td><td width="95">  Ja <br></td><td width="66">  Ja <br></td><td width="85">  Ja <br></td><td width="85">  Nein <br></td><td width="56">  Nein <br></td></tr><tr><td width="141">  Json-Abfrage <br></td><td width="94">  Ja <br></td><td width="95">  Ja <br></td><td width="66">  Nein <br></td><td width="85">  Ja <br></td><td width="85">  Ja <br></td><td width="56">  Nein <br></td></tr><tr><td width="141">  JSON-Sekund√§rindex <br></td><td width="94">  Ja <br></td><td width="95">  Ja <br></td><td width="66">  Nein <br></td><td width="85">  Ja <br></td><td width="85">  Nein <br></td><td width="56">  Nein <br></td></tr></tbody></table><br>  In dieser Tabelle k√∂nnen Sie visuell sehen, was mit Datenmodellen geschieht.  Relationale Datenbanken in ihrer Unterst√ºtzung f√ºr JSON liegen sogar vor nicht relationalen Datenbanken derselben Cassandra.  Es gibt keine Sekund√§rschl√ºssel f√ºr JSON-Felder.  Und sogar Grafikdatenbanken beginnen, JSON einzuschlie√üen, da <strong>jeder JSON ben√∂tigt</strong> . <br><br>  Datenbanken mit mehreren Modellen und insbesondere JSON als Datentyp, der in fast allen Produkten zu finden ist, werden daher ernsthaft und f√ºr lange Zeit von NoSQL √ºbrig bleiben. <br><br>  <strong>Aber wenn alle Datenbanken JSON unterst√ºtzen, warum ben√∂tigen Sie √ºberhaupt NoSQL-Datenbanken?</strong> <br><br>  Es gibt nur noch eine Geschichte - die horizontale Skalierung.  Wir m√∂chten horizontal skalieren und verwenden daher etwas anderes als MySQL oder PostgreSQL. <br><br><img src="https://habrastorage.org/webt/qp/rj/up/qprjupel17nogdvuzw2eal03hw4.jpeg"><br><br>  Dies ist die Keynote von Thomas Ulin, VP MySQL Engineering bei Oracle, der √ºber die Zukunft von MySQL spricht.  Das gleiche passiert in der Postgres-Community und anderen relationalen Produkten.  Der Druck der horizontalen Skalierung wirkt sich aufgrund des √úbergangs zu Hyperkonvergenz und Cloud Computing auf 100% der Produkte aus. <br><br>  Laut Thomas ist ihre Vision ein Produkt mit sofortiger Hochverf√ºgbarkeit und Skalierbarkeit.  Wir sprechen √ºber Hochverf√ºgbarkeit in erster Linie InnoDB Cluster, dies ist Gruppenreplikation + InnoDB.  Eine solche Datenbank stirbt nie, selbst wenn sie mit einem Hammer getroffen wird. <br><br>  Dann schreibt Thomas " <strong>Skalierungsfunktionen eingebrannt</strong> " - "Wir haben alle diese Funktionen gebacken".  Der Punkt ist, dass sie durch x-Releases (ich denke, dass x = 2, 3) MySQL Cluster in seiner reinen Form erhalten, die SQL auf dem Cluster, JSON-Speicher im Cluster, unterst√ºtzt. <br><br>  Bereits heute <strong>verf√ºgt MySQL √ºber ein X-Protokoll, das MongoDB sehr √§hnlich</strong> ist und f√ºr die Arbeit mit JSON ausgelegt ist. <br><br><h2><a name="SQL_NoSQL"></a>  SQL in NoSQL <br></h2><br>  Schauen wir uns nun die Bewegung von der anderen Seite an.  Um den Tod festzustellen, m√ºssen Sie nicht nur untersuchen, wie SQL die Prinzipien von NoSQL √ºbernimmt, sondern auch umgekehrt. <br><br><table border="1"><tbody><tr><td width="125"></td><td width="125">  Mongodb <br></td><td width="125">  Couchbase <br></td><td width="125">  Cassandra <br></td><td width="125">  Redis <br></td></tr><tr><td width="125">  Datenschema <br></td><td width="125">  Ja * <br></td><td width="125">  Nein <br></td><td width="125">  Ja <br></td><td width="125">  Nein <br></td></tr><tr><td width="125">  NULL / Abwesende Werte <br></td><td width="125">  Ja * <br></td><td width="125">  Ja <br></td><td width="125">  Ja <br></td><td width="125">  Nein <br></td></tr><tr><td width="125">  Tritt bei <br></td><td width="125">  Ja <br></td><td width="125">  Ja <br></td><td width="125">  Nein <br></td><td width="125">  Nein <br></td></tr><tr><td width="125">  Sekund√§rschl√ºssel <br></td><td width="125">  Ja * <br></td><td width="125">  Ja <br></td><td width="125">  Ja, aber ... <br></td><td width="125">  Nein <br></td></tr><tr><td width="125">  GRUPPE VON <br></td><td width="125">  Ja * <br></td><td width="125">  Ja <br></td><td width="125">  Nein <br></td><td width="125">  Nein <br></td></tr><tr><td width="125">  JDBC / ODBC <br></td><td width="125">  Nein <br></td><td width="125">  Ja <br></td><td width="125">  Nein <br></td><td width="125">  Nein <br></td></tr></tbody></table><br>  Hier gibt es tats√§chlich auch interessante Einblicke.  Ich habe meiner Meinung nach die F√ºhrer genommen.  Ich bin damit einverstanden, dass nicht alles hier ist, zum Beispiel ist Elastic auch ein NoSQL-F√ºhrer.  Da Elastic jedoch immer noch in erster Linie eine L√∂sung f√ºr die Volltextsuche ist, habe ich es nicht in die Tabelle aufgenommen. <br><br>  Times Series-Datenbanken als Trend, den ich nicht ber√ºhre.  Es gibt eine These unter den Zeitreihen von Bewegungen, dass dies eine separate Nische ist, √§hnlich wie bei Graphendatenbanken, aber wenn Sie tiefer graben, sitzt Postgres unter der Haube. <br><br><h3>  Couchbase <br></h3><br>  Meiner Meinung nach bietet Couchbase die unterschiedlichsten M√∂glichkeiten aus der SQL-Welt.  Jeder wei√ü, dass <strong>Couchbase Memcached ist</strong> .  Dormando ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alan Kasindorf</a> ), einer der Entwickler von Memcached, hatte eine v√∂llig andere Produktvision, die keine horizontale Skalierung beinhaltete.  Daher gabelte sich Memcache, um horizontal zu skalieren.  Es lief gut und begann Gesch√§fte zu machen, dann fusionierte es mit CouchDB und so weiter und so fort. <br><br>  Couchbase sagt sich zun√§chst, dass es sich um eine <strong>schemenlose Datenbank handelt</strong> .  Memcache ist urspr√ºnglich ein sehr einfacher Schl√ºsselwert.  Nun wollen wir sehen, wie sich diese Selbstidentifikation im Laufe der Zeit √§ndert. <br><br>  Zum Beispiel hat Couchbase Sekund√§rschl√ºssel, und <strong>Sekund√§rschl√ºssel sind eigentlich der Anfang des Schemas</strong> .  Wenn Sie sagen, dass Sie einige Felder haben, anhand derer Sie den Index erstellen, sprechen Sie bereits √ºber das Schema der von Ihnen gespeicherten Datendokumente. <br><br>  Da Couchbase heute nach und nach die gesamte Geschichte √ºber die Vergangenheit von Memcache aus der Dokumentation herausschneidet, wird morgen auch die Geschichte √ºber die eventuelle Konsistenz herausgeschnitten, obwohl es heute noch viele Geschichten √ºber die mangelnde Lesekonsistenz gibt - Sekund√§rschl√ºssel sind schlie√ülich konsistent. <br><br>  Aber der Haken ist, dass Couchbase JDBC / ODBC hat.  ,       Tableau  ClickView ‚Äî ,    CQL    SQL.   <strong>     ‚Äî    SQL.</strong> <br><br>  ,    . <br><br><img src="https://habrastorage.org/webt/ru/4o/wy/ru4owybeykx975o_owylkunnxrw.jpeg"><br><br>     ,   - ,      ,   ,    -   ‚Äî     ,     SQL. <br><br> ,    IS MISSING ‚Äî   ,     IS NULL? <br><br>   JDBC, ODBC       SQL    ?   30-40  ,  SQL-      SQL  ,  ,       :     look-in,  ,           .. <br><br>  ,   . <strong> ,  ,    .</strong> <br><br>  ,  Couchbase  JDBC/ODBC ‚Äî    .      ,   ‚Äî   . <br><br><h3> Secondary keys <br></h3><br>  ,    NoSQL ‚Äî   ,  ‚Äî   ,    .     OrientDB, ,   ,   . <br><br> SQL-     ,     (  ,    ),  NoSQL,   . <br><br>   NoSQL-   secondary keys.    secondary keys? <br><br> <strong>        </strong> (  ‚Äî    ): <br><br><ol><li>    ,     ,  <strong>  </strong> .               ,    range-,  SQL      .    range-             map/reduce   . <br></li><li>  <strong>    </strong> .     index notes,    .           range-  ..,     . <br></li></ol><br>           ,    , ,   ,     ,  .    ,      . <br><br> <strong>    </strong> .   , NoSQL-      SQL,   ,     ,     . <br><br>      :       CockroachDB?   : <strong>      ,       </strong> . ,  MySQL         ‚Äî       legacy.    ,  ,     .. <br><br>    ,  NoSQL-      legacy  10   . ,   ,     .     SQL-   ,   PostgreSQL,  ,  MySQL   Couchbase  ,    True NewSQL. <br><br>     ,  secondary keys.  MongoDB   SQL,     . ,       JOINs,   ,    . <br><br>  Redis  No,       .  Redis    ,      ‚Äî   .   ,      ,    ,    . <br><br>   ,  Redis    ‚Äî ,    - .    ,    Redis-,  SQL.    ,     Redis SQLite,     ‚Äî storage   ‚Äî  Redis',  in memory. <br><br>  NoSQL   ,         ,     ? <br><br><h3>   <br></h3><br>    ,  NoSQL     .   ,   ,    ,   SQL     .       SQL  . <br><br>  schemaless  ,    ,   ,     waterfall    :    agile,        -     .    ,        ,    CREATE TABLE,    . <br><br>   ,   online alter table.   Oracle    ,          . <br><br>     SQL      ,   . <strong>       MongoDB ‚Äî  ,     </strong> . <br><br>  MongoDB   ,  schemaless.        .   ,     ,      strict.  validation level  validation action. Validation level   ,           . <br><br>     ,       ,     - .          ,   ,   .  validation action     reject,  warn:   warning,     validation action. <br><br>   <strong>        </strong> .  ,  MongoDB (      Tarantool),     . <br>  Cassandra        JSON,      .      ‚Äî    ,    .  ,   ,   NoSQL,    . <br><br><h3>  <br></h3><br>   -,  NoSQL     SQL     . <br><br><img src="https://habrastorage.org/webt/je/z2/fj/jez2fj0_acxhcfrhuqh4zis3-es.jpeg"><br><br>  eventually consistent  ,    ,        ,    <strong> </strong> .    ,      ‚Äî    .   . <br><br>       ? <br><br>     ,    ,    .   BigQuery      , , Vertica,     . <br><br>  NoSQL     .  ,     SELECT    LTP,    LTP -   Key-value. <br><br><blockquote>    ,    NoSQL-          . </blockquote><br>   SELECT  JOIN    ,    ,    ,  <strong>    </strong> ‚Äî    .. <br><br><h2><a name="NoSQL_val"></a> NoSQL:   <br></h2><br> ,    <strong></strong> ,     ,       .     <strong>domain-specific languages</strong> . <br><br> NoSQL     DSL.     ‚Äî  <strong>RethinkDB ReQL</strong> .    ,    ‚Äî         domen specific language.     Python,  JavaScript  .. ‚Äî      .      SQL  ,           . <br><br>       ReQL,  . ReQL ,     ,     ‚Äî      .    RethinkDB, ,   ,     ,      ,   . <br><br>      : <br><br><ul><li> Elasticsearch Query Language: <ul><li> MIN/MAX/AVG; </li><li> derivative/percentiles/histogram/cumulative sum/serial diff; </li></ul></li><li> JSONIQ; <br></li><li> GraphQL; <br></li><li> SparQL; <br></li><li> Pregel. <br></li></ul><br>   , ,       SQL,   . <strong> -  SQL!</strong> <br><br>     SQL ‚Äî    OLTP ,  GROUP BY, Window Functions,       (recursive). SQL    ,      .     !        ,   ,    . <br><br><blockquote> ,   ,   . ,     ,    , ,       . <br></blockquote><br> , , Pregel ‚Äî     .     :   ,               /   .  -    ,  .   ,      ,     . <br><br>  -    SQL,    ,      ,       . <br><br>   ,  ,     <strong> ,  ,       </strong> .   . <br><br><h2><a name="MMDB"></a> -   <br></h2><br>  ,     ,   .      . <br><br><img src="https://habrastorage.org/webt/ul/ov/dv/ulovdv_tas-ndbzdymkwujc-cdm.jpeg"><br><br>    ArangoDB,      -      :   ,    ,   ( ),      ,    . <br><br><img src="https://habrastorage.org/webt/pp/k4/tb/ppk4tbnrjvmxesm52ac3somgiz4.jpeg"><br><br>   , ,          .               .    :  ,     . <br><br><img src="https://habrastorage.org/webt/zg/ml/gy/zgmlgy0df4it9m10lfxzyqnk4lo.jpeg"><br><br>    ,     ,    . ,  ,      ,    ,     .     . <br><br> <strong>           </strong> .           ,   ,   relations.  ,   relation    ,    ,       relations  .. <br><br><h2> UPSERT:   <br></h2><br>  Hier geht es nicht nur um NoSQL, aber dies ist ein Trend, der mir sehr wichtig erscheint - dies ist <strong>schreiboptimierter Speicher</strong> - der meiner Meinung nach ernsthaft und f√ºr lange Zeit bei uns bleiben wird. <br><br>  Weder SQL noch NoSQL haben Anweisungen, die nur von Natur aus geschrieben werden.  Sogar absert, das in MongoDB enthalten ist, liest in einigen F√§llen auch Daten.  Einf√ºgen ist auch ein Lesevorgang. Wenn im Dokument bereits eine ID definiert ist, m√ºssen Sie √ºberpr√ºfen, ob keine solche ID vorhanden ist. <br><br>  Sie sagen - wenn es Indizes gibt, m√ºssen wir lesen.  Aber <strong>selbst wenn es Indizes gibt, ist das Lesen nicht immer notwendig</strong> .  Die Idee ist folgende: Sie m√∂chten auf keinen Fall lesen, Sie m√ºssen dies nicht tun, Sie k√ºmmern sich nicht um das Ergebnis des Lesens.  Sie m√∂chten der Datenbank Daten hinzuf√ºgen, falls diese dort noch nicht vorhanden sind.  Wenn sie vorhanden sind, nehmen wir an, Sie ersetzen ihre alte Version durch eine neue oder f√ºhren einen Zusammenf√ºhrungsbefehl aus.  Das hei√üt, Sie m√ºssen eine <strong>neue Semantik</strong> erfinden, um nicht lesen zu k√∂nnen. <br><br>  Meiner Meinung nach bietet dies derzeit keine einzige Datenbank, aber die Attraktivit√§t schreiboptimierter Algorithmen ist so gro√ü, dass ich diese M√∂glichkeit wirklich m√∂chte.  Denn dank schreiboptimiertem Speicher ist die Schreibleistung von LSM-B√§umen (RocksDB, LevelDB und andere) <strong>ohne Lesen um 2 Gr√∂√üenordnungen h√∂her als die Schreibleistung mit Lesen</strong> .  Anstelle von 10 Tausend Anfragen pro Sekunde kann es eine Million auf einem Knoten geben. <br>  Aus diesem Grund gewinnt die Zeitreihendatenbank jetzt, weil ihnen diese semantische L√ºcke fehlt.  Der in ihnen ankommende Datenstrom ist klar als Zeitreihe definiert und wird insbesondere sehr schnell und kompakt in die Datenbank geschrieben.  weil Sie die Eindeutigkeit nicht √ºberpr√ºfen m√ºssen.  Dies ist eine Gr√∂√üenordnung schneller, einfach weil es in herk√∂mmlichen Datenbanken keine solche semantische Operation gibt, die nur geschrieben werden w√ºrde. <br><br>  Ich denke es wird erscheinen. <br><br><img src="https://habrastorage.org/webt/v0/-w/tl/v0-wtldczsojccjohz5nzbrcnrs.jpeg"><br><br>  Wohin geht das alles als n√§chstes?  Wenn Sie sehr weit wegschauen, h√∂rt die Innovation nicht bei NoSQL und NewSQL auf.  Unser Verst√§ndnis von Informationen entwickelt sich st√§ndig weiter. <br><br><blockquote>  Einer der wichtigsten Trends der Zukunft ist meiner Meinung nach, dass wir Informationen immer weniger l√∂schen werden. <br></blockquote><br>  Hierf√ºr entsteht eine ganze Reihe von Produkten, die als temporale Datenbanken bezeichnet werden. <br><br><h2>  Nach NewSQL: Zeitdatenbank <br></h2><br>  Unten finden Sie Screenshots von Microsoft SQL Server.  Dies ist eine Datenbank, mit der Sie Fragen zu einem bestimmten Zeitpunkt stellen k√∂nnen: Es gibt SELECT f√ºr den aktuellen Status, es ist jedoch weiterhin m√∂glich, SELECT f√ºr ein Datum in der Vergangenheit festzulegen. <br><br><img src="https://habrastorage.org/webt/1z/pz/c5/1zpzc5-px5chjpkth1v12pa71bs.jpeg"><br><br>  Dies f√ºhrt zu einer Reihe neuer Datenbankanwendungen.  Zun√§chst k√∂nnen Sie den Verlauf eines Objekts verfolgen.  Zweitens k√∂nnen Sie automatisch Gruppen und Berichte nach Zeitraum berechnen.  Sie m√ºssen hierf√ºr keine separaten Tabellen erstellen - Sie haben eine nat√ºrliche Darstellung in einer Tabelle: eine Entit√§t - eine Tabelle. <br><br><img src="https://habrastorage.org/webt/_w/ls/kk/_wlskk1vblw3g3_fxcsgdgjqdm0.jpeg"><br><br>  Aus Sicht der internen Struktur ist dies eigentlich die Haupttabelle und die Tabelle mit dem Verlauf.  Jede Leitung ist zwei dem System bekannten Zeiten zugeordnet.  Dies sind nicht nur zwei Spalten, die Sie hinzugef√ºgt haben, sondern Daten, die das System automatisch unterst√ºtzt: <br><br><ol><li>  <strong>die Zeit, zu der der Datensatz zur Datenbank hinzugef√ºgt wurde,</strong> <br></li><li>  <strong>Ereigniszeit.</strong> <br></li></ol><br>  Es sind verschiedene Zeiten, egal wie am√ºsant. <br><br>  Angenommen, Iwan Iwanowitsch ist am 17. November gestorben, und dieser Datensatz wurde am 20. November in die Datenbank eingegeben - beide Zeiten werden in solchen Datenbanken gespeichert. <br><br>  Dies ist meiner Meinung nach auch einer der grundlegenden Trends.  Warum denke ich so?  Wenn wir zu den Sekund√§rschl√ºsseln und der eventuellen Konsistenz zur√ºckkehren, k√∂nnen Sie dieses Problem nur speichern, indem Sie absolut alles speichern. <br><br><blockquote>  Wenn wir nie etwas aus der Datenbank l√∂schen m√ºssen, ist unsere Datenbank immer konsistent - eine so interessante Geschichte! <br></blockquote><br><h2>  N√ºtzliche Links <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.couchbase.com/documentation/server/current/developer-guide/query-consistency.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://martinfowler.com/books/nosql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://jimwebber.org/2011/02/on-sharding-graph-databases/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.mongodb.com/manual/core/document-validation/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.oreilly.com/pub/e/3847</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.oreilly.com/ideas/data-modeling-with-multi-model-databases</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://redislabs.com/blog/redis-as-a-json-store/</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">FAQ</b> <div class="spoiler_text"><blockquote>  <em>- Gibt es Entwicklungen beim Erstellen einer neuen Datenbank, die nicht f√ºr MySQL, PostgreSQL, MongoDB usw. gelten?</em> </blockquote><br>  Die Frage ist auf gute Weise: Wird es neue Datenbanken und Startups geben?  Ich denke, sie werden immer weniger erscheinen.  Der Sturm hat nachgelassen, und jetzt werden wir eher den Abflug als die Ankunft sehen. CockroachDB war einer der letzten, die ankamen. <br><br>  Kommen wir zum Punkt.  Mein Professor an der Universit√§t sagte, dass DBMS eine ewig gr√ºne Fl√§che ist.  Deshalb werden wir immer eine Art Bewegung sehen.  Aber ich denke, dass in naher Zukunft grunds√§tzlich andere Produkte nicht auftauchen werden, es wird Konvergenz geben, keinen Boom. <br><br><blockquote>  <em>- Keine Frage, sondern eine Erg√§nzung: SQL versucht h√§ufig, Deckungsindizes zu erstellen, damit das Ergebnis der SQL-Abfrage nicht die Speicherebene betrifft, sondern sofort aus dem Index abgerufen wird.</em>  <em>Der Index selbst ist eigentlich ein Sonderfall des Graphen.</em>  <em>Vielleicht geht der Trend also dahin, dass die gesamte Datenbank allm√§hlich in einen steilen Graphenindex √ºbergeht?</em> <br></blockquote><br>  Dies ist eine wunderbare Geschichte, die alle Vertreter von Grafikdatenbanken ihren Kunden gerne erz√§hlen - sie funktioniert nicht!  Weil es viele M√∂glichkeiten gibt, Indizes zu aktualisieren, und es gibt viele Indizierungsoptionen, aber nicht jeder hat ein Diagramm!  Beruhigen wir uns - so wie nicht alles relational ist, ist nicht jeder ein Graph. <br><br><blockquote>  <em>- Wohin gehen Ihrer Meinung nach Elastic und dergleichen?</em>  <em>Ich spreche von der Tatsache, dass er anf√§ngt, sehr seltsame Probleme zu l√∂sen - er versucht, Zeitreihen und eine analytische Basis f√ºr die Arbeit mit Protokollen vorzut√§uschen.</em>  <em>Es scheint, dass niemand es f√ºr die Textsuche verwendet.</em> <br></blockquote><br>  Elastic muss sich nirgendwo bewegen, weil Elastic sich gro√üartig anf√ºhlt.  Es l√∂st ein bestimmtes Gesch√§ftsproblem - es ist eine effektive Suche und alles, was mit diesem √ñkosystem zu tun hat. <br><br>  Ich denke, dass alles in erster Linie von der Tatsache herr√ºhrt, dass Elastic versucht, alles zu sein.  Aber hier ist die Frage von der Aufgabe, die elastische Aufgabe ist den Zeitreihenaufgaben sehr √§hnlich, daher ist sie gerechtfertigt.  Elastic eignet sich gut zum Durchsuchen gro√üer Arrays derselben Protokolle usw. <br><br>  Es gibt einen engeren Fall - es ist nur eine Volltextsuche, aber Sie werden nicht viel daraus machen.  Es muss mehr getan werden, um sich √ºberhaupt von den Wettbewerbern abzuheben.  Daher geschieht dies alles. <br><br>  Ich glaube jedoch nicht, dass Elastic morgen Bankgesch√§fte abwickeln wird.  Alles geht bis zu dem Punkt, an dem Couchbase zum Beispiel sein wird - wenn nicht Bankgesch√§fte, aber etwas so schnelles. <br></div></div><br><blockquote><h3>  Nachrichten </h3><br>  Sehr bald, <strong>am 21. Juni, wird die</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool-Konferenz</a> <strong>in Moskau stattfinden</strong> - oder kurz <strong>T + Conf</strong> - eine Konferenz nicht nur √ºber Tarantool selbst, sondern auch √ºber den Einsatz von <strong>In-Memory-Computing im</strong> Allgemeinen <strong>.</strong> <br><br><ul><li>  Konstantin Osipov plant, einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen,</a> in dem er die Vinyl-Architektur, ihre Funktionen und vor allem die f√ºr diese Engine spezifischen Optimierungs- und Leistungs√ºberwachungsmechanismen so konsistent und detailliert wie m√∂glich untersuchen wird. </li><li>  Vladimir Perepelitsa m√∂chte in einem Tutorial-Format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeigen,</a> dass Tarantool eine Datenbank ist, die ein gro√ües Potenzial f√ºr die Verwendung als Anwendungsserver hat. </li><li>  Vladislav Zaitsev wird sich diesem Thema nicht von seiner Seite n√§hern - von der Seite des Internets der Dinge - und insbesondere erkl√§ren, warum das IoT-Steuerungssystem. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413557/">https://habr.com/ru/post/de413557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413547/index.html">Erleben Sie 2 Millionen kopflose Sitzungen</a></li>
<li><a href="../de413549/index.html">Web Development Lecture Course</a></li>
<li><a href="../de413551/index.html">Scrollen und Aufmerksamkeit (Studie 2018)</a></li>
<li><a href="../de413553/index.html">Der Registrar REG.RU beraubte den Partner des Zugriffs auf 70.000 Domains und nahm deren Service f√ºr sich</a></li>
<li><a href="../de413555/index.html">Sichere Interoperabilit√§t in verteilten Systemen</a></li>
<li><a href="../de413559/index.html">Web-Verschlechterung oder wie man das Web f√ºr Menschen lesbar macht</a></li>
<li><a href="../de413561/index.html">Geschwindigkeit des kompilierten Linq Expression Tree</a></li>
<li><a href="../de413563/index.html">4 M√∂glichkeiten, ein Paket in Go zu importieren</a></li>
<li><a href="../de413565/index.html">Kubernetes Hack-Analyse - Hintert√ºr √ºber Kubelet</a></li>
<li><a href="../de413567/index.html">Erste Schritte mit Microservices in Spring Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>