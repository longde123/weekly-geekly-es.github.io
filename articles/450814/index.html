<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 👴🏽 ☪️ Cómo funciona BGP ✳️ 🏪 👰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy nos fijamos en el protocolo BGP. No hablaremos durante mucho tiempo por qué es y por qué se usa como el único protocolo. Hay mucha información sob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo funciona BGP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450814/">  Hoy nos fijamos en el protocolo BGP.  No hablaremos durante mucho tiempo por qué es y por qué se usa como el único protocolo.  Hay mucha información sobre este tema, por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Entonces, ¿qué es BGP?  BGP es un protocolo de enrutamiento dinámico que es el único protocolo EGP (Protocolo de puerta de enlace externo).  Este protocolo se utiliza para construir enrutamiento en Internet.  Considere cómo se construye el vecindario entre dos enrutadores BGP. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3fa/da6/dd3/3fada6dd3c41923367af475da9b0ae10.jpg" alt="Mi imagen"></a> <br>  Considere el vecindario entre Router1 y Router3.  Los configuraremos utilizando los siguientes comandos: <a name="habracut"></a><br><pre><code class="plaintext hljs">router bgp 10 network 192.168.12.0 network 192.168.13.0 neighbor 192.168.13.3 remote-as 10 router bgp 10 network 192.168.13.0 network 192.168.24.0 neighbor 192.168.13.1 remote-as 10</code> </pre> <br>  El vecindario dentro de un sistema autónomo es AS 10. Después de ingresar datos en un enrutador, por ejemplo en el Enrutador1, este enrutador intenta establecer una relación de vecindad con el Enrutador3.  El estado inicial cuando no sucede nada se llama <b>inactivo</b> .  Tan pronto como bgp esté configurado en el Router1, comenzará a escuchar el puerto TCP 179: pasará al estado <b>Conectar</b> , y cuando intente abrir una sesión con el Router3, pasará al estado <b>Activo</b> . <br><br>  Después de que se establece la sesión entre Router1 y Router3, se lleva a cabo un intercambio de mensajes abiertos.  Cuando el Router1 envía este mensaje, este estado se llamará <b>Open Sent</b> .  Y cuando recibe un mensaje Abierto del Router3, pasará al estado <b>Confirmar abierto</b> .  Considere la publicación abierta con más detalle: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9d/231/607/d9d2316070de22049a24da6d86cecb2b.jpg" alt="Mi imagen"></a> <br>  Este mensaje transmite información sobre el protocolo BGP que utiliza el enrutador.  Al intercambiar mensajes abiertos, el enrutador 1 y el enrutador 3 comunican información sobre sus configuraciones entre sí.  Se pasan los siguientes parámetros: <br><blockquote><ul><li>  <b>Versión</b> : esto incluye la versión BGP que está utilizando el enrutador.  La versión actual de BGP es la versión 4 que se describe en RFC 4271. Dos enrutadores BGP intentarán negociar una versión compatible, cuando haya una falta de coincidencia, no habrá sesión BGP. </li><li>  <b>Mi AS</b> : esto incluye el número AS del enrutador BGP, los enrutadores deberán acordar los números AS y también define si ejecutarán iBGP o eBGP. </li><li>  <b>Tiempo de espera</b> : si BGP no recibe ningún mensaje de mantenimiento o actualización del otro lado durante el tiempo de espera, entonces declarará al otro lado 'muerto' y anulará la sesión de BGP.  Por defecto, el tiempo de espera se establece en 180 segundos en los enrutadores Cisco IOS, el mensaje de mantenimiento se envía cada 60 segundos.  Ambos enrutadores deben acordar el tiempo de espera o no habrá una sesión BGP. </li><li>  <b>Identificador de BGP</b> : esta es la identificación del enrutador BGP local que se elige como OSPF: <br><ul><li>  Utilice la ID de enrutador que se configuró manualmente con el comando bgp router-id. </li><li>  Use la dirección IP más alta en una interfaz de bucle invertido. </li><li>  Use la dirección IP más alta en una interfaz física. </li></ul></li><li>  <b>Parámetros opcionales</b> : aquí encontrará algunas capacidades opcionales del enrutador BGP.  Este campo se ha agregado para que se puedan agregar nuevas funciones a BGP sin tener que crear una nueva versión. Las cosas que puede encontrar aquí son: <br><br><ul><li>  Soporte para MP-BGP (Multi Protocol BGP). </li><li>  soporte para ruta de actualización. </li><li>  soporte para números AS de 4 octetos. </li></ul></li></ul></blockquote>  Para establecer un vecindario, se deben cumplir las siguientes condiciones: <br><br><ul><li>  Número de versión  Versión actual 4. </li><li>  El número AS debe coincidir con el que configuró el <b>vecino 192.168.13.3 remoto-como 10</b> . </li><li>  El ID del enrutador debe ser diferente del vecino. </li></ul><br>  Si alguno de los parámetros no cumple con estas condiciones, el enrutador enviará un mensaje de <b>notificación</b> donde indica un error.  Después de enviar y recibir mensajes abiertos, la relación de vecindario ingresa al estado <b>ESTABLECIDO</b> .  Después de eso, los enrutadores pueden intercambiar información sobre rutas y hacerlo mediante mensajes de <b>actualización</b> .  Aquí hay un mensaje de actualización que envía Router1 a Router3: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/853/f42/1f0/853f421f0a69f407c5ae4eae3423240c.jpg" alt="Mi imagen"></a> <br><br>  Aquí se indican las redes informadas por los atributos Router1 y Path, que son análogas a las métricas.  Hablaremos sobre los atributos de ruta con más detalle.  Además, los mensajes keepalive se transmiten dentro de la sesión TCP.  Se transmiten, por defecto, cada 60 segundos.  Este es un temporizador Keepalive.  Si el mensaje Keepalive no se recibe durante el Temporizador de retención, esto significará la pérdida de comunicación con el vecino.  Por defecto, es igual a - 180 segundos. <br><br>  Placa útil: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/853/f42/1f0/853f421f0a69f407c5ae4eae3423240c.jpg" alt="Mi imagen"></a> <br><br>  Parece haber descubierto cómo los enrutadores transmiten información entre sí, ahora intentemos descubrir la lógica del protocolo BGP. <br><br>  Para anunciar una ruta a la tabla BGP, como en los protocolos IGP, se usa el comando de red, pero la lógica de operación es diferente.  Si en IGP, después de especificar una ruta en el comando de red, IGP observa qué interfaces pertenecen a esta subred y las incluye en su tabla, luego el comando de red en BGP busca en la tabla de enrutamiento y busca una coincidencia <b>exacta</b> con la ruta en el comando de red.  Si se encuentran estos, estas rutas caerán en la tabla BGP. <br><blockquote>  Busque una ruta en la tabla de enrutamiento IP actual del enrutador que coincida exactamente con los parámetros del comando de red;  si existe la ruta IP, coloque el NLRI equivalente en la tabla BGP local. </blockquote>  Ahora elevaremos BGP a todos los restantes y veremos cómo se selecciona la ruta dentro de un AS.  Después de que el enrutador BGP recibe rutas del vecino, comienza la selección de la ruta óptima.  Aquí debe comprender qué tipo de vecinos pueden ser: internos y externos.  ¿El enrutador de configuración comprende si el vecino configurado es interno o externo?  Si en un equipo: <br><br><pre> <code class="plaintext hljs">neighbor 192.168.13.3 remote-as 10</code> </pre> <br>  como parámetro remoto como, se especifica el AS, que se configura en el enrutador con el comando router bgp 10. Las rutas que provienen del AS interno se consideran internas y las rutas del AS externo se consideran externas.  Y con respecto a cada uno, una lógica diferente de recepción y envío de obras.  Considere la siguiente topología: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cea/5f8/2b0/cea5f82b050662b2632cab01f3de8e24.jpg" alt="Mi imagen"></a> <br><br>  Cada enrutador tiene una interfaz loopback configurada con ip: xxxx 255.255.255.0, donde x es el número del enrutador.  En Router9 tenemos una interfaz de bucle invertido con la dirección 9.9.9.9 255.255.255.0.  Lo anunciaremos en BGP y veremos cómo se distribuye.  Esta ruta se transmitirá al Router8 y al Router12.  Con Router8, esta ruta irá a Router6, pero en Router5 no estará en la tabla de enrutamiento.  Además, en el Router12 esta ruta entrará en la tabla, pero en el Router11 tampoco lo será.  Tratemos de resolverlo.  Considere qué datos y parámetros están siendo transmitidos por Router9 a sus vecinos, informando esta ruta.  El paquete a continuación se enviará desde Router9 a Router8. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5e7/80b/ca0/5e780bca084e8f42dab14d03f62723b6.jpg" alt="Mi imagen"></a> <br>  La información de ruta consta de atributos de ruta. <br><br>  Los atributos de ruta se dividen en 4 categorías: <br><br><ol><li>  <b>Obligatorio bien conocido</b> : todos los enrutadores BGP deben reconocer estos atributos.  Debe estar presente en todas las actualizaciones. </li><li>  <b>Discrecionalmente conocido</b> : todos los enrutadores BGP deben reconocer estos atributos.  Pueden estar presentes en las actualizaciones, pero su presencia no es necesaria. </li><li>  <b>Transitivo opcional</b> : es posible que no todas las implementaciones de BGP lo reconozcan.  Si el enrutador no reconoce el atributo, marca la actualización como parcial y la envía más a los vecinos, conservando el atributo no reconocido. </li><li>  <b>Opcional no transitivo</b> : puede no ser reconocido por todas las implementaciones de BGP.  Si el enrutador no reconoce el atributo, el atributo se ignora y se descarta durante la transmisión a los vecinos. </li></ol><br>  Ejemplos de atributos BGP: <br><br><ul><li>  <b>Conocido obligatorio</b> : <br><ul><li>  Ruta del sistema autónomo </li><li>  Siguiente salto </li><li>  Origen </li></ul><br></li><li>  <b>Discrecional bien conocido</b> : <br><ul><li>  Preferencia local </li><li>  Agregado atómico </li></ul></li><li>  <b>Transitivo opcional</b> : <br><ul><li>  Agregador </li><li>  Comunidades </li></ul></li><li>  <b>Opcional no transitivo</b> : <br><ul><li>  Discriminador de múltiples salidas (MED) </li><li>  ID del creador </li><li>  Lista de clúster </li></ul></li></ul><br>  En este caso, estaremos interesados ​​en Origin, Next-hop, AS Path.  Dado que la ruta pasa entre Router8 y Router9, es decir, dentro del mismo AS, se considera interna y prestaremos atención a Origin. <br><br>  Atributo de origen: indica cómo se recibió la ruta en la actualización.  Posibles valores de atributo: <br><br><ul><li>  0 - IGP: NLRI obtenido dentro del sistema autónomo original; </li><li>  1 - EGP: NLRI aprendido por el Protocolo de puerta de enlace exterior (EGP).  BGP predecesor, no utilizado </li><li>  2 - Incompleto: NLRI se aprendió de otra manera </li></ul><br>  En nuestro caso, como se puede ver en el paquete, es 0. Cuando esta ruta se transmite al Router12, este código tendrá el código - 1. <br><br>  Siguiente, siguiente salto.  Atributo del siguiente salto <br><br><ul><li>  Esta es la dirección IP del enrutador eBGP a través del cual pasa la ruta a la red de destino. </li><li>  El atributo cambia cuando el prefijo se pasa a otro AS. </li></ul><br>  En el caso de iBGP, es decir, dentro de un AS, el siguiente salto se indicará como el que aprendió o contó sobre esta ruta.  En nuestro caso, será 192.168.89.9.  Pero cuando transfiera esta ruta de Router8 a Router6, Router8 la cambiará y la reemplazará por la suya.  El siguiente salto será: 192.168.68.8.  Esto nos lleva a dos reglas: <br><br><ol><li>  Si el enrutador pasa la ruta a su vecino interno, entonces no cambia el parámetro Next-hop. </li><li>  Si el enrutador envía la ruta a su vecino externo, cambia el siguiente salto a la ip de la interfaz desde la que envía este enrutador. </li></ol><br>  Esto nos lleva a comprender el primer problema: por qué no habrá una ruta en la tabla de enrutamiento en Router5 y Router11.  Consideremos con más detalle.  Entonces, Router6 recibió la información de ruta 9.9.9.0/24 y la agregó de forma segura a la tabla de enrutamiento: <br><br><pre> <code class="plaintext hljs">Router6#show ip route bgp Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2 ia - IS-IS inter area, * - candidate default, U - per-user static route o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP a - application route + - replicated route, % - next hop override, p - overrides from PfR Gateway of last resort is not set 9.0.0.0/24 is subnetted, 1 subnets B 9.9.9.0 [20/0] via 192.168.68.8, 00:38:25</code> </pre> <br>  Ahora Router6 pasó la ruta Router5 y no cambió la primera regla del próximo salto.  Es decir, el Router5 debería agregar <b>9.9.9.0 [20/0] a través de 192.168.68.8</b> , pero no tiene una ruta a 192.168.68.8 y, por lo tanto, esta ruta no se agregará, aunque la información sobre esta ruta se almacenará en la tabla BGP: <br><br><pre> <code class="plaintext hljs">&lt;b&gt;Router5#show ip bgp BGP table version is 1, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path * i 9.9.9.0/24 192.168.68.8 0 100 0 45 i&lt;/b&gt;</code> </pre> <br>  La misma situación ocurrirá entre Router11-Router12.  Para evitar tal situación, es necesario configurar de modo que el Router6 o el Router12, pasando la ruta a sus vecinos internos, sustituyan su dirección IP como Next-hop.  Se hace usando el comando: <br><br><pre> <code class="plaintext hljs">neighbor 192.168.56.5 next-hop-self</code> </pre> <br>  Después de este comando, el Router6 enviará un mensaje de Actualización, donde para las rutas como Next-hop se indicará la ip de la interfaz Gi0 / 0 del Router6 - 192.168.56.6, después de lo cual esta ruta ya estará en la tabla de enrutamiento. <br><br>  Sigamos adelante y veamos si esta ruta aparece en Router7 y Router10.  No aparecerá en la tabla de enrutamiento y podríamos pensar que el problema es como el primero con el parámetro Next-hop, pero si miramos la salida del comando show ip bgp, veremos que la ruta no se recibió incluso con el Next-hop incorrecto, que significa que la ruta ni siquiera se transmitió.  Y esto nos llevará a la existencia de otra regla: <br><blockquote>  Las rutas recibidas de vecinos internos no se transfieren a otros vecinos internos. </blockquote>  Como el Router5 recibió la ruta del Router6, no se transmitirá a su otro vecino interno.  Para que la transferencia tenga lugar, debe configurar la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflector de ruta</a> , o configurar las relaciones de vecindad completamente conectadas (Full Mesh), es decir, el Router5-7 será vecino de cada una.  Utilizaremos el Reflector de ruta en este caso.  En el Router5, debe usar este comando: <br><br><pre> <code class="plaintext hljs">neighbor 192.168.57.7 route-reflector-client</code> </pre> <br>  Route-Reflector cambia el comportamiento de BGP al transmitir una ruta a un vecino interno.  Si el vecino interno se especifica como <b>route-reflector-client</b> , se anunciarán las rutas internas a estos clientes. <br><br>  ¿La ruta no apareció en Router7?  No te olvides de Next-hop también.  Después de estas manipulaciones, la ruta también debería estar en el Router7, pero esto no sucede.  Esto nos lleva a otra regla: <br><blockquote>  La regla del siguiente salto solo funciona para rutas externas.  Para rutas internas, el atributo del siguiente salto no se reemplaza. </blockquote><br>  Y tenemos una situación en la que necesita crear un entorno utilizando enrutamiento estático o IGP para informar a los enrutadores sobre todas las rutas dentro del AS.  Registraremos las rutas estáticas en Router6 y Router7 y luego obtendremos la ruta deseada en la tabla del enrutador.  En AS 678, actuaremos un poco diferente: escribiremos las rutas estáticas para 192.168.112.0/24 en Router10 y 192.168.110.0/24 en Router12.  A continuación, establecemos la relación de vecindad entre Router10 y Router12.  También configuramos Router12 para enviar su próximo salto para Router10: <br><br><pre> <code class="plaintext hljs">neighbor 192.168.110.10 next-hop-self</code> </pre> <br>  El resultado será que el Router10 recibirá la ruta 9.9.9.0/24, se recibirá tanto del Router7 como del Router12.  Veamos qué elección hace Router10: <br><br><pre> <code class="plaintext hljs">Router10#show ip bgp BGP table version is 3, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.112.12 0 100 0 45 i 192.168.107.7 0 123 45 i</code> </pre> <br>  Como podemos ver, dos rutas y una flecha (&gt;) significan que la ruta a través de 192.168.112.12 está seleccionada. <br>  Veamos cómo se lleva a cabo el proceso de selección de ruta: <br><br><ol><li>  En primer lugar, al recibir la ruta, se verifica la disponibilidad de su Next-hop.  Es por eso que, cuando recibimos una ruta en el Router5 sin configurar Next-hop-self, esta ruta ya no se envió para su procesamiento. </li><li>  El siguiente es el parámetro Peso.  Este parámetro no es un atributo de ruta (PA) y no se transmite en mensajes BGP.  Se configura localmente en cada enrutador y se usa solo para manipular la selección de ruta en el enrutador.  Considera un ejemplo.  Se muestra arriba que Router10 eligió la ruta para 9.9.9.0/24 a través de Router12 (192.168.112.12).  Para cambiar el parámetro Wieght, puede usar el mapa de ruta para establecer rutas específicas, o asignar peso a su vecino usando el comando: <br><br><pre> <code class="plaintext hljs"> neighbor 192.168.107.7 weight 200</code> </pre> <br>  Ahora todas las rutas de este vecino tendrán tal peso.  Veamos cómo cambia la elección de ruta después de esta manipulación: <br><br><pre> <code class="plaintext hljs">Router10#show bgp *Mar 2 11:58:13.956: %SYS-5-CONFIG_I: Configured from console by console BGP table version is 2, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt; 9.9.9.0/24 192.168.107.7 200 123 45 i * i 192.168.112.12 0 100 0 45 i</code> </pre> <br>  Como puede ver, la ruta a través del Router7 ahora está seleccionada, pero esto no tendrá ningún efecto en los otros enrutadores. </li><li>  En tercer lugar tenemos - Preferencia local.  Este parámetro es un atributo discrecional bien conocido, lo que significa que su presencia es opcional.  Este parámetro es válido solo dentro de un AS y afecta la elección de la ruta solo para los vecinos internos.  Por eso, se transmite solo en los mensajes de actualización destinados al vecino interno.  En los mensajes de actualización para vecinos externos está ausente.  Por lo tanto, fue asignado a la discrecionalidad conocida.  Intentemos aplicarlo en Router5.  En Router5, deberíamos tener dos rutas para 9.9.9.0/24: una a través de Router6 y la segunda a través de Router7. <br><br>  Buscamos: <br><br><pre> <code class="plaintext hljs">Router5#show bgp BGP table version is 2, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.56.6 0 100 0 45 i</code> </pre> <br>  Pero como puede ver una ruta a través de Router6.  ¿Y dónde está la ruta a través de Router7?  ¿Quizás ni siquiera existe en Router7?  Buscamos: <br><br><pre> <code class="plaintext hljs">Router#show bgp BGP table version is 10, local router ID is 7.7.7.7 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.56.6 0 100 0 45 i 192.168.107.10 0 678 45 i</code> </pre> <br>  Extraño, todo parece estar en orden.  ¿Por qué no se transmite al Router5?  El caso es que BGP tiene una regla: <br><blockquote>  El enrutador transmite solo aquellas rutas que utiliza por sí mismo. </blockquote><br>  Router7 utiliza la ruta a través de Router5, por lo que la ruta a través de Router10 no se transmitirá.  De vuelta a la preferencia local.  Establezcamos la Preferencia local en Router7 y veamos cómo Router5 responde a esto: <br><br><pre> <code class="plaintext hljs">route-map BGP permit 10 match ip address 10 set local-preference 250 access-list 10 permit any router bgp 123 neighbor 192.168.107.10 route-map BGP in&lt;/b&gt;</code> </pre> <br>  Entonces, creamos un mapa de ruta en el que caen todas las rutas y le indicamos al Router7 que cambie el parámetro de Preferencia Local a 250 al recibirlo, por defecto es 100. Observamos lo que sucedió en el Router5: <br><br><pre> <code class="plaintext hljs">Router5#show bgp BGP table version is 8, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.57.7 0 250 0 678 45 i</code> </pre> <br>  Como vemos ahora, Router5 prefiere la ruta a través de Router7.  La misma imagen estará en Router6, aunque es más rentable para él elegir una ruta a través de Router8.  También agregamos que un cambio en este parámetro requiere un reinicio del vecindario para que el cambio surta efecto.  Lee <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a>  Con preferencia local resuelta.  Ir al siguiente parámetro. </li><li>  Preferencia de ruta con el parámetro del siguiente salto 0.0.0.0, es decir, rutas locales o agregadas.  Después de ingresar el comando de red, a estas rutas se les asigna automáticamente el parámetro Peso igual al máximo - 32678: <br><br><pre> <code class="plaintext hljs">Router#show bgp BGP table version is 2, local router ID is 9.9.9.9 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt; 9.9.9.0/24 0.0.0.0 0 32768 i</code> </pre> </li><li>  El camino más corto a través de AS.  Se selecciona el parámetro más corto AS_Path.  Cuanto menos pase la ruta, mejor será.  Considere la ruta a 9.9.9.0/24 en Router10: <br><br><pre> <code class="plaintext hljs">Router10#show bgp BGP table version is 2, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path * 9.9.9.0/24 192.168.107.7 0 123 45 i *&gt;i 192.168.112.12 0 100 0 45 i</code> </pre> <br>  Como puede ver, Router10 eligió la ruta a través de 192.168.112.12 porque el parámetro AS_Path contiene solo 45 para esta ruta, y 123 y 45 en el otro caso. Intuitivamente. </li><li>  El siguiente parámetro es Origen.  ¿Es IGP (ruta obtenida usando BGP) mejor que EGP (ruta obtenida usando BGP predecesor, ahora no se usa) y EGP es mejor que Incomplete?  (recibido de alguna otra manera, por ejemplo, por redistribución). </li><li>  El siguiente parámetro es MED.  Teníamos Wieght, que solo funcionaba localmente en el enrutador.  Había una preferencia local que funcionaba solo dentro de un sistema autónomo.  Como puede suponer, MED es un parámetro que se transmitirá entre sistemas autónomos.  Muy buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> sobre esta opción. </li></ol><br>  No se utilizarán más atributos, pero si las dos rutas tienen los mismos atributos, se utilizarán las siguientes reglas: <br><br><ol><li>  Elija una ruta a través del vecino IGP más cercano. </li><li>  Seleccione la ruta más antigua para la ruta eBGP. </li><li>  Elija una ruta a través del vecino con la ID de enrutador BGP más baja. </li><li>  Elija una ruta a través del vecino con la dirección IP más baja. </li></ol><br>  <b>Ahora considere el tema de la convergencia BGP.</b> <br><br>  Veamos qué sucede si, por ejemplo, el Router6 pierde la ruta 9.9.9.0/24 a través del Router9.  Apagamos la interfaz Gi0 / 1 Router6, que comprende de inmediato que la sesión BGP con Router8 está desconectada y el vecino se ha ido, lo que significa que la ruta recibida no es válida.  El Router6 envía inmediatamente mensajes de Actualización donde indica la red 9.9.9.0/24 en el campo Rutas Retiradas.  Tan pronto como el Router5 reciba un mensaje similar, envíelo al Router7.  Pero dado que Router7 tiene una ruta a través de Router10, enviará inmediatamente Update con una nueva ruta en respuesta.  Si el estado de la interfaz no puede detectar la caída del vecino, entonces debe esperar a que se active el Temporizador de retención. <br><br>  <b>Confederación</b> <br><br>  Si recuerdas, hablamos sobre el hecho de que a menudo tienes que usar una topología completamente conectada.  Con una gran cantidad de enrutadores en un AS, esto puede causar grandes problemas, para evitar esto es necesario usar confederaciones.  Un AS se divide en varios sub-AS, lo que le permite funcionar sin el requisito de una topología completamente conectada. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d55/6a8/741/d556a874120b70319381332cdddf739b.jpg" alt="Mi imagen"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un enlace a este </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laboratorio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí está la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> configuración para GNS3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, con esta topología, tendríamos que conectar todos los enrutadores en AS 2345 entre sí, pero usando Confederación, podemos establecer relaciones de vecindad solo entre enrutadores conectados directamente entre sí. Hablemos de esto en detalle. Si solo tuviéramos AS 2345, entonces </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laForge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recibiría una marcha de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picard y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le diría a sus </font><b><font style="vertical-align: inherit;">enrutadores </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero no le dirían a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crusher al</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respecto </font><font style="vertical-align: inherit;">. Además, las rutas que el propio router rasprastranyaet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laforge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no serían transferidos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trituradora</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ni </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendría que establecer una Ruta-Reflector o una relación de vecindario completamente conectada. </font><font style="vertical-align: inherit;">Al dividir un AS 2345 en 4 sub-AS (2,3,4,5) para cada enrutador, terminamos con una lógica de operación diferente. </font><font style="vertical-align: inherit;">Todo está perfectamente descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuentes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCIE Routing and Switching v5.0 Official Cert Guide, Volume 2, Fifth Edition, Narbik Kocharians, Terry Vinson. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sitio web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sitio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNS3Vault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450814/">https://habr.com/ru/post/450814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450802/index.html">Corte de legado</a></li>
<li><a href="../450804/index.html">Impresión de metal en 3D en la industria automotriz: comience con poco</a></li>
<li><a href="../450806/index.html">Cuando una variable de entorno acelera el proceso 40 veces</a></li>
<li><a href="../450810/index.html">Las 7 mejores formas de verificar rápidamente las competencias de los especialistas de TI antes de la entrevista</a></li>
<li><a href="../450812/index.html">PSR-14: el evento principal en PHP</a></li>
<li><a href="../450816/index.html">Encabezados HTTP para el desarrollador responsable</a></li>
<li><a href="../450818/index.html">Desde alta latencia de ceph hasta parche de kernel con eBPF / BCC</a></li>
<li><a href="../450820/index.html">Comité del programa FrontendConf: marcos, horizontes, experiencia mundial y misión de la conferencia.</a></li>
<li><a href="../450822/index.html">Marcos desaparecidos</a></li>
<li><a href="../450824/index.html">El estado de css</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>