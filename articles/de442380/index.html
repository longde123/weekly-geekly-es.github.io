<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 🧓🏿 🤞🏽 Chaos sortieren 🤹 ⛸️ 👐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie die Praxis zeigt, entsteht ein großer Teil der Probleme nicht aufgrund der Lösungen selbst, sondern aufgrund der Art und Weise, wie die Kommunikat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chaos sortieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442380/"><p> Wie die Praxis zeigt, entsteht ein großer Teil der Probleme nicht aufgrund der Lösungen selbst, sondern aufgrund der Art und Weise, wie die Kommunikation zwischen den Komponenten des Systems erfolgt.  Wenn die Kommunikation zwischen den Komponenten des Systems durcheinander ist, fällt das gesamte System aus, da Sie nicht versuchen, die einzelnen Komponenten gut zu schreiben. </p><br><p>  Achtung  Im Fahrrad. </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi">  Problem oder Problemstellung </h1><br><p>  Vor einiger Zeit arbeitete es an einem Projekt für ein Unternehmen, das Massen wie CRM, ERM-Systeme und Derivate in die Massen bringt.  Darüber hinaus hat das Unternehmen ein ziemlich umfassendes Produkt von Software für Registrierkassen an Callcenter herausgegeben, mit der Möglichkeit, Betreiber in Höhe von bis zu 200 Seelen zu mieten. </p><br><p>  Ich selbst habe an einer Front-End-Anwendung für Call-Center gearbeitet. </p><br><p>  Es ist leicht vorstellbar, dass Informationen aus allen Systemkomponenten in die Anwendung des Bedieners fließen.  Und wenn wir die Tatsache berücksichtigen, dass es sich nicht um einen einzelnen Bediener, sondern auch um einen Manager und einen Administrator handelt, können Sie sich vorstellen, wie viel Kommunikation und Informationen die Anwendung „verdauen“ und miteinander in Beziehung setzen sollte. </p><br><p>  Als das Projekt bereits gestartet wurde und sogar für sich selbst recht stabil funktionierte, trat das Problem der Systemtransparenz in seinem gesamten Wachstum auf. </p><br><p>  Das ist der Punkt.  Es gibt viele Komponenten, die alle mit ihren Datenquellen arbeiten.  Aber fast alle diese Komponenten wurden einmal als eigenständige Produkte geschrieben.  Das heißt, nicht als Element des Gesamtsystems, sondern als separate Verkaufsentscheidungen.  Infolgedessen gibt es keine einzige (System-) API und keine gemeinsamen Kommunikationsstandards zwischen ihnen. </p><br><p>  Ich werde es erklären.  Einige Komponenten senden JSON, "jemand" sendet Zeilen mit Schlüssel: Wert im Inneren, "jemand" sendet im Allgemeinen Binärdateien und macht damit, was Sie wollen.  Aber und die endgültige Bewerbung für das Callcenter musste alles bekommen und irgendwie verarbeiten.  Nun und vor allem gab es keine Verknüpfung im System, die erkennen konnte, dass sich das Datenformat / die Datenstruktur geändert hat.  Wenn eine Komponente gestern JSON gesendet hat und heute beschlossen hat, Binärdateien zu senden, wird dies niemand sehen.  Nur die endgültige Anwendung stürzt wie erwartet ab. </p><br><p>  Es wurde schnell klar (für die um mich herum, nicht für mich, da ich in der Entwurfsphase über das Problem gesprochen habe), dass das Fehlen einer „einheitlichen Kommunikationssprache“ zwischen den Komponenten zu ernsthaften Problemen führt. </p><br><p>  Der einfachste Fall ist, wenn der Client aufgefordert wurde, einen Datensatz zu ändern.  Sie schreiben die Aufgabe an den jungen Mann ab, der beispielsweise die Komponente für die Arbeit mit Datenbanken von Waren / Dienstleistungen „hält“.  Er macht seine Arbeit, implementiert einen neuen Datensatz und für ihn, Arschloch, funktioniert alles.  Aber am Tag nach dem Update ... oh ... beginnt die Anwendung im Callcenter plötzlich nicht mehr so ​​zu funktionieren, wie sie es erwarten. </p><br><p>  Sie haben es wahrscheinlich schon erraten.  Unser Held hat nicht nur den Datensatz geändert, sondern auch die Datenstruktur, die seine Komponente an das System sendet.  Infolgedessen kann die Call-Center-Anwendung einfach nicht mehr mit dieser Komponente arbeiten, und andere Abhängigkeiten verlaufen entlang der Kette. </p><br><p>  Sie begannen darüber nachzudenken, was wir eigentlich raus wollen.  Infolgedessen haben wir die folgenden Anforderungen für eine mögliche Lösung formuliert: </p><br><p>  <strong>In erster</strong> Linie: Jede Änderung der Datenstruktur sollte sofort im System "hervorgehoben" werden.  Wenn jemand irgendwo Änderungen vorgenommen hat und diese Änderungen nicht mit den Erwartungen des Systems kompatibel sind, sollte in der Phase des Komponententests ein Fehler auftreten, der geändert wurde. </p><br><p>  <strong>Der zweite</strong> .  Datentypen sollten nicht nur während der Kompilierung, sondern auch zur Laufzeit überprüft werden. </p><br><p>  <strong>Der dritte</strong> .  Da eine große Anzahl von Personen mit völlig unterschiedlichen Fähigkeiten an Komponenten arbeiten, sollte die Beschreibungssprache einfacher sein. </p><br><p>  <strong>Viertens</strong> .  Unabhängig von der Lösung sollte es so bequem wie möglich sein, damit zu arbeiten.  Wenn möglich, sollte die IDE so viel wie möglich hervorheben. </p><br><p>  Der erste Gedanke war, Protobuf zu implementieren.  Einfach, lesbar und leicht.  Strikte Dateneingabe.  Es scheint das zu sein, was der Arzt befohlen hat.  Leider schien nicht jede Protobuf-Syntax einfach zu sein.  Darüber hinaus erforderte selbst ein kompiliertes Protokoll eine zusätzliche Bibliothek, aber Javascript wurde von protobuf nicht unterstützt und war das Ergebnis von Community-Arbeit.  Im Allgemeinen lehnten sie ab. </p><br><p>  Dann kam die Idee auf, das Protokoll in JSON zu beschreiben.  Nun, wie viel einfacher? </p><br><p>  Nun, dann höre ich auf.  Und diesbezüglich hätte dieser Beitrag abgeschlossen werden können, da sich nach meiner Abreise niemand mehr besonders intensiv mit dem Problem befasste. </p><br><p>  Angesichts einiger persönlicher Projekte, bei denen das Problem der Kommunikation zwischen Komponenten wieder voll ausgeschöpft wurde, beschloss ich, die Idee selbst umzusetzen.  Was wird unten diskutiert. </p><br><p>  Daher präsentiere ich Ihnen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres-</a> Projekt, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgendes</a> umfasst: </p><br><ul><li>  Protokollgenerator </li><li>  Anbieter </li><li>  der Kunde </li><li>  Durchführung von Transporten </li></ul><br><h1 id="protokol">  Protokoll </h1><br><p>  Die Aufgabe war es, es so zu machen, dass: </p><br><ul><li>  Es war einfach, die Nachrichtenstruktur im System festzulegen. </li><li>  Es war einfach, den Datentyp aller Nachrichtenfelder zu bestimmen. </li><li>  es war möglich, Hilfsentitäten zu definieren und auf diese zu verweisen. </li><li>  und natürlich, damit all dies von der IDE hervorgehoben wird </li></ul><br><p>  Ich denke, dass auf ganz natürliche Weise Typescript als die Sprache gewählt wurde, in die das Protokoll konvertiert wird, nicht reines Javascript.  Das heißt, alles, was der Protokollgenerator tut, ist, JSON in Typescript umzuwandeln. </p><br><p>  Um die im System verfügbaren Nachrichten zu beschreiben, müssen Sie nur wissen, was JSON ist.  Ich bin mir sicher, dass niemand Probleme damit hat. </p><br><p>  Anstelle von Hello World biete ich ein nicht weniger abgedroschenes Beispiel an - Chat. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Alles ist unglaublich einfach.  Wir haben einige NewMessage- und UsersListUpdated-Ereignisse.  sowie einige UsersList- und AddUserResult-Anforderungen.  Es gibt zwei weitere Entitäten: ChatMessage und User. </p><br><p>  Wie Sie sehen können, ist die Beschreibung ziemlich transparent und verständlich.  Ein wenig über die Regeln. </p><br><ul><li>  Ein Objekt in JSON wird zu einer Klasse im generierten Protokoll </li><li>  Der Eigenschaftswert ist eine Datentypdefinition oder ein Verweis auf eine Klasse (Entität). </li><li>  Verschachtelte Objekte werden aus Sicht des generierten Protokolls zu "verschachtelten" Klassen, dh verschachtelte Objekte erben alle Eigenschaften ihrer Eltern. </li></ul><br><p>  Jetzt müssen Sie nur noch ein Protokoll erstellen, um es zu verwenden. </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p>  Als Ergebnis erhalten wir ein Typescript-generiertes Protokoll.  Wir verbinden und nutzen: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="Bild"><br><p>  Das Protokoll gibt dem Entwickler also bereits etwas: </p><br><ul><li>  Die IDE hebt hervor, was wir im Protokoll haben.  Die IDE hebt auch alle erwarteten Eigenschaften hervor. </li><li>  Typoskript, das uns sicherlich sagt, ob etwas mit Datentypen nicht stimmt.  Dies geschieht natürlich in der Entwicklungsphase, aber das Protokoll selbst überprüft bereits zur Laufzeit die Datentypen und löst eine Ausnahme aus, wenn ein Verstoß festgestellt wird </li><li>  Im Allgemeinen können Sie die Validierung vergessen.  Das Protokoll führt alle erforderlichen Überprüfungen durch. </li><li>  Das generierte Protokoll erfordert keine zusätzlichen Bibliotheken.  Alles, was er zum Arbeiten braucht, enthält er bereits.  Und es ist sehr praktisch. </li></ul><br><blockquote>  Ja, die Größe des generierten Protokolls kann Sie, gelinde gesagt, überraschen.  Vergessen Sie jedoch nicht die Minimierung, für die sich die generierte Protokolldatei gut eignet. </blockquote><p>  Jetzt können wir die Nachricht "packen" und senden </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p>  Es ist wichtig, hier eine Reservierung vorzunehmen. Das Paket besteht aus einem Array von Bytes, was unter dem Gesichtspunkt der Verkehrslast sehr gut und korrekt ist, da das Senden derselben JSON- "Kosten" natürlich teurer ist.  Das Protokoll verfügt jedoch über eine Funktion: Im Debug-Modus wird lesbarer JSON generiert, sodass der Entwickler den Datenverkehr „betrachten“ und sehen kann, was passiert. </p><br><p>  Dies erfolgt direkt zur Laufzeit. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p>  Auf dem Server (oder einem anderen Empfänger) können wir die Nachricht einfach entpacken: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p>  Das Protokoll unterstützt alle wichtigen Datentypen: </p><br><table><thead><tr><th>  Typ </th><th>  Werte </th><th>  Beschreibung </th><th>  Größe, Bytes </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  UTF8-codierte Zeichenfolge </td><td>  x </td></tr><tr><td>  asciiString </td><td></td><td>  ASCII-Zeichenfolge </td><td>  1 Zeichen - 1 Byte </td></tr><tr><td>  int8 </td><td>  -128 bis 127 </td><td></td><td>  1 </td></tr><tr><td>  int16 </td><td>  -32768 bis 32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648 bis 2147483647 </td><td></td><td>  4 </td></tr><tr><td>  uint8 </td><td>  0 bis 255 </td><td></td><td>  1 </td></tr><tr><td>  uint16 </td><td>  0 bis 65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0 bis 4294967295 </td><td></td><td>  4 </td></tr><tr><td>  float32 </td><td>  1,2 x 10 <sup>-38</sup> bis 3,4 x 10 <sup>38</sup> </td><td></td><td>  4 </td></tr><tr><td>  float64 </td><td>  5,0 × 10 –324 bis 1,8 × 10 <sup>308</sup> </td><td></td><td>  8 </td></tr><tr><td>  Boolescher Wert </td><td></td><td></td><td>  1 </td></tr></tbody></table><br><p>  Innerhalb des Protokolls werden diese Datentypen als primitiv bezeichnet.  Ein weiteres Merkmal des Protokolls ist jedoch, dass Sie Ihre eigenen Datentypen hinzufügen können (sogenannte "zusätzliche Datentypen"). </p><br><p>  Zum Beispiel haben Sie wahrscheinlich bereits bemerkt, dass <strong>ChatMessage</strong> ein Feld mit einem <strong>Datetime-</strong> Datentyp erstellt hat.  Auf Anwendungsebene entspricht dieser Typ dem <strong>Datum</strong> und wird im Protokoll als <strong>uint32</strong> gespeichert (und gesendet). </p><br><p>  Das Hinzufügen Ihres Typs zum Protokoll ist ganz einfach.  Wenn wir beispielsweise einen <strong>E-Mail-</strong> Datentyp haben möchten, sagen wir für die folgende Nachricht im Protokoll: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Sie müssen lediglich eine Definition für den E-Mail-Typ schreiben. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p>  Das ist alles.  Durch das Generieren des Protokolls erhalten wir Unterstützung für den neuen <strong>E-Mail-</strong> Datentyp.  Wenn wir versuchen, eine Entität mit der falschen Adresse zu erstellen, wird eine Fehlermeldung angezeigt </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p>  Oh ... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p>  Das Protokoll lässt also einfach keine "schlechten" Daten in das System zu. </p><br><p>  Bitte beachten Sie, dass wir beim Definieren eines neuen Datentyps einige Schlüsseleigenschaften angegeben haben: </p><br><ul><li>  <strong>binaryType</strong> - Ein Verweis auf einen primitiven Datentyp, der zum Speichern, Codieren / Decodieren von Daten verwendet werden soll.  In diesem Fall geben wir an, dass die Adresse eine ASCII-Zeichenfolge ist. </li><li>  <strong>tsType</strong> ist eine Referenz auf den Javascript-Typ, <strong>dh</strong> wie der Datentyp in der Javascript-Umgebung dargestellt werden soll.  In diesem Fall handelt es sich um eine <strong>Zeichenfolge</strong> </li><li>  Es ist auch erwähnenswert, dass wir einen neuen Datentyp nur zum Zeitpunkt der Generierung des Protokolls definieren müssen.  Am Ausgang erhalten wir ein generiertes Protokoll, das bereits einen neuen Datentyp enthält. </li></ul><br><blockquote>  Detaillierte Informationen zu allen Protokollfunktionen finden Sie hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.protocol</a> . </blockquote><br><h1 id="provayder-i-klient">  Anbieter und Kunde </h1><br><p>  Im Großen und Ganzen kann das Protokoll selbst zum Organisieren der Kommunikation verwendet werden.  Wenn es sich jedoch um den Browser und die NodeJS handelt, sind der Anbieter und der Client verfügbar. </p><br><h2 id="klient">  Kunde </h2><br><h3 id="sozdanie">  Schöpfung </h3><br><p>  Um einen Client zu erstellen, benötigen Sie den Client und den Transport. </p><br><p>  Installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p>  Schöpfung </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote>  Sowohl der Client als auch der Anbieter sind speziell für das Protokoll konzipiert.  Das heißt, sie funktionieren nur mit dem Protokoll (ceres.protocol). </blockquote><br><h3 id="sobytiya">  Ereignisse </h3><br><p>  Nachdem der Client erstellt wurde, kann der Entwickler Ereignisse abonnieren </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Bitte beachten Sie, dass der Client den Ereignishandler nur aufruft, wenn die Nachrichtendaten vollständig korrekt sind.  Mit anderen Worten, unsere Anwendung ist vor falschen Daten geschützt und der <strong>NewMessage-</strong> Ereignishandler wird immer mit einer Instanz von <strong>Protocol.Events.NewMessage</strong> als Argument aufgerufen. </p><br><p>  Natürlich kann der Client Ereignisse generieren. </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Beachten Sie, dass wir nirgendwo Ereignisnamen angeben, sondern entweder entweder einen Link zur Klasse aus dem Protokoll verwenden oder eine Instanz davon übergeben. </p><br><p>  Wir können eine Nachricht auch an eine begrenzte Gruppe von Empfängern senden, indem wir als zweites Argument ein einfaches Objekt vom Typ <code>{ [key: string]: string }</code> angeben.  Innerhalb von ceres wird dieses Objekt als <strong>Abfrage bezeichnet</strong> . </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Durch die zusätzliche Angabe von <code>{ location: "UK" }</code> können wir sicher sein, dass nur Kunden, die ihre Position als UK identifiziert haben, diese Nachricht erhalten. </p><br><p>  Um den Client selbst einer bestimmten <strong>Abfrage zuzuordnen</strong> , müssen Sie nur die <strong>ref-</strong> Methode aufrufen: </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p>  Nachdem wir den Client mit der <strong>Abfrage verbunden haben</strong> , hat er die Möglichkeit, "persönliche" oder "Gruppen" -Nachrichten zu empfangen. </p><br><h3 id="zaprosy">  Anfragen </h3><br><p>  Wir können auch Anfragen stellen </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Es ist zu beachten, dass wir als zweites Argument das erwartete Ergebnis angeben ( <strong>Protocol.Responses.UsersList</strong> ). Dies bedeutet, dass unsere Anforderung nur dann erfolgreich abgeschlossen wird, wenn die Antwort eine Instanz von <strong>UsersList</strong> ist. In allen anderen Fällen werden wir "fallen" fangen  Dies versichert uns wiederum vor der Verarbeitung falscher Daten. </p><br><p>  Der Kunde selbst kann auch mit denen sprechen, die Anfragen bearbeiten können.  Dazu müssen Sie sich nur als "verantwortlich" für die Anfrage "identifizieren". </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Beachten Sie, dass wir optional als drittes Argument ein <strong>Abfrageobjekt</strong> angeben können, mit dem der Client identifiziert werden kann.  Wenn also jemand eine Anfrage mit der <strong>Anfrage</strong> <code>{ location: "RU" }</code> sendet, erhält unser Client eine solche Anfrage nicht, da seine Anfrage <code>{ location: "UK" }</code> . </p><br><p>  Eine <strong>Abfrage</strong> kann eine unbegrenzte Anzahl von Eigenschaften enthalten.  Beispielsweise können Sie Folgendes angeben </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p>  Zusätzlich zu einer vollständigen <strong>Abfrageübereinstimmung</strong> werden wir dann auch die folgenden Abfragen erfolgreich verarbeiten: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p>  oder </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder">  Anbieter </h2><br><h3 id="sozdanie-1">  Schöpfung </h3><br><p>  Um einen Anbieter zu erstellen (sowie einen Kunden zu erstellen), benötigen Sie den Anbieter und den Transport. </p><br><p>  Installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p>  Schöpfung </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p>  Ab dem Moment, in dem der Anbieter erstellt wird, kann er Verbindungen von Clients akzeptieren. </p><br><h3 id="sobytiya-1">  Ereignisse </h3><br><p>  Neben dem Client kann der Anbieter Nachrichten "abhören" und generieren. </p><br><p>  Zuhören </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p>  Generieren </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1">  Anfragen </h3><br><p>  Natürlich kann (und sollte) der Anbieter Anfragen "abhören" </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Es gibt nur einen Unterschied zum Client. Der Anbieter erhält zusätzlich zum Anforderungshauptteil eine eindeutige <strong>clientId</strong> , die automatisch allen verbundenen Clients zugewiesen wird. </p><br><h1 id="primer">  Beispiel </h1><br><p>  Tatsächlich möchte ich Sie nicht mit Auszügen aus der Dokumentation langweilen. Ich bin sicher, dass es für Sie einfacher und interessanter sein wird, nur ein kurzes Codefragment zu sehen. </p><br><p>  Sie können das Chat-Beispiel einfach installieren, indem Sie die <a href="">Quellen</a> herunterladen und einige einfache Aktionen ausführen </p><br><p>  Client-Installation und Start </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p>  Der Client ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000</a> verfügbar.  Öffnen Sie sofort einige Registerkarten mit dem Client, um die "Kommunikation" anzuzeigen. </p><br><p>  Installation und Start des Providers (Servers) </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p>  Ich bin sicher, dass Sie mit dem <strong>ts-node-</strong> Paket vertraut <strong>sind</strong> , aber wenn nicht, können Sie damit TS-Dateien ausführen.  Wenn Sie nicht installieren möchten, kompilieren Sie einfach den Server und führen Sie die JS-Datei aus. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat">  Was?  Schon wieder ?! </h1><br><p>  Ich kann nur sagen, dass es für mich interessant war, Fragen zu antizipieren, warum zum Teufel ein anderes Fahrrad erfunden werden sollte, weil es so viele bewährte Lösungen gibt, angefangen beim Protobuf bis hin zum Hardcore-Joynr von BMW.  Das gesamte Projekt wurde ausschließlich auf persönliche Initiative ohne Unterstützung in meiner Freizeit von der Arbeit durchgeführt. </p><br><p>  Deshalb ist Ihr Feedback für mich von <strong>besonderem Wert</strong> .  Um dich irgendwie zu motivieren, kann ich versprechen, dass ich für jeden Stern auf Github den Hamster streicheln werde (was ich, gelinde gesagt, nicht mag).  Für die Gabel, ähhh, werde ich seine Pussiko kratzen ... brrrr. </p><br><p>  <em>Der Hamster gehört nicht mir, dem Hamster des Sohnes</em> . </p><br><p>  Darüber hinaus wird das Projekt in ein paar Wochen meinen ehemaligen Kollegen zum Testen angeboten (die ich zu Beginn des Beitrags erwähnt habe und die an der Alfa-Version interessiert waren).  Das Ziel ist das Debuggen und Ausführen mehrerer Komponenten.  Ich hoffe wirklich, dass es funktioniert. </p><br><h1 id="ssylki-i-pakety">  Links und Pakete </h1><br><p>  Das Projekt wird von zwei Repositorys gehostet </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres-</a> Quellen: ceres.provider, ceres.consumer und alle heute verfügbaren Transporte. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.protocol</a> Protokollgeneratorquellen </li></ul><br><p>  NPM folgende Pakete verfügbar </p><br><ul><li>  Protokollgenerator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.protocol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.provider</a> Anbieter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.consumer</a> Kunde </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.provider.node.longpoll-</a> Transport für einen Anbieter basierend auf langen Abfragen </li><li>  <a href="">ceres.provider.node.ws-</a> Transport für einen auf Web Socket basierenden Anbieter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ceres.consumer.browser.longpoll-</a> Transport für den Client basierend auf langen Abfragen </li><li>  <a href="">ceres.consumer.browser.ws</a> Transport für einen Client basierend auf Web Socket </li></ul><br><p>  Gut und leicht. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442380/">https://habr.com/ru/post/de442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442370/index.html">Verzögertes Laden des Feature-Moduls aus dem Ordner "node_modules"</a></li>
<li><a href="../de442372/index.html">Zuverlässige Programmierung im Kontext von Sprachen. Teil 2 - Herausforderer</a></li>
<li><a href="../de442374/index.html">Entwicklung eines Aufwärtswandlers auf DSP: Funktionsprinzip, Berechnungen, Prototyping</a></li>
<li><a href="../de442376/index.html">Einzelhandelsgrundstücksdichte</a></li>
<li><a href="../de442378/index.html">Ein Klick in der Benutzeroberfläche von Booking com kann einen Urlaub ruinieren oder warum ein funktionierendes Bewertungssystem wichtig ist</a></li>
<li><a href="../de442384/index.html">Erweiterung der Funktionalität des Standard-Audiosystems</a></li>
<li><a href="../de442386/index.html">Thymeleaf: Dialektlayout + Spring Boot 2</a></li>
<li><a href="../de442392/index.html">NodeJS-Protokollierung richtig gemacht</a></li>
<li><a href="../de442396/index.html">Digitale Veranstaltungen in Moskau vom 04. bis 10. März</a></li>
<li><a href="../de442402/index.html">Das Wichtigste. Integration mit externen Diensten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>