<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏾 🏂🏽 🛋️ Testes escamosos ◾️ 👩🏽‍⚖️ 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que é mais desagradável do que o "teste vermelho"? O teste é verde ou vermelho, e não está claro o porquê. Em nossa conferência Heisenbug 2017 em Mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes escamosos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/416757/">  O que é mais desagradável do que o "teste vermelho"?  O teste é verde ou vermelho, e não está claro o porquê.  Em nossa conferência Heisenbug 2017 em Moscou, <b>Andrei Solntsev</b> (Codeborne) falou sobre por que eles podem surgir e como reduzir seu número.  Exemplos no relatório dele são tais que você sente a dor diretamente na pele quando colide com eles.  E as dicas são úteis - e vale a pena conhecer testadores e desenvolvedores.  Há algo inesperado: você pode descobrir como às vezes pode descobrir um problema se se afastar da tela e jogar cubos com sua filha. <br><br>  Como resultado, o público apreciou o relatório, e decidimos não apenas publicar o vídeo, mas também fazer uma versão em texto do relatório para Habr. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jLG3RXECQU8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Na minha opinião, testes esquisitos são o tópico mais relevante no mundo da automação.  Porque a pergunta "o que está sendo feito no mundo, como você está fazendo com a automação?"  todas respondem: “Não há estabilidade!  Nossos testes caem periodicamente. ” <br><br>  Você fez um teste em sua casa, é verde, outros dois dias verdes e, uma vez e de repente, caiu sobre Jenkins.  Você tenta repeti-lo, iniciá-lo e fica verde novamente.  E no final, você nunca sabe: é um bug ou é apenas um teste de glucana?  E toda vez que você precisa entender. <br><br>  Muitas vezes, após o lançamento noturno de testes no Jenkins, o testador vê pela primeira vez "30 testes caíram, você precisa estudar", mas todos sabem o que acontece a seguir ... <br><br><img src="https://habrastorage.org/webt/fz/vg/jh/fzvgjhfo6snzfs6qa0d9clltgcc.jpeg"><br><br>  Você, claro, adivinhou qual palavra indecente disfarçava: "Vou reiniciar".  Como "hoje não há relutância em entender ..." É assim que geralmente acontece e é um verdadeiro desastre. <br><br>  Não há estatísticas exatas, mas muitas vezes ouvi de pessoas diferentes que elas têm cerca de 30% dos testes - escamosos.  Grosso modo, eles lançam mil, dos quais 300 são periodicamente vermelhos e depois checam com as mãos se realmente caíram. <br><br>  O Google publicou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo há</a> alguns anos: ele diz que eles têm 1,5% por cento de testes inadequados e conta como eles lutam para reduzir seu número.  Posso me gabar um pouco e dizer que meu projeto em Codeborne agora é de 0,1%.  Mas, de fato, tudo isso é ruim, mesmo 0,1%.  Porque <br><br>  Tome 1,5%, esse número parece pequeno, mas o que isso significa na prática?  Digamos que haja mil testes em um projeto.  Isso pode significar que 15 testes caíram em uma versão, os próximos 12 e depois 18. E isso é muito ruim, porque nesse caso quase todas as versões são vermelhas e você precisa verificar constantemente com as mãos se é verdade ou não. <br><br>  E até o nosso 1 ppm (0,1%) ainda é ruim.  Suponha que tenhamos 1000 testes e, em seguida, 0,1% significa que regularmente uma em cada dez quedas cai com 1-2 testes em vermelho.  Aqui está a imagem real do nosso Jenkins, e acontece que: com uma corrida, um teste escamoso caiu, com outro começo outro. <br><br><img src="https://habrastorage.org/webt/dv/gx/da/dvgxdacsvc67zygojg18pu50v-q.jpeg"><br><br>  Acontece que não temos um dia sem uma construção vermelha.  Como há muito verde, tudo parece estar bem, mas o cliente tem o direito de nos perguntar: "Pessoal, pagamos dinheiro e você sempre nos fornece vermelho!"  O que você está fazendo? <br><br>  Eu ficaria insatisfeito no local do cliente, e explicar "em geral, isso é normal no setor, tudo é vermelho para todos" não é bom, certo?  Portanto, na minha opinião, esse é um problema muito urgente, e vamos entender juntos como lidar com isso. <br><br>  O plano é este: <br><br><ol><li>  Minha coleção de testes instáveis ​​(da minha prática, casos absolutamente reais, histórias de detetive complexas e interessantes) </li><li>  Causas de instabilidade (alguns até levaram anos para pesquisar) </li><li>  Como lidar com eles?  (espero que seja a parte mais útil) </li></ol><br>  Então, vamos começar com minha coleção, que eu valorizo ​​muito: me custou muitas horas noturnas de vida e depuração.  Vamos começar com um exemplo simples. <br><br><h2>  Exemplo 1: clássico </h2><br>  Para sementes - o clássico script Selenium: <br><br><pre><code class="java hljs">driver.navigate().to(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/"</span></span>); driver.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"q"</span></span>)).sendKeys(<span class="hljs-string"><span class="hljs-string">"selenide"</span></span>); driver.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"btnK"</span></span>)).click(); assertEquals(<span class="hljs-number"><span class="hljs-number">9</span></span>, driver.findElements(By.cssSelector(<span class="hljs-string"><span class="hljs-string">"#ires .g"</span></span>)).size());</code> </pre> <br><ol><li>  Abrimos o WebDriver; </li><li>  Encontre o elemento q, dirija na palavra para pesquisar lá; </li><li>  Encontre o elemento "Button" e clique; </li><li>  Verifique se a resposta é nove resultados. </li></ol><br>  Pergunta: qual linha pode quebrar aqui? <br><br>  É isso mesmo, todos sabemos bem que qualquer um!  Qualquer linha pode quebrar, por razões completamente diferentes: <br><br>  A primeira linha é a Internet lenta, o serviço travou, os administradores não configuraram nada. <br><br>  A segunda linha - o elemento ainda não teve tempo para renderizar se for desenhado dinamicamente. <br>  O que poderia quebrar na terceira linha?  Aqui foi inesperado para mim: escrevi este teste para a conferência, executei-o localmente e caiu na terceira linha com este erro: <br><br><img src="https://habrastorage.org/webt/8n/qu/4l/8nqu4l-8byopdwjdkbcrcgkhery.jpeg"><br><br>  Isso indica que o elemento neste momento não é clicável.  Parece um simples formulário básico do Google.  O segredo acabou sendo o de que atingimos a palavra na segunda linha e, enquanto a inseríamos, o Google já encontrou os primeiros resultados, mostrou os primeiros resultados em um pop-up e eles fecharam o botão seguinte.  E isso não acontece em todos os navegadores e nem sempre.  Isso aconteceu comigo com esse script uma vez em cada cinco. <br><br>  A quarta linha pode cair, por exemplo, porque esse elemento é desenhado dinamicamente e ainda não teve tempo para desenhar. <br><br>  Neste exemplo, quero dizer que, na minha experiência, 90% dos testes de falhas são baseados nos mesmos motivos: <br><br><ul><li>  Velocidade de solicitação do Ajax: às vezes eles correm mais devagar; </li><li>  A ordem dos pedidos do Ajax; </li><li>  Velocidade js. </li></ul><br>  Felizmente, há uma cura por esses motivos!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selenida</a> resolve esses problemas.  Como isso decide?  Reescrevemos nosso teste do Google no Selenide - quase tudo se parece, apenas os sinais de $ são usados: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userCanLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ open(“http:<span class="hljs-comment"><span class="hljs-comment">//localhost:8080/login”); $(By.name(“username”).setValue(“john”); $(“#submit”).click(); $(“.menu”).shouldHave(text(“Hello, John!”)); }</span></span></code> </pre><br>  Este teste sempre passa.  Devido ao fato de os métodos setValue (), click () e shouldHave () serem inteligentes: se algo não tiver tempo para ser aplicado, eles esperam um pouco e tentam novamente (isso é chamado de "expectativas inteligentes"). <br><br>  Se você olhar um pouco mais detalhadamente, todos esses métodos deveriam * são inteligentes: <br><br><img src="https://habrastorage.org/webt/gq/x8/uq/gqx8uq3gjj6wudrx0n3uajntzdy.jpeg"><br><br>  Eles podem esperar, se necessário.  Por padrão, eles esperam até 4 segundos, e esse tempo limite, é claro, é configurável, você pode especificar qualquer outro.  Por exemplo, assim: mvn -Dselenide.timeout = 8000. <br><br><h2>  Exemplo 2: nbob </h2><br>  Assim, 90% dos problemas com testes escamosos são resolvidos com Selenide.  Mas 10% dos casos muito mais sofisticados permanecem com razões complexas e confusas.  É precisamente sobre eles que quero falar hoje, porque é uma "área cinzenta".  Deixe-me dar um exemplo: um teste superficial, que me deparei imediatamente em um novo projeto.  À primeira vista, isso simplesmente não pode acontecer, mas isso é algo interessante. <br><br>  Testamos o aplicativo do teclado para login em quiosques.  O teste queria efetuar login como o usuário "bob", ou seja, digite três letras no campo "login": bob.  Para isso, foram utilizados os botões na tela.  Como regra, isso funcionava, mas às vezes o teste falhava e o valor "nbob" permanecia no campo "login": <br><br><img src="https://habrastorage.org/webt/7u/hp/zs/7uhpzsf9wrppgubv_cra_ldg2ri.jpeg"><br><br>  Naturalmente, você está lutando para pesquisar pelo código onde poderíamos ter escrito "nbob" - mas em todo o projeto isso não é de todo (nem no banco de dados, nem no código, nem nos arquivos do Excel).  Como isso é possível? <br><br>  Examinamos o código com mais detalhes - parece que tudo é simples, sem enigmas: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginKiosk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ open(“http:<span class="hljs-comment"><span class="hljs-comment">//localhost:9000/kiosk”); $(“body”).click(); $(By.name(“username”)).sendKeys(“bob”); $(“#login”).click(); }</span></span></code> </pre><br>  Começamos a debater mais, passo a passo e com esse método conseguimos entender: esse erro às vezes aparece após a linha $ ("body"). Clique em ().  Ou seja, nesta etapa, "n" aparece no campo "login" e, em seguida, "bob" é adicionado nas etapas subsequentes.  Quem já adivinhou de onde vem "n"? <br><br>  Aconteceu que a letra N estava no meio da tela e a função click () pelo menos no Chrome funciona assim: calcula a coordenada central de um elemento e clica nele.  Como corpo é um elemento grande, ela clicou no centro de toda a tela. <br><br><img src="https://habrastorage.org/webt/56/xh/k_/56xhk_clrm85lqkyn-wqeaa5hg4.jpeg"><br><br>  E isso nem sempre caiu.  Quem sabe porque?  De fato, eu mesmo não sei completamente.  Talvez devido ao fato de a janela do navegador ser aberta o tempo todo em tamanhos diferentes, e isso nem sempre cair na letra N. <br><br>  Você provavelmente tem uma pergunta: por que alguém ganhou $ ("body")? Clique em ()?  Também não sei até o fim, mas suponho remover o foco do campo.  Existe um problema no Selenium que é clicar em (), mas desmarcar () não.  Se houver um foco no campo, ele não poderá ser removido a partir daí, você poderá clicar apenas em qualquer outro elemento.  E como não havia outros elementos razoáveis, eles clicaram no corpo e obtiveram esse efeito. <br><br>  Daí a moral: não insira nada que entre no &lt;corpo&gt;.  Em outras palavras, você não precisa fazer nenhum movimento extra em pânico.  De fato, isso geralmente acontece: desde que eu lido com o Selenide, muitas vezes recebo reclamações de que "algo não funciona" e, em seguida, verifica-se que em algum lugar nos métodos de configuração havia 15 linhas extras que não fazem nada útil e interferem .  Não há necessidade de mexer e inserir de qualquer maneira em testes como "de repente será mais confiável". <br><br>  Como resultado, expandimos a lista de razões para testes instáveis: <br><br><ul><li>  Velocidade de solicitação do Ajax; </li><li>  A ordem dos pedidos do Ajax; </li><li>  Velocidade js; </li><li>  Tamanho da janela do navegador; </li><li>  Vaidade! </li></ul><br>  E, ao mesmo tempo, minha recomendação é: não execute testes de forma maximizada (ou seja, não abra o navegador em uma janela completa).  Como regra, todo mundo faz isso, e no Selenide era por padrão (ou ainda é).  Em vez disso, aconselho que você sempre inicie um navegador com uma resolução de tela estritamente definida, porque esse fator aleatório é excluído.  E aconselho que você defina o tamanho mínimo que seu aplicativo suporta, de acordo com a especificação. <br><br><h2>  Exemplo 3: contas fantasmas </h2><br>  Um exemplo é interessante, pois tudo o que só pode coincidir imediatamente coincide. <br><br>  Houve um teste que verificou se deveria haver 5 contas nessa tela. <br><br><img src="https://habrastorage.org/webt/td/hp/vl/tdhpvl7b-2ar4jxetsboygszf7m.jpeg"><br><br>  Como regra geral, era verde, mas às vezes não estava claro em que condições ele caiu e disse que não havia cinco, mas seis contagens na tela. <br><br>  Comecei a pesquisar de onde vem a conta extra.  Absolutamente incompreensível.  Surgiu a pergunta: talvez tenhamos outro teste, que durante o teste cria uma nova conta?  Descobriu-se que sim, existe um LoansTest.  E entre ele e o AccountsTest em queda (que espera cinco contas), pode haver um milhão de outros testes. <br><br>  Estamos tentando entender como é: o LoansTest, que cria a conta, não deve excluí-lo no final?  Nós olhamos para o seu código - sim, deveria, no final, há uma função After para isso.  Então, em teoria, tudo deve ficar bem, qual é o problema? <br><br>  Talvez o teste o remova, mas ele permanece em cache em algum lugar?  Observamos o código de produção que carrega as contas - ele realmente possui a anotação @CacheFor, ele armazena em cache as contas por cinco minutos. <br><br>  Surge a pergunta: mas o teste não deveria limpar esse cache?  Seria lógico, não pode haver tal batente?  Analisamos seu código - sim, ele realmente limpa o cache antes de cada teste.  O que houve?  Aqui você já está perdido, porque as hipóteses terminaram: o objeto foi excluído, o cache foi limpo, varas de árvores, o que mais poderia ser um problema?  Então ele começou a escalar o código, levou algum tempo, talvez até alguns dias.  Até que finalmente olhei para essa classe e superclasse e encontrei uma coisa suspeita lá: <br><br><img src="https://habrastorage.org/webt/ug/iz/qz/ugizqze3zr1gmexqfzgxfzqtb_o.jpeg"><br><br>  Alguém já percebeu, certo?  Isso mesmo: na classe filho e na classe pai, existe um método com o mesmo nome e ele não chama super. <br><br>  E em Java, é muito fácil: pressione Alt + Enter ou Ctrl + Insert no IntelliJ IDEA ou Eclipse; por padrão, ele cria o método setUp () para você e você não percebe que ele substitui o método na superclasse.  Ou seja, o cache ainda não foi chamado.  Quando vi isso, fiquei com muita raiva.  É alegre para mim agora. <br><br>  Daí a moral: <br><br><ol><li>  Nos testes, é muito importante monitorar o código limpo.  Se no código de produção todos estão atentos a isso, eles realizam uma revisão de código e, em seguida, nos testes - nem sempre. </li><li>  Se o código de produção for verificado por testes, quem testará os testes?  Portanto, é especialmente importante usar verificações no IDE. </li></ol><br>  Após esse incidente, encontrei na IDEA uma inspeção desse tipo, desativada por padrão, que verifica: se o método for substituído em algum lugar, mas não houver anotação @ Overrid, isso marca isso como um erro.  Agora eu sempre marquei histericamente esta caixa. <br><br>  Vamos resumir novamente: como isso aconteceu, por que o teste falhou nem sempre?  Primeiro, dependia da ordem desses dois testes; eles sempre são executados em ordem aleatória.  Outro teste dependia de quanto tempo passou entre eles.  As contas são armazenadas em cache por cinco minutos; se mais foram aprovadas, o teste ficou verde e, se menos, caiu, e isso raramente aconteceu. <br><br>  Expandimos a lista de por que os testes podem ser instáveis: <br><br><ul><li>  Velocidade de solicitação do Ajax; </li><li>  A ordem dos pedidos do Ajax; </li><li>  Velocidade js; </li><li>  Tamanho da janela do navegador; </li><li>  Cache de aplicativos; </li><li>  Dados de testes anteriores; </li><li>  Hora. </li></ul><br><h2>  Exemplo 4: Hora do Java </h2><br>  Houve um teste que funcionou em todos os nossos computadores e no nosso Jenkins, mas às vezes trava em um cliente Jenkins.  Nós olhamos para o teste, entendemos o porquê.  Acontece que estava caindo, porque ao verificar "a data do pagamento deveria ser agora ou no passado", acabou sendo "no futuro". <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> payment.time &lt;= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date();</code> </pre><br>  Observamos o código, de repente, sob algumas condições, podemos definir uma data no futuro?  Não podemos: no único local em que a hora do pagamento é inicializada, nova data () é usada e essa é sempre a hora atual (em casos extremos, pode ser no passado se o teste for muito lento).  Como isso é possível?  Eles bateram de cabeça por um longo tempo, eles não conseguiram entender. <br><br>  E uma vez que eles examinaram o log do aplicativo.  Daí a primeira moral - é muito útil ao examinar testes para examinar o log do próprio aplicativo.  Levante suas mãos, quem faz isso.  Em geral, não a maioria, infelizmente.  E há informações úteis: por exemplo, o log de solicitações, tal e qual URL foi executado naquele momento, deu tal e tal resposta. <br><br><img src="https://habrastorage.org/webt/z5/ca/cv/z5cacvqul4e4p9gw_lltdzoqk2c.jpeg"><br><br>  Há algo suspeito aqui, percebe?  Observamos o momento: esse pedido foi processado menos três segundos.  Como isso pode ser?  Eles lutaram por um longo tempo, não conseguiam entender.  Finalmente, quando ficamos sem teoria, tomamos uma decisão estúpida: Jenkins escreveu um script simples que registra a hora atual em um ciclo uma vez por segundo.  Lançado.  No dia seguinte, quando esse teste superficial caiu uma vez à noite, eles começaram a assistir a um trecho desse arquivo para o momento em que ele caiu: <br><br><img src="https://habrastorage.org/webt/yn/et/wx/ynetwxiyv1bc7kzmcgfafqolso8.jpeg"><br><br>  Então: 34 segundos, 35, 36, 37, 35, 39 ... É legal termos encontrado, mas como isso é possível?  As teorias terminaram novamente, mais dois dias coçando a cabeça.  Este é realmente o caso quando o Matrix está brincando com você, certo? <br><br>  Até que finalmente uma idéia me atingiu ... E isso acabou sendo.  O Linux possui um serviço de sincronização de tempo que é executado em um servidor central e pergunta "quantos milissegundos são agora?"  E acontece que dois serviços diferentes foram lançados nesse Jenkins específico.  O teste começou a falhar quando o Ubuntu foi atualizado neste servidor. <br><br>  Lá, um serviço NTP era configurado anteriormente, que acessava um servidor bancário especial e levava tempo a partir daí.  E com a nova versão do Ubuntu, um novo serviço leve foi incluído por padrão, por exemplo, systemd-timesyncd.  E ambos funcionaram.  Ninguém percebeu isso.  Por alguma razão, o servidor do banco central e o servidor Ubuntu central emitiram uma resposta com uma diferença de 3 segundos.  Naturalmente, esses dois serviços interferiram um no outro.  Em algum lugar profundo da documentação do Ubuntu, ele diz que, é claro, não permite essa situação ... Bem, obrigado pela informação :) <br><br>  A propósito, ao mesmo tempo, aprendi uma nuance interessante de Java, que antes disso, apesar de meus muitos anos de experiência, não conhecia.  Um dos métodos mais básicos em Java é chamado System.currentTimeMillis (), com a ajuda do qual normalmente é programado para chamar algo, muitos escreveram esse código: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">// ... long end = System.currentTimeMillis(); log.info("Loaded in {} ms", end-start);</span></span></code> </pre><br>  Esse código está nas bibliotecas Apache Commons, Guava.  Ou seja, se você precisar detectar quantos milissegundos foram necessários para chamar alguma coisa, eles geralmente o fazem.  E muitos provavelmente ouviram que isso não deveria ser feito.  Eu também ouvi, mas não sabia o porquê, e com preguiça de entender.  Eu pensei que a pergunta era exatamente porque System.nanoTime () apareceu em alguma versão do Java - é mais preciso, produz nanossegundos que são um milhão de vezes mais precisos.  E, como regra, minhas chamadas duram um segundo ou meio segundo, essa precisão não é importante para mim e continuei a usar System.currentTimeMillis (), que vimos no log em que eram -3 segundos.  Então, de fato, a maneira correta é essa, e agora eu descobri o porquê: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.nanoTime(); <span class="hljs-comment"><span class="hljs-comment">// ... long end = System.nanoTime(); log.info("Loaded in {} ms", (end-start)/1000000);</span></span></code> </pre><br>  Na verdade, isso está escrito na documentação dos métodos, mas eu nunca o li.  Durante toda a minha vida, pensei que System.currentTimeMillis () e System.nanoTime () são a mesma coisa, mas com uma diferença de um milhão de vezes.  Mas aconteceu que essas são coisas fundamentalmente diferentes. <br><br>  System.currentTimeMillis () retorna a data atual real - quantos milissegundos são agora desde 1º de janeiro de 1970.  E System.nanoTime () é um tipo de contador abstrato que não está vinculado ao tempo real: sim, é garantido que ele cresça a cada nanossegundo por unidade, mas não esteja conectado ao horário atual, pode até ser negativo.  No início da JVM, um ponto no tempo é de alguma forma selecionado aleatoriamente e começa a crescer.  Foi uma surpresa para mim.  Para você também?  Bem, não foi em vão que ele chegou. <br><br><h2>  Exemplo 5: A maldição do botão verde </h2><br>  Aqui, nosso teste preenche um determinado formulário, clica no botão verde Confirmar e, às vezes, não vai mais longe.  Por que isso não acontece é incompreensível. <br><br><img src="https://habrastorage.org/webt/cb/wq/fe/cbwqfenxe6_sfzyescgepr5m8tg.png"><br><br>  Dirigimos quatro zeros e travamos, não vá para a próxima página.  Clicar ocorre sem erros.  Eu olhei para tudo: solicitações do Ajax, espera, tempo limite, logs de aplicativos, cache - não encontrei nada.  A biblioteca do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gravador de vídeo</a> escrita por Sergey Pirogov ainda não apareceu.  Permite, adicionando uma anotação ao código, gravar vídeo.  Pude gravar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeo</a> desse teste, assisti-lo em câmera lenta e isso finalmente esclareceu a situação que eu não conseguia resolver por vários meses antes do vídeo. <br><br><img src="https://habrastorage.org/webt/i_/gz/_j/i_gz_jsw_vswjbeql9s2lwsefga.png"><br><br>  A barra de progresso bloqueou o botão por uma fração de segundo e o clique funcionou exatamente naquele momento e atingiu essa barra de progresso.  Ou seja, a barra de progresso clicou e desapareceu!  E não será visível em nenhuma captura de tela, em nenhum log, você nunca saberá o que aconteceu. <br><br>  Em princípio, isso é, de certa forma, um bug do aplicativo: uma barra de progresso apareceu porque o aplicativo realmente sai da borda da tela e, se você rolar, são muitos dados úteis.  Mas os usuários não se queixaram disso, porque tudo se encaixava na tela grande, não se encaixava apenas na tela pequena. <br><br><h2>  Exemplo 6: por que o Chrome congela? </h2><br>  Uma investigação de detetive de dois anos é um caso absolutamente real.  A situação é a seguinte: nossos testes muitas vezes eram escassos e caíam, e nos rastros da pilha ficou claro que o Chrome congela: não o nosso teste, ou seja, o Chrome.  Nos logs, era visível "A construção está executando 36 horas ..." Eles começaram a remover despejos de encadeamentos e rastreamentos de pilha - eles mostram que está tudo bem nos testes, a chamada para o Chromedriver trava e, como regra, no momento do fechamento (chamamos o método close, e esse método não faz nada, demora 36 horas).  Se interessante, o rastreamento da pilha ficou assim: <br><br><img src="https://habrastorage.org/webt/fz/ew/1e/fzew1eu0u-e3oatl1age_oqhnso.jpeg"><br><br>  Tentamos fazer tudo o que só poderia vir à mente: <br><br><ul><li>  Configure o tempo limite para abrir / fechar o navegador (se você não conseguir abrir / fechar o navegador em 15 segundos, tente novamente após 15 segundos, até três tentativas).  Abra e feche o navegador em um thread separado.  Resultado: as três tentativas foram suspensas da mesma maneira. </li><li>  Mate processos antigos do Chrome.  Eles criaram um trabalho separado no 'kill-chrome' de Jenkins, por exemplo, assim, você pode "matar" todos os processos anteriores a uma hora: <br><br>  killall --older-than 1h cromedriver <br>  killall - mais de 1h de cromo <br><br>  Isso pelo menos liberou memória, mas não deu uma resposta para a pergunta "o que está acontecendo?".  De fato, isso só nos atrasou no momento da decisão. </li><li>  Habilite os logs do aplicativo de depuração. </li><li>  Habilite os logs de depuração do WebDriver. </li><li>  Reabra o navegador após cada 20 testes.  Pode parecer ridículo, mas o pensamento era: "E se o Chrome congelar porque está cansado?"  Bem, um vazamento de memória ou outra coisa. </li></ul><br>  O resultado da última tentativa foi completamente inesperado: o problema começou a se repetir com mais frequência!  Esperávamos que isso ajudasse a estabilizar o Chrome para que funcionasse melhor.  Geralmente, esse é um argumento do cérebro.  Mas, de fato, quando o problema começa a se repetir com mais frequência, não se deve ficar triste, mas se alegrar!  Isso torna possível estudá-lo melhor.  Se ela começar a repetir com mais frequência, deve-se apegar a ela: "Sim, sim, agora vou adicionar outra coisa, logs, pontos de interrupção ..." <br><br>  Estamos tentando repetir o problema: escrevemos um ciclo de 1 a 1000, no ciclo simplesmente abrimos o navegador e fechamos a primeira página em nosso aplicativo.  Nós escrevemos esse ciclo, e ... bingo!  Resultado: o problema começou a se repetir de forma estável (embora aproximadamente a cada 80 iterações)!  Legal!  É verdade que essa conquista não deu nada por um longo tempo.  Você iniciou, esperou a 80ª iteração, o Chrome travou ... e depois o que fazer?  Você olha para rastreamentos de pilha, lixões, logs - não há nada útil lá.  As Ferramentas do desenvolvedor no Chrome podem ajudar, mas até setembro de 2017 essas ferramentas não funcionavam com o Selenium (as portas estavam em conflito: você inicia o Chrome a partir do Selenium e o DevTools não abre).  Durante muito tempo, não consegui pensar no que fazer. <br><br>  E aqui nesta história começa um momento fabuloso.  Depois que, depois de um número infinito de tentativas, executei esses testes novamente, ele travou novamente em algum tipo de iteração como a 56. Acho que “vamos cavar outra coisa” (embora eu não saiba mais onde colocar o ponto de interrupção ou o que adicione um log).  Neste momento, minha filha se oferece para jogar cubos, mas meu teste fica parado aqui.  Eu digo: "Espere", ela me disse: "O que você não entende, eu tenho <b>um b e um</b> aqui!" <br><br>  O que fazer, infelizmente saiu do computador, foi jogar cubos ... E de repente, depois de cerca de 20 minutos, acidentalmente olho para a tela e vejo uma imagem completamente inesperada: <br><br><img src="https://habrastorage.org/webt/hm/7o/6p/hm7o6peoyj0zroryt-8g-osfvkc.jpeg"><br><br>  O que acontece: há uma contagem regressiva, após quantos minutos a sessão expira, e eu construo uma torre de cubos, há dois, um ... a sessão expira, o teste continua, corre até o fim e cai (não há mais nenhum elemento, a sessão expirou). <br><br>  O que acontece: o Chrome realmente não congelou, como pensávamos durante todo esse tempo, estava esperando por algo o tempo todo.  Quando a sessão expirou, esperou, continuou.  O que exatamente o Chrome esperava - é completamente incompreensível entender isso, eu tive que vasculhar todo o código usando o método de pesquisa binária: jogar metade do JavaScript e HTML, tentar repetir 80 iterações novamente - não travou, oh, isso significa algum lugar lá fora ... Em geral, entendemos experimentalmente que o problema está aqui: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeout = setTimeout(sessionWatcher);</code> </pre><br>      JavaScript —  ,   ,   . ,  JavaScript- ,      : ,     &lt;script&gt;  .  ,  , ,         ,    .     JavaScript —   jQuery,   $,     function   ,      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeout; $(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ timeout = setTimeout(...); });</code> </pre> <br>   -, , , .      ,    .         1000 ,   . <br><br> ,       : ,  ,    ,      .  ,   Chrome,   . ,        . <br><br>    ,     flaky-  , , ,         .  ,       — ,       ,     (  ).    ,      .  ,     :   ? <br><br>     Chrome       flaky-:       -,   ,    ,    . <br><br>  UI-  :    ,             .    click(),          ,       . , ,  :  click()   ,       . -   , ?  :) <br><br>       .   ,    ,   ,       . ,     ,   ,    ,        Docker. <br><br>  ,    - ,    .     : <br><br><ul><li>  Ajax-; </li><li>  Ajax-; </li><li>  JS; </li><li>   ; </li><li>  ; </li><li>    ; </li><li> ; </li><li>  ; </li><li> UI-; </li><li>   ( ). </li></ul><br>    flaky-    ,     . ,   -,    :  ,   . <br><br>       .  «» .    ,  flaky- ,                 ID,  flaky-    .        . <br><br>   ,  :    ,   ,      . <br><br>  ,  flaky-     usability,   -,       flaky-  .            . <br><br>   ,       ,      …      ,    , ,  flaky-  security-,     .     ,      ! <br><br>    ,    ,     flaky-: <br><br><ul><li>  ; </li><li> Selenide; </li><li>  ; </li><li>     . </li></ul><br>  —   .     flaky- ,  unit-    ,  UI-?  ,    (   ),      ,     flaky. <br><br>  Selenide  . <br><br> .              (,   /   ).   ,     «      ?».      ,  ,    .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,   . <br><br>       ,    .    ,    ,    ,   ,      .      :     « », ,         (10 , 20 ,   — ,   —  ).       ,   flaky -   . <br><br>     ,   flaky- : <br><br><ol><li>   ; </li><li> ; </li><li>  Vídeo </li></ol><br>  «   »    ,    ,   ,   : -         .      «»,  «»  ,  :   flaky-,      ,    flaky.  ,   ,   .     . ,    Jenkins pipeline,   Jenkins      : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { stage(<span class="hljs-string"><span class="hljs-string">"Reports"</span></span>) { junit <span class="hljs-string"><span class="hljs-string">'build/test-results/**/*.xml'</span></span> artifacts = <span class="hljs-string"><span class="hljs-string">'build./reports/**/*,build/test-results/**/*,logs/**/*'</span></span> archiveArtifacts artifacts: artifacts } }</code> </pre><br>  finally    ,    .   :    -  - .  Jenkins        ,  . ,   Jenkins       ,   .   ,  . <br><br>       (Selenide   ,     ).      flaky-.  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Video Recorder</a> ,    :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">video</a> —  ,    ! <br><br>    ,      Docker:    TestContainers (    Heisenbug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ).       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Rule</a> ,   —      Docker    ,  ,     .           . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BrowserWebDriverContainer chrome = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrowserWebDriverContainer() .withRecordingMode(RECORD_ALL, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"build"</span></span>)) .withDesiredCapabilities(chrome());</code> </pre><br>  . <br><br>     . , ,    ,   , ,     .      flaky-        . <br><br> ,   !  ,    :)        .     ,    «     ,    ,  »,       ,      . <br><br>     — , ,   ,   , -   .      —    ,    … ! :)       flaky-  — :    ! <br><br><blockquote>     ,  : 6-7  <b>Heisenbug</b>    .      ,   ,       .     (,  ,  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416757/">https://habr.com/ru/post/pt416757/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416743/index.html">Bot para Starcraft em Rust, C e qualquer outro idioma</a></li>
<li><a href="../pt416745/index.html">Novo ASUS ROG na Computex 2018</a></li>
<li><a href="../pt416751/index.html">Coleta de informações contextuais para log</a></li>
<li><a href="../pt416753/index.html">O popular plugin Hola VPN comprometido</a></li>
<li><a href="../pt416755/index.html">Extreme Likes - Comitê de Investigação Contra</a></li>
<li><a href="../pt416759/index.html">Por que a inteligência artificial não resolverá todos os problemas</a></li>
<li><a href="../pt416761/index.html">Linguagem cósmica, parte 1: a gramática universal é universal?</a></li>
<li><a href="../pt416763/index.html">Puppet Salt Chef Ensemble: Compare Ansible, SaltStack, Chef e Puppet</a></li>
<li><a href="../pt416765/index.html">Empresa Foliplast: um ciclo completo de produção digital na Rússia</a></li>
<li><a href="../pt416767/index.html">Um empate para você ou uma auditoria com hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>