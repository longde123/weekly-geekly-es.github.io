<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôåÔ∏è ‚ûó üë©üèΩ‚Äçüî¨ Quorum Blockchain: Integration in Java-Code ‚ù£Ô∏è ü§±üèΩ üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 


 F√ºr diejenigen, die sich f√ºr das Thema Blockchain interessieren, ist es kein Geheimnis, dass es neben √∂ffentlichen Blockchains wie Eth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quorum Blockchain: Integration in Java-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462549/"><p>  Hallo Habr! </p><br><p>  F√ºr diejenigen, die sich f√ºr das Thema Blockchain interessieren, ist es kein Geheimnis, dass es neben √∂ffentlichen Blockchains wie <em>Ethereum</em> , <em>Bitcoin</em> , <em>Zcash</em> usw. auch ihre "privaten (privaten)" "Br√ºder" gibt, die in gewisser Weise besser sind als √∂ffentliche Netzwerke. aber in etwas verlieren sie gegen sie.  Unter den bekanntesten Netzwerken k√∂nnen Sie <em>Quorum</em> (Anbieter - <strong>JP Morgan Chase</strong> ), <em>Pantheon</em> (Anbieter - <strong>PegaSys</strong> ) und <em>Hyperledger</em> (verwaltet von <strong>The Linux Foundation</strong> ) nennen.  Trotz der Tatsache, dass es viele √∂ffentliche Entscheidungen gibt, ist das Gesch√§ft zunehmend an privaten Blockchains interessiert, da diese das erforderliche Ma√ü an Datenschutz bieten k√∂nnen, Transaktionen schneller sind und so weiter. <a name="habracut"></a>  Die Unterschiede zwischen privaten und √∂ffentlichen Blockchains sowie deren Vor- und Nachteile sind nicht Gegenstand dieses Artikels.  Wenn Sie daran interessiert sind, dar√ºber zu lesen, ist dies beispielsweise ein solcher Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium</a> . </p><br><p>  In diesem Artikel m√∂chte ich Ihnen erkl√§ren, wie Sie die <em>Quorum-</em> Blockchain verwenden k√∂nnen, um Ihre Anwendungen mit Unterst√ºtzung f√ºr private und √∂ffentliche Transaktionen zu entwickeln.  Um die Funktionen zu demonstrieren, schreiben wir eine kleine <em>Java / Spring-</em> Anwendung, die Anforderungen zum Bereitstellen (Bereitstellen) intelligenter Vertr√§ge, Ausf√ºhren von Transaktionen und Lesen von Daten aus einem intelligenten Vertrag akzeptiert.  Hier ist der Technologie-Stack, der im Artikel verwendet wird: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java 8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gradle 5.2.1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fr√ºhlingsrahmen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web3j</a> (Bibliothek f√ºr die Arbeit mit √∂ffentlichen Transaktionen in Ethereum-√§hnlichen Netzwerken) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web3j-Quorum</a> (Bibliothek f√ºr die Arbeit mit privaten Transaktionen im Quorum-Netzwerk) </li></ul><br><h1 id="nemnogo-obschey-informacii-o-quorum">  Einige allgemeine Informationen zum Quorum </h1><br><p>  <em>Quorum</em> ist ein Projekt mit Open Source Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> , dessen Zweck darin besteht, eine Blockchain bereitzustellen, die es erm√∂glicht, Transaktionen nicht nur √∂ffentlich, sondern auch im privaten Modus durchzuf√ºhren.  Aus technischer Sicht ist <em>Quorum</em> ein <em>Ethereum-</em> Upgrade und verf√ºgt √ºber einen eigenen modifizierten <em>Geth-</em> Client, um private Transaktionen durchf√ºhren zu k√∂nnen. </p><br><p>  Eine wichtige Erg√§nzung sind auch <em>Enklavendienste</em> , die f√ºr die Speicherung, Verschl√ºsselung und Verteilung privater Transaktionen untereinander verantwortlich sind.  Jetzt gibt es 2 solcher <em>Enklavendienste</em> : </p><br><ol><li>  <strong>Constellation</strong> - geschrieben in Haskell, der ersten Version der <em>Enklave</em> , aber jetzt entwickelt sie sich nicht mehr und wird h√∂chstwahrscheinlich in Zukunft zugunsten einer neuen Version aufgegeben. </li><li>  <strong>Tessera</strong> - ein neuer, in <em>Java</em> geschriebener Dienst, der von Entwicklern von JP Morgan Chase unterst√ºtzt wird, bietet mehr Optionen f√ºr die Integration in die Datenbank und die Verwaltung vertraulicher Informationen (zum Beispiel gibt es eine Option f√ºr die Integration in <em>HashiCorp Vault</em> zur Verwaltung von Geheimnissen). </li></ol><br><p>  Bei Transaktionen hat sich aus Sicht der Schnittstelle des gew√∂hnlichen <em>Ethereum</em> nicht viel ge√§ndert (und das ist gut so).  Um eine private Transaktion zu senden, m√ºssen Sie zus√§tzlich zu den √ºblichen Informationen √ºber die Transaktion auch den Parameter <strong>privateFor</strong> angeben - dies ist das <strong>Zeilenarray</strong> , und diese Zeilen sind √∂ffentliche Schl√ºssel des <em>Enklavenknotens</em> .  Mit diesen Schl√ºsseln werden <em>Nutzlasttransaktionen</em> <em>verschl√ºsselt</em> und die <em>Nutzlast</em> auf die <strong>Tessera-</strong> Knoten innerhalb der Blockchain verteilt. </p><br><p>  Um einen tieferen Einblick in <em>Quorum zu erhalten</em> , wie es funktioniert und wie das Blockchain-Netzwerk aufgebaut wird, finden Sie es auf der offiziellen Website (einen Link zur Dokumentation sowie einen Link zum Tutorial zum Starten einer Test-Blockchain werde ich am Ende des Artikels hinterlassen). </p><br><h1 id="razrabotka-java-prilozheniya">  Java-Anwendungsentwicklung </h1><br><p>  Als Beispiel werde ich eine kleine in <em>Java / Spring</em> geschriebene RESTful-API mit <em>Gradle</em> als Build- und Abh√§ngigkeitsmanagement-Tool zeigen, das den Smart-Vertrag in die Blockchain l√§dt, die Funktion zum √Ñndern des Vertragsstatus ausf√ºhrt und den Status aus dem Smart-Vertrag liest. </p><br><p>  Bevor ich mit der Entwicklung selbst beginne, muss ich etwas klarstellen.  Trotz der Tatsache, dass <em>Quorum</em> offiziell zwei Transaktionsoptionen hat, ziehe ich es vor, sie in drei Typen zu unterteilen: </p><br><ol><li>  <em>√ñffentliche</em> Transaktionen - Transaktionen sind f√ºr alle Netzwerkteilnehmer (einschlie√ülich <em>Nutzdaten</em> ) vollst√§ndig sichtbar. Der <em>Enklavenknoten</em> nimmt weder an der Verarbeitung noch an der Speicherung der Transaktion teil.  √ñffentliche Transaktionen im <em>Quorum unterscheiden sich</em> nicht von Transaktionen im <em>Ethereum-</em> Netzwerk. </li><li>  <em>Berechtigte</em> Transaktionen - Transaktionen sind im Wesentlichen privat, aber f√ºr mehrere Netzwerkteilnehmer, dh im √∂ffentlichen Netzwerk, haben wir Informationen √ºber die Transaktion und den Status ihrer Ausf√ºhrung, aber anstelle der tats√§chlichen <em>Nutzlast</em> im √∂ffentlichen Netzwerk haben wir nur eine 64-Bit-Hash-Zeichenfolge Durch eine Kennung f√ºr eine reale <em>Nutzlast</em> in einem <em>Enklavenknoten</em> ist der <em>Enklavenknoten</em> selbst f√ºr das Signieren, Verschl√ºsseln, Speichern und Verteilen der <em>Nutzlast</em> zwischen den angegebenen Parteien der Transaktion verantwortlich. </li><li>  <em>Private</em> Transaktionen - unterscheidet sich von <em>Berechtigten dadurch,</em> dass die Transaktion nur f√ºr den Knoten verf√ºgbar ist, der diese Transaktion erstellt hat. Andere Netzwerkteilnehmer k√∂nnen keine <em>Nutzlasttransaktionen sehen</em> . <br>  Ich werde diese Klassifizierung im gesamten Artikel verwenden. </li></ol><br><p> <code>gradle.build</code> zeige ich Ihnen, wie die Build-Datei aussehen wird - <code>gradle.build</code> : </p><br><pre> <code class="plaintext hljs">plugins { id 'org.springframework.boot' version '2.1.6.RELEASE' id 'java' } apply plugin: 'io.spring.dependency-management' group = 'com.github' version = '1.0' sourceCompatibility = '1.8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } test { testLogging.showStandardStreams = true } dependencies { implementation 'org.springframework.boot:spring-boot-starter-webflux' implementation group: 'org.web3j', name: 'quorum', version: '4.0.6' implementation group: 'org.web3j', name: 'core', version: '4.1.0' implementation group: 'org.web3j', name: 'codegen', version: '4.1.0' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'io.projectreactor:reactor-test' } task generateWrappers(type: JavaExec) { group 'Demo' description 'Generates wrappers for smart-contracts' classpath = sourceSets.main.runtimeClasspath main = 'com.github.quorum.utils.WrappersGenerator' }</code> </pre> <br><p>  Ein bisschen Erkl√§rung: </p><br><ol><li>  <code>org.web3j.core</code> - Abh√§ngigkeit f√ºr die Arbeit mit Transaktionen im <em>Ethereum-</em> Netzwerk und √∂ffentlichen Transaktionen im <em>Quorum-</em> Netzwerk </li><li>  <code>org.web3j.quorum</code> - Abh√§ngigkeit f√ºr die Arbeit mit privaten Transaktionen im <em>Quorum-</em> Netzwerk </li><li>  <code>org.web3j.codegen</code> - Abh√§ngigkeit zum Generieren von <code>org.web3j.codegen</code> f√ºr Smart-Vertr√§ge von <em>Solidity</em> </li><li>  <em>generateWrappers</em> - Gradle-Task zum Generieren von <em>Java-</em> Wrappern aus <em>soliden Solidity-</em> Vertr√§gen </li></ol><br><p>  Als n√§chstes zeige ich Ihnen den intelligenten Vertragscode, der in diesem Artikel verwendet wird: <code>QuorumDemo.sol</code> Datei: </p><br><pre> <code class="plaintext hljs">pragma solidity 0.5.0; /** * @dev Smart-Contract for demonstration purposes. */ contract QuorumDemo { string public user; /** * @dev Rewrite user name in storage. */ function writeUser(string calldata _user) public { user = _user; } }</code> </pre> <br><p>  Der Vertrag wird absichtlich vereinfacht, reicht aber f√ºr die Zwecke unseres Artikels aus.  Wenn Sie <em>Solidity</em> kennen, k√∂nnen Sie die Erkl√§rung √ºberspringen: </p><br><ul><li>  <code>string public user</code> - eine √∂ffentliche Variable vom Typ <em>string</em> und der Name <em>user</em> .  Im Gegensatz zu <em>Java</em> generiert <em>Solidity</em> automatisch einen <em>Getter</em> f√ºr √∂ffentliche Variablen, sodass Sie ihn nicht manuell implementieren m√ºssen. </li><li>  <code>function writeUser(...)</code> - die Funktion zum √Ñndern des Werts einer Variablen, tats√§chlich - <em>Setter</em> . </li></ul><br><p>  Um einen <code>Java-wrapper</code> aus einem intelligenten Vertrag zu erstellen, m√ºssen Sie die Datei mit einem beliebigen Namen in den Ordner <code>src/main/solidity/contracts</code> <code>QuorumDemo.sol</code> , z. B. <code>QuorumDemo.sol</code> . <br>  F√ºhren Sie als N√§chstes Gradle-task <em>generateWrappers mit dem folgenden</em> Befehl aus: </p><br><pre> <code class="plaintext hljs">gradle generateWrappers</code> </pre> <br><p>  Nach Abschluss dieser Aufgabe wird unter <code>src/main/java/com/github/quorum/component/wrappers</code> ein <em>Java-Wrapper</em> erstellt, mit dem Sie bereits in <em>Java-</em> Code arbeiten k√∂nnen. </p><br><p>  Damit das Backend Transaktionen signieren kann, m√ºssen wir <em>Nutzlasttransaktionen</em> empfangen k√∂nnen, bevor wir sie senden.  Zu diesem Zweck w√§re es sch√∂n, es direkt von der <em>Java-Wrapper-</em> Klasse zu erhalten.  Hier habe ich 2 Methoden im Wrapper erstellt.  Die erste Methode gibt einfach den <em>ABI des</em> Vertrags zur√ºck, mit dem ein neuer Smart-Vertrag heruntergeladen werden kann.  Die zweite Methode ist die Bildung einer Transaktion, um den Status eines intelligenten Vertrags zu √§ndern.  Hier ist der Code f√ºr diese Methoden: </p><br><pre> <code class="plaintext hljs">public static String getBinary() { return BINARY; } public static String getDataOnWriteUser(final String user) { final Function function = new Function( FUNC_WRITEUSER, Arrays.asList(new Utf8String(user)), Collections.emptyList() ); return FunctionEncoder.encode(function); }</code> </pre> <br><p>  Durch Einf√ºgen in den generierten <em>Java-Wrapper</em> k√∂nnen Sie <em>Nutzdaten</em> f√ºr Transaktionen empfangen. </p><br><p>  Als n√§chstes ben√∂tigen wir eine bequeme M√∂glichkeit, Transaktionen an die Blockchain zu senden, vorzugsweise mit derselben Schnittstelle f√ºr private und √∂ffentliche Transaktionen.  Aus diesem Grund habe ich eine Transaktionsmanager-Schnittstelle und zwei ihrer Implementierungen erstellt: </p><br><ol><li>  <code>TesseraTransactionManager</code> zum Senden privater Transaktionen </li><li>  <code>GethTransactionManager</code> zum Senden √∂ffentlicher Transaktionen </li></ol><br><p>  Nehmen wir sie auseinander.  <code>TesseraTransactionManager</code> Code: </p><br><pre> <code class="plaintext hljs">@Slf4j public class TesseraTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final Quorum quorum; private final String fromAddress; private final QuorumTransactionManager quorumTxManager; private final TransactionReceiptProcessor txReceiptProcessor; public TesseraTransactionManager( Quorum quorum, Credentials credentials, String publicKey, List&lt;String&gt; privateFor, Tessera tessera ) { this.quorum = quorum; this.fromAddress = credentials.getAddress(); this.quorumTxManager = new QuorumTransactionManager(quorum, credentials, publicKey, privateFor, tessera); this.txReceiptProcessor = new PollingTransactionReceiptProcessor(quorum, SLEEP_DURATION, ATTEMPTS); } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data); if (ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error {}", ethSendTx.getError().getMessage()); continue; } return processResponse(ethSendTx); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (Exception ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } private EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) throws IOException { final BigInteger nonce = getNonce(); final RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, to, data); return this.quorumTxManager.signAndSend(rawTransaction); } private TransactionReceipt processResponse(final EthSendTransaction transactionResponse) throws IOException, TransactionException { if (transactionResponse.hasError()) { throw new RuntimeException( "[BLOCKCHAIN] error processing transaction request: " + transactionResponse.getError().getMessage() ); } final String transactionHash = transactionResponse.getTransactionHash(); return this.txReceiptProcessor.waitForTransactionReceipt(transactionHash); } private BigInteger getNonce() throws IOException { final EthGetTransactionCount ethGetTxCount = this.quorum.ethGetTransactionCount( this.fromAddress, DefaultBlockParameterName.PENDING).send(); return ethGetTxCount.getTransactionCount(); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - Implementierung der Schnittstelle, einer Methode zum Ausf√ºhren von Transaktionen im Netzwerk und zum Behandeln von Fehlern, falls diese auftreten.  Gibt ein Objekt mit dem Ergebnis einer Transaktion zur√ºck. </li><li>  <code>EthSendTransaction sendTransaction(...)</code> - eine Methode zum Signieren und Senden von Transaktionen an die Blockchain.  Gibt ein Objekt mit dem Transaktionsstatus und seinem Hash zur√ºck. </li><li>  <code>TransactionReceipt processResponse(...)</code> - eine Methode, die auf den Abschluss der Transaktion wartet und <code>TransactionReceipt</code> nach ihrer Ausf√ºhrung zur√ºckgibt; </li><li>  <code>BigInteger getNonce()</code> - Gibt "nonce" aus dem Netzwerk zur√ºck. </li></ul><br><p>  Und der <code>GethTransactionManager</code> Code: </p><br><pre> <code class="plaintext hljs">@Slf4j public class GethTransactionManager extends FastRawTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final TransactionReceiptProcessor txReceiptProcessor; public GethTransactionManager(Web3j web3j, Credentials credentials) { this(web3j, credentials, new PollingTransactionReceiptProcessor(web3j, SLEEP_DURATION, ATTEMPTS)); } public GethTransactionManager(Web3j web3j, Credentials credentials, TransactionReceiptProcessor txReceiptProcessor) { super(web3j, credentials, txReceiptProcessor); this.txReceiptProcessor = txReceiptProcessor; } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data, BigInteger.ZERO); if (ethSendTx != null &amp;&amp; ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error: {}", ethSendTx.getError().getMessage()); continue; } return this.txReceiptProcessor.waitForTransactionReceipt(ethSendTx.getTransactionHash()); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (IOException ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } @Override public EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data, final BigInteger value ) throws IOException { return super.sendTransaction(gasPrice, gasLimit.add(BigInteger.valueOf(21_000L)), to, data, value); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - Implementierung der Schnittstelle, einer Methode zum Ausf√ºhren von Transaktionen im Netzwerk und zum Behandeln von Fehlern, falls diese auftreten.  Gibt ein Objekt mit dem Ergebnis einer Transaktion zur√ºck. </li><li>  <code>EthSendTransaction sendTransaction(...)</code> ist eine Methode, die die <code>EthSendTransaction sendTransaction(...)</code> Methode aufruft, um eine Transaktion an die Blockchain zu senden. </li></ul><br><p>  Der Handler f√ºr Anforderungen, die an die <em>API gesendet werden</em> : </p><br><pre> <code class="plaintext hljs">@Slf4j @Component public class RequestHandler { private final Web3j web3j; private final Quorum quorum; private final Tessera tessera; private final Credentials credentials; private final BlockchainConfig blockchainConfig; private String deployedContract; @Autowired public RequestHandler( @Qualifier("initWeb3j") Web3j web3j, Quorum quorum, Tessera tessera, Credentials credentials, BlockchainConfig blockchainConfig ) { this.web3j = web3j; this.quorum = quorum; this.tessera = tessera; this.credentials = credentials; this.blockchainConfig = blockchainConfig; } /** * Deploy new smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; deployContract(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::getTransactionManager) .map(this::deployContract) .flatMap(this::generateResponse); } private TransactionManager getTransactionManager(final APIRequest apiRequest) { log.info("[HANDLER] privateFor = {}", apiRequest.getPrivateFor()); TransactionManager txManager; if (isPrivate(apiRequest.getPrivateFor())) { if (apiRequest.getPrivateFor().size() == 0) { apiRequest.getPrivateFor().add(this.blockchainConfig.getTesseraPublicKey()); } txManager = new TesseraTransactionManager(this.quorum, this.credentials, this.blockchainConfig.getTesseraPublicKey(), apiRequest.getPrivateFor(), this.tessera); } else { txManager = new GethTransactionManager(this.web3j, this.credentials); } return txManager; } private boolean isPrivate(final List&lt;String&gt; limitedTo) { return limitedTo == null || limitedTo.size() == 0 || !limitedTo.get(0).equals("public"); } private APIResponse deployContract(final TransactionManager txManager) { log.info("[HANDLER] deploying new smart-contract"); final String data = QuorumDemo.getBinary(); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, DEPLOY_GAS_LIMIT, null, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); this.deployedContract = txReceipt.getContractAddress(); log.info("[HANDLER] contract has been successfully deployed. Result: {}", apiResponse.getMap()); return apiResponse; } private Mono&lt;ServerResponse&gt; generateResponse(final APIResponse apiResponse) { return ServerResponse .ok() .body(Mono.just(apiResponse.getMap()), Map.class); } /** * Send transaction on update user in smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; updateUser(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::sendTransaction) .flatMap(this::generateResponse); } private APIResponse sendTransaction(final APIRequest apiRequest) { final TransactionManager txManager = getTransactionManager(apiRequest); log.info("[HANDLER] sending new transaction"); final String data = QuorumDemo.getDataOnWriteUser(apiRequest.getUser()); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, TX_GAS_LIMIT, this.deployedContract, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); log.info("[HANDLER] transaction has been successfully executed. Result: {}", apiResponse.getMap()); return apiResponse; } /** * Read user from smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; getUser(final ServerRequest serverRequest) { final APIResponse apiResponse = getUser(); return generateResponse(apiResponse); } private APIResponse getUser() { log.info("[HANDLER] reading user from smart-contract"); final QuorumDemo quorumDemo = QuorumDemo.load(this.deployedContract, this.web3j, this.credentials, new StaticGasProvider(GAS_PRICE, DEPLOY_GAS_LIMIT)); final String user = readUserFromSmartContract(quorumDemo); final APIResponse apiResponse = APIResponse.newInstance(user); log.info("[HANDLER] user: '{}'", user); return apiResponse; } private String readUserFromSmartContract(final QuorumDemo quorumDemo) { try { return quorumDemo.user().send().getValue(); } catch (Exception ex) { log.info("[HANDLER] exception while reading user from smart-contract: {}", ex); return null; } } }</code> </pre> <br><p>  Jetzt werde ich erkl√§ren, welche Methoden f√ºr was verantwortlich sind. <br>  <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> - beschreibt die allgemeine Logik der <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> √∂ffentlichen und privaten Smart Contract. <br>  <code>TransactionManager getTransactionManager(...)</code> Methode <code>TransactionManager getTransactionManager(...)</code> - <code>TransactionManager getTransactionManager(...)</code> das Implementierungsobjekt des Transaktionsmanagers abh√§ngig von der Art der Transaktion zur√ºck.  Zu diesem <strong>Zweck</strong> enth√§lt der <strong>Anforderungsparameter den</strong> Parameter <strong>privateFor</strong> , bei dem es sich um ein Array von Zeichenfolgen √∂ffentlicher <em>Tessera-</em> Schl√ºssel handelt. <br>  <code>boolean isPrivate(...)</code> Methode <code>boolean isPrivate(...)</code> - gibt "true" zur√ºck, wenn der Parameter <strong>privateFor</strong> entweder leer ist ( <em>private</em> Transaktion) oder eine Liste √∂ffentlicher Schl√ºssel enth√§lt ( <em>autorisierte</em> Transaktion).  Gibt "false" zur√ºck, wenn der Parameter <strong>privateFor</strong> nicht leer ist und das erste Array-Element gleich "public" ist. <br>  <code>APIResponse deployContract(...)</code> -Methode - sendet die Bereitstellungstransaktion an die Blockchain. <br>  <code>Mono&lt;ServerResponse&gt; generateResponse(...)</code> - generiert ein Objekt mit einer Antwort an den Client. <br>  <code>Mono&lt;ServerResponse&gt; updateUser(...)</code> - beschreibt die allgemeine Logik der Transaktion zum √Ñndern des Status des Smart-Vertrags. <br>  <code>APIResponse sendTransaction(...)</code> -Methode - sendet eine <code>APIResponse sendTransaction(...)</code> an die Blockchain. <br>  <code>APIResponse getUser()</code> -Methode - beschreibt die allgemeine Logik zum Lesen von Informationen aus einem intelligenten Vertrag und gibt eine Antwort an den Client zur√ºck. <br>  <code>String readUserFromSmartContract(...)</code> Methode <code>String readUserFromSmartContract(...)</code> - liest den Status aus dem Smart-Vertrag und gibt das Ergebnis zur√ºck. </p><br><p>  Der vollst√§ndige Anwendungscode ist im <em>GitHub-</em> Repository verf√ºgbar. Ein Link dazu befindet sich am Ende dieses Artikels. </p><br><h1 id="proverka">  √úberpr√ºfen Sie </h1><br><p>  Um alle drei Arten von Transaktionen zu testen, habe ich Testklassen geschrieben (der Code befindet sich im <em>GitHub-</em> Repository).  Zu diesem Zweck habe ich eine Blockchain mit 3 <em>Quorum-</em> Knoten (3 <em>Geth-</em> Knoten + 3 <em>Tessera-</em> Knoten) bereitgestellt.  3 <em>Quorum-</em> Knoten sind die Mindestknoten, die zum √úberpr√ºfen aller Arten von Transaktionen erforderlich sind.  Denken Sie daran, wenn Sie es selbst ausprobieren m√∂chten. </p><br><h2 id="public-tranzakcii">  √ñffentliche Transaktionen </h2><br><p>  Um einen Testfall mit einer √∂ffentlichen Transaktion auszuf√ºhren, m√ºssen Sie den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PublicTransactionsTests</code> </pre> <br><p>  Dieser Testfall sendet 3 <em>API-</em> Anforderungen.  Das erste ist die Bereitstellung des Smart-Vertrags in der Blockchain, das zweite ist die √Ñnderung des Vertragsstatus und die dritte Anforderung ist das Lesen von Informationen aus dem Smart-Vertrag.  Als Ergebnis des Tests werden ungef√§hr die folgenden Protokolle angezeigt (Adressen in Ihrem Netzwerk sowie Transaktions-Hashes unterscheiden sich): </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [public] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf9425b94e459805da09950f5988071692d925097, transaction_hash=0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0} [HANDLER] privateFor = [public] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff} [HANDLER] reading user from smart-contract [HANDLER] user: 'Public Test User'</code> </pre> <br><p>  Im Allgemeinen zeigen diese Protokolle an, dass alle drei Vorg√§nge erfolgreich waren.  Die ersten 3 Protokolle - geh√∂ren zur Anforderung der Bereitstellung des Smart-Vertrags, die n√§chsten 3 Protokolle - geh√∂ren zur Transaktion und die letzten 2 - zum Lesen der Informationen aus dem Smart-Vertrag. <br>  Die Tatsache, dass beim Laden des Vertrags die Vertragsadresse angezeigt wird, bei einer einfachen Transaktion jedoch - nein, dies ist ganz normal, da wir den Vertrag zum zweiten Mal nicht bereitstellen, sondern die Transaktion f√ºr einen vorhandenen Smart-Vertrag ausf√ºhren. </p><br><p>  Lassen Sie uns nun √ºberpr√ºfen, was <em>Geth uns</em> zeigt <em>,</em> und den folgenden Befehl ausf√ºhren, um eine Verbindung zur <em>IPC-</em> Schnittstelle des <em>Geth-</em> Prozesses des Clients <em>herzustellen</em> : </p><br><pre> <code class="plaintext hljs">geth attach /path/to/ipc</code> </pre> <br><p>  Nachdem wir uns an den Prozess gew√∂hnt haben, k√∂nnen Sie alle erforderlichen Informationen vollst√§ndig √ºberpr√ºfen.  Schauen wir uns eine <code>TransactionReceipt</code> Transaktion zur Bereitstellung eines neuen Smart-Vertrags an, indem Sie den Befehl ausf√ºhren (der Transaktions-Hash muss eingerichtet und aus den Testprotokollen entnommen werden): </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  Als Ergebnis sehen wir Folgendes: </p><br><p><img src="https://habrastorage.org/webt/so/jm/yw/sojmyw_4gei16afdq47ypzmvtru.png"></p><br><p>  Wir interessieren uns f√ºr folgende Parameter: </p><br><ul><li>  "contractAddress" - wenn nicht "null", dann verstehen wir, dass dies eine Transaktion f√ºr die Bereitstellung eines intelligenten Vertrags ist; </li><li>  "status" - in diesem Fall ist es gleich "0x1" - was bedeutet, dass die Transaktion erfolgreich war. </li></ul><br><p>  Schauen wir uns die Transaktion selbst an.  Durch Ausf√ºhren des Befehls: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/ju/jq/86/jujq86cugnifanot96ypy_hvusm.png"></p><br><p>  Hier interessieren uns folgende Parameter: </p><br><ul><li>  "Eingabe" ist eine <em>Nutzlasttransaktion</em> ; </li><li>  "v" - im Allgemeinen ist dies ein Parameter f√ºr <em>ECDSA</em> , den Algorithmus f√ºr digitale Signaturen, aber jetzt interessieren wir uns f√ºr etwas anderes - die Bedeutung der Variablen.  Dies ist wichtig, da es bei √∂ffentlichen und privaten Transaktionen unterschiedlich sein wird.  "0x1c" ("28" im Dezimalsystem) und "0x1b" ("27" im Dezimalsystem) sind typisch f√ºr √∂ffentliche Transaktionen und "0x25" ("37" im Dezimalsystem) und "0x26" ("38" im Dezimalsystem) System) - Dies sind private Transaktionscodes. </li></ul><br><p>  Sie k√∂nnen auch √ºberpr√ºfen, ob sich die Informationen auf anderen Knoten nicht von denen unterscheiden, die wir jetzt gesehen haben. </p><br><p>  Jetzt k√∂nnen Sie die Transaktionsstatus√§nderungen des Smart-Vertrags anzeigen.  F√ºhren Sie den folgenden Befehl aus: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff');</code> </pre> <br><p>  Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/zz/8g/a-/zz8ga-le8lswmr7vkizq5tu_zog.png"></p><br><p>  Wir interessieren uns f√ºr folgende Parameter: </p><br><ul><li>  "to" - wir sehen, dass die Transaktion an den gerade erwarteten Smart-Vertrag ging; </li><li>  "status" - entspricht "0x1", was bedeutet, dass die Transaktion erfolgreich war. </li></ul><br><p>  Transaktion: </p><br><p><img src="https://habrastorage.org/webt/t9/yh/xp/t9yhxp0-hzbkvylmous8p--ft2e.png"></p><br><p>  Nichts Ungew√∂hnliches, aber Sie k√∂nnen die Informationen auf anderen Knoten √ºberpr√ºfen. Dies ist n√ºtzlich. </p><br><h2 id="private-tranzakcii">  Private Transaktionen </h2><br><p>  Um einen Testfall mit einer privaten Transaktion auszuf√ºhren, m√ºssen Sie den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PrivateTransactionsTests</code> </pre> <br><p>  Wie im Testfall bei √∂ffentlichen Transaktionen wird in diesem Testfall ein neuer Smart-Vertrag bereitgestellt, eine Status√§nderungstransaktion ausgef√ºhrt und Informationen aus der √Ñnderung im Smart-Vertrag gelesen. </p><br><p>  Infolgedessen schreibt das Programm die folgenden Protokolle: </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0x3e2284d92842f781b83cc7e56fbb074ab15f9a90, transaction_hash=0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595} [HANDLER] privateFor = [] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x72a0458a7b313c8a1c18269ae160e140c6a6e41cb2fd087c64cf665b08a6aefb} [HANDLER] reading user from smart-contract [HANDLER] user: 'Private Test User'</code> </pre> <br><p>  Die √Ñnderung im Vergleich zu √∂ffentlichen Transaktionen ist der Parameter <strong>privateFor</strong> - jetzt hat sie den Wert eines leeren Arrays. <br>  Lassen Sie uns <code>TransactionReceipt</code> auf eine Transaktion √ºberpr√ºfen.  Team: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/qx/aj/1g/qxaj1gluf9gl-o-rwbwaa6-oww8.png"></p><br><p>  Von den √Ñnderungen im Vergleich zu √∂ffentlichen Transaktionen ist anzumerken, dass Sie nicht sehen werden, wie viel Gas f√ºr die Transaktion <strong>ausgegeben wurde</strong> - <strong>gasUsed</strong> und <strong>cumulativeGasUsed</strong> haben den Wert "0". <br>  Schauen wir uns nun die Transaktion selbst an.  F√ºhren Sie den folgenden Befehl aus: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  Als Ergebnis werden wir Folgendes sehen: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p>  Was ist bei dieser Transaktion zu beachten: </p><br><ol><li>  Wie bereits am Anfang dieses Artikels erw√§hnt, wird im <strong>Eingabefeld</strong> anstelle einer echten <em>Nutzlasttransaktion</em> eine feste Zeile mit 64 Byte (128 Zeichen) <strong>angezeigt</strong> .  Diese Zeile ist die Kennung f√ºr die Daten im <em>Tessera-</em> Repository. Auf Anfrage k√∂nnen Sie echte Daten an <em>Tessera senden</em> . </li><li>  "v" - Anstelle der Codes "0x1c" oder "0x1b" wie bei √∂ffentlichen Transaktionen wird bei privaten Transaktionen "0x26" oder "0x25" angezeigt. </li></ol><br><p>  √úberpr√ºfen wir nun den <code>TransactionReceipt</code> und die Transaktion selbst, um den Status des Vertrags zu √§ndern (Sie kennen die Befehle bereits).  Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p><img src="https://habrastorage.org/webt/cw/mp/vk/cwmpvk3hjzcnh51isapyhecpkf0.png"></p><br><p>  Grunds√§tzlich werden wir aus dieser privaten Transaktion nichts Neues lernen. </p><br><h2 id="permissioned-tranzakcii">  Berechtigte Transaktionen </h2><br><p>  Da es sich auch um private Transaktionen handelt, sind sie einfach privat, nicht f√ºr einen Knoten, sondern f√ºr mehrere. Die Ergebnisse solcher Transaktionen unterscheiden sich nicht von privaten Transaktionen.  Sie k√∂nnen einen Unterschied machen, wenn Sie versuchen, Informationen von einem in <strong>privateFor</strong> angegebenen <strong>Knoten</strong> und von einem Knoten <strong>abzurufen,</strong> dessen √∂ffentlicher Schl√ºssel nicht in <strong>privateFor</strong> registriert <strong>ist</strong> (Sie k√∂nnen Informationen vom ersten Knoten <strong>abrufen</strong> und nicht vom zweiten). <br>  Um einen Testfall mit privaten Transaktionen f√ºr mehrere Netzwerkteilnehmer (berechtigte Transaktionen) auszuf√ºhren, m√ºssen Sie den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PermissionTransactionsTests</code> </pre> <br><p>  <em>Java API-</em> Protokolle: </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd, transaction_hash=0x585980bec88aa8a0fe5caffe6d6f24b82d3cd381fcf72fdd8e2102ce67799f01} [HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x47edc0d00fa9447b2da9f5a78f44602f96145497238cb1ce1d879afb351a3cbe} [HANDLER] reading user from smart-contract [HANDLER] user: 'Permissioned Test User'</code> </pre> <br><p>  Die Ergebnisse im <em>Geth-</em> Client zur Bereitstellung des neuen Smart-Vertrags <code>TransactionReceipt</code> bzw. der Transaktion selbst: </p><br><p><img src="https://habrastorage.org/webt/nk/cs/do/nkcsdozorvcuh7gv7kxspwovxmm.png"></p><br><p><img src="https://habrastorage.org/webt/bc/z5/1u/bcz51u6c28aussavjw7fdieayuq.png"></p><br><p>  Und die Status√§nderungstransaktion, <code>TransactionReceipt</code> und die Transaktion selbst: </p><br><p><img src="https://habrastorage.org/webt/4f/al/lt/4falltfjniekypa5r38xu8j6tzo.png"></p><br><p><img src="https://habrastorage.org/webt/tq/-s/ta/tq-stauf7_6a00ts7qgkzif0p18.png"></p><br><h3 id="http-zaprosy">  HTTP-Anfragen </h3><br><p>  Trotz der Tatsache, dass wir gesehen haben, wie sich √∂ffentliche Transaktionen aus Sicht des <em>Geth-</em> Kunden von privaten unterscheiden, zeigt dies keine wirkliche Einschr√§nkung bei der Informationsbeschaffung.  Um Ihnen zu zeigen, dass es wirklich m√∂glich ist, die Anzahl der Knoten zu begrenzen, die Ihre Transaktion lesen k√∂nnen, werde ich mit <em>CURL</em> mehrere Anforderungen f√ºr 3 Knoten stellen, um Informationen aus dem Smart-Vertrag zu lesen (die Anforderungen betreffen <em>private</em> und <em>unterbrochene</em> Transaktionen). <br>  HTTP-Anforderungen haben zwei Parameter im Anforderungshauptteil: </p><br><ol><li>  "Endpunkt" - Direkt Endpunkt zum <em>Quorum-</em> Knoten, Sie m√ºssen eine Verbindung zum Knoten herstellen. </li><li>  "contractAddress" ist die Adresse des Vertrags, aus dem die Daten gelesen werden. </li></ol><br><p>  In meinem Fall hat "endopint" einen Host - <em>localhost</em> - aber verschiedene Ports f√ºr 3 <em>Quorum-</em> Knoten: 22000 (alle Transaktionen wurden von diesem Knoten aus ausgef√ºhrt), 22001 (sein √∂ffentlicher Schl√ºssel wurde in autorisierten Transaktionen angegeben), 22002 (sollte keinen Zugriff haben Informationen). </p><br><p>  Beginnen wir mit einer <em>privaten</em> Transaktion (nur ein Knoten am 22000-Port sollte Informationen in einem Smart-Vertrag anzeigen k√∂nnen). </p><br><p>  <em>CURL-</em> Anforderung auf dem Knoten, der die Transaktion durchgef√ºhrt hat: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Als Ergebnis haben wir Folgendes erhalten: </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Private Test User"}}</code> </pre> <br><p>  Dies bedeutet, dass der Knoten Informationen in einem intelligenten Vertrag anzeigen kann. </p><br><p>  Nun wollen wir sehen, was der Knoten am 22001-Port zu uns zur√ºckgibt.  <em>CURL-</em> Anfrage: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Gro√üartig!        : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>     ,        - ‚Äî    ! </p><br><p>     , 3- . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Gro√üartig! API  : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>   ,        .     "permissioned" . </p><br><p>  <em>CURL</em>       "permissioned" -  ,    22000: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p> : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>  ,         ,   ,       . </p><br><p>       -   ,         -,       . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Gro√üartig!         : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>      ,          ,    . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Gro√üartig!         -.    . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>      ,    <em>Quorum blockchain</em>   Java .      ,    -     . </p><br><p>   : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  <em>Quorum</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   <em>Quorum</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  <em>GitHub</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Quorum</em>   <em>Slack</em></a> </li></ol><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462549/">https://habr.com/ru/post/de462549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462539/index.html">Trigonometrie vermeiden</a></li>
<li><a href="../de462541/index.html">Verwenden von Conditional im Fr√ºhjahr</a></li>
<li><a href="../de462543/index.html">Java-Treffen bei der Raiffeisenbank</a></li>
<li><a href="../de462545/index.html">Telegrammblockierung, Hetzner Subnetz / 16, Erfahrung mit ILV</a></li>
<li><a href="../de462547/index.html">SGX Malvar: Wie B√∂sewichte die neue Technologie von Intel f√ºr die falschen Zwecke nutzen</a></li>
<li><a href="../de462551/index.html">Beliebte Entwicklerfragen zum Testen</a></li>
<li><a href="../de462553/index.html">Ein bisschen √ºber einfach. Testdesign. Teil 1</a></li>
<li><a href="../de462555/index.html">Diskussion: Was ist, wenn Sie ohne Cookies arbeiten? Wir sagen Ihnen, welche Alternativen es gibt</a></li>
<li><a href="../de462563/index.html">Webinar ‚ÄûWie man Compliance √ºberlebt?‚Äú Der beste Ansatz zur Erf√ºllung regulatorischer Anforderungen ‚Äú</a></li>
<li><a href="../de462565/index.html">So bereiten Sie Daten f√ºr SAP Process Mining von Celonis vor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>