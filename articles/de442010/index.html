<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏫 💦 🐇 Python und FPGA. Testen 🙍 ↖️ 🥁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Fortsetzung des ersten Artikels möchte ich als Beispiel ein Beispiel für die Arbeit mit FPGA (FPGA) in Python zeigen. Dieser Artikel behandelt den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python und FPGA. Testen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442010/">  In Fortsetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikels</a> möchte ich als Beispiel ein Beispiel für die Arbeit mit FPGA (FPGA) in Python zeigen.  Dieser Artikel behandelt den Testaspekt ausführlicher.  Wenn das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MyHDL-</a> Framework es Benutzern, die mit der bekannten Syntax und dem bekannten Ökosystem an Python arbeiten, ermöglicht, einen Blick in die Welt des FPGA zu werfen, verstehen erfahrene FPGA-Entwickler die Bedeutung der Verwendung von Python nicht.  Die Hardwarebeschreibungsparadigmen für MyHDL und Verilog sind ähnlich, und die Auswahl einer bestimmten Sprache ist eine Frage der Gewohnheit und des Geschmacks.  Verilog / VHDL steht für die Tatsache, dass Firmware seit langer Zeit in diesen Sprachen geschrieben wurde und tatsächlich Standard für die Beschreibung digitaler Geräte ist.  Python kann als Anfänger auf diesem Gebiet beim Schreiben von Testumgebungen mithalten.  Ein wesentlicher Teil der Zeit des FPGA-Entwicklers wird für das Testen seiner Designs aufgewendet.  Als nächstes möchte ich anhand eines Beispiels demonstrieren, wie dies in Python mit MyHDL gemacht wird. <br><br>  Angenommen, es gibt eine Aufgabe, ein Gerät zu beschreiben, das mit Speicher auf dem FPGA arbeitet.  Der Einfachheit halber verwende ich den Speicher, der mit anderen Geräten kommuniziert, über eine parallele Schnittstelle (und nicht über eine serielle Schnittstelle, z. B. I2C).  Solche Mikroschaltungen sind angesichts der Tatsache, dass viele Stifte erforderlich sind, um mit ihnen zu arbeiten, nicht immer praktisch, andererseits wird ein schnellerer und einfacherer Informationsaustausch bereitgestellt.  Zum Beispiel inländische 1645RU1U und ihre Analoga. <br><br><img src="https://habrastorage.org/webt/e6/hh/ls/e6hhlsa3yvrcdjdzke3dc_jaxby.png"><br><a name="habracut"></a><br><h1>  Modulbeschreibung </h1><br>  Der Datensatz sieht folgendermaßen aus: FPGA gibt eine 16-Bit-Zellenadresse, 8-Bit-Daten, erzeugt ein Schreibsignal WE (Schreibfreigabe).  Da OE (Ausgangsfreigabe) und CE (Chipfreigabe) immer aktiviert sind, erfolgt das Lesen, wenn die Zellenadresse geändert wird.  Das Schreiben und Lesen kann sowohl nacheinander in mehreren Zellen hintereinander erfolgen, beginnend mit einer bestimmten adr_start-Adresse, die an der Vorderflanke des adr_write-Signals aufgezeichnet ist, als auch in einer Zelle an einer beliebigen Adresse (Direktzugriff). <br><br>  In MyHDL sieht der Code folgendermaßen aus (Schreib- und Lesesignale werden in umgekehrter Logik ausgeführt): <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ram_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     mem_z = data_memory.driver() #      @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: #    adr.next = adr_start else: #    / adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 0 #    ,    else: mem_z.next = None #        data_out.next = data_memory we.next = 1 return write_data, write_start_adr</span></span></code> </pre> <br>  Bei Konvertierung in Verilog mit der Funktion: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hdl)</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] inst = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) inst.convert(hdl=hdl) convert(hdl=<span class="hljs-string"><span class="hljs-string">'Verilog'</span></span>)</code> </pre> <br>  Dies führt zu <br><pre> <code class="vhdl hljs">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span>ns/<span class="hljs-number"><span class="hljs-number">10</span></span>ps module ram_driver ( data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we ); input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in; output [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; output [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; reg [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; input [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr_start; input adr_write; <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; input read; input write; output we; reg we; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_z; assign data_memory = mem_z; always @(write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_DATA <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!write)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= data_in; we &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= <span class="hljs-symbol"><span class="hljs-symbol">'bz</span></span>; data_out &lt;= data_memory; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge adr_write, posedge write, negedge read) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_START_ADR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adr_write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= adr_start; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= (adr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br>  Es ist nicht erforderlich, ein Projekt zur Simulation in Verilog zu konvertieren. Dieser Schritt ist zum Flashen des FPGA erforderlich. <br><br><h1>  Modellierung </h1><br>  Nach der Beschreibung der Logik sollte das Projekt überprüft werden.  Sie können sich beispielsweise darauf beschränken, Eingabeeinflüsse zu simulieren und die Reaktion des Moduls im Zeitdiagramm zu sehen.  Mit dieser Option ist es jedoch schwieriger, die Interaktion Ihres Moduls mit einem Speicherchip vorherzusagen.  Um den Betrieb des erstellten Geräts vollständig zu überprüfen, müssen Sie daher ein Speichermodell erstellen und die Interaktion zwischen diesen beiden Geräten testen. <br><br>  Da die Arbeit in Python stattfindet, bietet sich für das Speichermodell der vom Typ angegebene Wörterbuch (Dictionary) an.  Die Daten, in denen {key: value} und in diesem Fall {address: data} gespeichert sind. <br><br><pre> <code class="python hljs">memory = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">789</span></span> } memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  Für den gleichen Zweck ist der Listendatentyp geeignet, bei dem jedes Element seine eigenen Koordinaten hat, die die Position des Elements in der Liste angeben: <br><br><pre> <code class="python hljs">memory = [<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">789</span></span>] memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  Die Verwendung von Wörterbüchern zur Simulation des Gedächtnisses erscheint im Hinblick auf eine bessere Sichtbarkeit vorzuziehen. <br><br>  Die Beschreibung der Test-Shell (in der Datei test_seq_access.py) beginnt mit der Ansage der Signale, der Initialisierung der Anfangszustände und deren Einwurf in die oben beschriebene Speichertreiberfunktion: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def testbench(): data_memory = TristateSignal(intbv(0)[8:]) data_in = Signal(intbv(0)[8:]) data_out = Signal(intbv(0)[8:]) adr = Signal(intbv(0)[16:]) adr_start = Signal(intbv(20)[16:]) adr_write = Signal(bool(0)) read, write, we = [Signal(bool(1)) for i in range(3)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></code> </pre> <br>  Im Folgenden wird das Speichermodell beschrieben.  Anfangszustände werden initialisiert, standardmäßig ist der Speicher mit Nullwerten gefüllt.  Begrenzen Sie das Speichermodell auf 128 Zellen: <br><br><pre> <code class="python hljs">memory = {i: intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)}</code> </pre> <br>  und beschreiben Sie das Verhalten des Speichers: Wenn WE sich im niedrigen Zustand befindet, schreiben Sie den Wert in die Zeile in die entsprechende Speicheradresse, andernfalls gibt das Modell den Wert an der angegebenen Adresse an: <br><br><pre> <code class="python hljs">mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Anschließend können Sie in derselben Funktion das Verhalten der Eingangssignale beschreiben (für den Fall des sequentiellen Schreibens / Lesens): Die Startadresse wird aufgezeichnet → 8 Informationszellen werden aufgezeichnet → Die Startadresse wird aufgezeichnet → 8 aufgezeichnete Informationszellen werden gelesen. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): init_adr = random.randint(0, 50) #   yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr #   yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): # 8    write.next = 0 data_in.next = random.randint(0, 100) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr #   adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): #   read.next = 0 yield delay(100) read.next = 1 yield delay(100) raise StopSimulation return stimul, ram, access</span></span></code> </pre> <br>  Simulation ausführen: <br><br><pre> <code class="python hljs">tb = testbench() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Nach dem Starten des Programms wird die Datei testbench_seq_access.vcd im Arbeitsordner generiert. Öffnen Sie sie in gtkwave: <br><br><pre> <code class="bash hljs">gtkwave testbench_seq_access.vcd</code> </pre> <br>  Und wir sehen das Bild: <br><br><img src="https://habrastorage.org/webt/io/ak/oc/ioakocq8btz-hdlk_-m7xzeshse.jpeg"><br><br>  Die aufgezeichneten Informationen wurden erfolgreich gelesen. <br><br>  Sie können den Inhalt des Speichers anzeigen, indem Sie der Testbench den folgenden Code hinzufügen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory.items(): print(<span class="hljs-string"><span class="hljs-string">'adr:{}'</span></span>.format(key), <span class="hljs-string"><span class="hljs-string">'data:{}'</span></span>.format(value))</code> </pre> <br>  In der Konsole wird Folgendes angezeigt: <br><br><img src="https://habrastorage.org/webt/js/sb/ly/jssbly6h3kodhjqrw7ih9mtzamg.jpeg"><br><br><h1>  Testen </h1><br>  Danach können Sie mehrere automatisierte Tests mit einer erhöhten Anzahl von beschreibbaren / lesbaren Zellen durchführen.  Zu diesem Zweck werden der Testbench mehrere Testzyklen und Dummy-Wörterbücher hinzugefügt, in denen die geschriebenen und lesbaren Informationen und das Assert-Konstrukt hinzugefügt werden. Dies führt zu einem Fehler, wenn zwei Wörterbücher nicht gleich sind: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): for time in range(100): temp_mem_write = {} temp_mem_read = {} init_adr = random.randint(0, 50) yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): write.next = 0 data_in.next = random.randint(0, 100) temp_mem_write[i] = int(data_in.next) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): read.next = 0 temp_mem_read[i] = int(data_out.val) yield delay(100) read.next = 1 yield delay(100) assert temp_mem_write == temp_mem_read, "   " for key, value in memory.items(): print('adr:{}'.format(key), 'data:{}'.format(value)) raise StopSimulation return stimul, ram, access</span></span></code> </pre><br>  Als Nächstes können Sie eine zweite Testbench erstellen, um den Betrieb im Direktzugriffsmodus zu testen: test_random_access.py. <br><br>  Die Idee des zweiten Tests ist ähnlich: Wir schreiben zufällige Informationen an eine zufällige Adresse und fügen dem Wörterbuch temp_mem_write ein Paar {address: data} hinzu.  Dann gehen wir die Adressen in diesem Wörterbuch um, lesen die Informationen aus dem Speicher und geben sie in das Wörterbuch temp_mem_read ein.  Und am Ende mit dem Assert-Konstrukt überprüfen wir den Inhalt von zwei Wörterbüchern. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ram_driver <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ram_driver @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testbench_random_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">20</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) memory ={i:intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)} mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @instance <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stimul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): temp_mem_write = {} temp_mem_read = {} <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">64</span></span>): write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_start.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">126</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> data_in.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) temp_mem_write[int(adr_start.val)] = int(data_in.next) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_mem_write.keys(): adr_start.next = key adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">0</span></span> temp_mem_read[key] = int(data_out.val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> temp_mem_write == temp_mem_read, <span class="hljs-string"><span class="hljs-string">'  random access'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopSimulation <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stimul, ram, access tb = testbench_random_access() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Python verfügt über mehrere Frameworks zur Automatisierung der Testausführung.  Ich werde der Einfachheit halber pytest nehmen, es muss von pip installiert werden: <br><br><pre> <code class="bash hljs">pip3 install pytest</code> </pre> <br>  Wenn der Befehl "pysest" über die Konsole gestartet wird, findet das Framework alle Dateien im Arbeitsordner und führt sie aus, deren Namen "test_ *" enthalten. <br><br><img src="https://habrastorage.org/webt/pv/sz/zr/pvszzr_l6vdb6hnfn1pwkelu5vo.jpeg"><br><br>  Tests erfolgreich abgeschlossen.  Ich werde einen Fehler in der Beschreibung des Geräts machen <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we): mem_z = data_memory.driver() @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: adr.next = adr_start else: adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 1 #  ,    else: mem_z.next = None data_out.next = data_memory we.next = 1</span></span></code> </pre> <br>  Ich führe Tests durch: <br><br><img src="https://habrastorage.org/webt/q7/f3/4b/q7f34bqhdrvwapsxawc_sdquxdu.jpeg"><br><br>  Wie erwartet wurden in beiden Tests die Anfangsinformationen (Nullen) berücksichtigt, dh neue Informationen wurden nicht aufgezeichnet. <br><br><h1>  Fazit </h1><br>  Durch die Verwendung von Python zusammen mit myHDL können Sie das Testen der entwickelten Firmware für FPGAs automatisieren und nahezu jede Testumgebung mit den umfangreichen Funktionen der Programmiersprache Python erstellen. <br><br>  Der Artikel berücksichtigt: <br><br><ul><li>  Erstellen eines Moduls, das mit dem Speicher arbeitet; </li><li>  Erstellen eines Speichermodells; </li><li>  Testfallerstellung; </li><li>  Testautomatisierung mit dem Pytest-Framework. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442010/">https://habr.com/ru/post/de442010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441998/index.html">"Die Container haben den Kampf gewonnen, aber den Krieg gegen die Architektur ohne Server verloren" - Simon Wardley</a></li>
<li><a href="../de442002/index.html">Einführung in die neuronale ODE</a></li>
<li><a href="../de442004/index.html">SVG-Filtereffekte. Teil 7. Vorwärts</a></li>
<li><a href="../de442006/index.html">Dateiverwaltung falsch gemacht - Teil 2: Masterpiece of Shit</a></li>
<li><a href="../de442008/index.html">k3s ist ein kleines, aber zertifiziertes Kubernetes von Rancher Labs</a></li>
<li><a href="../de442012/index.html">Experiment: Wir sammeln ein Verzeichnis von Einheiten, die einen Pass ausgestellt haben</a></li>
<li><a href="../de442014/index.html">Dart 2.2 angekündigt: Effizienterer Maschinencode, Unterstützung für Set-Literale</a></li>
<li><a href="../de442016/index.html">Hacker sind schlimmer als Malen oder wie man Webanwendungen schützt</a></li>
<li><a href="../de442018/index.html">Frühlingsgesetz in Bezug auf die Verfassung. Warum kann</a></li>
<li><a href="../de442020/index.html">Neuer AV1-Codec: Beschleunigt das Laden von Videos in einem Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>