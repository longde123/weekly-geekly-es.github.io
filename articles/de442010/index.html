<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè´ üí¶ üêá Python und FPGA. Testen üôç ‚ÜñÔ∏è ü•Å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Fortsetzung des ersten Artikels m√∂chte ich als Beispiel ein Beispiel f√ºr die Arbeit mit FPGA (FPGA) in Python zeigen. Dieser Artikel behandelt den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python und FPGA. Testen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442010/">  In Fortsetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikels</a> m√∂chte ich als Beispiel ein Beispiel f√ºr die Arbeit mit FPGA (FPGA) in Python zeigen.  Dieser Artikel behandelt den Testaspekt ausf√ºhrlicher.  Wenn das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MyHDL-</a> Framework es Benutzern, die mit der bekannten Syntax und dem bekannten √ñkosystem an Python arbeiten, erm√∂glicht, einen Blick in die Welt des FPGA zu werfen, verstehen erfahrene FPGA-Entwickler die Bedeutung der Verwendung von Python nicht.  Die Hardwarebeschreibungsparadigmen f√ºr MyHDL und Verilog sind √§hnlich, und die Auswahl einer bestimmten Sprache ist eine Frage der Gewohnheit und des Geschmacks.  Verilog / VHDL steht f√ºr die Tatsache, dass Firmware seit langer Zeit in diesen Sprachen geschrieben wurde und tats√§chlich Standard f√ºr die Beschreibung digitaler Ger√§te ist.  Python kann als Anf√§nger auf diesem Gebiet beim Schreiben von Testumgebungen mithalten.  Ein wesentlicher Teil der Zeit des FPGA-Entwicklers wird f√ºr das Testen seiner Designs aufgewendet.  Als n√§chstes m√∂chte ich anhand eines Beispiels demonstrieren, wie dies in Python mit MyHDL gemacht wird. <br><br>  Angenommen, es gibt eine Aufgabe, ein Ger√§t zu beschreiben, das mit Speicher auf dem FPGA arbeitet.  Der Einfachheit halber verwende ich den Speicher, der mit anderen Ger√§ten kommuniziert, √ºber eine parallele Schnittstelle (und nicht √ºber eine serielle Schnittstelle, z. B. I2C).  Solche Mikroschaltungen sind angesichts der Tatsache, dass viele Stifte erforderlich sind, um mit ihnen zu arbeiten, nicht immer praktisch, andererseits wird ein schnellerer und einfacherer Informationsaustausch bereitgestellt.  Zum Beispiel inl√§ndische 1645RU1U und ihre Analoga. <br><br><img src="https://habrastorage.org/webt/e6/hh/ls/e6hhlsa3yvrcdjdzke3dc_jaxby.png"><br><a name="habracut"></a><br><h1>  Modulbeschreibung </h1><br>  Der Datensatz sieht folgenderma√üen aus: FPGA gibt eine 16-Bit-Zellenadresse, 8-Bit-Daten, erzeugt ein Schreibsignal WE (Schreibfreigabe).  Da OE (Ausgangsfreigabe) und CE (Chipfreigabe) immer aktiviert sind, erfolgt das Lesen, wenn die Zellenadresse ge√§ndert wird.  Das Schreiben und Lesen kann sowohl nacheinander in mehreren Zellen hintereinander erfolgen, beginnend mit einer bestimmten adr_start-Adresse, die an der Vorderflanke des adr_write-Signals aufgezeichnet ist, als auch in einer Zelle an einer beliebigen Adresse (Direktzugriff). <br><br>  In MyHDL sieht der Code folgenderma√üen aus (Schreib- und Lesesignale werden in umgekehrter Logik ausgef√ºhrt): <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ram_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     mem_z = data_memory.driver() #      @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: #    adr.next = adr_start else: #    / adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 0 #    ,    else: mem_z.next = None #        data_out.next = data_memory we.next = 1 return write_data, write_start_adr</span></span></code> </pre> <br>  Bei Konvertierung in Verilog mit der Funktion: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hdl)</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] inst = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) inst.convert(hdl=hdl) convert(hdl=<span class="hljs-string"><span class="hljs-string">'Verilog'</span></span>)</code> </pre> <br>  Dies f√ºhrt zu <br><pre> <code class="vhdl hljs">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span>ns/<span class="hljs-number"><span class="hljs-number">10</span></span>ps module ram_driver ( data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we ); input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in; output [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out; output [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; reg [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr; input [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adr_start; input adr_write; <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_memory; input read; input write; output we; reg we; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_z; assign data_memory = mem_z; always @(write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_DATA <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!write)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= data_in; we &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mem_z &lt;= <span class="hljs-symbol"><span class="hljs-symbol">'bz</span></span>; data_out &lt;= data_memory; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge adr_write, posedge write, negedge read) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: RAM_DRIVER_WRITE_START_ADR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adr_write) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= adr_start; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adr &lt;= (adr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br>  Es ist nicht erforderlich, ein Projekt zur Simulation in Verilog zu konvertieren. Dieser Schritt ist zum Flashen des FPGA erforderlich. <br><br><h1>  Modellierung </h1><br>  Nach der Beschreibung der Logik sollte das Projekt √ºberpr√ºft werden.  Sie k√∂nnen sich beispielsweise darauf beschr√§nken, Eingabeeinfl√ºsse zu simulieren und die Reaktion des Moduls im Zeitdiagramm zu sehen.  Mit dieser Option ist es jedoch schwieriger, die Interaktion Ihres Moduls mit einem Speicherchip vorherzusagen.  Um den Betrieb des erstellten Ger√§ts vollst√§ndig zu √ºberpr√ºfen, m√ºssen Sie daher ein Speichermodell erstellen und die Interaktion zwischen diesen beiden Ger√§ten testen. <br><br>  Da die Arbeit in Python stattfindet, bietet sich f√ºr das Speichermodell der vom Typ angegebene W√∂rterbuch (Dictionary) an.  Die Daten, in denen {key: value} und in diesem Fall {address: data} gespeichert sind. <br><br><pre> <code class="python hljs">memory = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">789</span></span> } memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  F√ºr den gleichen Zweck ist der Listendatentyp geeignet, bei dem jedes Element seine eigenen Koordinaten hat, die die Position des Elements in der Liste angeben: <br><br><pre> <code class="python hljs">memory = [<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>, <span class="hljs-number"><span class="hljs-number">789</span></span>] memory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">123</span></span> memory[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre> <br>  Die Verwendung von W√∂rterb√ºchern zur Simulation des Ged√§chtnisses erscheint im Hinblick auf eine bessere Sichtbarkeit vorzuziehen. <br><br>  Die Beschreibung der Test-Shell (in der Datei test_seq_access.py) beginnt mit der Ansage der Signale, der Initialisierung der Anfangszust√§nde und deren Einwurf in die oben beschriebene Speichertreiberfunktion: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def testbench(): data_memory = TristateSignal(intbv(0)[8:]) data_in = Signal(intbv(0)[8:]) data_out = Signal(intbv(0)[8:]) adr = Signal(intbv(0)[16:]) adr_start = Signal(intbv(20)[16:]) adr_write = Signal(bool(0)) read, write, we = [Signal(bool(1)) for i in range(3)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we)</span></span></code> </pre> <br>  Im Folgenden wird das Speichermodell beschrieben.  Anfangszust√§nde werden initialisiert, standardm√§√üig ist der Speicher mit Nullwerten gef√ºllt.  Begrenzen Sie das Speichermodell auf 128 Zellen: <br><br><pre> <code class="python hljs">memory = {i: intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)}</code> </pre> <br>  und beschreiben Sie das Verhalten des Speichers: Wenn WE sich im niedrigen Zustand befindet, schreiben Sie den Wert in die Zeile in die entsprechende Speicheradresse, andernfalls gibt das Modell den Wert an der angegebenen Adresse an: <br><br><pre> <code class="python hljs">mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Anschlie√üend k√∂nnen Sie in derselben Funktion das Verhalten der Eingangssignale beschreiben (f√ºr den Fall des sequentiellen Schreibens / Lesens): Die Startadresse wird aufgezeichnet ‚Üí 8 Informationszellen werden aufgezeichnet ‚Üí Die Startadresse wird aufgezeichnet ‚Üí 8 aufgezeichnete Informationszellen werden gelesen. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): init_adr = random.randint(0, 50) #   yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr #   yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): # 8    write.next = 0 data_in.next = random.randint(0, 100) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr #   adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(8): #   read.next = 0 yield delay(100) read.next = 1 yield delay(100) raise StopSimulation return stimul, ram, access</span></span></code> </pre> <br>  Simulation ausf√ºhren: <br><br><pre> <code class="python hljs">tb = testbench() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Nach dem Starten des Programms wird die Datei testbench_seq_access.vcd im Arbeitsordner generiert. √ñffnen Sie sie in gtkwave: <br><br><pre> <code class="bash hljs">gtkwave testbench_seq_access.vcd</code> </pre> <br>  Und wir sehen das Bild: <br><br><img src="https://habrastorage.org/webt/io/ak/oc/ioakocq8btz-hdlk_-m7xzeshse.jpeg"><br><br>  Die aufgezeichneten Informationen wurden erfolgreich gelesen. <br><br>  Sie k√∂nnen den Inhalt des Speichers anzeigen, indem Sie der Testbench den folgenden Code hinzuf√ºgen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory.items(): print(<span class="hljs-string"><span class="hljs-string">'adr:{}'</span></span>.format(key), <span class="hljs-string"><span class="hljs-string">'data:{}'</span></span>.format(value))</code> </pre> <br>  In der Konsole wird Folgendes angezeigt: <br><br><img src="https://habrastorage.org/webt/js/sb/ly/jssbly6h3kodhjqrw7ih9mtzamg.jpeg"><br><br><h1>  Testen </h1><br>  Danach k√∂nnen Sie mehrere automatisierte Tests mit einer erh√∂hten Anzahl von beschreibbaren / lesbaren Zellen durchf√ºhren.  Zu diesem Zweck werden der Testbench mehrere Testzyklen und Dummy-W√∂rterb√ºcher hinzugef√ºgt, in denen die geschriebenen und lesbaren Informationen und das Assert-Konstrukt hinzugef√ºgt werden. Dies f√ºhrt zu einem Fehler, wenn zwei W√∂rterb√ºcher nicht gleich sind: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@instance def stimul(): for time in range(100): temp_mem_write = {} temp_mem_read = {} init_adr = random.randint(0, 50) yield delay(100) write.next = 1 adr_write.next = 1 adr_start.next = init_adr yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): write.next = 0 data_in.next = random.randint(0, 100) temp_mem_write[i] = int(data_in.next) yield delay(100) write.next = 1 yield delay(100) adr_start.next = init_adr adr_write.next = 1 yield delay(100) adr_write.next = 0 yield delay(100) for i in range(64): read.next = 0 temp_mem_read[i] = int(data_out.val) yield delay(100) read.next = 1 yield delay(100) assert temp_mem_write == temp_mem_read, "   " for key, value in memory.items(): print('adr:{}'.format(key), 'data:{}'.format(value)) raise StopSimulation return stimul, ram, access</span></span></code> </pre><br>  Als N√§chstes k√∂nnen Sie eine zweite Testbench erstellen, um den Betrieb im Direktzugriffsmodus zu testen: test_random_access.py. <br><br>  Die Idee des zweiten Tests ist √§hnlich: Wir schreiben zuf√§llige Informationen an eine zuf√§llige Adresse und f√ºgen dem W√∂rterbuch temp_mem_write ein Paar {address: data} hinzu.  Dann gehen wir die Adressen in diesem W√∂rterbuch um, lesen die Informationen aus dem Speicher und geben sie in das W√∂rterbuch temp_mem_read ein.  Und am Ende mit dem Assert-Konstrukt √ºberpr√ºfen wir den Inhalt von zwei W√∂rterb√ºchern. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myhdl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ram_driver <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ram_driver @block <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testbench_random_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> data_memory = TristateSignal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_in = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) data_out = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">8</span></span>:]) adr = Signal(intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_start = Signal(intbv(<span class="hljs-number"><span class="hljs-number">20</span></span>)[<span class="hljs-number"><span class="hljs-number">16</span></span>:]) adr_write = Signal(bool(<span class="hljs-number"><span class="hljs-number">0</span></span>)) read, write, we = [Signal(bool(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>)] ram = ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we) memory ={i:intbv(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">128</span></span>)} mem_z = data_memory.driver() @always_comb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> we: memory[int(adr.val)] = data_memory.val <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we: data_out.next = memory[int(adr.val)] mem_z.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @instance <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stimul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): temp_mem_write = {} temp_mem_read = {} <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">64</span></span>): write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> adr_start.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">126</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> data_in.next = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) temp_mem_write[int(adr_start.val)] = int(data_in.next) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> temp_mem_write.keys(): adr_start.next = key adr_write.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) adr_write.next = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">0</span></span> temp_mem_read[key] = int(data_out.val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) read.next = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> temp_mem_write == temp_mem_read, <span class="hljs-string"><span class="hljs-string">'  random access'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopSimulation <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stimul, ram, access tb = testbench_random_access() tb.config_sim(trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.run_sim()</code> </pre> <br>  Python verf√ºgt √ºber mehrere Frameworks zur Automatisierung der Testausf√ºhrung.  Ich werde der Einfachheit halber pytest nehmen, es muss von pip installiert werden: <br><br><pre> <code class="bash hljs">pip3 install pytest</code> </pre> <br>  Wenn der Befehl "pysest" √ºber die Konsole gestartet wird, findet das Framework alle Dateien im Arbeitsordner und f√ºhrt sie aus, deren Namen "test_ *" enthalten. <br><br><img src="https://habrastorage.org/webt/pv/sz/zr/pvszzr_l6vdb6hnfn1pwkelu5vo.jpeg"><br><br>  Tests erfolgreich abgeschlossen.  Ich werde einen Fehler in der Beschreibung des Ger√§ts machen <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@block def ram_driver(data_in, data_out, adr, adr_start, adr_write, data_memory, read, write, we): mem_z = data_memory.driver() @always(adr_write.posedge, write.posedge, read.negedge) def write_start_adr(): if adr_write: adr.next = adr_start else: adr.next = adr + 1 @always(write) def write_data(): if not write: mem_z.next = data_in we.next = 1 #  ,    else: mem_z.next = None data_out.next = data_memory we.next = 1</span></span></code> </pre> <br>  Ich f√ºhre Tests durch: <br><br><img src="https://habrastorage.org/webt/q7/f3/4b/q7f34bqhdrvwapsxawc_sdquxdu.jpeg"><br><br>  Wie erwartet wurden in beiden Tests die Anfangsinformationen (Nullen) ber√ºcksichtigt, dh neue Informationen wurden nicht aufgezeichnet. <br><br><h1>  Fazit </h1><br>  Durch die Verwendung von Python zusammen mit myHDL k√∂nnen Sie das Testen der entwickelten Firmware f√ºr FPGAs automatisieren und nahezu jede Testumgebung mit den umfangreichen Funktionen der Programmiersprache Python erstellen. <br><br>  Der Artikel ber√ºcksichtigt: <br><br><ul><li>  Erstellen eines Moduls, das mit dem Speicher arbeitet; </li><li>  Erstellen eines Speichermodells; </li><li>  Testfallerstellung; </li><li>  Testautomatisierung mit dem Pytest-Framework. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442010/">https://habr.com/ru/post/de442010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441998/index.html">"Die Container haben den Kampf gewonnen, aber den Krieg gegen die Architektur ohne Server verloren" - Simon Wardley</a></li>
<li><a href="../de442002/index.html">Einf√ºhrung in die neuronale ODE</a></li>
<li><a href="../de442004/index.html">SVG-Filtereffekte. Teil 7. Vorw√§rts</a></li>
<li><a href="../de442006/index.html">Dateiverwaltung falsch gemacht - Teil 2: Masterpiece of Shit</a></li>
<li><a href="../de442008/index.html">k3s ist ein kleines, aber zertifiziertes Kubernetes von Rancher Labs</a></li>
<li><a href="../de442012/index.html">Experiment: Wir sammeln ein Verzeichnis von Einheiten, die einen Pass ausgestellt haben</a></li>
<li><a href="../de442014/index.html">Dart 2.2 angek√ºndigt: Effizienterer Maschinencode, Unterst√ºtzung f√ºr Set-Literale</a></li>
<li><a href="../de442016/index.html">Hacker sind schlimmer als Malen oder wie man Webanwendungen sch√ºtzt</a></li>
<li><a href="../de442018/index.html">Fr√ºhlingsgesetz in Bezug auf die Verfassung. Warum kann</a></li>
<li><a href="../de442020/index.html">Neuer AV1-Codec: Beschleunigt das Laden von Videos in einem Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>