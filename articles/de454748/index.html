<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🕤 👩🏼‍🎓 MongoDB Survival Guide 📢 🅿️ 🥊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alle guten Startups sterben entweder schnell oder wachsen maßstabsgetreu. Wir werden ein solches Startup modellieren, bei dem es zuerst um Funktionen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MongoDB Survival Guide</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/454748/">  Alle guten Startups sterben entweder schnell oder wachsen maßstabsgetreu.  Wir werden ein solches Startup modellieren, bei dem es zuerst um Funktionen und dann um Leistung geht.  Mit MongoDB, einer beliebten NoSQL-Datenspeicherlösung, verbessern wir die Leistung.  MongoDB ist einfach zu starten und viele Probleme haben sofort einsatzbereite Lösungen.  Wenn jedoch die Last zunimmt, kommt ein Rechen heraus, vor dem Sie noch niemand gewarnt hat ... bis heute! <br><br><img src="https://habrastorage.org/webt/oh/rq/ua/ohrquayfyh04hfgs-gareddfzlk.gif" alt="Bild"><br><br>  Die Modellierung wird von <strong>Sergey Zagursky durchgeführt</strong> , der für die Backend-Infrastruktur im Allgemeinen und MongoDB im Besonderen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joom verantwortlich ist</a> .  Es wurde auch auf der Serverseite der Entwicklung von MMORPG Skyforge gesehen.  Wie Sergei sich selbst beschreibt, ist er „ein professioneller Kegelnehmer mit eigener Stirn und Rechen“.  Unter dem Mikroskop ein Projekt, das eine Akkumulationsstrategie verwendet, um technische Schulden zu verwalten.  In dieser Textversion des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichts</a> in HighLoad ++ werden wir in chronologischer Reihenfolge vom Auftreten des Problems zur Lösung mit MongoDB übergehen. <br><a name="habracut"></a><br><h2>  Erste Schwierigkeiten </h2><br>  Wir modellieren ein Startup, das Unebenheiten stopft.  Die erste Lebensphase - Funktionen werden in unserem Startup gestartet und unerwartet kommen Benutzer.  Unser kleiner MongoDB-Server hat eine Last, von der wir nie geträumt haben.  Aber wir sind in der Cloud, wir sind ein Startup!  Wir machen die einfachsten Dinge: Schauen Sie sich die Anforderungen an - oh, und hier haben wir die gesamte Korrektur für jeden Benutzer abgezogen, hier werden wir die Indizes erstellen, wir werden die Hardware dort hinzufügen und hier werden wir zwischenspeichern. <br>  Alles - wir leben weiter! <br><br><blockquote>  Wenn Probleme mit so einfachen Mitteln gelöst werden können, sollten sie auf diese Weise gelöst werden. </blockquote><br>  Der zukünftige Weg eines erfolgreichen Starts ist jedoch eine langsame, schmerzhafte Verzögerung des horizontalen Skalierungsmoments.  Ich werde versuchen, Ratschläge zu geben, wie man diese Zeit überlebt, zur Skalierung kommt und nicht auf den Rechen tritt. <br><br><h2>  Langsame Aufnahme </h2><br>  Dies ist eines der Probleme, auf die Sie möglicherweise stoßen.  Was tun, wenn Sie sie treffen und die oben genannten Methoden nicht helfen?  Antwort: <strong>Standardmäßig ist der</strong> <strong>Haltbarkeitsgarantiemodus</strong> <strong>in MongoDB</strong> .  In drei Worten funktioniert es so: <br><br><ul><li>  Wir kamen zur Hauptleitung und sagten: "Schreiben!". <br></li><li>  Primärreplik aufgezeichnet. <br></li><li>  Danach wurden sekundäre Repliken von ihr gelesen und sie sagten primär: "Wir haben aufgenommen!" <br></li></ul><br>  In dem Moment, in dem die meisten sekundären Replikate dies getan haben, wird die Anforderung als vollständig betrachtet und die Steuerung kehrt zum Treiber in der Anwendung zurück.  Mit solchen Garantien können wir sicher sein, dass die Haltbarkeit nach der Rückkehr der Kontrolle zur Anwendung nirgendwohin führt, selbst wenn MongoDB sich hinlegt, außer bei absolut schrecklichen Katastrophen. <br><br><blockquote>  Glücklicherweise ist MongoDB eine solche Datenbank, mit der Sie die Haltbarkeitsgarantien für jede einzelne Anfrage reduzieren können. </blockquote><br>  Bei wichtigen Anfragen können wir standardmäßig die maximalen Haltbarkeitsgarantien beibehalten und bei einigen Anfragen reduzieren. <br><br><h3>  Klassen anfordern </h3><br>  Die erste Garantieebene, die wir entfernen können, besteht darin, <strong>nicht auf die Bestätigung des Datensatzes durch die meisten Replikate zu warten</strong> .  Dies spart Latenz, erhöht jedoch nicht die Bandbreite.  Manchmal ist jedoch eine Latenz erforderlich, insbesondere wenn der Cluster etwas überlastet ist und sekundäre Replikate nicht so schnell funktionieren, wie wir es möchten. <br><br><pre><code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>}</code> </pre> <br>  Wenn wir Aufzeichnungen mit solchen Garantien schreiben, wissen wir in dem Moment, in dem wir die Kontrolle über die Anwendung erhalten, nicht mehr, ob die Aufzeichnung nach einem Unfall lebendig sein wird.  Aber normalerweise lebt sie noch. <br><br>  Die nächste Garantie, die sich auch auf Bandbreite und Latenz auswirkt, ist das <strong>Deaktivieren der Protokollierungsbestätigung</strong> .  Ein Journaleintrag wird trotzdem geschrieben.  Das Magazin ist einer der grundlegenden Mechanismen.  Wenn wir die Bestätigung des Schreibens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u><strong>deaktivieren</strong></u></a> , tun wir nicht zwei Dinge: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u><strong>fsync</strong></u></a> <strong>im Protokoll</strong> und <strong>warten nicht, bis es endet</strong> .  Dies kann <strong>eine Menge Festplattenressourcen einsparen</strong> und den <strong>Durchsatz</strong> um ein <strong>Vielfaches steigern, indem</strong> einfach die Dauer der Garantie geändert wird. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}</code> </pre> <br>  Die strengsten Haltbarkeitsgarantien sind das <strong>Deaktivieren von Bestätigungen</strong> .  Wir erhalten nur eine Bestätigung, dass die Anfrage das primäre Replikat erreicht hat.  Dies spart Latenz und erhöht den Durchsatz in keiner Weise. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} —   .</code> </pre> <br>  Wir werden auch verschiedene andere Dinge erhalten, zum Beispiel, dass die Aufzeichnung aufgrund eines Konflikts mit einem eindeutigen Schlüssel fehlgeschlagen ist. <br><br><h3>  Für welche Operationen gilt dies? </h3><br>  Ich erzähle Ihnen von der Anwendung für das Setup in Joom.  Zusätzlich zur Last von Benutzern, bei denen es keine Zugeständnisse für die Haltbarkeit gibt, gibt es eine Last, die als Hintergrund-Batch-Last bezeichnet werden kann: Aktualisieren, Nachzählen von Bewertungen, Sammeln von Analysedaten. <br><br>  Diese Hintergrundoperationen können Stunden dauern, sind jedoch so konzipiert, dass sie bei einem Absturz, beispielsweise einem Backend, nicht das Ergebnis all ihrer Arbeit verlieren, sondern von dem Punkt in der jüngeren Vergangenheit aus fortgesetzt werden.  Das Reduzieren der Haltbarkeitsgarantie ist für solche Aufgaben nützlich, insbesondere da fsync im Protokoll wie bei allen anderen Vorgängen die Latenz auch beim Lesen erhöht. <br><br><h2>  Skalierung lesen </h2><br>  Das nächste Problem ist die <strong>unzureichende Lesebandbreite</strong> .  Denken Sie daran, dass es in unserem Cluster nicht nur primäre, sondern auch sekundäre Replikate gibt, <strong>aus denen Sie lesen können</strong> .  Lass es uns tun. <br><br>  Sie können lesen, aber es gibt Nuancen.  Etwas veraltete Daten stammen von sekundären Replikaten - um 0,5 bis 1 Sekunden.  In den meisten Fällen ist dies normal, aber das Verhalten des sekundären Replikats unterscheidet sich vom Verhalten der primären Replikate. <br><br>  Auf der sekundären Ebene wird oplog verwendet, das sich nicht auf der primären Replik befindet.  Dieser Prozess ist nicht auf niedrige Latenz ausgelegt - nur die MongoDB-Entwickler haben sich nicht darum gekümmert.  Unter bestimmten Umständen kann die Verwendung von Oplog von primär zu sekundär zu Verzögerungen von bis zu 10 s führen. <br><br><blockquote>  Sekundäre Replikate sind nicht für Benutzeranfragen geeignet - Benutzererfahrungen machen einen flotten Schritt in den Papierkorb. </blockquote><br>  Auf nicht schattierten Clustern sind diese Spitzen weniger auffällig, aber immer noch vorhanden.  Shard-Cluster leiden darunter, dass Oplog besonders vom Löschen betroffen ist und das <strong>Löschen Teil der Aufgabe des Balancers ist</strong> .  Der Balancer löscht Dokumente in kurzer Zeit zuverlässig und geschmackvoll zu Zehntausenden. <br><br><h2>  Anzahl der Verbindungen </h2><br>  Der nächste zu berücksichtigende Faktor ist die <strong>Begrenzung der Anzahl der Verbindungen auf MongoDB-Instanzen</strong> .  Standardmäßig gibt es keine Einschränkungen, <strong>außer für Betriebssystemressourcen.</strong> Sie können eine Verbindung herstellen, solange dies zulässig ist. <br><br>  Je mehr gleichzeitige Anforderungen gleichzeitig ausgeführt werden, desto langsamer werden sie ausgeführt.  <strong>Die Leistung verschlechtert sich nichtlinear</strong> .  Wenn daher eine Zunahme von Anfragen bei uns eintrifft, ist es besser, 80% zu bedienen, als 100% nicht zu bedienen.  Die Anzahl der Verbindungen muss direkt auf MongoDB begrenzt werden. <br><br>  Es gibt jedoch Fehler, die aufgrund dessen Probleme verursachen können.  Insbesondere ist der <strong>Verbindungspool auf der MongoDB-Seite sowohl für Benutzer- als auch für Service-Intracluster-Verbindungen gleich</strong> .  Wenn die Anwendung alle Verbindungen aus diesem Pool "gefressen" hat, kann die Integrität im Cluster verletzt werden. <br><br>  Wir haben davon erfahren, als wir den Index neu erstellen wollten, und da wir die Eindeutigkeit aus dem Index entfernen mussten, durchlief das Verfahren mehrere Phasen.  In MongoDB können Sie nicht gleich neben dem Index erstellen, jedoch ohne Eindeutigkeit.  Deshalb wollten wir: <br><br><ul><li>  Erstellen Sie einen ähnlichen Index ohne Eindeutigkeit <br></li><li>  Entfernen Sie den Index mit Eindeutigkeit. <br></li><li>  Erstellen Sie einen Index ohne Eindeutigkeit anstelle von Remote. <br></li><li>  vorübergehend löschen. <br></li></ul><br>  Als der temporäre Index noch auf dem sekundären Index fertiggestellt wurde, haben wir begonnen, den eindeutigen Index zu löschen.  Zu diesem Zeitpunkt kündigte die sekundäre MongoDB ihre Sperre an.  Einige Metadaten wurden blockiert, und in der Mehrzahl wurden alle Datensätze gestoppt: Sie hingen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Verbindungspool</u></a> und warteten darauf, dass sie bestätigten, dass der Datensatz bestanden wurde.  Alle Lesevorgänge auf der Sekundärseite wurden ebenfalls gestoppt, da das globale Protokoll erfasst wurde. <br><br>  Der Cluster in einem so interessanten Zustand verlor auch seine Konnektivität.  Manchmal erschien es und als zwei Bemerkungen miteinander verbunden waren, versuchten sie, in ihrem Zustand eine Wahl zu treffen, die sie nicht treffen konnten, weil sie eine globale Sperre haben. <br><br><blockquote>  Moral der Geschichte: Die Anzahl der Verbindungen muss überwacht werden. </blockquote><br>  Es gibt einen bekannten MongoDB-Rechen, der immer noch so oft angegriffen wird, dass ich mich entschlossen habe, einen kurzen Spaziergang darauf zu machen. <br><br><h2>  Verlieren Sie keine Dokumente </h2><br>  Wenn Sie eine Anforderung per Index an MongoDB senden, gibt die <strong>Anforderung möglicherweise nicht alle Dokumente zurück</strong> , die die Bedingung erfüllen, und dies in völlig unerwarteten Fällen.  Dies liegt an der Tatsache, dass wenn wir zum Anfang des Index gehen, das Dokument, das am Ende für die Dokumente, die wir übergeben haben, an den Anfang verschoben wird.  Dies ist ausschließlich <strong>auf die Veränderlichkeit des Index zurückzuführen</strong> .  Verwenden Sie für eine zuverlässige Iteration <strong>Indizes für nicht stabile Felder,</strong> und es treten keine Schwierigkeiten auf. <br>  MongoDB hat seine eigenen Ansichten, welche Indizes verwendet werden sollen.  Die Lösung ist einfach: <strong>Mit Hilfe von $ Hinweis zwingen wir MongoDB, den von uns angegebenen Index zu verwenden</strong> . <br><br><h2>  Sammlungsgrößen </h2><br>  Unser Startup entwickelt sich, es gibt viele Daten, aber ich möchte keine Festplatten hinzufügen - wir haben im letzten Monat bereits dreimal hinzugefügt.  Mal sehen, was in unseren Daten gespeichert ist, schauen wir uns die Größe der Dokumente an.  Wie können Sie verstehen, wo in der Sammlung Sie die Größe reduzieren können?  Nach zwei Parametern. <br><br><ul><li>  <strong>Die Größe</strong> <strong>bestimmter Dokumente</strong> , die mit ihrer Länge <code>Object.bsonsize()</code> : <code>Object.bsonsize()</code> ; <br></li><li>  <strong>Entsprechend der durchschnittlichen</strong> <strong>Größe des Dokuments in</strong> <strong>der</strong> <strong>Sammlung</strong> : <code>db.c.stats().avgObjectSize</code> . <br></li></ul><br><h3>  Wie kann die Größe des Dokuments beeinflusst werden? </h3><br>  Ich habe unspezifische Antworten auf diese Frage.  Erstens <strong>erhöht</strong> ein <strong>langer Feldname die Größe des Dokuments.</strong>  In jedem Dokument werden alle Feldnamen kopiert. Wenn das Dokument also einen langen Feldnamen hat, muss die Größe des Namens zur Größe jedes Dokuments hinzugefügt werden.  Wenn Sie eine Sammlung mit einer großen Anzahl kleiner Dokumente in mehreren Feldern haben, benennen Sie die Felder mit Kurznamen: "A", "B", "CD" - maximal zwei Buchstaben.  <strong>Auf der Festplatte wird dies durch Komprimierung ausgeglichen</strong> , aber alles wird unverändert im Cache gespeichert. <br><br>  Der zweite Tipp ist, dass manchmal <strong>einige Felder mit geringer Kardinalität im Namen der Sammlung platziert werden können</strong> .  Beispielsweise kann ein solches Feld eine Sprache sein.  Wenn wir eine Sammlung mit Übersetzungen ins Russische, Englische, Französische und ein Feld mit Informationen zur gespeicherten Sprache haben, kann der Wert dieses Feldes in den Namen der Sammlung eingetragen werden.  So <strong>reduzieren</strong> wir <strong>die Größe von Dokumenten</strong> und können <strong>die Anzahl und Größe von Indizes reduzieren</strong> - <strong>reine</strong> Einsparungen!  Dies ist nicht immer möglich, da manchmal Indizes im Dokument vorhanden sind, die nicht funktionieren, wenn die Sammlung in verschiedene Sammlungen unterteilt ist. <br><br>  Letzter Tipp zur Dokumentgröße - <strong>Verwenden Sie das Feld _id</strong> .  Wenn Ihre Daten einen natürlichen eindeutigen Schlüssel haben, geben Sie ihn direkt in das Feld id_field ein.  Auch wenn der Schlüssel zusammengesetzt ist - verwenden Sie eine zusammengesetzte ID.  Es ist perfekt indiziert.  Es gibt nur einen kleinen Rechen: Wenn Ihr Marshaller manchmal die Reihenfolge der Felder ändert, wird die ID mit denselben Feldwerten, aber mit unterschiedlicher Reihenfolge als unterschiedliche ID in Bezug auf einen eindeutigen Index in MongoDB betrachtet.  In einigen Fällen kann dies in Go passieren. <br><br><h2>  Indexgrößen </h2><br>  <strong>Der Index speichert eine Kopie der darin enthaltenen Felder</strong> .  Die Größe des Index besteht aus den indizierten Daten.  Wenn wir versuchen, große Felder zu indizieren, müssen Sie sich darauf einstellen, dass der Index groß ist. <br><br>  Der zweite Moment erhöht die Indizes stark: <strong>Array-Felder im Index multiplizieren andere Felder aus dem Dokument in diesem Index</strong> .  Seien Sie vorsichtig mit großen Arrays in Dokumenten: Indizieren Sie entweder nichts anderes für das Array oder spielen Sie mit der Reihenfolge, in der die Felder im Index aufgelistet sind. <br><br>  <strong>Die Reihenfolge der Felder ist wichtig</strong> , <strong>insbesondere wenn eines der Indexfelder ein Array ist</strong> .  Wenn sich die Felder in der Kardinalität unterscheiden und sich in einem Feld die Anzahl der möglichen Werte stark von der Anzahl der möglichen Werte in einem anderen Feld unterscheidet, ist es sinnvoll, sie durch Erhöhen der Kardinalität zu erstellen.  <strong>Sie können problemlos 50% der Indexgröße speichern, wenn Sie Felder mit unterschiedlicher Kardinalität austauschen.</strong>  Die Permutation der Felder kann zu einer signifikanteren Verringerung der Größe führen. <br><br>  Manchmal, wenn das Feld einen großen Wert enthält, müssen wir diesen Wert nicht mehr oder weniger vergleichen, sondern einen klaren Gleichheitsvergleich.  Dann kann der <strong>Index für das Feld mit starkem Inhalt</strong> <strong>durch den Index für Hash aus diesem Feld ersetzt werden</strong> .  Kopien von Hash werden im Index gespeichert, keine Kopien dieser Felder. <br><br><h2>  Dokumente löschen </h2><br>  Ich habe bereits erwähnt, dass das Löschen von Dokumenten ein unangenehmer Vorgang ist und <strong>es besser ist, wenn möglich nicht zu löschen.</strong>  Versuchen Sie beim Entwerfen eines Datenschemas, entweder das Entfernen einzelner Daten zu minimieren oder ganze Sammlungen zu löschen.  Sie könnten mit ganzen Sammlungen gelöscht werden.  Das Entfernen von Sammlungen ist ein billiger Vorgang, und das Löschen von Tausenden einzelner Dokumente ist ein schwieriger Vorgang. <br><br>  Wenn Sie immer noch viele Dokumente löschen müssen, <strong>müssen Sie die Drosselung durchführen</strong> . Andernfalls <strong>wirkt sich</strong> das Massenlöschen von Dokumenten auf die Leselatenz aus und ist unangenehm.  Dies ist besonders schlecht für die Latenz auf sekundären. <br><br>  Es lohnt sich, eine Art „Stift“ zu machen, um die Drosselung zu aktivieren - es ist sehr schwierig, das Niveau beim ersten Mal zu erreichen.  Wir haben es so oft durchlaufen, dass die Drosselung ab dem dritten, vierten Mal vermutet wird.  Betrachten Sie zunächst die Möglichkeit eines Festziehens. <br><br>  <strong>Wenn Sie mehr als 30% einer großen Sammlung löschen, übertragen Sie Live-Dokumente in die benachbarte Sammlung</strong> und löschen Sie die alte Sammlung als Ganzes.  Es ist klar, dass es Nuancen gibt, weil die Last von der alten auf die neue Sammlung umgeschaltet wird, aber wenn möglich verschoben wird. <br><br>  Eine andere Möglichkeit, Dokumente zu löschen, ist der <strong>TTL-</strong> Index, ein Index, der das Feld indiziert, das den Mongo-Zeitstempel enthält, der das Datum enthält, an dem das Dokument gestorben ist.  Zu diesem Zeitpunkt löscht MongoDB dieses Dokument automatisch. <br><br>  Der TTL-Index ist praktisch, aber <strong>es gibt keine Drosselung in der Implementierung.</strong>  MongoDB ist es egal, wie diese Löschungen entfernt werden.  Wenn Sie versuchen, eine Million Dokumente gleichzeitig zu löschen, haben Sie einige Minuten lang einen nicht funktionsfähigen Cluster, der sich nur mit dem Löschen und nicht mehr befasst.  Um dies zu verhindern, fügen Sie etwas <strong>Zufälligkeit hinzu</strong> , <strong>verbreiten Sie die TTL</strong> so weit, wie es Ihre Geschäftslogik und die Spezialeffekte auf die Latenz zulassen.  Das Verschmieren von TTL ist unerlässlich, wenn Sie natürliche Gründe für die Geschäftslogik haben, die das Löschen zu einem bestimmten Zeitpunkt konzentrieren. <br><br><h2>  Scherben </h2><br>  Wir haben versucht, diesen Moment zu verschieben, aber es ist soweit - wir müssen immer noch horizontal skalieren.  Für MongoDB ist dies eine Scherbe. <br><br><blockquote>  Wenn Sie bezweifeln, dass Sie Scherben benötigen, brauchen Sie diese nicht. </blockquote><br>  Sharding verkompliziert das Leben eines Entwicklers und entwickelt sich auf verschiedene Weise.  In einem Unternehmen nennen wir es Sharding Tax.  Wenn wir eine Sammlung sharden, nimmt die <strong>spezifische Leistung der Sammlung ab</strong> : MongoDB benötigt einen separaten Index für das Sharding, und zusätzliche Parameter müssen an die Anforderung übergeben werden, damit sie effizienter ausgeführt werden kann. <br><br>  Einige Sharding-Dinge funktionieren einfach nicht gut.  Zum Beispiel ist es eine schlechte Idee, Abfragen mit <code>skip</code> , insbesondere wenn Sie viele Dokumente haben.  Sie geben den Befehl: "100.000 Dokumente überspringen." <br><br>  MongoDB denkt so: „Erstens, zweitens, drittens ... einhunderttausendstel, gehen wir weiter.  Und wir werden dies dem Benutzer zurückgeben. “ <br><br>  In einer nicht gemeinsam genutzten Sammlung führt MongoDB eine Operation irgendwo in sich selbst aus.  In Shard-like - sie liest wirklich alle 100.000 Dokumente und sendet sie an einen Sharding-Proxy - in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Mongos</u></a> , die bereits auf ihrer Seite die ersten 100.000 herausfiltern und verwerfen. Eine unangenehme Funktion, die man beachten sollte. <br><br>  <strong>Der Code wird mit dem Sharding sicherlich komplizierter - Sie</strong> müssen den Sharding-Schlüssel an viele Stellen ziehen.  Dies ist nicht immer bequem und nicht immer möglich.  Einige Abfragen werden entweder per Broadcast oder Multicast gesendet, wodurch auch die Skalierbarkeit nicht erhöht wird.  Treffen Sie die Wahl eines Schlüssels, mit dem das Sharding genauer wird. <br><br>  <strong>In Shard-Sammlungen wird die <code>count</code> unterbrochen</strong> .  Sie beginnt mehr als in der Realität eine Zahl zurückzugeben - sie kann zweimal lügen.  Der Grund liegt im Ausgleichsprozess, wenn Dokumente von einem Splitter zum anderen gegossen werden.  Wenn die Dokumente auf den benachbarten Splitter gegossen, aber noch nicht auf dem Original gelöscht wurden, <code>count</code> sie trotzdem gezählt.  MongoDB-Entwickler nennen dies keinen Fehler - es ist eine solche Funktion.  Ich weiß nicht, ob sie das Problem beheben werden oder nicht. <br><br>  <strong>Ein gemischter Cluster ist viel schwieriger zu verwalten</strong> .  Devops werden Sie nicht mehr begrüßen, da das Entfernen eines Backups radikal komplizierter wird.  Beim Sharding blinkt die Notwendigkeit einer Infrastrukturautomatisierung wie ein Feueralarm - etwas, auf das Sie vorher hätten verzichten können. <br><br><h3>  Wie Sharding in MongoDB funktioniert </h3><br>  Es gibt eine Sammlung, wir wollen sie irgendwie um Scherben verteilen.  Zu diesem <strong>Zweck teilt MongoDB die Sammlung</strong> mithilfe des Shard-Schlüssels <strong>in Blöcke</strong> auf und versucht, sie im Shard-Schlüsselbereich in gleiche Teile zu teilen.  Als nächstes kommt der Balancer, der <strong>diese Brocken</strong> sorgfältig <strong>nach den Scherben im Cluster auslegt</strong> .  Darüber hinaus ist es dem Balancer egal, wie viel diese Brocken wiegen und wie viele Dokumente sich darin befinden, da das Balancieren Stück für Stück erfolgt. <br><br><h2>  Sharding Key </h2><br>  Entscheiden Sie immer noch, was Sie scherben möchten?  Nun, die erste Frage ist, wie man einen Sharding-Schlüssel auswählt.  Ein guter Schlüssel hat mehrere Parameter: <strong>hohe Kardinalität</strong> , <strong>Nichtstabilität</strong> und <strong>passt gut zu häufigen Anforderungen</strong> . <br><br>  Die natürliche Wahl eines Sharding-Schlüssels ist der Primärschlüssel - das ID-Feld.  Wenn das ID-Feld zum Sharding geeignet ist, ist es besser, direkt darauf zu sharden.  Dies ist eine ausgezeichnete Wahl - er hat eine gute Kardinalität, er ist nicht stabil, aber wie gut er in häufige Anfragen passt, hängt von Ihrer Geschäftsspezifität ab.  Bauen Sie auf Ihre Situation auf. <br><br>  Ich werde ein Beispiel für einen fehlgeschlagenen Sharding-Schlüssel geben.  Ich habe bereits die Sammlung von Übersetzungen erwähnt - Übersetzungen.  Es hat ein Sprachfeld, in dem die Sprache gespeichert ist.  Zum Beispiel unterstützt die Sammlung 100 Sprachen und wir shard Sprache.  Das ist schlecht - Kardinalität, die Anzahl der möglichen Werte beträgt nur 100 Stück, was klein ist.  Dies ist jedoch nicht das Schlimmste - vielleicht reicht Kardinalität für diese Zwecke aus.  Schlimmer noch, sobald wir uns in der Sprache umgesehen haben, stellen wir sofort fest, dass wir dreimal mehr englischsprachige Benutzer haben als die anderen.  Dreimal so viele Anfragen kommen an die unglückliche Scherbe, in der sich Englisch befindet, als an alle anderen zusammen. <br><br>  Daher sollte berücksichtigt werden, dass ein Splitterschlüssel manchmal natürlich zu einer ungleichmäßigen Lastverteilung neigt. <br><br><h3>  Ausbalancieren </h3><br>  Wir kommen zum Sharding, wenn der Bedarf für uns gereift ist - unser MongoDB-Cluster knarrt, knirscht mit seinen Festplatten, Prozessor - mit allem, was wir können.  Wohin?  Nirgendwo, und wir mischen heldenhaft die Fersen der Sammlungen.  Wir scherben, starten und stellen plötzlich fest, dass das <strong>Balancieren nicht kostenlos ist</strong> . <br><br>  Das Balancieren durchläuft mehrere Phasen.  Der Balancer wählt Brocken und Scherben aus, von wo und wohin er transferiert.  Die weitere Arbeit erfolgt in zwei Phasen: Zuerst werden <strong>Dokumente</strong> von der Quelle zum Ziel <strong>kopiert</strong> und dann <strong>werden kopierte</strong> Dokumente <strong>gelöscht</strong> . <br><br>  Unsere Scherbe ist überladen, sie enthält alle Sammlungen, aber der erste Teil der Operation ist für ihn einfach.  Aber das zweite - das Entfernen - ist ziemlich unangenehm, weil es eine Scherbe auf die Schulterblätter legt und bereits unter Last leidet. <br><br>  Das Problem wird durch die Tatsache verschärft, dass, wenn wir viele Chunks, zum Beispiel Tausende, ausgleichen, mit den Standardeinstellungen alle diese Chunks zuerst kopiert werden und dann ein Entferner hereinkommt und beginnt, sie in großen Mengen zu löschen.  Ab diesem Zeitpunkt ist der Vorgang nicht mehr betroffen und Sie müssen nur noch traurig beobachten, was passiert. <br><br>  Wenn Sie sich einem überlasteten Cluster nähern, müssen Sie daher planen, da das <strong>Ausgleichen Zeit benötigt.</strong>  Es ist ratsam, diese Zeit nicht zur Hauptsendezeit, sondern in Zeiten geringer Last zu nehmen.  Balancer - ein nicht angeschlossenes Ersatzteil.  Sie können sich dem primären Ausgleich im manuellen Modus nähern, den Ausgleich in der Hauptsendezeit ausschalten und ihn einschalten, wenn die Last abgenommen hat, um sich mehr zu erlauben. <br><br>  Wenn Sie mit den Funktionen der Cloud weiterhin vertikal skalieren können, sollten Sie die Shard-Quelle im Voraus verbessern, um all diese Spezialeffekte geringfügig zu reduzieren. <br><br>  <b>Scherben müssen sorgfältig vorbereitet werden.</b> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ Siberia 2019</a> wird am 24. und 25. Juni in Nowosibirsk erscheinen.  HighLoad ++ Sibirien bietet Entwicklern aus Sibirien die Möglichkeit, Berichte anzuhören, über hochgeladene Themen zu sprechen und in die Umgebung einzutauchen, in der "jeder seine eigenen hat", ohne über dreitausend Kilometer nach Moskau oder St. Petersburg zu fliegen.  Von den 80 Anträgen genehmigte das Programmkomitee 25, und wir berichten über alle anderen Änderungen im Programm, Ankündigungen von Berichten und andere Neuigkeiten in unserer Mailingliste.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abonnieren Sie</a> , um auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufenden</a> zu bleiben. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454748/">https://habr.com/ru/post/de454748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454736/index.html">Unterstützung von Visual Studio 2019 in PVS-Studio</a></li>
<li><a href="../de454738/index.html">Visual Studio 2019-Unterstützung in PVS-Studio</a></li>
<li><a href="../de454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../de454742/index.html">Mindestens ein Vim-Trick, von dem Sie nichts wussten</a></li>
<li><a href="../de454744/index.html">Übersicht über Java Track Reports von der RigaDevDays Konferenz</a></li>
<li><a href="../de454750/index.html">Schnelle Benutzeroberfläche - Galoppieren durch Europa</a></li>
<li><a href="../de454754/index.html">Wann lohnt es sich, die Hypothese einer nicht geringeren Wirksamkeit zu überprüfen?</a></li>
<li><a href="../de454756/index.html">Überprüfung der Effektivität der Website und der Werbeeinstellungen sowie der Kosten für die Kundengewinnung des Großhandelsunternehmens</a></li>
<li><a href="../de454758/index.html">Billig und fröhlich mit Windows Defender umgehen: Mimikatz verschleiern</a></li>
<li><a href="../de454760/index.html">Intel Optane Memory M15 - schneller als M10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>