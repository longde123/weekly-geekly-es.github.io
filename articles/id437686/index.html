<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏼 🙆 👩🏽‍🍳 Learning go: menulis messenger p2p dengan enkripsi ujung ke ujung 👩🏼‍🏭 👨🏼‍💻 🦔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Namun P2P Messenger lain 


 Membaca ulasan dan dokumentasi bahasa tidak cukup untuk mempelajari cara menulis aplikasi yang kurang lebih bermanfaat di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning go: menulis messenger p2p dengan enkripsi ujung ke ujung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437686/"><h1 id="yet-another-p2p-messenger">  Namun P2P Messenger lain </h1><br><p>  Membaca ulasan dan dokumentasi bahasa tidak cukup untuk mempelajari cara menulis aplikasi yang kurang lebih bermanfaat di dalamnya. </p><br><p>  Pastikan untuk melakukan konsolidasi, Anda perlu membuat sesuatu yang menarik agar perkembangannya dapat digunakan dalam tugas-tugas lain. </p><br><p><img src="https://habrastorage.org/webt/kt/bm/3r/ktbm3rsivunfcdcvcyqvnm14f5u.png" alt="Contoh UI ReactJs Chat"></p><br><p>  Artikel ini ditujukan untuk pemula yang tertarik dengan jaringan go and peer-to-peer. <br>  Dan untuk para profesional yang dapat menawarkan ide-ide yang masuk akal atau mengkritik secara konstruktif. </p><a name="habracut"></a><br><p>  Saya telah pemrograman untuk beberapa waktu dengan berbagai tingkat pencelupan di java, php, js, python. <br>  Dan setiap bahasa pemrograman bagus di bidangnya. </p><br><p>  Area utama untuk Go adalah penciptaan layanan terdistribusi, layanan microser. <br>  Paling sering, layanan mikro adalah program kecil yang melakukan fungsi yang sangat terspesialisasi. </p><br><p> Tetapi layanan microser masih harus dapat berkomunikasi satu sama lain, sehingga alat untuk membuat layanan microser harus memungkinkan jaringan yang mudah dan tidak menyakitkan. <br>  Untuk menguji ini, kita akan menulis sebuah aplikasi yang mengatur jaringan teman sebaya yang terdesentralisasi (Peer-To-Peer), yang paling sederhana adalah p2p messenger (omong-omong, apakah ada sinonim Rusia untuk kata ini?). </p><br><p>  Dalam kode tersebut, saya secara aktif menciptakan sepeda dan menginjak menyapu untuk merasakan golang, mendapatkan kritik konstruktif dan saran rasional. </p><br><h2 id="chto-delaem">  Apa yang kita lakukan </h2><br><p>  Peer (peer) - contoh unik dari messenger. </p><br><p>  Utusan kami harus dapat: </p><br><ul><li>  Temukan pesta terdekat </li><li>  Menjalin koneksi dengan rekan-rekan lain </li><li>  Enkripsi pertukaran data dengan teman sebaya </li><li>  Terima pesan dari pengguna </li><li>  Tampilkan pesan ke pengguna </li></ul><br><p>  Untuk membuat tugas sedikit lebih menarik, mari kita buat semuanya melalui satu port jaringan. </p><br><p><img src="https://habrastorage.org/webt/5b/zo/8g/5bzo8g4eqogveeure4lzgngo5ma.png" alt="Skema bersyarat dari pembawa pesan"></p><br><p>  Jika Anda menarik port ini melalui HTTP, kami mendapatkan aplikasi Bereaksi yang menarik port yang sama dengan membuat koneksi socket web. </p><br><p>  Jika Anda menarik port melalui HTTP bukan dari mesin lokal, maka kami menunjukkan spanduk. </p><br><p>  Jika peer lain terhubung ke port ini, maka koneksi permanen dibuat dengan enkripsi ujung ke ujung. </p><br><h2 id="opredelyaem-tip-vhodyaschego-soedineniya">  Tentukan jenis koneksi yang masuk </h2><br><p>  Pertama, buka port untuk mendengarkan dan kami akan menunggu koneksi baru. </p><br><pre><code class="go hljs">net.ListenTCP(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, tcpAddr)</code> </pre> <br><p>  Pada koneksi baru, baca 4 byte pertama. </p><br><p>  Kami mengambil daftar kata kerja HTTP dan membandingkan 4 byte kami dengannya. </p><br><p>  Sekarang kami menentukan apakah koneksi dibuat dari mesin lokal, dan jika tidak, kami merespons dengan spanduk dan menutup telepon. </p><br><pre> <code class="go hljs"> buf, err := readWriter.Peek(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItIsHttp(buf) { handleHttp(readWriter, conn, p) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { peer := proto.NewPeer(conn) p.HandleProto(readWriter, peer) } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"127"</span></span>) &amp;&amp; !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"[::"</span></span>) { response.Body = ioutil.NopCloser(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger. see https://github.com/easmith/p2p-messenger"</span></span>)) }</code> </pre> <br><p>  Jika koneksi bersifat lokal, maka kami merespons dengan file yang sesuai dengan permintaan. </p><br><p>  Kemudian saya memutuskan untuk menulis sendiri prosesnya, walaupun saya bisa menggunakan handler yang tersedia di perpustakaan standar. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//   func processRequest(request *http.Request, response *http.Response) {/*    */} //     fileServer := http.FileServer(http.Dir("./front/build/")) fileServer.ServeHTTP(NewMyWriter(conn), request)</span></span></code> </pre> <br><p>  Jika jalur diminta, maka kami mencoba membuat koneksi websocket. </p><br><p>  Karena saya mengumpulkan sepeda dalam memproses permintaan file, saya akan melakukan pemrosesan koneksi ws menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan gorilla / websocket</a> . </p><br><p>  Untuk melakukan ini, buat <code>MyWriter</code> dan terapkan metode di dalamnya untuk berhubungan dengan antarmuka <code>http.ResponseWriter</code> dan <code>http.Hijacker</code> . </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// w - MyWriter func handleWs(w http.ResponseWriter, r *http.Request, p *proto.Proto) { c, err := upgrader.Upgrade(w, r, w.Header()) /*          */ }</span></span></code> </pre> <br><h2 id="obnaruzhenie-pirov">  Deteksi Sebaya </h2><br><p>  Untuk mencari rekan di jaringan lokal, kami akan menggunakan UDP multicast. </p><br><p>  Kami akan mengirimkan paket dengan informasi tentang diri kami ke alamat IP Multicast. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto)</span></span></span></span> { conn, err := net.DialUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := conn.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"meow:%v:%v"</span></span>, hex.EncodeToString(p.PubKey), p.Port))) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br><p>  Dan dengarkan secara terpisah dari Multicast IP untuk semua paket UDP. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto, handler </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, peerAddress </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> conn, err := net.ListenMulticastUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> _, src, err := conn.ReadFromUDP(buffer) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">// connectToPeer handler(p, peerAddress) }</span></span></code> </pre> <br><p>  Dengan demikian, kita mendeklarasikan diri kita sendiri dan belajar tentang penampilan pesta-pesta lainnya. </p><br><p>  Mungkin untuk mengatur ini di tingkat IP, dan bahkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi paket IPv4,</a> hanya paket data multicast yang diberikan sebagai contoh kode. </p><br><h2 id="protokol-vzaimodeystviya-pirov">  Protokol Interaksi Teman </h2><br><p>  Kami akan mengemas semua komunikasi antar rekan dalam amplop (Amplop). </p><br><p>  Pada setiap amplop selalu ada pengirim dan penerima, untuk ini kami akan menambahkan perintah (yang ia bawa bersamanya), pengidentifikasi (sejauh ini adalah nomor acak, tetapi dapat dilakukan sebagai hash konten), panjang isi dan isi amplop itu sendiri - pesan atau parameter perintah. </p><br><p><img src="https://habrastorage.org/webt/3b/yx/yc/3byxycyif222uk2jslbya9qb1bs.png" alt="Byte amplop"></p><br><p>  Perintah, (atau jenis konten) berhasil ditempatkan di bagian paling awal amplop dan kami menetapkan daftar perintah 4 byte yang tidak bersinggungan dengan nama-nama kata kerja HTTP. </p><br><p>  Seluruh amplop selama transmisi serial ke dalam array byte. </p><br><h3 id="rukopozhatie">  Jabat tangan </h3><br><p>  Ketika koneksi dibuat, pesta segera meraih jabat tangan, memberikan namanya, kunci publik dan kunci publik sesaat untuk menghasilkan kunci sesi bersama. </p><br><p>  Sebagai tanggapan, rekan menerima kumpulan data yang serupa, mendaftarkan rekan yang ditemukan dalam daftar dan menghitung (CalcSharedSecret) kunci sesi umum. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handShake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, conn net.Conn)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> peer := proto.NewPeer(conn) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> p.SendName(peer) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> envelope, err := proto.ReadEnvelope(bufio.NewReader(conn)) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3 id="obmen-pirami">  Pertukaran pesta </h3><br><p>  Setelah jabat tangan, rekan-rekan bertukar daftar rekan mereka =) </p><br><p>  Untuk melakukan ini, sebuah amplop dengan perintah LIST dikirim, dan daftar teman sebaya JSON ditempatkan di isinya. <br>  Sebagai tanggapan, kami mendapatkan amplop yang serupa. </p><br><p>  Kami menemukan dalam daftar yang baru dan dengan masing-masing kami mencoba untuk terhubung, berjabat tangan, bertukar pesta dan seterusnya ... </p><br><h3 id="obmen-polzovatelskimi-soobscheniyami">  Olahpesan pengguna </h3><br><p>  Pesan khusus adalah nilai terbesar bagi kami, jadi kami akan mengenkripsi dan menandatangani setiap koneksi. </p><br><h4 id="o-shifrovanii">  Tentang enkripsi </h4><br><p>  Dalam pustaka golang (google) standar dari paket crypto, banyak algoritma yang berbeda diimplementasikan (tidak ada standar GOST). </p><br><p>  Yang paling nyaman untuk tanda tangan saya pikir adalah kurva Ed25519.  Kami akan menggunakan perpustakaan ed25519 untuk menandatangani pesan. </p><br><p>  Pada awalnya, saya berpikir tentang menggunakan pasangan kunci yang diperoleh dari ed25519 tidak hanya untuk penandatanganan, tetapi juga untuk menghasilkan kunci sesi. </p><br><p>  Namun, kunci untuk penandatanganan tidak berlaku untuk menghitung kunci bersama - Anda masih perlu menyulapnya: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateKeyExchangePair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publicKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, privateKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pub, priv, err := ed25519.GenerateKey(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(publicKey[:], pub[:]) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(privateKey[:], priv[:]) curve25519.ScalarBaseMult(&amp;publicKey, &amp;privateKey) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Oleh karena itu, diputuskan untuk menghasilkan kunci sementara, dan secara umum, ini adalah pendekatan yang tepat yang tidak memberikan kesempatan bagi penyerang untuk mengambil kunci bersama. </p><br><p>  Untuk pecinta matematika, berikut adalah tautan wiki: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol <em>Diffie</em> - Hellman_ pada Kurva Elips</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tanda Tangan Digital EdDSA</a> </p><br><p>  Pembuatan kunci bersama cukup standar: pertama, untuk koneksi baru, kami menghasilkan kunci sementara, kami mengirim amplop dengan kunci publik ke soket. </p><br><p>  Sisi yang berlawanan melakukan hal yang sama, tetapi dalam urutan yang berbeda: ia menerima amplop dengan kunci publik, menghasilkan pasangannya sendiri dan mengirimkan kunci publik ke soket. </p><br><p>  Sekarang setiap peserta memiliki kunci singkat publik dan pribadi orang lain. </p><br><p>  Mengalikannya, kita mendapatkan kunci yang sama untuk keduanya, yang akan kita gunakan untuk mengenkripsi pesan. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//CalcSharedSecret Calculate shared secret func CalcSharedSecret(publicKey []byte, privateKey []byte) (secret [32]byte) { var pubKey [32]byte var privKey [32]byte copy(pubKey[:], publicKey[:]) copy(privKey[:], privateKey[:]) curve25519.ScalarMult(&amp;secret, &amp;privKey, &amp;pubKey) return }</span></span></code> </pre> <br><p>  Kami akan mengenkripsi pesan dengan algoritma AES yang telah lama ada dalam mode kopling blok (CBC). </p><br><p>  Semua implementasi ini mudah ditemukan dalam dokumentasi golang. </p><br><p>  Satu-satunya perbaikan adalah pengisian otomatis pesan dengan nol byte untuk banyaknya panjangnya hingga panjang blok enkripsi (16 byte). </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Encrypt the message func Encrypt(content []byte, key []byte) []byte { padding := len(content) % aes.BlockSize if padding != 0 { repeat := bytes.Repeat([]byte("\x00"), aes.BlockSize-(padding)) content = append(content, repeat...) } /* ... */ } //Decrypt encrypted message func Decrypt(encrypted []byte, key []byte) []byte { /* ... */ encrypted = bytes.Trim(encrypted, string([]byte("\x00"))) return encrypted }</span></span></code> </pre> <br><p>  Kembali pada tahun 2013, ia menerapkan AES (dengan mode yang mirip dengan CBC) untuk mengenkripsi pesan di Telegram sebagai bagian dari kontes dari Pavel Durov. </p><br><p>  Pada saat itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol Diffie-Hellman yang</a> paling umum digunakan dalam telegram untuk menghasilkan kunci fana. </p><br><p>  Dan untuk mengecualikan beban dari koneksi palsu, sebelum setiap pertukaran kunci, klien memecahkan masalah faktorisasi. </p><br><h2 id="gui">  GUI </h2><br><p>  Kita perlu menunjukkan daftar teman dan daftar pesan dengannya, dan juga menanggapi pesan baru dengan menambah penghitung di sebelah nama rekan. </p><br><p>  Di sini tanpa masalah - ReactJS + websocket. </p><br><p>  Pesan soket web pada dasarnya adalah amplop unik, hanya saja tidak mengandung cipherteks. </p><br><p>  Semua dari mereka adalah "ahli waris" dari tipe <code>WsCmd</code> dan diserialisasi dalam JSON pada saat transfer. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Serializable interface to detect that can to serialised to json type Serializable interface { ToJson() []byte } func toJson(v interface{}) []byte { json, err := json.Marshal(v) /*  err */ return json } /* ... */ //WsCmd WebSocket command type WsCmd struct { Cmd string `json:"cmd"` } //WsMessage WebSocket command: new Message type WsMessage struct { WsCmd From string `json:"from"` To string `json:"to"` Content string `json:"content"` } //ToJson convert to JSON bytes func (v WsMessage) ToJson() []byte { return toJson(v) } /* ... */</span></span></code> </pre> <br><p>  Jadi, permintaan HTTP datang ke root ("/"), sekarang untuk menampilkan bagian depan, lihat di direktori "front / build" dan berikan index.html </p><br><p>  Nah antarmuka dibuat, sekarang pilihan untuk pengguna adalah: jalankan di browser atau di jendela yang terpisah - WebView. </p><br><p>  Untuk opsi terakhir digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zserge / webview</a> </p><br><pre> <code class="go hljs"> e := webview.Open(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger"</span></span>, fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:%v"</span></span>, initParams.Port), <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  Untuk membangun aplikasi dengannya, Anda perlu menginstal sistem lain </p><br><pre> <code class="bash hljs"> sudo apt install libwebkit2gtk-4.0-dev</code> </pre> <br><p>  Dalam proses berpikir tentang GUI, saya menemukan banyak perpustakaan untuk GTK, QT, dan antarmuka konsol akan terlihat sangat culun - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/jroimartin/gocui</a> - menurut saya ide yang sangat menarik. </p><br><h2 id="zapusk-messendzhera">  Peluncuran Messenger </h2><br><h3 id="ustanovka-golang">  Instalasi golang </h3><br><p>  Tentu saja, Anda harus menginstal go terlebih dahulu. <br>  Untuk melakukan ini, saya sangat merekomendasikan menggunakan instruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang.org/doc/install</a> . </p><br><p>  Instruksi sederhana untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bash script</a> </p><br><h3 id="zagruzka-prilozheniya-v-gopath">  Unduh aplikasi di GOPATH </h3><br><p>  Sudah diatur sedemikian rupa sehingga semua perpustakaan dan bahkan proyek Anda harus dalam apa yang disebut GOPATH. </p><br><p>  Secara default, ini adalah $ HOME / go.  Go memungkinkan Anda untuk menarik sumber dari repositori publik dengan perintah sederhana: </p><br><pre> <code class="bash hljs"> go get github.com/easmith/p2p-messenger</code> </pre> <br><p>  Sekarang, di <code>$HOME/go/src/github.com/easmith/p2p-messenger</code> sumber dari cabang master akan muncul </p><br><h3 id="ustanovka-npm-i-sborka-fronta">  Instalasi NPM dan perakitan depan </h3><br><p>  Seperti yang saya tulis di atas, GUI kami adalah aplikasi web dengan front di ReactJs, jadi front masih perlu dirakit. </p><br><p>  Nodejs + npm - di sini seperti biasa. </p><br><p>  Untuk jaga-jaga, berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi untuk ubuntu</a> </p><br><p>  Sekarang kita mulai perakitan depan sebagai standar </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> front npm update npm run build</code> </pre> <br><p>  Bagian depan siap! </p><br><h3 id="zapusk">  Luncurkan </h3><br><p>  Mari kita kembali ke root dan meluncurkan pesta utusan kita. </p><br><p>  Saat memulai, kita dapat menentukan nama rekan, port, file dengan alamat rekan-rekan lain dan bendera yang menunjukkan apakah akan meluncurkan WebView. </p><br><p>  Secara default, <code>$USER@$HOSTNAME</code> digunakan sebagai nama <code>$USER@$HOSTNAME</code> dan port 35035. </p><br><p>  Jadi, kami memulai dan mengobrol dengan teman-teman di jaringan lokal. </p><br><pre> <code class="bash hljs"> go run app.go -name Snowden</code> </pre> <br><h2 id="otzyv-o-programmirovanii-na-golang">  Umpan balik tentang pemrograman golang </h2><br><ul><li>  Hal yang paling penting yang ingin saya catat: <strong>on go, ternyata segera mengimplementasikan apa yang saya maksudkan</strong> . <br>  Hampir semua yang Anda butuhkan ada di perpustakaan standar. </li><li>  Namun, ada kesulitan ketika saya memulai proyek di direktori selain GOPATH. <br>  Saya menggunakan GoLand untuk menulis kode.  Dan pada awalnya memalukan untuk memformat kode secara otomatis dengan pustaka impor-otomatis. </li><li>  Ada <strong>banyak generator kode</strong> di <strong>IDE</strong> , yang memungkinkan kami untuk fokus pada pengembangan daripada pada kumpulan kode. </li><li>  Anda dengan cepat <strong>terbiasa</strong> dengan penanganan kesalahan yang sering, tetapi wajah-tangan terjadi ketika Anda menyadari bahwa untuk pergi situasi yang normal adalah ketika esensi kesalahan dianalisis menurut perwakilan stringnya. <br><pre> <code class="go hljs">err != io.EOF</code> </pre> </li><li>  Hal-hal sedikit lebih baik dengan perpustakaan os.  Konstruksi semacam itu membantu memahami esensi masalah. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> </li><li>  Di luar kotak, pergilah ajari kami untuk mendokumentasikan kode dan menulis tes dengan benar. <br>  Dan ada beberapa tapi.  Kami telah menggambarkan antarmuka dengan metode <code>ToJson()</code> . <br>  Jadi, pembuat dokumentasi tidak mewarisi deskripsi metode ini ke metode yang mengimplementasikannya, jadi untuk menghapus peringatan yang tidak perlu, Anda harus menyalin dokumentasi ke setiap metode yang diterapkan (proto / mtypes.go). </li><li>  Baru-baru ini saya terbiasa dengan kekuatan log4j di java, jadi tidak ada cukup logger yang baik di mana saja. <br>  Mungkin layak melihat luasnya github logging yang indah dengan appenders dan formatters. </li><li>  Pekerjaan yang tidak biasa dengan array. <br>  Misalnya, rangkaian terjadi melalui fungsi <code>append</code> , dan konversi array dengan panjang sewenang-wenang menjadi array dengan panjang tetap melalui <code>copy</code> . </li><li>  <code>switch-case</code> berfungsi seperti <code>if-elseif-else</code> - tetapi ini adalah pendekatan yang menarik, tetapi sekali lagi dengan wajah: <br>  jika kita menginginkan perilaku <code>switch-case</code> biasa, kita perlu membuat <code>fallthrough</code> pada setiap case. <br>  Anda juga bisa menggunakan <code>goto</code> , tapi jangan, tolong! </li><li>  Tidak ada operator ternary dan seringkali ini tidak nyaman. </li></ul><br><h2 id="chto-dalshe">  Apa selanjutnya </h2><br><p>  Jadi messenger Peer-To-Peer yang paling sederhana diterapkan. </p><br><p>  Kerucut dijejalkan, lebih jauh Anda dapat meningkatkan fungsionalitas pengguna: mengirim file, gambar, audio, emotikon, dll., Dll. </p><br><p>  Dan Anda tidak dapat menemukan protokol Anda, dan menggunakan Bufer Protokol Google, <br>  Hubungkan blockchain dan lindungi diri Anda dari spam menggunakan kontrak pintar Ethereum. </p><br><p>  Pada kontrak pintar, atur obrolan grup, saluran, sistem nama, avatar, dan profil pengguna. </p><br><p>  Sangat penting untuk menjalankan seed peer, mengimplementasikan bypass NAT, dan mengirim pesan dari peer to peer. </p><br><p>  Akibatnya, Anda mendapatkan telegram / telepon pengganti yang baik, Anda hanya perlu mentransfer semua teman Anda di sana =) </p><br><h2 id="poleznosti">  Kegunaan </h2><br><div class="spoiler">  <b class="spoiler_title">Beberapa tautan</b> <div class="spoiler_text"><p>  Dalam proses pengerjaan messenger, saya menemukan halaman yang menarik untuk pengembang pemula. <br>  Saya membaginya dengan Anda: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang.org/doc/</a> - dokumentasi bahasa, semuanya sederhana, jelas dan dengan contoh.  Dokumentasi yang sama dapat dijalankan secara lokal dengan perintah </p><br><pre> <code class="bash hljs">godoc -HTTP=:6060</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gobyexample.com</a> - kumpulan contoh sederhana </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang-book.ru</a> - buku bagus dalam bahasa Rusia </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/dariubs/GoBooks</a> adalah kumpulan buku tentang Go. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awesome-go.com</a> - Daftar pustaka, kerangka kerja dan aplikasi menarik saat bepergian.  Kategorisasi lebih atau kurang, tetapi deskripsi banyak dari mereka sangat langka, yang tidak membantu pencarian dengan Ctrl + F </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437686/">https://habr.com/ru/post/id437686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437674/index.html">Metode pengenalan objek 3D untuk kendaraan tak berawak. Laporan Yandex</a></li>
<li><a href="../id437676/index.html">Universitas dan Akselerator Perusahaan sebagai Pengungkit untuk Meluncurkan Startup B2B di AS</a></li>
<li><a href="../id437680/index.html">Koleksi DIY saya di Youtube</a></li>
<li><a href="../id437682/index.html">Menulis alat templating Kubernet lain</a></li>
<li><a href="../id437684/index.html">Algoritma Tertinggi - Kompendium Bias</a></li>
<li><a href="../id437688/index.html">OpenSceneGraph: Teknik Pemrograman Dasar</a></li>
<li><a href="../id437694/index.html">Analisis utilitas Files.walkFileTree ();</a></li>
<li><a href="../id437696/index.html">Intisari materi menarik untuk pengembang seluler # 283 (pada 21 - 27 Januari)</a></li>
<li><a href="../id437698/index.html">Layanan terjemahan paten WIPO Translate - pengalaman saya</a></li>
<li><a href="../id437702/index.html">Parsing Wawancara Kerja Google: Pertanyaan Sinonim</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>