<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ†Ô∏è üíé üåï Estamos implementando OSGI en la plataforma Karaf üë§ üçÜ üë®üèæ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OSGI no es dif√≠cil 
 Me he encontrado muchas veces que OSGI es dif√≠cil. Y adem√°s, √©l mismo tuvo una vez esa opini√≥n. A√±o en 2009, para ser exactos. En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos implementando OSGI en la plataforma Karaf</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435444/"><h2>  OSGI no es dif√≠cil </h2><br>  Me he encontrado muchas veces que OSGI es dif√≠cil.  Y adem√°s, √©l mismo tuvo una vez esa opini√≥n.  A√±o en 2009, para ser exactos.  En ese momento, recopilamos proyectos utilizando Maven Tycho y los implementamos en Equinox.  Y realmente fue m√°s dif√≠cil que desarrollar y ensamblar proyectos para JavaEE (en ese momento apareci√≥ la versi√≥n de EJB 3, a la que cambiamos).  Equinox era mucho menos conveniente que Weblogic, por ejemplo, y los beneficios de OSGI no eran obvios para m√≠ en ese momento. <br><br>  Pero luego, despu√©s de muchos a√±os, tuve que comenzar un proyecto en un nuevo trabajo, que fue concebido sobre la base de Apache Camel y Apache Karaf.  Esta no fue mi idea, conoc√≠a a Camel por mucho tiempo y decid√≠ leer sobre Karaf, incluso sin una oferta.  Lo le√≠ una noche y me di cuenta: aqu√≠ est√°, simple y listo, casi la misma soluci√≥n para algunos problemas de un JavaEE t√≠pico, similar al que hice una vez sobre mis rodillas usando Weblogic WLST, Jython y Maven Aether. <br><br>  Entonces, digamos que decides probar OSGI en la plataforma Karaf.  Por donde empezamos <br><a name="habracut"></a><br><h3>  Si quieres una comprensi√≥n m√°s profunda </h3><br>  Por supuesto, puede comenzar leyendo la documentaci√≥n.  Y es posible con Habr√©: hubo muy buenos art√≠culos aqu√≠, digamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hace</a> mucho tiempo.  Pero en general, karaf recibi√≥ hasta ahora poca atenci√≥n inmerecida.  Hubo un par de cr√≠ticas m√°s sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esto</a> .  Es mejor omitir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> menci√≥n de karaf.  Como dicen, no lean los peri√≥dicos sovi√©ticos por la noche ... porque all√≠ les dir√°n que karaf es un marco OSGI, por lo que no lo creen.  Los marcos OSGI son Apache Felix o Eclipse Equinox, sobre la base de los cuales karaf simplemente funciona.  Puedes elegir cualquiera de ellos. <br><br>  Cabe se√±alar que cuando se menciona Jboss Fuse o Apache ServiceMix, debe leerse como "Karaf, con componentes preinstalados", es decir  de hecho, lo mismo, solo recolectado por el vendedor.  No recomendar√≠a comenzar con esto en la pr√°ctica, pero es bastante posible leer art√≠culos de revisi√≥n sobre ServiceMix, por ejemplo. <br><br>  Para comenzar, intentar√© determinar aqu√≠ muy brevemente qu√© es OSGI y para qu√© se puede utilizar. <br><br>  En general, OSGI es una herramienta para crear aplicaciones Java a partir de m√≥dulos.  Se puede considerar un an√°logo cercano, por ejemplo, JavaEE, y hasta cierto punto los contenedores OSGI pueden ejecutar m√≥dulos JavaEE (por ejemplo, aplicaciones web en forma de guerra), y por otro lado, muchos contenedores JavaEE contienen OSGI en su interior como un medio para implementar modularidad "por s√≠ mismos ".  Es decir, JavaEE y OSGI son cosas similares a la compatibilidad, y exitosamente complementarias. <br><br>  Una parte importante de cualquier sistema modular es la definici√≥n del m√≥dulo en s√≠.  En el caso de OSGI, el m√≥dulo se llama paquete y es un archivo jar conocido por todos los desarrolladores con algunas adiciones (es decir, aqu√≠ es muy similar, por ejemplo, a war u ear).  Por analog√≠a con JavaEE, los paquetes pueden exportar e importar servicios, que son esencialmente m√©todos de clase (es decir, un servicio es una interfaz o todos los m√©todos p√∫blicos de una clase). <br><br>  Los metadatos del paquete son familiares para todos los META-INF / MANIFEST.MF.  Los encabezados del manifiesto OSGI no se cruzan con los encabezados para el JRE, respectivamente, fuera del paquete contenedor OSGI hay un contenedor normal.  Es significativo que entre los metadatos siempre haya: <br><br><pre><code class="plaintext hljs">Bundle-SymbolicName: com.example.myosgi Bundle-Version: 1.0.0</code> </pre> <br>  Estas son las "coordenadas" del paquete y es importante el hecho de que podamos tener dos o m√°s versiones instaladas simult√°neamente y funcionando del mismo paquete en un contenedor. <br><br>  Similar a JavaEE, los paquetes tienen un ciclo de vida similar al siguiente: <img src="https://habrastorage.org/getpro/habr/post_images/b71/a55/263/b71a5526390ea0fd4eaf02a3d5edc67a.png" alt="imagen">  Adem√°s de los servicios, los paquetes tambi√©n pueden importar y exportar paquetes (paquetes, en el sentido habitual del t√©rmino para java).  Los paquetes exportados se definen dentro del paquete y est√°n disponibles para otros componentes cuando el paquete se instala en el sistema.  Los importados se definen en alg√∫n lugar desde afuera, deben ser exportados por alguien y el contenedor los debe proporcionar al paquete antes de que pueda comenzar a funcionar. <br><br>  Las importaciones de paquetes pueden declararse opcionales, as√≠ como las importaciones de servicios.  Y es bastante significativo que la importaci√≥n y exportaci√≥n contenga una indicaci√≥n de la versi√≥n (o rango de versiones). <br><br><h4>  Diferencias de JavaEE </h4><br>  Bueno, es bueno que sean iguales, lo entendimos.  ¬øY en qu√© se diferencian? <br><br>  En mi opini√≥n, la principal diferencia es que OSGI nos da mucha m√°s flexibilidad.  Una vez que el paquete est√° en estado INICIADO, las posibilidades est√°n limitadas solo por su imaginaci√≥n.  Supongamos que puede crear f√°cilmente subprocesos (s√≠, s√≠, s√© sobre ManagedExecutorService), grupos de conexi√≥n a bases de datos, etc.  Un contenedor no toma el control de todos los recursos en la misma medida que JavaEE. <br><br>  Puede exportar nuevos servicios en el proceso.  ¬øIntenta decir en JavaEE crear din√°micamente un nuevo servlet?  Y aqu√≠ es bastante posible, adem√°s, el servlet contenedor creado por el embarcadero karaf ser√° detectado inmediatamente por su servlet creado y estar√° disponible para los clientes en una URL espec√≠fica. <br><br>  Aunque esto es una ligera simplificaci√≥n, pero si la aplicaci√≥n JavaEE en su forma cl√°sica consta principalmente de componentes: <br><br><ul><li>  pasivo, esperando una llamada del cliente </li><li>  definido est√°ticamente, es decir, en el momento del despliegue de la aplicaci√≥n. </li></ul><br>  Por otro lado, una aplicaci√≥n basada en OSGI puede contener: <br><br><ul><li>  componentes programados activos y pasivos, realizar encuestas, bueno, escuchar un socket, etc. </li><li>  los servicios se pueden definir y publicar din√°micamente </li><li>  Puede suscribirse a eventos marco, por ejemplo, escuchar el registro de servicios, paquetes, etc., recibir enlaces a otros paquetes y servicios, y hacer mucho m√°s. </li></ul><br>  S√≠, en JavaEE, gran parte de esto tambi√©n es parcialmente posible (por ejemplo, a trav√©s de JNDI), pero en el caso de OSGI, en la pr√°ctica se hace m√°s f√°cil.  Aunque probablemente haya algunos riesgos m√°s aqu√≠. <br><br><h4>  Diferencias entre karaf y OSGI puro </h4><br>  Adem√°s del marco karaf, hay muchas cosas √∫tiles.  En esencia, karaf es una herramienta para administrar convenientemente el marco OSGI: instalar paquetes (incluidos grupos) all√≠, configurarlos, monitorear, describir el modelo a seguir y garantizar la seguridad, y similares. <br><br><h2>  ¬øY practiquemos ya? </h2><br>  Bueno, entonces, comencemos de inmediato con la instalaci√≥n.  No hay mucho que escribir aqu√≠: vaya a karaf.apache.org, descargue el paquete de distribuci√≥n, descompr√≠malo.  Las versiones de karaf difieren en el soporte de diferentes especificaciones OSGI (4, 5 o 6) y versiones de Java.  No recomiendo la familia 2.x, pero aqu√≠ hay 3 (si tiene Java 8, como la m√≠a), y se puede usar 4, aunque hoy solo se est√° desarrollando la familia 4.x (versi√≥n actual 4.2.2, es compatible con OSGI 6 y Java hasta 10). <br><br>  Karaf funciona bien en Windows y Linux, todo lo que necesita para crear un servicio y ejecuci√≥n autom√°tica est√° disponible.  Tambi√©n se declara la compatibilidad con MacOS y muchos otros tipos de Unix. <br><br>  Por lo general, puede iniciar karaf de inmediato si est√° en Internet.  Si no es as√≠, generalmente vale la pena arreglar el archivo de configuraci√≥n, indicando d√≥nde tiene repositorios maven.  Por lo general, ser√° un Nexus corporativo, o digamos Artifactory, a quien le guste qu√©.  La configuraci√≥n de karaf se encuentra en la carpeta etc. de la distribuci√≥n.  Los nombres de los archivos de configuraci√≥n no son muy obvios, pero en este caso necesita el archivo org.ops4j.pax.url.mvn.cfg.  El formato de este archivo es propiedades java. <br><br>  Puede especificar el (los) repositorio (s) en el archivo de configuraci√≥n en s√≠, enumerando la lista de URL en la configuraci√≥n o simplemente mostrando d√≥nde se encuentra su settings.xml.  All√≠, el karaf tomar√° la ubicaci√≥n de su proxy, que generalmente es necesario saber en la intranet. <br><br>  Kafar necesita varios puertos, estos son HTTP, HTTPS (si la web est√° configurada, por defecto no), SSH, RMI, JMX.  Si est√°n ocupados con usted o si desea ejecutar varias copias en el mismo host, tambi√©n deber√° cambiarlas.  Hay aproximadamente cinco de estos puertos. <br><br>  Puertos como jmx y rmi - aqu√≠: org.apache.karaf.management.cfg, ssh - org.apache.karaf.shell.cfg, para cambiar los puertos http / https, deber√° crear (probablemente no) el archivo etc / org.ops4j.pax.web.cfg, y escriba el valor org.osgi.service.http.port = port que necesita en √©l. <br><br>  Entonces definitivamente puedes iniciarlo, y como regla, todo comenzar√°.  Para uso industrial, obviamente, deber√° realizar cambios en el archivo bin / setenv o bin / setenv.bat, por ejemplo, para asignar la cantidad de memoria requerida, pero primero, para ver, no es necesario. <br><br>  Puede iniciar Karaf de inmediato con la consola, el comando karaf, o puede ejecutarlo en segundo plano con el comando de inicio del servidor y luego conectarse a √©l a trav√©s de SSH.  Este es un SSH completamente est√°ndar, con soporte para SCP y SFTP.  Puede ejecutar comandos y copiar archivos de un lado a otro.  Es posible conectarse con cualquier cliente, por ejemplo, mi herramienta favorita es Far NetBox.  El inicio de sesi√≥n est√° disponible mediante inicio de sesi√≥n y contrase√±a, as√≠ como mediante claves.  En menudillos jsch, con todo lo que implica. <br><br>  Recomiendo tener una ventana de consola adicional de inmediato para ver los registros que se encuentran en data / log / karaf.log (y otros archivos generalmente est√°n all√≠, aunque esto es personalizable).  Los registros son √∫tiles para usted, desde mensajes cortos en la consola, no todo est√° claro. <br><br>  Aconsejar√≠a instalar la web inmediatamente y la consola web hawtio.  Estas dos cosas har√°n que sea mucho m√°s f√°cil para usted navegar lo que est√° sucediendo en el contenedor y dirigir el proceso desde all√≠ en gran medida (como beneficio adicional, obtendr√° jolokia y la capacidad de monitorear a trav√©s de http).  La instalaci√≥n de hawtio se realiza mediante dos comandos desde la consola karaf ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como se describe aqu√≠</a> ), y lamentablemente, hoy la versi√≥n de karaf 3.x ya no es compatible (tendr√° que buscar versiones anteriores de hawtio). <br><br>  Fuera de la caja, https no ser√° inmediato, para esto debe hacer algunos esfuerzos, como generar certificados, etc. La implementaci√≥n se basa en el embarcadero, por lo que todos estos esfuerzos se realizan principalmente de la misma manera. <br><br><h2>  OK, comenz√≥, ¬øqu√© sigue? </h2><br><img src="https://habrastorage.org/webt/lh/ty/ge/lhtygefalzjfywb-3lr088qvrha.png"><br><br>  En realidad, ¬øqu√© esperabas?  Dije que ser√° ssh.  Tab funciona, si eso. <br><br>  Es hora de instalar alguna aplicaci√≥n.  Una aplicaci√≥n para OSGI es un paquete o consta de varios paquetes.  Karaf puede implementar aplicaciones en varios formatos: <br><br><ul><li>  Un paquete jar, con o sin un manifiesto OSGI </li><li>  xml que contiene Spring DM o Blueprint </li><li>  XML que contiene la denominada caracter√≠stica, que es una colecci√≥n de paquetes, otras caracter√≠sticas y recursos (archivos de configuraci√≥n) </li><li>  Archivo .kar que contiene varias caracter√≠sticas y un repositorio maven con dependencias </li><li>  Aplicaciones JavaEE (bajo algunas condiciones adicionales), por ejemplo .war </li></ul><br>  Hay varias formas de hacer esto: <br><br><ul><li>  poner la aplicaci√≥n en la carpeta de implementaci√≥n </li><li>  instalar desde la consola con el comando de instalaci√≥n </li><li>  instale la funci√≥n con el comando de la funci√≥n: instalar la consola </li><li>  kar: instalar </li></ul><br>  Bueno, en general, esto es bastante similar a lo que puede hacer un contenedor JavaEE t√≠pico, pero es algo m√°s conveniente (yo dir√≠a que es mucho m√°s conveniente). <br><br><h3>  Tarro simple </h3><br>  La opci√≥n m√°s f√°cil es instalar un jar regular.  Si lo tiene en el repositorio maven, entonces el comando es suficiente para instalar: <br><br><pre> <code class="bash hljs">install mvn:groupId/artifactId/version</code> </pre> <br>  Al mismo tiempo, Karaf se da cuenta de que tiene un frasco regular frente a √©l y lo procesa, creando un envoltorio de paquete sobre la marcha, el llamado  wrapper, que genera un manifiesto predeterminado, con las importaciones y exportaciones de paquetes. <br><br>  La sensaci√≥n de instalar solo un jar generalmente no es mucha, ya que este paquete ser√° pasivo: solo exporta clases que estar√°n disponibles para otros paquetes. <br><br>  Este m√©todo se utiliza para instalar componentes como Apache Commons Lang, por ejemplo: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons.lang3/commons-lang/3.8.1</code> </pre> <br>  Pero no funcion√≥ :) Estas son las coordenadas correctas: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons/commons-lang3/3.8.1</code> </pre> <br>  Veamos qu√© sucedi√≥: list -u nos mostrar√° los paquetes y sus fuentes: <br><br><pre> <code class="bash hljs">karaf@root()&gt; list -u START LEVEL 100 , List Threshold: 50 ID | State | Lvl | Version | Name | Update location ------------------------------------------------------------------------------------------------- 87 | Installed | 80 | 3.8.1 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.8.1 88 | Installed | 80 | 3.6.0 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.6</code> </pre> <br>  Como puede ver, es bastante posible instalar dos versiones de un componente.  Ubicaci√≥n de actualizaci√≥n: aqu√≠ es donde obtuvimos el paquete y donde se puede actualizar si es necesario. <br><br><h3>  Contexto Jar y Spring </h3><br>  Si hay un contexto de primavera dentro de su frasco, las cosas se ponen m√°s interesantes.  Karaf Deployer busca autom√°ticamente contextos xml en la carpeta META-INF / spring, y los crea si todos los paquetes externos necesarios para el paquete se han encontrado con √©xito. <br><br>  Por lo tanto, todos los servicios que estaban dentro de los contextos ya comenzar√°n.  Si ten√≠a Camel Spring all√≠, por ejemplo, las rutas Camel tambi√©n comenzar√°n.  Esto significa que decimos que un servicio REST, o un servicio que escucha en un puerto TCP, ya puede comenzar.  Por supuesto, el lanzamiento de varios servicios de escucha en un puerto no funcionar√° de esa manera. <br><br><h3>  Just Spring contexto XML </h3><br>  Si ten√≠a, por ejemplo, definiciones de JDBC DataSources dentro de Spring Context, puede instalarlas por separado en Karaf.  Es decir  tome un archivo xml que contenga solo un DataSource en forma de &lt;bean&gt;, o cualquier otro conjunto de componentes, puede colocarlo en la carpeta de implementaci√≥n.  El contexto se lanzar√° de la manera est√°ndar.  El √∫nico problema es que los DataSources creados de esta manera no ser√°n visibles para otros paquetes.  Deben exportarse a OSGI como servicios.  Sobre esto, un poco m√°s tarde. <br><br><h3>  Primavera dm </h3><br>  ¬øCu√°l es la diferencia entre Spring DM (versi√≥n habilitada para OSGI) y el cl√°sico Spring?  Entonces, en el caso cl√°sico, todos los beans en el contexto se crean en la etapa de inicializaci√≥n del contexto.  Los nuevos no pueden aparecer, los viejos no ir√°n a ninguna parte.  En el caso de OSGI, se pueden instalar nuevos paquetes y eliminar paquetes viejos.  El entorno se est√° volviendo m√°s din√°mico, debe responder de alguna manera. <br><br>  El m√©todo de respuesta se llama servicios.  Un servicio suele ser una interfaz determinada, con sus propios m√©todos, que es publicada por alg√∫n paquete.  Un servicio tiene metadatos que permiten buscarlo y distinguirlo de otro servicio que implementa una interfaz similar (obviamente, de otro DataSource).  Los metadatos son un conjunto simple de propiedades clave-valor. <br><br>  Dado que los servicios pueden aparecer y desaparecer, aquellos que los necesitan pueden suscribirse a los servicios al inicio o escuchar eventos para conocer su aparici√≥n o desaparici√≥n.  En el nivel Spring DM, en XML, esto se implementa como dos elementos, servicio y referencia, cuyo prop√≥sito b√°sico es bastante simple: publicar el bean existente desde el contexto como un servicio, y suscribirse a un servicio externo al publicarlo en el contexto actual de Spring. <br><br>  En consecuencia, al inicializar dicho paquete, el contenedor encontrar√° los servicios externos que necesita y publicar√° los paquetes implementados dentro de √©l, haci√©ndolos accesibles desde el exterior.  Un paquete comienza solo despu√©s de que se resuelven los enlaces de servicio. <br><br>  De hecho, todo es un poco m√°s complicado, porque el paquete puede usar una lista de servicios similares y suscribirse de inmediato a la lista.  Es decir  un servicio, en general, tiene una propiedad como cardinalidad, que toma el valor 0..N.  En este caso, la suscripci√≥n, donde se indica 0..1, describe un servicio opcional, y en este caso el paquete se inicia con √©xito incluso si no hay tal servicio en el sistema (y en lugar de un enlace, obtendr√° un c√≥digo auxiliar). <br><br>  Observo que un servicio es solo cualquier interfaz (o puede publicar solo clases), por lo que puede publicar java.util.Map con datos como servicio. <br><br>  Entre otras cosas, el servicio le permite especificar metadatos, y la referencia le permite buscar un servicio por estos metadatos. <br><br><h3>  Anteproyecto </h3><br>  Blueprint es la nueva encarnaci√≥n de Spring DM, que es un poco m√°s simple.  Es decir, si en Spring tiene elementos XML personalizados, entonces no est√°n aqu√≠, por innecesarios.  A veces esto todav√≠a causa inconvenientes, pero, francamente, con poca frecuencia.  Si no est√° migrando un proyecto desde Spring, puede comenzar de inmediato con Blueprint. <br><br>  La esencia aqu√≠ es la misma: es XML, que describe los componentes a partir de los cuales se ensambla el contexto del paquete.  Para aquellos que conocen Spring, no hay nada desconocido en absoluto. <br><br>  Aqu√≠ hay un ejemplo de c√≥mo describir un DataSource y exportarlo como un servicio: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.osgi.org/xmlns/blueprint/v1.0.0"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"oracle.jdbc.pool.OracleDataSource"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"USER"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PASSWORD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ds"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"osgi.jndi.service.name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/ds"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Bueno, implementamos este archivo en la carpeta de implementaci√≥n y observamos los resultados del comando de lista.  Vieron que el paquete no comenz√≥, en el estado Instalado.  Intentamos iniciar y recibimos un mensaje de error. <br><br>  Ahora en la lista de paquetes en el estado Error.  Que pasa  Obviamente, tambi√©n necesita dependencias, en este caso, un Jar con clases JDBC de Oracle, o m√°s precisamente, el paquete oracle.jdbc.pool. <br>  Encontramos el jar necesario en el repositorio, o lo descargamos del sitio de Oracle, y lo instalamos, como se describi√≥ anteriormente.  Nuestro DataSource ha comenzado. <br><br>  ¬øC√≥mo usar todo esto?  El enlace de servicio se llama en la referencia Blueprint (en alg√∫n lugar, en el contexto de otro paquete): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Luego, este bean se convierte, como de costumbre, en una dependencia para otros beans (en el ejemplo camel-sql): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.component.sql.SqlComponent"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Jarra y Activador </h3><br>  La forma can√≥nica de inicializar paquetes es usar una clase que implemente la interfaz Activador.  Esta es una interfaz t√≠pica de ciclo de vida que contiene m√©todos de inicio y detenci√≥n que pasan el <i>contexto</i> .  Dentro de ellos, el paquete generalmente inicia sus hilos, si es necesario, comienza a escuchar puertos, se suscribe a servicios externos utilizando la API OSGI, y as√≠ sucesivamente.  Esta es quiz√°s la forma m√°s compleja, m√°s b√°sica y m√°s flexible.  Durante tres a√±os nunca lo he necesitado. <br><br><h2>  Configuraciones y configuraci√≥n </h2><br>  Est√° claro que tal configuraci√≥n de DataSource, como se muestra en el ejemplo, pocas personas necesitan.  Inicio de sesi√≥n, contrase√±a y m√°s, todo est√° codificado en XML.  Es necesario eliminar estos par√°metros. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.url}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.user}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.password}"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  La soluci√≥n es bastante simple y similar a la utilizada en el cl√°sico Spring: en cierto punto del ciclo de vida del contexto, los valores de propiedad se sustituyen de varias fuentes. <br><br>  Con esto terminaremos la primera parte.  Si hay inter√©s en este tema, entonces continuar√°.  Consideraremos c√≥mo ensamblar aplicaciones a partir de paquetes, configurar, monitorear e implementar sistemas autom√°ticamente en esta plataforma. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435444/">https://habr.com/ru/post/es435444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435430/index.html">Las mejores noticias CES 2019</a></li>
<li><a href="../es435432/index.html">A√±o nuevo, GitHub nuevo: repositorios privados gratuitos ilimitados</a></li>
<li><a href="../es435436/index.html">5 tendencias en infraestructura de TI: pron√≥stico para 2019</a></li>
<li><a href="../es435438/index.html">PHP: estructura de base de datos cambiante en el desarrollo de equipos</a></li>
<li><a href="../es435442/index.html">Embudo de cambio</a></li>
<li><a href="../es435446/index.html">Algoritmo de Verhuff para un sistema arbitrario de n√∫meros pares</a></li>
<li><a href="../es435448/index.html">Sobre la experiencia de comunicarse con un generador de se√±al a trav√©s de QTcpSocket y SCPI</a></li>
<li><a href="../es435450/index.html">Feliz a√±o nuevo, feliz nuevo MQTT / UDP</a></li>
<li><a href="../es435452/index.html">Prueba de extremo a extremo de microservicios con Catcher</a></li>
<li><a href="../es435454/index.html">AOP vs Caracter√≠sticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>