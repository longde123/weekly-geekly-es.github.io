<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”š â„ï¸ ğŸ‘§ğŸ¿ Arend - bahasa tipe dependen berbasis HoTT (bagian 1) ğŸ’ ğŸ§ ğŸ˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini, kita akan berbicara tentang bahasa JetBrains yang baru dirilis dengan tipe dependen Arend (bahasa ini dinamai Gating Rent ). Bahasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - bahasa tipe dependen berbasis HoTT (bagian 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"> Dalam posting ini, kita akan berbicara tentang bahasa JetBrains yang baru dirilis dengan tipe dependen Arend (bahasa ini dinamai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gating Rent</a> ).  Bahasa ini telah dikembangkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JetBrains Research</a> selama beberapa tahun terakhir.  Dan meskipun repositori setahun yang lalu diposting secara publik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/JetBrains</a> , rilis penuh Arend hanya terjadi pada bulan Juli tahun ini. <br><br>  Kami akan mencoba memberi tahu bagaimana Arend berbeda dari sistem matematika formal yang ada berdasarkan tipe dependen, dan fungsi apa yang sekarang tersedia untuk penggunanya.  Kami berasumsi bahwa pembaca artikel ini umumnya akrab dengan tipe dependen dan telah mendengar setidaknya satu bahasa berdasarkan tipe dependen: Agda, Idris, Coq, atau Lean.  Namun, kami tidak berharap pembaca memiliki tipe dependen pada level lanjutan. <br><br>  Untuk kesederhanaan dan konkret, cerita kami tentang tipe Arend dan homotopy akan disertai dengan implementasi pada Arend dari algoritma pengurutan daftar paling sederhana - bahkan dengan contoh ini Anda dapat merasakan perbedaan antara Arend dan Agda dan Coq.  Sudah ada sejumlah artikel tentang HabrÃ© yang ditujukan untuk tipe-tipe dependen.  Katakanlah tentang implementasi daftar penyortiran menggunakan metode QuickSort di Agda ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel seperti itu</a> .  Kami akan menerapkan algoritma yang lebih sederhana untuk menyortir sisipan.  Dalam hal ini, kami akan fokus pada konstruksi bahasa Arend, dan bukan pada algoritma penyortiran itu sendiri. <br><a name="habracut"></a><br>  Jadi, perbedaan utama antara Arend dan bahasa lain dengan tipe dependen adalah teori logis yang menjadi dasarnya.  Arend menggunakan teori jenis homotopy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V. Voevodsky yang</a> baru-baru ini ditemukan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HoTT</a> ).  Lebih khusus lagi, Arend didasarkan pada variasi HoTT yang disebut "teori tipe dengan spasi."  Ingat bahwa Coq didasarkan pada apa yang disebut kalkulus konstruksi induktif (Kalkulus Konstruksi Induktif), sedangkan Agda dan Idris didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori tipe intensifikasi Martin-LÃ¶f</a> .  Fakta bahwa Arend didasarkan pada HoTT secara signifikan memengaruhi konstruksi sintaksisnya dan pengoperasian algoritma pengecekan tipe (typcheker).  Kami akan membahas fitur-fitur ini dalam artikel ini. <br><br>  Mari kita coba menggambarkan secara singkat keadaan infrastruktur bahasa.  Untuk Arend ada plugin untuk IntelliJ IDEA, yang dapat diinstal langsung dari repositori plugin IDEA.  Pada prinsipnya, menginstal plugin cukup untuk sepenuhnya berfungsi dengan Arend, Anda masih tidak perlu mengunduh dan menginstal apa pun.  Selain memeriksa jenis, plugin Arend menyediakan fungsionalitas yang akrab bagi pengguna IDEA: ada penyorotan dan penyelarasan kode, berbagai refactor dan tips.  Ada juga opsi untuk menggunakan versi konsol Arend.  Penjelasan lebih rinci tentang proses instalasi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Contoh kode dalam artikel ini didasarkan pada pustaka standar Arend, jadi kami sarankan mengunduh kode sumbernya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> .  Setelah mengunduh, direktori sumber harus diimpor sebagai proyek IDEA menggunakan perintah Impor Proyek.  Di Arend, beberapa bagian dari teori tipe homotopy dan teori cincin telah diformalkan.  Sebagai contoh, di perpustakaan standar ada implementasi dari cincin bilangan rasional Q bersama dengan bukti dari semua sifat teori-cincin yang diperlukan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi bahasa</a> terperinci, di mana banyak poin yang dibahas dalam artikel ini dijelaskan lebih terinci, juga ada dalam domain publik.  Anda dapat langsung mengajukan pertanyaan kepada Arend pengembang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> . <br><br><h2>  1. Ikhtisar HoTT / Arend </h2><br>  Teori tipe homotopy (atau, singkatnya, HoTT) adalah jenis teori tipe intensional yang berbeda dari teori tipe Martin-Lof klasik (MLTT, yang menjadi dasar Agda) dan kalkulus konstruksi induktif (CIC, yang menjadi dasar Coq), dalam hal itu, bersama dengan pernyataan dan set berisi apa yang disebut jenis tingkat homotopy yang lebih tinggi. <br><br>  Dalam artikel ini, kami tidak menetapkan tujuan untuk menjelaskan dasar-dasar HoTT secara detail - untuk penjelasan terperinci tentang teori ini, perlu untuk menceritakan kembali seluruh buku (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> ).  Kami hanya mencatat bahwa teori yang didasarkan pada aksioma HoTT, dalam arti tertentu, jauh lebih elegan dan menarik daripada teori tipe klasik Martin-LÃ¶f.  Dengan demikian, sejumlah aksioma yang sebelumnya harus dipostulatkan tambahan (misalnya, ekstensionalitas fungsional) dibuktikan dalam HoTT sebagai teorema.  Selain itu, di HoTT, seseorang dapat secara internal mendefinisikan bola homotopy multidimensi dan bahkan menghitung beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelompok homotopy</a> mereka. <br><br>  Namun, aspek-aspek HoTT ini terutama menarik bagi matematikawan, dan tujuan dari artikel ini adalah untuk menjelaskan bagaimana Arend berbasis HoTT dibandingkan dengan Agda / MLTT dan Coq / CIC dengan contoh mewakili yang sederhana dan akrab bagi entitas pemrogram seperti daftar pesanan.  Saat membaca artikel ini, cukup untuk memperlakukan HoTT sebagai semacam teori tipe intensional dengan aksioma yang lebih maju, yang memberikan kenyamanan ketika bekerja dengan alam semesta dan persamaan. <br><br><h2>  1.1 Jenis ketergantungan, korespondensi Curry - Howard, semesta </h2><br>  Ingatlah bahwa bahasa dengan tipe dependen berbeda dari bahasa pemrograman fungsional biasa selain tipe data biasa, seperti daftar atau angka alami, ada beberapa tipe yang bergantung pada nilai parameter.  Contoh paling sederhana dari jenis tersebut adalah vektor dengan panjang tertentu n atau pohon seimbang dengan kedalaman tertentu d.  Beberapa contoh lebih lanjut dari jenis-jenis tersebut disebutkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Ingat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korespondensi Curry - Howard</a> memungkinkan seseorang untuk menafsirkan pernyataan logika sebagai tipe dependen.  Gagasan utama dari korespondensi ini adalah bahwa tipe kosong sesuai dengan pernyataan salah, dan tipe populasi sesuai dengan pernyataan yang benar.  Jenis elemen dapat dianggap sebagai bukti dari pernyataan logis yang sesuai.  Sebagai contoh, setiap elemen seperti bilangan bulat dapat dianggap sebagai bukti dari fakta bahwa bilangan bulat ada (yaitu, jenis bilangan bulat diisi). <br><br>  Konstruksi alami yang berbeda untuk tipe sesuai dengan koneksi logis yang berbeda: <br><br><ul><li>  <i>Produk tipe A Ã— B</i> kadang-kadang disebut tipe pasangan Pair A B. Karena tipe ini terisi jika dan hanya jika kedua tipe A dan B terisi, konstruksi ini sesuai dengan "dan" logis. </li><li>  <i>Jumlah tipe A + B.</i> Dalam Haskell, tipe ini disebut E A. Karena tipe ini terisi jika dan hanya jika salah satu tipe A atau B terisi, konstruksi ini sesuai dengan "atau" yang logis. <br></li><li>  <i>Tipe fungsional A â†’ B.</i>  Setiap fungsi dari tipe ini mengubah elemen A ke elemen B. Dengan demikian, fungsi seperti itu ada tepat ketika keberadaan elemen tipe A menyiratkan keberadaan elemen tipe B. Oleh karena itu, konstruksi ini sesuai dengan implikasi. <br></li></ul><br>  Misalkan sekarang kita diberi tipe A tertentu dan keluarga tipe B yang diparameterisasi oleh elemen a dari tipe A. Mari kita berikan contoh konstruksi yang lebih kompleks daripada tipe dependen. <br><br><ul><li>  <i>Jenis fungsi dependen</i> <b>Î </b> (a: A) (B a).  Tipe ini bertepatan dengan tipe fungsional A â†’ B yang biasa jika B tidak bergantung pada A. Fungsi tipe <b>Î </b> (a: A) (B a) mengubah elemen apa pun dari tipe A menjadi elemen tipe B a.  Jadi, fungsi semacam itu ada jika dan hanya jika, <i>untuk a</i> : A, ada elemen B a.  Oleh karena itu, konstruksi ini sesuai dengan kuantifier universal âˆ€.  Untuk tipe fungsional dependen, Arend menggunakan sintaks <code><b>\Pi</b> (x : A) -&gt; B a</code> , dan istilah yang mendiami tipe ini dapat dikonstruksikan menggunakan ekspresi lambda <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li>  <i>Jenis pasangan tergantung adalah <b>Î£</b> (a: A) (B a).</i>  Tipe ini bertepatan dengan tipe pasangan A Ã— B yang biasa jika B tidak bergantung pada A. Tipe <b>Î£</b> (a: A) (B a) terisi persis ketika <i>ada</i> elemen a: A dan elemen tipe B a.  Jadi, tipe ini sesuai dengan quantifier keberadaan <code>âˆƒ</code> .  Jenis pasangan dependen dalam Arend dilambangkan dengan <code>\Sigma (a : A) (B a)</code> , dan istilah yang mendiami itu dibangun menggunakan konstruktor dari pasangan <i>(tergantung)</i> <code>(a, b)</code> . <br></li><li>  <i>Jenis kesetaraan adalah</i> a = a ', di mana a dan' adalah dua elemen dari beberapa jenis A. Jenis tersebut dihuni jika a dan a 'sama, dan kosong sebaliknya.  Jelas, tipe ini adalah analog dari predikat kesetaraan dalam logika. </li></ul><br>  Pada titik ini, kami merujuk pembaca ke sumber di mana korespondensi Curry - Howard dibahas secara lebih rinci (lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus kuliah</a> atau artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Semua ekspresi yang dipertimbangkan dalam teori tipe harus memiliki beberapa tipe.  Karena ekspresi yang menunjukkan tipe juga dipertimbangkan dalam kerangka teori ini, mereka juga perlu diberi tipe tertentu.  Pertanyaannya adalah, seperti apa jenisnya? <br><br>  Keputusan naif pertama yang muncul di pikiran adalah untuk menetapkan semua tipe tipe formal <code>\Type</code> , yang disebut <i>alam semesta</i> (disebut demikian karena berisi semua tipe pada umumnya).  Jika kita menggunakan alam semesta ini, jumlah konstruksi dan jenis produk yang disebutkan di atas akan menerima tanda tangan <code>\Type â†’ \Type â†’ \Type</code> , dan konstruksi yang lebih kompleks dari produk tergantung dan jumlah bergantung akan menerima tanda tangan <code><b>Î </b> (A : \Type) â†’ ((A â†’ \Type) â†’ \Type)</code> . <br><br>  Pada titik ini, muncul pertanyaan, tipe apa yang seharusnya dimiliki oleh <code>\Type</code> semesta itu sendiri?  Upaya naif untuk mengatakan bahwa jenis alam semesta <code>\Type</code> , menurut definisi, adalah <code>\Type</code> itu sendiri mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paradoks Girard</a> , jadi alih-alih sebuah alam semesta tunggal <code>\Type</code> mempertimbangkan <i>hierarki alam semesta yang</i> tak terbatas, mis.  rantai bersarang alam semesta <code>\Type 1 &lt; \Type 2 &lt; â€¦</code> , yang levelnya diberi nomor oleh bilangan alami, dan tipe alam semesta <code>\Type i</code> , menurut definisi, adalah alam semesta <code>\Type (i+1)</code> .  Untuk jenis konstruksi yang disebutkan di atas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tanda tangan yang</a> lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleks</a> juga harus diperkenalkan. <br><br>  Dengan demikian, alam semesta dalam teori tipe diperlukan sehingga setiap ekspresi memiliki tipe tertentu.  Dalam beberapa varietas teori tipe, alam semesta digunakan untuk tujuan lain: untuk membedakan antara varietas jenis.  Kita telah melihat bahwa set dan pernyataan adalah tipe kasus khusus.  Ini menunjukkan bahwa masuk akal untuk memperkenalkan ke dalam teori Prop universe yang terpisah untuk pernyataan dan hierarki yang terpisah dari alam semesta Set <sub>i</sub> .  Ini persis pendekatan yang digunakan dalam Kalkulus Konstruksi Induktif, teori di mana sistem Coq didasarkan. <br><br><h2>  1.2 Contoh tipe induktif paling sederhana dan fungsi rekursif </h2><br>  Pertimbangkan definisi Arend dari tipe data induktif yang paling sederhana: tipe Boolean, tipe angka alami, dan daftar polimorfik.  Arend menggunakan <code>\data</code> kata kunci untuk memperkenalkan tipe induktif baru. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  Seperti yang Anda lihat dari contoh di atas, setelah <code>\data</code> kata kunci, Anda perlu menentukan nama tipe induktif dan daftar konstruktornya.  Pada saat yang sama, tipe data dan konstruktor mungkin memiliki beberapa parameter.  Katakanlah dalam contoh di atas tipe <code>List</code> memiliki satu parameter <code>A</code>  Konstruktor daftar <code>nil</code> tidak memiliki parameter, dan konstruktor: -: memiliki dua parameter (salah satunya adalah tipe <code>A</code> , dan yang lainnya adalah tipe <code>List A</code> ).  The Univers <code>\Set</code> terdiri dari tipe-tipe yang merupakan set (definisi dari set akan diberikan pada bagian selanjutnya).  <code>\infixr</code> memungkinkan Anda untuk menggunakan notasi infiks untuk konstruktor: -: dan, selain itu, memberi tahu parser Arend bahwa operator: -: adalah operasi asosiatif-kanan dengan prioritas 5. <br><br>  Di Arend, semua kata kunci dimulai dengan karakter garis miring terbalik (â€œ\â€), sebuah implementasi yang terinspirasi oleh LaTeX.  Perhatikan bahwa aturan leksikal di Arend sangat liberal: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> dan bahkan <code>n:Nat</code> - semua literal ini adalah contoh pengidentifikasi yang valid di Arend.  Contoh terakhir menunjukkan betapa pentingnya bagi pengguna Arend <i>untuk mengingat untuk menempatkan spasi antara pengidentifikasi dan karakter titik dua</i> .  Perhatikan bahwa dalam pengidentifikasi Arend tidak diperbolehkan untuk menggunakan karakter Unicode (khususnya, Anda tidak dapat menggunakan Cyrillic). <br><br>  Arend menggunakan kata kunci <code>\func</code> untuk mendefinisikan fungsi.  Sintaks dari konstruksi ini adalah sebagai berikut: setelah kata kunci <code>\func</code> , Anda perlu menentukan nama fungsi, parameternya dan jenis nilai kembali.  Elemen terakhir dalam mendefinisikan suatu fungsi adalah tubuhnya. <br><br>  Jika dimungkinkan untuk secara eksplisit menentukan ekspresi di mana fungsi yang diberikan dihitung, maka untuk menunjukkan tubuh fungsi, token =&gt; digunakan.  Pertimbangkan, misalnya, definisi fungsi negasi jenis. <br><br><pre> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  Tipe kembalinya suatu fungsi tidak selalu harus ditentukan secara eksplisit.  Pada contoh di atas, Arend akan dapat secara independen menyimpulkan tipe <code>Not</code> , dan kita dapat menghilangkan ungkapan ": <code>\Type</code> " setelah tanda kurung. <br><br>  Seperti dalam kebanyakan sistem matematika yang diformalkan, pengguna tidak harus menentukan tingkat prediktif eksplisit untuk <code>\Type</code> semesta, dan definisi di mana alam semesta digunakan tanpa secara eksplisit menentukan tingkat prediksi dianggap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polimorfik</a> . <br><br>  Sekarang mari kita coba mendefinisikan fungsi yang menghitung panjang daftar.  Fungsi seperti itu mudah diidentifikasi melalui pencocokan pola.  Arend menggunakan <code>\elim</code> kata kunci untuk ini.  Setelah itu, Anda harus menentukan variabel tempat perbandingan dilakukan (jika ada lebih dari satu variabel seperti itu, maka mereka harus ditulis dengan koma).  Jika perbandingan dilakukan untuk semua parameter eksplisit, maka <code>\elim</code> beserta variabel dapat dihilangkan.  Ini diikuti oleh blok titik perbandingan, dipisahkan satu sama lain oleh bilah vertikal "|".  Setiap item dalam blok ini adalah ekspresi dari bentuk <code>Â«,    Â» =&gt; Â«Â»</code> . <br><br><pre> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  Pada contoh di atas, parameter A dari fungsi <code>length</code> dikelilingi oleh kurung kurawal.  Tanda kurung di Arend ini digunakan untuk menunjukkan argumen implisit, mis.  argumen yang dapat dihilangkan pengguna saat memanggil suatu fungsi atau menggunakan tipe.  Perhatikan bahwa di Arend Anda tidak dapat menggunakan notasi infiks untuk menunjuk konstruktor saat mencocokkan dengan pola, sehingga notasi awalan digunakan dalam contoh sampel. <br><br>  Seperti dalam Coq / Agda, dalam Arend semua fungsi harus dijamin akan selesai (mis., Pemeriksaan penghentian hadir di Arend).  Dalam definisi fungsi panjang, pemeriksaan ini berhasil, karena panggilan rekursif secara ketat mengurangi argumen eksplisit pertama.  Jika pengurangan seperti itu tidak terjadi, Arend akan memberikan pesan kesalahan. <br><br><pre> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  Arend memungkinkan dependensi melingkar dan fungsi saling rekursif yang pemeriksaan kelengkapannya juga dilakukan.  Algoritma pemeriksaan ini dilaksanakan berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh</a> A. Abel.  Di dalamnya Anda akan menemukan deskripsi yang lebih rinci tentang kondisi yang harus dipenuhi fungsi rekursif bersama. <br><br><h2>  1.3 Apa perbedaan set dari pernyataan? </h2><br>  Kami sebelumnya menulis bahwa contoh tipe adalah himpunan dan pernyataan.  Selain itu, kami menggunakan kata kunci <code>\Type</code> dan <code>\Set</code> untuk menunjukkan semesta di Arend.  Pada bagian ini, kami akan mencoba menjelaskan secara lebih rinci bagaimana pernyataan berbeda dari set dalam hal varietas dari teori tipe intensional (MLTT, CIC, HoTT), dan pada saat yang sama menjelaskan apa arti dari kata kunci <code>\Prop</code> , <code>\Set</code> dan <code>\Type</code> dalam Arend terdiri. <br><br>  Ingatlah bahwa dalam teori klasik Martin-Lof tidak ada pemisahan tipe menjadi himpunan dan pernyataan.  Secara khusus, dalam teori hanya ada satu kumulatif alam semesta (yang dilambangkan dengan Set in Agda, atau Type in Idris, atau Sort in Lean).  Pendekatan ini adalah yang paling sederhana, tetapi ada situasi di mana kekurangannya terwujud.  Misalkan kita sedang berusaha mengimplementasikan tipe "daftar pesanan" sebagai pasangan tidak tetap yang terdiri dari daftar dan bukti pemesanannya.  Ternyata kemudian, dalam kerangka MLTT "murni", tidak akan mungkin untuk membuktikan kesetaraan daftar terurut yang terdiri dari elemen identik, yang pada saat bersamaan berbeda dalam hal bukti pemesanan.  Untuk memiliki kesetaraan seperti itu akan sangat alami dan diinginkan, sehingga ketidakmungkinan untuk membuktikannya dapat dianggap sebagai cacat teoritis dalam MLTT. <br><br>  Di Agda, masalah ini sebagian diselesaikan dengan bantuan yang disebut annotations of immateriality (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumbernya</a> , di mana contoh daftar dibahas lebih rinci).  Anotasi ini, bagaimanapun, bukan merupakan konstruk dari teori MLTT, juga bukan merupakan konstruk penuh pada tipe (tidak mungkin untuk menandai dengan anotasi tipe yang tidak digunakan dalam argumen fungsi). <br><br>  Dalam CIC, berdasarkan CIC, ada dua alam semesta berbeda yang saling bersarang: <code>Prop</code> (alam semesta pernyataan) dan <code>Set</code> (alam semesta himpunan), yang dicelupkan ke dalam hierarki komprehensif semesta <code>Type</code> .  Perbedaan utama antara <code>Prop</code> dan <code>Set</code> adalah bahwa ada sejumlah batasan pada variabel yang jenisnya termasuk <code>Prop</code> dalam Coq.  Sebagai contoh, mereka tidak dapat digunakan dalam perhitungan, dan perbandingan dengan sampel untuk mereka hanya mungkin dilakukan di dalam bukti pernyataan lain.  Di sisi lain, semua elemen dari jenis milik <code>Prop</code> semesta adalah sama dalam aksioma bukti tidak penting, lihat pernyataan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coq.Logic.ProofIrrelevance</a> .  Dengan menggunakan aksioma ini, kita dapat dengan mudah membuktikan kesetaraan dari daftar pesanan yang disebutkan di atas. <br><br>  Akhirnya, pertimbangkan pendekatan Arend / HoTT untuk pernyataan dan alam semesta.  Perbedaan utama adalah bahwa HoTT membuang dengan aksioma bukti tidak penting.  Artinya, tidak ada aksioma khusus dalam HoTT yang mendalilkan bahwa semua elemen pernyataan adalah sama.  Tetapi dalam HoTT, tipe, <i>menurut definisi</i> , adalah pernyataan jika dapat dibuktikan bahwa semua elemennya sama satu sama lain.  Kita dapat mendefinisikan predikat pada tipe yang benar jika tipenya adalah pernyataan: <br><br><pre> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Muncul pertanyaan: apa jenis yang memenuhi predikat ini, yaitu, pernyataan?  Sangat mudah untuk memverifikasi bahwa ini berlaku untuk jenis kosong dan tunggal.  Untuk tipe yang paling tidak memiliki dua elemen berbeda, ini tidak lagi benar. <br><br>  Tentu saja, kami ingin semua penghubung logis yang perlu ditentukan berdasarkan pernyataan.  Dalam Bagian 1.1, kita sudah membahas bagaimana mereka dapat ditentukan menggunakan konstruksi tipe-teori.  Namun, ada masalah berikut: tidak semua operasi yang kami masukkan mempertahankan properti <code>isProp</code> .  Konstruksi produk tipe dan tipe fungsional (tergantung) mempertahankan properti ini, sedangkan konstruksi jumlah tipe dan pasangan dependen tidak.  Jadi, kita tidak bisa menggunakan disjungsi dan kuantifikasi keberadaan. <br><br>  Masalah ini dapat diselesaikan dengan bantuan konstruksi baru, yang ditambahkan ke HoTT, yang disebut <i>pemotongan proposisional</i> .  Desain ini memungkinkan Anda untuk mengubah tipe apa pun menjadi pernyataan.  Ini dapat dianggap sebagai operasi formal, menyamakan semua istilah yang mendiami tipe ini.  Operasi ini agak mirip dengan penjelasan immaterialitas dari Agda, namun, tidak seperti mereka, ini adalah operasi penuh pada jenis dengan tanda tangan <code>\Type -&gt; \Prop</code> . <br><br>  Contoh pernyataan penting terakhir adalah kesetaraan dua elemen dari beberapa tipe.  Ternyata dalam kasus umum jenis kesetaraan <code>a = a'</code> tidak harus berupa pernyataan.  Jenis yang disebut satu set: <br><br><pre> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  Semua jenis yang ditemukan dalam bahasa pemrograman biasa memenuhi predikat ini, yaitu, kesetaraan pada mereka adalah pernyataan.  Sebagai contoh, ini berlaku untuk bilangan asli, bilangan bulat, produk set, jumlah set, fungsi lebih dari set, daftar set, dan tipe data induktif lainnya yang dibangun dari set.  Ini berarti bahwa jika kita hanya tertarik pada konstruksi yang sudah dikenal seperti itu, maka kita tidak dapat berpikir tentang tipe arbitrer yang tidak memenuhi predikat ini.  Semua tipe yang ditemukan dalam Coq adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">set</a> . <br><br>  Tipe yang tidak disetel menjadi berguna jika Anda ingin berurusan dengan teori tipe homotopy.  Untuk saat ini, kami cukup merujuk pembaca ke <a href="">modul</a> perpustakaan standar yang berisi definisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bola n-dimensi</a> , contoh dari jenis yang bukan kumpulan. <br><br>  Arend memiliki alam semesta khusus <code>\Prop</code> dan <code>\Set</code> , yang masing-masing terdiri dari pernyataan dan set.  Jika kita sudah tahu bahwa tipe A terkandung dalam alam semesta <code>\Prop</code> (atau <code>\Set</code> ), maka bukti properti <code>isProp</code> (atau <code>isSet</code> ) yang sesuai di Arend dapat diperoleh dengan menggunakan aksioma <code>Path.inProp</code> dibangun di <a href="">awal</a> (kami memberikan contoh menggunakan aksioma ini dalam bagian 2.3). <br><br><pre> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Kami telah mencatat bahwa tidak semua konstruksi alami pada tipe mempertahankan properti <code>isProp</code> .  Misalnya, tipe data induktif dengan dua atau lebih konstruktor tidak pernah memuaskannya.  Seperti disebutkan di atas, kita dapat menggunakan konstruksi <i>pemotongan proposisional</i> yang mengubah tipe apa pun menjadi pernyataan. <br>  Di perpustakaan Arend, implementasi standar pemotongan proposisional disebut <code>Logic.TruncP</code> .  Kita bisa mendefinisikan tipe logis "atau" di Arend sebagai memotong jumlah jenis: <br><br><pre> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical â€œorâ€, analogue of Coq's type "\/"</code> </pre> <br>  Di Arend, ada cara lain, lebih sederhana dan lebih nyaman untuk mendefinisikan tipe induktif yang terpotong proposisi.  Untuk melakukan ini, tambahkan saja kata kunci <code>\truncated</code> sebelum mendefinisikan tipe data.  Sebagai contoh, definisi logis â€œatauâ€ di pustaka standar Arend diberikan sebagai berikut. <br><br><pre> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical â€œorâ€, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  Pekerjaan lebih lanjut dengan jenis terpotong proposisional menyerupai jenis yang ditugaskan ke alam semesta <code>Prop</code> di Coq.  Misalnya, pencocokan pola variabel yang jenisnya adalah pernyataan hanya diizinkan dalam situasi di mana jenis ekspresi itu sendiri merupakan pernyataan.  Dengan demikian, selalu mudah untuk mendefinisikan fungsi <code>Or-to-||</code>  melalui perbandingan dengan sampel, tetapi fungsi terbalik untuk itu, hanya jika tipe A <code>`Or`</code> B adalah pernyataan (yang cukup langka, misalnya, ketika tipe <code>A</code> dan <code>B</code> keduanya pernyataan dan saling terpisah satu sama lain). <br><br><pre> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  Ingat juga bahwa kekhasan mekanisme alam semesta dalam Coq adalah bahwa jika beberapa definisi diberikan ke alam semesta <code>Prop</code> , maka sama sekali tidak mungkin untuk menggunakannya dalam perhitungan.  Untuk alasan ini, pengembang Coq sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak merekomendasikan</a> penggunaan konstruksi proposisional, tetapi menyarankan untuk menggantinya dengan analog dari set semesta, jika memungkinkan.  Mekanisme alam semesta Arend tidak memiliki kelemahan ini, yaitu, dalam situasi tertentu dimungkinkan untuk menggunakan pernyataan dalam perhitungan.  Kami akan memberikan contoh situasi seperti itu ketika kami membahas implementasi algoritma pengurutan daftar. <br><br><h2>  1.4 Kelas di Arend </h2><br>  Karena tujuan kami adalah menerapkan algoritma penyortiran yang paling sederhana, tampaknya berguna untuk membiasakan diri Anda dengan penerapan set yang dipesan yang tersedia di pustaka standar Arend. <br><br>  Di Arend, kelas digunakan untuk merangkum operasi dan aksioma yang mendefinisikan struktur matematika, dan juga untuk menyoroti hubungan antara struktur ini menggunakan pewarisan.  Kelas juga ruang nama, yang di dalamnya nyaman untuk menempatkan konstruksi dan teori yang sesuai dengan makna. <br><br>  Kelas dasar dari mana semua kelas pesanan di Arend diwarisi adalah kelas <code>BaseSet</code> , yang tidak mengandung anggota apa pun selain penunjukan <code>E</code> untuk set host (mis., Set di mana <code>BaseSet</code> turunan <code>BaseSet</code> sudah memperkenalkan berbagai operasi).  Pertimbangkan definisi kelas ini dari pustaka Arend standar. <br><br><pre> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  Dalam definisi di atas, operator <code>E</code> dinyatakan sebagai parameter kelas.  Orang mungkin bertanya, apakah ada perbedaan dalam definisi <code>BaseSet</code> dari definisi berikut, di mana carrier E didefinisikan sebagai bidang kelas? <br><br><pre> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  Jawaban yang sedikit tidak terduga adalah bahwa dalam Arend <i>tidak ada perbedaan</i> antara dua definisi dalam arti bahwa setiap parameter kelas (bahkan implisit) dalam Arend, pada kenyataannya, <i>adalah</i> bidangnya.  Dengan demikian, untuk kedua implementasi <code>BaseSet</code> , orang dapat menggunakan ekspresi <code>xE</code> untuk mengakses bidang E. <code>BaseSet</code> perbedaan antara varian di atas dari definisi <code>BaseSet</code> , tetapi lebih halus, kita akan memeriksanya lebih detail di bagian selanjutnya ketika kita membahas contoh kelas ( instance kelas). <br><br>  Operasi pengurutan daftar masuk akal hanya jika urutan linier ditentukan pada jenis objek dalam daftar, jadi kami pertama-tama mempertimbangkan definisi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">himpunan sebagian yang dipesan secara ketat</a> dan rangkaian yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipesan secara linear.</a> <br><br><pre> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  Dari sudut pandang teori tipe, kelas-kelas di Arend dapat dianggap sebagai analog dari tipe sigma dengan sintaksis yang lebih nyaman untuk proyeksi dan konstruktor.  ,  Arend-    -,       . <br><br>     ,     <i></i> .     ,      . ,  StrictPoset  <code>&lt;-irreflexive</code>  <code>&lt;-transitive</code>  ,   <code>E</code>  <code>&lt;</code> â€” .     ,     (,  ,    )    ,       . <br><br>        ,   ,    .   ,   Arend  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,  ,      .  ,       . ,     ,        ,     ,      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  : <br><br><pre> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br>  <code>Dec</code>     ,  <code>Dec E</code>     ,  <code>E</code> ,      <code>E</code> ,   <code>E</code> . <br><br><pre> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br> , ,  <code>Dec</code> (  decidable)   <code>Order.LinearOrder</code> .  Dec    , ,  ,     <code>trichotomy</code> , ,      <code>E</code> ,    &lt;.  , <code>Dec</code>      Comparable  Java. <br><br><pre> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br>   <code>Dec</code>         <code>Dec</code> ,    ,   ,  ,            .     <code>Dec</code>    ,     . <br><br>       ,          <code>Dec</code> (        ).  <code>Dec</code> ,   Arend    ( <code>Dec</code>     <code>LinearOrder,</code>  <code>DecSet</code> ),  ,     (diamond inheritance). <br><br>       :                ,     (    ,       ). <br><br>    <code>Dec</code>   <code>Order.LinearOrder</code>   IDEA    (      [Ctrl]+[H]),   ,    . <br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br>              Arend (    IDEA    <code>BaseSet</code> ).   ,      . <br><br><h2> 1.5  ,  ,     . </h2><br>        <code>StrictPoset</code>     Nat.  Arend       ,     .       -,  ,    ,   - (   ),           . <br><br>         :   .             . <br><br><pre> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br>       <code>\func</code>   <code>\lemma</code> .      ,       ,        ,     .      ,   <code>\lemma</code>  ,        <code>\Prop</code> . <br><br>    <code>x'&lt;y'</code> â€”    -,    <code>x' &lt; y'</code> .         - (.. ,       ,     ). <br><br>      (instance)  <code>StrictPoset</code> .  Arend       .           <code>\new</code>   .      Â«  Â». <br><br><pre> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  <code>StrictPoset { â€¦ }</code>       <code>\new</code> :       - <code>StrictPoset</code> .   -    , ,    ,        <code>\new</code>  .   <code>\new C { â€¦ }</code>   <code>C { â€¦ }</code> .       C,      C. ,    ,  <code>NatOrder</code>    <code>StrictPoset</code> . <br><br>    ,         .  ,       <code>StrictPoset Nat</code>      <code>StrictPoset { | E =&gt; Nat }</code> . ,        <code>NatOrder</code>  <code>StrictPoset</code> ,           (     ). <br><br>      <code>NatOrder</code>      <code>\cowith</code>    (          - ). <br><br><pre> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br> , ,          <code>\instance.</code> <br><br><pre> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  Arend     ,     Haskell.   <code>NatOrder</code>    <code>\instance</code>    <code>\cowith</code>      ,           <code>StrictPoset</code> (    ). <br><br> ,    <code>BaseSet</code>    - E     (   ),      ,         E   .      . <br><br>  ,         Arend      .   Arend  ,            ,       (  ,  Â« <i> </i> Â»         <code>\classifying \field</code> ,    Arend      ).      : <br><br><ul><li> Arend                . ,  <code>X</code>   <code>StrictPoset</code> ,   <code>List X</code>         <code>List XE</code> . <br></li><li> Arend          . </li></ul><br>  ,    . ,         <code>\instance</code>    <code>StrictPoset</code>    ,     <code>Nat</code>    <code>Int</code> (   <code>NatOrder</code>  <code>IntOrder</code> ). <br><br> ,      <code>x &lt; y</code>      ,  x, y   ,    ,  x, y   .    Arend  ,     <code>NatOrder.&lt;</code> ,    â€” <code>IntOrder.&lt;</code> . <br><br>    ,     . Arend ,   &lt;    <code>StrictPoset</code> ,       E. , Arend      <code>x&lt;y</code>          <code>StrictPoset</code> (  ),     E   .    ,    <code>&lt;</code>     . <br><br> ,                     Arend.        ,     <code>\use \coerce</code>  <i> </i>  .  Arend      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> â€”   ,   ,       .       -  ,    <code>\where</code> . <br><br>       .  <code>fromNat</code>         . <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br>    <code>\use \coerce</code>  <code>\func</code>   ,          .     ,         ,      (,     ,        ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469569/">https://habr.com/ru/post/id469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469551/index.html">VDS dengan kartu video - kami tahu banyak tentang penyimpangan</a></li>
<li><a href="../id469555/index.html">Siaran: Pertemuan Kubernet Moskow # 6</a></li>
<li><a href="../id469557/index.html">Generic Recycler Lihat atau bagaimana tidak menulis kode boilerplate</a></li>
<li><a href="../id469561/index.html">Perhitungan akar kuadrat integer</a></li>
<li><a href="../id469567/index.html">Latar belakang: detail pada iPhone 11, 11 Pro dan Apple Watch baru setelah dua minggu pengujian</a></li>
<li><a href="../id469573/index.html">Linux Piter 2019: apa yang menanti para tamu untuk konferensi Linux skala besar dan mengapa itu tidak boleh dilewatkan</a></li>
<li><a href="../id469575/index.html">Cara memprogram ulang mode tidur: 30 hari setiap pagi saya menyinari lampu hijau terang di mata saya</a></li>
<li><a href="../id469577/index.html">Disk forensik, forensik memori dan log forensik. Kerangka Volatilitas dan Otopsi. Pemecahan masalah dengan r0ot-mi. Bagian 1</a></li>
<li><a href="../id469581/index.html">Analisis Efek Picabu</a></li>
<li><a href="../id469583/index.html">OpenVPN dan Direktori Aktif (Kerberos tanpa sertifikat pengguna)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>