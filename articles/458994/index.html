<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëç ü§öüèø üéø Raspberry Pi + CentOS = Punto de acceso Wi-Fi (o Raspberry Router en un Red Hat) ‚öîÔ∏è üî∑ üëê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existe una gran cantidad de informaci√≥n en Internet sobre la creaci√≥n de puntos de acceso Wi-Fi basados ‚Äã‚Äãen una PC Raspberry de placa √∫nica. Como reg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raspberry Pi + CentOS = Punto de acceso Wi-Fi (o Raspberry Router en un Red Hat)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458994/">  Existe una gran cantidad de informaci√≥n en Internet sobre la creaci√≥n de puntos de acceso Wi-Fi basados ‚Äã‚Äãen una PC Raspberry de placa √∫nica.  Como regla, implica el uso del sistema operativo nativo para Raspberry - Raspbian. <br><br>  Siendo adherente a los sistemas basados ‚Äã‚Äãen RPM, no pude superar este peque√±o milagro y no probar mi CentOS favorito en √©l. <br><br>  El art√≠culo proporciona instrucciones para hacer un enrutador Wi-Fi de 5 GHz / CA desde el Raspberry Pi 3 Modelo B + basado en el sistema operativo CentOS.  Habr√° varios trucos est√°ndar, pero poco conocidos, y como beneficio adicional: un dibujo de conexi√≥n al equipo de Wi-Fi adicional "frambuesa", que le permite trabajar simult√°neamente en varios modos (2.4 + 5GHz). <br><br><img src="https://habrastorage.org/webt/mp/yb/fz/mpybfz6gzojqkaftnuljhpzx5da.png" alt="imagen"><br>  <sub><i>(mezcla de im√°genes de libre acceso)</i></sub> <br><a name="habracut"></a><br>  Notamos de inmediato que algunas velocidades c√≥smicas no funcionar√°n.  Exprimo un m√°ximo de 100 Mbit de mi "frambuesa" por el aire, y esto cubre la velocidad de mi proveedor de Internet.  ¬øPor qu√© necesitamos una CA tan lenta, si incluso en N, en teor√≠a, puede obtener medio gigabyte?  Si hizo esta pregunta, vaya a la tienda para obtener un enrutador real con ocho antenas externas. <br><br><h1>  0. Lo que se necesita </h1><br><ul><li>  En realidad, el "producto de frambuesa" del calibre mismo: Pi 3 Modelo B + (para lograr las codiciadas velocidades y canales de 5 GHz); <br></li><li>  MicroSD s√≥lida&gt; = 4 GB; <br></li><li>  Estaci√≥n de trabajo Linux con lector / escritor microSD; <br></li><li>  La presencia de suficientes habilidades en Linux, el art√≠culo es para el Geek preparado; <br></li><li>  Conectividad de red cableada (eth0) entre Raspberry y Linux, un servidor DHCP en funcionamiento en la red local, y acceso a Internet desde ambos dispositivos. <br></li></ul><br>  Un breve comentario sobre el √∫ltimo punto.  "¬øQu√© vino primero, un huevo o ..." c√≥mo hacer un enrutador Wi-Fi en ausencia de cualquier equipo de acceso a Internet?  Dejemos este entretenido ejercicio fuera del alcance del art√≠culo y simplemente supongamos que Raspberry est√° conectado a la red local por cable y tiene acceso a Internet.  En este caso, no necesitamos un televisor adicional ni un manipulador para configurar la frambuesa. <br><br><h1>  1. Instalar CentOS </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P√°gina de inicio del proyecto</a> <br><br>  En el momento de escribir este art√≠culo, la versi√≥n de trabajo de CentOS en el dispositivo es de 32 bits.  En alg√∫n lugar de la inmensidad de la World Wide Web, me encontr√© con opiniones sobre la degradaci√≥n del rendimiento de dichos sistemas operativos en la arquitectura ARM de 64 bits hasta en un 20%.  Dejar√© este punto sin comentarios. <br><br>  En Linux, descargue la imagen m√≠nima con el n√∫cleo " <b>-RaspberryPI-</b> " y escr√≠bala en microSD: <br><br><pre><code class="plaintext hljs"># xzcat CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1810-sda.raw.xz | \ dd of=/dev/mmcblk0 bs=4M # sync</code> </pre> <br>  Antes de usar la imagen, elimine la secci√≥n SWAP, expanda la ra√≠z a todo el volumen disponible y elimine SELinux.  El algoritmo es simple: hacemos una copia de la ra√≠z en Linux, eliminamos todas las particiones de la microSD excepto la primera (/ boot), creamos una nueva ra√≠z y devolvemos su contenido de la copia. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de acciones necesarias (salida de consola severa)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># mount /dev/mmcblk0p3 /mnt # cd /mnt # tar cfz ~/pi.tgz . --no-selinux # cd # umount /mnt</code> </pre><br><pre> <code class="plaintext hljs"># parted /dev/mmcblk0 (parted) unit s (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 2369535s 999424s primary linux-swap(v1) 3 2369536s 5298175s 2928640s primary ext4 5298176s 31116287s 25818112s Free Space (parted) rm 3 (parted) rm 2 (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 1370112s 31116287s 29746176s Free Space (parted) mkpart Partition type? primary/extended? primary File system type? [ext2]? ext4 Start? 1370112s End? 31116287s (parted) set Partition number? 2 Flag to Invert? lba New state? on/[off]? off (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 31116287s 29746176s primary ext4 (parted) quit</code> </pre><br><pre> <code class="plaintext hljs"># mkfs.ext4 /dev/mmcblk0p2 mke2fs 1.44.6 (5-Mar-2019) /dev/mmcblk0p2 contains a swap file system labelled '_swap' Proceed anyway? (y,N) y Discarding device blocks: done Creating filesystem with 3718272 4k blocks and 930240 inodes Filesystem UUID: 6a1a0694-8196-4724-a58d-edde1f189b31 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done # mount /dev/mmcblk0p2 /mnt # tar xfz ~/pi.tgz -C /mnt --no-selinux</code> </pre><br>  Despu√©s de desempaquetar el contenido de la partici√≥n ra√≠z, es hora de hacer algunos cambios. <br><br>  Deshabilite SELinux en <b>/ mnt / etc / selinux / config</b> : <br><br><pre> <code class="plaintext hljs">SELINUX=disabled</code> </pre><br>  <b>Editamos / mnt / etc / fstab</b> , dejando solo dos entradas de partici√≥n: boot (/ boot, sin cambios) y root (cambie el valor de UUID, que se puede encontrar examinando la salida del comando blkid en Linux): <br><br><pre> <code class="plaintext hljs">UUID=6a1a0694-8196-4724-a58d-edde1f189b31 / ext4 defaults,noatime 0 0 UUID=6938-F4F2 /boot vfat defaults,noatime 0 0</code> </pre><br>  Finalmente, cambiamos los par√°metros de arranque del kernel: especificamos la nueva ubicaci√≥n de la partici√≥n ra√≠z, deshabilitamos la salida de informaci√≥n de depuraci√≥n y (opcionalmente) prohibimos que el kernel asigne direcciones IPv6 en las interfaces de red: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # mount /dev/mmcblk0p1 /mnt</code> </pre><br>  <b>Traemos el</b> contenido de <b>/mnt/cmdline.txt</b> a la siguiente forma (una l√≠nea sin gui√≥n): <br><br><pre> <code class="plaintext hljs">root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait quiet ipv6.disable_ipv6=1</code> </pre><br>  Hecho: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # sync</code> </pre><br></div></div><br>  Reorganizamos la microSD en "Malinka", la ejecutamos y obtenemos acceso de red a trav√©s de ssh (root / centos). <br><br><h1>  2. Configurando CentOS </h1><br>  Los primeros tres movimientos inquebrantables: <b>passwd</b> , <b>yum -y update</b> , <b>reinicio</b> . <br><br>  Damos administraci√≥n de red a <b>networkd</b> : <br><br><pre> <code class="plaintext hljs"># yum install systemd-networkd # systemctl enable systemd-networkd # systemctl disable NetworkManager # chkconfig network off</code> </pre><br>  Cree el archivo (junto con los directorios) <b>/etc/systemd/network/eth0.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=eth0 [Network] DHCP=ipv4</code> </pre><br>  Reiniciamos la "frambuesa" y nuevamente tenemos acceso a la red a trav√©s de ssh (la direcci√≥n IP puede cambiar).  Tenga en cuenta que se <b>utiliza /etc/resolv.conf</b> , creado previamente por Network Manager.  Por lo tanto, en caso de problemas con la resoluci√≥n, edite su contenido.  No utilizaremos <b>systemd-resolve</b> . <br><br>  Eliminamos lo "superfluo", reparamos y agilizamos la carga del sistema operativo: <br><br><pre> <code class="plaintext hljs"># systemctl set-default multi-user.target # yum remove GeoIP Network* aic* alsa* cloud-utils-growpart \ cronie* dhc* firewal* initscripts iwl* kexec* logrotate \ postfix rsyslog selinux-pol* teamd wpa_supplicant</code> </pre><br>  Qui√©n necesita <b>cron</b> y qui√©n no digiere los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">temporizadores</a> incorporados del sistema, puede instalar los que faltan.  <b>/ var / log -</b> y <b>revisa journalctl</b> .  Si necesita un historial de registro (de forma predeterminada, la informaci√≥n se almacena solo desde el momento en que se inicia el sistema): <br><br><pre> <code class="plaintext hljs"># mkdir /var/log/journal # systemd-tmpfiles --create --prefix /var/log/journal # systemctl restart systemd-journald # vi /etc/systemd/journald.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Deshabilite el uso de IPv6 por los servicios principales (si es necesario)</b> <div class="spoiler_text">  <b>/ etc / ssh / sshd_config</b> : <br><br><pre> <code class="plaintext hljs">AddressFamily inet</code> </pre><br>  <b>/ etc / sysconfig / chronyd</b> : <br><pre> <code class="plaintext hljs">OPTIONS="-4"</code> </pre><br></div></div><br>  La relevancia del tiempo en la "frambuesa" es algo importante.  Como "listo para usar" no hay capacidad de hardware para guardar el estado actual del reloj al reiniciar, necesita sincronizaci√≥n.  Un demonio muy bueno y r√°pido para esto, <b>Chrony</b> , ya est√° instalado y se inicia autom√°ticamente.  Puede cambiar los servidores NTP a la siguiente. <br><br>  <b>/etc/chrony.conf</b> : <br><br><pre> <code class="plaintext hljs">server 0.ru.pool.ntp.org iburst server 1.ru.pool.ntp.org iburst server 2.ru.pool.ntp.org iburst server 3.ru.pool.ntp.org iburst</code> </pre><br>  Usaremos el <b>truco</b> para establecer la zona horaria.  Dado que nuestro objetivo es crear un enrutador Wi-Fi que funcione a frecuencias de 5 GHz, nos prepararemos de antemano para las sorpresas <b>del regulador</b> : <br><blockquote>  # yum info crda <br>  Resumen: demonio de cumplimiento normativo para redes inal√°mbricas 802.11 <br></blockquote><br>  Este dise√±o rencoroso, centrado, entre otras cosas, en la zona horaria, "proh√≠be" el uso (en Rusia) de frecuencias de 5 GHz y canales con n√∫meros "grandes".  El truco consiste en establecer la zona horaria sin usar los nombres del continente / ciudad, es decir, en lugar de: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Europe/Moscow</code> </pre><br>  Prensa: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Etc/GMT-3</code> </pre><br>  Y los toques finales en el peinado del sistema: <br><br><pre> <code class="plaintext hljs"># hostnamectl set-hostname router</code> </pre><br>  <b>/root/.bash_profile</b> : <br><br><pre> <code class="plaintext hljs">. . . # User specific environment and startup programs export PROMPT_COMMAND="echo -n $(($(&lt;/sys/class/thermal/thermal_zone0/temp) / 1000))\'C\ " export LANG=en_US.UTF-8 export PATH=$PATH:$HOME/bin</code> </pre><br><h1>  3. Complementos CentOS </h1><br>  Todo lo que se dijo anteriormente puede considerarse instrucciones completas para instalar CentOS "vainilla" en la Raspberry Pi.  Debe tener una PC que (re) arranque en menos de 10 segundos, use menos de 15 megabytes de RAM y 1.5 gigabytes de microSD (en realidad menos de 1 gigabyte debido a un arranque / arranque incompleto, pero seremos honestos hasta el final): <br><img src="https://habrastorage.org/webt/mu/0g/cf/mu0gcfyiokq0x_2dysrb1ieh0ke.jpeg"><br><br><img src="https://habrastorage.org/webt/xx/l3/_g/xxl3_gukovfw0zawwvvy8ua0dtw.jpeg"><br><br><img src="https://habrastorage.org/webt/wt/yc/-9/wtyc-9erdcdx-rvqnnjite7c9ru.jpeg"><br><br>  Para instalar el software de punto de acceso Wi-Fi en este sistema, deber√° expandir ligeramente las capacidades de la distribuci√≥n est√°ndar de CentOS.  En primer lugar, "bombee" el controlador (firmware) del adaptador Wi-Fi incorporado.  La p√°gina de inicio del proyecto dice: <br><blockquote>  Wifi en Raspberry 3B y 3B + <br><br>  El proyecto CentOS no puede distribuir los archivos de firmware Raspberry PI 3B / 3B +.  Puede utilizar los siguientes art√≠culos para comprender el problema, obtener el firmware y configurar el wifi. <br></blockquote><br>  Lo que el proyecto CentOS no puede hacer no est√° prohibido para uso personal.  Reemplazamos el firmware de distribuci√≥n de Wi-Fi en CentOS con el correspondiente de los desarrolladores de Broadcom (esos mismos blobs binarios odiados ...).  Esto, en particular, permitir√° el uso de CA en modo de punto de acceso. <br><br><div class="spoiler">  <b class="spoiler_title">Actualizaci√≥n de firmware de Wi-Fi</b> <div class="spoiler_text">  Descubrimos el modelo del dispositivo y la versi√≥n actual del firmware: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Mar 1 2015 07:29:38 version 7.45.18 (r538002) FWID 01-6a2c8ad4 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 7.14.8 Compiler: 1.24.9 ClmImport: 1.24.9 Creation: 2014-09-02 03:05:33 Inc Data: 7.17.1 Inc Compiler: 1.26.11 Inc ClmImport: 1.26.11 Creation: 2015-03-01 07:22:34</code> </pre><br>  Vemos que la versi√≥n del firmware es 7.45.18 con fecha 01/03/2015, y recordamos el siguiente conjunto de n√∫meros: <b>43455</b> (brcmfmac43455-sdio.bin). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargue la imagen actual de Raspbian</a> .  La gente perezosa puede escribir la imagen en microSD y desde all√≠ recoger los archivos con el firmware.  Y puede montar la partici√≥n ra√≠z de la imagen en Linux y copiar la que necesita desde all√≠: <br><br><pre> <code class="plaintext hljs"># wget https://downloads.raspberrypi.org/raspbian_lite_latest # unzip -p raspbian_lite_latest &gt; raspbian.img # fdisk -l raspbian.img Disk raspbian.img: 2 GiB, 2197815296 bytes, 4292608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x17869b7d Device Boot Start End Sectors Size Id Type raspbian.img1 8192 532480 524289 256M c W95 FAT32 (LBA) raspbian.img2 540672 4292607 3751936 1.8G 83 Linux # mount -t ext4 -o loop,offset=$((540672 * 512)) raspbian.img /mnt # cp -fv /mnt/lib/firmware/brcm/*43455* ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.bin' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.clm_blob' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.txt' -&gt; ... # umount /mnt</code> </pre><br>  Los archivos de firmware resultantes para el adaptador de Wi-Fi deben copiarse con el reemplazo de la "frambuesa" en el directorio <b>/ usr / lib / firmware / brcm /</b> <br><br>  Reiniciamos el futuro enrutador y sonreiremos m√°s bien: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Feb 27 2018 03:15:32 version 7.45.154 (r684107 CY) FWID 01-4fbe0b04 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 9.10.105 Compiler: 1.29.4 ClmImport: 1.36.3 Creation: 2018-03-09 18:56:28</code> </pre><br>  Versi√≥n: 7.45.154 del 27/02/2018. <br></div></div><br>  Y por supuesto EPEL: <br><br><pre> <code class="plaintext hljs"># cat &gt; /etc/yum.repos.d/epel.repo &lt;&lt; EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF # yum clean all # rm -rfv /var/cache/yum # yum update</code> </pre><br><h1>  4. Configuraci√≥n de red y desaf√≠os futuros </h1><br>  Como acordamos anteriormente, el "Malinka" est√° conectado por un "cable" a la red local.  Suponga que un proveedor proporciona acceso a Internet exactamente de la misma manera: una direcci√≥n en una red p√∫blica es emitida din√°micamente por un servidor DHCP (puede vincularse a un MAC).  En este caso, despu√©s de la configuraci√≥n final de la "frambuesa", es suficiente "enchufar" el cable del proveedor y todo est√° listo.  La autorizaci√≥n mediante <b>systemd-networkd</b> es el tema de un art√≠culo separado y no se considera aqu√≠. <br><br>  La (s) interfaz (es) Wi-Fi de Raspberry es una red local, y el adaptador Ethernet incorporado (eth0) es externo.  Numeramos la red local est√°ticamente, por ejemplo: 192.168.0.0/24.  Direcci√≥n de Malinka: 192.168.0.1.  En una red externa (Internet) funcionar√° un servidor DHCP. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema de la uniformidad de los nombres</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">famoso programador guatemalteco</a> son dos problemas que esperan a todos los involucrados en la configuraci√≥n de interfaces de red y servicios en las distribuciones de systemd. <br><br><div class="spoiler">  <b class="spoiler_title">Caos Paralelo (digresi√≥n l√≠rica)</b> <div class="spoiler_text">  Lennart Pottering hizo su programa <b>systemd</b> muy bien.  Este sistema lanza otros programas tan r√°pido que, al no haberse recuperado del silbato del √°rbitro, tropiezan y caen al inicio sin siquiera comenzar su carrera de obst√°culos. <br><br>  Pero, en serio, la paralelizaci√≥n agresiva de los procesos lanzados al comienzo del systemd-OS es una especie de "puente de burro" para los controladores LSB seriales experimentados.  Afortunadamente, ordenar este "caos paralelo" resulta ser simple, aunque la verdad no siempre es obvia. <br></div></div><br>  Creamos dos interfaces de puente virtual con nombres constantes: <b>lan</b> y <b>wan</b> .  "Conectaremos" los adaptadores de Wi-Fi al primero y eth0 de la "frambuesa" al segundo. <br><br>  <b>/etc/systemd/network/lan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=lan Kind=bridge</code> </pre><br>  <b>/etc/systemd/network/lan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=lan [Network] Address=192.168.0.1/24 IPForward=yes</code> </pre><br>  <b>/etc/systemd/network/wan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=wan Kind=bridge #MACAddress=xx:xx:xx:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=wan [Network] DHCP=ipv4 IPForward=yes</code> </pre><br>  <b>IPForward = yes</b> elimina la necesidad de insinuar el n√∫cleo a trav√©s de sysctl para habilitar el enrutamiento. <br>  <b>MACAddress =</b> descomentar y cambiar si es necesario. <br><br>  Primero, conectamos eth0.  Recuerde el "problema de uniformidad" y use solo la direcci√≥n MAC de esta interfaz, que puede encontrar, por ejemplo, as√≠: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/eth0/address</code> </pre><br>  Cree <b>/etc/systemd/network/eth.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Network] Bridge=wan</code> </pre><br>  Elimine el archivo de configuraci√≥n eth0 anterior, reinicie la "frambuesa" y obtenga acceso de red (es probable que la direcci√≥n IP cambie): <br><br><pre> <code class="plaintext hljs"># rm -fv /etc/systemd/network/eth0.network # reboot</code> </pre><br><h1>  5. DNSMASQ </h1><br>  Para la fabricaci√≥n de puntos de acceso Wi-Fi, nada mejor que una dulce pareja de <b>dnsmasq</b> + <b>hostapd</b> a√∫n no se ha inventado.  En mi opinion. <br><br><div class="spoiler">  <b class="spoiler_title">Si alguien lo olvid√≥, entonces ...</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hostapd</a> es una cosa que gestiona los adaptadores de Wi-Fi (en particular, tomar√° la molestia de conectarlos a la <b>LAN</b> virtual de la frambuesa), autoriza y registra clientes inal√°mbricos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dnsmasq</a> : configura la pila de red de clientes: proporciona direcciones IP, servidores DNS, una puerta de enlace predeterminada y similares. <br></div></div><br>  Comenzamos con dnsmasq: <br><br><pre> <code class="plaintext hljs"># yum install dnsmasq</code> </pre><br>  Plantilla <b>/etc/resolv.conf</b> : <br><br><pre> <code class="plaintext hljs">nameserver 1.1.1.1 nameserver 1.0.0.1 nameserver 8.8.8.8 nameserver 8.8.4.4 nameserver 77.88.8.8 nameserver 77.88.8.1 domain router.local search router.local</code> </pre><br>  ed√≠talo a tu gusto. <br><br>  Minimalista <b>/etc/dnsmasq.conf</b> : <br><br><pre> <code class="plaintext hljs">domain-needed bogus-priv interface=lan bind-dynamic expand-hosts domain=# dhcp-range=192.168.0.100,192.168.0.199,255.255.255.0,24h conf-dir=/etc/dnsmasq.d</code> </pre><br>  La "magia" aqu√≠ es el par√°metro <b>bind-dynamic</b> , que le dice al dnsmasq daemon que espere <b>a que</b> aparezca <b>interface = lan</b> en el sistema, y ‚Äã‚Äãque no se desmaye de un ataque de orgullosa soledad despu√©s del comienzo. <br><br><pre> <code class="plaintext hljs"># systemctl enable dnsmasq # systemctl start dnsmasq; journalctl -f</code> </pre><br><h1>  6. HOSTAPD </h1><br>  Finalmente, las configuraciones m√°gicas de hostapd.  No tengo dudas de que alguien est√° leyendo este art√≠culo en busca precisamente de estas preciadas l√≠neas. <br><br>  Antes de instalar hostapd, debe lidiar con el "problema de uniformidad".  El adaptador de Wi-Fi incorporado wlan0 puede cambiar f√°cilmente su nombre a wlan1 cuando se conecta un equipo de USB Wi-Fi adicional.  Por lo tanto, arreglamos los nombres de las interfaces de la siguiente manera: crearemos nombres √∫nicos de adaptadores (inal√°mbricos) y los vincularemos a las direcciones MAC. <br><br>  Para el adaptador de Wi-Fi incorporado, que todav√≠a es wlan0: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b8:27:eb:xx:xx:xx</code> </pre><br>  Cree <b>/etc/systemd/network/wl0.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Link] Name=wl0</code> </pre><br>  Ahora nos aseguraremos de que <b>wl0</b> sea ‚Äã‚Äãel Wi-Fi incorporado.  Reiniciamos la "frambuesa" para ver esto. <br><br>  Instalar: <br><br><pre> <code class="plaintext hljs"># yum install hostapd wireless-tools</code> </pre><br>  Archivo de configuraci√≥n <b>/etc/hostapd/hostapd.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi wpa_passphrase=1234567890 channel=36 country_code=US interface=wl0 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=a wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[MAX-AMSDU-3839][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40] # AC ieee80211ac=1 require_vht=1 ieee80211d=0 ieee80211h=0 vht_capab=[MAX-AMSDU-3839][SHORT-GI-80] vht_oper_chwidth=1 vht_oper_centr_freq_seg0_idx=42</code> </pre><br>  Sin olvidar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GKChP</a> por un minuto, cambiamos los par√°metros que necesitamos y verificamos manualmente el rendimiento: <br><br><pre> <code class="plaintext hljs"># hostapd /etc/hostapd/hostapd.conf</code> </pre><br>  hostapd comenzar√° interactivamente, traduciendo su estado a la consola.  Si no hay errores, los clientes que admiten el modo AC ya pueden conectarse al punto de acceso.  Para detener hostapd - Ctrl-C. <br><br>  Queda por incluir hostapd en el inicio del sistema.  Si act√∫a de manera est√°ndar (systemctl enable hostapd), luego del pr√≥ximo reinicio, puede obtener un "demonio en la sangre" de un demonio con un diagn√≥stico de " <b>interfaz wl0 no encontrada</b> ".  Como resultado del "caos paralelo", hostapd termin√≥ m√°s r√°pido de lo que el n√∫cleo encontr√≥ un adaptador inal√°mbrico. <br><br>  Internet est√° lleno de medicamentos: desde el tiempo de espera forzado antes de que comience el demonio (durante unos minutos), hasta otro demonio que monitorea la apariencia de la interfaz y (re) inicia el hostpad.  Las soluciones funcionan bastante, pero son terriblemente feas.  Pedimos ayuda al gran <b>systemd</b> con sus "objetivos" y " <s>tareas</s> " "dependencias". <br><br>  Copie el archivo del servicio de distribuci√≥n en <b>/etc/systemd/system/hostapd.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system</code> </pre><br>  y llevar su contenido a la siguiente forma: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl0.device BindsTo=sys-subsystem-net-devices-wl0.device [Service] Type=forking PIDFile=/run/hostapd.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd.conf -P /run/hostapd.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl0.device</code> </pre><br>  La magia del archivo de servicio actualizado es vincular din√°micamente hostapd a un nuevo objetivo: la interfaz wl0.  Cuando aparece la interfaz, se inicia el demonio; cuando desaparece, se detiene.  Y todo est√° en l√≠nea, sin reiniciar el sistema.  Especialmente esta t√©cnica ser√° √∫til cuando se conecte al adaptador USB Wi-Fi "frambuesa". <br><br>  Ahora puedes: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd # reboot</code> </pre><br><h1>  7. IPTABLES </h1><br>  "Shta ???"  ¬© ¬°S√≠, s√≠!  No <b>systemd</b> .  No hay cosechadoras novedosas (en forma de <b>firewalld</b> ), que finalmente hacen lo mismo. <br><br>  Utilizamos las buenas y antiguas <b>iptables</b> , cuyos servicios, despu√©s de su inicio, subir√°n las reglas de red al n√∫cleo y se cerrar√°n silenciosamente sin permanecer residentes y sin consumir recursos.  Systemd tiene una elegante <b>IPMasquerade =</b> , pero a√∫n confiaremos a iptables con traducci√≥n de direcciones (NAT) y firewall. <br><br>  Instalar: <br><br><pre> <code class="plaintext hljs"># yum install iptables-services # systemctl enable iptables ip6tables</code> </pre><br>  Prefiero almacenar la configuraci√≥n de iptables como un script (ejemplo): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # Disable IPv6 # ip6tables --flush ip6tables --delete-chain ip6tables --policy INPUT DROP ip6tables --policy FORWARD DROP ip6tables --policy OUTPUT DROP ip6tables-save &gt; /etc/sysconfig/ip6tables systemctl restart ip6tables # # Cleaning # iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables -t mangle -F iptables -t mangle -X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT # # Loopback, lan # iptables -A INPUT -i lo -j ACCEPT iptables -A INPUT -i lan -j ACCEPT # # Ping, Established # iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # # NAT # iptables -t nat -A POSTROUTING -o wan -j MASQUERADE # # Saving # iptables-save &gt; /etc/sysconfig/iptables systemctl restart iptables</span></span></code> </pre><br>  Ejecutamos el script anterior y perdemos la capacidad de establecer nuevas conexiones ssh cableadas con el "Malinka".  As√≠ es, creamos un enrutador Wi-Fi, cuyo acceso "por Internet" est√° prohibido por defecto, ahora solo "por aire".  ¬°Conectamos el cable del proveedor a Ethernet y comenzamos a navegar! <br><br><h1>  8. Bonificaci√≥n: + 2.4GHz </h1><br>  Cuando ensambl√© el primer enrutador Raspberry del dibujo descrito anteriormente, descubr√≠ en mi granja varios dispositivos que, debido a sus limitaciones de dise√±o, el Wi-Fi no pod√≠a ver la "frambuesa" en absoluto.  La reconfiguraci√≥n del enrutador para que funcione en 802.11b / g / n fue antideportiva, ya que la velocidad m√°xima "inal√°mbrica" ‚Äã‚Äãen este caso no super√≥ los 40 Mbps, y mi proveedor de Internet favorito me ofrece 100 (por cable). <br><br>  De hecho, ya se ha inventado una soluci√≥n al problema: una segunda interfaz Wi-Fi que funciona a 2,4 GHz y un segundo punto de acceso.  En el puesto m√°s cercano, compr√© no el primero, sino el segundo "silbato" de Wi-Fi USB que me lleg√≥.  El vendedor fue atormentado por preguntas sobre el conjunto de chips, la compatibilidad con los n√∫cleos ARM de Linux y la posibilidad de trabajar en modo AP (comenz√≥ por primera vez). <br><br>  Configuramos el "silbato" por analog√≠a con el adaptador de Wi-Fi incorporado. <br><br>  Primero, <b>c√°mbiele el</b> nombre a <b>wl1</b> : <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b0:6e:bf:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wl1.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b0:6e:bf:xx:xx:xx [Link] Name=wl1</code> </pre><br>  Confiaremos la administraci√≥n de la nueva interfaz Wi-Fi a un demonio hostapd separado, que comenzar√° y se detendr√° dependiendo de la presencia de un "silbato" estrictamente definido en el sistema: wl1. <br><br>  Archivo de configuraci√≥n <b>/etc/hostapd/hostapd2.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi2 wpa_passphrase=1234567890 #channel=1 #channel=6 channel=11 interface=wl1 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=g wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[HT40][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]</code> </pre><br>  El contenido de este archivo depende directamente del modelo del adaptador USB Wi-Fi, por lo que una copia / pegado trivial puede decepcionarte. <br><br>  Copie el archivo del servicio de distribuci√≥n en <b>/etc/systemd/system/hostapd2.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system/hostapd2.service</code> </pre><br>  y llevar su contenido a la siguiente forma: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl1.device BindsTo=sys-subsystem-net-devices-wl1.device [Service] Type=forking PIDFile=/run/hostapd2.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd2.conf -P /run/hostapd2.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl1.device</code> </pre><br>  Queda por incluir una nueva instancia de hostapd: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd2</code> </pre><br>  Eso es todo!  Haz sonar el silbato y la frambuesa en s√≠, mira las redes inal√°mbricas alrededor. <br><br>  Y, por √∫ltimo, quiero advertir sobre la calidad del adaptador USB Wi-Fi y la fuente de alimentaci√≥n Raspberry.  Conectado "a un silbato", a veces puede causar un "bloqueo de frambuesa" debido a problemas el√©ctricos a corto plazo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458994/">https://habr.com/ru/post/458994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458984/index.html">C√≥mo crear la primera aplicaci√≥n para operar en el intercambio: 3 pasos iniciales</a></li>
<li><a href="../458986/index.html">Recetas PostgreSQL: conversi√≥n de HTML y URL a PDF y PS</a></li>
<li><a href="../458988/index.html">Texturizado, o lo que necesitas saber para convertirte en un Artista de Surface. Parte 4. Modelos, normales y barrido</a></li>
<li><a href="../458990/index.html">Deja de celoso con comentarios en el c√≥digo</a></li>
<li><a href="../458992/index.html">Atenci√≥n para dummies e implementaci√≥n en Keras</a></li>
<li><a href="../458996/index.html">User Inyerface: c√≥mo no atormentar al usuario</a></li>
<li><a href="../459000/index.html">C√≥mo intent√© mejorar Halo 2, pero casi lo arruin√©</a></li>
<li><a href="../459002/index.html">C√≥mo configurar HTTPS - SSL Configuration Generator ayudar√°</a></li>
<li><a href="../459004/index.html">Algoritmo criptogr√°fico Grasshopper: casi el complejo</a></li>
<li><a href="../459012/index.html">Crear una aplicaci√≥n para Bitrix24 desde cero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>