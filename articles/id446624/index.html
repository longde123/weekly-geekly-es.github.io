<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏻 🔔 🚶🏼 Indeks dalam PostgreSQL - 6 (SP-GiST) 🛴 🏯 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah membahas mesin pengindeksan PostgreSQL, antarmuka metode akses , dan tiga metode: indeks hash , B-tree , dan GiST . Pada artikel ini, kami ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Kami telah membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka metode akses</a> , dan tiga metode: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> .  Pada artikel ini, kami akan menjelaskan SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Pertama, beberapa kata tentang nama ini.  Bagian "GiST" menyinggung beberapa kesamaan dengan metode akses nama yang sama.  Kesamaan memang ada: keduanya pohon pencarian umum yang menyediakan kerangka kerja untuk membangun berbagai metode akses. <br><br>  "SP" adalah singkatan dari partisi ruang.  Ruang di sini sering kali biasa kita sebut ruang, misalnya, bidang dua dimensi.  Tetapi kita akan melihat bahwa ruang pencarian apa pun dimaksudkan, yaitu, sebenarnya domain nilai apa pun. <br><br>  SP-GiST cocok untuk struktur di mana ruang dapat dibelah secara rekursif menjadi area yang <em>tidak berpotongan</em> .  Kelas ini terdiri dari quadtrees, pohon k-dimensional (pohon kD), dan pohon radix. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Jadi, ide metode akses SP-GiST adalah untuk membagi domain nilai menjadi subdomain yang tidak <em>tumpang tindih yang</em> masing-masing, pada gilirannya, juga dapat dibagi.  Pemisahan seperti ini menyebabkan pohon tidak <em>seimbang</em> (tidak seperti pohon B dan GiST biasa). <br><br>  Sifat tidak berpotongan menyederhanakan pengambilan keputusan selama penyisipan dan pencarian.  Di sisi lain, sebagai suatu peraturan, pohon yang diinduksi adalah bercabang rendah.  Sebagai contoh, sebuah simpul quadtree biasanya memiliki empat node anak (tidak seperti B-tree, di mana jumlah node mencapai ratusan) dan kedalaman yang lebih besar.  Pohon-pohon seperti ini cocok dengan pekerjaan dalam RAM, tetapi indeks disimpan pada disk dan oleh karena itu, untuk mengurangi jumlah operasi I / O, node harus dimasukkan ke dalam halaman, dan tidak mudah untuk melakukan ini secara efisien.  Selain itu, waktu yang diperlukan untuk menemukan nilai yang berbeda dalam indeks, dapat bervariasi karena perbedaan kedalaman cabang. <br><br>  Metode akses ini, sama seperti GiST, menangani tugas-tugas tingkat rendah (akses dan kunci simultan, logging, dan algoritma pencarian murni) dan menyediakan antarmuka yang disederhanakan khusus untuk memungkinkan menambahkan dukungan untuk tipe data baru dan untuk algoritma partisi baru. <br><br>  Node internal pohon SP-GiST menyimpan referensi ke node anak;  <em>label</em> dapat didefinisikan untuk setiap referensi.  Selain itu, simpul internal dapat menyimpan nilai yang disebut <em>awalan</em> .  Sebenarnya nilai ini bukan merupakan awalan wajib;  itu dapat dianggap sebagai predikat sewenang-wenang yang dipenuhi untuk semua node anak. <br><br>  Node daun SP-GiST berisi nilai dari tipe yang diindeks dan referensi ke baris tabel (TID).  Data yang diindeks itu sendiri (kunci pencarian) dapat digunakan sebagai nilai, tetapi tidak wajib: nilai yang dipersingkat dapat disimpan. <br><br>  Selain itu, node daun dapat dikelompokkan ke dalam daftar.  Jadi, sebuah simpul internal dapat merujuk tidak hanya satu nilai, tetapi seluruh daftar. <br><br>  Perhatikan bahwa awalan, label, dan nilai dalam node daun memiliki tipe datanya sendiri, tidak tergantung satu sama lain. <br><br>  Sama seperti di GiST, fungsi utama untuk menentukan untuk pencarian adalah <em>fungsi konsistensi</em> .  Fungsi ini dipanggil untuk simpul pohon dan mengembalikan satu set simpul anak yang nilainya "konsisten" dengan predikat pencarian (seperti biasa, dalam bentuk " <em>ekspresi operator bidang-bidang</em> ").  Untuk simpul daun, fungsi konsistensi menentukan apakah nilai yang diindeks dalam simpul ini memenuhi predikat pencarian. <br><br>  Pencarian dimulai dengan root node.  Fungsi konsistensi memungkinkan untuk mengetahui simpul anak mana yang masuk akal untuk dikunjungi.  Algoritme berulang untuk setiap node yang ditemukan.  Pencarian adalah kedalaman-pertama. <br><br>  Pada tingkat fisik, indeks node dikemas ke dalam halaman untuk membuat pekerjaan dengan node efisien dari sudut pandang operasi I / O.  Perhatikan bahwa satu halaman dapat berisi node internal atau daun, tetapi tidak keduanya. <br><br><h2>  Contoh: quadtree </h2><br>  Quadtree digunakan untuk mengindeks poin dalam sebuah pesawat.  Gagasannya adalah membagi daerah secara rekursif menjadi empat bagian (kuadran) sehubungan dengan <em>titik pusat</em> .  Kedalaman cabang di pohon seperti itu dapat bervariasi dan tergantung pada kepadatan titik di kuadran yang sesuai. <br><br>  Ini terlihat seperti dalam gambar, dengan contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database demo</a> ditambah oleh bandara dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openflights.org</a> .  Ngomong-ngomong, baru-baru ini kami merilis versi baru dari database di mana, di antara yang lain, kami mengganti bujur dan lintang dengan satu bidang tipe "titik". <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Pertama, kami membagi pesawat menjadi empat kuadran ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Lalu kami membagi masing-masing kuadran ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Dan seterusnya sampai kita mendapatkan partisi terakhir.</em> <br><br>  Mari kita berikan lebih banyak detail dari contoh sederhana yang telah kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahas dalam artikel terkait GiST</a> .  Lihat seperti apa tampilan partisi dalam kasus ini: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Kuadran diberi nomor seperti yang ditunjukkan pada gambar pertama.  Demi kepastian, mari kita tempatkan node anak dari kiri ke kanan tepat dalam urutan yang sama.  Struktur indeks yang mungkin dalam hal ini ditunjukkan pada gambar di bawah ini.  Setiap simpul internal merujuk maksimal empat simpul anak.  Setiap referensi dapat diberi label dengan nomor kuadran, seperti pada gambar.  Tetapi tidak ada label dalam implementasi karena lebih mudah untuk menyimpan array tetap dari empat referensi yang beberapa di antaranya bisa kosong. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Poin yang terletak pada batas berkaitan dengan kuadran dengan jumlah yang lebih kecil. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  Dalam hal ini, kelas operator "quad_point_ops" digunakan secara default, yang berisi operator berikut: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Misalnya, mari kita lihat bagaimana kueri <code>select * from points where p &gt;^ point '(2,7)'</code> akan dilakukan (temukan semua titik yang terletak di atas yang diberikan). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Kita mulai dengan simpul root dan menggunakan fungsi konsistensi untuk memilih ke mana simpul anak diturunkan.  Untuk operator <code>&gt;^</code> , fungsi ini membandingkan titik (2,7) dengan titik pusat simpul (4,4) dan memilih kuadran yang mungkin mengandung titik yang dicari, dalam hal ini, kuadran pertama dan keempat. <br><br>  Dalam node yang sesuai dengan kuadran pertama, kami kembali menentukan node anak menggunakan fungsi konsistensi.  Titik pusatnya adalah (6,6), dan kita kembali perlu melihat kuadran pertama dan keempat. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  Daftar node daun (8.6) dan (7.8) sesuai dengan kuadran pertama, yang hanya titik (7,8) yang memenuhi kondisi kueri.  Referensi ke kuadran keempat kosong. <br><br>  Di simpul internal (4.4), referensi ke kuadran keempat juga kosong, yang melengkapi pencarian. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Internal </h3><br>  Kita dapat menjelajahi struktur internal indeks SP-GiST menggunakan ekstensi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gevel</a> ", yang disebutkan sebelumnya.  Berita buruknya adalah karena bug, ekstensi ini berfungsi secara salah dengan versi modern PostgreSQL.  Berita baiknya adalah kami berencana menambah "pageinspect" dengan fungsionalitas "gevel" ( <a href="">diskusi</a> ).  Dan bug sudah diperbaiki di "pageinspect". <br><blockquote>  Sekali lagi, berita buruknya adalah tambalan itu macet tanpa kemajuan. <br></blockquote><br>  Sebagai contoh, mari kita ambil basis data demo yang diperluas, yang digunakan untuk menggambar dengan peta dunia. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Pertama, kita bisa mendapatkan beberapa statistik untuk indeks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Dan kedua, kita dapat menampilkan pohon indeks itu sendiri: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Tetapi perlu diingat bahwa "spgist_print" menampilkan tidak semua nilai daun, tetapi hanya yang pertama dari daftar, dan karena itu menunjukkan struktur indeks daripada konten lengkapnya. <br><br><h2>  Contoh: pohon k-dimensional </h2><br>  Untuk titik-titik yang sama di pesawat, kami juga dapat menyarankan cara lain untuk mempartisi ruang. <br><br>  Mari menggambar <em>garis horizontal</em> melalui titik pertama yang diindeks.  Membagi pesawat menjadi dua bagian: atas dan bawah.  Titik kedua yang akan diindeks jatuh ke dalam salah satu bagian ini.  Melalui titik ini, mari kita menggambar <em>garis vertikal</em> , yang membagi bagian ini menjadi dua yang: kanan dan kiri.  Kita lagi menggambar garis horizontal melalui titik berikutnya dan garis vertikal melalui titik berikutnya, dan seterusnya. <br><br>  Semua simpul internal pohon yang dibangun dengan cara ini hanya akan memiliki dua simpul anak.  Masing-masing dari dua referensi dapat mengarah ke node internal yang berikutnya dalam hierarki atau ke daftar node daun. <br><br>  Metode ini dapat dengan mudah digeneralisasikan untuk ruang dimensi k, dan oleh karena itu, pohon juga disebut dimensi k (pohon kD) dalam literatur. <br><br>  Menjelaskan metode dengan contoh bandara: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Pertama kami membagi pesawat menjadi bagian atas dan bawah ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Lalu kami membagi setiap bagian menjadi bagian kiri dan kanan ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Dan seterusnya sampai kita mendapatkan partisi terakhir.</em> <br><br>  Untuk menggunakan partisi seperti ini, kita perlu secara eksplisit menentukan kelas operator <strong>"kd_point_ops"</strong> saat membuat indeks. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Kelas ini mencakup operator yang sama persis dengan kelas "default" "quad_point_ops". <br><br><h3>  Internal </h3><br>  Ketika melihat melalui struktur pohon, kita perlu memperhitungkan bahwa awalan dalam kasus ini hanya satu koordinat daripada satu titik: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Contoh: pohon radix </h2><br>  Kita juga bisa menggunakan SP-GiST untuk mengimplementasikan pohon radix untuk string.  Gagasan pohon radix adalah bahwa string yang akan diindeks tidak sepenuhnya disimpan dalam simpul daun, tetapi diperoleh dengan menggabungkan nilai-nilai yang disimpan dalam node di atas yang satu ini sampai ke root. <br><br>  Asumsikan, kita perlu mengindeks URL situs: "postgrespro.ru", "postgrespro.com", "postgresql.org", dan "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  Pohon itu akan terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Node internal prefix store tree umum untuk semua node anak.  Misalnya, dalam simpul anak "stgres", nilai dimulai dengan "p" + "o" + "stgres". <br><br>  Tidak seperti di quadtrees, setiap pointer ke simpul anak juga diberi label dengan satu karakter (lebih tepatnya, dengan dua byte, tetapi ini tidak begitu penting). <br><br>  "Text_ops" kelas operator mendukung operator mirip-Pohon: "sama", "lebih besar", dan "kurang": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  Perbedaan operator dengan tilde adalah mereka memanipulasi <em>byte</em> daripada <em>karakter</em> . <br><br>  Kadang-kadang, representasi dalam bentuk pohon radix dapat berubah menjadi jauh lebih kompak daripada B-pohon karena nilai-nilai tidak sepenuhnya disimpan, tetapi direkonstruksi karena kebutuhan muncul saat turun melalui pohon. <br><br>  Pertimbangkan kueri: <code>select * from sites where url like 'postgresp%ru'</code> .  Itu dapat dilakukan dengan menggunakan indeks: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  Sebenarnya, indeks digunakan untuk menemukan nilai yang lebih besar atau sama dengan "postgresp", tetapi kurang dari "postgresq" (Indeks Cond), dan kemudian nilai yang cocok dipilih dari hasil (Filter). <br><br>  Pertama, fungsi konsistensi harus memutuskan ke simpul anak mana dari akar "p" yang perlu kita turunkan.  Tersedia dua opsi: "p" + "l" (tidak perlu turun, yang jelas bahkan tanpa menyelam lebih dalam) dan "p" + "o" + "stgres" (lanjutkan penurunan). <br><br>  Untuk simpul "stgres", panggilan ke fungsi konsistensi diperlukan lagi untuk memeriksa "postgres" + "p" + "ro."  (lanjutkan penurunan) dan "postgres" + "q" (tidak perlu turun). <br><br>  Untuk "ro."  simpul dan semua simpul daun anaknya, fungsi konsistensi akan merespons "ya", sehingga metode indeks akan mengembalikan dua nilai: "postgrespro.com" dan "postgrespro.ru".  Satu nilai yang cocok akan dipilih dari mereka pada tahap penyaringan. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Internal </h3><br>  Saat melihat melalui struktur pohon, kita perlu mempertimbangkan tipe data: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Properti </h2><br>  Mari kita lihat properti dari metode akses SP-GiST (pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disediakan sebelumnya</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  Indeks SP-GiST tidak dapat digunakan untuk menyortir dan untuk mendukung kendala unik.  Selain itu, indeks seperti ini tidak dapat dibuat di beberapa kolom (tidak seperti GiST).  Tetapi diizinkan untuk menggunakan indeks tersebut untuk mendukung batasan pengecualian. <br><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Perbedaan dari GiST di sini adalah bahwa pengelompokan tidak mungkin. <br><br>  Dan akhirnya yang berikut adalah properti kolom-layer: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  Penyortiran tidak didukung, yang dapat diprediksi.  Operator jarak untuk mencari tetangga terdekat tidak tersedia di SP-GiST sejauh ini.  Kemungkinan besar, fitur ini akan didukung di masa depan. <br><blockquote>  Ini didukung di PostgreSQL 12 mendatang, tambalan oleh Nikita Glukhov. <br></blockquote><br>  SP-GiST dapat digunakan untuk pemindaian hanya indeks, setidaknya untuk kelas operator yang dibahas.  Seperti yang telah kita lihat, dalam beberapa kasus, nilai-nilai yang diindeks secara eksplisit disimpan dalam simpul daun, sementara di yang lain, nilai-nilai tersebut direkonstruksi bagian demi bagian selama penurunan pohon. <br><br><h3>  Nulls </h3><br>  Tidak menyulitkan gambar, kami belum menyebutkan NULL sejauh ini.  Jelas dari properti indeks bahwa NULL didukung.  Sungguh: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  Namun, NULL adalah sesuatu yang asing bagi SP-GiST.  Semua operator dari kelas operator "spgist" harus ketat: operator harus mengembalikan NULL setiap kali salah satu parameternya adalah NULL.  Metode itu sendiri memastikan ini: NULL tidak diteruskan ke operator. <br><br>  Tetapi untuk menggunakan metode akses untuk pemindaian hanya indeks, NULL harus tetap disimpan dalam indeks.  Dan mereka disimpan, tetapi di pohon yang terpisah dengan akarnya sendiri. <br><br><h2>  Tipe data lainnya </h2><br>  Selain poin dan pohon radix untuk string, metode lain berdasarkan SP-GiST juga diterapkan PostgreSQL: <br><br><ul><li>  Kelas operator Box_ops menyediakan quadtree untuk persegi panjang. <br>  Setiap <em>persegi panjang</em> diwakili oleh <em>sebuah titik dalam ruang empat dimensi</em> , sehingga jumlah kuadran sama dengan 16. Indeks seperti ini dapat mengalahkan GiST dalam kinerja ketika ada banyak persimpangan dari persegi panjang: di GiST tidak mungkin untuk menggambar batas sehingga untuk memisahkan objek berpotongan satu sama lain, sementara tidak ada masalah dengan poin (bahkan empat dimensi). <br></li><li>  "Range_ops" kelas operator menyediakan quadtree untuk interval. <br>  <em>Interval</em> diwakili oleh <em>titik dua dimensi</em> : batas bawah menjadi absis, dan batas atas menjadi ordinat. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446624/">https://habr.com/ru/post/id446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446612/index.html">Saat kami mulai percaya pada inovasi</a></li>
<li><a href="../id446614/index.html">Sistem file virtual Linux: mengapa mereka diperlukan dan bagaimana cara kerjanya? Bagian 1</a></li>
<li><a href="../id446616/index.html">Bagaimana kami melakukan cloud FaaS di dalam Kubernetes dan menang di Tinkoff Hackathon</a></li>
<li><a href="../id446620/index.html">DataGrip 2019.1: dukungan untuk database baru, skrip inisialisasi, inspeksi baru dan banyak lagi</a></li>
<li><a href="../id446622/index.html">Berita di 11</a></li>
<li><a href="../id446626/index.html">Kaspersky Mobile Talks # 1. Multi-modularitas</a></li>
<li><a href="../id446628/index.html">Beri lebih banyak HighLoad ++: mulai Senin di St. Petersburg</a></li>
<li><a href="../id446630/index.html">Bagaimana memilih printer 3D, atau mengapa Anda membutuhkan meja pemanas dan kamera tertutup</a></li>
<li><a href="../id446632/index.html">Dari Hukum ke Pengembangan Data Besar</a></li>
<li><a href="../id446634/index.html">Digest SDN - Enam Emulator Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>