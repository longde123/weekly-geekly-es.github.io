<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 👩🏼‍🏫 👨🏼‍🌾 Widgets pilotés par la souris. Glissez et déposez dans la fenêtre 😮 🏠 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La compréhension habituelle du glisser-déposer (D&D) suppose que, par exemple, un lien vers un fichier est extrait d'un widget et déplacé avec la sour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Widgets pilotés par la souris. Glissez et déposez dans la fenêtre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473716/"><p> La compréhension habituelle du glisser-déposer (D&amp;D) suppose que, par exemple, un lien vers un fichier est extrait d'un widget et déplacé avec la souris vers une autre fenêtre ou widget.  Ensuite, nous ne parlerons pas des fonctions de bibliothèque de D&amp;D, mais de notre propre implémentation de déplacement du widget dans la fenêtre et des fonctionnalités associées.  Le code est plus par exemple qu'une application pratique concrète, écrite en style C avec des classes.  L'éditeur est CodeBlocks 17.12, qui a cessé de planter sur Ubuntu x64 par rapport à la 16e version. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/e1/2g/ve/e12gvery3tvo4tlu5z_2mrdkppy.png" alt="image"></div><a name="habracut"></a><br><p>  Il existe un conteneur de widgets GtkFixed, qui peut stocker d'autres widgets à certaines coordonnées, le concept classique de création d'applications sur GTK implique l'utilisation de conteneurs de widgets GtkBox (et autres) pour étirer correctement la fenêtre et remplir l'espace.  Le conteneur est soit étiré à la taille de la fenêtre (et aux bordures des autres widgets), soit réduit à la taille du widget enfant en règle générale. <br></p><p>  Le code est divisé en main.cpp, main.hpp, movable_widgets.hpp.  Je n'ai pas sélectionné le fichier d'implémentation séparément.  Le contenu de main.cpp est assez typique: <br><br></p><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movable_widgets.hpp"</span></span></span><span class="hljs-meta"> void builder_init(gpointer user_data) { appdata *data=(appdata*) user_data; GError *</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = NULL; GtkBuilder *builder = gtk_builder_new(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!gtk_builder_add_from_file (builder, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"window.glade"</span></span></span><span class="hljs-meta">, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     g_critical ("   : %s", error-&gt;message); g_error_free (error); } data-&gt;win=GTK_WIDGET(gtk_builder_get_object(builder, "window1")); data-&gt;notebook=GTK_NOTEBOOK(gtk_builder_get_object(builder, "notebook1")); gtk_notebook_remove_page(data-&gt;notebook,0); ///    gtk_builder_connect_signals (builder,data); g_clear_object(&amp;builder); } void application_activate(GtkApplication *application, gpointer user_data) { appdata *data=(appdata*) user_data; builder_init(data); gtk_widget_set_size_request(data-&gt;win,320,240); gtk_application_add_window(data-&gt;app,GTK_WINDOW(data-&gt;win)); page_body *page=new page_body(data, G_OBJECT(data-&gt;notebook)); const gchar *text ="&lt;span foreground=\"blue\" size=\"x-large\"&gt;Blue text&lt;/span&gt;" ; GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), text); GtkWidget *image=gtk_image_new_from_file("opennet2.gif"); GtkWidget *image2=gtk_image_new_from_file("n_temp.png"); page-&gt;add_widget(label,label_t,10,10); page-&gt;add_widget(image,image_t,20,20); page-&gt;add_widget(image2,image_t,40,40); gtk_widget_show_all(data-&gt;win); } void application_shutdown(const GtkApplication *application, gpointer user_data) {} int main (int argc, char *argv[]) { appdata data; gtk_init (&amp;argc, &amp;argv); gint res; data.app = gtk_application_new("gtk3.org", G_APPLICATION_FLAGS_NONE); g_signal_connect(data.app, "activate", G_CALLBACK(application_activate), &amp;data); g_signal_connect(data.app, "shutdown", G_CALLBACK(application_shutdown), &amp;data); res = g_application_run(G_APPLICATION(data.app), 0, NULL); return 0; }</span></span></span></span></code> </pre> <br><p>  Certains widgets sont créés à partir d'une description XML (fonction builder_init), une autre partie par programmation (page-&gt; add_widget).  Fonction Gtk_widget_show_all (data-&gt; win);  nécessaire pour l'affichage récursif des widgets et de leur contenu.  GTK efface indépendamment le contenu des widgets lorsqu'ils sont supprimés, en particulier d'autres widgets enfants.  Au moment où la fonction de rappel application_shutdown est exécutée, la fenêtre principale et tous les widgets de contenu ont déjà été supprimés. <br></p><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdlib.h&gt; #define restrict __restrict__ class appdata { public: char *glade_name=(char*)"window.glade"; GtkApplication *restrict app; GtkWidget *restrict win; GtkNotebook *restrict notebook; GArray *restrict pages; }; #endif</span></span></span></span></code> </pre><br>  Le champ des pages est un tableau de pointeurs vers les classes avec le contenu des pages, dans cet exemple, il n'est pas utilisé, car 1 onglet est uniquement utilisé.  Utiliser restrict est un amateur.  Théoriquement, donne une certaine augmentation des performances.  Dans ce cas, il n'est pas nécessaire de l'utiliser. <br><br><p>  Le widget lui-même est placé dans un conteneur de type GtkEventBox.  Il collectionne les événements <br>  cliquez sur le bouton.  Également un conteneur facultatif du type GtkFrame pour afficher un widget dans un cadre lorsque vous cliquez avec le bouton gauche de la souris.  L'opération de changement de conteneur est assez rapide.  L'onglet lui-même, où les widgets sont insérés, a la hiérarchie de pièces jointes suivante: GtkScrolledWindow-&gt; GtkViewport-&gt; GtkFixed.  Initialement, les widgets sont de type GtkWidget, qui sont convertis par des macros en types GtkViewport, GtkFixed.  Je voudrais souligner <br>  attention à la vue macro <br>  InsertedWidgetWithProperty * widget_with_property = &amp; g_array_index (widgets, InsertedWidgetWithProperty, i); <br>  car il est plus simple de se tromper ici.  Paramètres x_correction, y_correction - coordonnées du clic de la souris par rapport au widget inséré GtkEvent.  L'indicateur button_not_pressed est utilisé pour afficher correctement le conteneur de trames.  Par logique, il est entendu que si l'un des boutons de la souris est cliqué sur le widget inséré, il doit être placé dans un cadre.  Autrement dit, les événements buttonclick et buttonrelease ne sont pas associés, contrairement aux événements enter-notify-event et Leave-notify-event, qui sont associés à une modification de la forme du curseur.  Si les paramètres x_correction, button_not_pressed sont des paramètres de service, c'est-à-dire qu'ils doivent être placés dans la section privée, l'indicateur click_order est utilisé pour afficher le widget actuel au-dessus du reste. <br><br></p><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> widget_ptr; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> eventbox; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> frame; <span class="hljs-comment"><span class="hljs-comment">//   GtkWidget *restrict pmenu; widget_type type; bool button_not_pressed; } InsertedWidgetWithProperty; class page_body { public: GtkWidget *restrict scrolledwindow; GtkWidget *restrict viewport; GtkWidget *restrict fixed; GArray *restrict widgets=g_array_new(FALSE, TRUE, sizeof(InsertedWidgetWithProperty)); GtkAdjustment *restrict h_adj; GtkAdjustment *restrict v_adj; int num_of_current_widget=0; double x_correction=0; double y_correction=0; GtkWidget *restrict window; ///      int widget_count=0; bool click_order=FALSE; //TRUE -  page_body(appdata *data, GObject *container) { window=data-&gt;win; h_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); v_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); scrolledwindow=gtk_scrolled_window_new(h_adj, v_adj); viewport=gtk_viewport_new(h_adj, v_adj); fixed=gtk_fixed_new(); gtk_container_add(GTK_CONTAINER(scrolledwindow),GTK_WIDGET(viewport)); gtk_container_add(GTK_CONTAINER(viewport),GTK_WIDGET(fixed)); if(GTK_IS_NOTEBOOK(container)) { gtk_notebook_append_page ((GtkNotebook*)container,scrolledwindow,NULL); } else if(GTK_IS_WIDGET(container)) { gtk_container_add(GTK_CONTAINER(container),scrolledwindow); } g_signal_connect(fixed,"motion-notify-event",G_CALLBACK(fixed_motion_notify), this); g_signal_connect(scrolledwindow,"destroy",G_CALLBACK(scrolled_window_destroy_cb), this); } ~page_body() { int i=widgets-&gt;len; if(widget_count&gt;0) { for(i; i&gt;=0; i--) { InsertedWidgetWithProperty *widget_with_property; widget_with_property=&amp;g_array_index(widgets,InsertedWidgetWithProperty,i); } } g_array_free(widgets,TRUE); } void add_widget(GtkWidget *widget, widget_type type, int x, int y) { ++widget_count; InsertedWidgetWithProperty *widget_with_property=(InsertedWidgetWithProperty*) g_malloc0(sizeof(InsertedWidgetWithProperty)); widget_with_property-&gt;eventbox=gtk_event_box_new(); widget_with_property-&gt;type=type; widget_with_property-&gt;widget_ptr=widget; gtk_container_add(GTK_CONTAINER(widget_with_property-&gt;eventbox),widget); gtk_fixed_put(GTK_FIXED(fixed),widget_with_property-&gt;eventbox,x,y); widget_with_property-&gt;pmenu=gtk_menu_new(); GtkWidget *menu_items = gtk_menu_item_new_with_label (""); gtk_widget_show(menu_items); gtk_menu_shell_append (GTK_MENU_SHELL (widget_with_property-&gt;pmenu), menu_items); g_signal_connect(widget_with_property-&gt;eventbox,"button-press-event",G_CALLBACK(eventbox_press_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"button-release-event",G_CALLBACK(eventbox_release_cb),this); g_signal_connect(menu_items,"activate",G_CALLBACK(menu_delete_activate),this); g_signal_connect(widget_with_property-&gt;eventbox,"leave-notify-event",G_CALLBACK(eventbox_leave_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"enter-notify-event",G_CALLBACK(eventbox_enter_cb),this); gtk_widget_set_events(widget_with_property-&gt;eventbox,GDK_LEAVE_NOTIFY_MASK|GDK_ENTER_NOTIFY_MASK|GDK_STRUCTURE_MASK); g_array_append_val(widgets, *widget_with_property); } inline void change_cursor(char *cursor_name) { GdkDisplay *display; GdkCursor *cursor; display = gtk_widget_get_display (window); if(cursor_name) cursor = gdk_cursor_new_from_name (display, cursor_name); else cursor = gdk_cursor_new_from_name (display, "default"); GdkWindow *gdkwindow=gtk_widget_get_window (window); gdk_window_set_cursor (gdkwindow, cursor); } inline void delete_widget(int i) { InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(this-&gt;widgets,InsertedWidgetWithProperty,i); GtkWidget *eventbox=widget_with_property-&gt;eventbox; g_object_ref(eventbox); gtk_container_remove(GTK_CONTAINER(this-&gt;fixed),eventbox); if(widget_with_property-&gt;frame!=NULL) { gtk_widget_destroy(widget_with_property-&gt;frame); } gtk_widget_destroy(widget_with_property-&gt;eventbox); this-&gt;widgets=g_array_remove_index_fast(this-&gt;widgets,i); --this-&gt;widget_count; } };</span></span></code> </pre><br>  La formule pour calculer les coordonnées du widget afin qu'il ne se déplace dans aucune direction lorsque vous cliquez dessus avec le bouton de la souris.  Il s'agit des coordonnées du clic par rapport au widget, <br>  Coordonnées GtkFixed par rapport à la fenêtre de l'application, coordonnées de la fenêtre par rapport à l'écran. <br>  Le facteur de correction +25 me trouble quelque peu, mais je ne sais pas comment écrire plus simplement.  J'ai vérifié le travail dans les versions d'Ubuntu 15.10, 16.04, 18.04.  La comparaison avec 0 et -1 est effectuée afin que le widget inséré ne soit pas supprimé de la zone de défilement.  Le défilement lui-même est fourni par le widget GtkScrolledWindow. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixed_motion_notify</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x_win, y_win, x_fixed, y_fixed; gtk_window_get_position(GTK_WINDOW(page-&gt;window),&amp;x_win,&amp;y_win); gtk_widget_translate_coordinates(page-&gt;window,page-&gt;fixed,x_win,y_win,&amp;x_fixed,&amp;y_fixed); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_y=(-y_fixed+y_win)*<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_x=(-x_fixed+x_win); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x_corr=page-&gt;x_correction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y_corr=page-&gt;y_correction; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_x=event-&gt;motion.x_root-x_corr-x_win-correction_x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_y=event-&gt;motion.y_root-y_corr-y_fixed-correction_y; InsertedWidgetWithProperty *widget_with_property=&amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); GtkWidget *fixed=page-&gt;fixed; GtkWidget *eventbox=widget_with_property-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_x&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_y&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_y=<span class="hljs-number"><span class="hljs-number">0</span></span>; gtk_fixed_move(GTK_FIXED(fixed), eventbox, position_x, position_y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Le reste des fonctions de rappel.  Implémentation de la suppression de widgets individuels via le menu contextuel avec le bouton droit de la souris.  La suppression de la classe page_body est suspendue à l'événement de suppression GtkScrolledWindow. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrolled_window_destroy_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *object, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> page; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">menu_delete_activate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkMenuItem *menuitem, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;delete_widget(page-&gt;num_of_current_widget); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_leave_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_enter_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-string"><span class="hljs-string">"pointer"</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_press_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;x_correction=event-&gt;button.x; page-&gt;y_correction=event-&gt;button.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; InsertedWidgetWithProperty *widget_compare; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i; i&lt;=page-&gt;widgets-&gt;len; i++) { widget_compare=(InsertedWidgetWithProperty*) page-&gt;widgets-&gt;data+i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget==widget_compare-&gt;eventbox) { page-&gt;num_of_current_widget=i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;button_not_pressed==FALSE) { GtkWidget *eventbox=widget_compare-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(page-&gt;click_order) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; gtk_widget_translate_coordinates(page-&gt;fixed, eventbox,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,&amp;x, &amp;y); gtk_container_remove(GTK_CONTAINER(page-&gt;fixed),eventbox); gtk_fixed_put(GTK_FIXED(page-&gt;fixed),eventbox,-x,-y); } g_object_ref(widget_compare-&gt;widget_ptr); gtk_container_remove(GTK_CONTAINER(eventbox),widget_compare-&gt;widget_ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;frame==<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) widget_compare-&gt;frame=gtk_frame_new(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); gtk_container_add(GTK_CONTAINER(widget_compare-&gt;frame),widget_compare-&gt;widget_ptr); gtk_container_add(GTK_CONTAINER(eventbox),widget_compare-&gt;frame); gtk_widget_show_all(eventbox); widget_compare-&gt;button_not_pressed=TRUE; } <span class="hljs-comment"><span class="hljs-comment">///   const gint RIGHT_CLICK = 3; if (event-&gt;type == GDK_BUTTON_PRESS) { GdkEventButton *bevent = (GdkEventButton *) event; if (bevent-&gt;button == RIGHT_CLICK) { gtk_menu_popup(GTK_MENU(widget_compare-&gt;pmenu), NULL, NULL, NULL, NULL, bevent-&gt;button, bevent-&gt;time); } } return FALSE; } gboolean eventbox_release_cb (GtkWidget *eventbox, GdkEvent *event, gpointer user_data) { page_body *page=(page_body*) user_data; InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); ///      ,    if(widget_with_property-&gt;button_not_pressed==TRUE) { widget_with_property-&gt;frame=(GtkWidget*) g_object_ref(widget_with_property-&gt;frame); widget_with_property-&gt;widget_ptr=(GtkWidget*) g_object_ref(widget_with_property-&gt;widget_ptr); GtkWidget *frame=widget_with_property-&gt;frame; GtkWidget *widget=widget_with_property-&gt;widget_ptr; gtk_container_remove(GTK_CONTAINER(eventbox), frame); gtk_container_remove(GTK_CONTAINER(frame), widget); gtk_container_add(GTK_CONTAINER(eventbox), widget); widget_with_property-&gt;button_not_pressed=FALSE; } }</span></span></code> </pre><br>  Merci de votre attention. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/SanyaZ7/movable_widgets_on_GtkFixed-</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473716/">https://habr.com/ru/post/fr473716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473704/index.html">Bro vs. pas frère</a></li>
<li><a href="../fr473706/index.html">Zoia: CMS réactif léger pour un développement rapide de sites Web</a></li>
<li><a href="../fr473708/index.html">Voiture électrique faite maison - tout n'est pas ce que vous pensez</a></li>
<li><a href="../fr473710/index.html">Les principes de documentation et de localisation, ou comment obtenir une bonne localisation à moindre coût</a></li>
<li><a href="../fr473714/index.html">Comment je suis arrivé à la spécification formelle d'un processeur RISC-V en F #</a></li>
<li><a href="../fr473718/index.html">Comment ajouter des chèques à NoVerify sans écrire une seule ligne de code Go</a></li>
<li><a href="../fr473720/index.html">Deux façons de réaliser des tests unitaires fiables</a></li>
<li><a href="../fr473722/index.html">Isolement à distance, anxiété et dépression</a></li>
<li><a href="../fr473726/index.html">Il ne suffit pas de savoir ce que sont Mutex, Semaphore et async / wait. Vous devez tout savoir des quanta</a></li>
<li><a href="../fr473728/index.html">Mise en œuvre typique de la surveillance. Nikolay Sivko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>