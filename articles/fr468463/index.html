<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèø üßë üî∂ Am√©lioration des performances de Zabbix + PostgreSQL avec le partitionnement et l'indexation üë©üèæ‚Äç‚úàÔ∏è üèÇ ü§¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a environ un an, mes coll√®gues et moi avons √©t√© charg√©s de trier √† l'aide du syst√®me de surveillance d'infrastructure r√©seau populaire - Zabbix. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Am√©lioration des performances de Zabbix + PostgreSQL avec le partitionnement et l'indexation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468463/"> Il y a environ un an, mes coll√®gues et moi avons √©t√© charg√©s de trier √† l'aide du syst√®me de surveillance d'infrastructure r√©seau populaire - Zabbix.  Apr√®s avoir √©tudi√© la documentation, nous avons imm√©diatement proc√©d√© au test de charge: nous voulions √©valuer le nombre de param√®tres que Zabbix peut fonctionner sans baisse notable des performances.  Seul PostgreSQL a √©t√© utilis√© comme SGBD. <br><br>  Au cours des tests, certaines caract√©ristiques architecturales de la disposition de la base de donn√©es et le comportement du syst√®me de surveillance lui-m√™me ont √©t√© identifi√©s, ce qui par d√©faut ne permet pas au syst√®me de surveillance d'atteindre sa puissance maximale.  En cons√©quence, certaines mesures d'optimisation ont √©t√© d√©velopp√©es, men√©es et test√©es principalement en termes de r√©glage de la base de donn√©es. <br><br>  Je veux partager les r√©sultats du travail effectu√© dans cet article.  Cet article sera utile pour les administrateurs DBA Zabbix et PostgreSQL, ainsi que pour tous ceux qui souhaitent mieux comprendre et comprendre le SGBD PosgreSQL populaire. <br><br>  Un petit spoiler: sur une machine faible avec une charge de 200 000 param√®tres par minute, nous avons r√©ussi √† r√©duire le CPU iowait de 20% √† 2%, r√©duire le temps d'enregistrement par portions aux tables de donn√©es primaires de 250 fois et aux tables de donn√©es agr√©g√©es de 32 fois, r√©duire la taille des index 5 √† 10 fois et acc√©l√©rer la r√©ception d'√©chantillons historiques dans certains cas jusqu'√† 18 fois. <br><a name="habracut"></a><br><h4>  Test de charge </h4><br>  Les tests de charge ont √©t√© effectu√©s selon le sch√©ma: un serveur Zabbix, un proxy Zabbix actif, deux agents.  Chaque agent a √©t√© configur√© pour fournir 50 tonnes de param√®tres entiers et 50 tonnes de param√®tres de cha√Æne par minute (pour un total de 200 agents, 200 tonnes de param√®tres par minute ou 3333 param√®tres par seconde).  Pour g√©n√©rer des param√®tres d'agent, nous avons utilis√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug-in pour Zabbix.</a> Pour v√©rifier le nombre maximum de param√®tres qu'un agent peut g√©n√©rer, vous devez utiliser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script sp√©cial du m√™me auteur de plug-in zabbix_module_stress</a> .  L'administrateur Web de Zabbix a des difficult√©s √† enregistrer de gros mod√®les, nous avons donc divis√© les param√®tres en 20 mod√®les avec 5 tonnes de param√®tres (2500 num√©riques et 2500 cha√Ænes). <br><br><div class="spoiler">  <b class="spoiler_title">Mod√®le de g√©n√©rateur de script pour les tests de charge en python</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-string"><span class="hljs-string">"""     .   20   5000    ( 2500  :  echo,  ;  ping,  ) """</span></span> TEMP_HEAD = <span class="hljs-string"><span class="hljs-string">""" &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;zabbix_export&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;date&gt;2015-08-17T23:15:01Z&lt;/date&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;templates&gt; &lt;template&gt; &lt;template&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/template&gt; &lt;name&gt;Template Zabbix Srv Stress {count} passive {char}&lt;/name&gt; &lt;description/&gt; &lt;groups&gt; &lt;group&gt; &lt;name&gt;Templates&lt;/name&gt; &lt;/group&gt; &lt;/groups&gt; &lt;applications/&gt; &lt;items&gt; """</span></span> TEMP_END = <span class="hljs-string"><span class="hljs-string">"""&lt;/items&gt; &lt;discovery_rules/&gt; &lt;macros/&gt; &lt;templates/&gt; &lt;screens/&gt; &lt;/template&gt; &lt;/templates&gt; &lt;/zabbix_export&gt; """</span></span> TEMP_ITEM = <span class="hljs-string"><span class="hljs-string">"""&lt;item&gt; &lt;name&gt;{k}&lt;/name&gt; &lt;type&gt;0&lt;/type&gt; &lt;snmp_community/&gt; &lt;multiplier&gt;0&lt;/multiplier&gt; &lt;snmp_oid/&gt; &lt;key&gt;{k}&lt;/key&gt; &lt;delay&gt;1m&lt;/delay&gt; &lt;history&gt;3&lt;/history&gt; &lt;trends&gt;365&lt;/trends&gt; &lt;status&gt;0&lt;/status&gt; &lt;value_type&gt;{t}&lt;/value_type&gt; &lt;allowed_hosts/&gt; &lt;units/&gt; &lt;delta&gt;0&lt;/delta&gt; &lt;snmpv3_contextname/&gt; &lt;snmpv3_securityname/&gt; &lt;snmpv3_securitylevel&gt;0&lt;/snmpv3_securitylevel&gt; &lt;snmpv3_authprotocol&gt;0&lt;/snmpv3_authprotocol&gt; &lt;snmpv3_authpassphrase/&gt; &lt;snmpv3_privprotocol&gt;0&lt;/snmpv3_privprotocol&gt; &lt;snmpv3_privpassphrase/&gt; &lt;formula&gt;1&lt;/formula&gt; &lt;delay_flex/&gt; &lt;params/&gt; &lt;ipmi_sensor/&gt; &lt;data_type&gt;0&lt;/data_type&gt; &lt;authtype&gt;0&lt;/authtype&gt; &lt;username/&gt; &lt;password/&gt; &lt;publickey/&gt; &lt;privatekey/&gt; &lt;port/&gt; &lt;description/&gt; &lt;inventory_link&gt;0&lt;/inventory_link&gt; &lt;applications/&gt; &lt;valuemap/&gt; &lt;logtimefmt/&gt; &lt;/item&gt; """</span></span> TMP_FNAME_DEFAULT = <span class="hljs-string"><span class="hljs-string">"Template_App_Zabbix_Server_Stress_{count}_passive_{char}.xml"</span></span> chars = <span class="hljs-string"><span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: parser = argparse.ArgumentParser( description=<span class="hljs-string"><span class="hljs-string">'     zabbix'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--items'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'items'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1000</span></span>, help=<span class="hljs-string"><span class="hljs-string">'-   (default: 1000)'</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'--templates'</span></span>, dest=<span class="hljs-string"><span class="hljs-string">'templates'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">1</span></span>, help=<span class="hljs-string"><span class="hljs-string">f'-  [1-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">] (default: 1)'</span></span>) args = parser.parse_args() items_count = args.items tmps_count = args.templates <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (tmps_count &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tmps_count &lt;= len(chars)): sys.exit(<span class="hljs-string"><span class="hljs-string">f"Templates must be in range 1 - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{len(chars)}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(tmps_count): fname = TMP_FNAME_DEFAULT.format(count=items_count, char=chars[i]) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(fname, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> output: output.write(TEMP_HEAD.format(count=items_count, char=chars[i])) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [(<span class="hljs-string"><span class="hljs-string">'stress.ping[{}-I-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-string"><span class="hljs-string">'stress.echo[{}-S-{:06d}]'</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)]: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(items_count/<span class="hljs-number"><span class="hljs-number">2</span></span>)): output.write(TEMP_ITEM.format(k=k.format(chars[i],j),t=t)) output.write(TEMP_END)</code> </pre> <br></div></div><br>  La m√©trique iostat du processeur est un bon indicateur des performances de Zabbix - elle refl√®te la fraction de l'unit√© de temps pendant laquelle le processeur attend l'acc√®s au disque.  Plus il est √©lev√©, plus le disque est occup√© par des op√©rations de lecture et d'√©criture, ce qui affecte indirectement la d√©gradation des performances du syst√®me de surveillance dans son ensemble.  C'est-√†-dire  c'est un signe certain que quelque chose ne va pas avec la surveillance.  Soit dit en passant, sur les espaces ouverts du r√©seau, la question plut√¥t populaire est ¬´comment supprimer le d√©clencheur iostat dans Zabbix¬ª, donc c'est un point sensible, car il existe de nombreuses raisons d'augmenter la valeur de la m√©trique iowait. <br><br>  Voici l'image de la m√©trique du processeur iowait que nous avons obtenue trois jours plus tard initialement: <br><br><img src="https://habrastorage.org/webt/dc/md/yo/dcmdyote_ghzxca-o9sft88ptxq.png"><br><br>  Mais quelle image pour la m√™me mesure, nous avons √©galement obtenu dans les trois jours √† la fin apr√®s toutes les mesures d'optimisation qui ont √©t√© faites, qui seront discut√©es ci-dessous: <br><br><img src="https://habrastorage.org/webt/do/cs/fc/docsfcjjczkhgxoubjayslrohuw.png"><br><br>  Comme le montrent les graphiques, l'indicateur cpu iowait est pass√© de pr√®s de 20% √† 2%, ce qui a indirectement acc√©l√©r√© le temps d'ex√©cution de toutes les demandes d'ajout et de lecture de donn√©es.  Voyons maintenant pourquoi, avec les param√®tres de base de donn√©es standard, les performances globales du syst√®me de surveillance diminuent et comment y rem√©dier. <br><br><h4>  Raisons de la baisse des performances de Zabbix </h4><br>  Avec l'accumulation de plus de 10 millions de valeurs de param√®tres dans chaque tableau de donn√©es primaires, il a √©t√© constat√© que les performances du syst√®me de surveillance diminuent fortement, pour les raisons suivantes: <br><br><ul><li>  la m√©trique iowait pour le processeur du serveur est augment√©e de plus de 20%, ce qui indique une augmentation du temps pendant lequel le processeur attend l'acc√®s aux op√©rations de lecture et d'√©criture sur le disque </li><li>  index des tableaux dans lesquels les donn√©es de surveillance sont fortement gonfl√©es </li><li>  la m√©trique d'utilisation est augment√©e √† 100% pour un disque avec des donn√©es de surveillance, ce qui indique la pleine charge du disque avec des op√©rations de lecture et d'√©criture </li><li>  les valeurs obsol√®tes n'ont pas le temps d'√™tre supprim√©es des tables d'historique lors du nettoyage selon le planning de la femme de m√©nage </li></ul><br>  La situation est aggrav√©e au d√©but de chaque heure, lorsque, en plus de cela, des statistiques horaires agr√©g√©es sont calcul√©es - tout en lisant et en √©crivant activement les pages d'index du disque, en supprimant les donn√©es obsol√®tes de l'historique, ce qui conduit au m√™me r√©sultat - une baisse des performances de la base de donn√©es et une augmentation du temps d'ex√©cution demandes (dans la limite, une demande pouvant aller jusqu'√† 5 minutes a √©t√© not√©e!). <br><br>  Un peu d'aide pour organiser un entrep√¥t de donn√©es de surveillance dans Zabbix.  De plus, il stocke les donn√©es primaires et les donn√©es agr√©g√©es dans diff√©rentes tables avec la s√©paration des types de param√®tres.  Chaque table stocke un champ itemid (une r√©f√©rence implicite √† un √©l√©ment de donn√©es enregistr√© dans le syst√®me), un horodatage pour enregistrer la valeur d'horloge au format d'horodatage unix (millisecondes dans une colonne s√©par√©e) et une valeur dans une colonne s√©par√©e (l'exception est la table de journal, elle a plus de champs - semblable au journal des √©v√©nements) ): <br><div class="scrollable-table"><table><tbody><tr><th>  Nom de table </th><th>  Rendez-vous </th><th>  Type de donn√©es </th></tr><tr><td>  histoire </td><td>  Donn√©es de surveillance principales </td><td>  num√©rique (16,4) </td></tr><tr><td>  history_uint </td><td>  Donn√©es de surveillance principales </td><td>  num√©rique (20,0) </td></tr><tr><td>  history_str </td><td>  Donn√©es de surveillance principales </td><td>  varchar (255) </td></tr><tr><td>  history_text </td><td>  Donn√©es de surveillance principales </td><td>  texte </td></tr><tr><td>  historiques_logs </td><td>  Donn√©es de surveillance principales </td><td>  champs texte et int </td></tr><tr><td>  tendances </td><td>  Donn√©es de surveillance agr√©g√©es </td><td>  num√©rique (16,4) </td></tr><tr><td>  trends_uint </td><td>  Donn√©es de surveillance agr√©g√©es </td><td>  num√©rique (20,0) </td></tr></tbody></table></div><h4>  Activit√©s d'optimisation </h4><br>  Pour am√©liorer les performances de la base de donn√©es PostgreSQL, diff√©rentes mesures d'optimisation ont √©t√© effectu√©es, dont les principales sont le partitionnement et la modification des index.  Cependant, il convient de mentionner quelques mots sur quelques mesures importantes et utiles qui peuvent acc√©l√©rer le travail de toute base de donn√©es sous le syst√®me de gestion de base de donn√©es PostgreSQL. <br><br>  <b>Remarque importante.</b>  Au moment de collecter le mat√©riel de l'article, nous utilisions Zabbix version 4.0, bien que la version 4.2 ait d√©j√† √©t√© publi√©e et que la version 4.4 soit en cours de pr√©paration.  Pourquoi est-il important de le mentionner?  Parce qu'√† partir de la version 4.2, Zabbix a commenc√© √† prendre en charge une extension puissante sp√©ciale pour travailler avec les s√©ries temporelles TimescaleDB, mais jusqu'√† pr√©sent en mode exp√©rimental: pour tous les avantages de l'utilisation de cette extension, on pense que certaines demandes ont commenc√© √† fonctionner plus lentement et il y a encore des probl√®mes de performances non r√©solus (il y aura r√©solu dans la version 4.4) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lisez cet article</a> .  <i>Dans le prochain article, je pr√©vois d'√©crire sur les r√©sultats des tests de charge utilisant d√©j√† l'extension TimescaleDB par rapport √† ce cas de solution.</i>  La version PostgreSQL a √©t√© utilis√©e 10, mais toutes les informations fournies sont pertinentes pour les versions 11 et 12 (nous attendons!). <br><br>  Par cons√©quent, tout d'abord: <br><br><ul><li>  configuration d'un fichier de configuration √† l'aide de l'utilitaire pgtune </li><li>  placer la base de donn√©es sur un disque physique distinct </li><li>  partitionnement des tables d'historique avec pg_pathman </li><li>  modification des types d'index des tables d'historique en brin (horloge) et btree-gin (itemid) </li><li>  collecte et analyse des statistiques d'ex√©cution des requ√™tes pg_stat_statements </li><li>  d√©finition des param√®tres de surveillance du disque physique </li><li>  am√©lioration des performances mat√©rielles </li><li>  cr√©ation d'un cluster distribu√© (mat√©riel au-del√† de la port√©e de cet article) </li></ul><br><br><h4>  Configuration d'un fichier de configuration √† l'aide de l'utilitaire pgtune </h4><br>  En fait, PostgreSQL est un SGBD assez l√©ger.  Son fichier de configuration par d√©faut est configur√© de mani√®re √† ce que, comme le dit mon coll√®gue, "m√™me travailler sur la machine √† caf√©", c'est-√†-dire  sur un fer tr√®s modeste.  Par cons√©quent, il est n√©cessaire de configurer PostgreSQL pour la configuration du serveur, en tenant compte de la quantit√© de m√©moire, du nombre de processeurs, du type d'utilisation pr√©vue de la base de donn√©es, du type de disque (HDD ou SSD) et du nombre de connexions. <br><br>  H√©las, il n'y a pas de formule unique pour r√©gler tous les SGBD, mais il existe certaines r√®gles et mod√®les qui conviennent √† la plupart des configurations (un r√©glage plus fin est d√©j√† le travail d'un expert).  Pour simplifier la vie de DBA, l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pgtune a</a> √©t√© √©crit, qui a √©t√© compl√©t√© par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version web</a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">le0pard</a> , l'auteur d'un livre int√©ressant et utile sur l'administration de PostgreSQL. <br><br>  Un exemple d'ex√©cution de l'utilitaire dans la console avec 100 connexions (Zabbix a un administrateur Web exigeant) pour le type d'application ¬´Data Warehouses¬ª: <br><br><pre>  pgtune -i postgresql.conf -o new_postgresql.conf -T DW -c 100 </pre><br><div class="spoiler">  <b class="spoiler_title">Les param√®tres de configuration que l'utilitaire pgtune modifie avec une description de l'objectif (les valeurs sont donn√©es √† titre d'exemple)</b> <div class="spoiler_text"><pre> # Version DB: 11
 # Type de syst√®me d'exploitation: linux
 # Type de base de donn√©es: web
 # M√©moire totale (RAM): 8 Go
 # CPUs num: 1
 # Nombre de connexions: 100
 # Stockage de donn√©es: hdd<font></font>
<font></font>
 max_connections = 100 # nombre maximum de connexions de base de donn√©es simultan√©es
 shared_buffers = 2 Go # de m√©moire pour diff√©rents tampons (principalement cache de blocs de table et blocs d'index) en m√©moire partag√©e
 effective_cache_size = 6 Go # taille maximale de m√©moire requise pour l'ex√©cution des requ√™tes √† l'aide d'index
 maintenance_work_mem = 512 Mo # affecte la vitesse des op√©rations VACUUM, ANALYZE, CREATE INDEX
 checkpoint_completion_target = 0.7 # temps cible pour terminer la proc√©dure de point de contr√¥le
 wal_buffers = 16 Mo de m√©moire utilis√©e par la m√©moire partag√©e pour g√©rer les journaux de transactions
 default_statistics_target = 100 # quantit√© de statistiques collect√©es par la commande ANALYZE - lors de l'augmentation, l'optimiseur cr√©e des requ√™tes plus lentement, mais mieux
 random_page_cost = 4 # co√ªt conditionnel d'acc√®s √† l'index pour les pages de donn√©es - affecte la d√©cision d'utiliser l'index
 effective_io_concurrency = 2 # nombre d'op√©rations d'E / S asynchrones que le SGBD tentera d'effectuer dans une session distincte
 work_mem = 10485kB # la quantit√© de m√©moire utilis√©e pour le tri et les tables de hachage avant d'utiliser des fichiers temporaires sur le disque
 min_wal_size = 1 Go # limite en dessous du nombre de fichiers WAL qui seront recycl√©s pour une utilisation future
 max_wal_size = 2 Go # limite au-dessus le nombre de fichiers WAL qui seront recycl√©s pour une utilisation future </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Quelques options de configuration postgresql utiles</b> <div class="spoiler_text"><pre> # gestion des gestionnaires de demandes simultan√©es
 max_worker_processes = 8 # le nombre maximum de processus d'arri√®re-plan - au moins un par base de donn√©es
 max_parallel_workers_per_gather = 4 # nombre maximum de processus parall√®les au sein d'une m√™me requ√™te
 max_parallel_workers = 8 # le nombre maximum de processus de travail que le syst√®me peut prendre en charge pour les op√©rations parall√®les<font></font>
<font></font>
 # param√®tres de journalisation (un moyen simple de conna√Ætre le temps d'ex√©cution des requ√™tes sans utiliser l'extension pg_stat_statements)
 log_min_duration_statement = 3000 # √©crire dans les journaux la dur√©e de l'ex√©cution de toutes les commandes dont le temps de fonctionnement&gt; = de la valeur sp√©cifi√©e en ms
 log_duration = off # enregistre la dur√©e de chaque commande termin√©e
 log_statement = 'none' # quelles commandes SQL √©crire dans le journal, valeurs: none (d√©sactiv√©), ddl, mod et all (toutes les commandes)
 debug_print_plan = off # sortie de l'arborescence du plan de requ√™te pour une analyse plus approfondie<font></font>
<font></font>
 # extrayez le maximum de la base de donn√©es et soyez pr√™t √† l'obtenir en cas d'√©chec (pour les plus r√©prim√©s, qui ignorent l'existence de ssd et d'un cluster distribu√©)
 #fsync = off # √©criture physique sur le disque des modifications, la d√©sactivation de fsync donne un gain de vitesse, mais peut entra√Æner des √©checs permanents
 #synchronous_commit = off # vous permet de r√©pondre au client avant m√™me que les informations de transaction ne soient dans le WAL - une alternative presque s√ªre √† la d√©sactivation de fsync
 #full_page_writes = off # l'arr√™t acc√©l√®re les op√©rations normales, mais peut entra√Æner une corruption des donn√©es ou une corruption des donn√©es en cas de panne du syst√®me </pre></div></div><br><h4>  Liste d'une base de donn√©es sur un disque physique distinct </h4><br>  <i>Cet √©l√©ment est facultatif et constitue plut√¥t une solution de transition vers un cluster distribu√© √† part enti√®re, mais il sera utile de conna√Ætre cette possibilit√©.</i>  Pour acc√©l√©rer la base de donn√©es, vous pouvez la placer sur un disque s√©par√©.  Nous avons mont√© l'int√©gralit√© du disque dans le r√©pertoire de base, o√π toutes les bases de donn√©es PostgreSQL sont stock√©es, mais en g√©n√©ral, cela peut √™tre fait diff√©remment: cr√©er une nouvelle base de donn√©es et transf√©rer la base de donn√©es (ou m√™me seulement une partie - les tables de donn√©es de surveillance principales et agr√©g√©es) vers cette base de donn√©es sur un disque s√©par√©. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de montage</b> <div class="spoiler_text">  Vous devez d'abord formater le disque avec le syst√®me de fichiers ext4 et le connecter au serveur.  Montez le disque de la base de donn√©es avec l'√©tiquette noatime: <br><br><pre>  mount / dev / sdc1 / var / lib / pgsql / 10 / data / base -o noatime </pre><br>  Pour un montage permanent, ajoutez la ligne au fichier / etc / fstab: <br><br><pre> # o√π UUID est l'identifiant du disque, vous pouvez le voir en utilisant l'utilitaire blkid
 UUID = 121efe29-70bf-410b-bc71-90704568ce3b / var / lib / pgsql / 10 / data / base ext4 par d√©faut, noatime 0 0 </pre><br></div></div><br><h4>  Partitionnement des tables d'historique avec pg_pathman </h4><br>  L'un des probl√®mes rencontr√©s lors des tests de r√©sistance de Zabbix - PostgreSQL ne parvient pas √† supprimer les donn√©es obsol√®tes de la base de donn√©es.  En utilisant le partitionnement, vous pouvez diviser la table en ses parties constituantes, r√©duisant ainsi la taille des index et des parties constitutives de la super table, ce qui affecte positivement la vitesse de la base de donn√©es dans son ensemble. <br><br>  Le partitionnement r√©sout deux probl√®mes √† la fois: <br><br>  1. acc√©l√©rer la suppression des donn√©es obsol√®tes en supprimant des tables enti√®res <br><br>  2. indices de fractionnement pour chaque table composite <br><br>  Il existe quatre m√©canismes de partitionnement dans PostgreSQL: <br><br>  1.exclusion_contrainte_standard <br><br>  2. extension pg_partman ( <i>ne pas confondre avec pg_pathman</i> ) <br><br>  3. extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_pathman</a> <br><br>  4. cr√©er et maintenir manuellement des partitions par nous-m√™mes <br><br>  La solution de partitionnement la plus pratique, fiable et optimis√©e, √† notre avis, est l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_pathman</a> .  Avec cette m√©thode de partitionnement, le planificateur de requ√™tes d√©termine de mani√®re flexible dans quelles partitions rechercher les donn√©es.  <i>La rumeur veut que dans la 12e version de PostgreSQL, il y aura d√©j√† une excellente partition pr√™te √† l'emploi.</i> <br><br>  Ainsi, nous avons commenc√© √† √©crire les donn√©es de surveillance pour chaque jour dans une table h√©rit√©e distincte du supertable et la suppression des valeurs de param√®tres obsol√®tes a commenc√© √† se produire par la suppression de toutes les tables obsol√®tes √† la fois, ce qui est beaucoup plus facile pour un SGBD en raison des co√ªts de main-d'≈ìuvre.  La suppression a √©t√© effectu√©e en appelant la fonction utilisateur de la base de donn√©es en tant que param√®tre de surveillance du serveur Zabbix √† 2 heures du matin avec une indication de la plage acceptable de stockage des statistiques. <br><br><div class="spoiler">  <b class="spoiler_title">Installer et configurer le partitionnement pour PostgreSQL 10</b> <div class="spoiler_text">  Installez et configurez l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_pathman √†</a> partir du r√©f√©rentiel OS standard (pour obtenir des instructions sur la cr√©ation de la derni√®re version de l'extension √† partir des sources, recherchez dans le m√™me r√©f√©rentiel sur github): <br><br><pre> yum install pg_pathman10
 nano /var/pgsqldb/postgresql.conf
 shared_preload_libraries = 'pg_pathman' # important - ici, √©crivez pg_pathman en dernier dans la liste
</pre><br>  Nous red√©marrons le SGBD, cr√©ons l'extension pour la base de donn√©es et configurons le partitionnement (1 jour pour les donn√©es de surveillance principales et 3 jours pour les donn√©es de surveillance agr√©g√©es - cela pourrait √™tre fait pendant 1 jour): <br><br><pre> systemctl restart postgresql-10.service
 psql -d zabbix -U postgres
 CR√âER UNE EXTENSION pg_pathman;
 # configurer un jour pour les tables de donn√©es de surveillance principales
 # 1552424400 - Compte √† rebours comme horodatage Unix, 86400 - secondes en jours
 s√©lectionnez create_range_partitions ('historique', 'horloge', 1552424400, 86400);
 s√©lectionnez create_range_partitions ('history_uint', 'clock', 1552424400, 86400);
 s√©lectionnez create_range_partitions ('history_text', 'clock', 1552424400, 86400);
 s√©lectionnez create_range_partitions ('history_str', 'clock', 1552424400, 86400);
 s√©lectionnez create_range_partitions ('history_log', 'clock', 1552424400, 86400);
 # configurer pendant trois jours pour les tableaux de donn√©es de surveillance agr√©g√©s
 # 1552424400 - Compte √† rebours comme horodatage Unix, 259200 - secondes en trois jours
 s√©lectionnez create_range_partitions ('tendances', 'horloge', 1545771600, 259200);  
 s√©lectionnez create_range_partitions ('trends_uint', 'clock', 1545771600, 259200); 
</pre><br>  <i>S'il n'y a pas encore de donn√©es dans l'une des tables, alors lors de l'appel de la fonction create_range_partitions, un autre argument suppl√©mentaire p_count = 0_ doit √™tre pass√©.</i> <br><br>  Requ√™tes utiles pour surveiller et g√©rer les partitions: <br><br><pre> # liste g√©n√©rale des tables partitionn√©es, stockage de la configuration principale:
 s√©lectionnez * dans pathman_config;
 # repr√©sentation avec toutes les sections existantes, ainsi que leurs parents et limites de plage:
 s√©lectionnez * dans pathman_partition_list;
 # param√®tres suppl√©mentaires qui remplacent le comportement standard de pg_pathman:
 s√©lectionnez * dans pathman_config_params;
 # copiez le contenu dans la table parent et supprimez les partitions:
 s√©lectionnez drop_partitions ('table_name' :: regclass, false);
</pre><br>  Script utile pour visualiser les statistiques sur le nombre et la taille des partitions: <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> schemaname, relname, relkind, <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span> (reltuples <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>), pg_size_pretty(pg_relation_size(C.oid)) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"size"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class C <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace N <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (N.oid = C.relnamespace) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'pg_catalog'</span></span>, <span class="hljs-string"><span class="hljs-string">'information_schema'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'history%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'trends%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-comment"><span class="hljs-comment">-- and reltuples &gt; 0 -- and pg_relation_size(C.oid) &gt;= 0 ORDER BY schemaname, relname</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">R√©glage automatique de la suppression des partitions obsol√®tes (ahtung - une grande fonction SQL)</b> <div class="spoiler_text">  Pour configurer la suppression automatique des partitions, vous devez cr√©er une fonction dans la base de donn√©es <br>  (texte large, j'ai donc d√ª supprimer la coloration syntaxique): <br><br><pre> CR√âER OU REMPLACER LA FONCTION public.delete_old_partitions (entier history_days, entier trends_days, entier str_days)
  RETOURNE le texte
  LANGUAGE plpgsql
 AS $ function $
 / *
 La fonction supprime toutes les partitions ant√©rieures au nombre de jours sp√©cifi√©:
 history_days - pour les partitions history_x, history_uint_x
 trends_days - pour les partitions trends_x, trends_uint_x
 str_days - pour les partitions history_str_x, history_text_x, history_log_x
 * /
 d√©clarer clock_today_start int;
 d√©clarer clock_delete_less_history int = 0;
 d√©clarer clock_delete_less_trends int = 0;
 d√©clarer clock_delete_less_strings int = 0;
 clock_delete_less int = 0;
 d√©clarer l'it√©rateur int = 0;
 declare result_str text = '';
 d√©clarer le texte buf_table_size;
 d√©clarer le texte buf_table_len;
 d√©clarer le texte nom_partition;
 d√©clarer le texte de clock_max;
 d√©clarer le texte err_detail;
 d√©clarer t_start timestamp = clock_timestamp ();
 d√©clarer l'horodatage t_end;
 commencer
     si $ 1 &lt;= 0 retourne alors 'ups, quelque chose de mal: l'argument history_days doit √™tre une valeur enti√®re positive';  fin si;
     si $ 2 &lt;= 0 retourne alors 'ups, quelque chose de mal: l'argument trends_days doit √™tre une valeur enti√®re positive';  fin si;
     si $ 3 &lt;= 0 retourne alors 'ups, quelque chose de mal: l'argument str_days doit √™tre une valeur enti√®re positive';  fin si;
     clock_today_start = extract (epoch from date_trunc ('day', now ())) :: int;
     clock_delete_less_history = extract (epoch from date_trunc ('day', now ()) - ($ 1 :: text || 'days') :: interval) :: int;
     clock_delete_less_trends = extract (epoch from date_trunc ('day', now ()) - ($ 2 :: text || 'days') :: interval) :: int;
     clock_delete_less_strings = extract (epoch from date_trunc ('day', now ()) - ($ 3 :: text || 'days') :: interval) :: int;
     clock_delete_less = moins (clock_delete_less_history, clock_delete_less_trends, clock_delete_less_strings);
     - avis de mont√©e 'clock_today_start% (%)', to_timestamp (clock_today_start), clock_today_start;
     - avis de mont√©e 'clock_delete_less_history% (%)% days', to_timestamp (clock_delete_less_history), clock_delete_less_history, $ 1;
     --raise notice 'clock_delete_less_trends% (%)% days', to_timestamp (clock_delete_less_trends), clock_delete_less_trends, $ 2;
     - avis de mont√©e 'clock_delete_less_strings% (%)% days', to_timestamp (clock_delete_less_strings), clock_delete_less_strings, $ 3;
     pour nom_partition, horloge_max dans la partition s√©lectionn√©e, plage_max de pathman_partition_list o√π 
     range_max :: int &lt;= le plus grand (clock_delete_less_history, clock_delete_less_trends, clock_delete_less_strings) et 
     (partition :: texte comme 'history%' ou partition :: texte comme 'trends%') ordre par partition asc
     boucle
         if (nom_partition ~ 'history_uint_ \ d' et clock_max :: int &lt;= clock_delete_less_history)
         ou (nom_partition ~ 'history_ \ d' et clock_max :: int &lt;= clock_delete_less_history)
         ou (nom_partition ~ 'trends_ \ d' et clock_max :: int &lt;= clock_delete_less_trends)
         ou (nom_partition ~ 'history_log_ \ d' et clock_max :: int &lt;= clock_delete_less_strings)
         ou (nom_partition ~ 'history_str_ \ d' et clock_max :: int &lt;= clock_delete_less_strings)
         ou (nom_partition ~ 'history_text_ \ d' et clock_max :: int &lt;= clock_delete_less_strings)
         alors 
             it√©rateur = it√©rateur + 1;
             augmenter l'avis '%', format ('!!! supprimer% s% s', nom_partition, horloge_max);
             s√©lectionnez max (reltuples :: int), pg_size_pretty (sum (pg_relation_size (pg_class.oid))) comme "taille" dans pg_class o√π relname comme nom_partition ||  '%' dans buf_table_len strict, buf_table_size;
             si result_str! = '' alors result_str = result_str ||  ',';  fin si;
             result_str = result_str ||  format ('% s (dt &lt;% s, len% s,% s)', partition_name, to_char (to_timestamp (clock_max :: int), 'YYYY-MM-DD'), buf_table_len, buf_table_size);
             ex√©cuter le format ('supprimer la table s'il existe% s', nom_partition);
         fin si;
     boucle de fin;
     si it√©rateur = 0, alors result_str = format ('il n'y a pas de partitions √† supprimer plus anciennes, alors% s date', to_char (to_timestamp (clock_delete_less), 'YYYY-MM-DD')); 
     else result_str = format ('partitions% s supprim√©es en% s secondes:', it√©rateur, trunc (extrait (secondes de (clock_timestamp () - t_start)) :: num√©rique, 3)) ||  result_str;
     fin si;
     --raise notice '%', result_str;
     return result_str;
 exception quand d'autres alors
    obtenir des diagnostics empil√©s err_detail = PG_EXCEPTION_CONTEXT;
    format de retour ('ups, quelque chose de mal:% s [code d'erreur% s],% s', sqlerrm, sqlstate, err_detail);
 fin; 
 $ function $;
</pre><br>  Pour appeler automatiquement la fonction de partition de nettoyage automatique, vous devez cr√©er un √©l√©ment de donn√©es pour l'h√¥te du serveur zabbix du type "Database Monitor" avec les param√®tres suivants: <br><br><pre> - type: moniteur de base de donn√©es
 - nom: delete_old_history_partitions
 - cl√©: db.odbc.select [delete_old_history_partitions, zabbix]
 - expression sql: s√©lectionnez delete_old_partitions (3, 30, 30);
 # ici, les param√®tres de l'appel de la fonction delete_old_partitions indiquent la dur√©e de stockage en jours 
 # pour les valeurs num√©riques, les valeurs num√©riques agr√©g√©es et les valeurs de cha√Æne
 - type de donn√©es: texte
 - intervalle de mise √† jour: 0
 - intervalle utilisateur: pr√©vu en h2
 - p√©riode de stockage de l'historique: 90 jours
 - groupe d'√©l√©ments de donn√©es: base de donn√©es
</pre><br>  Par cons√©quent, nous obtiendrons des statistiques sur le nettoyage des partitions d'environ le type suivant: <br><br><pre>  2019-09-16 02:00:00, supprim√© 3 partitions en 0,024 seconde: trends_78 (dt &lt;2019-08-17, len 1, 48 kB), history_193 (dt &lt;2019-09-13, len 85343, 9448 kB ), history_uint_186 (dt &lt;2019-09-13, len 27969, 3480 kB)
</pre><br>  <b>Important!</b>  Apr√®s avoir configur√© la suppression automatique des partitions via l'√©l√©ment de donn√©es et la fonction utilisateur, vous devez d√©sactiver l'historique et le nettoyage des tendances dans le planificateur de t√¢ches de femme de m√©nage Zabbix: <i>via l'√©l√©ment de menu zabbix, s√©lectionnez ¬´Administration¬ª -&gt; ¬´G√©n√©ral¬ª -&gt; s√©lectionnez ¬´Effacer l'historique¬ª dans la liste dans le coin -&gt; d√©sactiver toutes les cases √† cocher des sections ¬´Historique¬ª et ¬´Dynamique des changements¬ª.</i> <br></div></div><br><h4>  Modification des types d'index des tables d'historique en brin (horloge) et btree-gin (itemid) </h4><br>  Un merci sp√©cial √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">erogov</a> pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente s√©rie d'articles</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pr√©sentation</a> sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">index PostgreSQL</a> .  <i>Et en effet toute l'√©quipe PostgresPRO.</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impressionn√©s par ces articles, nous avons jou√© avec diff√©rents types d'index sur les tableaux de donn√©es de surveillance et sommes parvenus √† la conclusion quels types d'index sur quels champs donneraient le maximum de performances. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il a √©t√© remarqu√© que l'index composite btree (itemid, horloge) est cr√©√© par d√©faut sur toutes les tables de donn√©es de surveillance - il est rapide pour la recherche, en particulier pour les valeurs ordonn√©es de fa√ßon monotone, mais il ¬´gonfle¬ª sur le disque quand il y a beaucoup de donn√©es - plus de 10 millions. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur les tables Par d√©faut, les statistiques agr√©g√©es toutes les heures, un index unique est g√©n√©ralement cr√©√©, bien que ces tables de stockage et d'unicit√© des donn√©es soient fournies ici au niveau du serveur d'applications, et qu'un index unique ne fait que ralentir l'insertion des donn√©es.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au cours des tests de divers indices, la combinaison d'indices la plus r√©ussie a √©t√© r√©v√©l√©e: l'indice de brin sur le champ d'horloge et l'indice btree-gin sur le champ itemid pour toutes les tables de donn√©es de surveillance. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'indice de brin est id√©al pour augmenter de fa√ßon monotone des donn√©es, telles que l'horodatage du fait d'un √©v√©nement, c'est-√†-dire </font><font style="vertical-align: inherit;">pour les s√©ries chronologiques. </font><font style="vertical-align: inherit;">Et l'index btree-gin est essentiellement un index gin sur les types de donn√©es standard, qui est g√©n√©ralement beaucoup plus rapide que l'indice btree classique car </font><font style="vertical-align: inherit;">L'index gin n'est pas reconstruit lors de l'ajout de nouvelles valeurs, mais seulement compl√©t√© par celles-ci. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'index btree-gin est mis comme une extension de PostgreSQL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une comparaison de la vitesse d'√©chantillonnage pour cette strat√©gie d'indexation et pour les index dans la base de donn√©es Zabbix par d√©faut est donn√©e ci-dessous. </font><font style="vertical-align: inherit;">Lors des tests de charge, nous avons accumul√© des donn√©es pendant trois jours pour trois partitions:</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nom de la partition </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le nombre de lignes dans le MLN </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taille en Mo </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 81,3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4119 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 74,9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4426 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history_uint_3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5387 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour √©valuer les r√©sultats, trois types de requ√™tes ont √©t√© effectu√©es: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour un itemid de param√®tre sp√©cifique, les donn√©es du dernier mois, en fait les trois derniers jours (total 1660 enregistrements) </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expliquer analyser s√©lectionner * dans history_uint o√π itemid = 313300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et horloge&gt; = extraire (√©poque du '2019-03-09 00:00:00' :: horodatage) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et clock &lt;= extract (epoch from '2019-04-09 12:00:00' :: timestamp) :: int;</font></font><font></font>
</pre></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour une donn√©e de param√®tre sp√©cifique pour 12 heures d'une journ√©e (649 entr√©es au total) </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expliquer analyser s√©lectionner * dans history_text o√π itemid = 310650</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et horloge&gt; = extraire (√©poque du '2019-04-09 00:00:00' :: horodatage) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et clock &lt;= extract (epoch from '2019-04-09 12:00:00' :: timestamp) :: int;</font></font><font></font>
</pre></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour une donn√©e de param√®tre sp√©cifique pendant une heure (61 enregistrements au total): </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expliquer analyser s√©lectionner le nombre (*) de history_text o√π itemid = 336540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et horloge&gt; = extraire (√©poque du '2019-04-08 11:00:00' :: horodatage) :: int</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et clock &lt;= extract (epoch from '2019-04-08 12:00:00' :: timestamp) :: int;</font></font><font></font>
</pre></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les r√©sultats des tests ont √©t√© tabul√©s ci-dessous: </font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type d'index </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> taille en Mo * </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demande 1 ** en ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demande 2 ** en ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demande 3 ** en ms </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btree (horloge, itemid) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14741 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7154,3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2205,3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1860,4 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brin (horloge), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btree-gin (itemid)</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,42 et 1329 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2958.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1820,4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 102,1 </font></font></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* la taille en Mo est indiqu√©e au total pour trois partitions </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">** demande de type 1 - donn√©es pour 3 jours, demande de type 2 - donn√©es pour 12 heures, demande de type 3 - donn√©es pour une heure </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le tableau de comparaison, on peut voir que pour les grands tableaux de donn√©es avec le nombre d'enregistrements plus de 100 millions, on voit clairement que le changement de l'index composite standard btree en deux indices brin et btree-gin a un effet b√©n√©fique sur la r√©duction de la taille des index et l'acc√©l√©ration du temps d'ex√©cution des requ√™tes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'efficacit√© de l'indexation et du partitionnement est illustr√©e ci-dessous sur l'exemple d'une demande d'ajout de nouveaux enregistrements aux tables history_uint et trends_uint (les ajouts se produisent en moyenne 2000 valeurs par requ√™te).</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Table </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temps moyen de demande d'am√©liorations, ms </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temps de demande moyen apr√®s am√©liorations, ms </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trends_uint </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2201.48 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.72 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trends_uint </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1997.27 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 62,16 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En r√©sumant les r√©sultats des tests de diverses configurations d'index pour les tableaux de donn√©es de surveillance du syst√®me zabbix, nous pouvons dire qu'un changement similaire dans l'index standard pour les tableaux de donn√©es de surveillance du syst√®me zabbix affecte positivement les performances globales du syst√®me, ce qui se ressent surtout lorsque des volumes de donn√©es de plus de 10 millions sont accumul√©s. vous devez oublier l'effet indirect du ¬´gonflement¬ª de l'index btree standard par d√©faut - les reconstructions fr√©quentes de l'index multi-gigaoctets entra√Ænent une lourde charge du disque dur (m√©trique utiliz ation), ce qui augmente finalement le temps des op√©rations sur le disque et le temps d‚Äôattendre l‚Äôacc√®s au disque √† partir du CPU (m√©trique iowait). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour que l'index btree-gin puisse fonctionner avec le type de donn√©es bigint (in8), qui est la colonne itemid, vous devez enregistrer une famille d'op√©rateurs bigint pour l'index btree-gin. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrement d'une famille d'op√©rateurs bigint pour l'index btree-gin</font></font></b> <div class="spoiler_text"><pre>/*<font></font>
     gin    biginteger  integer    .<font></font>
 -   gin     int2, int4, int8,<font></font>
       bigint     ,     bigint (&lt;= 2147483647)<font></font>
        intger_ops,  :<font></font>
create index on tablename using gin(columnname int8_family_ops) with (fastupdate = false);<font></font>
 * /<font></font>
<font></font>
--       btree_gin<font></font>
CREATE EXTENSION btree_gin;<font></font>
<font></font>
CREATE OPERATOR FAMILY integer_ops using gin;<font></font>
<font></font>
CREATE OPERATOR CLASS int4_family_ops<font></font>
FOR TYPE int4 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint4cmp(int4,int4),<font></font>
    FUNCTION 2 gin_extract_value_int4(int4, internal),<font></font>
    FUNCTION 3 gin_extract_query_int4(int4, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int4(int4,int4,int2, internal),<font></font>
STORAGE int4;<font></font>
<font></font>
CREATE OPERATOR CLASS int8_family_ops<font></font>
FOR TYPE int8 USING gin FAMILY integer_ops<font></font>
AS<font></font>
    OPERATOR 1 &lt;,<font></font>
    OPERATOR 2 &lt;=,<font></font>
    OPERATOR 3 =,<font></font>
    OPERATOR 4 &gt;=,<font></font>
    OPERATOR 5 &gt;,<font></font>
    FUNCTION 1 btint8cmp(int8,int8),<font></font>
    FUNCTION 2 gin_extract_value_int8(int8, internal),<font></font>
    FUNCTION 3 gin_extract_query_int8(int8, internal, int2, internal, internal),<font></font>
    FUNCTION 4 gin_btree_consistent(internal, int2, anyelement, int4, internal, internal),<font></font>
    FUNCTION 5 gin_compare_prefix_int8(int8,int8,int2, internal),<font></font>
STORAGE int8;<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int4,int8),<font></font>
  OPERATOR 2 &lt;=(int4,int8),<font></font>
  OPERATOR 3 =(int4,int8),<font></font>
  OPERATOR 4 &gt;=(int4,int8),<font></font>
  OPERATOR 5 &gt;(int4,int8);<font></font>
<font></font>
ALTER OPERATOR FAMILY integer_ops USING gin add<font></font>
  OPERATOR 1 &lt;(int8,int4),<font></font>
  OPERATOR 2 &lt;=(int8,int4),<font></font>
  OPERATOR 3 =(int8,int4),<font></font>
  OPERATOR 4 &gt;=(int8,int4),<font></font>
  OPERATOR 5 &gt;(int8,int4);<font></font>
</pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce script redistribue tous les index de la base de donn√©es PostgreSQL pour Zabbix de la configuration par d√©faut √† la configuration optimale d√©crite ci-dessus.</font></font></b> <div class="spoiler_text"><pre>/*<font></font>
        <font></font>
 * /<font></font>
<font></font>
--   <font></font>
drop index history_1;<font></font>
drop index history_uint_1;<font></font>
drop index history_str_1;<font></font>
drop index history_text_1;<font></font>
drop index history_log_1;<font></font>
--          PK <font></font>
-- (   ,         )<font></font>
alter table trends drop constraint trends_pk;<font></font>
alter table trends_uint drop constraint trends_uint_pk;<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--   btree-gin  bigint       <font></font>
-- https://habr.com/ru/company/postgrespro/blog/340978/#comment_10545932<font></font>
--    create extension btree_gin;<font></font>
create index on history using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_str using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_text using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on history_log using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
create index on trends_uint using gin(itemid int8_family_ops) with (fastupdate = false);<font></font>
<font></font>
--     bree-gin   itemid    <font></font>
--     brin    128 ,    <font></font>
--           ,<font></font>
--      https://habr.com/ru/company/postgrespro/blog/346460/<font></font>
create index on history using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_uint using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_str using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_text using brin(clock) with (pages_per_range = 128);<font></font>
create index on history_log using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends using brin(clock) with (pages_per_range = 128);<font></font>
create index on trends_uint using brin(clock) with (pages_per_range = 128);<font></font>
</pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'indice de brin pour notre volume de donn√©es √† une intensit√© de 100 tonnes de param√®tres par minute (100 tonnes dans l'historique et 100 tonnes dans history_uint), il a √©t√© remarqu√© que l'index fonctionne sur les tables de donn√©es de surveillance primaires avec une taille de zone de 512 pages deux fois plus rapide qu'avec la taille standard de 128 pages, mais elle est individuelle et d√©pend de la taille des tables et de la configuration du serveur. Dans tous les cas, l'indice de brin prend tr√®s peu de place, mais sa vitesse peut √™tre l√©g√®rement augment√©e en ajustant avec pr√©cision la taille de la zone, mais √† condition que le d√©bit de donn√©es ne change pas beaucoup.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, il convient de noter qu'il existe une limitation associ√©e √† l'architecture de Zabbix lui-m√™me: sur l'onglet ¬´Donn√©es r√©centes¬ª, les deux derni√®res valeurs pour chaque param√®tre sont collect√©es en tenant compte du filtrage. Pour chaque param√®tre, les valeurs sont demand√©es s√©par√©ment dans la base de donn√©es. Par cons√©quent, plus ces param√®tres sont s√©lectionn√©s, plus la requ√™te s'ex√©cutera longtemps. Les donn√©es les plus r√©centes sont recherch√©es lorsque l'index btree (itemid, clock desc) est d√©fini sur des tables d'historique avec un tri inverse par heure, mais l'index lui-m√™me ¬´gonfle¬ª sur le disque et ralentit g√©n√©ralement indirectement la base de donn√©es, ce qui provoque un probl√®me, d√©crit ci-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, il existe trois solutions:</font></font><br><br><ol><li>             ¬´ ¬ª      100  (..   ,     ¬´ ¬ª    ) </li><li>     Zabbix ,                  ,          ¬´ ¬ª </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> laissez les index tels qu'ils sont par d√©faut et limitez-vous au partitionnement uniquement pour obtenir des s√©lections assez importantes sur l'onglet Donn√©es r√©centes en m√™me temps pour une vari√©t√© de param√®tres (cependant, il a √©t√© remarqu√© que le serveur Web Zabbix a toujours une limite sur le nombre de valeurs de param√®tres affich√©es simultan√©ment sur l'onglet "Donn√©es r√©centes" - donc, lorsque j'essaie d'afficher 5000 valeurs, la base de donn√©es a calcul√© le r√©sultat, mais le serveur n'a pas pu pr√©parer la page Web et afficher une telle quantit√© de donn√©es). </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collecte et analyse des statistiques d'ex√©cution des requ√™tes pg_stat_statements </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pg_stat_statements est une extension pour collecter des statistiques sur les performances des requ√™tes sur l'ensemble du serveur. </font><font style="vertical-align: inherit;">L'avantage de cette extension est qu'elle n'a pas besoin de collecter et d'analyser les journaux PostgreSQL.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de l'extension pg_stat_statements</font></font></b> <div class="spoiler_text">    psql: <br><br><pre> CREATE EXTENSION pg_stat_statements; </pre><br>       postgresql.conf: <br><br><pre>shared_preload_libraries = 'pg_stat_statements'<font></font>
pg_stat_statements.max = 10000 #   sql ,     (     );<font></font>
pg_stat_statements.track = all # all -   (    ), top -   /, none -  <font></font>
pg_stat_statements.save = true #     <font></font>
</pre><br>  : <br><br><pre> SELECT pg_stat_statements_reset(); </pre><br>          : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> query_sub, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(calls) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> calls, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(mean_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mean_time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'insert into'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> ~ <span class="hljs-string"><span class="hljs-string">'update trends'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'[^(]*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> calls <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span></code> </pre> </div></div><br><h4>      </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour surveiller les disques durs dans Zabbix, seuls les param√®tres vfs.dev.read et vfs.dev.write sont fournis pr√™ts √† l'emploi. Ces options ne fournissent pas d'informations sur l'utilisation du disque. Les crit√®res utiles pour trouver des probl√®mes avec les performances de vos disques durs sont le facteur d'utilisation, l'attente du temps de requ√™te et la charge de la file d'attente de chargement du disque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, une charge de disque √©lev√©e est en corr√©lation avec un int√©r√™t √©lev√© du processeur lui-m√™me et avec une augmentation du temps d'ex√©cution des requ√™tes SQL, qui a √©t√© trouv√©e lors des tests de charge d'un serveur zabbix avec une configuration standard sans partitionnement et sans configuration d'index alternatifs. Vous pouvez ajouter ces param√®tres pour surveiller les disques durs en utilisant les √©tapes suivantes, qui ont √©t√© consult√©es dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d'un ami</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et am√©lior√©: maintenant les param√®tres iostat sont collect√©s s√©par√©ment pour chaque disque dans le param√®tre de temps json, d'o√π, selon les param√®tres de post-traitement, ils sont d√©j√† d√©compos√©s dans les param√®tres de surveillance finaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant que la demande Pull est en attente, vous pouvez essayer d'√©tendre la surveillance des param√®tres du disque selon les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions d√©taill√©es via mon fork</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s toutes les √©tapes d√©crites, vous pouvez ajouter un graphique personnalis√© avec le processeur iowait et les param√®tres d'utilisation du disque syst√®me et du disque de la base de donn√©es (s'ils sont diff√©rents) au panneau de surveillance principal du serveur Zabbix. </font><font style="vertical-align: inherit;">Le r√©sultat peut ressembler √† ceci (sda est le disque principal, sdc est le disque avec la base de donn√©es):</font></font><br><br><img src="https://habrastorage.org/webt/oa/nj/fa/oanjfa3hajssftbq22dk8njiwj0.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Am√©lioration des performances mat√©rielles </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir configur√© le SGBD, l'indexation et le partitionnement, vous pouvez proc√©der √† une mise √† l'√©chelle verticale - pour am√©liorer les caract√©ristiques mat√©rielles du serveur: ajoutez de la RAM, changez les disques en SSD et ajoutez des c≈ìurs de processeur. </font><font style="vertical-align: inherit;">Il s'agit d'une augmentation des performances garantie, mais il est pr√©f√©rable de le faire uniquement apr√®s l'optimisation du logiciel.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'un cluster distribu√© </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s une mise √† l'√©chelle verticale mod√©r√©e, vous devez d√©marrer horizontalement - cr√©er un cluster distribu√©: partitionner ou r√©pliquer l'esclave ma√Ætre. </font><font style="vertical-align: inherit;">Mais il s'agit d'un sujet et d'un mat√©riau s√©par√©s d'un article s√©par√© </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(comment mouler un cluster de merde et de b√¢tons)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi qu'une comparaison de la technique d'optimisation de la base de donn√©es Zabbix d√©crite ci-dessus en utilisant pg_pathman et l'indexation avec la m√©thode d'application de l'extension TimescaleDB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attendant, on ne peut qu'esp√©rer que le contenu de cet article s'est av√©r√© utile et instructif!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468463/">https://habr.com/ru/post/fr468463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468447/index.html">Laragon - WAMP avec domaines locaux automatiques</a></li>
<li><a href="../fr468453/index.html">MBLT19 :: rapports, bataille de produits et test</a></li>
<li><a href="../fr468455/index.html">Grand GPS et son c√¥t√© sombre</a></li>
<li><a href="../fr468457/index.html">Le g√©n√©rateur d'exemples arithm√©tiques simples pour les nuls et pas seulement</a></li>
<li><a href="../fr468459/index.html">Pr√©sentation du d√©tecteur de radar Signature: notre produit phare Playme Silent 2</a></li>
<li><a href="../fr468465/index.html">Le point de vue d'un avocat: comment les soci√©t√©s informatiques peuvent-elles r√©silier un contrat avec un client gouvernemental toxique</a></li>
<li><a href="../fr468471/index.html">Pr√©sentation d'AngularConnect 2019. Partie 1</a></li>
<li><a href="../fr468479/index.html">¬´Les gens pensent que la gratuit√© ne vaut rien. Il m'a sembl√© que je pouvais les convaincre ¬ª- Yuri Yartsev √† propos de l'√©cole Russol</a></li>
<li><a href="../fr468481/index.html">Comment S7 a √©t√© le premier en Russie √† vendre des billets d'avion en ligne</a></li>
<li><a href="../fr468485/index.html">Lorsque vous voulez une belle interface graphique, mais le GPU n'est pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>