<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏻 ⛅️ 💟 OpenSceneGraph: animación procesal de geometría y atributos de estado 🐯 💡 🏪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Hablando de técnicas de programación específicas para OSG , la última vez que hablamos sobre el mecanismo de devolución de llamada y su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: animación procesal de geometría y atributos de estado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437724/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Hablando de técnicas de programación específicas para OSG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, la última vez</a> que hablamos sobre el mecanismo de devolución de llamada y su implementación en el motor.  Es hora de ver las posibilidades que ofrece este mecanismo para administrar el contenido de una escena tridimensional. <br><br>  Si hablamos de animación de objetos, OSG proporciona al desarrollador dos opciones para su implementación: <br><br><ol><li>  Animación procesal implementada programáticamente a través de la transformación de objetos y sus atributos. </li><li>  Exportar animación desde un editor 3D y administrarla desde el código de la aplicación </li></ol><br>  Para comenzar, considere la primera posibilidad, como la más obvia.  Definitivamente hablaremos sobre el segundo un poco más tarde. <br><a name="habracut"></a><br><h1>  1. Animación de transformación procesal </h1><br>  Al atravesar el gráfico de escena, OSG transfiere datos a la canalización de OpenGL, que se ejecuta en un hilo separado.  Este hilo debe estar sincronizado con otros hilos de procesamiento en cada cuadro.  De lo contrario, el método frame () puede completarse antes de procesar los datos de geometría.  Esto conducirá a comportamientos y bloqueos impredecibles del programa.  OSG ofrece una solución a este problema en forma del método setDataVariance () de la clase osg :: Object, que es la base para todos los objetos de escena.  Puede configurar tres modos de procesamiento para objetos <br><br><ol><li>  NO ESPECIFICADO (por defecto): OSG determina independientemente el orden de procesamiento del objeto. <br></li><li>  ESTÁTICO: el objeto es inmutable y el orden de su procesamiento no es importante.  Acelera significativamente el renderizado. <br></li><li>  DINÁMICO: el objeto debe procesarse antes del inicio de la representación. <br></li></ol><br>  Esta configuración se puede establecer en cualquier momento llamando <br><br><pre><code class="cpp hljs">node-&gt;setDataVariance( osg::Object::DYNAMIC );</code> </pre> <br>  La práctica generalmente aceptada es modificar la geometría "sobre la marcha", es decir, cambiar las coordenadas de vértices, colores normales y texturas dinámicamente en cada cuadro, obteniendo geometría mutable.  Esta técnica se llama animación de transformación.  En este caso, el orden de procesamiento de la geometría es decisivo: todos sus cambios deben recalcularse antes de que comience el dibujo.  Para ilustrar este truco, modificamos ligeramente el ejemplo cuadrado de color, obligando a uno de sus vértices a girar alrededor del eje X. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Animquad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad() { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class DynamicQuadCallback : public osg::Drawable::UpdateCallback { public: virtual void update(osg::NodeVisitor *, osg::Drawable *drawable); }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = static_cast&lt;osg::Geometry *&gt;(drawable); if (!quad) return; osg::Vec3Array *vertices = static_cast&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); if (!vertices) return; osg::Quat quat(osg::PI * 0.01, osg::X_AXIS); vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(new DynamicQuadCallback); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Crearemos un cuadrado en una función separada <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  una descripción de la cual, en principio, no es necesaria, ya que hemos realizado tales acciones repetidamente.  Para modificar los vértices de este cuadrado, escribimos la clase DynamicQuadCallback, heredando de osg :: Drawable :: UpdateCallback <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicQuadCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Drawable::UpdateCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor *, osg::Drawable *drawable)</span></span></span></span>; };</code> </pre><br>  anulando el método update () en él <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!quad) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!vertices) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>; vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); }</code> </pre><br>  Aquí obtenemos un puntero a un objeto de geometría <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable);</code> </pre><br>  leemos de la geometría una lista de vértices (o más bien un puntero a ella) <br><br><pre> <code class="cpp hljs">osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray());</code> </pre><br>  Para obtener el último elemento (último vértice) en la matriz, la clase osg :: Array proporciona el método back ().  Para rotar el vértice en relación con el eje X, presentamos <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>;</code> </pre><br>  es decir, establecemos un cuaternión que implementa una rotación alrededor del eje X en un ángulo de 0.01 * Pi.  Gire el vértice multiplicando el cuaternión por un vector que defina las coordenadas del vértice <br><br><pre> <code class="cpp hljs">vertices-&gt;back() = quat * vertices-&gt;back();</code> </pre><br>  Las últimas dos llamadas relatan la lista de visualización y el paralelepípedo dimensional para la geometría modificada. <br><br><pre> <code class="cpp hljs">quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound();</code> </pre><br>  En el cuerpo de la función main (), creamos un cuadrado, establecemos el modo de dibujo dinámico para él y agregamos una devolución de llamada modificando la geometría <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicQuadCallback);</code> </pre><br>  Dejaré indiscriminadamente la creación del nodo raíz y el lanzamiento del visor, ya que ya lo hemos hecho al menos veinte veces de diferentes maneras.  Como resultado, tenemos la animación de transformación más simple <br><br><img src="https://habrastorage.org/webt/rk/oy/rf/rkoyrfpjkx_kan0puqvyj1ocxps.gif"><br><br>  Ahora intente eliminar (comentar) la llamada setDataVariance ().  Quizás no veamos nada criminal en este caso: de forma predeterminada, OSG intenta determinar automáticamente cuándo actualizar los datos de geometría, tratando de sincronizar con el renderizado.  Luego intente cambiar el modo de DINÁMICO a ESTÁTICO y verá que la imagen no se procesa sin problemas, con sacudidas, errores y advertencias notables como esta <br><br><pre> <code class="plaintext hljs">Warning: detected OpenGL error 'invalid value' at after RenderBin::draw(..)</code> </pre><br>  Si no ejecuta el método dirtyDisplayList (), OpenGL ignorará todos los cambios en la geometría y utilizará la lista de visualización creada al principio para crear el cuadrado para la representación.  Elimine esta llamada y verá que no hay animación. <br><br>  Sin llamar al método dirtyBound (), el cuadro delimitador no se volverá a calcular y OSG recortará incorrectamente las caras invisibles. <br><br><h1>  2. El concepto de interpolación de movimiento. </h1><br>  Suponga que un tren que va de la estación A a la estación B tarda 15 minutos en viajar.  ¿Cómo podemos simular esta situación cambiando la posición del tren en la devolución de llamada?  La forma más fácil es correlacionar la posición de la estación A con el tiempo 0 y la estación B con 15 minutos y mover el tren de manera uniforme entre estos tiempos.  Este enfoque más simple se llama interpolación lineal.  En la interpolación lineal, la fórmula describe un vector que especifica la posición de un punto intermedio <br><br><pre> <code class="plaintext hljs">p = (1 - t) * p0 + t * p1</code> </pre><br>  donde p0 es el punto de partida;  p1 es el punto final;  t es un parámetro que varía uniformemente de 0 a 1. Sin embargo, el movimiento del tren es mucho más complicado: sale de la estación A, acelera, luego se mueve a una velocidad constante y luego disminuye la velocidad, deteniéndose en la estación B. Tal proceso ya no puede describir la interpolación lineal y Se ve antinatural. <br><br>  OSG proporciona al desarrollador la biblioteca osgAnimation, que contiene varios algoritmos de interpolación estándar utilizados para animar sin problemas el movimiento de los objetos de la escena.  Cada una de estas funciones generalmente tiene dos argumentos: el valor inicial del parámetro (generalmente 0) y el valor final del parámetro (generalmente 1).  Estas funciones se pueden aplicar al inicio del movimiento (InMotion), al final del movimiento (OutMotion) o al inicio y al final del movimiento (InOutMotion) <br><br><table><thead><tr><th>  Tipo de movimiento </th><th>  en clase </th><th>  fuera de clase </th><th>  clase de entrada / salida </th></tr></thead><tbody><tr><td>  Interpolación lineal </td><td>  Movimiento lineal </td><td>  - </td><td>  - </td></tr><tr><td>  Interpolación cuadrática </td><td>  InQuadMotion </td><td>  OutQuadMotion </td><td>  InOutQuadMotion </td></tr><tr><td>  Interpolación cúbica </td><td>  InCubicMotion </td><td>  Outcubicmotion </td><td>  InOutCubicMotion </td></tr><tr><td>  Interpolación de 4 órdenes </td><td>  InQuartMotion </td><td>  OutQuartMotion </td><td>  InOutQuartMotion </td></tr><tr><td>  Interpolación de efecto de rebote </td><td>  InBounceMotion </td><td>  OutBounceMotion </td><td>  InOutBounceMotion </td></tr><tr><td>  Interpolación de rebote elástico </td><td>  InElasticMotion </td><td>  OutElasticMotion </td><td>  InOutElasticMotion </td></tr><tr><td>  Interpolación sinusoidal </td><td>  InSineMotion </td><td>  Outsinemotion </td><td>  InOutSineMotion </td></tr><tr><td>  Interpolación inversa </td><td>  Inbackmotion </td><td>  Outbackmotion </td><td>  InOutBackMotion </td></tr><tr><td>  Interpolación circular </td><td>  InCircMotion </td><td>  Movimiento exterior </td><td>  InOutCircMotion </td></tr><tr><td>  Interpolación exponencial </td><td>  InExpoMotion </td><td>  Outexpomotion </td><td>  InOutExpoMotion </td></tr></tbody></table><br>  Para crear una interpolación lineal del movimiento de un objeto, escribimos dicho código <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgAnimation::LinearMotion&gt; motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::LinearMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><h1>  3. Animación de nodos de transformación. </h1><br>  La animación de trayectoria es el tipo de animación más común en aplicaciones gráficas.  Esta técnica se puede utilizar para animar el movimiento de un automóvil, el vuelo de un avión o el movimiento de la cámara.  La trayectoria está predefinida, con todas las posiciones, rotaciones y cambios de escala en puntos clave en el tiempo.  Cuando comienza el ciclo de simulación, el estado del objeto se recalcula en cada cuadro, utilizando la interpolación lineal para la posición y la escala y la interpolación lineal esférica para los cuaterniones de rotación.  Para hacer esto, use el método interno slerp () de la clase osg :: Quat. <br><br>  OSG proporciona la clase osg :: AnimationPath para describir una ruta que varía en el tiempo.  El método de esta clase insert () se usa para agregar puntos de control correspondientes a ciertos puntos en el tiempo a la trayectoria.  El punto de control es descrito por la clase osg :: AnimationPath :: ControlPoint, cuyo constructor toma la posición como parámetros y, opcionalmente, la rotación de objetos y los parámetros de escala.  Por ejemplo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;insert(t1, osg::AnimationPath::ControlPoint(pos1, rot1, scale1)); path-&gt;insert(t2, ...);</code> </pre><br>  Aquí t1, t2 son instantes de tiempo en segundos;  rot1 es el parámetro de rotación en el tiempo t1, descrito por el cuaternión osg :: Quat. <br><br>  Es posible controlar los bucles de animación a través del método setLoopMode ().  De manera predeterminada, el modo LOOP está activado: la animación se repetirá continuamente.  Otros valores posibles: NO_LOOPING - reproduce la animación una vez y SWING - repite el movimiento en las direcciones hacia adelante y hacia atrás. <br><br>  Después de completar toda la inicialización, adjuntamos el objeto osg :: AnimationPath al objeto incorporado osg :: AnimationPathCallback, que se deriva de la clase osg :: NodeCallback. <br><br><h1>  4. Un ejemplo de una animación de movimiento a lo largo de un camino. </h1><br>  Ahora haremos que nuestro cessna se mueva en círculo con el centro en el punto (0,0,0).  La posición de la aeronave en la trayectoria se calculará interpolando linealmente la posición y orientación entre cuadros clave. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de animcessna</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/AnimationPath&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::AnimationPath *createAnimationPath(double radius, double time) { osg::ref_ptr&lt;osg::AnimationPath&gt; path = new osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); unsigned int numSamples = 32; double delta_yaw = 2.0 * osg::PI / (static_cast&lt;double&gt;(numSamples) - 1.0); double delta_time = time / static_cast&lt;double&gt;(numSamples); for (unsigned int i = 0; i &lt; numSamples; ++i) { double yaw = delta_yaw * i; osg::Vec3d pos(radius * sin(yaw), radius * cos(yaw), 0.0); osg::Quat rot(-yaw, osg::Z_AXIS); path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } return path.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg.0,0,90.rot"); osg::ref_ptr&lt;osg::MatrixTransform&gt; root = new osg::MatrixTransform; root-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = new osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(50.0, 6.0)); root-&gt;setUpdateCallback(apcb.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Comenzamos creando la trayectoria del avión, tomando este código en una función separada <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">AnimationPath *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAnimationPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.release(); }</code> </pre><br>  Como parámetros, la función toma el radio del círculo a lo largo del cual se mueve el avión y el tiempo durante el cual hará una revolución.  Dentro de la función, cree un objeto de trayectoria y active el modo de bucle de animación <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP);</code> </pre><br>  Código siguiente <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples);</code> </pre><br>  calcula los parámetros de aproximación de la trayectoria.  Dividimos toda la trayectoria en numSamples de secciones rectas, y calculamos el cambio en el ángulo de rotación del plano alrededor del eje vertical (yaw) delta_yaw y el cambio en el tiempo delta_time cuando se mueve de una sección a otra.  Ahora crea los puntos de control necesarios <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); }</code> </pre><br>  En el ciclo, se ordenan todas las secciones de la trayectoria, desde la primera hasta la última.  Cada punto de control se caracteriza por un ángulo de guiñada <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i;</code> </pre><br>  la posición del centro de masa de la aeronave en el espacio <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  El cuaternión establece la rotación de la aeronave al ángulo de guiñada deseado (en relación con el eje vertical) <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>;</code> </pre><br>  y luego agregue los parámetros calculados a la lista de puntos de control de la ruta <br><br><pre> <code class="cpp hljs">path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot));</code> </pre><br>  En el programa principal, prestamos atención al matiz al indicar el nombre del archivo de modelo de la aeronave al momento del arranque <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  - se agregó un sufijo ".0,0,90.rot" al nombre del archivo.  El mecanismo para cargar geometría desde un archivo utilizado en OSG le permite especificar la posición inicial y la orientación del modelo después de la carga.  En este caso, queremos que el modelo gire 90 grados alrededor del eje Z después de cargarlo. <br><br>  A continuación, se crea el nodo raíz, que es el nodo de transformación, y el objeto modelo se agrega como un nodo secundario <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; root-&gt;addChild(model.get());</code> </pre><br>  Ahora cree una devolución de llamada de animación de trayectoria, agregando la ruta creada por la función createAnimationPath () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(<span class="hljs-number"><span class="hljs-number">50.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>));</code> </pre><br>  Adjunte esta devolución de llamada al nodo de transformación <br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback(apcb.get());</code> </pre><br>  El visor se inicializa y se inicia como de costumbre. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Obtén una animación de movimiento de avión <br><br><img src="https://habrastorage.org/webt/ax/01/rl/ax01rlkfna5cfkvzqk3qfao_lmq.gif"><br><br>  ¿Crees que no encontraste nada extraño en este ejemplo?  Anteriormente, por ejemplo, en un programa cuando se renderizaba a una textura, cambiaba explícitamente la matriz de transformación para lograr un cambio en la posición del modelo en el espacio.  Aquí solo creamos un nodo de transformación y en el código no hay una asignación de matriz explícita en ningún lado. <br><br>  El secreto es que la clase especial osg :: AnimationPathCallback hace este trabajo.  De acuerdo con la posición actual del objeto en la ruta, calcula la matriz de transformación y la aplica automáticamente al nodo de transformación al que está conectado, salvando al desarrollador de un montón de operaciones de rutina. <br><br>  Cabe señalar que adjuntar osg :: AnimationPathCallback a otros tipos de nodos no solo no tendrá ningún efecto, sino que también puede conducir a un comportamiento indefinido del programa.  Es importante recordar que esta devolución de llamada solo afecta a los nodos de transformación. <br><br><h1>  5. Animación de control de software </h1><br>  La clase osg :: AnimationPathCallback proporciona métodos para controlar la animación durante la ejecución del programa. <br><br><ol><li>  reset (): reinicia la animación y reprodúcela primero. <br></li><li>  setPause (): pausa la animación.  Toma un valor booleano como parámetro <br></li><li>  setTimeOffset (): establece el desplazamiento de tiempo antes del inicio de la animación. <br></li><li>  setTimeMultiplier (): establece el factor de tiempo para la aceleración / desaceleración de la animación. <br></li></ol><br>  Por ejemplo, para eliminar la animación de la pausa y restablecer, ejecutamos dicho código <br><br><pre> <code class="cpp hljs">apcb-&gt;setPause(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); apcb-&gt;reset();</code> </pre><br>  y para comenzar la animación desde el cuarto segundo después de comenzar el programa con doble aceleración, tal código <br><br><pre> <code class="cpp hljs">apcb-&gt;setTimeOffset(<span class="hljs-number"><span class="hljs-number">4.0f</span></span>); apcb-&gt;setTimeMultiplier(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>);</code> </pre><br><h1>  6. El orden de renderizar primitivas en OpenGL </h1><br>  OpenGL almacena vértices y datos primitivos en varios búferes, como un búfer de color, un búfer de profundidad, un búfer de plantilla, etc.  Además, no sobrescribe los vértices y las caras triangulares ya enviadas a su tubería.  Esto significa que OpenGL crea una nueva geometría, independientemente de cómo se creó la geometría existente.  Esto significa que el orden en que se envían las primitivas a la canalización de representación afecta significativamente el resultado final que vemos en la pantalla. <br><br>  Según los datos del búfer de profundidad, OpenGL dibujará correctamente objetos opacos, clasificando los píxeles de acuerdo con su distancia del observador.  Sin embargo, al utilizar la técnica de mezcla de colores, por ejemplo, al implementar objetos transparentes y translúcidos, se realizará una operación especial para actualizar el búfer de color.  Los píxeles nuevos y antiguos de la imagen se mezclan, teniendo en cuenta el valor del canal alfa (componente del cuarto color).  Esto lleva al hecho de que el orden de renderizado de los bordes translúcidos y opacos afecta el resultado final <br><br><img src="https://habrastorage.org/webt/tz/3w/o4/tz3wo4dfy14oscogqvrb1akmh5m.png"><br><br>  En la figura, en la situación de la izquierda, primero se enviaron objetos opacos y luego transparentes a la tubería, lo que condujo al cambio correcto en el búfer de color y a la visualización correcta de caras.  En la situación correcta, primero se dibujaron objetos transparentes y luego opacos, lo que condujo a una visualización incorrecta. <br><br>  El método setRenderingHint () de la clase osg :: StateSet indica a OSG el orden de representación requerido de nodos y objetos geométricos, si esto debe hacerse explícitamente.  Este método simplemente indica si las caras translúcidas deben o no ser tomadas en cuenta al renderizar, asegurando así que si hay caras translúcidas en la escena, primero se dibujarán caras opacas y luego transparentes, teniendo en cuenta la distancia del observador.  Para informar al motor que este nodo es opaco, usamos este código <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::OPAQUE_BIN);</code> </pre><br>  o contiene bordes transparentes <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><h1>  7. Un ejemplo de la implementación de objetos translúcidos. </h1><br>  Tratemos de ilustrar toda la introducción teórica anterior con un ejemplo concreto de la implementación de un objeto translúcido. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de transparencia</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/BlendFunc&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 0.5f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = new osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); osg::StateSet *stateset = geode-&gt;getOrCreateStateSet(); stateset-&gt;setTextureAttributeAndModes(0, texture.get()); stateset-&gt;setAttributeAndModes(blendFunc); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  En su mayor parte, el código que se muestra aquí no contiene nada nuevo: se crean dos objetos geométricos: un cuadrado texturizado y un ala delta, cuyo modelo se carga desde un archivo.  Sin embargo, aplicamos un color blanco translúcido a todos los vértices del cuadrado. <br><br><pre> <code class="cpp hljs">colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre><br>  - el valor del canal alfa es 0.5, que, cuando se mezcla con colores de textura, debería dar el efecto de un objeto translúcido.  Además, la función de mezcla de colores debe establecerse para el procesamiento de transparencia. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre><br>  pasarlo a la máquina de estado OpenGL <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(blendFunc);</code> </pre><br>  Al compilar y ejecutar este programa, obtenemos el siguiente resultado <br><br><img src="https://habrastorage.org/webt/_m/mz/kz/_mmzkzrmxvmfll-qi0xli6wq_5g.png"><br><br>  Basta!  ¿Y dónde está la transparencia?  La cuestión es que olvidamos decirle al motor que se deben procesar los bordes transparentes, lo cual se resuelve fácilmente llamando <br><br><pre> <code class="cpp hljs">stateset-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>  después de lo cual obtenemos el resultado que necesitamos: el ala del ala delta brilla a través de un cuadrado con textura translúcida <br><br><img src="https://habrastorage.org/webt/py/bl/ta/pybltaqa6xkligouodxgunwoyvs.png"><br><br>  Los parámetros de las funciones de mezcla GL_SRC_ALPHA y GL_ONE_MINUS_SRC_ALPHA significan que el píxel de la pantalla resultante al dibujar una cara translúcida tendrá componentes de color calculados por la fórmula <br><br><pre> <code class="plaintext hljs">R = srcR * srcA + dstR * (1 - srcA) G = srcG * srcA + dstG * (1 - srcA) B = srcB * srcA + dstB * (1 - srcA)</code> </pre><br>  donde [srcR, srcG, srcB] son ​​los componentes de color de la textura cuadrada; [dstR, dstG, dstB] —           ,    ,            .  srcA  -  . <br><br>  seRenderingHint()    ,      ,             .         ,        . <br><br><h1> 8.    </h1><br>        .               .  ,             . <br><br>              . <br><br>        .  ,   -   ,     ,   1 —  . ,      0  1          .      <br><br><div class="spoiler"> <b class="spoiler_title"> fading-in</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/BlendFunc&gt; #include &lt;osg/Material&gt; #include &lt;osgAnimation/EaseMotion&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AlphaFadingCallback : public osg::StateAttributeCallback { public: AlphaFadingCallback() { _motion = new osgAnimation::InOutCubicMotion(0.0f, 1.0f); } virtual void operator() (osg::StateAttribute* , osg::NodeVisitor*); protected: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void AlphaFadingCallback::operator()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (void) nv; osg::Material *material = static_cast&lt;osg::Material *&gt;(sa); if (material) { _motion-&gt;update(0.0005f); float alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, alpha)); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(-0.5f, 0.0f, -0.5f), osg::Vec3(1.0f, 0.0f, 0.0f), osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, 0.5f)); material-&gt;setUpdateCallback(new AlphaFadingCallback); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get()); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(new osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>     -   -   <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlphaFadingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::StateAttributeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::StateAttribute* , osg::NodeVisitor*)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; };</code> </pre><br>   _motion    ,        .       ,    ,    <br><br><pre> <code class="cpp hljs">AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br>         <br><br><img src="https://habrastorage.org/webt/ej/gd/cr/ejgdcr97gkb0lru6evved46sk6q.png"><br><br>    InOutCubicMotion       0  1.   operator()      <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AlphaFadingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) nv; osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material) { _motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha)); } }</code> </pre><br>     <br><br><pre> <code class="cpp hljs">osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa);</code> </pre><br>  callback    ,       ,      ,          .         —   ,           <br><br><pre> <code class="cpp hljs">_motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>);</code> </pre><br>     <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue();</code> </pre><br>        <br><br><pre> <code class="cpp hljs">material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha));</code> </pre><br>      main().           ,    —      OSG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>      ,        ,      .   ,     <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Material&gt; material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>));</code> </pre><br>     . Ambient color —  ,      ,    . Diffuse color —   ,        ,   ,       .  FRONT_AND_BACK ,       ,      . <br><br>       <br><br><pre> <code class="cpp hljs">material-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlphaFadingCallback);</code> </pre><br>     <br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get());</code> </pre><br>     —     ,       <br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>       <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/glider.osg"</span></span>)); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>          <br><br><img src="https://habrastorage.org/webt/s5/jv/1h/s5jv1h_ebaecadz6owo60nnrdvg.gif"><br><br><h1>  :     </h1><br>     ,     .    –        main.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgAnimation/EaseMotion&gt;</span></span></span></span></code> </pre><br>   OSG,     ,     ,       ,   .    osgAnimation/      ,           ,   (       ) <br><br><pre> <code class="cmake hljs">LIBS += -losgAnimation</code> </pre><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuará ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437724/">https://habr.com/ru/post/437724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437712/index.html">Estación espacial Roskomnadzor</a></li>
<li><a href="../437714/index.html">Dibujamos una explosión de dibujos animados para 180 líneas de C ++ desnudo</a></li>
<li><a href="../437716/index.html">Tres formas relativamente honestas de crear un proyecto Flutter</a></li>
<li><a href="../437720/index.html">La lucha por soluciones de calidad en Erlang / Elixir</a></li>
<li><a href="../437722/index.html">Consecuencias Cósmicas de American Shatdown</a></li>
<li><a href="../437726/index.html">Serialización de Kotlin con Kotlinx.</a></li>
<li><a href="../437730/index.html">Cómo resolvimos el problema de memoria en PostgreSQL sin agregar un byte</a></li>
<li><a href="../437732/index.html">Descripción general de la impresora DLP MakeX M-One Pro 70</a></li>
<li><a href="../437734/index.html">Configuración de IPTV desde Rostelecom en enrutadores MikroTik</a></li>
<li><a href="../437736/index.html">Cómo automatizamos el lanzamiento de las pruebas de Selenium a través de Moon y OpenShift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>