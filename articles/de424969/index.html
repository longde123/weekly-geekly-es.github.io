<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë©üèº‚Äçüç≥ ü§πüèæ Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem üîá ü§§ üòÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im neunten Teil der √úbersetzung des Node.js-Tutorials, werden wir √ºber das Arbeiten mit Dateien sprechen. Insbesondere werden wir √ºber fs und P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424969/">  Heute, im neunten Teil der √úbersetzung des Node.js-Tutorials, werden wir √ºber das Arbeiten mit Dateien sprechen.  Insbesondere werden wir √ºber fs und Pfadmodule sprechen - √ºber Dateideskriptoren, √ºber Dateipfade, √ºber das Abrufen von Informationen √ºber Dateien, √ºber das Lesen und Schreiben, √ºber das Arbeiten mit Verzeichnissen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Arbeiten mit Dateideskriptoren in Node.js.</font> </h2><br>  Bevor Sie mit Dateien im Dateisystem Ihres Servers interagieren k√∂nnen, ben√∂tigen Sie einen Dateideskriptor. <br><br>  Der Deskriptor kann mithilfe der asynchronen <code>open()</code> -Methode aus dem <code>fs</code> Modul abgerufen werden, um die Datei zu √∂ffnen: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.open(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, fd)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>fd -    })</code> </pre> <br>  Beachten Sie den zweiten Parameter <code>r</code> , der beim Aufrufen der Methode <code>fs.open()</code> verwendet wird.  Dies ist ein Flag, das dem System mitteilt, dass die Datei zum Lesen ge√∂ffnet wird.  Hier sind einige weitere Flags, die h√§ufig bei der Arbeit mit dieser und einigen anderen Methoden verwendet werden: <br><br><ul><li>  <code>r+</code> - √ñffnen Sie die Datei zum Lesen und Schreiben. </li><li>  <code>w+</code> - √ñffnen Sie die Datei zum Lesen und Schreiben, indem Sie den Stream-Zeiger auf den Anfang der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>a</code> - √ñffnen Sie die Datei zum Schreiben, indem Sie den Stream-Zeiger auf das Ende der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>a+</code> - √ñffnen Sie die Datei zum Lesen und Schreiben, indem Sie den Stream-Zeiger auf das Ende der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li></ul><br>  Dateien k√∂nnen mit der synchronen Methode <code>fs.openSync()</code> ge√∂ffnet werden, die anstelle eines Dateideskriptors im R√ºckruf <code>fs.openSync()</code> zur√ºckgibt: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fd = fs.openSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Nachdem Sie den Deskriptor mit einer der oben genannten Methoden erhalten haben, k√∂nnen Sie die erforderlichen Operationen damit ausf√ºhren. <br><br><h2>  <font color="#3AC1EF">Dateidaten</font> </h2><br>  Jeder Datei ist ein Datensatz zugeordnet. Sie k√∂nnen diese Daten mit Node.js untersuchen.  Dies kann insbesondere mit der <code>stat()</code> -Methode aus dem <code>fs</code> Modul erfolgen. <br><br>  Diese Methode wird aufgerufen, indem der Pfad zur Datei √ºbergeben wird. Nachdem Node.js die erforderlichen Informationen zur Datei erhalten hat, wird der an die <code>stat()</code> -Methode √ºbergebene R√ºckruf aufgerufen.  So sieht es aus: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      `<span class="javascript"><span class="javascript">stats</span></span>` })</code> </pre> <br>  Node.js kann Dateiinformationen synchron abrufen.  Bei diesem Ansatz wird der Hauptthread blockiert, bis die Eigenschaften der Datei erhalten werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stats = fs.statSync (<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Informationen √ºber die Datei fallen in die <code>stats</code> .  Was ist diese Information?  Tats√§chlich bietet uns das entsprechende Objekt eine Vielzahl n√ºtzlicher Eigenschaften und Methoden: <br><br><ul><li>  Mit den <code>.isFile()</code> und <code>.isDirectory()</code> k√∂nnen Sie herausfinden, ob es sich bei der untersuchten Datei um eine regul√§re Datei oder ein Verzeichnis handelt. </li><li>  Mit der Methode <code>.isSymbolicLink()</code> k√∂nnen Sie <code>.isSymbolicLink()</code> , ob eine Datei ein symbolischer Link ist. </li><li>  Die Dateigr√∂√üe kann mit der Eigenschaft <code>.size</code> . </li></ul><br>  Es gibt hier andere Methoden, aber diese werden am h√§ufigsten verwendet.  So verwenden Sie sie: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } stats.isFile() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">true</span></span> stats.isDirectory() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.isSymbolicLink() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.size <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1024000</span></span> //= <span class="hljs-number"><span class="hljs-number">1</span></span>MB })</code> </pre> <br><h2>  <font color="#3AC1EF">Dateipfade in Node.js und im Pfadmodul</font> </h2><br>  Der Dateipfad ist die Adresse des Ortes im Dateisystem, an dem er sich befindet. <br><br>  Unter Linux und MacOS k√∂nnte der Pfad folgenderma√üen aussehen: <br><br><pre> <code class="hljs mel">/users/flavio/<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>.txt</code> </pre> <br>  Unter Windows sehen die Pfade etwas anders aus: <br><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">flavio</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span></span>.txt</code> </pre> <br>  Unterschiede in den Pfadaufzeichnungsformaten bei Verwendung verschiedener Betriebssysteme sollten beachtet werden, da das Betriebssystem zur Bereitstellung des Node.js-Servers verwendet wird. <br><br>  Node.js verf√ºgt √ºber ein Standardpfadmodul, das f√ºr die Arbeit mit Dateipfaden entwickelt wurde.  Bevor Sie dieses Modul in einem Programm verwenden k√∂nnen, muss es verbunden sein: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Abrufen von Dateipfadinformationen</font> </h3><br>  Wenn Sie einen Pfad zur Datei haben und die Funktionen des Pfadmoduls verwenden, k√∂nnen Sie in einer f√ºr die Wahrnehmung und weitere Verarbeitung geeigneten Form Details zu diesem Pfad herausfinden.  Es sieht so aus: <br><br><pre> <code class="hljs pgsql">const notes = <span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.dirname(notes) // /users/flavio <span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes) // notes.txt <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes) // .txt</code> </pre> <br>  Hier wird in der <code>notes</code> der Dateipfad gespeichert.  Die folgenden Methoden des Pfadmoduls wurden verwendet, um den <code>path</code> zu analysieren: <br><br><ul><li>  <code>dirname()</code> - gibt das √ºbergeordnete Verzeichnis der Datei zur√ºck. </li><li>  <code>basename()</code> - gibt den Dateinamen zur√ºck. </li><li>  <code>extname()</code> - gibt die Dateierweiterung zur√ºck. </li></ul><br>  Sie k√∂nnen den Dateinamen ohne die Erweiterung ermitteln, indem Sie die Methode <code>.basename()</code> aufrufen und das zweite Argument √ºbergeben, das die Erweiterung darstellt: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes, <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes)) //notes</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçArbeiten mit Dateipfaden</font> </h3><br>  Mit der Methode <code>path.join()</code> k√∂nnen mehrere Teile des Pfads kombiniert werden: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br>  Sie k√∂nnen den absoluten Pfad zur Datei basierend auf dem relativen Pfad dazu mithilfe der <code>path.resolve()</code> -Methode ermitteln: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      </code> </pre> <br>  In diesem Fall f√ºgt Node.js einfach <code>/flavio.txt</code> zum Pfad hinzu, der zum aktuellen Arbeitsverzeichnis f√ºhrt.  Wenn Sie beim Aufrufen dieser Methode einen anderen Parameter √ºbergeben, der den Pfad zum Ordner darstellt, verwendet die Methode diesen als Basis, um den absoluten Pfad zu bestimmen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/Users/flavio/tmp/flavio.txt'</span></span>      </code> </pre> <br>  Wenn der als erster Parameter √ºbergebene Pfad mit einem Schr√§gstrich beginnt, bedeutet dies, dass es sich um einen absoluten Pfad handelt. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'/etc'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/etc/flavio.txt'</span></span></code> </pre> <br>  Hier ist eine weitere n√ºtzliche Methode - <code>path.normalize()</code> .  Sie k√∂nnen den tats√§chlichen Pfad zur Datei anhand des Pfads ermitteln, der die relativen Pfadqualifizierer wie einen Punkt ( <code>.</code> ), Zwei Punkte ( <code>..</code> ) oder zwei Schr√§gstriche enth√§lt: <br><br><pre> <code class="hljs mel">path.<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// /users/test.txt</span></span></code> </pre> <br>  Die Methoden <code>resolve()</code> und <code>normalize()</code> pr√ºfen nicht, ob ein Verzeichnis vorhanden ist.  Sie finden den Pfad einfach anhand der an sie √ºbergebenen Daten. <br><br><h2>  <font color="#3AC1EF">Dateien in Node.js lesen</font> </h2><br>  Der einfachste Weg, Dateien in Node.js zu lesen, besteht darin, die Methode <code>fs.readFile()</code> verwenden und ihr den Pfad zur Datei und den R√ºckruf zu √ºbergeben, der bei der √úbertragung der <code>fs.readFile()</code> des <code>fs.readFile()</code> darauf aufgerufen wird: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br>  Bei Bedarf k√∂nnen Sie die synchrone Version dieser Methode verwenden - <code>fs.readFileSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Standardm√§√üig wird beim Lesen von Dateien die <code>utf8</code> Codierung verwendet. Die Codierung kann jedoch auch unabh√§ngig festgelegt werden, indem der entsprechende Parameter an die Methode √ºbergeben wird. <br><br>  Die <code>fs.readFile()</code> und <code>fs.readFileSync()</code> lesen den gesamten Inhalt der Datei in den Speicher.  Dies bedeutet, dass die Arbeit mit gro√üen Dateien mit diesen Methoden den Speicherverbrauch Ihrer Anwendung erheblich beeintr√§chtigt und deren Leistung beeintr√§chtigt.  Wenn Sie mit solchen Dateien arbeiten m√ºssen, verwenden Sie am besten Streams. <br><br><h2>  <font color="#3AC1EF">Schreiben von Dateien in Node.js.</font> </h2><br>  In Node.js ist es am einfachsten, Dateien mit der Methode <code>fs.writeFile()</code> zu schreiben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, (err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Es gibt auch eine synchrone Version derselben Methode - <code>fs.writeFileSync()</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = require(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content) <span class="hljs-comment"><span class="hljs-comment">//   } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Diese Methoden ersetzen standardm√§√üig den Inhalt vorhandener Dateien.  Sie k√∂nnen ihr Standardverhalten mit dem entsprechenden Flag √§ndern: <br><br><pre> <code class="hljs coffeescript">fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, { flag: <span class="hljs-string"><span class="hljs-string">'a+'</span></span> }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {})</code> </pre> <br>  Hier k√∂nnen Flags verwendet werden, die wir bereits im Abschnitt √ºber Deskriptoren aufgef√ºhrt haben.  Details zu Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">H√§ngen Sie Daten an eine Datei an</font> </h2><br>  Die Methode <code>fs.appendFile()</code> (und ihre synchrone Version <code>fs.appendFileSync()</code> ) wird bequem verwendet, um Daten an das Ende der Datei anzuh√§ngen: <br><br><pre> <code class="hljs coffeescript">const content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.appendFile(<span class="hljs-string"><span class="hljs-string">'file.log'</span></span>, content, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>! })</code> </pre> <br><h2>  <font color="#3AC1EF">Informationen zur Verwendung von Threads</font> </h2><br>  Oben haben wir Methoden beschrieben, die beim Schreiben in eine Datei die gesamte √ºbertragene Datenmenge schreiben. Wenn ihre synchronen Versionen verwendet werden, geben sie die Steuerung an das Programm zur√ºck, und wenn asynchrone Versionen verwendet werden, rufen sie R√ºckrufe auf.  Wenn dieser Zustand nicht zu Ihnen passt, ist es besser, Streams zu verwenden. <br><br><h2>  <font color="#3AC1EF">Arbeiten mit Verzeichnissen in Node.js.</font> </h2><br>  Das <code>fs</code> Modul bietet dem Entwickler viele praktische Methoden, mit denen er mit Verzeichnissen arbeiten kann. <br><br><h3>  <font color="#3AC1EF">‚ñç√úberpr√ºfen Sie, ob ein Ordner vorhanden ist</font> </h3><br>  Um zu √ºberpr√ºfen, ob das Verzeichnis vorhanden ist und ob Node.js mit den entsprechenden Berechtigungen darauf zugreifen kann, k√∂nnen Sie die Methode <code>fs.access()</code> verwenden. <br><br><h3>  <font color="#3AC1EF">‚ñçErstellen Sie einen neuen Ordner</font> </h3><br>  Um neue Ordner zu erstellen, k√∂nnen Sie die <code>fs.mkdir()</code> und <code>fs.mkdirSync()</code> verwenden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderName = <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fs.existsSync(dir)){   fs.mkdirSync(dir) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçLesen Sie den Inhalt des Ordners</font> </h3><br>  Um den Inhalt eines Ordners zu lesen, k√∂nnen Sie die <code>fs.readdir()</code> und <code>fs.readdirSync()</code> verwenden.  In diesem Beispiel wird der Inhalt des Ordners gelesen, dh die Informationen dar√ºber, welche Dateien und Unterverzeichnisse darin enthalten sind, und ihre relativen Pfade zur√ºckgegeben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderPath = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.readdirSync(folderPath)</code> </pre> <br>  So erhalten Sie den vollst√§ndigen Pfad zur Datei: <br><br><pre> <code class="hljs swift">fs.readdirSync(folderPath).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(fileName =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(folderPath, fileName) }</code> </pre> <br>  Die Ergebnisse k√∂nnen gefiltert werden, um nur die Dateien abzurufen und von der Ausgabe des Verzeichnisses auszuschlie√üen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isFile = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.lstatSync(fileName).isFile() } fs.readdirSync(folderPath).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.join(folderPath, fileName)).filter(isFile) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Ordner umbenennen</font> </h3><br>  Mit den <code>fs.rename()</code> und <code>fs.renameSync()</code> k√∂nnen Sie den Ordner umbenennen.  Der erste Parameter ist der aktuelle Ordnerpfad, der zweite ist ein neuer: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Sie k√∂nnen den Ordner mit der synchronen Methode <code>fs.renameSync()</code> umbenennen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Ordner l√∂schen</font> </h3><br>  Um einen Ordner zu l√∂schen, k√∂nnen Sie die <code>fs.rmdir()</code> oder <code>fs.rmdirSync()</code> verwenden.  Es ist zu beachten, dass das L√∂schen eines Ordners, in dem sich etwas befindet, etwas komplizierter ist als das L√∂schen eines leeren Ordners.  Wenn Sie solche Ordner l√∂schen m√ºssen, verwenden Sie das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fs-extra</a> , das sehr beliebt ist und gut unterst√ºtzt wird.  Es ist ein Ersatz f√ºr das <code>fs</code> Modul und erweitert seine Funktionen. <br><br>  Die Methode <code>remove()</code> aus dem Paket <code>fs-extra</code> kann Ordner l√∂schen, die bereits etwas enthalten. <br><br>  Sie k√∂nnen dieses Modul wie folgt installieren: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> fs-extra</code> </pre> <br>  Hier ist ein Beispiel f√ºr seine Verwendung: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs-extra'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folder = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.remove(folder, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Seine Methoden k√∂nnen in Form von Versprechungen angewendet werden: <br><br><pre> <code class="hljs coffeescript">fs.remove(folder).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> }).<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Das Konstrukt async / await ist ebenfalls akzeptabel: <br><br><pre> <code class="hljs matlab">async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fs</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function">   // } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catch</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">folder</span></span></span><span class="hljs-function"> = '/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Users</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flavio</span></span></span><span class="hljs-function">' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fs-Modul</font> </h2><br>  Oben sind wir bereits auf einige Methoden des <code>fs</code> Moduls <code>fs</code> , die bei der Arbeit mit dem Dateisystem verwendet werden.  In der Tat enth√§lt es viele weitere n√ºtzliche Dinge.  Denken Sie daran, dass es nicht installiert werden muss, um es im Programm zu verwenden. Es reicht aus, es anzuschlie√üen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>)</code> </pre> <br>  Danach haben Sie Zugriff auf seine Methoden, von denen wir Folgendes notieren, von denen einige Sie bereits kennen: <br><br><ul><li>  <code>fs.access()</code> : √úberpr√ºft das Vorhandensein einer Datei und die M√∂glichkeit, basierend auf Berechtigungen darauf zuzugreifen. </li><li>  <code>fs.appendFile()</code> : <code>fs.appendFile()</code> Daten an eine Datei an.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>fs.chmod()</code> : <code>fs.chmod()</code> Berechtigungen f√ºr eine bestimmte Datei.  √Ñhnliche Methoden: <code>fs.lchmod()</code> , <code>fs.fchmod()</code> . </li><li>  <code>fs.chown()</code> : <code>fs.chown()</code> den Eigent√ºmer und die Gruppe f√ºr die angegebene Datei.  √Ñhnliche Methoden: <code>fs.fchown()</code> , <code>fs.lchown()</code> . </li><li>  <code>fs.close()</code> : Schlie√üt den Dateideskriptor. </li><li>  <code>fs.copyFile()</code> : <code>fs.copyFile()</code> die Datei. </li><li>  <code>fs.createReadStream()</code> : <code>fs.createReadStream()</code> einen Stream zum Lesen einer Datei. </li><li>  <code>fs.createWriteStream()</code> : <code>fs.createWriteStream()</code> einen <code>fs.createWriteStream()</code> . </li><li>  <code>fs.link()</code> : <code>fs.link()</code> einen neuen festen Link zur Datei. </li><li>  <code>fs.mkdir()</code> : <code>fs.mkdir()</code> ein neues Verzeichnis. </li><li>  <code>fs.mkdtemp()</code> : <code>fs.mkdtemp()</code> ein tempor√§res Verzeichnis. </li><li>  <code>fs.open()</code> : <code>fs.open()</code> eine Datei. </li><li>  <code>fs.readdir()</code> : Liest den Inhalt eines Verzeichnisses. </li><li>  <code>fs.readFile()</code> : Liest den Inhalt einer Datei.  √Ñhnliche Methode: <code>fs.read()</code> . </li><li>  <code>fs.readlink()</code> : Liest den Wert eines symbolischen Links. </li><li>  <code>fs.realpath()</code> : <code>fs.realpath()</code> den relativen Dateipfad auf, der mit Zeichen erstellt wurde <code>.</code>  und <code>..</code> , auf dem vollen Weg. </li><li>  <code>fs.rename()</code> : <code>fs.rename()</code> eine Datei oder einen Ordner um. </li><li>  <code>fs.rmdir()</code> : <code>fs.rmdir()</code> den Ordner. </li><li>  <code>fs.stat()</code> : <code>fs.stat()</code> zur√ºck.  √Ñhnliche Methoden: <code>fs.fstat()</code> , <code>fs.lstat()</code> . </li><li>  <code>fs.symlink()</code> : <code>fs.symlink()</code> einen neuen symbolischen Link zur Datei. </li><li>  <code>fs.truncate()</code> : <code>fs.truncate()</code> die Datei auf die angegebene L√§nge ab.  √Ñhnliche Methode: <code>fs.ftruncate()</code> . </li><li>  <code>fs.unlink()</code> : <code>fs.unlink()</code> eine Datei oder einen symbolischen Link. </li><li>  <code>fs.unwatchFile()</code> : <code>fs.unwatchFile()</code> die √úberwachung von Datei√§nderungen. </li><li>  <code>fs.utimes()</code> : <code>fs.utimes()</code> den Zeitstempel einer Datei.  √Ñhnliche Methode: <code>fs.futimes()</code> . </li><li>  <code>fs.watchFile()</code> : Aktiviert die √úberwachung von Datei√§nderungen.  √Ñhnliche Methode: <code>fs.watch()</code> . </li><li>  <code>fs.writeFile()</code> : Schreibt Daten in eine Datei.  √Ñhnliche Methode: <code>fs.write()</code> . </li></ul><br>  Ein interessantes Merkmal des <code>fs</code> Moduls ist die Tatsache, dass alle seine Methoden standardm√§√üig asynchron sind, es gibt jedoch auch synchrone Versionen davon, deren Namen durch Hinzuf√ºgen des Wortes <code>Sync</code> zu den Namen asynchroner Methoden erhalten werden. <br><br>  Zum Beispiel: <br><br><ul><li> <code>fs.rename()</code> </li> <li> <code>fs.renameSync()</code> </li> <li> <code>fs.write()</code> </li> <li> <code>fs.writeSync()</code> </li> </ul><br>  Die Verwendung synchroner Methoden hat schwerwiegende Auswirkungen auf die Funktionsweise des Programms. <br><br>  Node.js 10 bietet experimentelle Unterst√ºtzung f√ºr diese auf Versprechen basierenden APIs. <br><br>  Entdecken Sie die Methode <code>fs.rename()</code> .  Hier ist eine asynchrone Version dieser Methode mit R√ºckrufen: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Bei Verwendung der synchronen Version wird das <code>try/catch</code> Konstrukt verwendet, um Fehler zu behandeln: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Der Hauptunterschied zwischen diesen Optionen f√ºr die Verwendung dieser Methode besteht darin, dass im zweiten Fall das Skript blockiert wird, bis der Dateivorgang abgeschlossen ist. <br><br><h2>  <font color="#3AC1EF">Pfadmodul</font> </h2><br>  Das Pfadmodul, √ºber das wir auch einige seiner Funktionen gesprochen haben, enth√§lt viele n√ºtzliche Tools, mit denen Sie mit dem Dateisystem interagieren k√∂nnen.  Wie bereits erw√§hnt, m√ºssen Sie es nicht installieren, da es Teil von Node.js ist.  Um es zu verwenden, reicht es aus, es anzuschlie√üen: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br>  Die <code>path.sep</code> Eigenschaft dieses Moduls enth√§lt das Zeichen, das zum Trennen von <code>path.sep</code> verwendet wird ( <code>\</code> unter Windows und <code>/</code> unter Linux und macOS), und die <code>path.delimiter</code> Eigenschaft gibt das Zeichen an, das zum Trennen mehrerer Pfade verwendet wird ( <code>;</code> unter Windows und <code>:</code> unter Linux) und macOS). <br><br>  Betrachten und veranschaulichen wir einige Methoden des Pfadmoduls. <br><br><h3>  <font color="#3AC1EF">‚ñçpath.basename ()</font> </h3><br>  Gibt das letzte Fragment des Pfads zur√ºck.  Durch √úbergeben des zweiten Parameters an diese Methode k√∂nnen Sie die Dateierweiterung entfernen. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) //something <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>) //something.txt <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>) //something</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.dirname ()</font> </h3><br>  Gibt den Teil des Pfads zur√ºck, der den Verzeichnisnamen darstellt: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span><span class="hljs-regexp"><span class="hljs-regexp">/something</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.extname ()</font> </h3><br>  Gibt den Teil des Pfads zur√ºck, der die Dateierweiterung darstellt: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.isAbsolute ()</font> </h3><br>  Gibt true zur√ºck, wenn der Pfad absolut ist: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'./test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.join ()</font> </h3><br>  Verbindet mehrere Teile des Pfades: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.normalize ()</font> </h3><br>  Der Versuch, den realen Pfad basierend auf dem Pfad herauszufinden, der die Zeichen enth√§lt, die zum Erstellen relativer Pfade wie verwendet werden <code>.</code>  , <code>..</code> und <code>//</code> : <br><br><pre> <code class="hljs mel">require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">///users/test.txt</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.parse ()</font> </h3><br>  Konvertiert einen Pfad in ein Objekt, dessen Eigenschaften einzelne Teile des Pfads darstellen: <br><br><ul><li>  <code>root</code> : das Stammverzeichnis. </li><li>  <code>dir</code> : Dateipfad ab dem Stammverzeichnis </li><li>  <code>base</code> : Dateiname und Erweiterung. </li><li>  <code>name</code> : Dateiname. </li><li>  <code>ext</code> : Dateierweiterung. </li></ul><br>  Hier ist ein Beispiel mit dieser Methode: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).parse(<span class="hljs-string"><span class="hljs-string">'/users/test.txt'</span></span>)</code> </pre> <br>  Als Ergebnis seiner Arbeit erh√§lt man folgendes Objekt: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">root</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, dir: <span class="hljs-string"><span class="hljs-string">'/users'</span></span>, base: <span class="hljs-string"><span class="hljs-string">'test.txt'</span></span>, ext: <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'test'</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.relative ()</font> </h3><br>  Nimmt als Argumente zwei M√∂glichkeiten.  Gibt den relativen Pfad vom ersten zum zweiten Pfad basierend auf dem aktuellen Arbeitsverzeichnis zur√ºck: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'test.txt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/something/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'something/test.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.resolve ()</font> </h3><br>  Findet den absoluten Pfad basierend auf dem relativen Pfad, der an ihn √ºbergeben wurde: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      .</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir uns die Node.js <code>fs</code> und <code>path</code> Module angesehen, die f√ºr die Arbeit mit dem Dateisystem verwendet werden.  Im n√§chsten Teil dieser Reihe, an dem sie endet, werden wir die Betriebssysteme, <code>events</code> und <code>http</code> Module diskutieren und √ºber die Arbeit mit Streams und Datenbankverwaltungssystemen in Node.js sprechen. <br><br>  <b>Liebe Leser!</b>  Welche npm-Pakete verwenden Sie, wenn Sie mit dem Dateisystem in Node.js arbeiten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424969/">https://habr.com/ru/post/de424969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424957/index.html">Generieren von Bildern aus Text mit AttnGAN</a></li>
<li><a href="../de424961/index.html">MTA-STS f√ºr Postfix</a></li>
<li><a href="../de424963/index.html">Zuckerberg-Finanzierung: Gemeinsam Werkzeuge f√ºr die Wissenschaft bauen</a></li>
<li><a href="../de424965/index.html">Reagieren Sie auf die Anwendungsentwicklung mit ReasonReact</a></li>
<li><a href="../de424967/index.html">JavaScript-Verkn√ºpfungen f√ºr Anf√§nger</a></li>
<li><a href="../de424971/index.html">Habrokast "Sunset Manually" # 1. Versuch, eine Umgebung f√ºr die Entwicklung eines Spielzeugs f√ºr Windows einzurichten</a></li>
<li><a href="../de424973/index.html">Gesichtserkennung auf Video: Raspberry Pi und Neural Compute Stick</a></li>
<li><a href="../de424975/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 2. Datenschema als Reflexion des Weltmodells</a></li>
<li><a href="../de424977/index.html">Aus Fehlern lernen: Anwendungen im App Store und bei Google Play optimieren</a></li>
<li><a href="../de424979/index.html">Ulme. Bequem und umst√§ndlich. HTTP, Aufgabe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>