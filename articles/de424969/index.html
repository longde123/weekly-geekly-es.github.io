<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 👩🏼‍🍳 🤹🏾 Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem 🔇 🤤 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im neunten Teil der Übersetzung des Node.js-Tutorials, werden wir über das Arbeiten mit Dateien sprechen. Insbesondere werden wir über fs und P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424969/">  Heute, im neunten Teil der Übersetzung des Node.js-Tutorials, werden wir über das Arbeiten mit Dateien sprechen.  Insbesondere werden wir über fs und Pfadmodule sprechen - über Dateideskriptoren, über Dateipfade, über das Abrufen von Informationen über Dateien, über das Lesen und Schreiben, über das Arbeiten mit Verzeichnissen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Arbeiten mit Dateideskriptoren in Node.js.</font> </h2><br>  Bevor Sie mit Dateien im Dateisystem Ihres Servers interagieren können, benötigen Sie einen Dateideskriptor. <br><br>  Der Deskriptor kann mithilfe der asynchronen <code>open()</code> -Methode aus dem <code>fs</code> Modul abgerufen werden, um die Datei zu öffnen: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.open(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, fd)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>fd -    })</code> </pre> <br>  Beachten Sie den zweiten Parameter <code>r</code> , der beim Aufrufen der Methode <code>fs.open()</code> verwendet wird.  Dies ist ein Flag, das dem System mitteilt, dass die Datei zum Lesen geöffnet wird.  Hier sind einige weitere Flags, die häufig bei der Arbeit mit dieser und einigen anderen Methoden verwendet werden: <br><br><ul><li>  <code>r+</code> - Öffnen Sie die Datei zum Lesen und Schreiben. </li><li>  <code>w+</code> - Öffnen Sie die Datei zum Lesen und Schreiben, indem Sie den Stream-Zeiger auf den Anfang der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>a</code> - Öffnen Sie die Datei zum Schreiben, indem Sie den Stream-Zeiger auf das Ende der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>a+</code> - Öffnen Sie die Datei zum Lesen und Schreiben, indem Sie den Stream-Zeiger auf das Ende der Datei setzen.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li></ul><br>  Dateien können mit der synchronen Methode <code>fs.openSync()</code> geöffnet werden, die anstelle eines Dateideskriptors im Rückruf <code>fs.openSync()</code> zurückgibt: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fd = fs.openSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Nachdem Sie den Deskriptor mit einer der oben genannten Methoden erhalten haben, können Sie die erforderlichen Operationen damit ausführen. <br><br><h2>  <font color="#3AC1EF">Dateidaten</font> </h2><br>  Jeder Datei ist ein Datensatz zugeordnet. Sie können diese Daten mit Node.js untersuchen.  Dies kann insbesondere mit der <code>stat()</code> -Methode aus dem <code>fs</code> Modul erfolgen. <br><br>  Diese Methode wird aufgerufen, indem der Pfad zur Datei übergeben wird. Nachdem Node.js die erforderlichen Informationen zur Datei erhalten hat, wird der an die <code>stat()</code> -Methode übergebene Rückruf aufgerufen.  So sieht es aus: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      `<span class="javascript"><span class="javascript">stats</span></span>` })</code> </pre> <br>  Node.js kann Dateiinformationen synchron abrufen.  Bei diesem Ansatz wird der Hauptthread blockiert, bis die Eigenschaften der Datei erhalten werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stats = fs.statSync (<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Informationen über die Datei fallen in die <code>stats</code> .  Was ist diese Information?  Tatsächlich bietet uns das entsprechende Objekt eine Vielzahl nützlicher Eigenschaften und Methoden: <br><br><ul><li>  Mit den <code>.isFile()</code> und <code>.isDirectory()</code> können Sie herausfinden, ob es sich bei der untersuchten Datei um eine reguläre Datei oder ein Verzeichnis handelt. </li><li>  Mit der Methode <code>.isSymbolicLink()</code> können Sie <code>.isSymbolicLink()</code> , ob eine Datei ein symbolischer Link ist. </li><li>  Die Dateigröße kann mit der Eigenschaft <code>.size</code> . </li></ul><br>  Es gibt hier andere Methoden, aber diese werden am häufigsten verwendet.  So verwenden Sie sie: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } stats.isFile() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">true</span></span> stats.isDirectory() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.isSymbolicLink() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.size <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1024000</span></span> //= <span class="hljs-number"><span class="hljs-number">1</span></span>MB })</code> </pre> <br><h2>  <font color="#3AC1EF">Dateipfade in Node.js und im Pfadmodul</font> </h2><br>  Der Dateipfad ist die Adresse des Ortes im Dateisystem, an dem er sich befindet. <br><br>  Unter Linux und MacOS könnte der Pfad folgendermaßen aussehen: <br><br><pre> <code class="hljs mel">/users/flavio/<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>.txt</code> </pre> <br>  Unter Windows sehen die Pfade etwas anders aus: <br><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">flavio</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span></span>.txt</code> </pre> <br>  Unterschiede in den Pfadaufzeichnungsformaten bei Verwendung verschiedener Betriebssysteme sollten beachtet werden, da das Betriebssystem zur Bereitstellung des Node.js-Servers verwendet wird. <br><br>  Node.js verfügt über ein Standardpfadmodul, das für die Arbeit mit Dateipfaden entwickelt wurde.  Bevor Sie dieses Modul in einem Programm verwenden können, muss es verbunden sein: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Abrufen von Dateipfadinformationen</font> </h3><br>  Wenn Sie einen Pfad zur Datei haben und die Funktionen des Pfadmoduls verwenden, können Sie in einer für die Wahrnehmung und weitere Verarbeitung geeigneten Form Details zu diesem Pfad herausfinden.  Es sieht so aus: <br><br><pre> <code class="hljs pgsql">const notes = <span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.dirname(notes) // /users/flavio <span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes) // notes.txt <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes) // .txt</code> </pre> <br>  Hier wird in der <code>notes</code> der Dateipfad gespeichert.  Die folgenden Methoden des Pfadmoduls wurden verwendet, um den <code>path</code> zu analysieren: <br><br><ul><li>  <code>dirname()</code> - gibt das übergeordnete Verzeichnis der Datei zurück. </li><li>  <code>basename()</code> - gibt den Dateinamen zurück. </li><li>  <code>extname()</code> - gibt die Dateierweiterung zurück. </li></ul><br>  Sie können den Dateinamen ohne die Erweiterung ermitteln, indem Sie die Methode <code>.basename()</code> aufrufen und das zweite Argument übergeben, das die Erweiterung darstellt: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes, <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes)) //notes</code> </pre> <br><h3>  <font color="#3AC1EF">▍Arbeiten mit Dateipfaden</font> </h3><br>  Mit der Methode <code>path.join()</code> können mehrere Teile des Pfads kombiniert werden: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br>  Sie können den absoluten Pfad zur Datei basierend auf dem relativen Pfad dazu mithilfe der <code>path.resolve()</code> -Methode ermitteln: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      </code> </pre> <br>  In diesem Fall fügt Node.js einfach <code>/flavio.txt</code> zum Pfad hinzu, der zum aktuellen Arbeitsverzeichnis führt.  Wenn Sie beim Aufrufen dieser Methode einen anderen Parameter übergeben, der den Pfad zum Ordner darstellt, verwendet die Methode diesen als Basis, um den absoluten Pfad zu bestimmen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/Users/flavio/tmp/flavio.txt'</span></span>      </code> </pre> <br>  Wenn der als erster Parameter übergebene Pfad mit einem Schrägstrich beginnt, bedeutet dies, dass es sich um einen absoluten Pfad handelt. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'/etc'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/etc/flavio.txt'</span></span></code> </pre> <br>  Hier ist eine weitere nützliche Methode - <code>path.normalize()</code> .  Sie können den tatsächlichen Pfad zur Datei anhand des Pfads ermitteln, der die relativen Pfadqualifizierer wie einen Punkt ( <code>.</code> ), Zwei Punkte ( <code>..</code> ) oder zwei Schrägstriche enthält: <br><br><pre> <code class="hljs mel">path.<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// /users/test.txt</span></span></code> </pre> <br>  Die Methoden <code>resolve()</code> und <code>normalize()</code> prüfen nicht, ob ein Verzeichnis vorhanden ist.  Sie finden den Pfad einfach anhand der an sie übergebenen Daten. <br><br><h2>  <font color="#3AC1EF">Dateien in Node.js lesen</font> </h2><br>  Der einfachste Weg, Dateien in Node.js zu lesen, besteht darin, die Methode <code>fs.readFile()</code> verwenden und ihr den Pfad zur Datei und den Rückruf zu übergeben, der bei der Übertragung der <code>fs.readFile()</code> des <code>fs.readFile()</code> darauf aufgerufen wird: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br>  Bei Bedarf können Sie die synchrone Version dieser Methode verwenden - <code>fs.readFileSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Standardmäßig wird beim Lesen von Dateien die <code>utf8</code> Codierung verwendet. Die Codierung kann jedoch auch unabhängig festgelegt werden, indem der entsprechende Parameter an die Methode übergeben wird. <br><br>  Die <code>fs.readFile()</code> und <code>fs.readFileSync()</code> lesen den gesamten Inhalt der Datei in den Speicher.  Dies bedeutet, dass die Arbeit mit großen Dateien mit diesen Methoden den Speicherverbrauch Ihrer Anwendung erheblich beeinträchtigt und deren Leistung beeinträchtigt.  Wenn Sie mit solchen Dateien arbeiten müssen, verwenden Sie am besten Streams. <br><br><h2>  <font color="#3AC1EF">Schreiben von Dateien in Node.js.</font> </h2><br>  In Node.js ist es am einfachsten, Dateien mit der Methode <code>fs.writeFile()</code> zu schreiben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, (err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Es gibt auch eine synchrone Version derselben Methode - <code>fs.writeFileSync()</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = require(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content) <span class="hljs-comment"><span class="hljs-comment">//   } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Diese Methoden ersetzen standardmäßig den Inhalt vorhandener Dateien.  Sie können ihr Standardverhalten mit dem entsprechenden Flag ändern: <br><br><pre> <code class="hljs coffeescript">fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, { flag: <span class="hljs-string"><span class="hljs-string">'a+'</span></span> }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {})</code> </pre> <br>  Hier können Flags verwendet werden, die wir bereits im Abschnitt über Deskriptoren aufgeführt haben.  Details zu Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Hängen Sie Daten an eine Datei an</font> </h2><br>  Die Methode <code>fs.appendFile()</code> (und ihre synchrone Version <code>fs.appendFileSync()</code> ) wird bequem verwendet, um Daten an das Ende der Datei anzuhängen: <br><br><pre> <code class="hljs coffeescript">const content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.appendFile(<span class="hljs-string"><span class="hljs-string">'file.log'</span></span>, content, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>! })</code> </pre> <br><h2>  <font color="#3AC1EF">Informationen zur Verwendung von Threads</font> </h2><br>  Oben haben wir Methoden beschrieben, die beim Schreiben in eine Datei die gesamte übertragene Datenmenge schreiben. Wenn ihre synchronen Versionen verwendet werden, geben sie die Steuerung an das Programm zurück, und wenn asynchrone Versionen verwendet werden, rufen sie Rückrufe auf.  Wenn dieser Zustand nicht zu Ihnen passt, ist es besser, Streams zu verwenden. <br><br><h2>  <font color="#3AC1EF">Arbeiten mit Verzeichnissen in Node.js.</font> </h2><br>  Das <code>fs</code> Modul bietet dem Entwickler viele praktische Methoden, mit denen er mit Verzeichnissen arbeiten kann. <br><br><h3>  <font color="#3AC1EF">▍Überprüfen Sie, ob ein Ordner vorhanden ist</font> </h3><br>  Um zu überprüfen, ob das Verzeichnis vorhanden ist und ob Node.js mit den entsprechenden Berechtigungen darauf zugreifen kann, können Sie die Methode <code>fs.access()</code> verwenden. <br><br><h3>  <font color="#3AC1EF">▍Erstellen Sie einen neuen Ordner</font> </h3><br>  Um neue Ordner zu erstellen, können Sie die <code>fs.mkdir()</code> und <code>fs.mkdirSync()</code> verwenden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderName = <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fs.existsSync(dir)){   fs.mkdirSync(dir) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Lesen Sie den Inhalt des Ordners</font> </h3><br>  Um den Inhalt eines Ordners zu lesen, können Sie die <code>fs.readdir()</code> und <code>fs.readdirSync()</code> verwenden.  In diesem Beispiel wird der Inhalt des Ordners gelesen, dh die Informationen darüber, welche Dateien und Unterverzeichnisse darin enthalten sind, und ihre relativen Pfade zurückgegeben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderPath = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.readdirSync(folderPath)</code> </pre> <br>  So erhalten Sie den vollständigen Pfad zur Datei: <br><br><pre> <code class="hljs swift">fs.readdirSync(folderPath).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(fileName =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(folderPath, fileName) }</code> </pre> <br>  Die Ergebnisse können gefiltert werden, um nur die Dateien abzurufen und von der Ausgabe des Verzeichnisses auszuschließen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isFile = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.lstatSync(fileName).isFile() } fs.readdirSync(folderPath).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.join(folderPath, fileName)).filter(isFile) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Ordner umbenennen</font> </h3><br>  Mit den <code>fs.rename()</code> und <code>fs.renameSync()</code> können Sie den Ordner umbenennen.  Der erste Parameter ist der aktuelle Ordnerpfad, der zweite ist ein neuer: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Sie können den Ordner mit der synchronen Methode <code>fs.renameSync()</code> umbenennen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Ordner löschen</font> </h3><br>  Um einen Ordner zu löschen, können Sie die <code>fs.rmdir()</code> oder <code>fs.rmdirSync()</code> verwenden.  Es ist zu beachten, dass das Löschen eines Ordners, in dem sich etwas befindet, etwas komplizierter ist als das Löschen eines leeren Ordners.  Wenn Sie solche Ordner löschen müssen, verwenden Sie das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fs-extra</a> , das sehr beliebt ist und gut unterstützt wird.  Es ist ein Ersatz für das <code>fs</code> Modul und erweitert seine Funktionen. <br><br>  Die Methode <code>remove()</code> aus dem Paket <code>fs-extra</code> kann Ordner löschen, die bereits etwas enthalten. <br><br>  Sie können dieses Modul wie folgt installieren: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> fs-extra</code> </pre> <br>  Hier ist ein Beispiel für seine Verwendung: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs-extra'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folder = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.remove(folder, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Seine Methoden können in Form von Versprechungen angewendet werden: <br><br><pre> <code class="hljs coffeescript">fs.remove(folder).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> }).<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Das Konstrukt async / await ist ebenfalls akzeptabel: <br><br><pre> <code class="hljs matlab">async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fs</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function">   // } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catch</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">folder</span></span></span><span class="hljs-function"> = '/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Users</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flavio</span></span></span><span class="hljs-function">' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fs-Modul</font> </h2><br>  Oben sind wir bereits auf einige Methoden des <code>fs</code> Moduls <code>fs</code> , die bei der Arbeit mit dem Dateisystem verwendet werden.  In der Tat enthält es viele weitere nützliche Dinge.  Denken Sie daran, dass es nicht installiert werden muss, um es im Programm zu verwenden. Es reicht aus, es anzuschließen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>)</code> </pre> <br>  Danach haben Sie Zugriff auf seine Methoden, von denen wir Folgendes notieren, von denen einige Sie bereits kennen: <br><br><ul><li>  <code>fs.access()</code> : Überprüft das Vorhandensein einer Datei und die Möglichkeit, basierend auf Berechtigungen darauf zuzugreifen. </li><li>  <code>fs.appendFile()</code> : <code>fs.appendFile()</code> Daten an eine Datei an.  Wenn die Datei nicht vorhanden ist, wird sie erstellt. </li><li>  <code>fs.chmod()</code> : <code>fs.chmod()</code> Berechtigungen für eine bestimmte Datei.  Ähnliche Methoden: <code>fs.lchmod()</code> , <code>fs.fchmod()</code> . </li><li>  <code>fs.chown()</code> : <code>fs.chown()</code> den Eigentümer und die Gruppe für die angegebene Datei.  Ähnliche Methoden: <code>fs.fchown()</code> , <code>fs.lchown()</code> . </li><li>  <code>fs.close()</code> : Schließt den Dateideskriptor. </li><li>  <code>fs.copyFile()</code> : <code>fs.copyFile()</code> die Datei. </li><li>  <code>fs.createReadStream()</code> : <code>fs.createReadStream()</code> einen Stream zum Lesen einer Datei. </li><li>  <code>fs.createWriteStream()</code> : <code>fs.createWriteStream()</code> einen <code>fs.createWriteStream()</code> . </li><li>  <code>fs.link()</code> : <code>fs.link()</code> einen neuen festen Link zur Datei. </li><li>  <code>fs.mkdir()</code> : <code>fs.mkdir()</code> ein neues Verzeichnis. </li><li>  <code>fs.mkdtemp()</code> : <code>fs.mkdtemp()</code> ein temporäres Verzeichnis. </li><li>  <code>fs.open()</code> : <code>fs.open()</code> eine Datei. </li><li>  <code>fs.readdir()</code> : Liest den Inhalt eines Verzeichnisses. </li><li>  <code>fs.readFile()</code> : Liest den Inhalt einer Datei.  Ähnliche Methode: <code>fs.read()</code> . </li><li>  <code>fs.readlink()</code> : Liest den Wert eines symbolischen Links. </li><li>  <code>fs.realpath()</code> : <code>fs.realpath()</code> den relativen Dateipfad auf, der mit Zeichen erstellt wurde <code>.</code>  und <code>..</code> , auf dem vollen Weg. </li><li>  <code>fs.rename()</code> : <code>fs.rename()</code> eine Datei oder einen Ordner um. </li><li>  <code>fs.rmdir()</code> : <code>fs.rmdir()</code> den Ordner. </li><li>  <code>fs.stat()</code> : <code>fs.stat()</code> zurück.  Ähnliche Methoden: <code>fs.fstat()</code> , <code>fs.lstat()</code> . </li><li>  <code>fs.symlink()</code> : <code>fs.symlink()</code> einen neuen symbolischen Link zur Datei. </li><li>  <code>fs.truncate()</code> : <code>fs.truncate()</code> die Datei auf die angegebene Länge ab.  Ähnliche Methode: <code>fs.ftruncate()</code> . </li><li>  <code>fs.unlink()</code> : <code>fs.unlink()</code> eine Datei oder einen symbolischen Link. </li><li>  <code>fs.unwatchFile()</code> : <code>fs.unwatchFile()</code> die Überwachung von Dateiänderungen. </li><li>  <code>fs.utimes()</code> : <code>fs.utimes()</code> den Zeitstempel einer Datei.  Ähnliche Methode: <code>fs.futimes()</code> . </li><li>  <code>fs.watchFile()</code> : Aktiviert die Überwachung von Dateiänderungen.  Ähnliche Methode: <code>fs.watch()</code> . </li><li>  <code>fs.writeFile()</code> : Schreibt Daten in eine Datei.  Ähnliche Methode: <code>fs.write()</code> . </li></ul><br>  Ein interessantes Merkmal des <code>fs</code> Moduls ist die Tatsache, dass alle seine Methoden standardmäßig asynchron sind, es gibt jedoch auch synchrone Versionen davon, deren Namen durch Hinzufügen des Wortes <code>Sync</code> zu den Namen asynchroner Methoden erhalten werden. <br><br>  Zum Beispiel: <br><br><ul><li> <code>fs.rename()</code> </li> <li> <code>fs.renameSync()</code> </li> <li> <code>fs.write()</code> </li> <li> <code>fs.writeSync()</code> </li> </ul><br>  Die Verwendung synchroner Methoden hat schwerwiegende Auswirkungen auf die Funktionsweise des Programms. <br><br>  Node.js 10 bietet experimentelle Unterstützung für diese auf Versprechen basierenden APIs. <br><br>  Entdecken Sie die Methode <code>fs.rename()</code> .  Hier ist eine asynchrone Version dieser Methode mit Rückrufen: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Bei Verwendung der synchronen Version wird das <code>try/catch</code> Konstrukt verwendet, um Fehler zu behandeln: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Der Hauptunterschied zwischen diesen Optionen für die Verwendung dieser Methode besteht darin, dass im zweiten Fall das Skript blockiert wird, bis der Dateivorgang abgeschlossen ist. <br><br><h2>  <font color="#3AC1EF">Pfadmodul</font> </h2><br>  Das Pfadmodul, über das wir auch einige seiner Funktionen gesprochen haben, enthält viele nützliche Tools, mit denen Sie mit dem Dateisystem interagieren können.  Wie bereits erwähnt, müssen Sie es nicht installieren, da es Teil von Node.js ist.  Um es zu verwenden, reicht es aus, es anzuschließen: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br>  Die <code>path.sep</code> Eigenschaft dieses Moduls enthält das Zeichen, das zum Trennen von <code>path.sep</code> verwendet wird ( <code>\</code> unter Windows und <code>/</code> unter Linux und macOS), und die <code>path.delimiter</code> Eigenschaft gibt das Zeichen an, das zum Trennen mehrerer Pfade verwendet wird ( <code>;</code> unter Windows und <code>:</code> unter Linux) und macOS). <br><br>  Betrachten und veranschaulichen wir einige Methoden des Pfadmoduls. <br><br><h3>  <font color="#3AC1EF">▍path.basename ()</font> </h3><br>  Gibt das letzte Fragment des Pfads zurück.  Durch Übergeben des zweiten Parameters an diese Methode können Sie die Dateierweiterung entfernen. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) //something <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>) //something.txt <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>) //something</code> </pre> <br><h3>  <font color="#3AC1EF">▍path.dirname ()</font> </h3><br>  Gibt den Teil des Pfads zurück, der den Verzeichnisnamen darstellt: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span><span class="hljs-regexp"><span class="hljs-regexp">/something</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.extname ()</font> </h3><br>  Gibt den Teil des Pfads zurück, der die Dateierweiterung darstellt: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.isAbsolute ()</font> </h3><br>  Gibt true zurück, wenn der Pfad absolut ist: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'./test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.join ()</font> </h3><br>  Verbindet mehrere Teile des Pfades: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.normalize ()</font> </h3><br>  Der Versuch, den realen Pfad basierend auf dem Pfad herauszufinden, der die Zeichen enthält, die zum Erstellen relativer Pfade wie verwendet werden <code>.</code>  , <code>..</code> und <code>//</code> : <br><br><pre> <code class="hljs mel">require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">///users/test.txt</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.parse ()</font> </h3><br>  Konvertiert einen Pfad in ein Objekt, dessen Eigenschaften einzelne Teile des Pfads darstellen: <br><br><ul><li>  <code>root</code> : das Stammverzeichnis. </li><li>  <code>dir</code> : Dateipfad ab dem Stammverzeichnis </li><li>  <code>base</code> : Dateiname und Erweiterung. </li><li>  <code>name</code> : Dateiname. </li><li>  <code>ext</code> : Dateierweiterung. </li></ul><br>  Hier ist ein Beispiel mit dieser Methode: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).parse(<span class="hljs-string"><span class="hljs-string">'/users/test.txt'</span></span>)</code> </pre> <br>  Als Ergebnis seiner Arbeit erhält man folgendes Objekt: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">root</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, dir: <span class="hljs-string"><span class="hljs-string">'/users'</span></span>, base: <span class="hljs-string"><span class="hljs-string">'test.txt'</span></span>, ext: <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'test'</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">▍path.relative ()</font> </h3><br>  Nimmt als Argumente zwei Möglichkeiten.  Gibt den relativen Pfad vom ersten zum zweiten Pfad basierend auf dem aktuellen Arbeitsverzeichnis zurück: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'test.txt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/something/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'something/test.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍path.resolve ()</font> </h3><br>  Findet den absoluten Pfad basierend auf dem relativen Pfad, der an ihn übergeben wurde: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      .</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir uns die Node.js <code>fs</code> und <code>path</code> Module angesehen, die für die Arbeit mit dem Dateisystem verwendet werden.  Im nächsten Teil dieser Reihe, an dem sie endet, werden wir die Betriebssysteme, <code>events</code> und <code>http</code> Module diskutieren und über die Arbeit mit Streams und Datenbankverwaltungssystemen in Node.js sprechen. <br><br>  <b>Liebe Leser!</b>  Welche npm-Pakete verwenden Sie, wenn Sie mit dem Dateisystem in Node.js arbeiten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424969/">https://habr.com/ru/post/de424969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424957/index.html">Generieren von Bildern aus Text mit AttnGAN</a></li>
<li><a href="../de424961/index.html">MTA-STS für Postfix</a></li>
<li><a href="../de424963/index.html">Zuckerberg-Finanzierung: Gemeinsam Werkzeuge für die Wissenschaft bauen</a></li>
<li><a href="../de424965/index.html">Reagieren Sie auf die Anwendungsentwicklung mit ReasonReact</a></li>
<li><a href="../de424967/index.html">JavaScript-Verknüpfungen für Anfänger</a></li>
<li><a href="../de424971/index.html">Habrokast "Sunset Manually" # 1. Versuch, eine Umgebung für die Entwicklung eines Spielzeugs für Windows einzurichten</a></li>
<li><a href="../de424973/index.html">Gesichtserkennung auf Video: Raspberry Pi und Neural Compute Stick</a></li>
<li><a href="../de424975/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 2. Datenschema als Reflexion des Weltmodells</a></li>
<li><a href="../de424977/index.html">Aus Fehlern lernen: Anwendungen im App Store und bei Google Play optimieren</a></li>
<li><a href="../de424979/index.html">Ulme. Bequem und umständlich. HTTP, Aufgabe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>