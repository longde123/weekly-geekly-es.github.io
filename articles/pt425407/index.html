<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üë©üèø‚Äç‚öïÔ∏è ü¶Ä Firecore - um jogo divertido no AVR üèÇüèº ‚Ñ¢Ô∏è üì£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quero compartilhar outra constru√ß√£o noturna de longo prazo, que mostra que voc√™ pode criar jogos mesmo com hardware fraco. 

 Sobre o que voc√™ tinha q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore - um jogo divertido no AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  Quero compartilhar outra constru√ß√£o noturna de longo prazo, que mostra que voc√™ pode criar jogos mesmo com hardware fraco. <br><br>  Sobre o que voc√™ tinha que fazer, como foi decidido e como fazer algo mais do que apenas mais um clone de Pong - bem-vindo ao Cat. <br><br>  Cuidado: excelente artigo, tr√°fego e v√°rias inser√ß√µes de c√≥digo! <br><a name="habracut"></a><br><h3>  Brevemente sobre o jogo </h3><hr>  Atire neles!  - agora no AVR. <br><br>  Na verdade, este √© outro shmap, ent√£o mais uma vez o personagem principal <s>Shepard</s> deve salvar a gal√°xia de um ataque repentino de pessoas desconhecidas, percorrendo o espa√ßo atrav√©s das estrelas e campos de aster√≥ides, limpando simultaneamente cada sistema estelar. <br>  Todo o jogo √© escrito em C e C ++ sem usar a biblioteca Wire do Arduino. <br><br>  O jogo tem 4 navios para escolher (o √∫ltimo est√° dispon√≠vel ap√≥s a passagem), cada um com suas pr√≥prias caracter√≠sticas: <br><ul><li>  manobrabilidade; </li><li>  durabilidade; </li><li>  poder de arma. </li></ul><br>  Tamb√©m implementado: <br><ul><li>  Gr√°ficos em cores 2D; </li><li>  poder para armas; </li><li>  chefes no final dos n√≠veis; </li><li>  n√≠veis com aster√≥ides (e sua anima√ß√£o de rota√ß√£o); </li><li>  mudan√ßa de cor de fundo em n√≠veis (e n√£o apenas espa√ßo em preto); </li><li>  o movimento de estrelas ao fundo em diferentes velocidades (para efeito de profundidade); </li><li>  pontua√ß√£o e economia na EEPROM; </li><li>  os mesmos sons (tiros, explos√µes, etc.); </li><li>  um mar de oponentes id√™nticos. </li></ul><br><h3>  Plataforma </h3><hr>  O retorno do fantasma. <br><br><blockquote>  Esclarecemos antecipadamente que esta plataforma deve ser percebida como o antigo console de jogos da <s>primeira</s> terceira gera√ß√£o (anos 80, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">shiru8bit</a> ). <br></blockquote><br>  Al√©m disso, s√£o proibidas modifica√ß√µes de hardware em rela√ß√£o ao hardware original, o que garante o lan√ßamento em qualquer outra placa id√™ntica imediatamente. <br>  Este jogo foi escrito para o conselho do Arduino Esplora, mas a transfer√™ncia para o GBA ou qualquer outra plataforma, acho, n√£o ser√° dif√≠cil. <br>  No entanto, mesmo neste recurso, este f√≥rum foi abordado apenas algumas vezes, e outros conselhos n√£o valiam a pena mencionar, apesar da grande comunidade de cada um: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  makerBuino; </li><li>  Arduboy; </li><li>  UzeBox / FuzeBox; </li><li>  e muitos outros. </li></ul><br>  Para come√ßar, o que n√£o est√° no Esplora: <br><ul><li>  muita mem√≥ria (ROM 28kb, RAM 2.5kb); </li><li>  pot√™ncia (CPU de 8 bits a 16 MHz); </li><li>  DMA </li><li>  gerador de caracteres; </li><li>  √°reas de mem√≥ria alocadas ou registros especiais.  destino (paleta, ladrilhos, plano de fundo, etc.); </li><li>  controlar o brilho da tela (oh, tantos efeitos no lixo); </li><li>  extensores de espa√ßo de endere√ßo (mapeadores); </li><li>  depurador ( <s>mas quem precisa quando h√° uma tela inteira!</s> ). </li></ul><br>  Vou continuar com o fato de que existe: <br><ul><li>  SPI de hardware (pode ser executado na velocidade F_CPU / 2); </li><li>  tela baseada em ST7735 160x128 1,44 "; </li><li>  uma pitada de temporizadores (apenas 4 pe√ßas); </li><li>  uma pitada de GPIO; </li><li>  um punhado de bot√µes (5pcs. + joystick de dois eixos); </li><li>  poucos sensores (ilumina√ß√£o, aceler√¥metro, term√¥metro); </li><li>  emissor de <s>irrita√ß√£o</s> piezo. </li></ul><br>  Aparentemente, n√£o h√° quase nada l√°.  N√£o √© de surpreender que ningu√©m quisesse fazer nada com ela, exceto o clone Pong e alguns jogos durante todo esse tempo! <br>  Talvez o fato seja que escrever sob o controlador ATmega32u4 (e similares) √© semelhante √† programa√ß√£o para Intel 8051 (que tem quase 40 anos no momento da publica√ß√£o), onde √© necess√°rio observar um grande n√∫mero de condi√ß√µes e recorrer a v√°rios truques e truques. <br><br><h3>  Processamento perif√©rico </h3><hr>  Um por tudo! <br><br>  Tendo examinado o circuito, ficou claramente vis√≠vel que todos os perif√©ricos est√£o conectados atrav√©s do expansor GPIO (74HC4067D multiplexador mais MUX) e s√£o comutados usando o GPIO PF4, PF5, PF6, PF7 ou a mordidela PORTF s√™nior, e a sa√≠da MUX √© lida no GPIO - PF1. <br>  √â muito conveniente alternar a entrada simplesmente atribuindo os valores √† porta PORTF por m√°scara e de forma alguma esquecendo a menor mordidela: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Enquete de clique no bot√£o: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  A seguir est√£o os valores para a porta F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  Adicionando um pouco mais: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  Voc√™ pode entrevistar com seguran√ßa a cruz certa: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Observe que o estado anterior n√£o √© redefinido; caso contr√°rio, voc√™ pode perder o fato de pressionar a tecla (ela tamb√©m funciona como uma prote√ß√£o adicional contra conversas). <br><br><h3>  Sfx </h3><hr>  Um zumbido. <br><br>  E se n√£o houver DAC, nenhum chip da Yamaha e houver apenas um ret√¢ngulo PWM de 1 bit para som? <br>  No come√ßo, parece n√£o muito, mas, apesar disso, o astuto PWM √© usado aqui para recriar a t√©cnica ‚Äú√°udio PDM‚Äù e, com sua ajuda, voc√™ pode fazer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isso.</a> <br><br>  Algo semelhante √© fornecido pela biblioteca do Gamebuino e tudo o que √© necess√°rio √© transferir o gerador de popping para outro GPIO e o timer para o Esplora (sa√≠da do timer4 e OCR4D).  Para uma opera√ß√£o correta, o timer1 tamb√©m √© usado para gerar interrup√ß√µes e recarregar o registro OCR4D com novos dados. <br><br>  O mecanismo Gamebuino usa padr√µes de som (como na m√∫sica do rastreador), o que economiza muito espa√ßo, mas voc√™ precisa fazer todas as amostras sozinho, n√£o h√° bibliotecas com as j√° prontas. <br>  Vale ressaltar que esse mecanismo est√° vinculado a um per√≠odo de atualiza√ß√£o de cerca de 1/50 s ou 20 quadros / s. <br><br>  Para ler os padr√µes de som, depois de ler o Wiki em formato de √°udio, desenhei uma GUI simples no Qt.  N√£o produz som da mesma maneira, mas fornece um conceito aproximado de como o padr√£o soar√° e permite carregar, salvar e editar. <br><br><h3>  Gr√°ficos </h3><hr>  Pixelart imortal. <br><br>  A exibi√ß√£o codifica as cores em dois bytes (RGB565), mas como as imagens nesse formato ocupam muito, todas elas foram indexadas pela paleta para economizar espa√ßo, que eu j√° descrevi mais de uma vez nos artigos anteriores. <br>  Ao contr√°rio do Famicom / NES, n√£o h√° limites de cores para a imagem e h√° mais cores dispon√≠veis na paleta. <br><br>  Cada imagem no jogo √© uma matriz de bytes na qual os seguintes dados s√£o armazenados: <br><ul><li>  largura, altura; </li><li>  iniciar marcador de dados; </li><li>  dicion√°rio (se houver, mas mais sobre isso posteriormente); </li><li>  carga √∫til; </li><li>  fim do marcador de dados. </li></ul><br>  Por exemplo, essa imagem (ampliada 10 vezes): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  no c√≥digo, ficar√° assim: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  Onde sem um navio neste g√™nero?  Ap√≥s centenas de esbo√ßos de teste com uma diferen√ßa de pixels, apenas esses navios permaneceram para o jogador: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  Vale ressaltar que os navios n√£o t√™m chama nos ladrilhos (aqui √© para maior clareza), √© aplicado separadamente para criar uma anima√ß√£o do escapamento do motor. <br><br>  N√£o se esque√ßa dos pilotos de cada navio: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  A varia√ß√£o das naves inimigas n√£o √© muito grande, mas lembre-se de que n√£o h√° muito espa√ßo, ent√£o aqui est√£o tr√™s naves: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Sem b√¥nus can√¥nicos na forma de melhorar armas e restaurar a sa√∫de, o jogador n√£o vai durar muito: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  Obviamente, com o aumento do poder das armas, o tipo de proj√©til emitido muda: <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  Como foi escrito no come√ßo, o jogo tem um n√≠vel de aster√≥ides, depois de cada segundo chefe.  √â interessante que existem muitos objetos em movimento e rota√ß√£o de tamanhos diferentes.  Al√©m disso, quando um jogador os atinge, eles entram em colapso parcial, ficando menores em tamanho. <br><blockquote>  Dica: Aster√≥ides grandes ganham mais pontos. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  Para criar esta anima√ß√£o simples, basta 12 imagens pequenas: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  Eles s√£o divididos em tr√™s para cada tamanho (grande, m√©dio e pequeno) e para cada √¢ngulo de rota√ß√£o, voc√™ precisa de mais 4 rodados de 0, 90, 180 e 270 graus.  No jogo, basta substituir o ponteiro do array pela imagem em um intervalo igual, criando a ilus√£o de rota√ß√£o. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  Isso √© feito apenas devido √† falta de recursos de hardware, e uma implementa√ß√£o de software como a transforma√ß√£o Affine levar√° mais do que as pr√≥prias imagens e ser√° muito lenta. <br><br><div class="spoiler">  <b class="spoiler_title">Um peda√ßo de cetim para quem est√° interessado.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  Voc√™ pode notar parte dos prot√≥tipos e o que aparece apenas nos cr√©ditos ap√≥s a aprova√ß√£o no jogo. <br></div></div><br>  Al√©m dos gr√°ficos simples, para economizar espa√ßo e adicionar um efeito retr√¥, os glifos em min√∫sculas e todos os glifos com at√© 30 e ap√≥s 127 bytes de ASCII foram expulsos da fonte. <br><blockquote>  Importante! <br>  N√£o esque√ßa que const e constexpr no AVR n√£o significam que os dados estejam na mem√≥ria do programa; aqui, para isso, √© necess√°rio usar PROGMEM adicionalmente. <br>  Isso se deve ao fato de o n√∫cleo do AVR ser baseado na arquitetura de Harvard, portanto, s√£o necess√°rios c√≥digos de acesso especiais para a CPU para acessar os dados. <br></blockquote><br><h3>  Espremendo a gal√°xia </h3><hr>  A maneira mais f√°cil de embalar √© o RLE. <br><br>  Depois de estudar os dados compactados, voc√™ pode observar que o bit mais significativo no byte de carga √∫til no intervalo de 0x00 a 0x50 n√£o √© usado.  Isso permite adicionar os dados e o marcador de in√≠cio para o in√≠cio da repeti√ß√£o (0x80) e o pr√≥ximo byte para indicar o n√∫mero de repeti√ß√µes, o que permite compactar uma s√©rie de 257 (+2 do fato de que o RLE de dois bytes √© est√∫pido) de bytes id√™nticos em apenas dois. <br>  Implementa√ß√£o e exibi√ß√£o do desempacotador: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  O principal √© n√£o exibir a imagem fora da tela, caso contr√°rio, ser√° lixo, pois n√£o h√° verifica√ß√£o de borda aqui. <br>  A imagem de teste √© descompactada em ~ 39ms.  ao mesmo tempo, ocupando 3040 bytes, enquanto sem compacta√ß√£o seriam necess√°rios 11.200 bytes ou 22.400 bytes sem indexa√ß√£o. <br><br>  Imagem de teste (ampliada 2 vezes): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  Na imagem acima, voc√™ pode ver o entrela√ßamento, mas na tela √© suavizado pelo hardware, criando um efeito semelhante ao CRT e, ao mesmo tempo, aumentando significativamente a taxa de compacta√ß√£o. <br><br><h3>  O RLE n√£o √© uma panac√©ia </h3><hr>  Somos tratados por d√©j√† vu. <br><br>  Como voc√™ sabe, o RLE funciona bem com empacotadores do tipo LZ.  O WiKi veio ao resgate com uma lista de m√©todos de compacta√ß√£o.  O √≠mpeto foi o v√≠deo de "GameHut" sobre a an√°lise da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o</a> imposs√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Sonic 3D Blast.</a> <br>  Tendo estudado muitos empacotadores (LZ77, LZW, LZSS, LZO, RNC, etc.), cheguei √† conclus√£o de que seus desembaladores: <br><ul><li>  requer muita RAM para dados descompactados (pelo menos 64kb. e mais); </li><li>  volumoso e lento (alguns precisam construir √°rvores Huffman para cada subunidade); </li><li>  tenha uma baixa taxa de compacta√ß√£o com uma pequena janela (requisitos de RAM muito rigorosos); </li><li>  tem ambig√ºidades com o licenciamento. </li></ul><br>  Ap√≥s meses de adapta√ß√µes f√∫teis, decidiu-se modificar o empacotador existente. <br>  Por analogia com os empacotadores do tipo LZ, para obter a compacta√ß√£o m√°xima, o acesso ao dicion√°rio foi usado, mas no n√≠vel de bytes - os pares de bytes repetidos com mais freq√º√™ncia s√£o substitu√≠dos por um ponteiro de byte no dicion√°rio. <br>  Mas h√° um problema: como distinguir um byte de "quantas repeti√ß√µes" de um "marcador de dicion√°rio"? <br>  Depois de uma longa sess√£o com um peda√ßo de papel e um jogo m√°gico com morcegos, isso apareceu: <br><blockquote><ul><li>  "Marcador de dicion√°rio" √© um marcador RLE (0x80) + byte de dados (0x50) + n√∫mero da posi√ß√£o no dicion√°rio; </li><li>  limite o byte "quantas repeti√ß√µes" ao tamanho do marcador do dicion√°rio - 1 (0xCF); </li><li>  o dicion√°rio n√£o pode usar o valor 0xff (√© para o marcador no final da imagem). </li></ul><br></blockquote><br>  Aplicando tudo isso, obtemos um tamanho fixo de dicion√°rio: n√£o mais de 46 pares de bytes e redu√ß√£o de RLE para 209 bytes.  Obviamente, nem todas as imagens podem ser empacotadas dessa maneira, mas n√£o ser√£o mais exibidas. <br>  Nos dois algoritmos, a estrutura da imagem compactada ser√° a seguinte: <br><ul><li>  1 byte por largura e altura; </li><li>  1 byte para o tamanho do dicion√°rio, √© um ponteiro de marcador para o in√≠cio dos dados compactados; </li><li>  de 0 a 92 bytes do dicion√°rio; </li><li>  1 a N bytes de dados compactados. </li></ul><br>  O utilit√°rio empacotador resultante no D (pickoPacker) √© suficiente para colocar em uma pasta com arquivos * .png indexados e executar a partir do terminal (ou cmd).  Se precisar de ajuda, execute com a op√ß√£o "-h" ou "--help". <br>  Ap√≥s a execu√ß√£o do utilit√°rio, obtemos arquivos * .h, cujo conte√∫do √© conveniente para a transfer√™ncia para o local certo no projeto (portanto, n√£o h√° prote√ß√£o). <br><br>  Antes de desembalar, a tela, o dicion√°rio e os dados iniciais s√£o preparados: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  Uma parte de dados lida pode ser compactada em um dicion√°rio, portanto, a verificamos e descompactamos: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Agora, a partir do buffer recebido, descompactamos o RLE de maneira familiar e o exibimos na tela: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Surpreendentemente, a substitui√ß√£o do algoritmo n√£o afetou significativamente o tempo de descompacta√ß√£o e √© de ~ 47ms.  Isso √© quase 8ms.  por mais tempo, mas a imagem de teste leva apenas 1650 bytes! <br><br><h3>  At√© a √∫ltima medida </h3><hr>  Quase tudo pode ser feito mais r√°pido! <br><br>  Apesar da presen√ßa de SPI de hardware, o n√∫cleo do AVR oferece muita dor de cabe√ßa ao us√°-lo. <br>  H√° muito se sabe que o SPI no AVR, al√©m de rodar na velocidade F_CPU / 2, tamb√©m possui um registro de dados de apenas 1 byte (n√£o √© poss√≠vel carregar 2 bytes de uma vez). <br>  Al√©m disso, quase todo o c√≥digo SPI no AVR que conheci funciona de acordo com este esquema: <br><ul><li>  Baixar dados SPDR </li><li>  interrogar o bit SPIF no SPSR em um loop. </li></ul><br>  Como voc√™ pode ver, o fornecimento cont√≠nuo de dados, como √© feito no STM32, n√£o cheira aqui.  Mas, mesmo aqui voc√™ pode acelerar a sa√≠da de ambos os desempacotadores em ~ 3ms! <br><br>  Abrindo a folha de dados e observando a se√ß√£o "Rel√≥gios do conjunto de instru√ß√µes", √© poss√≠vel calcular os custos da CPU ao transmitir um byte via SPI: <br><ul><li>  1 ciclo para carregamento de registro com novos dados; </li><li>  2 batidas por bit (ou 16 batidas por byte); </li><li>  1 barra por linha m√°gica do rel√≥gio (um pouco mais tarde sobre "NOP"); </li><li>  1 rel√≥gio para verificar o bit de status no SPSR (ou 2 rel√≥gio na filial); </li></ul><br>  No total, para transmitir um pixel (dois bytes), 38 ciclos de clock ou ~ 425600 ciclos para a imagem de teste (11.200 bytes) devem ser gastos. <br>  Sabendo que F_CPU == 16 MHz obtemos <s>0,0000000625</s> 62,5 nanossegundos por ciclo de clock ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Process0169</a> ), multiplicando os valores, obtemos ~ 26 milissegundos.  Surge a pergunta: ‚ÄúDe onde escrevi anteriormente que o tempo de desempacotamento √© de 39ms.  e 47ms. "?  Tudo √© simples - l√≥gica do desempacotador + manipula√ß√£o de interrup√ß√£o. <br><br>  Aqui est√° um exemplo de sa√≠da de interrup√ß√£o: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  e sem interrup√ß√£o: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  Os gr√°ficos mostram que o tempo entre a configura√ß√£o da janela de endere√ßo na tela VRAM e o in√≠cio da transfer√™ncia de dados na vers√£o sem interrup√ß√µes √© menor e quase n√£o h√° intervalos entre os bytes durante a transmiss√£o (o gr√°fico √© uniforme). <br>  Infelizmente, voc√™ n√£o pode desativar as interrup√ß√µes para cada sa√≠da de imagem, caso contr√°rio, o som e o n√∫cleo de todo o jogo ser√£o interrompidos (mais sobre isso mais tarde). <br><br>  Foi escrito acima sobre um certo "NOP m√°gico" para uma linha de rel√≥gio.  O fato √© que, para estabilizar o CLK e definir o sinalizador SPIF, s√£o necess√°rios exatamente 1 ciclo de rel√≥gio e, quando este sinalizador √© lido, ele j√° est√° configurado, o que evita ramifica√ß√µes em 2 barras na instru√ß√£o BREQ. <br>  Aqui est√° um exemplo sem um NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  e com ele: <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  A diferen√ßa parece insignificante, apenas alguns microssegundos, mas se voc√™ tomar uma escala diferente: <br>  NOP grande: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  e com ele muito grande: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  ent√£o a diferen√ßa se torna muito mais vis√≠vel, atingindo ~ 4.3ms. <br><br>  Agora vamos fazer o seguinte truque sujo: <br><blockquote>  Trocamos a ordem de carregamento e leitura dos registros e voc√™ n√£o pode esperar em cada segundo byte do sinalizador SPIF, mas verifique-o apenas antes de carregar o primeiro byte do pr√≥ximo pixel. <br></blockquote><br>  Aplicamos conhecimento e implantamos a fun√ß√£o "pushColorFast (repeatColor);": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  Apesar da interrup√ß√£o do timer, o uso do truque acima d√° um ganho de quase 6ms. <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  √â assim que o conhecimento simples do ferro permite extrair um pouco mais dele e gerar algo semelhante: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Colis√µes no Coliseu </h3><hr>  A batalha das caixas. <br><br>  Para come√ßar, todo o conjunto de objetos (naves, conchas, aster√≥ides, b√¥nus) s√£o estruturas (sprites) com os seguintes par√¢metros: <br><ul><li>  coordenadas X, Y atuais; </li><li>  novas coordenadas X, Y; </li><li>  ponteiro para a imagem. </li></ul><br>  Como a imagem armazena a largura e a altura, n√£o h√° necessidade de duplicar esses par√¢metros; al√©m disso, essa organiza√ß√£o simplifica a l√≥gica em muitos aspectos. <br><br>  O c√°lculo em si √© simplificado para o banal - com base na interse√ß√£o dos ret√¢ngulos.  Embora n√£o seja preciso o suficiente e n√£o calcule conflitos futuros, isso √© mais do que suficiente. <br>  A verifica√ß√£o ocorre alternadamente nos eixos X e Y. Por esse motivo, a aus√™ncia de interse√ß√£o no eixo X reduz o c√°lculo da colis√£o. <br><blockquote>  Primeiro, o lado direito do primeiro ret√¢ngulo com o lado esquerdo do segundo ret√¢ngulo √© verificado para a parte comum do eixo X. Se for bem-sucedido, uma verifica√ß√£o semelhante ser√° realizada para o lado esquerdo do primeiro e do lado direito do segundo ret√¢ngulo. <br>  Ap√≥s a detec√ß√£o bem-sucedida de interse√ß√µes ao longo do eixo X, uma verifica√ß√£o √© realizada da mesma maneira para os lados superior e inferior dos ret√¢ngulos ao longo do eixo Y. <br></blockquote><br>  O exposto acima parece muito mais f√°cil do que parece: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  Resta acrescentar isso ao jogo: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Curva de Bezier </h3><hr>  Trilhos espaciais. <br><br>  Como em qualquer outro jogo com esse g√™nero, os navios inimigos devem se mover ao longo das curvas. <br>  Foi decidido implementar curvas quadr√°ticas como as mais simples para o controlador e para esta tarefa.  Tr√™s pontos s√£o suficientes para eles: o inicial (P0), o final (P2) e o imagin√°rio (P1).  Os dois primeiros especificam o in√≠cio e o fim da linha, o √∫ltimo ponto descreve o tipo de curvatura. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√ìtimo artigo sobre curvas.</a> <br>  Como essa √© uma curva param√©trica de Bezier, ela tamb√©m precisa de mais um par√¢metro - o n√∫mero de pontos intermedi√°rios entre os pontos inicial e final. <br><br>  Total chegamos aqui a essa estrutura: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  Nele, position_t √© uma estrutura de dois bytes das coordenadas X e Y. <br>  A localiza√ß√£o de um ponto para cada coordenada √© calculada usando esta f√≥rmula (thx Wiki): <br>  B = ((1,0 - t) ^ 2) P0 + 2t (1,0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 e&amp; &lt;= 1] <br><br>  Por um longo tempo, sua implementa√ß√£o foi resolvida de frente, sem uma matem√°tica de ponto fixo: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Claro, isso n√£o pode ser deixado.  Afinal, livrar-se do flutuador n√£o s√≥ poderia melhorar a velocidade, mas tamb√©m liberar a ROM; portanto, as seguintes implementa√ß√µes foram encontradas: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  O primeiro continua sendo um azar√£o, pois √© uma biblioteca compilada e n√£o queria mexer com o desmontador. <br><br>  O segundo candidato do pacote GCC tamb√©m n√£o deu certo, pois o avr-gcc usado n√£o foi corrigido e o tipo "short _Accum" permaneceu indispon√≠vel. <br><br>  A terceira op√ß√£o, apesar de possuir um grande n√∫mero de mantas.  possui opera√ß√µes de bits codificadas em bits espec√≠ficos no formato Q16.16, o que torna imposs√≠vel controlar os valores de Q e I. <br><br>  Esta √∫ltima pode ser considerada uma vers√£o simplificada de "Fixedmath", mas a principal vantagem √© a capacidade de controlar n√£o apenas o tamanho da vari√°vel, que por padr√£o √© de 32 bits com o formato Q24.8, mas tamb√©m os valores de Q e I. <br><br>  Resultados do teste em diferentes configura√ß√µes: <br><table><tbody><tr><th>  Tipo </th><th>  QI </th><th>  Sinalizadores adicionais </th><th>  Byte de ROM </th><th>  Tms. * </th></tr><tr><td>  flutuar </td><td>  - </td><td>  - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  fixo </td><td>  16.16 </td><td>  - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  fixo </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  fixo </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  fixo </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24,8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9,7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * A verifica√ß√£o foi realizada no padr√£o: "195,175,145,110,170,70,170" e na chave "-Os". <br><br>  Pode ser visto na tabela que ambas as bibliotecas ocupavam mais ROM e se mostravam piores que o c√≥digo compilado do GCC ao usar o float. <br>  Tamb√©m √© visto que uma pequena revis√£o para o formato Q9.7 e uma diminui√ß√£o na vari√°vel para 16 bits deram uma acelera√ß√£o de 4ms.  e liberando ROM a ~ 50 bytes. <br><br>  O efeito esperado foi uma diminui√ß√£o na precis√£o e um aumento no n√∫mero de erros: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  que neste caso n√£o √© cr√≠tico. <br><br><h3>  Alocando Recursos </h3><hr>  Ter√ßa e quinta-feira trabalham por apenas uma hora. <br><br>  Na maioria dos casos, todos os c√°lculos s√£o executados em todos os quadros, o que nem sempre √© justificado, pois pode n√£o haver tempo suficiente no quadro para calcular algo e voc√™ ter√° que tentar alternar, contar quadros ou ignor√°-los.  Ent√£o fui mais longe - abandonei completamente a equipe. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo dividido tudo em pequenas tarefas, seja: calcular colis√µes, processar sons, bot√µes e exibir gr√°ficos, basta execut√°-las em um determinado intervalo, e a in√©rcia do olho e a capacidade de atualizar apenas parte da tela ser√£o suficientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerenciamos tudo isso nem uma vez com o sistema operacional, mas com a m√°quina de estado que eu criei alguns anos atr√°s, ou, mais simplesmente, n√£o com o gerenciador de tarefas tinySM que est√° se aglomerando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repito as raz√µes para us√°-lo em vez de qualquer um dos RTOS:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requisitos m√≠nimos de ROM (n√∫cleo de ~ 250 bytes); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menores requisitos de RAM (~ 9 bytes por tarefa); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> princ√≠pio simples e compreens√≠vel do trabalho; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determinismo de comportamento; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menos tempo de CPU √© desperdi√ßado; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deixa o acesso ao ferro; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plataforma independente; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito em C e f√°cil de quebrar em C ++; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisava da minha pr√≥pria bicicleta.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como descrevi uma vez, as tarefas para ele s√£o organizadas em uma matriz de ponteiros para estruturas, onde um ponteiro para uma fun√ß√£o e seu intervalo de chamada s√£o armazenados. </font><font style="vertical-align: inherit;">Esse agrupamento simplifica a descri√ß√£o do jogo em est√°gios separados, o que tamb√©m permite reduzir o n√∫mero de ramifica√ß√µes e alternar dinamicamente o conjunto de tarefas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, durante a tela inicial, 7 tarefas s√£o executadas e durante o jogo j√° existem 20 tarefas (todas as tarefas s√£o descritas no arquivo gameTasks.c). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, voc√™ precisa definir algumas macros para sua conveni√™ncia:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A declara√ß√£o da tarefa est√° realmente criando uma estrutura, inicializando seus campos e colocando-a na ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada uma dessas estruturas ocupa 4 bytes de ROM (dois por ponteiro e dois por intervalo). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um bom b√¥nus para macros √© que n√£o funciona para criar mais de uma estrutura exclusiva para cada fun√ß√£o. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de declarar as tarefas necess√°rias, as adicionamos √† matriz e tamb√©m as colocamos na ROM:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao definir o sinalizador USE_DYNAMIC_MEM como 0 para mem√≥ria est√°tica, o principal a lembrar √© inicializar os ponteiros para o armazenamento de tarefas na RAM e definir o n√∫mero m√°ximo deles que ser√£o executados: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configurando tarefas para execu√ß√£o: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prote√ß√£o contra estouro √© controlada pelo sinalizador USE_MEM_PANIC; se voc√™ tiver certeza do n√∫mero de tarefas, poder√° desativ√°-lo para salvar a ROM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta apenas executar o manipulador:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dentro, h√° um loop infinito que cont√©m a l√≥gica b√°sica. </font><font style="vertical-align: inherit;">Uma vez dentro dela, a pilha tamb√©m √© restaurada gra√ßas a "__attribute__ ((noreturn))". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No loop, os elementos da matriz s√£o varridos alternadamente para a necessidade de chamar a tarefa ap√≥s o intervalo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A contagem regressiva dos intervalos foi feita com base no timer0 como um sistema com um quantum de 1ms ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar da distribui√ß√£o bem-sucedida de tarefas no tempo, √†s vezes elas se sobrepunham (tremula√ß√£o), o que causava desbotamento a curto prazo de tudo e de tudo no jogo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitivamente tinha que ser decidido, mas como? </font><font style="vertical-align: inherit;">Sobre como tudo foi tra√ßado na pr√≥xima vez, mas, por enquanto, tente encontrar o ovo da P√°scoa na fonte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O fim </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, usando muitos truques (e muitos mais dos quais eu n√£o descrevi), tudo se encaixava na ROM de 24kb e 1500 bytes de RAM. </font><font style="vertical-align: inherit;">Se voc√™ tiver alguma d√∫vida, terei prazer em respond√™-las.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para quem n√£o encontrou ou n√£o procurou um ovo de P√°scoa:</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cavar para o lado: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nada not√°vel, certo? </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raaaaazvorachivaem macro invadersMagicRespawn:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   ¬´(void)¬ª    ,  ¬´action()¬ª          10 ,    ¬´disablePause();¬ª.               ¬´Matrix Falling code¬ª    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para construir e executar, basta colocar a pasta (ou link) "esploraAPI" em "/ arduino / libraries /". </font></font><br><br>  Refer√™ncias: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um jogo;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empacotador pickoPacker;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Voc√™ pode ver e ouvir como tudo fica um pouco mais tarde quando eu fa√ßo um v√≠deo aceit√°vel. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425407/">https://habr.com/ru/post/pt425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425395/index.html">10 fatos f√≠sicos que voc√™ deveria conhecer na escola, mas que talvez n√£o soubesse</a></li>
<li><a href="../pt425397/index.html">10 bibliotecas que todo desenvolvedor Android deve conhecer</a></li>
<li><a href="../pt425401/index.html">Relat√≥rio do Clube de Roma de 2018, cap√≠tulo 1.11: Tecnologia disruptiva e revolu√ß√£o digital</a></li>
<li><a href="../pt425403/index.html">Finan√ßas do criador do Craigslist: site contra not√≠cias falsas, discrimina√ß√£o e excessos de gigantes da Internet</a></li>
<li><a href="../pt425405/index.html">Newtypes de grande pot√™ncia</a></li>
<li><a href="../pt425409/index.html">DevBoy: criando um gerador de sinal</a></li>
<li><a href="../pt425411/index.html">Scrum est√° morto</a></li>
<li><a href="../pt425413/index.html">Joons s√£o t√£o bons?</a></li>
<li><a href="../pt425415/index.html">Perl 5: como as macros ocultam erros</a></li>
<li><a href="../pt425417/index.html">Flash para todos. Todos os Flash Array da QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>