<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üî¥ üìÖ Die ganze Wahrheit √ºber RTOS. Artikel 8. Nucleus SE: Internes Design und Bereitstellung üåÉ üßïüèº üë©üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel setzt die √úberpr√ºfung von Nucleus SE fort. 

 Dienstleistungen 
 Nucleus SE bietet eine Reihe von Tools, die von jedem RTOS erwartet we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 8. Nucleus SE: Internes Design und Bereitstellung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422617/"><img src="https://habrastorage.org/webt/b_/hz/jv/b_hzjvxfyiqk1hj4znoykfy4iyi.jpeg"><br><br>  Dieser Artikel setzt die √úberpr√ºfung von Nucleus SE fort. <br><br><h2>  Dienstleistungen </h2><br>  Nucleus SE bietet eine Reihe von Tools, die von jedem RTOS erwartet werden k√∂nnen. <br>  Erstens enth√§lt Nucleus SE einen relativ einfachen Scheduler, der jedoch dank der vier verf√ºgbaren Optionen Flexibilit√§t bietet.  Der Scheduler unterst√ºtzt die Algorithmen Run to Completion, Round Robin, Carousel, Time Slice und Priority. <br><a name="habracut"></a><br>  Die Nucleus SE-API enth√§lt etwa 50 Dienstprogrammaufrufe, mit denen Entwickler auf Aufgabenverwaltung, Speicherabschnitte, Signale, Ereignisflaggruppen, Semaphoren, Postf√§cher, Warteschlangen, Pipelines, Systemzeit, Anwendungszeitgeber und Diagnose zugreifen k√∂nnen. <br><br>  Neben der einfachen Aufgabenplanung unterst√ºtzt Nucleus SE (optional) die Aufgabenpause.  Diese Funktion kann "sauber" sein (z. B. als Ergebnis eines explizit festgelegten API-Aufrufs f√ºr den Suspendierungsdienst), eine "Sleep" -Funktion (wenn eine Task f√ºr einen bestimmten Zeitraum angehalten wird) oder das Ergebnis eines anderen API-Aufrufs, bei dem die Task blockiert wird (die sogenannte "bedingte" Suspendierung), die auf den Zugriff auf die Kernelressource wartet.  Im Gegensatz zu Nucleus RTOS unterst√ºtzt Nucleus SE keine Zeit√ºberschreitungen beim Blockieren von API-Aufrufen. <br><br>  Die Vielzahl der vorgestellten Mechanismen erm√∂glicht es Ihnen, aus einer Hierarchie von Mitteln zur Synchronisierung und Kommunikation zwischen Aufgaben auszuw√§hlen: von Semaphoren √ºber Signale, Ereignisflags, Postf√§cher bis hin zu Warteschlangen / Pipelines. <br><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  √úberpr√ºfung der Parameter </h2><br>  Bei Auswahl der Konfiguration <b>NUSE_API_PARAMETER_CHECKING</b> ist der Code zum √úberpr√ºfen der Parameter in allen API-Funktionen enthalten: √úberpr√ºfen auf Nullzeiger, Objektindizes usw. Da dies zus√§tzlicher Code ist, der zus√§tzlichen Speicher ben√∂tigt, ist es ratsam, diese Funktion w√§hrend des Debuggens zu aktivieren, sie jedoch in der Release-Assembly zu deaktivieren. <br><br><h2>  Konfiguration </h2><br>  Nucleus SE hat eine flexible Struktur, die uns zwei positive Punkte gibt.  Einerseits kann der Kernel eine fein abgestimmte Konfiguration haben, die aufgrund der einfachen Konfiguration der verf√ºgbaren Funktionen und der einfachen Verwaltung der Speichernutzung die Aufgaben einer bestimmten Anwendung erf√ºllt.  Andererseits kann der Nucleus SE-Code problemlos zwischen beiden Tools und zwischen Prozessoren √ºbertragen werden. <br><br><h2>  Namenskonventionen </h2><br>  Da Klarheit und Verst√§ndlichkeit bei der Entwicklung von Nucleus SE wichtig waren, wurden die Namenskonventionen sorgf√§ltig durchdacht.  Jedem Zeichen im Code wird <b>NUSE_</b> vorangestellt <b>.</b>  Alles, was diesem Pr√§fix folgt, folgt einer Reihe einfacher Regeln. <br><br><h3>  API-Aufrufe </h3><br>  Jede API- <b>Aufruffunktion</b> in Nucleus SE beginnt mit <b>NUSE_, auf</b> das fast immer ein Objekttyp folgt, gefolgt von einer Operation in gemischten Gro√ü- und Kleinschreibung, die durch Unterstriche getrennt ist.  Ein Beispiel ist die Funktion <b>NUSE_Queue_Send ()</b> , mit der Nachrichten in die <b>Warteschlange gestellt werden</b> . <br><br><h3>  Andere Funktionen und Variablen </h3><br>  Die √ºbrigen Funktionen und (globalen) Variablen im Nucleus SE-Code verwenden ebenfalls das Pr√§fix NUSE_, der Rest des Namens hat jedoch nicht immer eine ‚ÄûStruktur‚Äú.  Dies ist f√ºr den durchschnittlichen Kernel-Benutzer unwichtig, da er √ºber gen√ºgend API-Funktionen verf√ºgt. <br><br><h3>  Konfigurationssymbole </h3><br>  Da Nucleus SE mit # define-Zeichen konfiguriert ist, befolgen sie auch Namenskonventionen.  Sie werden nur in Gro√übuchstaben geschrieben.  Die Namen der Aktivatoren der API-Aufrufe <b>stimmen</b> mit den Namen der Funktionen <b>√ºberein</b> und werden auch in Gro√übuchstaben geschrieben, z. B. <b>NUSE_QUEUE_SEND.</b> <br><br><h3>  Andere #define Zeichen </h3><br>  Alle anderen <b># Define-</b> Zeichen (z. B. API-Aufrufparameter und R√ºckgabestatuswerte), die vom Anwendungscode verwendet werden k√∂nnen, befolgen dieselben Regeln. Sie beginnen mit <b>NUSE_</b> und werden in Gro√übuchstaben geschrieben.  Zum Beispiel <b>NUSE_SUCCESS.</b> <br><br><h2>  Datenstrukturen </h2><br>  Alle RTOSs verf√ºgen √ºber eine Reihe von Datenstrukturen, die Kernelobjekte beschreiben.  In den meisten Implementierungen handelt es sich um Datenstrukturen in C, die verkn√ºpfte Listen bilden, h√§ufig mit bidirektionaler und sogar zirkul√§rer Kommunikation.  Dies ist logisch, da wichtige Daten bequem gekapselt werden und Listenelemente hinzugef√ºgt oder gel√∂scht werden k√∂nnen, wenn Objekte erstellt und gel√∂scht werden. <br><br>  In Nucleus SE sind alle Objekte statisch, daher war es naheliegend, alle Datenstrukturen dieser Objekte in einer einfachen Liste zu organisieren.  Dies reduziert das Volumen und die Komplexit√§t von Vorw√§rts- und R√ºckw√§rtszeigern.  Ich entschied mich jedoch, die Optimierung des Systems zu verst√§rken und lehnte es ab, √ºberhaupt Strukturen zu verwenden.  In Nucleus SE werden alle Daten von Kernelobjekten durch mehrere einfache Arrays (auch als Tabellen bezeichnet) verschiedener Typen dargestellt, eines oder mehrere f√ºr jeden Objekttyp.  Es gibt mehrere Argumente f√ºr diese Entscheidung: <br><br><ul><li>  Nucleus SE wurde unter Ber√ºcksichtigung der Kompatibilit√§t mit 8-Bit-Strukturen entwickelt.  Die meisten kleinen CPUs verf√ºgen nicht √ºber optimale Tools zum Implementieren von Datenstrukturen in einem C-Compiler.  Einfache Arrays sind viel effizienter. </li><li>  Da die maximal zul√§ssige Anzahl von Objekten jedes Typs 16 betr√§gt und der Zugriff auf die Elemente jedes Arrays vier Bits erfordert, wird h√§ufig ein Byte verwendet.  Dies ist effizienter als eine Adresse, die normalerweise 16 oder 32 Bit ben√∂tigt. </li><li>  Permanente Objektdaten m√ºssen im ROM gespeichert und nicht in den RAM kopiert werden.  Da die Struktur nicht zwischen ROM und RAM aufgeteilt werden kann (im herk√∂mmlichen tragbaren C), kann jeder Objekttyp zwei Strukturen aufweisen, was zu komplex ist.  In Nucleus SE k√∂nnen Objektbeschreibungstabellen je nach Bedarf sowohl im ROM als auch im RAM gefunden werden. </li><li>  Aufgrund der hohen Konfigurierbarkeit von Nucleus SE (‚Äûultrahohe Skalierbarkeit‚Äú) k√∂nnen einige Objektbeschreibungsdaten abh√§ngig von den ausgew√§hlten Werkzeugen optional sein.  Dies f√ºhrt zu einer weit verbreiteten Verwendung der bedingten Kompilierung.  Eine strukturelle Definition mit integrierten Anweisungen zur bedingten Kompilierung ist sehr schwer zu verstehen.  Die Steuerung der Instanziierung einzelner Arrays mit dieser Methode ist wiederum recht einfach zu verstehen. </li></ul><br><br>  Alle Objektdatentabellen unterliegen der oben genannten hierarchischen Namenskonvention.  Somit ist es ziemlich leicht zu verstehen, welche Tabellen logisch zusammenh√§ngen. <br><br><h2>  Hauptunterschiede zu Nucleus RTOS </h2><br>  Obwohl Nucleus SE mit einem hohen Grad an Kompatibilit√§t mit Nucleus RTOS entwickelt wurde, konnten einige kleine und gr√∂√üere Unterschiede nicht vermieden werden.  Sie werden in den entsprechenden Artikeln ausf√ºhrlich beschrieben, und eine kurze Beschreibung wird unten gegeben. <br><br><h3>  Objektdaten </h3><br>  In Nucleus RTOS werden Objekte auf Anfrage erstellt und gel√∂scht.  In Nucleus SE werden alle Objekte statisch erstellt und w√§hrend der Montage festgelegt. <br><br><h3>  Anzahl der Objekte </h3><br>  Nucleus RTOS unterst√ºtzt eine unbestimmte Anzahl von Objekten jedes Typs.  Nucleus SE unterst√ºtzt maximal 16 Objekte jedes Typs. <br><br><h3>  Objektnamen </h3><br>  Mit Nucleus RTOS k√∂nnen Sie einigen Objekttypen Texttypen zuweisen, die zum Debuggen verwendet werden k√∂nnen.  Nucleus SE verf√ºgt nicht √ºber diese Funktion. <br><br><h3>  Task-Sperrmechanismus </h3><br>  Der Mechanismus zum Blockieren von Aufgaben mit einem API-Aufruf in Nucleus SE ist ziemlich einfach.  Wenn eine Ressource freigegeben wird, werden alle ausstehenden Aufgaben fortgesetzt und konkurrieren (mithilfe des Aufgabenplaners) um Ressourcen.  Die verlorenen Aufgaben werden erneut ausgesetzt (blockiert).  In Nucleus RTOS ist der Mechanismus komplexer, es werden nur wichtige Aufgaben ausgef√ºhrt, was effektiver ist. <br><br><h3>  API-Aufruf-Timeout </h3><br>  Beim Aufrufen der blockierenden API kann der Entwickler mit Nucleus RTOS eine Zeit√ºberschreitung angeben, nach der der Aufruf fortgesetzt wird, auch wenn die Ressource nicht freigegeben wird.  Nucleus SE verf√ºgt nicht √ºber diese Funktion. <br><br><h3>  Aufgabenplanung </h3><br>  Der Nucleus RTOS Scheduler ist flexibel, effizient und gut definiert.  Nucleus SE bietet eine Reihe von Schedulern, von denen jeder einfach und effektiv genug f√ºr eine reduzierte Anzahl unterst√ºtzter Aufgaben ist: von 1 bis 16. <br><br><h3>  Aufgabenpriorit√§ten </h3><br>  Ein System, das Nucleus RTOS verwendet, kann eine beliebige Anzahl von Aufgaben haben, denen eine von 256 Priorit√§tsstufen zugewiesen werden kann, w√§hrend mehrere Aufgaben eine Priorit√§tsstufe haben k√∂nnen.  Die Aufgabenpriorit√§tsstufen k√∂nnen sich auch zur Laufzeit √§ndern.  Wenn in Nucleus SE ein Priorit√§tsplaner ausgew√§hlt ist, muss jede Aufgabe eine eindeutige Priorit√§tsstufe haben, die nicht dynamisch ge√§ndert werden kann.  Es kann nur eine Priorit√§tsstufe pro Aufgabe geben. <br><br><h3>  Behandlung unterbrechen </h3><br>  Nucleus RTOS unterst√ºtzt die ausgefeilte Architektur eines zweistufigen Interrupt-Handlers, der eine effiziente Interoperabilit√§t zwischen Interrupt-Handler und Kernel-Diensten erm√∂glicht.  Nucleus SE verwendet einen √§hnlichen Ansatz, der sowohl einfache Interrupt-Handler ohne Kernel (nicht verwaltete Interrupts) als auch vollst√§ndig kontextsensitive Interrupt-Handler unterst√ºtzt, die API-Aufrufe (verwaltete Interrupts) verwenden k√∂nnen. <br><br><h3>  Ger√§tetreiber </h3><br>  Nucleus RTOS verf√ºgt √ºber eine gut gestaltete Ger√§tetreiberarchitektur.  Nucleus SE verf√ºgt nicht √ºber eine solche Architektur, sodass der Entwickler die Aufgabe hat, die Ger√§testeuerung auf die Aufgaben und den Interrupt-Handler-Code zu verteilen. <br><br><h2>  Verteilung von Nucleus SE </h2><br>  Die Quellcodes von Nucleus SE werden im Zuge der Entwicklung dieser Artikelserie ver√∂ffentlicht.  Verf√ºgbare Dateien sind auf Anfrage per E-Mail erh√§ltlich.  Gegen Ende der Artikelserie wird ein Repository zum Herunterladen aller ver√∂ffentlichten Dateien erstellt. <br><br><div class="spoiler">  <b class="spoiler_title">√úber den Autor</b> <div class="spoiler_text">  Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und verbringt die meiste Zeit mit Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  Colins professionelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog-</a> <a href="">E-Mail</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422617/">https://habr.com/ru/post/de422617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422605/index.html">Schon in jungen Jahren einen Safe aufbauen - Bildungsprogramm von Rostelecom und MIPT</a></li>
<li><a href="../de422609/index.html">Sprachbarriere und NLP. Warum verstehen uns Chatbots nicht?</a></li>
<li><a href="../de422611/index.html">Standard Error Handler in RxJava2 oder warum RxJava Anwendungsabst√ºrze verursacht, selbst wenn onError implementiert ist</a></li>
<li><a href="../de422613/index.html">PowerPool Cybergroup hat die Zero-Day-Sicherheitsanf√§lligkeit in Advanced Local Procedure Call gemeistert</a></li>
<li><a href="../de422615/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 9. Scheduler: Implementierung</a></li>
<li><a href="../de422623/index.html">So sichern Sie C.</a></li>
<li><a href="../de422625/index.html">Wir haben mit Troy Miles gesprochen - dem Programmierer von "Neuromancer"</a></li>
<li><a href="../de422627/index.html">MongoDB und IT-Arbeitsmarktforschung</a></li>
<li><a href="../de422629/index.html">H√∂r auf, die Holzf√§ller zu f√ºttern! Gib mehr Modifikatoren! Lazy Static Final Fields. Entwurf einer Feature-Skizze</a></li>
<li><a href="../de422631/index.html">QIWI-Terminals. So holen Sie das Beste aus einfachen Technologien heraus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>