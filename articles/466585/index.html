<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùÑÔ∏è ‚ò™Ô∏è üë∞üèΩ Comprender los corredores de mensajes. Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka. Cap√≠tulo 3. Kafka üåá üå§Ô∏è üïú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuaci√≥n de la traducci√≥n de un peque√±o libro: 
 "Comprender los corredores de mensajes", 
 autor: Jakub Korab, editor: O'Reilly Media, Inc., fech...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprender los corredores de mensajes. Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka. Cap√≠tulo 3. Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466585/"> Continuaci√≥n de la traducci√≥n de un peque√±o libro: <br>  "Comprender los corredores de mensajes", <br>  autor: Jakub Korab, editor: O'Reilly Media, Inc., fecha de publicaci√≥n: junio de 2017, ISBN: 9781492049296. <br><br>  <b>Traducci√≥n completada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tele.gg/middle_java</a></b> <br><br>  Parte anterior: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender los corredores de mensajes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 2. ActiveMQ</a> <br><a name="habracut"></a><br><h2>  CAPITULO 3 </h2><br><h2>  Kafka </h2><br>  Kafka se desarroll√≥ en LinkedIn para eludir algunas de las limitaciones de los corredores de mensajes tradicionales y evitar la necesidad de configurar m√∫ltiples corredores de mensajes para diferentes interacciones punto a punto, que se describe en la secci√≥n "Escalado vertical y horizontal" en la p√°gina 28 de este libro. LinkedIn se bas√≥ en gran medida en la absorci√≥n unidireccional de grandes cantidades de datos, como los clics de p√°gina y los registros de acceso, al tiempo que permit√≠a que varios sistemas usaran estos datos.  de la ma√±ana, sin afectar al rendimiento de otros productores o konsyumerov.  De hecho, la raz√≥n por la que existe Kafka es para obtener la arquitectura de mensajer√≠a que describe Universal Data Pipeline. <br><br>  Dado este objetivo final, surgieron naturalmente otros requisitos.  Kafka debe: <br><br><ul><li>  Se extremadamente r√°pido </li><li>  Proporcionar un mayor rendimiento de mensajer√≠a </li><li>  Admite modelos de editor-suscriptor y punto a punto </li><li>  No disminuya la velocidad con la adici√≥n de consumidores.  Por ejemplo, el rendimiento de las colas y los temas en ActiveMQ se deteriora a medida que aumenta el n√∫mero de consumidores en el destino. </li><li>  Ser horizontalmente escalable;  si un solo mensaje persiste solo puede hacerlo a la velocidad m√°xima del disco, entonces para aumentar el rendimiento tiene sentido ir m√°s all√° de los l√≠mites de una instancia de agente </li><li>  Delinear el acceso al almacenamiento y recuperaci√≥n de mensajes </li></ul><br>  Para lograr todo esto, Kafka ha adoptado una arquitectura que redefini√≥ los roles y responsabilidades de los clientes y los corredores de mensajer√≠a.  El modelo JMS est√° muy centrado en el corredor, donde es responsable de la distribuci√≥n de mensajes, y los clientes solo tienen que preocuparse por enviar y recibir mensajes.  Kafka, por otro lado, est√° orientado al cliente, y el cliente asume muchas de las funciones de un agente tradicional, como la distribuci√≥n justa de mensajes relevantes entre los consumidores, a cambio de recibir un agente extremadamente r√°pido y escalable.  Para las personas que trabajan con sistemas de mensajer√≠a tradicionales, trabajar con Kafka requiere un cambio fundamental de actitud. <br>  Esta direcci√≥n de ingenier√≠a ha llevado a la creaci√≥n de una infraestructura de mensajer√≠a que puede aumentar el rendimiento en muchos √≥rdenes de magnitud en comparaci√≥n con un agente convencional.  Como veremos, este enfoque est√° lleno de compromisos, lo que significa que Kafka no es adecuado para ciertos tipos de cargas y software instalado. <br><br><h3>  Modelo de destino unificado </h3><br>  Para cumplir con los requisitos descritos anteriormente, Kafka combin√≥ la publicaci√≥n-suscripci√≥n y la mensajer√≠a punto a punto en un tipo de destinatario: el <i>tema</i> .  Esto es confuso para las personas que trabajan con sistemas de mensajer√≠a, donde la palabra "tema" se refiere a un mecanismo de transmisi√≥n desde el cual la lectura (del tema) no es confiable (no es duradera).  Los temas de Kafka deben considerarse un tipo de destino h√≠brido, como se define en la introducci√≥n de este libro. <br><blockquote>  En el resto de este cap√≠tulo, a menos que especifiquemos expl√≠citamente lo contrario, el t√©rmino tema se referir√° al tema de Kafka. </blockquote><br>  Para comprender completamente c√≥mo se comportan los temas y qu√© garant√≠as ofrecen, primero debemos considerar c√≥mo se implementan en Kafka. <br>  <i>Cada tema en Kafka tiene su propio diario.</i> <br>  Los productores que env√≠an mensajes a Kafka se anexan a esta revista, y los consumidores leen la revista utilizando punteros que avanzan constantemente.  Kafka elimina peri√≥dicamente las partes m√°s antiguas del diario, independientemente de si los mensajes en estas partes se leyeron o no.  Una parte central del dise√±o de Kafka es que al agente no le importa si los mensajes se leen o no, esto es responsabilidad del cliente. <br><blockquote>  Los t√©rminos "revista" e "√≠ndice" no se encuentran en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de Kafka</a> .  Estos t√©rminos bien conocidos se usan aqu√≠ para ayudar a comprender. </blockquote><br>  Este modelo es completamente diferente de ActiveMQ, donde los mensajes de todas las colas se almacenan en un diario, y el intermediario marca los mensajes como eliminados despu√©s de haberlos le√≠do. <br>  Veamos ahora un poco m√°s y miremos la revista tem√°tica con m√°s detalle. <br>  Kafka Magazine consta de varias particiones ( <a href="">Figura 3-1</a> ).  Kafka garantiza un orden estricto en cada partici√≥n.  Esto significa que los mensajes escritos en la partici√≥n en cierto orden se leer√°n en el mismo orden.  Cada partici√≥n se implementa como un archivo de registro (log) que contiene un <i>subconjunto de</i> todos los mensajes enviados al tema por sus productores.  El tema creado contiene una partici√≥n por defecto.  Particionar es la idea central de Kafka para el escalado horizontal. <br><br><img src="https://habrastorage.org/webt/tm/w2/yf/tmw2yf3lanppqtrumxoidotplhi.png"><br>  <i>Figura 3-1.</i>  <i>Particiones Kafka</i> <br><br>  Cuando el productor env√≠a un mensaje al tema de Kafka, decide a qu√© partici√≥n enviar el mensaje.  Consideraremos esto con m√°s detalle m√°s adelante. <br><br><h2>  Leer mensajes </h2><br>  Un cliente que quiere leer mensajes controla un puntero con nombre llamado <i>grupo de consumidores</i> , que indica el <i>desplazamiento de un</i> mensaje en una partici√≥n.  Un desplazamiento es una posici√≥n con un n√∫mero creciente que comienza en 0 al comienzo de la partici√≥n.  Este grupo de consumidores, al que se hace referencia en la API a trav√©s de un identificador definido por el usuario group_id, corresponde a un <i>√∫nico consumidor o sistema l√≥gico</i> . <br><br>  La mayor√≠a de los sistemas de mensajer√≠a leen datos del destinatario a trav√©s de m√∫ltiples instancias y subprocesos para procesar mensajes en paralelo.  Por lo tanto, generalmente habr√° muchos casos de consumidores que comparten el mismo grupo de consumidores. <br><br>  El problema de lectura se puede representar de la siguiente manera: <br><br><ul><li>  El tema tiene varias particiones. </li><li>  Varios grupos de consumidores pueden usar el tema al mismo tiempo. </li><li>  Un grupo de consumidores puede tener varias instancias separadas. </li></ul><br>  Este es un problema no trivial de muchos a muchos.  Para comprender c√≥mo Kafka maneja las relaciones entre grupos de consumidores, instancias de consumidores y particiones, echemos un vistazo a una serie de guiones de lectura cada vez m√°s complejos. <br><br><h3>  Consumidores y grupos de consumidores </h3><br>  Tomemos un tema de partici√≥n √∫nica como punto de partida ( <a href="">Figura 3-2</a> ). <br><br><img src="https://habrastorage.org/webt/6z/tz/dh/6ztzdhqmjweck-z15htxb2xbe28.png"><br>  <i>Figura 3-2.</i>  <i>El consumidor lee desde la partici√≥n</i> <br><br>  Cuando una instancia de consumidor se conecta con su propio group_id a este tema, se le asigna una partici√≥n para leer y un desplazamiento en esta partici√≥n.  La posici√≥n de este desplazamiento se configura en el cliente como un puntero a la posici√≥n m√°s reciente (el mensaje m√°s reciente) o la posici√≥n m√°s temprana (el mensaje m√°s antiguo).  El consumidor solicita mensajes (encuestas) del tema, lo que lleva a su lectura secuencial de la revista. <br>  La posici√≥n de desplazamiento se devuelve regularmente a Kafka y se guarda como mensajes en el tema interno <i>_consumer_offsets</i> .  Los mensajes le√≠dos a√∫n no se eliminan, a diferencia de un intermediario normal, y el cliente puede rebobinar el desplazamiento para volver a procesar los mensajes ya vistos. <br><br>  Cuando se conecta un segundo consumidor l√≥gico usando otro group_id, controla un segundo puntero que es independiente del primero ( <a href="">Figura 3-3</a> ).  Por lo tanto, el tema de Kafka act√∫a como una cola en la que hay un consumidor y, como tema habitual, un editor-suscriptor (pub-sub), al que se suscriben varios consumidores, con la ventaja adicional de que todos los mensajes se guardan y pueden procesarse varias veces. <br><br><img src="https://habrastorage.org/webt/qe/v1/yk/qev1yktga3s-g1gqlynylbe3n9w.png"><br>  <i>Figura 3-3.</i>  <i>Dos consumidores en diferentes grupos de consumidores leen desde la misma partici√≥n</i> <br><br><h3>  Consumidores en el grupo de consumidores </h3><br>  Cuando una instancia del consumidor lee datos de la partici√≥n, controla completamente el puntero y procesa los mensajes, como se describe en la secci√≥n anterior. <br>  Si varias instancias de los consumidores se conectaron con el mismo group_id al tema con una partici√≥n, entonces la instancia que se conect√≥ en √∫ltimo lugar tendr√° el control sobre el puntero y, a partir de ese momento, recibir√° todos los mensajes ( <a href="">Figura 3-4</a> ). <br><br><img src="https://habrastorage.org/webt/0j/ao/f2/0jaof2mdwg3cqvmwemhtxkrltuq.png"><br>  <i>Figura 3-4.</i>  <i>Dos consumidores en el mismo grupo de consumidores leen desde la misma partici√≥n</i> <br><br>  Este modo de procesamiento, en el que el n√∫mero de instancias de consumidores excede el n√∫mero de particiones, puede considerarse como un tipo de consumidor monopolista.  Esto puede ser √∫til si necesita la agrupaci√≥n "activa-pasiva" (o "caliente-caliente") de sus instancias de consumidores, aunque la operaci√≥n paralela de varios consumidores ("activo-activo" o "caliente-caliente") es mucho m√°s t√≠pica que los consumidores en modo de espera. <br><blockquote>  Este comportamiento de distribuci√≥n de mensajes, descrito anteriormente, puede ser sorprendente en comparaci√≥n con el comportamiento de una cola JMS normal.  En este modelo, los mensajes enviados a la cola se distribuir√°n uniformemente entre los dos consumidores. </blockquote><br>  Muy a menudo, cuando creamos varias instancias de compiladores, lo hacemos para el procesamiento paralelo de mensajes, para aumentar la velocidad de lectura o para aumentar la estabilidad del proceso de lectura.  Dado que solo una instancia de un consumidor puede leer datos de una partici√≥n, ¬øc√≥mo se logra esto en Kafka? <br><br>  Una forma de hacerlo es usar una instancia del consumidor para leer todos los mensajes y enviarlos al grupo de subprocesos.  Aunque este enfoque aumenta el rendimiento del procesamiento, aumenta la complejidad de la l√≥gica de los consumidores y no hace nada para aumentar la estabilidad del sistema de lectura.  Si una instancia del consumidor se apaga debido a una falla de energ√≠a o un evento similar, entonces la revisi√≥n se detiene. <br><br>  La forma can√≥nica de resolver este problema en Kafka es usar m√°s particiones. <br><br><h3>  Particionamiento </h3><br>  Las particiones son el mecanismo principal para paralelizar la lectura y la escala del tema m√°s all√° del ancho de banda de una instancia del intermediario.  Para comprender mejor esto, veamos una situaci√≥n en la que hay un tema con dos particiones y un consumidor se suscribe a este tema ( <a href="">Figura 3-5</a> ). <br><br><img src="https://habrastorage.org/webt/en/9g/ct/en9gct0o017cqp8buawguwlscty.png"><br>  <i>Figura 3-5.</i>  <i>Un consumidor lee desde varias particiones</i> <br><br>  En este escenario, el consultor tiene control sobre los punteros correspondientes a su group_id en ambas particiones, y comienza la lectura de mensajes de ambas particiones. <br>  Cuando se agrega un compilador adicional a este tema para el mismo group_id, Kafka reasigna (reasigna) una de las particiones de la primera a la segunda.  Despu√©s de eso, cada instancia del consumidor se restar√° de una partici√≥n del tema ( <a href="">Figura 3-6</a> ). <br><br>  Para garantizar que los mensajes se procesen en paralelo en 20 hilos, necesitar√° al menos 20 particiones.  Si habr√° menos particiones, seguir√° teniendo consumidores que no tienen nada en qu√© trabajar, como se describi√≥ anteriormente en la discusi√≥n de monitores exclusivos. <br><br><img src="https://habrastorage.org/webt/8b/a0/um/8ba0umn2yzr9yy3vztonhdfiub0.png"><br>  <i>Figura 3-6.</i>  <i>Dos consumidores en el mismo grupo de consumidores leen desde diferentes particiones</i> <br><br>  Este esquema reduce significativamente la complejidad del agente Kafka en comparaci√≥n con la distribuci√≥n de mensajes necesaria para admitir la cola JMS.  No es necesario ocuparse de los siguientes puntos: <br><br><ul><li>  Qu√© consumidor debe recibir el siguiente mensaje en funci√≥n de la distribuci√≥n por turnos, la capacidad de almacenamiento intermedio de captaci√≥n previa actual o los mensajes anteriores (como para los grupos de mensajes JMS). </li><li>  Qu√© mensajes se enviaron a qu√© consumidores y si deber√≠an reenviarse en caso de falla. </li></ul><br>  Todo lo que el corredor de Kafka debe hacer es enviar mensajes consistentemente al asesor cuando este lo solicite. <br><br>  Sin embargo, los requisitos para paralelizar la correcci√≥n de pruebas y el reenv√≠o de mensajes fallidos no desaparecen; la responsabilidad de ellos simplemente pasa del intermediario al cliente.  Esto significa que deben tenerse en cuenta en su c√≥digo. <br><br><h2>  Enviando mensajes </h2><br>  La responsabilidad de decidir a qu√© partici√≥n enviar el mensaje es el productor del mensaje.  Para comprender el mecanismo por el cual se hace esto, primero debe considerar qu√© es lo que estamos enviando exactamente. <br><br>  Mientras que en JMS usamos una estructura de mensaje con metadatos (encabezados y propiedades) y un cuerpo que contiene una carga √∫til, en Kafka el mensaje es <i>un par clave-valor</i> .  La carga √∫til del mensaje se env√≠a como un valor.  Una clave, por otro lado, se usa principalmente para particionar y debe contener una <i>clave espec√≠fica de l√≥gica de negocios</i> para colocar mensajes relacionados en la misma partici√≥n. <br><br>  En el Cap√≠tulo 2, discutimos el escenario de apuestas en l√≠nea, cuando los eventos relacionados deben ser procesados ‚Äã‚Äãen orden por un solo consumidor: <br><br><ol><li>  La cuenta de usuario est√° configurada. </li><li>  El dinero se acredita en la cuenta. </li><li>  Se realiza una apuesta que retira dinero de la cuenta. </li></ol><br>  Si cada evento es un mensaje enviado al tema, en este caso el identificador de la cuenta ser√° la clave natural. <br>  Cuando se env√≠a un mensaje utilizando la API de Kafka Producer, se pasa a la funci√≥n de partici√≥n, que, dado el mensaje y el estado actual del cl√∫ster de Kafka, devuelve el identificador de la partici√≥n a la que se debe enviar el mensaje.  Esta caracter√≠stica se implementa en Java a trav√©s de la interfaz Partitioner. <br><br>  Esta interfaz es la siguiente: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Partitioner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String topic, Object key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, Object value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] valueBytes, Cluster cluster)</span></span></span></span>; }</code> </pre> <br>  La implementaci√≥n del Partitioner usa el algoritmo de hash de prop√≥sito general predeterminado sobre la clave o round-robin si la clave no se especifica para determinar la partici√≥n.  Este valor predeterminado funciona bien en la mayor√≠a de los casos.  Sin embargo, en el futuro querr√°s escribir el tuyo. <br><br><h3>  Escribir su propia estrategia de partici√≥n </h3><br>  Veamos un ejemplo cuando desea enviar metadatos junto con la carga √∫til del mensaje.  La carga √∫til en nuestro ejemplo es una instrucci√≥n para hacer un dep√≥sito en una cuenta de juego.  Una instrucci√≥n es algo que nos gustar√≠a garantizar que no se modifique durante la transmisi√≥n, y queremos asegurarnos de que solo un sistema superior confiable pueda iniciar esta instrucci√≥n.  En este caso, los sistemas de env√≠o y recepci√≥n acuerdan el uso de la firma para autenticar el mensaje. <br>  En un JMS normal, simplemente definimos la propiedad de firma del mensaje y la agregamos al mensaje.  Sin embargo, Kafka no nos proporciona un mecanismo para transmitir metadatos, solo la clave y el valor. <br><br>  Dado que el valor es la carga √∫til de una transferencia bancaria (carga √∫til de transferencia bancaria), cuya integridad queremos mantener, no tenemos m√°s remedio que determinar la estructura de datos para usar en la clave.  Suponiendo que necesitamos un identificador de cuenta para la partici√≥n, ya que todos los mensajes relacionados con la cuenta deben procesarse en orden, se nos ocurrir√° la siguiente estructura JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"541661622185851c248b41bf0cea7ad0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"accountId"</span></span>: <span class="hljs-string"><span class="hljs-string">"10007865234"</span></span> }</code> </pre> <br>  Debido a que el valor de la firma variar√° dependiendo de la carga √∫til, la estrategia de hash de la interfaz Partitioner predeterminada no agrupar√° de manera confiable los mensajes relacionados.  Por lo tanto, necesitaremos escribir nuestra propia estrategia, que analizar√° esta clave y compartir√° el valor de accountId. <br><blockquote>  Kafka incluye sumas de verificaci√≥n para detectar la corrupci√≥n de mensajes en el repositorio y tiene un conjunto completo de caracter√≠sticas de seguridad.  Incluso entonces, a veces aparecen requisitos espec√≠ficos de la industria, como el anterior. </blockquote><br>  La estrategia de partici√≥n del usuario debe garantizar que todos los mensajes relacionados terminen en la misma partici√≥n.  Aunque esto parece simple, el requisito puede ser complicado debido a la importancia de ordenar los mensajes relacionados y cu√°n fijo es el n√∫mero de particiones en el tema. <br><br>  El n√∫mero de particiones en el tema puede cambiar con el tiempo, ya que se pueden agregar si el tr√°fico supera las expectativas iniciales.  Por lo tanto, las claves de mensaje se pueden asociar con la partici√≥n a la que se enviaron originalmente, lo que implica una parte del estado que debe distribuirse entre las instancias del productor. <br><br>  Otro factor a considerar es la distribuci√≥n uniforme de mensajes entre particiones.  Como regla general, las claves no se distribuyen uniformemente entre los mensajes, y las funciones hash no garantizan una distribuci√≥n justa de los mensajes para un peque√±o conjunto de claves. <br>  Es importante tener en cuenta que, sin importar c√≥mo decida dividir los mensajes, el separador en s√≠ puede necesitar ser reutilizado. <br><br>  Considere el requisito para la replicaci√≥n de datos entre grupos de Kafka en diferentes ubicaciones geogr√°ficas.  Para este prop√≥sito, Kafka viene con una herramienta de l√≠nea de comandos llamada MirrorMaker, que se usa para leer mensajes de un cl√∫ster y transferirlos a otro. <br><br>  MirrorMaker debe comprender las claves del tema replicado para mantener el orden relativo entre mensajes durante la replicaci√≥n entre cl√∫steres, ya que el n√∫mero de particiones para este tema puede no coincidir en dos cl√∫steres. <br><br>  Las estrategias de particionamiento personalizadas son relativamente raras, ya que los hashes predeterminados o el round robin funcionan con √©xito en la mayor√≠a de los escenarios.  Sin embargo, si necesita garant√≠as estrictas de pedido o si necesita extraer metadatos de las cargas √∫tiles, la partici√≥n es algo que debe observar m√°s de cerca. <br><br>  Los beneficios de escalabilidad y rendimiento de Kafka provienen de la transferencia de algunas de las responsabilidades de un corredor tradicional a un cliente.  En este caso, se toma una decisi√≥n sobre la distribuci√≥n de mensajes potencialmente relacionados entre varios consumidores que trabajan en paralelo. <br><blockquote>  Los corredores de JMS tambi√©n deben ocuparse de tales requisitos.  Curiosamente, el mecanismo para enviar mensajes relacionados a la misma cuenta implementada a trav√©s de los grupos de mensajes JMS (una especie de estrategia de equilibrio de equilibrio de carga fija (SLB)) tambi√©n requiere que el remitente marque los mensajes como relacionados.  En el caso de JMS, el agente es responsable de enviar este grupo de mensajes relacionados a uno de los muchos clientes y transferir la propiedad del grupo si el cliente se ha ca√≠do. </blockquote><br><h2>  Acuerdo del productor </h2><br>  Particionar no es lo √∫nico a tener en cuenta al enviar mensajes.  Veamos los m√©todos send () de la clase Productor en la API de Java: <br><br><pre> <code class="java hljs">Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record); Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record, Callback callback);</code> </pre> <br>  Debe notarse de inmediato que ambos m√©todos devuelven Future, lo que indica que la operaci√≥n de env√≠o no se realiza de inmediato.  Como resultado, resulta que el mensaje (ProducerRecord) se escribe en el b√∫fer de env√≠o para cada partici√≥n activa y se transmite al intermediario en la secuencia de fondo en la biblioteca del cliente Kafka.  Aunque esto hace que el trabajo sea incre√≠blemente r√°pido, significa que una aplicaci√≥n sin experiencia puede perder mensajes si se detiene su proceso. <br><br>  Como siempre, hay una manera de hacer que la operaci√≥n de env√≠o sea m√°s confiable debido al rendimiento.  El tama√±o de este b√∫fer se puede establecer en 0, y el hilo de la aplicaci√≥n de env√≠o se ver√° obligado a esperar hasta que el mensaje se env√≠e al intermediario, de la siguiente manera: <br><br><pre> <code class="java hljs">RecordMetadata metadata = producer.send(record).get();</code> </pre> <br><h2>  Una vez m√°s sobre leer mensajes </h2><br>  Leer mensajes tiene dificultades adicionales que deben considerarse.  A diferencia de la API JMS, que puede iniciar un escucha de mensajes en respuesta a un mensaje, la interfaz <i>Consumer</i> Kafka solo sondea.  Echemos un vistazo m√°s de cerca al m√©todo <i>poll ()</i> utilizado para este prop√≥sito: <br><br><pre> <code class="java hljs">ConsumerRecords &lt; K, V &gt; poll(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeout);</code> </pre> <br>  El valor de retorno del m√©todo es una estructura de contenedor que contiene varios objetos <i>ConsumerRecord</i> de potencialmente varias particiones.  <i>Un ConsumerRecord en</i> s√≠ mismo es un objeto titular para un par clave-valor con metadatos asociados, como la partici√≥n de la que se deriva. <br><br>  Como se discuti√≥ en el Cap√≠tulo 2, debemos recordar constantemente lo que sucede con los mensajes despu√©s de que se procesan con √©xito o sin √©xito, por ejemplo, si el cliente no puede procesar el mensaje o si interrumpe el trabajo.  En JMS, esto se manej√≥ a trav√©s del modo de reconocimiento.  El intermediario eliminar√° el mensaje procesado con √©xito o volver√° a entregar el mensaje sin formato o invertido (siempre que se hayan utilizado las transacciones). <br>  Kafka funciona de una manera completamente diferente.  Los mensajes no se eliminan en el intermediario despu√©s de la correcci√≥n de pruebas, y la responsabilidad de lo que sucede en caso de falla recae en el c√≥digo mismo. <br><br>  Como ya dijimos, un grupo de consumidores est√° asociado con una compensaci√≥n en la revista.  La posici√≥n de registro asociada con este sesgo corresponde al siguiente mensaje que se emitir√° en respuesta a <i>poll ()</i> .  Un punto crucial en la lectura es el momento en que aumenta este desplazamiento. <br><br>  Volviendo al modelo de lectura discutido anteriormente, el procesamiento de mensajes consta de tres etapas: <br><br><ol><li>  Recuperar un mensaje para leer. </li><li>  Procesar el mensaje. </li><li>  Confirmar mensaje. </li></ol><br>  Kafka Consumer Advisor viene con la <i>opci√≥n de</i> configuraci√≥n <i>enable.auto.commit</i> .  Esta es una configuraci√≥n predeterminada de uso com√∫n, como suele ser el caso con la configuraci√≥n que contiene la palabra "auto". <br><br>  Antes de Kafka 0.10, el cliente que usaba este par√°metro enviaba el desplazamiento del √∫ltimo mensaje le√≠do en la siguiente llamada <i>poll ()</i> despu√©s del procesamiento.  Esto significaba que cualquier mensaje que ya hubiera sido recuperado podr√≠a volver a procesarse si el cliente ya lo hab√≠a procesado, pero se destruy√≥ inesperadamente antes de llamar a <i>poll ()</i> .  Como el agente no mantiene ning√∫n estado con respecto a cu√°ntas veces se ha le√≠do el mensaje, el pr√≥ximo consumidor que recupere este mensaje no sabr√° que algo malo ha sucedido.  Este comportamiento fue pseudo transaccional.  El desplazamiento se confirm√≥ solo en caso de procesamiento exitoso del mensaje, pero si el cliente interrumpi√≥, el agente nuevamente envi√≥ el mismo mensaje a otro cliente.  Este comportamiento era consistente con la garant√≠a de entrega de mensajes " <i>al menos una vez</i> ". <br><br>  En Kafka 0.10, el c√≥digo del cliente se cambi√≥ de tal manera que la biblioteca del cliente comenz√≥ a iniciar peri√≥dicamente la confirmaci√≥n, de acuerdo con la configuraci√≥n <i>auto.commit.interval.ms</i> .  Este comportamiento se encuentra entre los modos JMS AUTO_ACKNOWLEDGE y DUPS_OK_ACKNOWLEDGE.  Cuando se utiliza la confirmaci√≥n autom√°tica, los mensajes pueden confirmarse independientemente de si realmente se procesaron; esto podr√≠a suceder en el caso de un consumidor lento.  Si se interrumpi√≥ el compilador, el siguiente compilador recuper√≥ los mensajes, comenzando desde una posici√≥n segura, lo que podr√≠a provocar que se saltara un mensaje.  En este caso, Kafka no perdi√≥ mensajes, el c√≥digo de lectura simplemente no los proces√≥. <br><br>  Este modo tiene las mismas perspectivas que en la versi√≥n 0.9: los mensajes pueden procesarse, pero en caso de falla, el desplazamiento puede no cerrarse, lo que podr√≠a conducir a una duplicaci√≥n de la entrega.  Cuantos m√°s mensajes recupere al hacer <i>sondeo ()</i> , mayor ser√° este problema. <br><br>  Como se discuti√≥ en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secci√≥n</a> "Restar mensajes de la cola" en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 2</a> , no existe una entrega de mensajes √∫nica en el sistema de mensajer√≠a, dados los modos de falla. <br><br>  En Kafka, hay dos formas de arreglar (confirmar) un desplazamiento (desplazamiento): autom√°tica y manualmente.  En ambos casos, los mensajes se pueden procesar varias veces, en el caso de que el mensaje se haya procesado pero haya fallado antes de la confirmaci√≥n.  Tampoco puede procesar el mensaje si la confirmaci√≥n se produjo en segundo plano y su c√≥digo se complet√≥ antes de que comenzara a procesarse (posiblemente en Kafka 0.9 y versiones anteriores). <br><br>  Puede controlar el proceso de confirmaci√≥n de compensaciones manualmente en la API de Kafka <i>Consumer</i> configurando <i>enable.auto.commit</i> en falso y llamando expl√≠citamente a uno de los siguientes m√©todos: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Si desea procesar el mensaje "al menos una vez", debe confirmar el desplazamiento manualmente mediante <i>commitSync ()</i> ejecutando este comando inmediatamente despu√©s de procesar los mensajes. <br><br>  Estos m√©todos no permiten que se procesen los mensajes reconocidos antes de que se procesen, pero no hacen nada para eliminar la posible duplicaci√≥n de procesamiento, al tiempo que crean la apariencia de transaccionalidad.  Kafka no tiene transacciones.  El cliente no tiene la oportunidad de hacer lo siguiente: <br><br><ul><li>  Revierte autom√°ticamente un mensaje de reversi√≥n.  Los consumidores mismos deben manejar las excepciones que surgen de cargas √∫tiles problem√°ticas y desconexiones de backend, ya que no pueden confiar en el corredor para volver a entregar mensajes. </li><li>  Enviar mensajes a varios temas dentro de una operaci√≥n at√≥mica.  Como veremos pronto, el control sobre varios temas y particiones se puede ubicar en diferentes m√°quinas en el cl√∫ster de Kafka, que no coordinan las transacciones al enviarlas.  Al momento de escribir este art√≠culo, se ha trabajado para hacer esto posible con el KIP-98. </li><li>  Asociar la lectura de un mensaje de un tema con el env√≠o de otro mensaje a otro tema.  Una vez m√°s, la arquitectura de Kafka depende de muchas m√°quinas independientes que funcionan como un solo bus y no se intenta ocultarlo.  Por ejemplo, no hay componentes API que permitan vincular al <i>consumidor</i> y al <i>productor</i> en una transacci√≥n.  En JMS, esto es proporcionado por el objeto <i>Session a</i> partir del cual se crean <i>MessageProducers</i> y <i>MessageConsumers</i> . </li></ul><br>  Si no podemos confiar en las transacciones, ¬øc√≥mo podemos proporcionar una sem√°ntica m√°s cercana a las proporcionadas por los sistemas de mensajer√≠a tradicionales? <br><br>  Si existe la posibilidad de que la compensaci√≥n del consumidor pueda aumentar antes de que se haya procesado el mensaje, por ejemplo, durante el fallo del cliente, entonces el cliente no tendr√° forma de saber si el grupo de clientes ha perdido el mensaje cuando se asigna la partici√≥n.  Por lo tanto, una estrategia es rebobinar el desplazamiento a la posici√≥n anterior.  La API de Kafka Consumer Advisor proporciona los siguientes m√©todos para esto: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopicPartition partition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekToBeginning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection &lt; TopicPartition &gt; partitions)</span></span></span></span>;</code> </pre> <br>  El m√©todo <i>seek ()</i> se puede usar con el m√©todo <br>  <i>offsetsForTimes (Map &lt;TopicPartition, Long&gt; timestampsToSearch)</i> para rebobinar a un estado en cualquier punto en particular en el pasado. <br><br>  Impl√≠citamente, el uso de este enfoque significa que es muy probable que algunos mensajes que fueron procesados ‚Äã‚Äãanteriormente sean le√≠dos y procesados ‚Äã‚Äãnuevamente.  Para evitar esto, podemos usar lecturas idempotentes, como se describe en el Cap√≠tulo 4, para rastrear mensajes vistos anteriormente y eliminar duplicados. <br><br>  Como alternativa, el c√≥digo de su consumidor puede ser simple si se permite la p√©rdida o la duplicaci√≥n de mensajes.  Cuando observamos escenarios de uso para los que se usa Kafka, por ejemplo, para procesar eventos de registro, m√©tricas, seguimiento de clics, etc., entendemos que es poco probable que la p√©rdida de mensajes individuales tenga un impacto significativo en las aplicaciones circundantes.  En tales casos, los valores predeterminados son aceptables.  Por otro lado, si su aplicaci√≥n necesita transferir pagos, debe cuidar cuidadosamente cada mensaje individual.  Todo se reduce al contexto. <br><br>  Las observaciones personales muestran que al aumentar la intensidad del mensaje, el valor de cada mensaje individual disminuye.  Los mensajes de gran volumen tienden a ser valiosos cuando se ven en forma agregada. <br><br><h2>  Alta disponibilidad </h2><br>  El enfoque de alta disponibilidad de Kafka es muy diferente de ActiveMQ.  Kafka se desarrolla sobre la base de cl√∫steres escalables horizontalmente en los que todas las instancias del intermediario reciben y distribuyen mensajes simult√°neamente. <br><br>  El cl√∫ster Kafka consta de varias instancias de intermediario que se ejecutan en diferentes servidores.  Kafka fue dise√±ado para trabajar en un hardware convencional independiente, donde cada nodo tiene su propio almacenamiento dedicado.  No se recomienda el uso de Almacenamiento conectado a la red (SAN) porque varios nodos de c√≥mputo pueden competir por intervalos de tiempo de almacenamiento y crear conflictos. <br><br>  Kafka es un sistema <i>constantemente en</i> funcionamiento.  Muchos usuarios grandes de Kafka nunca extinguen sus cl√∫steres y el software siempre proporciona actualizaciones a trav√©s de un reinicio constante.  Esto se logra garantizando la compatibilidad con la versi√≥n anterior para mensajes e interacciones entre corredores. <br><br>  Los intermediarios est√°n conectados a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cl√∫ster de</a> servidores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ZooKeeper</a> , que act√∫a como un registro de configuraci√≥n determinado y se utiliza para coordinar los roles de cada intermediario.  ZooKeeper es un sistema distribuido que proporciona alta disponibilidad a trav√©s de la replicaci√≥n de informaci√≥n mediante el establecimiento de un <i>qu√≥rum</i> . <br><br>  En el caso base, el tema se crea en el cl√∫ster de Kafka con las siguientes propiedades: <br><br><ul><li>  El n√∫mero de particiones.  Como se discuti√≥ anteriormente, el valor exacto utilizado aqu√≠ depende del nivel deseado de lectura concurrente. </li><li>  El coeficiente de replicaci√≥n (factor) determina cu√°ntas instancias de intermediario en el cl√∫ster deben contener los registros de esta partici√≥n. </li></ul><br>  Usando ZooKeepers para la coordinaci√≥n, Kafka est√° tratando de distribuir de manera justa nuevas particiones entre los corredores en el cl√∫ster.  Esto lo hace una instancia, que act√∫a como el controlador. <br><br>  En tiempo <i>de</i> ejecuci√≥n <i>para cada partici√≥n del tema, el</i> <i>Controlador</i> asigna al corredor los roles de <i>l√≠der</i> (l√≠der, maestro, l√≠der) y <i>seguidores</i> (seguidores, esclavos, subordinados).  El corredor, que act√∫a como l√≠der de esta partici√≥n, es responsable de recibir todos los mensajes que le env√≠an los productores y de distribuirlos a los consumidores.  Al enviar mensajes a una partici√≥n de tema, se replican en todos los nodos del intermediario que act√∫an como seguidores de esta partici√≥n.  Cada nodo que contiene los registros de la partici√≥n se denomina <i>r√©plica</i> .  Un corredor puede actuar como l√≠der para algunas particiones y como seguidor para otras. <br><br>  Un seguidor que contiene todos los mensajes almacenados por el l√≠der se llama <i>r√©plica sincronizada</i> (una r√©plica en un estado sincronizado, r√©plica sincronizada).  Si el agente que act√∫a como l√≠der de la partici√≥n est√° desconectado, cualquier agente que se encuentre en el estado actualizado o sincronizado para esta partici√≥n puede asumir el rol de l√≠der.  Este es un dise√±o incre√≠blemente sostenible. <br><br>  Parte de la configuraci√≥n del productor es el par√°metro <i>acks</i> , que determina cu√°ntas r√©plicas deben acusar recibo de un mensaje antes de que el flujo de la aplicaci√≥n contin√∫e enviando: 0, 1 o todos.  Si el valor se establece en <i>todos</i> , cuando se reciba el mensaje, el l√≠der enviar√° una confirmaci√≥n al productor tan pronto como reciba la confirmaci√≥n de varias r√©plicas (incluido √©l mismo) definidas por la <i>configuraci√≥n del</i> tema <i>min.insync.replicas</i> (por defecto 1).  Si el mensaje no se puede replicar con √©xito, entonces el productor lanzar√° una excepci√≥n para la aplicaci√≥n ( <i>NotEnoughReplicas</i> o <i>NotEnoughReplicasAfterAppend</i> ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En una configuraci√≥n t√≠pica, se crea un tema con un coeficiente de replicaci√≥n de 3 (1 l√≠der, 2 seguidores para cada partici√≥n) y el par√°metro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min.insync.replicas se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establece en 2. En este caso, el cl√∫ster permitir√° que uno de los intermediarios que administran la partici√≥n se desconecte sin afectar las aplicaciones del cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto nos devuelve al compromiso ya familiar entre rendimiento y confiabilidad. La replicaci√≥n ocurre debido al tiempo de espera adicional para los reconocimientos (reconocimientos) de los seguidores. Aunque, dado que se ejecuta en paralelo, la replicaci√≥n de al menos tres nodos tiene el mismo rendimiento que dos (ignorando el aumento en el uso del ancho de banda de la red).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando este esquema de replicaci√≥n, Kafka evita h√°bilmente la necesidad de escribir f√≠sicamente cada mensaje en el disco utilizando la operaci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cada mensaje enviado por el productor se escribir√° en el registro de partici√≥n, pero, como se discuti√≥ en el Cap√≠tulo 2, la escritura en el archivo se realiza inicialmente en el b√∫fer del sistema operativo. Si este mensaje se replica a otra instancia de Kafka y est√° en su memoria, la p√©rdida de un l√≠der no significa que el mensaje en s√≠ se haya perdido, una r√©plica sincronizada puede asumirlo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar la operaci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sincronizaci√≥n ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que Kafka puede recibir mensajes a la velocidad con la que puede escribirlos en la memoria. Por el contrario, cuanto m√°s tiempo pueda evitar vaciar la memoria en el disco, mejor. Por esta raz√≥n, no es raro que los corredores de Kafka asignen 64 GB o m√°s de memoria. Este uso de memoria significa que una instancia de Kafka puede funcionar f√°cilmente a velocidades miles de veces m√°s r√°pidas que un agente de mensajes tradicional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka tambi√©n se puede configurar para usar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para enviar paquetes de mensajes. Dado que todo en Kafka est√° orientado a paquetes, en realidad funciona bastante bien para muchos casos de uso y es una herramienta √∫til para usuarios que requieren garant√≠as muy s√≥lidas. La mayor parte del rendimiento puro de Kafka est√° relacionado con los mensajes que se env√≠an al intermediario en forma de paquetes, y al hecho de que estos mensajes se leen del intermediario en bloques sucesivos utilizando </font><font style="vertical-align: inherit;">operaciones de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copia cero</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (operaciones que no realizan la tarea de copiar datos de un √°rea de memoria a otro) Esta √∫ltima es una gran ganancia en t√©rminos de rendimiento y recursos y solo es posible mediante el uso de la estructura de datos de registro subyacente que define el esquema de partici√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En un cl√∫ster Kafka, es posible un rendimiento mucho mayor que cuando se usa un solo agente Kafka, ya que las particiones tem√°ticas se pueden escalar horizontalmente en muchas m√°quinas separadas. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resumen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este cap√≠tulo, examinamos c√≥mo la arquitectura Kafka reinterpreta la relaci√≥n entre clientes y corredores para proporcionar una canalizaci√≥n de mensajes incre√≠blemente robusta, con un ancho de banda muchas veces mayor que un corredor de mensajes normal. Discutimos la funcionalidad que utiliza para lograr este objetivo, y revisamos brevemente la arquitectura de las aplicaciones que proporcionan esta funcionalidad. En el pr√≥ximo cap√≠tulo, discutiremos los problemas comunes que las aplicaciones de mensajer√≠a necesitan resolver y las estrategias para resolverlos. Concluimos el cap√≠tulo describiendo c√≥mo hablar sobre tecnolog√≠as de mensajer√≠a en general para que pueda evaluar su idoneidad para sus casos de uso. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traducci√≥n completada: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continuar√° ...</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466585/">https://habr.com/ru/post/466585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466573/index.html">Preguntas al futuro empleador</a></li>
<li><a href="../466575/index.html">Pasar listas bidimensionales de Python a DLL</a></li>
<li><a href="../466579/index.html">La historia de los algoritmos de aleatorizaci√≥n de Tetris</a></li>
<li><a href="../466581/index.html">Darwinismo cu√°ntico: una idea que explica la realidad objetiva pasa la primera prueba</a></li>
<li><a href="../466583/index.html">Una breve historia del detector de mentiras</a></li>
<li><a href="../466587/index.html">Variables CSS y tema de color para el sitio en varias l√≠neas</a></li>
<li><a href="../466589/index.html">C√≥mo recibir datos de Google Analytics usando R en Microsoft SQL Server</a></li>
<li><a href="../466591/index.html">MVC sin C: ¬øQu√© cambiar√° SwiftUI en la arquitectura de la aplicaci√≥n?</a></li>
<li><a href="../466597/index.html">Historia del segundo lugar en Mini AI Cup 4: Paper IO</a></li>
<li><a href="../466599/index.html">C√≥mo evitar el captcha usando el reconocimiento de sonido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>