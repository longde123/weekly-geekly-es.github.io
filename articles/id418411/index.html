<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤š ğŸ”® ğŸ‘¼ğŸ¾ Penembak jaringan browser di Node.js ğŸ˜’ ğŸš³ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembangan game multi pemain itu rumit karena banyak alasan: hosting mereka bisa mahal, strukturnya tidak jelas, dan implementasinya sulit. Dalam tu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penembak jaringan browser di Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418411/"> Pengembangan game multi pemain itu rumit karena banyak alasan: hosting mereka bisa mahal, strukturnya tidak jelas, dan implementasinya sulit.  Dalam tutorial ini saya akan mencoba membantu Anda mengatasi penghalang terakhir. <br><br>  Artikel ini ditujukan untuk pengembang yang dapat membuat game dan terbiasa dengan JavaScript, tetapi belum pernah menulis game online multi-pemain sebelumnya.  Setelah menyelesaikan tutorial ini, Anda akan menguasai implementasi komponen jaringan dasar dalam gim Anda dan dapat mengembangkannya menjadi sesuatu yang lebih!  Inilah yang akan kami buat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/220/340/e9a22034098ab10a84721a48615a1476.png"></div><br>  Anda dapat memainkan game yang sudah selesai di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> !  Ketika Anda menekan tombol W atau "atas", kapal mendekati kursor, ketika Anda mengklik tetikus, ia menembak.  <em>(Jika tidak ada yang online, maka untuk memeriksa cara kerja multi-pemain, buka dua jendela browser di satu komputer, atau salah satunya di telepon,).</em>  Jika Anda ingin menjalankan game secara lokal, maka kode sumber lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">GitHub</a> . <br><a name="habracut"></a><br>  Saat membuat game, saya menggunakan sumber daya grafis dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">Kenney's Pirate Pack</a> dan framework game <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">Phaser</a> .  Dalam tutorial ini Anda ditugaskan peran programmer jaringan.  Titik awal akan menjadi versi pengguna tunggal yang berfungsi penuh dari permainan, dan tugas kami adalah menulis server di Node.js menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Socket.io</a> untuk bagian jaringan.  Agar tidak membebani tutorial, saya akan fokus pada bagian yang terkait dengan multipemain dan melewati konsep yang terkait dengan Phaser dan Node.js. <br><br>  Anda tidak perlu mengonfigurasi apa pun secara lokal, karena kami akan membuat game ini sepenuhnya di browser di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Glitch.com</a> !  Glitch adalah alat yang luar biasa untuk membangun aplikasi web, termasuk backend, database, dan banyak lagi.  Ini bagus untuk membuat prototipe, pelatihan, dan kolaborasi, dan saya akan sangat senang memperkenalkan Anda dengan kemampuannya dalam tutorial ini. <br><br>  Mari kita mulai. <br><br><h2>  1. Persiapan </h2><br>  Saya memposting draft proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">Glitch.com</a> . <br><br>  Tip Antarmuka: Anda dapat meluncurkan pratinjau aplikasi dengan mengklik tombol <strong>Show</strong> (kiri atas). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/8b6/4dd/ac28b64dd9c37370872ad6a913b10078.png"></div><br>  Bilah samping vertikal di sebelah kiri berisi semua file aplikasi.  Untuk mengedit aplikasi ini, Anda harus membuat "remix" -nya.  Jadi kita akan membuat salinannya di akun kita (atau "fork" di git jargon).  Klik pada tombol <strong>Remix this</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/88f/6e4/f7188f6e4b66e9b9801d04c7891d42dd.png"></div><br>  Pada titik ini, Anda sedang mengedit aplikasi di bawah akun anonim.  Untuk menyimpan pekerjaan Anda, Anda dapat masuk (kanan atas). <br><br>  Sekarang, sebelum melanjutkan, penting bagi Anda untuk berkenalan dengan game tempat kami akan menambahkan mode multipemain.  Lihatlah <strong>index.html</strong> .  Ini memiliki tiga fungsi penting yang perlu Anda ketahui: <code>preload</code> (baris 99), <code>create</code> (line 115) dan <code>GameLoop</code> (line 142), serta objek pemain (baris 35). <br><br>  Jika Anda lebih suka belajar dengan berlatih, maka pastikan untuk memahami pekerjaan permainan dengan menyelesaikan tugas-tugas berikut: <br><br><ul><li>  Tingkatkan ukuran dunia <em>(baris 29)</em> - <em>perhatikan bahwa ada ukuran dunia yang terpisah untuk dunia dalam game dan ukuran jendela untuk kanvas halaman itu sendiri</em> . </li><li>  Memungkinkan untuk bergerak maju dengan bantuan "ruang" <em>(baris 53).</em> </li><li>  Ubah jenis kapal pemain <em>(baris 129).</em> </li><li>  Perlambat gerakan kerang <em>(baris 155).</em> </li></ul><br><h3>  Pasang Socket.io </h3><br>  Socket.io adalah pustaka untuk mengelola komunikasi real-time di dalam browser menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSockets</a> (alih-alih menggunakan protokol seperti UDP, yang digunakan untuk membuat game multipemain klasik).  Selain itu, perpustakaan memiliki cara berlebihan untuk memastikan operasi, bahkan ketika WebSockets tidak didukung.  Artinya, dia berurusan dengan protokol pengiriman pesan dan memungkinkan penggunaan sistem pesan berbasis acara yang nyaman. <br><br>  Hal pertama yang perlu kita lakukan adalah memasang modul Socket.io.  Di Glitch, ini dapat dilakukan dengan masuk ke file <strong>package.json</strong> , dan kemudian memasukkan modul yang diperlukan di dependensi, atau mengklik <strong>Tambah paket</strong> dan memasukkan "socket.io". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/41f/005/d9441f0059e23044aa69f6f8750c81bb.png"></div><br>  Sekarang adalah waktu yang tepat untuk berurusan dengan log server.  Klik tombol <strong>Log</strong> di sebelah kiri untuk membuka log server.  Anda akan melihat bahwa ia menginstal Socket.io dengan semua dependensinya.  Di sinilah Anda perlu mencari semua kesalahan dan output dari kode server. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/6e1/58c/7db6e158c6e48d0d91f70344eaf51af7.png"></div><br>  Sekarang mari kita pergi ke <strong>server.js</strong> .  Di sinilah kode server kami berada.  Sejauh ini, hanya ada beberapa kode boilerplate dasar untuk menyajikan HTML kami.  Tambahkan baris ke bagian atas file untuk mengaktifkan Socket.io: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(http); <span class="hljs-comment"><span class="hljs-comment">//     http</span></span></code> </pre> <br>  Sekarang kita juga perlu mengaktifkan Socket.io di klien, jadi mari kita kembali ke <strong>index.html</strong> dan tambahkan baris berikut di dalam <code>&lt;head&gt;</code> : <br><br><pre> <code class="javascript hljs">&lt;!--    Socket.io --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/socket.io/socket.io.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  <em>Catatan: Socket.io secara otomatis memproses pemuatan pustaka klien di sepanjang jalur ini, jadi baris ini berfungsi bahkan jika tidak ada direktori /socket.io/ di folder Anda.</em> <br><br>  Sekarang Socket.io termasuk dalam proyek dan siap untuk pergi! <br><br><h2>  2. Pengakuan dan pemijahan pemain </h2><br>  Langkah nyata pertama kami adalah menerima koneksi di server dan membuat pemain baru di klien. <br><br><h3>  Menerima koneksi server </h3><br>  Tambahkan kode ini ke bagian bawah <strong>server.js</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); })</span></span></code> </pre> <br>  Jadi kami meminta Socket.io untuk mendengarkan semua acara <code>connection</code> yang secara otomatis terjadi ketika klien terhubung.  Perpustakaan membuat objek <code>socket</code> baru untuk setiap klien, di mana <code>socket.id</code> adalah pengidentifikasi unik untuk klien ini. <br><br>  Untuk memverifikasi bahwa ini berfungsi, kembali ke klien ( <strong>index.html</strong> ) dan tambahkan baris ini di suatu tempat di fungsi <strong>buat</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = io(); <span class="hljs-comment"><span class="hljs-comment">//    'connection'  </span></span></code> </pre> <br>  Jika Anda memulai permainan dan melihat log server (klik tombol <strong>Log</strong> ), Anda akan melihat bahwa server telah mendaftarkan acara koneksi ini! <br><br>  Sekarang, saat menghubungkan pemain baru, kami berharap dia memberi kami informasi tentang kondisinya.  Dalam kasus kami, kami perlu tahu setidaknya <strong>x</strong> , <strong>y</strong> dan <strong>sudut</strong> untuk membuatnya dengan benar di titik yang tepat. <br><br>  Acara <code>connection</code> adalah acara inline yang dipicu oleh Socket.io.  Kami dapat mendengarkan acara yang diatur secara independen.  Saya akan memberi nama <code>new-player</code> acara saya, dan saya akan mengharapkan klien untuk mengirimkannya segera setelah terhubung dengan informasi tentang posisinya.  Ini akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); }) })</span></span></code> </pre> <br>  Jika Anda menjalankan kode ini, maka sampai Anda melihat sesuatu di log server, karena kami belum memberi tahu klien untuk membuat acara <code>new-player</code> ini.  Tapi mari kita berpura-pura sejenak bahwa kita sudah melakukan ini, dan terus bekerja di server.  Apa yang harus terjadi setelah mendapatkan lokasi pemain yang baru bergabung? <br><br>  Kami dapat mengirim pesan ke semua pemain <em>lain yang</em> terhubung sehingga mereka tahu bahwa pemain baru telah muncul.  Socket.io memiliki fungsi yang nyaman untuk ini: <br><br><pre> <code class="javascript hljs">socket.broadcast.emit(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,state_data);</code> </pre> <br>  Ketika <code>socket.emit</code> dipanggil <code>socket.emit</code> pesan itu hanya diteruskan ke klien tunggal ini.  Ketika <code>socket.broadcast.emit</code> dipanggil <code>socket.broadcast.emit</code> ia dikirim ke setiap klien yang terhubung ke server, kecuali pada soket siapa fungsi ini dipanggil. <br><br>  Fungsi <code>io.emit</code> mengirimkan pesan ke setiap klien yang terhubung ke server tanpa pengecualian.  Dalam skema kami, kami tidak memerlukan ini, karena jika kami menerima pesan dari server yang meminta kami membuat kapal kami sendiri, maka kami akan mendapatkan duplikat sprite, karena kami sudah membuat kapal kami sendiri ketika permainan dimulai.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut tip praktis</a> tentang berbagai jenis fitur perpesanan yang akan kami gunakan dalam tutorial ini. <br><br>  Kode server sekarang akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); socket.broadcast.emit('create-player',state_data); }) })</span></span></code> </pre> <br>  Artinya, setiap kali pemain terhubung, kami berharap dia mengirimi kami pesan berisi informasi tentang lokasinya, dan kami mengirim data ini ke semua pemain lain sehingga mereka dapat membuat sprite-nya. <br><br><h3>  Pemijahan klien </h3><br>  Sekarang, untuk menyelesaikan siklus ini, kita perlu melakukan dua tindakan di klien: <br><br><ol><li>  Hasilkan pesan dengan data lokasi kami setelah koneksi. </li><li>  Dengarkan acara membuat pemain dan buat pemain pada saat ini. </li></ol><br>  Untuk melakukan tindakan pertama setelah membuat pemain di fungsi <strong>buat</strong> (kira-kira di baris 135), kami dapat membuat pesan berisi data lokasi yang perlu kami kirim: <br><br><pre> <code class="javascript hljs">socket.emit(<span class="hljs-string"><span class="hljs-string">'new-player'</span></span>,{<span class="hljs-attr"><span class="hljs-attr">x</span></span>:player.sprite.x,<span class="hljs-attr"><span class="hljs-attr">y</span></span>:player.sprite.y,<span class="hljs-attr"><span class="hljs-attr">angle</span></span>:player.sprite.rotation})</code> </pre> <br>  Kita tidak perlu khawatir tentang serialisasi data yang dikirim.  Anda dapat mentransfernya di semua jenis objek, dan Socket.io akan memprosesnya untuk kami. <br><br>  Sebelum melanjutkan, <em>uji kodenya</em> .  Kita akan melihat pesan serupa di log server: <br><br><pre> <code class="javascript hljs">New player has state: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">728.8180247836519</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">261.9979387913289</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Sekarang kita tahu bahwa server kami menerima pemberitahuan tentang koneksi pemain baru dan dengan benar membaca data tentang lokasinya! <br><br>  Selanjutnya, kami ingin mendengarkan permintaan untuk membuat pemain baru.  Kita dapat menempatkan kode ini segera setelah membuat pesan, seharusnya terlihat seperti ini: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CreateShip -      ,     CreateShip(1,state.x,state.y,state.angle) })</span></span></code> </pre> <br>  Sekarang <em>uji kodenya</em> .  Buka dua jendela dengan permainan dan pastikan itu berfungsi. <br><br>  Anda harus melihat bahwa setelah membuka dua klien, klien pertama memiliki dua kapal dibuat, dan yang kedua hanya memiliki satu. <br><br><blockquote>  Tugas: dapatkah Anda mencari tahu mengapa itu terjadi?  Atau bagaimana Anda bisa memperbaikinya?  Langkah demi langkah ikuti logika klien / server yang kami tulis dan coba debug. </blockquote><br>  Saya harap Anda mencoba mencari tahu sendiri!  Berikut ini terjadi: ketika pemain pertama terhubung, server mengirimkan acara <code>create-player</code> ke semua pemain lain, tetapi belum ada pemain yang bisa menerimanya.  Setelah menghubungkan pemain kedua, server mengirim kembali pesannya, dan pemain pertama menerimanya dan membuat sprite dengan benar, sementara pemain kedua melewatkan pesan dari pemain pertama. <br><br>  Artinya, masalahnya adalah bahwa pemain kedua terhubung ke permainan nanti dan dia perlu mengetahui keadaan permainan.  Kami harus memberi tahu semua pemain penghubung baru bahwa para pemain sudah ada (serta acara lain yang telah terjadi di dunia) sehingga mereka dapat mengarahkan diri mereka sendiri.  Sebelum kita menyelesaikan masalah ini, saya memiliki peringatan singkat. <br><br><h3>  Peringatan Sinkronisasi Status Game </h3><br>  Ada dua pendekatan untuk mengimplementasikan sinkronisasi semua pemain.  Yang pertama adalah mengirim sejumlah informasi minimum tentang perubahan yang terjadi melalui jaringan.  Yaitu, setiap kali pemain baru terhubung, kami akan mengirimkan semua pemain lain hanya informasi tentang pemain baru ini (dan mengirim daftar semua pemain lain di dunia ke pemain baru ini), dan setelah memutuskan sambungan kami memberi tahu semua pemain bahwa pemain tertentu ini telah terputus. <br><br>  Pendekatan kedua adalah untuk menyampaikan seluruh kondisi permainan.  Dalam hal ini, kami hanya setiap kali Anda menghubungkan atau memutuskan mengirim semua orang daftar lengkap semua pemain. <br><br>  Pendekatan pertama lebih baik karena meminimalkan jumlah informasi yang dikirimkan melalui jaringan, tetapi bisa sangat sulit untuk diterapkan, dan memiliki kemungkinan pemain tidak sinkron.  Yang kedua memastikan bahwa pemain selalu sinkron, tetapi setiap pesan harus mengirim lebih banyak data. <br><br>  Dalam kasus kami, alih-alih mencoba mengirim pesan ketika pemain terhubung untuk membuatnya dan ketika terputus untuk menghapusnya, serta ketika bergerak untuk memperbarui posisinya, kami dapat menggabungkan semua ini menjadi satu peristiwa <code>update</code> umum.  Acara pembaruan ini akan selalu mengirim posisi masing-masing pemain ke semua pelanggan.  Inilah yang harus dilakukan server.  Tugas klien adalah untuk menjaga kesesuaian dunia dengan negara yang diterima. <br><br>  Untuk mengimplementasikan skema semacam itu, saya akan melakukan hal berikut: <br><br><ol><li>  Saya akan menyimpan kamus pemain, yang kuncinya adalah ID mereka, dan nilainya akan menjadi data di lokasi mereka. </li><li>  Tambahkan pemain ke kamus ini saat terhubung dan kirim acara pembaruan. </li><li>  Hapus pemain dari kamus ini ketika dimatikan dan kirim acara pembaruan. </li></ol><br>  Anda dapat mencoba menerapkan sistem ini sendiri, karena langkah-langkah ini cukup sederhana ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">tip fitur saya</a> mungkin berguna di sini).  Seperti apa implementasi penuh kelihatannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    // 1 -      / var players = {}; io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); // 2 -      players[socket.id] = state_data; //    io.emit('update-players',players); }) socket.on('disconnect',function(){ // 3-       delete players[socket.id]; //    }) })</span></span></code> </pre> <br>  Sisi klien sedikit lebih rumit.  Di satu sisi, sekarang kita seharusnya hanya peduli pada acara <code>update-players</code> , tetapi di sisi lain, kita harus mempertimbangkan membuat kapal baru jika server mengirim lebih banyak kapal daripada yang kita tahu, atau menghapus jika ada terlalu banyak dari mereka. <br><br>  Inilah cara saya menangani acara ini di klien: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     // : -         other_players = {} socket.on('update-players',function(players_data){ var players_found = {}; //        for(var id in players_data){ //      if(other_players[id] == undefined &amp;&amp; id != socket.id){ // ,      var data = players_data[id]; var p = CreateShip(1,data.x,data.y,data.angle); other_players[id] = p; console.log("Created new player at (" + data.x + ", " + data.y + ")"); } players_found[id] = true; //     if(id != socket.id){ other_players[id].x = players_data[id].x; //  ,    ,      other_players[id].y = players_data[id].y; other_players[id].rotation = players_data[id].angle; } } //       for(var id in other_players){ if(!players_found[id]){ other_players[id].destroy(); delete other_players[id]; } } })</span></span></code> </pre> <br>  Di sisi klien, saya menyimpan kapal di kamus <code>other_players</code> , yang baru saja saya definisikan di bagian atas skrip (tidak ditampilkan di sini).  Karena server mengirim data pemain ke semua pemain, saya harus menambahkan tanda centang agar klien tidak membuat sprite tambahan untuk dirinya sendiri.  (Jika Anda memiliki masalah dengan penataan, maka di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external">kode lengkap</a> yang seharusnya ada di index.html saat ini). <br><br>  Sekarang <em>uji kodenya</em> .  Anda harus dapat membuat beberapa pelanggan dan melihat jumlah kapal yang benar dibuat di posisi yang tepat! <br><br><h2>  3. Sinkronisasi posisi kapal </h2><br>  Di sini dimulai bagian yang sangat menarik.  Kami ingin menyinkronkan posisi kapal pada semua klien.  Ini akan mengungkapkan kesederhanaan struktur yang telah kita buat saat ini.  Kami sudah memiliki acara pembaruan yang dapat menyinkronkan lokasi semua kapal.  Cukup bagi kita untuk melakukan hal berikut: <br><br><ol><li>  Paksa klien untuk menghasilkan pesan setiap kali ia pindah ke posisi baru. </li><li>  Ajari server untuk mendengarkan pesan gerakan ini dan memperbarui elemen data <code>players</code> kamus <code>players</code> . </li><li>  Hasilkan acara pembaruan untuk semua klien. </li></ol><br>  Dan itu sudah cukup!  Sekarang giliran Anda untuk mencoba mengimplementasikannya sendiri. <br><br>  Jika Anda benar-benar bingung dan membutuhkan petunjuk, maka lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek yang sudah selesai</a> . <br><br><h3>  Catatan tentang meminimalkan data yang dikirim melalui jaringan </h3><br>  Cara paling mudah untuk mengimplementasikannya adalah dengan memperbarui posisi semua pemain setiap kali acara pergerakan diterima dari pemain <em>mana pun</em> .  Sangat bagus jika pemain selalu mendapatkan informasi terbaru segera setelah itu muncul, tetapi jumlah pesan yang dikirim melalui jaringan dapat dengan mudah bertambah menjadi ratusan per bingkai.  Bayangkan Anda memiliki 10 pemain, yang masing-masing mengirim pesan gerakan di setiap frame.  Server harus meneruskannya kembali ke 10 pemain.  Ini sudah 100 pesan per bingkai! <br><br>  Akan lebih baik untuk melakukan ini: tunggu sampai server menerima semua pesan dari semua pemain, dan kemudian kirim semua pemain pembaruan besar yang berisi semua informasi.  Dengan demikian, kami akan mengurangi jumlah pesan yang ditransmisikan ke jumlah pengguna yang ada dalam game (bukan kuadrat dari nomor ini).  Masalahnya di sini adalah bahwa semua pengguna akan mengalami penundaan yang sama seperti pemain dengan koneksi paling lambat. <br><br>  Solusi lain adalah mengirim pembaruan server pada frekuensi konstan, terlepas dari jumlah pesan yang diterima dari pemain.  Standar umum adalah memperbarui server sekitar 30 kali per detik. <br><br>  Namun, ketika memilih struktur server Anda, Anda harus mengevaluasi jumlah pesan yang dikirimkan dalam setiap frame pada tahap awal pengembangan game. <br><br><h2>  4. Sinkronisasi shell </h2><br>  Kita hampir selesai!  Bagian serius terakhir adalah menyinkronkan melalui jaringan kerang.  Kami dapat menerapkannya dengan cara yang sama seperti pemain yang disinkronkan: <br><br><ul><li>  Setiap klien mengirimkan posisi semua cangkang mereka di setiap frame. </li><li>  Server mengarahkan mereka ke setiap pemain. </li></ul><br>  Tapi ada masalah. <br><br><h3>  Perlindungan curang </h3><br>  Jika Anda mengarahkan ulang segala sesuatu yang dikirim klien sebagai posisi sebenarnya dari shell, pemain dapat dengan mudah menipu dengan memodifikasi kliennya dan mengirimkan data palsu kepada Anda, misalnya, shell yang melakukan teleportasi ke posisi kapal.  Anda dapat dengan mudah memverifikasi ini sendiri dengan mengunduh halaman web, mengubah kode menjadi JavaScript, dan membukanya lagi.  Dan ini adalah masalah tidak hanya untuk game browser.  Dalam kasus umum, kami tidak pernah bisa mempercayai data yang berasal dari pengguna. <br><br>  Untuk mengatasi sebagian masalah ini, kami akan mencoba menggunakan skema lain: <br><br><ul><li>  Klien menghasilkan pesan tentang shell tembakan dengan posisi dan arahnya. </li><li>  Server mensimulasikan pergerakan cangkang. </li><li>  Server memperbarui data setiap klien, melewati posisi semua shell. </li><li>  Klien membuat shell di posisi yang diterima dari server. </li></ul><br>  Dengan demikian, klien bertanggung jawab atas posisi proyektil, tetapi tidak untuk kecepatannya dan bukan untuk pergerakan selanjutnya.  Klien dapat mengubah posisi cangkang untuk dirinya sendiri, tetapi ini tidak akan mengubah apa yang dilihat klien lain. <br><br>  Untuk mengimplementasikan skema semacam itu, kami akan menambahkan pembuatan pesan saat dipecat.  Saya tidak akan lagi membuat sprite itu sendiri, karena keberadaan dan lokasinya akan sepenuhnya ditentukan oleh server.  Sekarang tembakan proyektil baru kami di <strong>index.html</strong> akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){ var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20; var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20; /*    ,       ,       var bullet = {}; bullet.speed_x = speed_x; bullet.speed_y = speed_y; bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet'); bullet_array.push(bullet); */ this.shot = true; //  ,     socket.emit('shoot-bullet',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y}) }</span></span></code> </pre> <br>  Juga sekarang kita dapat mengomentari seluruh fragmen kode yang memperbarui shell di klien: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,         //   for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.sprite.x += bullet.speed_x; bullet.sprite.y += bullet.speed_y; //  ,       if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){ bullet.sprite.destroy(); bullet_array.splice(i,1); i--; } } */</span></span></code> </pre> <br>  Akhirnya, kita perlu membuat klien mendengarkan pembaruan shell.  Saya memutuskan untuk mengimplementasikan ini dengan cara yang sama seperti dengan para pemain, yaitu, server hanya mengirim array dari semua posisi shell dalam peristiwa yang disebut <code>bullets-update</code> , dan klien membuat atau menghancurkan shell untuk menjaga sinkronisasi.  Begini tampilannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     socket.on('bullets-update',function(server_bullet_array){ //     ,   for(var i=0;i&lt;server_bullet_array.length;i++){ if(bullet_array[i] == undefined){ bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet'); } else { //      ! bullet_array[i].x = server_bullet_array[i].x; bullet_array[i].y = server_bullet_array[i].y; } } //    ,   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){ bullet_array[i].destroy(); bullet_array.splice(i,1); i--; } })</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan hanya itu yang seharusnya ada di klien. </font><font style="vertical-align: inherit;">Saya akan berasumsi bahwa Anda sudah tahu di mana harus menyematkan fragmen kode ini dan bagaimana menyatukannya, tetapi jika Anda memiliki masalah, Anda selalu dapat melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil yang sudah selesai</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang di server.js kita perlu melacak dan mensimulasikan shell. </font><font style="vertical-align: inherit;">Pertama, kami akan membuat array untuk melacak shell, mirip dengan array untuk pemain:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bullet_array = []; <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selanjutnya, kami mendengarkan acara tembakan proyektil: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   shoot-bullet        socket.on('shoot-bullet',function(data){ if(players[socket.id] == undefined) return; var new_bullet = data; data.owner_id = socket.id; //    id  bullet_array.push(new_bullet); });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kami mensimulasikan cangkang 60 kali per detik: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   60       function ServerGameLoop(){ for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.x += bullet.speed_x; bullet.y += bullet.speed_y; // ,       if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){ bullet_array.splice(i,1); i--; } } } setInterval(ServerGameLoop, 16);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan langkah terakhir adalah mengirim acara pembaruan di suatu tempat di dalam fungsi ini (tapi jelas di luar for for loop): </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,    io.emit("bullets-update",bullet_array);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita akhirnya bisa menguji permainan! </font><font style="vertical-align: inherit;">Jika semuanya ternyata benar, maka Anda akan melihat bahwa cangkang disinkronkan dengan benar pada semua klien. </font><font style="vertical-align: inherit;">Fakta bahwa kami menerapkan ini pada server memaksa kami untuk melakukan lebih banyak pekerjaan, tetapi itu memberi kami lebih banyak kontrol. </font><font style="vertical-align: inherit;">Misalnya, ketika kami menerima peristiwa penembakan proyektil, kami dapat memeriksa apakah kecepatan proyektil berada dalam interval tertentu, dan jika tidak demikian, kami akan tahu bahwa pemain ini curang.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Tabrakan dengan kerang </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah mekanisme dasar terakhir yang kami laksanakan. </font><font style="vertical-align: inherit;">Saya harap Anda sudah terbiasa dengan prosedur untuk merencanakan implementasi Anda, pertama menyelesaikan implementasi klien sepenuhnya, dan kemudian pindah ke server (atau sebaliknya). </font><font style="vertical-align: inherit;">Metode ini jauh lebih rentan kesalahan daripada melompat ketika diterapkan bolak-balik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memeriksa tabrakan adalah mekanik gim yang penting, jadi kami ingin agar terlindung dari kecurangan. </font><font style="vertical-align: inherit;">Kami mengimplementasikannya di server dengan cara yang sama seperti yang kami lakukan dengan shell. </font><font style="vertical-align: inherit;">Kami membutuhkan yang berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Periksa apakah proyektilnya cukup dekat dengan pemain di server. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasilkan acara untuk semua klien saat proyektil mengenai pemain. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajari klien untuk mendengarkan acara hit dan buat kapal berkedip saat mengenai. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mencoba mengimplementasikan bagian ini sendiri. </font><font style="vertical-align: inherit;">Untuk membuat kapal pemain berkedip ketika mengenai, cukup setel saluran alfa ke 0:</font></font><br><br><pre> <code class="javascript hljs">player.sprite.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan itu akan dengan lancar kembali ke opacity penuh (ini dilakukan dalam pembaruan pemain). </font><font style="vertical-align: inherit;">Untuk pemain lain, aksinya akan serupa, tetapi Anda harus mengembalikan saluran alfa ke satu di fungsi pembaruan dengan sesuatu yang serupa:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> other_players){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other_players[id].alpha &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ other_players[id].alpha += (<span class="hljs-number"><span class="hljs-number">1</span></span> - other_players[id].alpha) * <span class="hljs-number"><span class="hljs-number">0.16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other_players[id].alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya bagian yang sulit adalah memverifikasi bahwa pemain tidak mengenai cangkangnya sendiri (jika tidak, ia akan mendapat kerusakan setiap kali ia menembak). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa dalam skema ini, bahkan jika klien mencoba menipu dan menolak untuk menerima pesan hit yang dikirim kepadanya oleh server, ini hanya akan mengubah apa yang dilihatnya di layarnya sendiri. </font><font style="vertical-align: inherit;">Semua pemain lain masih akan melihat bahwa mereka menekan pemain.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Gerakan menghaluskan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda telah menyelesaikan semua langkah hingga saat ini, saya dapat memberi selamat kepada Anda. </font><font style="vertical-align: inherit;">Anda baru saja membuat game multiplayer yang berfungsi! </font><font style="vertical-align: inherit;">Kirim tautan ke teman dan lihat bagaimana keajaiban multiplayer online dapat menyatukan pemain! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permainan ini berfungsi penuh, tetapi pekerjaan kami tidak berakhir di sana. </font><font style="vertical-align: inherit;">Ada beberapa masalah yang dapat memengaruhi permainan secara negatif, dan kita harus mengatasinya:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika tidak semua orang memiliki koneksi cepat, maka pergerakan pemain lain terlihat sangat gugup. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerang tampaknya lambat, karena tidak segera dipecat. </font><font style="vertical-align: inherit;">Sebelum muncul di layar klien, mereka menunggu pesan balasan dari server.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat memecahkan masalah pertama dengan menginterpolasi data posisi kapal kami di klien. Karena itu, jika kami tidak menerima pembaruan dengan cukup cepat, kami dapat dengan lancar memindahkan kapal ke tempat di mana seharusnya, dan tidak hanya memindahkannya ke sana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerang membutuhkan solusi yang lebih kompleks. Kami ingin server memproses cangkang untuk melindungi dari kecurangan, tetapi kami juga membutuhkan reaksi instan: tembakan dan proyektil terbang. Solusi terbaik adalah pendekatan hybrid. Baik server dan klien dapat mensimulasikan shell, dan server masih akan mengirim pembaruan ke posisi shell. Jika mereka tidak sinkron, maka kami mengasumsikan bahwa server benar dan mendefinisikan kembali posisi proyektil di klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak akan menerapkan sistem shell ini dalam tutorial ini, tetapi senang mengetahui bahwa metode ini ada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melakukan interpolasi sederhana posisi kapal sangat sederhana. </font><font style="vertical-align: inherit;">Alih-alih mengatur posisi secara langsung dalam acara pembaruan, tempat kami pertama kali menerima data posisi baru, kami hanya menyimpan posisi target:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     if(id != socket.id){ other_players[id].target_x = players_data[id].x; //  ,    ,     other_players[id].target_y = players_data[id].y; other_players[id].target_rotation = players_data[id].angle; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemudian, dalam fungsi pembaruan (juga di sisi klien), kami memutar semua pemain lain dan mendorong mereka ke arah tujuan mereka: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      for(var id in other_players){ var p = other_players[id]; if(p.target_x != undefined){ px += (p.target_x - px) * 0.16; py += (p.target_y - py) * 0.16; //  ,    /  var angle = p.target_rotation; var dir = (angle - p.rotation) / (Math.PI * 2); dir -= Math.round(dir); dir = dir * Math.PI * 2; p.rotation += dir * 0.16; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan demikian, server mengirimkan pembaruan kepada kami 30 kali per detik, tetapi kami masih bisa bermain dengan kecepatan 60 fps dan permainan masih terlihat lancar! </font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memeriksa banyak masalah. Mari kita buat daftar: kita belajar cara mentransfer pesan antara klien dan server, cara menyinkronkan keadaan permainan, menyiarkannya dari server ke semua pemain. Ini adalah cara termudah untuk mengimplementasikan game online multi-pemain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga belajar cara melindungi gim dari kecurangan, mensimulasikan bagian-bagian penting di server dan memberi tahu pelanggan tentang hasilnya. Semakin sedikit Anda mempercayai klien, semakin aman permainannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, kami belajar cara mengatasi penundaan menggunakan interpolasi klien. Kompensasi untuk keterlambatan adalah topik serius dan sangat penting (beberapa game dengan penundaan yang cukup besar menjadi tidak bisa dimainkan). Interpolasi sambil menunggu pembaruan berikutnya dari server hanyalah salah satu cara untuk mengurangi masalah. Yang lain sedang memprediksi beberapa frame berikutnya di muka, dan memperbaikinya ketika menerima data nyata dari server, tetapi, tentu saja, pendekatan ini bisa sangat sulit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang sama sekali berbeda untuk mengurangi dampak penundaan adalah membuat desain sistem mem-bypass masalah ini. </font><font style="vertical-align: inherit;">Keuntungan dari putaran kapal lambat adalah bahwa itu adalah mekanisme gerakan yang unik, dan itu adalah cara untuk mencegah perubahan tiba-tiba dalam pergerakan. </font><font style="vertical-align: inherit;">Karenanya, meski dengan koneksi lambat, mereka tetap tidak akan merusak gameplay. </font><font style="vertical-align: inherit;">Sangat penting untuk mempertimbangkan keterlambatan saat mengembangkan elemen-elemen dasar permainan. </font><font style="vertical-align: inherit;">Terkadang keputusan terbaik sama sekali bukan trik teknis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan fungsi Glitch lain yang bermanfaat, yang terdiri dari kemampuan untuk mengunduh atau mengekspor proyek Anda sendiri melalui Opsi Tingkat Lanjut di sudut kiri atas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/d6b/dba/c62d6bdba51311a7a0d8976c37dbe6fb.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418411/">https://habr.com/ru/post/id418411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418399/index.html">Pada gelombang Selectel FM</a></li>
<li><a href="../id418401/index.html">Bagaimana saya tidak menjadi Anda: posting cinta untuk administrator sistem</a></li>
<li><a href="../id418403/index.html">Contoh Pemrograman Akselerator FPGA</a></li>
<li><a href="../id418405/index.html">Prinsip piramida terbalik dalam analitik. Kami membangun dasbor yang bisa dimengerti</a></li>
<li><a href="../id418407/index.html">Penambangan awan Hashflare telah ditutup. Uang tidak kembali</a></li>
<li><a href="../id418415/index.html">Telegram memperkenalkan layanan Paspornya sendiri untuk verifikasi dan otorisasi pengguna</a></li>
<li><a href="../id418417/index.html">Apollo: 9 bulan - penerbangan normal</a></li>
<li><a href="../id418419/index.html">Bagaimana Dodo Pizza Memecahkan Masalah Bisnis Menggunakan Pembelajaran Mesin</a></li>
<li><a href="../id418423/index.html">Rumah pintar: dimensi baru kenyamanan dan pengejaran keunggulan. Bagian satu</a></li>
<li><a href="../id418427/index.html">Pengindeksan seluler-pertama. Bagaimana dan mengapa grafik tautan berubah?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>