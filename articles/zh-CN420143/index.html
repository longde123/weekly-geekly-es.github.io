<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👯 👩‍🚒 🚶🏿 Kotlin在Android上的性能 😖 👏🏼 📬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天让我们谈谈Kotlin在生产中的Android性能。 让我们来看一下，实施棘手的优化，比较字节码。 最后，我们将认真进行比较并衡量基准。 

 本文基于亚历山大·斯米尔诺夫 （ Alexander Smirnov）在AppsConf 2017上的一份报告，将有助于弄清是否有可能用Kotlin编写...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin在Android上的性能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/"> 今天让我们谈谈Kotlin在生产中的Android性能。 让我们来看一下，实施棘手的优化，比较字节码。 最后，我们将认真进行比较并衡量基准。 <br><br> 本文基于<strong>亚历山大·斯米尔诺夫</strong> （ <strong>Alexander Smirnov）</strong>在AppsConf 2017上的一份报告，将有助于弄清是否有可能用Kotlin编写代码，这在速度上不会逊于Java。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>演讲者简介：</strong> PapaJobs的CTO Alexander Smirnov， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Faces中</a>运行视频博客<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android，</a>也是Mosdroid社区的组织者之一。 <br><a name="habracut"></a><br> 让我们从您的期望开始。 <br><br><blockquote> 您认为Kotlin在运行时是否比Java慢？ 还是更快？ 或者也许没有太大区别？ 毕竟，两者都可以使用虚拟机为我们提供的字节码。 </blockquote><br> 让我们做对。 传统上，当出现比较性能的问题时，每个人都希望看到基准和特定数字。 不幸的是，对于Android，没有JMH（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java Microbenchmark Harness</a> ），所以我们不能仅仅衡量在Java中可以完成多酷。 那么，我们可以做如下所述的测量吗？ <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br> 如果您曾经尝试过以这种方式来衡量代码，那么一位JMH开发人员将伤心，哭泣，并在梦里来到您身边-永远不要那样做。 <br><br> 在Android上，您可以进行基准测试，尤其是Google在去年的I / O上演示了这一点。 他们说，他们极大地改进了虚拟机，在本例中为ART，如果在Android 4.1上分配一个对象大约需要600-700纳秒，那么在第八个版本中，大约需要60纳秒。 即 他们能够在虚拟机中如此精确地对其进行测量。 为什么我们都不做-我们没有这样的工具。 <br><br> 如果我们查看所有文档，那么唯一可以发现的就是上面的建议，即如何测量UI： <br><br>  <strong>亚行shell dumpsys gfxinfo％package_name％</strong> <br><br> 实际上，让我们以这种方式进行操作，最后看看它会带来什么。 但是首先，我们将确定我们将测量的内容以及我们还能做的其他事情。 <br><br><blockquote> 下一个问题。 创建一流的应用程序时，您认为性能在哪里重要？ <br><br><ol><li> 绝对无处不在。 </li><li>  UI线程。 </li><li> 自定义视图+动画。 </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br> 我最喜欢第一个选项，但是最有可能相信不可能使所有代码都非常非常快地工作，并且至少没有UiThread或自定义视图很重要。 我也同意这一点-这非常非常重要。 没有人会注意到在您自己的JSON流中将反序列化10毫秒以上的事实。 <br><br> 格式塔心理学说，当我们眨眼大约150-300毫秒时，人眼无法聚焦，看不到那里实际发生的情况。 然后这10毫秒的天气就没有了。 但是，如果我们回到格式塔心理学，那么重要的不是我真正看到的和发生的事情，而是我作为用户所理解的很重要。 <br><br> 即 如果我们让用户认为他拥有非常非常快的所有东西，但是实际上，例如在漂亮的动画的帮助下，它会被完美地击败，那么即使实际上不是这样，他也会感到满意。 <br><br>  iOS中的格式塔心理学主题已经移动了很长时间。 因此，如果您将两个具有相同处理时间但在不同平台上的应用程序并排放置，则似乎在iOS上一切都更快。  iOS中的动画处理要快一些，较早的动画会在启动时启动，并会启动许多其他动画，因此它很漂亮。 <br><br> 因此， <strong>第一个规则是考虑用户。</strong> <br><br> 对于第二条规则，您需要将自己沉浸在铁杆中。 <br><br><h2> 小提琴风格 <br></h2><br> 为了诚实地评估Kotlin的性能，我们将其与Java进行比较。 因此，事实证明，无法衡量仅在Kotlin中存在的某些事物，例如： <br><br><ul><li> 集合Api。 </li><li> 方法默认参数。 </li><li> 数据类。 </li><li> 化类型。 </li><li> 协程。 </li></ul><br>  Kotlin提供给我们<strong>的Collection API</strong>非常酷，非常快。 在Java中，这根本不存在，只有不同的实现。 例如，Liteweight Stream API库会变慢，因为它所做的一切与Kotlin相同，但是会为操作分配一两个额外的分配，因为一切都会变成一个附加的对象。 <br><br> 如果我们采用Java 8的Stream API，它的运行速度将比Kotlin Collection API慢，但有一个条件-如果我们对大量Stream API数据启用并行，则Collection API中不会出现这种瘫痪， Java将绕过Kotlin Collection API。 因此，我们无法比较这些事情，因为我们正是从Android的角度进行比较。 <br><br> 在我看来，第二件事是无法比较的，它是<strong>Method的默认参数</strong> -一项很酷的功能，顺便说一下，它在Dart中。 当您调用某个方法时，它可能具有一些参数，这些参数可能需要一些值，但可能为NULL。 因此，您不会使用10种不同的方法，而是使用一种方法并说其中一个参数可以为NULL，并且将来使用时不带任何参数。 即 他会看，参数已经来了，还是他还没有来。 这很方便，因为您可以编写更少的代码，但是不便之处在于您必须为此付费。 这是语法糖：作为开发人员，您认为这是一个API方法，但实际上，在幕后，该方法的每个带有缺失参数的变体都是在字节码中生成的。 这些方法中的每一个都还逐位检查此参数是否到达。 如果成功，那么就创建一个位掩码，并根据该位掩码实际调用您编写的原始方法。 按位运算，所有的一切<em>都</em>花了一点钱，但是却很少，而且为了方便起见，这是正常的。 在我看来，这绝对是正常的。 <br><br> 下一个无法比较的项目是<strong>数据类</strong> 。 <br><br> 每个人都在哭泣，在Java中有一些参数，这些参数有一些模型类。 即 您可以获取参数并为所有这些参数执行更多方法，获取器和设置器。 事实证明，对于具有十个参数的类，您仍然需要一整套吸气剂，二传手和更多的东西。 此外，如果您不使用生成器，则必须用手书写，这通常很糟糕。 <br><br>  Kotlin让您摆脱一切。 首先，由于Kotlin中有属性，因此您无需编写getter和setter。 它<strong>没有类参数，所有属性</strong> 。 无论如何，我们是这样认为的。 其次，如果您将其写为Data类，则将生成其他所有内容。 例如equals（），toStrung（）/ hasCode（）等。 <br><br> 当然，这也有缺点。 例如，我不需要在equals（）中一次比较数据类的所有20个参数，而只需要比较3。有人不喜欢这一切，因为这样做会降低性能，并且还会产生很多东西服务功能，并且编译后的代码非常庞大。 也就是说，如果您手动编写所有内容，则与使用数据类相比，代码将更少。 <br><br> 由于其他原因，我不使用数据类。 以前，此类类的扩展受到限制。 现在每个人对此都比较好，但是习惯仍然存在。 <br><br> 在Kotlin中，什么是非常非常酷的？它将比Java上的更快？ 这是<strong>Reified类型</strong> ，顺便说一句，在Dart中也是如此。 <br><br> 您知道在使用泛型时，类型擦除将在编译阶段删除，并且在运行时您不再知道该泛型的实际对象是什么。 <br><br> 使用Reified类型时，在Java中不需要反射时，您不需要在很多地方使用反射，因为使用内联方法时，您可以通过Reified知道类型，因此事实证明您不使用反射，并且代码运行更快。 魔术。 <br><br> 还有<strong>协程</strong> 。 它们非常酷，我非常喜欢它们，但是在演奏时，它们仅包含在alpha版本中，因此无法与它们进行正确的比较。 <br><br><h2> 领域 <br></h2><br> 因此，让我们继续前进，继续我们可以与Java进行比较的内容以及我们可以总体上影响的内容。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br> 就像我说的，我们没有该类的参数，而是有属性。 <br><br> 我们有var，有val，有一个外部类，其一个属性是@JvmField，我们将研究work（）函数实际发生的情况：我们将自己类的字段a和字段b的值相加，外部类的字段a和字段b的值，该值写在不可变字段c中。 <br><br> 问题是，实际上将在d = a + b中调用什么。 我们都知道，一旦有此属性，就将为此参数调用此类的getter。 <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br> 但是，如果我们查看字节码，我们将看到实际上正在访问getfield。 也就是说，字节码中的这个不是对InvokeVirtual函数的调用，而是对字段的直接访问。 最初没有任何承诺要我们拥有所有属性，而不是字段。 事实证明，科特林在欺骗我们，这是直接的吸引力。 <br><br> 如果我们确实看到另一行生成了什么字节码，那么会发生什么情况：val e = ca + cb？ <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br> 以前，如果您要访问私有财产，那么您总是会收到一个InvokeVirtual调用。 如果这是私有财产，则可以通过GetField对其进行访问。  GetField比InvokeVirtual快得多，Android的规范声称直接访问字段要快3到7倍。 因此，建议您始终引用Field，而不是通过getter或setter来引用。 现在，尤其是在第八个ART虚拟机中，已经有不同的数字，但是如果您仍然支持4.1，这将是正确的。 <br><br> 因此，事实证明，拥有GetField而不是InvokeVirtual对我们仍然是有益的。 <br><br> 现在，如果要访问自己的类的属性，或者如果这是公共属性，则必须设置@JvmField，就可以实现GetField。 然后，GetField调用将在字节码中完全相同，这将提高3-7倍。 <br><br> 显然，我们在这里以纳秒为单位讲话，而且只有一个宝座，它很小，非常小。 但是，另一方面，如果您在UI线程中执行此操作（例如，在ondraw方法中访问某种视图），则这将影响每个帧的呈现，并且您可以更快地执行此操作。 <br><br>  <strong>如果我们将所有优化加起来，那么总而言之，它可以提供一些帮助。</strong> <br><br><h2> 静态！ <br></h2><br> 静电呢？ 我们都知道，在Kotlin中，static是一个伴随对象。 以前，您可能添加了某种标记，例如public static，final static等，如果将其转换为Kotlin代码，则将获得一个伴随对象，该对象将编写如下内容： <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote> 您认为该条目与Java中的标准静态最终声明相同吗？ 完全是静态的吗？ </blockquote><br> 是的，确实，Kotlin在这里声明它在Kotlin中-静态，该对象表示它是静态的。 实际上，这不是静态的。 <br><br> 如果查看生成的字节码，将看到以下内容： <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br> 生成一个Test.Companion；为其创建实例的单例对象，该实例被写入其自己的字段。 之后，将通过此对象访问伴随对象之一。 他采用getstatic，即此类的静态实例，并在其上调用getK函数invokevirtual，与work2函数完全相同。 因此我们得到它不是静态的。 <br><br> 这很重要，因为在较早的JVM上，invokestatic比invokevirtual快30％。 当然，现在在HotSpot，优化的虚拟化真的很酷，而且几乎是看不见的。 但是，您需要牢记这一点，尤其是因为有一个额外的分配，并且4ST1上的额外位置太700纳秒。 <br><br> 让我们看一下如果反向部署字节码时出现的Java代码： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br> 创建一个静态字段，创建Companion对象的静态最终实现，创建getter和setter，并且正如您所看到的，引用内部的静态字段时，将出现一个附加的static方法。 一切都很难过。 <br><br> 我们怎么办，确保它不是静态的？ 我们可以尝试添加@JvmField和@JvmStatic，看看会发生什么。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br> 我马上说，您不会离开@JvmStatic，它将是同一个对象，因为这是一个伴随对象，所以将对该对象进行额外的分配，并且会有一个额外的调用。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br> 但是调用将仅针对k进行更改，因为它将是@JvmField，它将直接作为getstatic使用，不再生成getter和setter。 但是对于work2函数，什么都不会改变。 <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br> 关于如何创建静态的第二种选择是在Kotlin文档中提出的，因此据说我们可以只创建一个对象，这就是静态代码。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br> 实际上，事实并非如此。 <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br> 事实证明，我们从创建的单调中进行了一个getstatic实例调用，并调用了完全相同的虚方法。 <br><br> 我们可以实现invokestatic的唯一方法是高阶函数。 例如，当我们只在类之外编写一些函数时，fun test2实际上将称为静态。 <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br> 此外，最有趣的是，将创建一个类，一个对象（在本例中为testKt），它将为其自身生成一个对象，将生成一个将其放入该对象的函数，现在将其称为invokestatic。 <br><br> 为什么这样做是无法理解的。 许多人对此不满意，但是有些人认为这种实现是很正常的。 由于虚拟机，包括。 艺术在进步，但现在并不是那么关键。 在Android的第八版中，就像在HotSpot上一样，所有内容都进行了优化，但是这些小问题仍然会稍微影响整体性能。 <br><br><h2> 可空性 <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br> 这是下一个有趣的例子。 似乎我们注意到，second可以为空，并且在对其进行任何操作之前必须对其进行检查。 在这种情况下，我希望我们能有一个。 如果第二秒不等于零，则部署此代码时，我认为执行会更进一步，并且仅先输出。 <br><br> 这实际上如何在Java代码中展现出来？ 实际上会有支票。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br> 我们将首先获得本征。 假设我说这个 <br><br> 如果将扩展为三元运算符。 但是除此之外，尽管我们甚至修复了第一个参数不能为空的问题，但仍将通过内部函数对其进行检查。 <br><br>  Intrinsics是Kotlin的内部类，具有一组特定的参数和检查。 每次使方法参数不可为空时，无论如何都会对其进行检查。 怎么了 然后，我们在Interop Java中工作，您可能会期望它在这里不会为空，但是对于Java，它将来自某个地方。 <br><br> 如果选中此选项，它将沿着代码走得更远，然后在调用10-20个方法之后，您将使用一个参数执行某项操作，尽管该参数可能不能为空，但由于某种原因它确实是可以为空的。 一切都会落到您身上，您将无法理解实际发生的情况。 为了避免这种情况，每次传递null参数时，仍然需要检查它。 并且如果它可以为空，那么将会有一个例外。 <br><br> 此检查也很有价值，如果有很多检查，那将不是很好。 <br><br> 但是实际上，如果我们谈论的是HotSpot，则这些Intrinsics的10次调用将花费大约4纳秒。 这非常非常小，您不必为此担心，但这是一个有趣的因素。 <br><br><h2> 基本原则 <br></h2><br> 在Java中，有一种称为原语的东西。 众所周知，在Kotlin中，没有基元，我们始终使用对象进行操作。 在Java中，它们用于在一些次要计算中为对象提供更高的性能。 添加两个对象比添加两个基元要昂贵得多。 考虑一个例子。 <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br> 有三个数字，因为将推导出前两个非空类型，而对于第三个，我们说它可以为空。 <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br> 如果查看字节码并查看生成了哪个Java代码，则前两个数字不为null，因此它们可以是原语。 但是原语不能包含Null，只有一个对象可以执行此操作，因此将为第三个数字生成一个对象。 <br><br><h2> 自动装箱 <br></h2><br> 当使用基元并使用基元和非基元执行操作时，您将需要将其中之一转换为基元或对象。 <br><br> 而且，如果您在Kotlin中使用可空值和不可空值进行操作，那么性能损失会很小，这并不奇怪。 而且，如果有很多这样的操作，那么您将损失很多。 <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br> 看到装箱/拆箱的位置在哪里？ 在查看字节码之前，我也没有看到。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br> 实际上，我希望会有这样的比较：如果字符串不为null且为空，则设置为true，否则设置为false。 一切似乎都很简单，但是实际上生成了以下代码： <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br> 让我们看看里面。 变量<em>a被</em>采用，将其强制转换为CharSequence，强制转换后也已使用了一段时间，另一个检查称为-StringsKt.isBlank-这是CharSequence扩展函数的编写方式，因此将其强制转换并发送。 由于第一个表达式可以为空，因此将其接受并进行装箱，并将其全部包装在Boolean.valueOf中。 因此，真正的原语也成为对象，并且只有在已经进行验证并调用Intrinsics.areEqual之后，该原语才成为对象。 <br><br> 看来这是一个简单的操作，但结果却出乎意料。 实际上，这种事情很少。 但是，当您可以拥有可为空/不可为空的内容时，就可以生成很多这样的东西，而这是您从未期望的。 因此，我建议您尽快摆脱晦涩难懂的地方。 即  <strong>尽早获得值的免疫力，并远离可为空值，</strong>以便您尽可能快地不为空。 <br><br><h2> 循环 <br></h2><br> 下一个有趣的事情。 <br><br> 您可以使用Java中的常规方式，但也可以使用新的便捷API-立即在列表中编写元素枚举。 ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     —   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   «»,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        −1,  until ,   ,    .   ,    ,    ranges. 即   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    —   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   — Xno-param-assertions —    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  — ,     .     ,    ,    0,04 . ,  ,        —   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  —   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   — . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420143/">https://habr.com/ru/post/zh-CN420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420131/index.html">概率比特币挖掘方法</a></li>
<li><a href="../zh-CN420133/index.html">动态系统建模：月球如何运动？</a></li>
<li><a href="../zh-CN420135/index.html">这也是东芝：日本公司的意外产品</a></li>
<li><a href="../zh-CN420139/index.html">本书“站点可靠性工程。 与Google一样的可靠性和可靠性»</a></li>
<li><a href="../zh-CN420141/index.html">从加载的MPP DBMS中-具有分析工具的peppy Data Lake：共享创建的详细信息</a></li>
<li><a href="../zh-CN420145/index.html">PC AppsConf会员的工作日如何</a></li>
<li><a href="../zh-CN420147/index.html">Clojure上的开源</a></li>
<li><a href="../zh-CN420151/index.html">比听起来容易。 第十二章</a></li>
<li><a href="../zh-CN420153/index.html">支持ABS和PLA的复杂零件的3D打印</a></li>
<li><a href="../zh-CN420155/index.html">英特尔数据中心SSD。 大批量和新名称</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>