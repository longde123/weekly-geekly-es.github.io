<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš± ğŸ ğŸ Tes Codeception untuk PHP backends â†–ï¸ â›µï¸ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Pasha dan saya seorang insinyur QA untuk tim Pemrosesan Pesanan di Lamoda. Saya baru-baru ini berbicara di PHP Badoo Meetup. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes Codeception untuk PHP backends</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/452136/">  Halo semuanya!  Nama saya Pasha dan saya seorang insinyur QA untuk tim Pemrosesan Pesanan di Lamoda.  Saya baru-baru ini berbicara di PHP Badoo Meetup.  Hari ini saya ingin memberikan transkrip dari laporan saya. <br><br>  Kami akan berbicara tentang Codeception, tentang bagaimana kami menggunakannya di Lamoda dan bagaimana menulis tes di atasnya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rg1h7mJrU7Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Lamoda memiliki banyak layanan.  Ada layanan klien yang berinteraksi langsung dengan pengguna kami, dengan pengguna situs, aplikasi seluler.  Kami tidak akan membicarakannya.  Dan ada yang oleh perusahaan kami disebut backend mendalam - ini adalah sistem back-office kami yang mengotomatiskan proses bisnis kami.  Ini termasuk pengiriman, penyimpanan, otomasi studio foto dan call center.  Sebagian besar layanan ini dikembangkan dalam PHP. <br><br>  Berbicara singkat tentang tumpukan kami, ini adalah PHP + Symfony.  Di sana-sini ada proyek lama di Zend'e.  PostgreSQL dan MySQL digunakan sebagai basis data, dan Rabbit atau Kafka digunakan sebagai sistem pengiriman pesan. <br><br>  <b>Mengapa PHP backends?</b> <br><br>  Karena mereka biasanya memiliki API bercabang - itu REST, di beberapa tempat ada sedikit SOAP.  Jika mereka memiliki UI, maka UI ini lebih merupakan tambahan, yang digunakan pengguna internal kami. <br><br>  <b>Mengapa kita perlu autotests di Lamoda?</b> <br><br>  Secara umum, ketika saya datang untuk bekerja di Lamoda, ada slogan seperti: "Mari kita singkirkan regresi manual".  Kami tidak akan menguji regresi apa pun secara manual.  Dan kami mengerjakan tugas ini.  Sebenarnya, ini adalah salah satu alasan utama mengapa kita membutuhkan autotest - agar tidak mendorong regresi dengan tangan.  Mengapa kita membutuhkan ini?  Hak untuk rilis dengan cepat.  Sehingga kami dapat dengan cepat, tanpa rasa sakit meluncurkan rilis kami dan pada saat yang sama memiliki semacam kisi-kisi dari tes mandiri yang akan mereka beri tahu, baik atau buruk.  Ini mungkin tujuan yang paling penting.  Tetapi ada beberapa pembantu, yang juga ingin saya sampaikan. <br><br>  Mengapa kita perlu uji otomatis? <br><br><ol><li>  Jangan menguji regresi dengan tangan Anda </li><li>  Rilis cepat </li><li>  Gunakan sebagai dokumentasi </li><li>  Mempercepat orientasi karyawan baru </li><li>  Autotests mudah digunakan (dalam beberapa kasus) sebagai dokumentasi.  Terkadang lebih mudah untuk mengikuti tes, melihat kasus mana yang dicakup, cara kerjanya, dan memahami cara kerja fungsi ini atau itu, dan mempercepat masuknya karyawan baru - baik pengembang maupun penguji - ke dalam proyek baru.  Ketika Anda duduk untuk menulis autotests, segera menjadi jelas bagaimana sistem bekerja. </li></ol><br>  Oke, bicarakan mengapa kita perlu autotest.  Sekarang mari kita bicara tentang tes apa yang kita tulis di Lamoda. <br><br><img src="https://habrastorage.org/webt/qx/ci/0f/qxci0fma8tivrntsz95gv-d802e.jpeg" alt="gambar"><br><br>  Ini adalah piramida pengujian yang cukup standar, dari pengujian unit hingga pengujian E2E, di mana beberapa rantai bisnis sudah diuji.  Saya tidak akan berbicara tentang dua tingkat yang lebih rendah, bukan karena mereka dicat dengan warna putih.  Ini adalah tes pada kode itu sendiri, ditulis oleh pengembang kami.  Dalam kasus ekstrim, tester dapat masuk ke Permintaan Tarik, melihat kode dan berkata: "Yah, ada sesuatu yang tidak cukup kasus di sini, mari kita bahas hal lain."  Ini melengkapi pekerjaan penguji untuk tes ini. <br><br>  Kami akan berbicara tentang level di atas, yang ditulis oleh pengembang dan penguji.  Mari kita mulai dengan tes sistem.  Ini adalah tes yang menguji API (REST atau SOAP), menguji beberapa logika sistem internal, berbagai perintah, antrian parse di Rabbit, atau pertukaran dengan sistem eksternal.  Sebagai aturan, tes ini cukup atom.  Mereka tidak memeriksa rantai apa pun, tetapi memeriksa satu tindakan.  Misalnya, satu metode API atau satu perintah.  Dan mereka memeriksa sebanyak mungkin kasus, baik positif maupun negatif. <br><br>  Silakan, tes E2E.  Saya membaginya menjadi 2 bagian.  Kami memiliki tes yang menguji sekelompok UI dan backend.  Dan ada tes yang kami sebut tes aliran.  Mereka menguji rantai - kehidupan suatu objek dari awal hingga akhir. <br><br>  Misalnya, kami memiliki sistem untuk mengelola pemrosesan pesanan kami.  Di dalam sistem seperti itu dapat ada tes - perintah dari penciptaan ke pengiriman, yaitu, melewati semua status.  Pada pengujian seperti itu maka sangat mudah dan sederhana untuk melihat bagaimana sistem bekerja.  Anda segera melihat seluruh aliran objek tertentu, dengan sistem eksternal apa semua ini berinteraksi, perintah apa yang digunakan untuk ini. <br><br>  Karena UI ini digunakan oleh pengguna internal, akses lintas-browser tidak penting bagi kami.  Kami tidak menjalankan tes ini di peternakan apa pun, cukup bagi kami untuk memeriksa dalam satu browser, dan terkadang kami bahkan tidak perlu menggunakan browser. <br><br>  "Mengapa kita memilih Codeception untuk otomatisasi pengujian?"  - Anda mungkin bertanya. <br><br>  Sejujurnya, saya tidak punya jawaban untuk pertanyaan ini.  Ketika saya datang ke Lamoda, Codeception sudah dipilih sebagai standar untuk menulis autotests, dan saya menemukan sebenarnya.  Tetapi setelah bekerja dengan kerangka kerja ini untuk beberapa waktu, saya masih mengerti mengapa Codeception.  Ini yang ingin saya bagikan dengan Anda. <br><br>  <b>Mengapa codeception?</b> <br><br><ol><li>  Anda dapat menulis dan menjalankan tes apa pun yang sama (unit, fungsional, penerimaan). </li><li>  Banyak rake telah diselesaikan, banyak modul telah ditulis. </li><li>  Di semua proyek, meskipun kebutuhan sedikit berbeda, tes akan terlihat sama. </li><li>  Konsep Codeception menyarankan Anda menulis tes apa pun pada kerangka kerja ini: unit, integrasi, fungsional, penerimaan.  Dan Anda, setidaknya, mereka akan diluncurkan secara setara. </li><li>  Codeception adalah prosesor yang cukup kuat di mana banyak masalah, banyak pertanyaan, banyak tugas untuk tes telah diselesaikan.  Jika sesuatu tidak diputuskan, kemungkinan besar Anda akan menemukan sesuatu dari luar - beberapa tambahan untuk beberapa pekerjaan tertentu.  Anda tidak perlu menulis pembungkus uji apa pun untuk basis data, untuk hal lain.  Hanya mengambil dan menghubungkan modul ke Codeception dan bekerja dengannya. </li><li>  Nah, nilai tambah seperti itu (mungkin itu lebih cocok untuk perusahaan besar ketika Anda memiliki banyak proyek dan layanan) - dalam semua proyek tes akan terlihat plus atau minus sama.  Ini sangat keren. </li></ol><br>  Secara singkat saya akan mengatakan seperti apa Codeception, karena banyak yang bekerja dengannya. <br><br><img src="https://habrastorage.org/webt/bp/ac/nt/bpacntwtc_xvl52su3nh7-vvidi.jpeg" alt="gambar"><br><br>  Codeception bekerja pada model aktor.  Setelah Anda menyeretnya ke dalam proyek dan menginisialisasi, struktur seperti itu dihasilkan. <br><br>  Kami memiliki file yml, di sini di bawah ini - <i>functional.suite.yml</i> , <i>integrasi.suit.yml</i> , <i>unit.suite.yml</i> .  Mereka menciptakan konfigurasi tes Anda.  Ada ayah untuk setiap jenis tes, di mana tes ini, ada 3 ayah tambahan: <br><br>  _ <i>data</i> - untuk data uji; <br>  _ <i>output</i> - di mana laporan ditempatkan (xml, html); <br>  _ <i>dukungan</i> - di mana beberapa pembantu bantu, fungsi, dan semua yang Anda tulis digunakan untuk digunakan dalam pengujian Anda. <br><br>  Untuk memulainya, saya akan memberi tahu Anda apa yang kami ambil dari Codeception dan menggunakannya di luar kotak, tidak mengubah apa pun, tidak menyelesaikan tugas atau masalah tambahan. <br><br>  <b>Modul standar</b> <br><br><ol><li>  Phpbrowser </li><li>  SISA </li><li>  Db </li><li>  Cli </li><li>  AMQP </li></ol><br>  Modul tersebut adalah PhpBrowser.  Modul ini adalah pembungkus lebih dari Guzzle yang memungkinkan Anda untuk berinteraksi dengan aplikasi Anda: membuka halaman, mengisi formulir, mengirimkan formulir.  Dan jika Anda tidak peduli tentang cross-browser dan pengujian browser, jika Anda tiba-tiba menguji UI, Anda dapat menggunakan PhpBrowser.  Sebagai aturan, kami menggunakannya dalam pengujian UI kami, karena kami tidak memerlukan logika interaksi yang rumit, kami hanya perlu membuka halaman dan melakukan sesuatu yang kecil di sana. <br><br>  Modul kedua yang kami gunakan adalah REST.  Saya pikir namanya memperjelas apa yang dia lakukan.  Untuk setiap interaksi http, Anda dapat menggunakan modul ini.  Sepertinya saya bahwa hampir semua interaksi diselesaikan di dalamnya: tajuk, cookie, otorisasi.  Semua yang Anda butuhkan ada di dalamnya. <br><br>  Modul ketiga yang kami gunakan di luar kotak adalah modul Db.  Dalam versi terbaru Codeception, dukungan untuk tidak satu, tetapi beberapa database telah ditambahkan di sana.  Oleh karena itu, jika Anda tiba-tiba memiliki beberapa database di proyek Anda, sekarang ini berfungsi dengan baik. <br><br>  Modul Cli, yang memungkinkan Anda untuk menjalankan perintah <b>shell</b> dan <b>bash</b> dari pengujian, dan kami juga menggunakannya. <br><br>  Ada modul AMQP yang berfungsi dengan pialang pesan apa pun yang didasarkan pada protokol ini.  Saya ingin mencatat bahwa itu secara resmi diuji di RabbitMQ.  Karena kami menggunakan RabbitMQ, semuanya baik-baik saja dengannya. <br><br>  Bahkan, Codeception, setidaknya dalam kasus kami, mencakup 80-85% dari semua tugas yang kita butuhkan.  Tetapi saya masih harus mengerjakan sesuatu. <br><br>  Mari kita mulai dengan SABUN. <br><img src="https://habrastorage.org/webt/c9/zy/bk/c9zybkm3eu-kvkxc_uvpcte_h0u.jpeg" alt="gambar"><br><br>  Dalam layanan kami, di beberapa tempat ada titik akhir SOAP.  Mereka perlu diuji, ditarik, ada hubungannya dengan mereka.  Tetapi Anda akan mengatakan bahwa dalam Codeception ada modul seperti itu yang memungkinkan Anda mengirim permintaan dan kemudian melakukan sesuatu dengan jawabannya.  Entah bagaimana untuk menguraikan, tambahkan cek dan semuanya OK.  Tetapi modul SOAP tidak bekerja di luar kotak dengan beberapa titik akhir SOAP. <br><img src="https://habrastorage.org/webt/uj/s_/zv/ujs_zvshqpzmecycdggm3mys4nq.jpeg" alt="gambar"><br><br>  Sebagai contoh, kami memiliki monolit yang memiliki beberapa WSDL, beberapa titik akhir SOAP.  Ini berarti bahwa tidak mungkin dalam modul Codeception untuk mengkonfigurasi ini dalam file yml sehingga dapat berfungsi dengan beberapa. <br><img src="https://habrastorage.org/webt/uc/z-/ab/ucz-abgapgah_r9qo6uoitkstg8.jpeg" alt="gambar"><br><br>  Codeception memiliki konfigurasi ulang modul dinamis, dan Anda dapat menulis beberapa jenis adaptor Anda untuk menerima, misalnya, modul SOAP dan mengkonfigurasi ulang secara dinamis.  Dalam hal ini, perlu untuk mengganti titik akhir dan skema yang digunakan.  Kemudian dalam pengujian, jika Anda perlu mengubah titik akhir yang ingin Anda kirimi permintaan, kami mendapatkan adaptor kami dan mengubahnya ke titik akhir yang baru, ke sirkuit baru dan mengirimkan permintaan ke sana. <br><img src="https://habrastorage.org/webt/68/iu/kl/68iuklk2oherxt4ov7odgrszyli.jpeg" alt="gambar"><br><br>  Dalam Codeception, tidak ada pekerjaan dengan Kafka dan tidak ada tambahan pihak ketiga yang kurang lebih resmi untuk bekerja dengan Kafka.  Tidak ada yang perlu dikhawatirkan, kami menulis modul kami. <br><img src="https://habrastorage.org/webt/es/gp/eg/esgpegswio_kwmtqer7gkqvjfgi.jpeg" alt="gambar"><br><br>  Jadi itu dikonfigurasi dalam file yml.  Beberapa pengaturan ditetapkan untuk broker, untuk konsumen dan untuk topik.  Pengaturan ini, ketika Anda menulis modul Anda, Anda kemudian dapat menariknya ke dalam modul dengan fungsi inisialisasi dan inisialisasi modul ini dengan pengaturan yang sama.  Dan, pada kenyataannya, modul memiliki semua metode lain untuk diterapkan - letakkan pesan dalam topik dan bacalah.  Hanya itu yang Anda butuhkan dari modul ini. <br><img src="https://habrastorage.org/webt/zo/5p/bo/zo5pbox8a8xxic2n8972phohhd0.jpeg" alt="gambar"><br><br>  <b>Kesimpulan</b> : modul untuk Codeception mudah ditulis. <br><br>  Silakan.  Seperti yang saya katakan, Codeception memiliki modul Cli - pembungkus untuk perintah <i>shell</i> dan bekerja dengan output mereka. <br><img src="https://habrastorage.org/webt/8c/gg/yr/8cggyrxinincflxsx2ti3o4klwq.jpeg" alt="gambar"><br><br>  Tetapi kadang-kadang perintah <i>shell</i> perlu dijalankan bukan dalam tes, tetapi dalam aplikasi.  Secara umum, tes dan aplikasi adalah entitas yang sedikit berbeda, mereka dapat terletak di tempat yang berbeda.  Tes dapat dijalankan di satu tempat, dan aplikasi mungkin di tempat lain. <br><br>  Jadi mengapa kita perlu menjalankan <i>shell</i> di tes? <br><br>  Kami memiliki perintah dalam aplikasi yang, misalnya, mengurai antrian di RabbitMQ dan memindahkan objek berdasarkan status.  Perintah-perintah ini dalam mode pro diluncurkan dari bawah supervisor.  Pengawas memantau implementasinya.  Jika mereka jatuh, maka dia mulai lagi dan seterusnya. <br><br>  Saat kami uji, supervisor tidak berjalan.  Jika tidak, tes menjadi tidak stabil, tidak dapat diprediksi.  Kami sendiri ingin mengontrol peluncuran perintah ini di dalam aplikasi.  Oleh karena itu, kita perlu menjalankan perintah ini dari pengujian di aplikasi.  Kami menggunakan dua opsi.  Yang satu itu, yang lain - pada prinsipnya, semuanya sama, dan semuanya berfungsi. <br><br>  Bagaimana cara menjalankan <i>shell</i> dalam suatu aplikasi? <br><br>  Pertama: jalankan tes di tempat yang sama di mana aplikasi berada.  Karena semua aplikasi yang kami miliki di Docker, pengujian dapat dijalankan dalam wadah yang sama di mana layanan itu sendiri berada. <br><br>  Opsi kedua: buat wadah terpisah untuk pengujian, beberapa <i>pelari ujian</i> , tetapi buatlah sama dengan aplikasi.  Yaitu, dari gambar Docker yang sama, dan kemudian semuanya akan bekerja sama. <br><img src="https://habrastorage.org/webt/wm/hw/g0/wmhwg0-0xviw0be73xgrwfppsfi.jpeg" alt="gambar"><br><br>  Masalah lain yang kami temui dalam pengujian adalah bekerja dengan berbagai sistem file.  Di bawah ini adalah contoh dari apa yang dapat dan harus Anda kerjakan.  Tiga yang pertama relevan bagi kita.  Ini adalah Webdav, SFTP, dan sistem file Amazon. <br><br>  Dengan apa Anda perlu bekerja? <br><br><ol><li>  Webdav </li><li>  FTP / SFTP </li><li>  AWS S3 </li><li>  Lokal </li><li>  Azure, Dropbox, google drive </li></ol><br>  Jika Anda mencari-cari melalui Codeception, Anda dapat menemukan beberapa modul untuk hampir semua sistem file yang kurang lebih populer. <br><br><img src="https://habrastorage.org/webt/84/kr/ol/84krold4wqwi4ckxe4trmr8u9oq.jpeg" alt="gambar"><br><br>  Satu-satunya hal yang saya tidak temukan adalah untuk WebDAV.  Tetapi sistem file ini, plus atau minus, sama dalam hal pekerjaan eksternal dengan mereka, dan kami ingin bekerja dengan mereka dengan cara yang sama. <br><br>  Kami menulis modul kami yang disebut Flysystem.  Itu terletak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> di domain publik dan mendukung 2 sistem file - SFTP dan Webdav - dan memungkinkan Anda untuk bekerja dengan keduanya menggunakan API yang sama. <br><img src="https://habrastorage.org/webt/5a/w5/sm/5aw5smemb1fabsbsyvt5eit70r8.jpeg" alt="gambar"><br><br>  Dapatkan daftar file, bersihkan direktori, tulis file, dan sebagainya.  Jika Anda juga menambahkan sistem file Amazon di sana, kebutuhan kami pasti akan tercakup. <br><br>  Poin berikutnya, saya pikir, sangat penting untuk autotest, terutama tingkat sistem, bekerja dengan basis data.  Secara umum, saya ingin, seperti pada gambar, - VZHUH dan semuanya dimulai, berfungsi, dan database ini harus kurang didukung dalam tes. <br><img src="https://habrastorage.org/webt/hb/-y/ul/hb-yulyfmetwazoatr4oukazpli.jpeg" alt="gambar"><br><br>  Apa tugas utama yang saya lihat di sini: <br><br><ol><li>  Cara menggelar basis data struktur yang diinginkan - Db </li><li>  Cara mengisi database dengan data uji - Db, Jadwal </li><li>  Cara membuat pilihan dan memeriksa - Db </li></ol><br>  Untuk semua 3 tugas dalam Codeception, ada 2 modul - Db, yang sudah saya bicarakan, yang lain disebut Fixtures. <br><br>  Dari 2 modul dan 3 tugas ini, kami hanya menggunakan DB untuk tugas ketiga. <br><br>  Untuk tugas pertama, Anda bisa menggunakan DB.  Di sana Anda dapat mengkonfigurasi dump SQL dari mana database akan digunakan, baik, modul dengan perlengkapan, saya pikir jelas mengapa itu diperlukan. <br><br>  Akan ada perlengkapan dalam bentuk array yang dapat disimpan ke dalam basis data. <br><br>  Seperti yang saya katakan, 2 tugas pertama yang kami selesaikan sedikit berbeda, sekarang saya akan memberi tahu Anda bagaimana kami melakukannya. <br><br>  <b>Penempatan basis data</b> <br><br><ol><li>  Meningkatkan wadah dengan PostgreSQL atau MySQL </li><li>  Kami menggulung semua migrasi dengan migrasi doktrin </li></ol><br>  Yang pertama adalah tentang menggunakan basis data.  Bagaimana ini terjadi dalam tes.  Kami menaikkan wadah dengan database yang diinginkan - baik PostgreSQL atau MySQL, lalu gulung semua migrasi yang diperlukan menggunakan <i>migrasi doktrin</i> .  Semuanya, database dari struktur yang diinginkan sudah siap, dapat digunakan dalam tes. <br><br>  Mengapa kami tidak menggunakan peredam - karena itu tidak perlu didukung.  Ini adalah semacam dump yang terletak pada tes, yang perlu terus diperbarui jika ada perubahan dalam database.  Ada migrasi - tidak perlu mengelola dump. <br><br>  Poin kedua adalah pembuatan data uji.  Kami tidak menggunakan modul Fixtures dari Codeception, kami menggunakan bundel <i>Symfony</i> untuk fixture. <br><img src="https://habrastorage.org/webt/kx/lf/m9/kxlfm9zppbdqmgj_i_ekaripjw4.jpeg" alt="gambar"><br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke sana dan contoh bagaimana Anda bisa membuat fixture dalam database. <br><br>  Fixture Anda kemudian akan dibuat sebagai beberapa objek domain, dapat disimpan dalam database, dan data uji akan siap. <br><br>  Mengapa DoctrineFixtureBundle? <br><br><ol><li>  Lebih mudah untuk membuat rantai benda terkait. </li><li>  Lebih sedikit duplikasi data jika perlengkapan untuk tes yang berbeda serupa. </li><li>  Lebih sedikit pengeditan saat mengubah struktur basis data. </li><li>  Kelas fixture jauh lebih visual daripada array. </li></ol><br>  Mengapa kita menggunakannya?  Ya, untuk alasan yang sama - perlengkapan ini jauh lebih mudah dirawat daripada perlengkapan dari Codeception.  Lebih mudah untuk membuat rantai benda terkait, karena semuanya ada dalam bundel symfony.  Lebih sedikit data yang perlu digandakan, karena fixture dapat diwarisi, ini adalah kelas.  Jika struktur database berubah, array ini selalu perlu diedit, dan kelas tidak selalu.  Perlengkapan dalam bentuk objek domain selalu lebih terlihat daripada array. <br><br>  Kami berbicara tentang database, mari kita bicara sedikit tentang moki. <br><br>  Karena ini adalah tes dari tingkat yang cukup tinggi yang menguji seluruh sistem dan karena sistem kami sangat saling berhubungan, jelas bahwa ada beberapa pertukaran dan interaksi.  Sekarang kita akan berbicara tentang mokeys tentang interaksi antar sistem. <br><br>  <b>Aturan untuk mok</b> <br><br><ol><li>  Menangis semua interaksi layanan http eksternal </li><li>  Memeriksa tidak hanya skenario positif, tetapi juga negatif </li></ol><br>  Interaksi adalah beberapa interaksi REST atau SOAP http.  Semua interaksi ini dalam kerangka tes yang kita ngompol.  Artinya, dalam pengujian kami tidak ada daya tarik nyata untuk sistem eksternal di mana saja.  Ini membuat tes stabil.  Karena layanan eksternal dapat bekerja, mungkin tidak berfungsi, dapat merespons dengan lambat, mungkin dengan cepat, secara umum, tidak tahu apa perilakunya.  Karena itu, kami menutup semuanya dengan moks. <br><br>  Kami juga punya aturan seperti itu.  Kami tidak hanya membasahi interaksi positif, tetapi juga mencoba memeriksa beberapa kasus negatif.  Misalnya, ketika layanan pihak ketiga merespons dengan kesalahan ke-500 atau menghasilkan beberapa kesalahan yang lebih bermakna, kami mencoba memeriksa semuanya. <br><br>  Kami menggunakan Wiremock untuk mengejek, Codeception sendiri mendukung ..., ia memiliki add-on resmi seperti Httpmock, tetapi kami lebih menyukai Wiremock.  Bagaimana cara kerjanya? <br><br><br><br>  Wiremock naik sebagai wadah Docker terpisah selama pengujian, dan semua permintaan yang harus pergi ke sistem eksternal pergi ke Wiremock. <br><br><img src="https://habrastorage.org/webt/n9/cb/y8/n9cby8a1hoiicw5fqprvzsfxsae.jpeg" alt="gambar"><br><br>  Wiremock, jika Anda melihat slide - ada kotak seperti itu, Pemetaan Permintaan, ia memiliki seperangkat pemetaan yang mengatakan bahwa jika permintaan seperti itu datang, Anda perlu memberikan jawaban seperti itu.  Semuanya sangat sederhana: permintaan datang - menerima tiruan. <br><br>  Mengolok-olok dapat dibuat secara statis, maka wadah, ketika sudah dengan Wiremock naik, mengolok-olok ini akan tersedia, mereka dapat digunakan dalam pengujian manual.  Anda dapat membuat secara dinamis, tepat di kode, dalam beberapa jenis tes. <br><br>  Berikut ini adalah contoh cara membuat tiruan secara dinamis, Anda tahu, uraiannya cukup deklaratif, segera jelas dari kode jenis tiruan yang kita buat: tiruan untuk metode GET yang datang ke URL seperti itu, dan, pada kenyataannya, apa yang harus dikembalikan. <br><br><img src="https://habrastorage.org/webt/d7/xu/2g/d7xu2gg75_-vjff1ejruhj2dvba.jpeg" alt="gambar"><br><br>  Selain fakta bahwa tiruan ini dapat dibuat, Wiremock memiliki kesempatan kemudian untuk memeriksa permintaan mana yang masuk ke tiruan ini.  Ini juga sangat berguna dalam tes. <br><br>  Tentang Codeception itu sendiri, mungkin, segalanya, dan beberapa kata tentang bagaimana pengujian kami dijalankan, dan sedikit infrastruktur. <br><br>  Apa yang kita gunakan <br><br><img src="https://habrastorage.org/webt/qy/my/hj/qymyhjaocwm0apzi7orjlot7hnw.jpeg" alt="gambar"><br><br>  Yah, pertama, semua layanan yang kami miliki di Docker, jadi meluncurkan lingkungan pengujian meningkatkan wadah yang tepat. <br><br>  Make digunakan untuk perintah internal, Bamboo digunakan sebagai CI. <br><br>  Seperti apa tampilan uji CI? <br><br><img src="https://habrastorage.org/webt/hb/iq/jf/hbiqjftacif8wg-67x666c7l5yc.jpeg" alt="gambar"><br><br>  Pertama, kami membangun versi aplikasi yang diinginkan, kemudian kami meningkatkan lingkungan - ini adalah aplikasi, semua layanan yang dibutuhkan, seperti Kafka, Kelinci, basis data, dan kami memutar migrasi ke basis data. <br><br>  Semua lingkungan ini dimunculkan dengan bantuan Docker Compose.  Berada di CI, pada prod bahwa semua kontainer berputar di bawah Kubernetes.  Kemudian jalankan tes dan jalankan. <br><br>  Berapa lama waktu yang dibutuhkan? <br><br>  Itu semua tergantung pada layanan spesifik, tetapi, sebagai suatu peraturan, meningkatkan lingkungan sebelum menjalankan tes adalah 5-10 menit, tes - dari 6 hingga 30 menit. <br><br><img src="https://habrastorage.org/webt/nm/kh/n0/nmkhn0sdps-qtoowra4mrtgtu8m.jpeg" alt="gambar"><br><br>  Saya akan segera memperingatkan pertanyaan ini saat semua tes mengejar dalam satu utas. <br><br>  Nah, pertanyaan seperti itu.  Seberapa sering tes harus dijalankan?  Tentu saja, semakin sering, semakin baik.  Semakin cepat Anda menangkap masalah, semakin cepat Anda bisa menyelesaikannya. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki 2 aturan utama. </font><font style="vertical-align: inherit;">Ketika tugas masuk ke pengujian, semua tes, baik unit dan bukan unit tes, harus diteruskan. </font><font style="vertical-align: inherit;">Jika beberapa tes gagal, ini adalah kesempatan untuk mentransfer tugas untuk diperbaiki. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wajar bila kami meluncurkan rilisnya. </font><font style="vertical-align: inherit;">Pada rilis, semua tes harus lulus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, saya ingin mengatakan sesuatu yang menginspirasi - menulis tes, biarkan mereka menjadi hijau, gunakan Codeception, buat moki. </font><font style="vertical-align: inherit;">Saya pikir Anda semua mengerti ini.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452136/">https://habr.com/ru/post/id452136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452124/index.html">â€œKita perlu lapar akan pengetahuan dan prestasiâ€ - bagaimana rasanya menjadi penguji di Alfa-Bank</a></li>
<li><a href="../id452128/index.html">Kesalahpahaman populer tentang resistensi radiasi dari sirkuit mikro</a></li>
<li><a href="../id452130/index.html">Bulan menyusut, menyebabkan gempa bulan</a></li>
<li><a href="../id452132/index.html">Jalur Freelancer</a></li>
<li><a href="../id452134/index.html">Bagaimana semuanya dimulai: sejarah besi solder dan munculnya alat-alat modern</a></li>
<li><a href="../id452138/index.html">13. Periksa Titik Memulai R80.20. Perizinan</a></li>
<li><a href="../id452140/index.html">Mengapa CFO beralih ke model biaya operasional di TI</a></li>
<li><a href="../id452142/index.html">Bagaimana kita berurusan dengan menyalin konten, atau serangan permusuhan pertama di prod</a></li>
<li><a href="../id452146/index.html">Jadi apa yang akan terjadi dengan otentikasi dan kata sandi? Bagian 2 dari Laporan Status Otentikasi Kuat Javelin</a></li>
<li><a href="../id452152/index.html">Solusi apa yang dimiliki Rostelecom untuk IIoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>