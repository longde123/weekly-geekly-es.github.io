<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿 👨‍👨‍👧‍👧 🚥 Menulis Perilaku Vertikal Fleksibel 🔊 🚱 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Ilya Osintsev, saya adalah pengembang Android di Apiqa. Di bawah kucing Anda akan menemukan contoh menggunakan ViewDragHelper un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis Perilaku Vertikal Fleksibel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481910/"><p>  Halo, Habr!  Nama saya Ilya Osintsev, saya adalah pengembang Android di Apiqa.  Di bawah kucing Anda akan menemukan contoh menggunakan ViewDragHelper untuk membuat komponen antarmuka pengguna yang mirip dengan SwipeDismissBehavior, tetapi bekerja secara vertikal. </p><br><p>  Dengan munculnya Desain Material, aplikasi telah menjadi elemen yang lebih interaktif yang merespons tindakan pengguna.  Mereka tidak hanya menghemat ruang, tetapi juga memperkenalkan interaksi mikro yang menyenangkan.  Di beberapa proyek kami, kami memutuskan untuk menggunakan spanduk yang bergerak secara vertikal pada mekanik gesek-untuk-pemberhentian.  Untuk memberikan keaktifan pada antarmuka, spanduk harus memperhitungkan kecepatan pointer dan mengubah transparansi tergantung pada arah offset. </p><a name="habracut"></a><br>
<h2 id="ocenivaem-zadachu">  Mengevaluasi tugas </h2><br><div class="scrollable-table"><table><thead><tr><th>  Akun pribadi </th><th>  Teknisi Kabinet </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/webt/au/bz/ma/aubzmap7axgperiid2fkvvttt20.jpeg" alt="Akun pribadi"></td><td><img src="https://habrastorage.org/webt/c6/n6/ox/c6n6oxsscnhr7elqtgullowpjte.jpeg" alt="Teknisi Kabinet"></td></tr></tbody></table></div><br><p>  Dalam aplikasi <a href="https://apiqa.io/case_pik_app">Akun Pribadi</a> kami <a href="https://apiqa.io/case_pik_app">,</a> spanduk bertindak sebagai cara cepat untuk meninggalkan banding ke layanan pencarian penyewa untuk rumah Anda.  Dalam aplikasi "Alat Kabinet", spanduk memungkinkan Anda untuk menyimpan konteks pekerjaan pengguna dengan tugas saat beralih dari kartu informasi ke komentar.  Dalam kasus pertama, kami menekankan opsionalitas layanan PIK-Rent dan membiarkan klien merasa betah dalam aplikasi.  Dalam kasus lain, kami menerapkan gesek saat diminta sehingga tidak tumpang tindih baris pesan antara pengirim dan pelaksana. </p><br><p>  Untuk memulai, saya mengumpulkan demo sederhana berdasarkan SwipeDismissBehavior untuk mempelajari cara kerjanya dan memperkirakan skala perubahan.  Mencoba untuk menentukannya di markup xml melempar pengecualian ketika dieksekusi: </p><br><pre><code class="plaintext hljs">E/AndroidRuntime: FATAL EXCEPTION: main Process: io.apiqa.android.example, PID: 1024 android.view.InflateException: Binary XML file line #115: Could not inflate Behavior subclass com.google.android.material.behavior.SwipeDismissBehavior</code> </pre> <br><p>  Pengembang melanggar kontrak Perilaku dan lupa untuk menimpa konstruktor <a href="">kelas</a> dari konteks dan AttributeSet.  Sekarang Anda dapat menggunakan perilaku ini hanya dengan membuat instance dari hal itu dalam kode Anda, tetapi bahkan kemudian, perilaku tampilan secara fundamental tidak memenuhi persyaratan kami, bahkan tanpa memperhitungkan arah horizontal. </p><br><p><img src="https://habrastorage.org/webt/sb/ud/5b/sbud5byhw9ufcoj7hpqdjg2lcbq.gif" alt="SwipeDismissBehavior di luar kotak"></p><br><p>  Ada pesan di log aplikasi demo yang menyatakan bahwa beberapa peristiwa sentuh tidak jatuh ke handler. </p><br><blockquote>  E / ViewDragHelper: Mengabaikan pointerId = -1 karena ACTION_DOWN tidak diterima untuk pointer ini sebelum ACTION_MOVE.  Ini mungkin terjadi karena ViewDragHelper tidak menerima semua acara di aliran acara. </blockquote><p>  Sebagai alternatif, ada solusi yang didasarkan pada <code>OnTouchListener</code> , ini memberi kita kesempatan untuk menggunakan OnClickListener, yang berarti kita harus menggambarkan hukum pergerakan spanduk dalam aktivitas.  Kami tidak ingin mengubah parameter gerakan (misalnya, sensitivitas) saat kami bergerak, dan menggunakan OnTouchListener di sini tampaknya berlebihan.  Selain itu, di kedua proyek kami spanduk ditempatkan di CoordinatorLayout. </p><br><p>  Jika Anda tidak memperhitungkan getter dan setter dari parameter opsional, SwipeDismissBehavior itu sendiri cukup pendek, ia menggunakan <code>ViewDragHelper</code> .  Saya menemukan <a href="https://medium.com/android-development-p-ractises/dragging-panel-with-viewdraghelper-6df8dd980082">beberapa</a> <a href="https://newfivefour.com/android-viewdraghelper-example-tutorial.html">publikasi</a> tentang dia di jaringan dan memutuskan untuk menulis sendiri implementasi komponen yang diperlukan. </p><br><h2 id="koordiniruem-s-viewdraghelper">  Kami berkoordinasi dengan ViewDragHelper </h2><br><p>  <a href="https://developer.android.com/reference/androidx/customview/widget/ViewDragHelper.html">ViewDragHelper</a> adalah kelas utilitas untuk memfasilitasi dukungan seret &amp; lepas di tingkat Tampilan.  Ini melacak posisi widget dan berisi beberapa fungsi yang berguna untuk menjiwainya sepanjang satu atau dua sumbu di dalam induk ViewGroup.  Untuk bekerja, ia membutuhkan penangan yang mengimplementasikan <a href="https://developer.android.com/reference/androidx/customview/widget/ViewDragHelper.Callback.html">ViewDragHelper.Callback</a> .  Pawang memiliki satu metode wajib, dan agar spanduk mulai bergerak, cukup untuk mendefinisikan kembali beberapa.  Secara umum, helper ini mudah digunakan, tersedia di proyek apa pun, karena dilengkapi dengan appcompat.  Untuk membuat pembantu, diperlukan referensi ke induk CoordinatorLayout, jadi kami akan mengatur inisialisasi malas.  Di <code>onInterceptTouchEvent</code> dan <code>onTouchEvent</code> kita harus memanggil metode pembantu yang sesuai, sisa logika akan berada di dalam handler. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerticalSwipeBehavior</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V: View</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CoordinatorLayout.Behavior</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;V: View&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">V</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: VerticalSwipeBehavior&lt;V&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lp = v.layoutParams require(lp <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CoordinatorLayout.LayoutParams) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> behavior = lp.behavior requireNotNull(behavior) require(behavior <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VerticalSwipeBehavior) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> behavior <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VerticalSwipeBehavior&lt;V&gt; } } <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"unused"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"unused"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(context: Context, attrs: AttributeSet) : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dragHelper: ViewDragHelper? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interceptingEvents = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInterceptTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CoordinatorLayout</span></span></span></span><span class="hljs-function"><span class="hljs-params">, child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">V</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ev: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MotionEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isIntercept = interceptingEvents <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (ev.actionMasked) { MotionEvent.ACTION_DOWN -&gt; { isIntercept = parent.isPointInChildBounds(child, ev.x.toInt(), ev.y.toInt()) interceptingEvents = isIntercept } MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; { interceptingEvents = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntercept) { helper(parent).shouldInterceptTouchEvent(ev) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CoordinatorLayout</span></span></span></span><span class="hljs-function"><span class="hljs-params">, child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">V</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ev: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MotionEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> helper = helper(parent) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isViewUnder = helper.isViewUnder(child, ev.x.toInt(), ev.y.toInt()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (helper.capturedView == child || isViewUnder ) { helper.processTouchEvent(ev) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ViewDragHelper { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> h = dragHelper <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { h = ViewDragHelper.create(parent, callback) dragHelper = h <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h } }</code> </pre> <br><p>  Dalam metode <code>tryCaptureView</code> handler yang diperlukan <code>tryCaptureView</code> kita harus memutuskan apakah akan memindahkan tampilan tertentu.  Agar helper tidak ketinggalan peristiwa yang diperlukan, kami mengakui pointer yang diterima sebelumnya.  Untuk mendapatkan solusi paling fleksibel, tiga antarmuka tambahan diperkenalkan, di mana Anda dapat mengontrol desain banner secara detail: </p><br><ul><li>  <code>SideEffect</code> mencerminkan kemajuan <code>SideEffect</code> di properti tampilan </li><li>  <code>VerticalClamp</code> dirancang untuk membatasi pergerakan tampilan secara vertikal </li><li>  <code>PostAction</code> dipanggil setelah pengguna menghentikan swipe, di sini kita dapat melanjutkan gerakan tampilan. </li></ul><br><p>  Di masing-masing dari mereka, metode <code>onViewCaptured(View)</code> , di sini implementasi klien dapat mengekstraksi nilai awal dari properti tampilan.  Urutan panggilan ke metode ini tidak dijamin. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideEffect: SideEffect = AlphaElevationSideEffect() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clamp: VerticalClamp = FractionConstraintWithTopMargin(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settle: PostAction = OriginSettleAction() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> callback = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: ViewDragHelper.Callback() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INVALID_POINTER_ID = -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentPointer = INVALID_POINTER_ID <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> originTop: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryCaptureView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pointerId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPointer == INVALID_POINTER_ID || pointerId == currentPointer } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCaptured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, activePointerId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { originTop = child.top currentPointer = activePointerId sideEffect.onViewCaptured(child) settle.onViewCaptured(child) clamp.onViewCaptured(child.top) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewReleased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xvel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, yvel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO currentPointer = INVALID_POINTER_ID } override fun clampViewPositionHorizontal(child: View, left: Int, dx: Int) = child.left // TODO }</span></span></code> </pre> <br><p>  Meskipun pandangan kami tidak bergerak secara vertikal, kita harus ingat untuk mengimplementasikan <code>clampViewPositionHorizontal</code> di handler untuk menghindari bug visual.  Implementasi sederhana mengembalikan koordinat kiri, yang berarti bahwa widget tidak bergerak secara horizontal. </p><br><p>  Dalam kasus kami, panggilan ke handler <code>clampViewPositionVertical</code> didelegasikan ke antarmuka <em>VerticalClamp</em> .  Metode <code>constraint</code> harus mengembalikan koordinat ketinggian yang dibatasi oleh posisi tampilan maksimum dan / atau minimum.  Ketika sudah tercapai, ViewDragHelper akan membatasi pergerakan.  Metode <code>upCast(distance, top, height, dy)</code> dan <code>downCast</code> memiliki tanda tangan yang sama dan mengembalikan sebagian kecil dari jarak yang ditempuh, dengan mempertimbangkan posisi awal tampilan.  Dalam <code>onViewPositionChanged</code> penangan <code>onViewPositionChanged</code> kami mendapatkan progres pemindahan dan meneruskannya ke <code>SideEffect#apply(View, Float)</code> , di mana Anda dapat mengubah transparansi atau properti tampilan lainnya tergantung pada kemajuan gerakan.  Jika posisi tampilan saat ini lebih tinggi dari awal, maka progres ditransmisikan dengan tanda minus. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clampViewPositionVertical</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, top: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dy: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp.constraint(child.height, top, dy) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewPositionChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, left: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, top: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dx: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dy: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factor = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (top &lt; originTop) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diff = originTop - top -clamp.bottomCast(diff, top, child.height, dy) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diff = top - originTop clamp.topCast(diff, top, child.height, dy) } sideEffect.apply(child, factor) }</code> </pre> <br><p>  Secara default, <code>FractionClamp</code> digunakan, yang membatasi pergerakan tampilan satu ketinggian ke atas dan ke bawah (koefisien diatur dalam konstruktor), <code>AlphaElevationSideEffect</code> mengubah transparansi dan ketinggian spanduk.  Untuk mempertimbangkan tugas selesai, Anda harus menambahkan kemampuan untuk memindahkan banner setelah pengguna merilisnya. </p><br><p>  Saat pengguna melepaskan tampilan, helper akan mengingat kecepatan pointer dan memanggil <code>onViewReleased</code> pada handler.  Di dalamnya, kita dapat memulai animasi gerakan menggunakan <code>settleCapturedViewAt</code> atau <code>smoothSlideViewTo</code> .  Menurut kontrak, setelah panggilan yang berhasil dari mereka, <code>continueSettling</code> harus dipanggil pada setiap frame berikutnya sehingga pandangan terus bergerak.  Dalam kasus ini, <em>settleCapturedViewAt</em> hanya dapat dipanggil dari metode onViewReleased ketika flag internal <em>helper</em> mReleaseInProgress disetel ke true.  Perbedaan lainnya adalah <em>smoothSlideViewTo</em> tidak memperhitungkan kecepatan pointer. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewReleased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xvel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, yvel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diff = child.top - originTop <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(yvel) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> settled = dragHelper?.let { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { settle.releasedBelow(it, diff, child) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { settle.releasedAbove(it, diff, child) } } ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (settled) { listener?.onPreSettled(diff) child.postOnAnimation(RecursiveSettle(child, diff)) } } currentPointer = INVALID_POINTER_ID }</code> </pre> <br><p>  Logika ini diringkas dalam antarmuka <code>PostAction</code> .  Metode <code>releasedAbove</code> dan <code>releasedBelow</code> dapat diimplementasikan sehingga ketika digeser ke atas, spanduk terus bergerak dengan kecepatan yang sama, meninggalkan layar, dan ketika digeser ke bawah, ia kembali ke posisi semula.  Jika salah satu metode mengembalikan true, maka animasi telah dipicu dan RecursiveSettle ditambahkan ke antrian acara tampilan, yang akan tetap di dalamnya sampai animasi selesai.  Secara default, <code>OriginSettleAction</code> digunakan ketika tampilan pada offset apa pun kembali ke titik awal.  Pilihan lain - <code>SettleOnTopAction</code> saat memindahkan tampilan turun mengembalikannya ke titik awal, dan ketika bergerak lebih tinggi itu membawa Anda keluar dari layar. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SettleOnTopAction</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> originTop: Int = -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCaptured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child: View)</span></span></span><span class="hljs-function"> </span></span>{ originTop = child.top } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releasedAbove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(helper: ViewDragHelper, child: View)</span></span></span><span class="hljs-function">: Boolean </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> helper.settleCapturedViewAt(child.left, originTop) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releasedBelow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(helper: ViewDragHelper, child: View)</span></span></span><span class="hljs-function">: Boolean </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> helper.settleCapturedViewAt(child.left, -child.height) } }</code> </pre> <br><p>  Jika perlu, Anda dapat berlangganan acara dengan mengimplementasikan antarmuka <code>VerticalSwipeBehavior.SwipeListener</code> .  Ini memiliki dua metode simetris, satu dipanggil sebelum dimulainya animasi bergerak, yang lain setelah itu berakhir.  Argumen menunjukkan arah dan jarak di mana pengguna merilis spanduk.  Hasil yang dihasilkan memenuhi persyaratan kami. </p><br><p><img src="https://habrastorage.org/webt/fw/er/9e/fwer9eaidf1vlmzsym0wyygdbvm.gif" alt="Hasil yang dihasilkan"></p><br><p>  Untuk mendapatkan hasilnya, cukup mendefinisikan properti sebagai berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> drag = findViewById&lt;View&gt;(R.id.drag) VerticalSwipeBehavior.from(drag).apply { settle = SettleOnTopAction() sideEffect = NegativeFactorFilterSideEffect(AlphaElevationSideEffect()) clamp = BelowFractionalClamp() }</code> </pre> <br><p>  Omong-omong, helper juga menyediakan fitur kontrol gerak lainnya.  Misalnya, menggunakan metode <code>setMinVelocity(Float)</code> , Anda dapat membatasi kecepatan minimum agar tampilan dapat dipindahkan.  Helper juga mendukung pengenalan gesekan dari batas layar, untuk ini Anda perlu menentukannya dalam metode <code>setEdgeTrackingEnabled(Int)</code> .  Harus diingat bahwa satu instance dari ViewDragHelper dapat mengontrol pergerakan hanya satu tampilan dan hanya memperhitungkan satu pointer. </p><br><h2 id="delaem-vyvody">  Buat kesimpulan </h2><br><p>  Pengalaman saya adalah ViewDragHelper membuatnya mudah untuk membuat drag &amp; drop atau memindahkan panel dalam suatu aplikasi.  Helper mudah digunakan di Behavior atau ViewGroup yang ditimpa.  Ini memiliki beberapa metode yang berguna untuk menggerakkan tampilan dan mengontrol gerakan mereka.  Mempelajari implementasi internal komponen Desain Bahan adalah pengalaman yang baik dalam karier pengembang Android.  Tugas-tugas seperti dari desainer memotivasi saya untuk mengeksplorasi pendekatan baru untuk membangun antarmuka aplikasi dan berbagi pengetahuan dengan rekan kerja dan masyarakat. </p><br><p>  Anda dapat menggunakan pustaka yang dihasilkan dalam proyek Anda.  Untuk mengaktifkannya, tentukan dependensi dalam file <code>build.gradle</code> </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'io.apiqa.android:verticalswipebehavior:1.0.0' }</code> </pre> <br><p>  Untuk tampilan yang sesuai di dalam CoordinatorLayout, tentukan properti <code>app:layout_behavior="io.apiqa.android.verticalswipe.VerticalSwipeBehavior"</code> di markup.  Anda dapat menempatkan banner di dalam induk menggunakan indentasi.  Dengan mengoordinasikan <em>implementasi SideEffect</em> , <em>VerticalClamp,</em> dan <em>PostAction,</em> Anda dapat mencapai perilaku banner yang Anda butuhkan.  Di <a href="https://github.com/pik-software/android-verticalSwipeBehavior">repositori</a> , tersedia versi masing-masing yang berfungsi. </p><br><p>  <em>Selamat Tahun Baru!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481910/">https://habr.com/ru/post/id481910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481896/index.html">PHP Vs ASP.NET: Bagaimana Memilih Yang Tepat?</a></li>
<li><a href="../id481898/index.html">Server web sederhana untuk SPA / PWA dalam 5 menit</a></li>
<li><a href="../id481902/index.html">Memodelkan operasi pembangkit listrik termal nyata untuk mengoptimalkan mode: uap dan matematika</a></li>
<li><a href="../id481904/index.html">Vladimir Marshinin alias mavl: "Panggilan" Jangan menyalin kartu lain "memungkinkan Anda menghindari masalah lisensi OpenStreetMap"</a></li>
<li><a href="../id481906/index.html">Otak Cina, atau membela Spring</a></li>
<li><a href="../id481912/index.html">Seminggu saya bekerja magang di SRE-engineer. Perhatikan melalui mata seorang insinyur perangkat lunak</a></li>
<li><a href="../id481914/index.html">Spring Boot vs Spring MVC vs Spring - Bagaimana mereka membandingkan?</a></li>
<li><a href="../id481916/index.html">Untuk apa tahun 2019 dalam pembangunan diingat?</a></li>
<li><a href="../id481922/index.html">IMaskjs 6 Tahun Baru - Bereaksi Asli, Pipa, ESM</a></li>
<li><a href="../id481924/index.html">Apache Spark, evaluasi malas, dan kueri multi-halaman SQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>