<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 👰🏽 🛌🏼 Offenes Webinar: „SSH / NC / Socat: Tipps und Tricks“ 💔 🙎🏾 📣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle! 

 Nächste Woche starten wir die nächste Linux-Administratorgruppe , in deren Zusammenhang wir eine Reihe von Veranstaltungen durch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Offenes Webinar: „SSH / NC / Socat: Tipps und Tricks“</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/437114/">  Guten Tag an alle! <br><br>  Nächste Woche starten wir die nächste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Administratorgruppe</a> , in deren Zusammenhang wir eine Reihe von Veranstaltungen durchgeführt haben.  Eine davon ist eine offene Lektion zum Thema „SSH / NC / Socat: Tipps &amp; Tricks“.  Darauf erinnerten wir uns, was SSH ist, seine Geschichte und Mission.  Wir haben verschiedene Optionen für die Verwendung untersucht: Remote, lokale Portweiterleitung, sichere Kopie, Socken-Proxy, Reverse-Proxy.  Wir haben die Dienstprogramme nc und socat tatsächlich in einem virtuellen Labor ausprobiert. <br><br>  Das Webinar wurde von dem erfahrenen Systemadministrator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladimir Drozdetsky</a> , einem Infrastrukturentwickler bei letundra.com, exposcan.ru, crispmessenger.com, durchgeführt. <br><br>  Wir machen Sie auf eine detaillierte Beschreibung der vergangenen Veranstaltung aufmerksam. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/n7jxFK9SMsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <b>Erinnern Sie sich, was SSH ist</b> <br><br>  SSH (Secure Shell) ist eine „sichere Shell“, ein Netzwerkprotokoll auf Anwendungsebene.  Sie können damit das Betriebssystem fernsteuern und TCP-Verbindungen tunneln (z. B. um Dateien zu übertragen).  In seiner Funktionalität ähnelt SSH den Protokollen Telnet und rlogin, unterscheidet sich jedoch von diesen, da es den gesamten Datenverkehr einschließlich der übertragenen Kennwörter verschlüsselt.  Die SSH-2-Protokollspezifikation ist in RFC 4251 enthalten. <br><br>  Schauen wir uns die verschiedenen Verwendungen von SSH an, sowohl Standard- als auch Nicht-Standard-Anwendungen.  Der folgende Stand hilft uns dabei: <br><br><img src="https://habrastorage.org/webt/mi/d9/2a/mid92ankvqf8pgggjz7orphgps4.png"><br><br>  Der Stand präsentiert vier virtuelle Maschinen, die sich hinter der Firewall befinden.  Wir werden alle Aktionen von der Node-1-Maschine ausführen. <br><br>  <b>Erstellen eines SSH-Schlüssels</b> <b><br></b> <br>  Um den SSH-Schlüssel verwenden zu können, müssen Sie ihn zuerst erstellen.  Hierfür eignet sich ein spezielles Dienstprogramm, das absolut in jeder Linux-Distribution enthalten ist: <br><br><pre><code class="plaintext hljs">ssh-keygen -t RSA -N otuslinux -f ~/.ssh/otus</code> </pre> <br><ul><li>  -t - welcher Verschlüsselungsalgorithmus verwendet werden soll; </li><li>  -N - Verschlüsselungsschlüssel (ein praktisches Argument, wenn Sie einen Schlüssel ohne Verschlüsselung und Antworten auf verschiedene ssh-keygen-Anforderungen erstellen müssen); </li><li>  -f - in welcher Datei der Schlüssel gespeichert werden soll. </li></ul><br>  <b>SSH-Einstellungen SSH-Server</b> <br><br>  Für weitere Arbeiten müssen Sie die Datei / etc / ssh / sshd_config bearbeiten und den ssh-Server neu starten.  Hier sollten Sie folgende Optionen beachten: <br><br>  <code>RSAAuthentication yes</code> (ob die RSA-Authentifizierung zulässig ist); <br>  <code>PubkeyAuthentication yes</code> (ob die Authentifizierung per Schlüssel zulässig ist); <br>  <code>AuthorizedKeysFile %h/.ssh/authorized_keys</code> (Pfad zum öffentlichen Teil des Schlüssels); <br>  <code>PasswordAuthentication yes</code> (ob die Authentifizierung zulässig ist). <br><br>  Gehen Sie wie folgt vor, um den Schlüssel auf den Server zu kopieren: <br><br>  <code>ssh-copy-id -i /path/to/pub/key user@server</code> (Kopieren Sie den öffentlichen Teil des Schlüssels auf den Remote-Server. Der öffentliche Schlüssel wird entlang des Pfads in die Datei% h / .ssh / autorisierte_Tasten kopiert.) <br><br>  Um den Verschlüsselungsschlüssel beim Herstellen einer Verbindung zu einem Remote-Server nicht jedes Mal erneut einzugeben, können wir ssh-agent verwenden.  Dafür: <br><br>  <code>eval $(ssh-agent -s)</code> (eval ist Teil von POSIX. Die Schnittstelle kann auch eine Shell sein. Der Schlüssel im Agenten wird in entschlüsselter Form gespeichert.) <br><br>  <code>ssh-add ~/.ssh/our_private_key</code> (Fügen Sie einen privaten Schlüssel hinzu). <br><br>  In diesem Fall: <br><br><ul><li>  -i - gibt den Speicherort des öffentlichen Schlüssels an; </li><li>  Benutzer - Benutzername auf dem Remote-Server; </li><li>  Server - IP oder DNS des Zielservers. </li></ul><br>  Um die Verbindung zu einem Remote-Server zu vereinfachen, können wir die Verbindungsparameter in der ssh-Konfigurationsdatei beschreiben, die sich im Pfad ~ / .ssh / config befindet <br><br>  Somit erhalten wir die folgende SSH-Konfigurationsdatei: <br><br><pre> <code class="bash hljs">Host myserver HostName ip/hostname Port 22/??? User username IdentityFile ~/.ssh/id_rsa</code> </pre> <br>  Hier ist alles einfach: <br><br><ul><li>  Host - der Name unserer Verbindung; </li><li>  Hostname - Servername; </li><li>  Port - ssh Port </li><li>  Benutzer - Benutzername; </li><li>  IdentityFile - ssh-Schlüssel. </li></ul><br>  <b>SSH SCP</b> <br><br>  Lass uns weitermachen.  Der einfachste Weg, SSH zu verwenden, besteht darin, die Datei von einem Computer auf die Fernbedienung zu kopieren.  Verwenden Sie dazu das Dienstprogramm SCP (Secure Copy Protocol).  Mit ihm können Sie ein Verzeichnis oder eine Datei von einem lokalen Server auf einen Remote-Server kopieren oder umgekehrt: <br><br>  <code>scp test.txt username@server:/some/directory</code> (Kopieren einer Datei vom lokalen Server auf den Remote-Server). <br>  <code>scp username@server:test.txt /some/directory</code> (Kopieren einer Datei von einem Remote-Server auf einen lokalen). <br>  <code>scp -r dir_name username@server:/some/directory</code> (Kopieren eines Ordners vom lokalen Server auf die Remote). <br><br>  Hier: <br><br><ul><li>  Benutzername - Benutzername; </li><li>  Server - Serveradresse; </li><li>  / some / server - das Verzeichnis, in das wir kopieren; </li><li>  dir_name - Ordnername; </li><li>  -r - rekursiv verwenden. </li></ul><br>  <b>SSH-Tunnel, Proxy</b> <br><br>  Schauen wir uns nun die Möglichkeit an, einen Port mit einer Fernbedienung an den lokalen Computer weiterzuleiten.  Nehmen wir den klassischen Fall als Beispiel, das heißt, ein Haufen, wenn wir einen „bösen Sicherheitsbeamten“ und einen Server mit einer Webanwendung haben, die SSH- und https-Ports in die Welt schauen und wir wirklich eine Verbindung zum MySQL-Server herstellen möchten. <br><br>  Also: <br><br>  <code>ssh -f -N -L 9906:127.0.0.1:3306 user@server</code> (Nur unser Fall mit MySQL) <br><br>  Infolgedessen können wir mit dem MySQL-Client eine Verbindung zum lokalen Port 9906 herstellen und zu unserem "Sicherheitsserver" gelangen. <br><br>  <code>ssh -D 8080 -q -C -N -f servername</code> (Proxy-Verkehr durch SOCKS über Port 8080) <br><br>  Mit diesem Befehl erstellen wir mit ssh einen socks5-Proxyserver.  Um die Leistung zu überprüfen, können wir den folgenden Befehl verwenden: <br><br><pre> <code class="plaintext hljs">curl -x socks5h://server-with-proxy:8080 https://test.domain</code> </pre><br>  Ein klassisches Beispiel für die Portweiterleitung mit ssh ist, wenn sich der Server, zu dem Sie eine Verbindung herstellen möchten, hinter dem nat befindet.  Der folgende Befehl hilft uns, eine Verbindung zu einem solchen Server herzustellen: <br><br>  <code>ssh -f -N -R 2255:localhost:22 username@servername</code> (Weiterleitung von einem Remote-Server an einen lokalen Server). <br><br>  Auf dem Remote-Server wird Port 2255 geöffnet, der für das nat an Port 22 unseres Servers umgeleitet wird.  Um eine Verbindung zu einem solchen Server herzustellen, können wir den folgenden Befehl verwenden: <br><br><pre> <code class="plaintext hljs">ssh -p 2255 username@localhost</code> </pre><br>  Bitte beachten Sie Folgendes: <br><br><ul><li>  -f - sende ssh an den Hintergrund; </li><li>  -N - Führen Sie den Befehl nicht auf dem Remote-Host aus. </li><li>  -L - leitet den lokalen Port weiter (lokaler Port: lokaler Computer: Remote-Port); </li><li>  -R - Port am Remote-Computer; </li><li>  -q - stiller Modus; </li><li>  -D - definiert das lokale dynamische Routing von Ports auf Anwendungsebene; </li><li>  -C - Anforderung zur Datenkomprimierung. </li></ul><br>  <b>Netcat (nc)</b> <br><br>  Unser nächster Stopp ist Netcat, ein Unix-Dienstprogramm, mit dem Sie TCP- und UDP-Verbindungen herstellen, Daten von dort empfangen und übertragen können.  Trotz seiner Nützlichkeit und Einfachheit ist dieses Dienstprogramm in keinem Standard enthalten und wird nicht mit einem Distributionskit geliefert.  Dementsprechend muss es von Hand installiert werden. <br><br>  Eine der interessanten Funktionen von Netcat (nc) ist die Möglichkeit, Ports zu scannen: <br><br>  <code>nc -vn ipaddress 22</code> (Single-Port-Scan); <br>  <code>nc -v ipaddress 10-55</code> (Port Range Scan); <br>  <code>nc -l 4444</code> (Port 4444 öffnen und abhören); <br>  <code>nc servername 4444</code> (wir stellen über den gewünschten Port eine Verbindung zum Server her). <br><br>  Nachdem wir den Port geöffnet und eine Verbindung hergestellt haben, erhalten wir einen kleinen Netzwerk-Chatroom =). <br><br>  Als nächstes betrachten wir die Möglichkeit, Dateien mit dem Dienstprogramm nc zu übertragen.  Dazu hilft uns der folgende Befehl: <br><br> <code>cat test_file | pv -b | nc -l 4444</code>  <code>cat test_file | pv -b | nc -l 4444</code> (öffne den Port und übertrage die Datei über die Pipe dorthin. Das Dienstprogramm pv mit dem Schalter -b wird verwendet, um den Fortschritt der Dateiübertragung in Bytes anzuzeigen.) <br><br> <code>nc servername 4444 | pv -b &gt; filename</code>  <code>nc servername 4444 | pv -b &gt; filename</code> (wir stellen eine Verbindung zum Server her, um die Datei zu empfangen, pv -b wird auf die gleiche Weise verwendet). <br><br>  Wir können unsere Pipe komplizieren, indem wir die Dateiarchivierung im laufenden Betrieb hinzufügen: <br><br> <code>tar -czf - /path/to/ | pv -b | nc -l 4444</code>  <code>tar -czf - /path/to/ | pv -b | nc -l 4444</code> (Ordner im <code>tar -czf - /path/to/ | pv -b | nc -l 4444</code> archivieren und senden); <br>  n <code>c servername 4444 | pv -b &gt; file.tar.gz</code>  <code>c servername 4444 | pv -b &gt; file.tar.gz</code> (das Archiv wird gesendet). <br><br>  Ein nicht sehr offensichtliches Merkmal von nc ist das Erstellen eines http-Servers. <br><br><pre> <code class="plaintext hljs">while true; do nc -lp 80 &lt; index.html; done</code> </pre> <br>  Bitte beachten Sie, dass Sie Root-Rechte haben müssen, um Port 80 verwenden zu können. <br><br>  Beachten Sie auch Folgendes: <br><br><ul><li>  -l - zeigt den Betriebsmodus des Hörens an; </li><li>  -n - keine DNS-Abfragen verwenden; </li><li>  -v - ausführliche Ausgabe. </li></ul><br>  <b>Socat</b> <br><br>  Es ist auch ein nützliches Dienstprogramm, mit dem Sie TCP-Verbindungen zwischen Computern, Forward-Ports usw. herstellen können. Es funktioniert nach dem Prinzip von Netcat: Es öffnet zwei bidirektionale Verbindungen, kann Daten, Streams usw. übertragen. Es verfügt jedoch über eine interessante Funktion.  Mit Socat können wir beispielsweise COM-Ports TCP-Ports usw. zuordnen. <br><br>  Socat Arbeitsbeispiele: <br><br>  <code>socat -u FILE:file_name TCP-LISTEN:5778,reuseaddr</code> # send file; <br> <code>socat -u TCP:192.168.1.48:5778 STDOUT | pv -r &gt; file_name</code>  <code>socat -u TCP:192.168.1.48:5778 STDOUT | pv -r &gt; file_name</code> # get file; <br>  <code>socat TCP-LISTEN:80,fork TCP:ubuntunode-4:80</code> # Portweiterleitung des Remote-Servers an den lokalen Port; <br>  <code>socat TCP-LISTEN:1234,reuseaddr EXEC:/bin/bash</code> # Remote-Shell öffnen =); <br>  <code>socat - TCP:server_with_remote_shell:1234</code> # <code>socat - TCP:server_with_remote_shell:1234</code> eine Verbindung zur Remote-Shell des Remote-Servers her. <br><br>  Kleine Entschlüsselung: <br><br><ul><li>  -u - Verwendung des unidirektionalen Modus; </li><li>  DATEI - Geben Sie an, dass wir die Datei verwenden. </li><li>  TCP-LISTEN - Abhören des TCP-Ports; </li><li>  reuseaddr - ermöglicht es anderen Sockets, mit derselben Adresse zu kommunizieren, auch wenn diese verwendet wird; </li><li>  Fork - Nachdem die Verbindung hergestellt wurde, wird der Kanal im untergeordneten Prozess verarbeitet. </li><li>  TCP ist die Art der Verbindung. </li></ul><br>  <b>Soll ich mir jetzt die Videoversion ansehen?</b> <br><br>  Natürlich ja, denn in der Beschreibung wird alles abstrakt dargestellt.  Darüber hinaus werden die Themen des Webinars ausführlicher beschrieben. Einige von ihnen bieten zusätzliche Beispiele und Implementierungsoptionen.  Wenn Sie sich für dieses Thema interessieren, schauen Sie sich die offene Lektion vollständig an und wiederholen Sie alle Schritte für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladimir Drozdetsky,</a> um eine maximale Assimilation des Materials zu erreichen.  Und vergessen Sie nicht, Ihre Kommentare zu hinterlassen. <br><br>  Wir verabschieden uns wiederum nicht und laden Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Administrator</a> Kurs ein! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437114/">https://habr.com/ru/post/de437114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437104/index.html">Introskop: Nun, sehr fauler Unit-Test</a></li>
<li><a href="../de437106/index.html">IT in der Zone .it</a></li>
<li><a href="../de437108/index.html">Die meisten Texte im Internet werden von Verrückten geschrieben.</a></li>
<li><a href="../de437110/index.html">Nanomaterialien verändern unsere Welt, und wir haben immer noch keine Verfahren zur Überprüfung ihrer Sicherheit</a></li>
<li><a href="../de437112/index.html">DMA: Mythen und Realität</a></li>
<li><a href="../de437116/index.html">AWS, MongoDB und die wirtschaftlichen Realitäten von Open Source</a></li>
<li><a href="../de437118/index.html">AI und 2048. Teil 1: Monte-Carlo-Methode</a></li>
<li><a href="../de437120/index.html">Koreanischer Bürostuhl: Harachair Miracle Sensations</a></li>
<li><a href="../de437122/index.html">Dinge benennen</a></li>
<li><a href="../de437124/index.html">Eine einfache Möglichkeit, mehrere Sprachen hinzuzufügen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>