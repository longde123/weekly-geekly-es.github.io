<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎮 🤷🏿 ⛸️ 使用ReasonReact进行应用程序开发 ✋🏼 🧝🏼 🙇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否使用React创建用户界面？ 该材料的作者（我们发表了译文）说他也与React一起工作。 在这里，他想谈谈为什么ReasonML值得为React应用程序编写。 

  

 React是一个非常好的界面开发工具。 你能做得更好吗？ 为了改善您使用React的工作，您首先需要了解它的主要问题。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用ReasonReact进行应用程序开发</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424965/"> 您是否使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React</a>创建用户界面？ 该材料的作者（我们发表了译文）说他也与React一起工作。 在这里，他想谈谈为什么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReasonML</a>值得为React应用程序编写。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/e6a/7fb/319/e6a7fb319e17959ec7820b51e2d6538f.jpg"></a> <br><br>  React是一个非常好的界面开发工具。 你能做得更好吗？ 为了改善您使用React的工作，您首先需要了解它的主要问题。 特别是，一个问题的根源在于React是一个JavaScript库。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">React和JavaScript</font> </h2><br> 如果仔细观察React，您会注意到该库的某些基本原理与JavaScript无关。 特别是，我们谈论的是不变性，功能编程的原理以及类型系统。 <br><br> 免疫是React的基本原则之一。 组件属性或应用程序状态的更改非常不受欢迎，因为这可能导致不可预测的后果。  JavaScript没有提供抗扰性的标准机制。 通过遵守某些约定或使用像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">immutable-js</a>这样的库，可以使数据结构不可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">变</a> 。 <br><br> 由于React应用程序是功能的组合，因此React库基于函数式编程的原理。 尽管JavaScript具有某些功能性编程功能，例如一流的功能，但它不是功能性编程语言。 如果需要用JavaScript编写良好的声明性代码，则必须诉诸于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lodash / fp</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ramda之</a>类的第三方库。 <br><br> 类型系统有什么问题？  React具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PropTypes</a>的概念。 由于该语言本身不是静态类型，因此它用于模拟JavaScript中的类型。 为了充分利用JS中的静态类型，必须再次使用第三方工具，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flow</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TypeScript</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/b1b/136/f27b1b136262168696ea82470b66cd3d.jpg"></div><br>  <i><font color="#999999">比较React和JavaScript</font></i> <br><br> 如您所见，JavaScript与React的基本原理不兼容。 <br><br> 是否有比React更好的JavaScript语言？ <br> 您可以对这个问题给出肯定的答案。 这种语言是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReasonML</a> 。 <br><br> 理性实现不变性。 由于它基于功能性编程语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OCaml</a> ，因此相应的功能也内置在Reason中。 这种语言也有自己的适用于React的类型系统。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a83/a37/41e/a83a3741e3cdfac7139203f491e4f06d.jpg"></div><br>  <i><font color="#999999">比较React，JavaScript和原因</font></i> <br><br> 事实证明，Reason与React的基本原理兼容。 <br><br><h2>  <font color="#3AC1EF">原因</font> </h2><br> 原因不是一种新语言。 它是OCaml的另一种类似于JavaScript的语法和工具包，OCaml是一种功能编程语言，已有20多年的历史了。 原因是由Facebook的开发人员创建的，他们已经在其项目中使用了OCaml（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flow</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Infer</a> ）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/e30/c30/c95e30c30a5de6bb24b079dbfdb667a4.jpg"></div><br>  <i><font color="#999999">OCaml</font></i> <br><br>  Reason的C语言语法使OCaml对熟悉JavaScript或Java等常见语言的程序员可用。 与OCaml相比，Reason为开发人员提供了更好的文档，并且围绕他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>爱好者不断发展。 此外，使用Reason编写的内容易于与现有JS项目集成。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a05/501/393/a05501393404c126b3a9164d346b6cc7.jpg"></div><br>  <i><font color="#999999">原因</font></i> <br><br> 原因的核心是OCaml。 原因与OCaml具有相同的语义，只是语法不同。 这意味着Reason使得可以使用类似JavaScript的语法编写OCaml代码。 结果，程序员具有出色的OCaml功能，例如严格的类型系统和模式匹配机制。 <br><br> 查看一下原因代码片段，以熟悉其语法。 <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fizzbuzz = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i mod <span class="hljs-number"><span class="hljs-number">3</span></span>, i mod <span class="hljs-number"><span class="hljs-number">5</span></span>) {  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>  | <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> string_of_int(i)  }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">100</span></span>) {  Js.log(fizzbuzz(i)) };</code> </pre> <br> 尽管此模式使用模式匹配机制，但仍与JavaScript非常相似。 <br><br> 在浏览器中唯一可用的语言是JavaScript，因此，为了以任何语言为浏览器编写代码，我们需要在JavaScript中进行编译。 <br><br><h2>  <font color="#3AC1EF">BuckleScript</font> </h2><br>  Reason最为有趣的功能之一可以称为BuckleScript编译器，该编译器将用Reason编写的代码转换为可读且高效的JS代码，此外，还可以清除未使用的构造。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6c/075/e17/f6c075e172668e85e291b39f468a57c1.png"></div><br>  <i><font color="#999999">BuckleScript</font></i> <br><br> 如果您在并非每个人都熟悉Reason的团队中工作，那么BuckleScript结果的可读性将派上用场。 至少这些人将能够阅读生成的JS代码。 <br><br> 原因代码有时与JS代码非常相似，以至于编译器根本不需要对其进行转换。 在这种情况下，您可以享受Reason静态类型的好处，并编写看起来像用JavaScript编写的代码。 <br><br> 这是可以在Reason和JavaScript中使用的代码示例： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> = (a, b) =&gt; a + b; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  BuckleScript带有四个库。 这是一个称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Belt</a>的标准库（这里<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的OCaml标准库</a>还不够），以及JavaScript，Node.js和DOM API的绑定。 <br><br> 由于BuckleScript基于OCaml编译器，因此编译<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非常快</a> -比Babel快得多，比TypeScript快几倍。 <br><br> 使用BuckleScript，我们在JavaScript中编译了上面的Reason代码片段，其中包含<code>fizzbuzz()</code>函数。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/a05/8a2/21ca058a2b658c47d975d922e39d1390.jpg"></div><br>  <i><font color="#999999">使用BuckleScript在JavaScript中编译原因代码</font></i> <br><br> 如您所见，JS代码变得可读性强。 看起来好像是男人写的。 <br><br> 用Reason编写的程序不仅可以用JavaScript进行编译，还可以使用本机代码和字节代码进行编译。 因此，例如，您可以在Reason上编写应用程序，然后在MacOS上的浏览器，运行Android和iOS的智能手机上运行该应用程序。 贾里德·福赛斯（Jared Forsyth）在理性上有一款<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gravitron</a>游戏。 它可以在上述所有平台上运行。 <br><br><h2>  <font color="#3AC1EF">与JavaScript交互的组织</font> </h2><br>  BuckleScript使组织Reason和JavaScript的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交互</a>成为可能。 这不仅意味着有可能在Reason代码库中使用有效的JS代码，而且还意味着有可能将使用Reason语言编写的代码与此JavaScript代码进行交互。 结果，用Reason编写的代码很容易集成到现有的JS项目中。 此外，在原因代码中，您可以使用NPM的JavaScript包。 例如，您可以创建共享Flow，TypeScript和Reason的项目。 <br><br> 但是，一切并非如此简单。 为了在Reason中使用JavaScript代码或库，您必须首先使用Reason绑定移植它们。 换句话说，为了使用严格的Reason类型系统，我们需要常规JavaScript代码的类型。 <br><br> 如果您需要在原因代码中使用任何JavaScript库，则应首先转到原因包索引（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redex</a> ），然后确定该库是否已移植到Reason。  Redex项目是用Reason和带有Reason绑定的JavaScript库编写的库和工具的目录。 如果设法在此目录中找到必要的库，则可以将其安装为依赖项，并在Reason应用程序中使用它。 <br><br> 如果找不到所需的库，则必须自己编写活页夹。 如果您刚开始使用Reason，请记住，编写活页夹不是初学者的任务。 对于那些使用Rational进行编程的人来说，这是必须解决的最困难的任务之一。 实际上，这是另一篇文章的主题。 <br><br> 如果只需要某些JavaScript库的某些有限功能，则无需为整个此类库编写绑定。 只能对必要的功能或组件执行此操作。 <br><br><h2>  <font color="#3AC1EF">原因反应</font> </h2><br> 在本文的开头，我们讨论了它如何专门用于使用Reason开发React应用程序。 您可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReasonReact</a>库来执行此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作</a> 。 <br><br> 也许现在您在想：“我仍然不明白为什么要用Reason编写React应用程序。” 但是，我们已经讨论了使用React和Reason捆绑软件的主要原因，这就是说React与Reason的兼容性比与JavaScript的兼容性更好。 为什么会这样呢？ 问题是React是基于Reason或基于OCaml创建的。 <br><br><h2>  <font color="#3AC1EF">理性之路</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/139/424/38c139424305904a5d72c3c8596420ec.jpg"></div><br> 第一个React原型是由Facebook开发的，并且是使用OCaml的相对语言使用标准元语言（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StandardML</a> ）编写的。 然后将React转移到OCaml，此外，将React移植到JavaScript。 这样做是由于整个Web都使用JavaScript，并且做出这样的声明可能是不合理的：“现在我们将在OCaml上编写UI”。 从React到JavaScript的翻译获得了回报，并导致了该库的广泛分发。 <br><br> 结果，每个人都习惯于将React视为JS库。  React以及其他库和语言（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Elm</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Recompose</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ramda</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PureScript</a> ）已帮助普及了JavaScript编程的功能样式。 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flow</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TypeScript</a>在JavaScript中的广泛应用，静态类型也变得很流行。 结果，在前端开发领域，使用静态类型的函数式编程已成为主流。 <br><br>  2006年， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">彭博社</a>创建了BuckleScript编译器并将其转移到开源项目类别中，该编译器将OCaml转换为JavaScript。 这使他们可以使用严格的OCaml类型系统编写更好，更安全的前端代码。 他们采用了经过优化且非常快速的OCaml编译器，并使其生成JavaScript代码。 <br><br> 函数式编程的普及以及BuckleScript的发布创造了一种理想的氛围，使Facebook可以返回到React的原始想法-一个最初用StandardML编写的库。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e2/9f4/1ab/4e29f41aba5732c3a1c23482f1859d7c.png"></div><br>  <i><font color="#999999">原因反应</font></i> <br><br> 他们将OCaml语义与JavaScript语法混合在一起，并创建了Reason。 此外，他们还为React创建了一个Reason包装器，以ReasonReact库的形式提供，它具有其他功能，例如将Redux原理封装在有状态的组件中。 这样做之后，他们将React带回了它的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">起源</a> 。 <br><br><h2>  <font color="#3AC1EF">关于合理的React功能</font> </h2><br> 当将React库翻译成JavaScript时，通过创建各种库和工具，可根据React的需求对语言的功能进行定制。 尤其是，这种方法意味着需要大量依赖项目。 我们不会说此类库在不断发展，并且经常在其中进行更改，从而使其新版本与旧版本不兼容。 因此，开发人员必须非常认真和谨慎地维护其项目所依赖的库。 <br><br> 这为JavaScript开发增加了一层额外的复杂性。 例如，典型的React应用程序通常至少包含依赖关系，如下图所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ed/64a/ac4/0ed64aac438522cd6a241e340a14194b.jpg"></div><br>  <i><font color="#999999">典型的React应用依赖</font></i> <br><br> 这些依赖项可以解决以下任务： <br><br><ul><li> 静态类型-Flow / TypeScript。 </li><li> 免疫-ImmutableJS。 </li><li> 路由-ReactRouter。 </li><li> 代码格式化-更漂亮。 </li><li>  Linting-ESLint。 </li><li> 辅助功能-Ramda / Lodash。 </li></ul><br> 现在，我们将使用ReasonReact库而不是React for JavaScript。 通过这种方法，我们需要所有这些依赖吗？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e92/76b/d37/e9276bd37be87945122ed64af7d37118.gif"></div><br>  <i><font color="#999999">切换到ReasonReact</font></i> <br><br> 在分析了以前使用其他工具可以解决的相同任务列表之后，我们发现可以使用内置的ReasonReact工具解决所有任务。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关它们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a>信息。 <br><br> 在ReasonReact准备的应用程序中，不需要所有这些依赖关系和许多其他依赖关系。 事实是，简化语言的许多最重要的功能已经包含在该语言中。 结果，简化了依赖项的工作，并且随着应用程序的增长和发展，这项工作不会变得复杂。 <br><br> 由于使用了20多年的OCaml语言，所有这些都是可能的。 这是一门成熟的语言，其基本原理和机制经过时间的考验和稳定。 <br><br><h2>  <font color="#3AC1EF">接下来是什么？</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/326/c67/499326c67ab497eee1c0794b58a80641.jpg"></div><br> 如果您是来自JavaScript世界的人，那么使用Reason会很容易，因为该语言的语法类似于JavaScript。 如果您之前编写过React应用程序，那么切换到Reason将会更加轻松，因为您可以在使用ReasonReact时使用React领域的全部知识。  ReasonReact的核心与React的核心一样，具有相同的思维模式，使用它们的过程也非常相似。 这意味着当您切换到Reason时，您不必从头开始。 您将在此过程中处理Reason。 <br><br> 在您的项目中开始使用Reason的最佳方法是逐步将用Reason编写的片段引入其中。 如前所述，Reason代码可以在JS项目中使用，也可以在原因项目中使用JS代码。 当使用ReasonReact时，此方法也适用。 您可以使用ReasonReact组件，并在用JavaScript编写的传统React应用程序中使用它。 <br><br> 这正是Facebook开发人员选择的增量方法，他们在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Facebook Messenger</a>时广泛使用了Reason。 <br><br> 如果您想使用Reason编写React应用程序并在实践中学习该语言的基础知识，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>材料，其中逐步开发了“井字游戏”游戏。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>  Reason的创建者有两种选择。 首先是采用JavaScript并以某种方式进行改进。 如果他们选择这条道路，他们将不得不处理JS的历史缺陷。 <br><br> 但是，他们选择了与OCaml相关的第二条路径。 他们选择了OCaml（一种性能卓越的成熟语言），并将其修改为类似于JavaScript。 <br><br>  React也基于OCaml的原理。 这就是为什么使用Reason编写React应用程序变得更加轻松和有趣的原因。 在理性中使用React提供了一种更稳定和安全的方法来创建React组件，因为严格的类型系统可以确保开发人员而且他不必面对大多数历史JavaScript问题。 <br><br>  <b>亲爱的读者们！</b> 您是否尝试过ReasonReact？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424965/">https://habr.com/ru/post/zh-CN424965/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424951/index.html">万岁！ 这不是妄想症</a></li>
<li><a href="../zh-CN424955/index.html">上周第332期来自前端世界的新鲜材料摘要（2018年9月24日至30日）</a></li>
<li><a href="../zh-CN424957/index.html">使用AttnGAN从文本生成图像</a></li>
<li><a href="../zh-CN424961/index.html">MTA-STS for Postfix</a></li>
<li><a href="../zh-CN424963/index.html">扎克伯格资助：共同构建科学工具</a></li>
<li><a href="../zh-CN424967/index.html">面向初学者的JavaScript快捷方式</a></li>
<li><a href="../zh-CN424969/index.html">Node.js指南，第9部分：使用文件系统</a></li>
<li><a href="../zh-CN424971/index.html">Habrokast“手动日落”＃1。 尝试建立用于开发Windows玩具的环境</a></li>
<li><a href="../zh-CN424973/index.html">视频的人脸检测：Raspberry Pi和神经计算棒</a></li>
<li><a href="../zh-CN424975/index.html">SIEM深度：现成的相关性。 第2部分。数据模式反映“世界”模型</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>