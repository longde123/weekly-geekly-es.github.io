<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 🌕 👨‍❤️‍👨 BTRFS pour les plus petits 🤭 📩 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Khabravchane. Je travaille chez Veeam Software et je suis l'un des développeurs de notre solution de sauvegarde Linux. Par occupation, il m'e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS pour les plus petits</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/"> Bonjour, Khabravchane.  Je travaille chez Veeam Software et je suis l'un des développeurs de notre solution de sauvegarde Linux.  Par occupation, il m'est arrivé de rencontrer BTRFS.  Plus récemment, il est passé du statut «pas encore adapté» au statut «stable».  Et tandis que ses premiers utilisateurs sur le réseau discutaient des problèmes et des problèmes de stabilité, nous, chez Veeam, l'avons poussé avec une baguette et avons essayé de le sauvegarder.  Il s'est avéré, pour ne pas dire grand-chose - c'est trop différent, pas comme les systèmes de fichiers traditionnels.  J'ai dû étudier de nombreux aspects et collecter beaucoup de râteaux avant d'apprendre à travailler avec.  Dans le processus d'apprentissage, BTRFS a réussi à m'impressionner, à la fois dans le bon sens et moins.  Je suis sûr qu'elle ne laissera indifférent aucun spécialiste informatique du monde Linux: certains cracheront, d'autres feront l'éloge. <br><br>  Si vous avez entendu parler de ce système de fichiers, mais que vous ne savez pas pourquoi il est intéressé par les détails ou que vous cherchez où commencer à le connaître, je vous invite à chatter. <br><a name="habracut"></a><br><h1>  Présentation </h1><br>  BTRFS (B-Tree Filesystem) - système de fichiers pour les systèmes d'exploitation de type Unix, basé sur la technique Copy on Write (CoW), conçu pour fournir une facilité de mise à l'échelle du système de fichiers, un degré élevé de fiabilité et de sécurité des données, une flexibilité de configuration et une facilité d'administration, tout en maintenant en même temps à grande vitesse.  C'est du moins ce que dit la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page principale du wiki</a> . <br><br>  Pour respecter les formalités, nous listons les principales fonctionnalités de btrfs: <br><br><ul><li>  Taille maximale du fichier 2 ^ 64 octets <br></li><li>  Table d'inode dynamique <br></li><li>  Déduplication des données <br></li><li>  Stockage efficace des fichiers de très petites et très grandes tailles <br></li><li>  Création de sous-groupes et d'instantanés <br></li><li>  Quotas de sous-volume <br></li><li>  Somme de contrôle des données et des métadonnées <br></li><li>  La possibilité de combiner plusieurs disques en un seul système de fichiers <br></li><li>  Création d'une configuration RAID au niveau du système de fichiers <br></li><li>  Compression des données <br></li><li>  Défragmentation des données à la volée <br></li></ul><br>  Je tiens à vous avertir immédiatement que BTRFS se développe activement, et certains points peuvent différer d'une version à l'autre.  Le lien - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://btrfs.wiki.kernel.org/index.php/Changelog,</a> vous permet de savoir quand quelles fonctionnalités ont été ajoutées, modifiées ou corrigées. <br><br>  Oui, BTRFS est un système de fichiers jeune et moderne qui résout un large éventail de tâches, mais pas sans ses inconvénients: <br><br><ul><li>  Son développement actif entraîne une modification de tous les points clés sur lesquels les utilitaires tiers peuvent s'appuyer lorsqu'ils travaillent avec. <br></li><li>  Malgré les assurances des développeurs quant à la stabilité de BTRFS, les utilisateurs rencontrent régulièrement des problèmes pouvant entraîner une perte de données.  En règle générale, ils sont de nature «flottante», de sorte qu'ils n'ont pas encore été étudiés et corrigés. <br></li><li>  Haute sensibilité à la fragmentation. <br></li><li>  Documentation limitée et parfois obsolète. <br></li></ul><br>  Une page entière est consacrée aux problèmes du système de fichiers sur différentes versions des noyaux - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://btrfs.wiki.kernel.org/index.php/Gotchas</a> .  Je vous conseille fortement de regarder là-bas - cela s'avère beaucoup intéressant et non évident. <br><br><h1>  Structure BTRFS </h1><br>  Le périphérique BTRFS simplifié peut être divisé selon les niveaux suivants: <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br>  Les périphériques de bloc sont situés au niveau le plus bas, représentant un ou plusieurs espaces d'adressage physiques distincts (le même «physique» que les périphériques de bloc eux-mêmes, mais ce sont déjà des détails).  Grâce à des structures spéciales, les blocs de mémoire physique alloués sont combinés en un seul espace d'adressage virtuel. <br><br>  Les structures de métadonnées et les blocs contenant des données utilisateur (étendues) sont déjà traités à un niveau logique.  Par conséquent, les données situées séquentiellement à un niveau logique peuvent résider physiquement sur différents périphériques de bloc. <br><br>  Les structures de métadonnées peuvent être divisées en niveaux.  Bien sûr, je ne les classerai pas - il y en a beaucoup, et ces détails de bas niveau font l'objet d'un article séparé.  Il est important ici que certaines structures de la hiérarchie se révèlent être de niveau supérieur à d'autres, et tout en haut, il y aura une structure qui est un sous-volume. <br><br>  Le sous-volume est une sorte de point d'entrée, ou plutôt, les éléments racine du système de fichiers.  Ils forment une couche distincte de représentation des données, qui encapsule le travail des couches inférieures, présentant les données utilisateur sous la forme habituelle: répertoires et fichiers.  De plus, les sous-loups sont un élément clé du mécanisme CoW sur BTRFS.  Les mêmes fichiers dans deux sous-volumes peuvent se révéler être le même ensemble de données aux niveaux inférieurs. <br><br>  La dernière couche est la couche de données.  Comme l'utilisateur les voit.  Ce sont des fichiers et des répertoires situés dans le sous-volume. <br><br>  Mais assez de théorie.  Il est temps de passer à la pratique! <br><br><h1>  Btrfs-progs </h1><br>  Il s'agit d'un ensemble standard d'utilitaires pour la gestion de BTRFS.  Selon le package de distribution avec ces utilitaires dans le référentiel peuvent avoir des noms différents: <b>btrfsprogs</b> , <b>btrfs-progs</b> , <b>btrfs-tools</b> , etc.  Si votre référentiel n'avait rien de similaire, vous pouvez toujours le compiler manuellement, les sources ne sont pas loin - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/kdave/btrfs-progs</a> . <br>  Les utilitaires les plus importants de ce package sont <b>btrfs</b> et <b>mkfs.btrfs</b> .  À partir de la seconde, je pense que tout est très clair - il est nécessaire de créer BTRFS sur un périphérique bloc.  Tout d'abord, <b>btrfs</b> est l'utilitaire principal qui vous permet de faire le reste.  Une sorte de "couteau suisse". <br><br>  Dans cet article, j'ai utilisé la version v4.15.1.  L'utilitaire se développe très activement et il existe des différences notables d'une version à l'autre.  Donc, si vous n'aviez pas la commande nécessaire, vérifiez la version de l'utilitaire <b>btrfs</b> , elle est peut-être déjà obsolète. <br><br>  De plus, très probablement, les <b>utilitaires btrfsck</b> et <b>btrfstune</b> se trouvent dans le package. <br><br><ul><li>  Le premier sert à vérifier le système de fichiers pour les erreurs et les corrections ultérieures, cependant, je ne recommande pas de l'utiliser - il est dans <i>un</i> état <i>obsolète</i> , sa fonctionnalité a été déplacée vers la commande de <b>vérification btrfs</b> . </li><li>  Le second vous permet d'effectuer certaines opérations utiles sur btrfs, par exemple, de changer l'identifiant unique du système de fichiers (FS UUID), ou d'activer certaines fonctionnalités du système de fichiers. </li></ul><br>  En plus des utilitaires répertoriés ci-dessus, il existe plusieurs autres utilitaires dans le package, mais ils sont principalement nécessaires pour le débogage de btrfs et ne nous seront pas utiles dans cet article. <br><br><h1>  Formatage d'un disque en BTRFS </h1><br>  En pratique, tout est plus simple.  Commençons par un lecteur. <br>  Le formatage d'un seul disque dans btrfs se produit avec la commande habituelle: <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br>  En réponse, l'utilitaire affichera les paramètres du système de fichiers créé sur la console: <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br>  Passons en revue les paramètres présentés. <br><br><ul><li>  <b>Étiquette</b> - Un nom d'étiquette ou de système de fichiers.  Il est spécifié par le commutateur <code>-L</code> et est un paramètre facultatif. </li><li>  <b>UUID</b> est un identifiant unique qui permet au noyau btrfs de différencier les instances les unes des autres. </li><li>  <b>Taille du nœud</b> - la taille des éléments de l'arbre B dans lesquels les métadonnées sont stockées.  Il peut être défini à l'aide de l' <code>-n | --nodesize</code>  <code>-n | --nodesize</code> , et il doit être un multiple de la taille de la taille du <b>secteur</b> .  La petite taille du nœud entraîne une augmentation de la hauteur de l'arbre B (une augmentation du nombre de nœuds) et, par conséquent, une diminution de la concurrence pour bloquer un nœud individuel.  D'un autre côté, la petite taille du nœud rend l'instance du système de fichiers plus sujette à la fragmentation.  Les gros nœuds, en revanche, contribuent à un meilleur empaquetage des métadonnées sur le disque, ce qui réduit la fragmentation. <br>  L'inconvénient est l'augmentation du temps d'accès aux données pour la mise à jour du même nœud par plusieurs threads.  Sur les noyaux antérieurs à 3.11, par défaut, la taille du nœud est de 16384 octets ou la taille de la page de mémoire du système d'exploitation (la plus grande de ces deux valeurs). </li><li>  <b>Taille du secteur</b> - la quantité d'espace qui est des multiples dont l'espace est alloué et libéré au niveau physique.  Elle est égale à la taille de page de la mémoire virtuelle du système d'exploitation, sauf indication contraire avec le <code>-s</code> . </li><li>  <b>Taille du système de fichiers</b> - la capacité totale du système de fichiers (données et métadonnées).  Défini manuellement avec le commutateur <code>-b</code> .  Par défaut, tout le volume du périphérique de bloc est occupé. </li><li>  <b>Fonctionnalités incompatibles</b> - une liste de fonctionnalités incluses sur les btrfs créés qui rompent la compatibilité descendante avec les anciennes versions du noyau.  Si la compatibilité descendante est nécessaire, vous pouvez désactiver: <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br>  Soit dit en passant, vous pouvez vérifier les fonctionnalités prises en charge par le noyau actuel par l'appel suivant: <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>Nombre de périphériques et de périphériques</b> - combien de périphériques de bloc sont impliqués dans l'instance btrfs créée, et une liste de tous les périphériques, respectivement. </li><li>  Nous devrions également parler du paramètre <b>Block Group Profiles</b> .  Il indique le profil d'enregistrement applicable pour chacun des trois types de données: données, métadonnées et système.  Revenant à la structure généralisée de btrfs, on peut dire que: <br><br><ul><li>  Les données sont des données utilisateur; </li><li>  Les métadonnées sont une combinaison d'une couche de sous-volume et d'une couche de métadonnées et d'étendues; </li><li>  Les systèmes sont des structures permettant de mapper l'espace d'adressage de la mémoire physique en un espace continu d'adresses logiques. </li></ul><br>  Un profil d'enregistrement est un moyen de stocker des données au niveau physique: <br><br><ul><li>  Single - stockage des données en une seule copie; </li><li>  DUP - duplication de données sur un seul support; </li><li>  RAIDX est l'une des configurations de RAID0, RAID1, RAID10, RAID5 et RAID6. </li></ul><br></li></ul><br>  Lors du balisage d'un périphérique bloc, btrfs appliquera la duplication aux métadonnées et aux données système par défaut, et les données utilisateur resteront sur le support en une seule copie.  La création de btrfs sur plusieurs disques à la fois appliquera le profil «RAID0» aux données utilisateur par défaut et «RAID1» aux métadonnées. <br>  Ce groupe de paramètres est contrôlé à l'aide de deux clés: <code>-d</code> pour les données et <code>-m</code> pour les métadonnées et les données système. <br><br>  Mais il y a une nuance ... Les choses sont différentes avec les SSD.  Le fait est que si nous marquions un lecteur SSD (ou un lecteur flash), par défaut, le système de fichiers ne dupliquerait pas les métadonnées.  Les disques SSD peuvent étendre la déduplication des données pour prolonger la durée de vie des éléments de mémoire.  C'est-à-dire  ayant deux copies logiques des données, en fait une seule sera enregistrée sur le support.  Par conséquent, lorsqu'un segment de mémoire échoue, les «deux copies» des données seront endommagées.  De plus, en écrivant deux fois des données, la ressource SSD est simplement consommée plus rapidement. <br><br>  Pour déterminer le type de support, btrfs vérifie le contenu du fichier <i>/ sys / block / DEV / queue / rotation</i> , où "DEV" est le nom du périphérique de bloc en cours de vérification. <br>  Bien sûr, même dans le cas d'un SSD, le profil de stockage peut être forcé. <br><br>  Pour créer une instance btrfs sur plusieurs appareils, spécifiez-les simplement avec un espace: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br>  ou avec des profils: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br>  Il convient de noter que les supports ne doivent pas nécessairement être de la même taille, même si la mise en miroir complète est utilisée.  Cependant, dès qu'il n'y a pas assez d'espace sur le plus petit lecteur pour allouer de la mémoire, le système de fichiers affiche un message indiquant qu'il n'y a pas d'espace libre, bien que physiquement il puisse toujours y avoir de l'espace libre sur d'autres supports. <br><br><h1>  Montage </h1><br>  Le premier montage de btrfs fraîchement créé n'est pas différent des autres systèmes de fichiers: <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br>  Si le système de fichiers se trouve sur plusieurs disques, pour le montage, il suffit de spécifier l'un d'entre eux. <br><br>  En général, le montage de btrfs implique toujours le montage d'un ou plusieurs de ses sous-volumes.  Si la commande mount n'est pas spécifiée, quel sous-volume doit être monté, alors btrfs lira à partir de l'enregistrement spécial l'ID du sous-volume, qui doit être monté par défaut.  Cette entrée peut être modifiée ultérieurement avec la commande <code>btrfs set-default</code> , mais lorsque vous la montez pour la première fois sur btrfs, il n'y a qu'un seul sous-volume - celui racine.  Il est spécifié par défaut pour le montage. <br><br>  Le sous-monde racine sur btrfs est toujours présent.  Il apparaît avec le système de fichiers et n'est soumis à aucune modification à l'avenir. <br><br>  Il existe deux façons de monter un sous-volume autre que celui par défaut: <br>  spécifiez le chemin depuis le sous-volume racine btrfs: <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br>  spécifiez soit l'ID de sous-volume: <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br>  Comme déjà mentionné, l'un des sous-volumes btrfs est spécifié comme monté par défaut.  Découvrez lequel est possible en faisant: <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br>  Pour installer le sous-montage par défaut, vous pouvez utiliser la commande: <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br>  Dans ce cas, le chemin d'accès au sous-volume n'est nécessaire que pour indiquer l'instance btrfs spécifique à laquelle la commande s'applique.  Soit dit en passant, il n'est pas nécessaire que ce soit un sous-monde; le chemin vers n'importe quel répertoire convient également. <br><br>  La commande <code>mount</code> accepte un grand nombre d'options pour contrôler les capacités de btrfs: défragmentation, vidage du cache, compression, vache, journalisation, équilibre, prise en charge ssd et beaucoup d'autres choses spécifiques à btrfs.  Je ne les considérerai pas dans le cadre de cet article, car  ils sont nécessaires pour affiner le système de fichiers, et dans la grande majorité des cas, vous pouvez vous en passer. <br><br><h1>  Le sous-volume est </h1><br>  Un sous-volume est un élément clé de btrfs qui remplit diverses fonctions: <br><br><ul><li>  stockage des données utilisateur et autres sous-volumes, <br></li><li>  accès aux données (montage), <br></li><li>  Mécanisme CoW <br></li><li>  créer des instantanés. <br></li></ul><br>  En première approximation, le sous-volume est un répertoire normal.  Vous pouvez les renommer / déplacer, afficher leur contenu, y placer et modifier des fichiers.  Aucun utilitaire spécial n'est requis. <br><br>  La création et la suppression d'un sous-volume sont effectuées sur des btrfs montés à l'aide de commandes spéciales: <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br>  Je note que si vous essayez de supprimer le sous-volume à l'aide du gestionnaire de fichiers ou de l'utilitaire <b>rm</b> , l'opération se terminera par une erreur d' <i>opération non autorisée</i> (l'opération n'est pas autorisée). <br><br>  <b>UPD: à</b> partir de la version 4.18.0 du noyau, les sous-volées peuvent être supprimées à l'aide de l'utilitaire <b>rm</b> ou des outils du gestionnaire de fichiers.  Apparemment, c'était un bug, pas une fonctionnalité.  Merci à Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">habravchanin</a> pour la clarification. <br><br>  Après avoir créé un sous-volume, vous pouvez voir ses propriétés: <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Passons en revue les principales propriétés du sous-volume: <br><br><ul><li>  <b>Nom</b> - le nom du sous-volume <br></li><li>  <b>UUID</b> est un identifiant unique universel qui sert principalement à déterminer les relations subwoofer-snapshot, <br></li><li>  <b>UUID parent</b> - identifiant de l'ancêtre du sous-volume dont dérive l'actuel, <br></li><li>  <b>UUID reçu</b> - identifiant de l'ancêtre du sous-volume envoyé via <i>btrfs send</i> , <br></li><li>  <b>ID de sous-volume</b> - un identifiant unique pour le placement dans l'arbre B, <br></li><li>  <b>Génération</b> - numéro de transaction lors de la dernière mise à jour des métadonnées de sous-volume, <br></li><li>  <b>Gén à la création</b> - numéro de transaction au moment de la création du sous-volume, <br></li><li>  <b>ID parent</b> - identifiant du sous-volume dans lequel le courant est intégré, <br></li><li>  <b>L'ID de niveau supérieur</b> est exactement le même que l'ID parent, <br></li><li>  <b>Drapeaux</b> - drapeaux (en fait, un seul drapeau est en <i>lecture seule</i> ), <br></li><li>  <b>Instantanés</b> - une liste d'instantanés pris à partir de ce sous-volume. <br></li></ul><br>  Le sous-volume a un paramètre de plus - c'est son chemin depuis l'élément racine btrfs.  Le chemin est affiché lors de la liste du sous-volume: <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br>  Mais ici, tout est simple et clair - cela n'a même pas de sens d'apporter la sortie de la commande. <br>  Comme pour les commandes <code>get-default</code> et <code>set-default</code> , vous pouvez spécifier ici le chemin d'accès à n'importe quel sous-volume, le résultat ne changera pas.  Ce chemin est utilisé pour trouver les btrfs du sous-bol racine.  Après quoi tout l'arbre sous-wolum est lu. <br><br>  Si vous essayez de copier le sous-volume, par exemple, avec l'utilitaire <b>cp</b> , l'opération de copie réussira, mais en conséquence, non le sous-volume sera créé, mais le répertoire habituel.  Cependant, btrfs fournit un outil beaucoup plus flexible pour créer de telles copies - des instantanés. <br><br><h1>  Le snapshot est </h1><br>  Snapshot est également un sous-monde, ayant juste des propriétés avancées. <br><br>  Leur principale différence est que l'instantané contient des enregistrements à partir desquels il a été produit.  Il s'agit des champs <b>UUID</b> <b>parent</b> et <b>UUID reçu</b> .  Dans le caisson de basses, ces champs sont également présents, mais ils sont toujours vides.  Donc, en fait, un instantané et un sous-volume sont une seule et même chose. <br>  Lors de la création, vous pouvez bloquer l'instantané des modifications à l'aide du commutateur <code>-r</code> . <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br>  Dans ce cas, les fichiers sont garantis dans leur état d'origine au moment de la création de l'instantané. <br><br>  L'indicateur en lecture seule peut également être contrôlé manuellement, cela fonctionne pour n'importe quel sous-volume: <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br>  Si nous regardons maintenant les propriétés de l'instantané, nous verrons le champ <b>UUID parent</b> rempli: <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Une caractéristique importante de l'opération d'instantané est qu'elle n'est pas récursive.  Au lieu d'un sous-volume imbriqué, des répertoires vides seront créés dans l'instantané. <br><br>  Passons à l'exemple suivant. <br><br>  Sur le système de fichiers, il y a un subwoofer «sub0», à l'intérieur duquel se trouve un subwoofer <i>subA</i> et un répertoire <i>dirB</i> .  À l'intérieur de chacun d'eux se trouvent respectivement le <i>fichierA</i> et le <i>fichierB</i> . <br><br>  Supprimer l'instantané: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  Le snapshot <i>snap0 créé</i> héritera de tous les fichiers et répertoires de son parent, cependant, le <i>subwoofer</i> subA n'apparaîtra pas dans le snapshot.  Au lieu de cela, seul un répertoire vide apparaîtra dans l'instantané, c'est-à-dire  le contenu du <i>sous-</i> volume subA ne sera pas hérité. <br><br>  D'une part, c'est bien - nous supprimons l'instantané d'un sous-volume spécifique, et tous ceux imbriqués ne nous intéressent pas.  D'un autre côté, si un instantané récursif est requis, alors btrfs n'a pas de solution à ce problème.  Nous devrons chercher des tournées de travail. <br><br>  La première solution de contournement est basée sur le fait que l'instantané a été supprimé sans indicateur de lecture seule, ce qui vous permet de corriger la situation tout simplement: <br><br><ul><li>  supprimer un répertoire supplémentaire de l'instantané <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li>  supprimer un instantané d'un sous-volume imbriqué <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br>  Si l'instantané a été supprimé avec l'indicateur de lecture seule, l'option ci-dessus ne fonctionnera pas, car  dans <i>snap0,</i> vous ne pouvez ni supprimer le répertoire ni placer un instantané.  Il n'y a qu'une seule option - placer des instantanés quelque part près du caisson de <i>basses</i> snap0: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br>  puis montez <i>snapA</i> dans l'instantané <i>snap0</i> , le répertoire correspondant est déjà là: <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br>  Dans tous les cas, il est important de comprendre que les instantanés récursifs seront tous tournés dans différentes opérations, à des moments différents.  Il ne peut être question d'une suppression atomique d'un instantané de plusieurs sous-volumes. <br><br><h1>  Copie en écriture </h1><br>  Un peu sur le sous-volume et l'approche CoW.  Imaginez qu'un sous-volume soit présent sur le système de fichiers et qu'un fichier s'y trouve (prenez le cas idéal - le fichier n'est pas fragmenté).  Ensuite, un instantané est supprimé du sous-chariot. <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br>  Un nouveau sous-volume (instantané) apparaîtra sur le système de fichiers avec exactement le même contenu que le sous-volume d'origine.  Le processus de création d'un instantané est presque instantané - les données du fichier lui-même ne sont pas copiées.  Au lieu de cela, des métadonnées supplémentaires sont créées et un instantané avec le sous-volume parent devient le propriétaire du fichier.  En fait, il n'y avait qu'un seul fichier sur le disque, mais maintenant il appartient à la fois au sous-volume et à l'instantané. <br>  Si vous modifiez maintenant le fichier dans le sous-volume, les modifications n'affecteront pas le fichier dans l'instantané.  Si l'indicateur de lecture seule n'a pas été défini lors de la création de l'instantané, le fichier de l'instantané peut également être modifié. <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br>  Techniquement, lorsqu'un fichier est modifié, seules ces modifications sont enregistrées.  Ainsi, le fichier source sera stocké sur le disque plus un delta qui distingue le fichier d'origine du fichier modifié.  Si vous supprimez l'un des sous-volumes (par la seconde je veux dire un instantané), les données en excès qui ne sont plus utilisées par personne seront effacées du disque, et seule la version actuelle du fichier restera sur le disque (du point de vue du sous-volume restant). <br><br>  <i>Une courte note</i> : lors du retrait, le caisson de graves disparaîtra instantanément des yeux de l'utilisateur, et l'utilitaire rendra le contrôle au terminal, cependant, les données sur le disque seront nettoyées par le processus d'arrière-plan pendant un certain temps.  Autrement dit, contrairement à la suppression d'un répertoire normal, il n'est pas nécessaire d'attendre la fin réelle de l'opération de suppression.  Si vous devez vous synchroniser avec ce processus et attendre qu'il se termine, vous pouvez spécifier le <code>--commit-after</code> lors de l'appel de la <b>suppression</b> .  La commande <b>btrfs subvolume list</b> , <b>invoquée</b> avec le commutateur <code>-d</code> , affiche une liste des sous-volumes qui ont été supprimés par l'utilisateur et sont en train d'être supprimés du disque. <br><br>  De plus, btrfs vous permet de cloner des fichiers sur le système de fichiers sans avoir recours à des instantanés.  Cela se fait en copiant régulièrement avec l' <code>--reflink</code> : <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  La <code>reflink=always</code> indique au système de fichiers que nous voulons utiliser le mécanisme CoW lors de la copie.  Après la copie, les fichiers peuvent être modifiés indépendamment les uns des autres, de sorte que nous obtenons le même comportement qu'après la création d'un instantané.  Alors pourquoi avons-nous besoin de sous-bols? <br><br>  Les sous-volumes sur btrfs jouent le rôle d'un outil de contrôle de haut niveau pour des ensembles de données entiers: d'une part, il s'agit de la suppression d'instantanés atomiques de toutes les données d'un sous-volume (dans le cas où --reflink atomicity n'est qu'au niveau du fichier), et d'autre part, il est possible de voir de qui il est hérité ou «restaurez» rapidement l'ensemble de données dans une version antérieure, etc. <br>  Ainsi, btrfs offre la possibilité de capturer les états des fichiers aux moments souhaités, en utilisant le sous-volume comme moyen de haut niveau pour gérer ces états. <br><br><h1>  Récupération de sous-volume </h1><br>  Dans les vastes étendues, la question se pose souvent: "J'ai un subwoofer, j'ai un instantané, comment faire un reverse?"  Cette approche n'est pas applicable à btrfs, car  il n'y a aucune possibilité de "faire reculer le sous-chariot".  Au lieu de cela, btrfs propose une stratégie pour remplacer le sous-chariot par son instantané.  En effet, pourquoi revenir sur quelque chose, si l'instantané lui-même est cet objet que nous voulons obtenir avec revenir. <br><br>  Imaginez ce scénario: sur btrfs il y a un sous-volume dans lequel se trouvent les fichiers d'une base de données (enfin, ou d'autres données importantes).  Les instantanés sont périodiquement supprimés de ce sous-volume et, à un moment donné, il est nécessaire de restaurer les données.  Dans ce cas, nous nous débarrassons simplement du sous-groupe et commençons à la place à utiliser l'instantané qui en est extrait, ou - si nous ne voulons pas gâcher ces données également - nous supprimons un autre instantané de l'instantané.  Si le sous-monde d'origine n'a pas été monté et utilisé comme répertoire normal, il doit alors être supprimé ou déplacé / renommé, et un instantané doit être mis à sa place. <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br>  Dans la console, cela pourrait ressembler à ceci: <br><br><ul><li>  renommer la subwolly <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li>  mettre son instantané à la place du sous-volume <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br>  Si le sous-volume a été monté et utilisé via le point de montage, il suffit de démonter le sous-volume et de monter un instantané à sa place. <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li>  Démontez le caisson de basses <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li>  Vous pouvez créer un instantané d'un instantané afin de ne pas gâcher les dernières données survivantes: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li>  montage instantané: <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br>  Pour être complet, je vais réessayer et un peu différemment.  Le sous-volume dans lequel les changements se produisent est la branche <i>principale</i> . <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br>  Lors de la création d'un instantané, l'état des fichiers sur le disque est fixe.  Désormais, un instantané est un brunch de la branche <i>principale</i> .  Toutes les autres modifications apportées à <i>main principale</i> n'affecteront en aucun cas l'instantané.  Revenir à l'instantané signifie arrêter l'utilisation de la branche <i>principale</i> et passer complètement au brunch.  La branche <i>principale</i> peut être supprimée car inutile.  Ainsi, btrfs est pratiquement un système de contrôle de version, mais sans possibilité de fusionner les branches. <br><br><h1>  Arborescence du système de fichiers </h1><br>  L'un des points non évidents associés à l'utilisation de btrfs est de savoir comment diviser les données système en sous-volume.  Bien sûr, il n'y a pas de «bonne» approche à ce problème.  Mais il y a 3 façons d'organiser la structure du sous-volume: une structure plate, imbriquée et mixte. <br><br>  Une structure plate signifie que le sous-volume est placé dans une liste plate dans le sous-volume racine.  Par exemple, vous pouvez sélectionner la racine du système de fichiers (appelons-la <i>root</i> ), le répertoire utilisateur <i>home</i> , le répertoire avec le site <i>/ var / www</i> et la base de données située par exemple dans <i>/ var / database</i> comme sous-volumes séparés. <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br>  Pour plus de commodité, certains sous-volumes peuvent être placés dans des répertoires, comme, par exemple, dans le cas du sous-volume <i>var / www</i> . <br><br>  Avec cette approche, tous les sous-volumes doivent être montés.  Le sous- <i>root</i> doit avoir un point de montage /, et à l'intérieur il doit contenir les répertoires <i>home</i> et <i>var</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après le </font><font style="vertical-align: inherit;">montage de </font><font style="vertical-align: inherit;">la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">racine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maison /</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit être installé sabvolyum la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maison</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et dans le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e - sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de </font><font style="vertical-align: inherit;">données</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respectivement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, l'arborescence de btrfs-subvolume peut être affichée arbitrairement dans le système de fichiers virtuel de l'OS, et il y en a déjà assez pour cela.</font></font><br><br>  Avantages: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l'utilisateur ne voit que le sous-volume monté, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il est facile de remplacer le subwoofer (démonter l'un, monter l'autre), </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> subwoofer facile à retirer. </font></font><br></li></ul><br>  Inconvénients: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il est facile de se demander où l'installer, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour chaque sous-volume, il devrait y avoir une entrée dans fstab, et s'il y a des «rollbacks» aux instantanés, alors les entrées correspondantes dans fstab doivent également être mises à jour. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La structure imbriquée du sous-volume suggère une utilisation simple du sous-volume au lieu de certains répertoires. </font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, en plus du sous-volume racine, rien de plus n'est requis pour être monté.</font></font><br><br>  Avantages: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tous les sous-volumes sont visibles, la structure est facile à percevoir, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous n'avez plus besoin de monter quoi que ce soit, tout est comme avec un système de fichiers «normal». </font></font><br></li></ul><br>  Inconvénients: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tous les sous-volumes sont visibles, peut-être que certains voudraient se cacher de l'utilisateur, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il est difficile de retirer / remplacer le sous-loup (la raison en est les sous-loups imbriqués). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, la troisième approche est mixte. </font><font style="vertical-align: inherit;">Il implique une combinaison des deux premiers pour maximiser les avantages des deux. </font><font style="vertical-align: inherit;">Cependant, il est possible que cette approche particulière conduise à une structure complexe, difficile à modifier et confuse avec un grand nombre d'entrées dans fstab. </font><font style="vertical-align: inherit;">Tout dépend de la </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobriété</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'administrateur système.</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajouter / retirer un disque, équilibrer </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btrfs possède d'excellentes fonctionnalités - la possibilité d'ajouter des périphériques bloqués à chaud directement pendant le fonctionnement du système de fichiers: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou supprimez: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, dans un seul appel d'ajout / suppression, vous pouvez spécifier plusieurs disques. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois, le chemin spécifié est le chemin vers tout sous-volume de ce btrfs auquel la commande sera appliquée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifions le nombre et les périphériques de blocs contrôlés par btrfs:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le champ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisé</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous indique que le disque ajouté est vide. </font><font style="vertical-align: inherit;">Pour le remplir de données en fonction du profil d'enregistrement, vous devez équilibrer:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redistribue les données sur les disques en fonction du profil d'enregistrement sélectionné. Par exemple, dans le cas de RAID1, l'équilibre entraînera le clonage des données du périphérique d'origine, dans le cas de RAID0, cela conduira à une distribution plus uniforme des données sur deux disques, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de l'équilibre, si auparavant il y avait des vides sur le disque, les données sur le disque seront écrites de manière plus dense, c'est-à-dire la défragmentation se révélera. Cependant, il est important de comprendre qu'il ne s'agit pas exactement de «cette» défragmentation. Dans ce cas, la commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne regarde pas le contenu logique, mais ne fonctionne que sur les blocs de données. Elle ne fait pas attention au fait qu'un fichier soit étalé sur le disque. Au lieu de cela, le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transfère les blocs de données d'un endroit à un autre.</font></font> C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un fichier fragmenté pour équilibrer restera fragmenté après lui. Mais! La fragmentation au niveau des blocs de données continuera de diminuer, et cela peut être utilisé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour éviter toute confusion, disons ceci: l'opération d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">équilibrage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> réduit la fragmentation au niveau des blocs de données, mais n'affecte pas la fragmentation des fichiers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la commande de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offre la possibilité de modifier le profil d'enregistrement. Par exemple, le profil DUP a été utilisé sur le disque, et après avoir ajouté le disque, ils ont décidé de faire un RAID1 complet. Pour ce faire, utilisez le filtre </font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'aide des options </font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et, de </font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveaux profils d'enregistrement sont définis pour les données et les métadonnées, respectivement. </font><font style="vertical-align: inherit;">Il existe également l'option -sconvert, qui est conçue pour modifier le profil d'écriture des données système, mais vous devrez également ajouter le commutateur -f (--force) avec lui pour forcer l'opération.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, l'objectif principal des filtres est de définir les règles de l'opération d'équilibrage: quels blocs traiter et lesquels ne pas toucher. </font><font style="vertical-align: inherit;">Ainsi, par exemple, vous ne pouvez affecter que des blocs enregistrés avec un profil d'enregistrement spécifique (profils de filtre), ou des blocs occupés au-dessus d'un certain pourcentage (filtre d'utilisation), ou vous ne pouvez affecter que des groupes de blocs liés à un disque particulier (filtre dévid), etc. </font><font style="vertical-align: inherit;">À propos, ils peuvent toujours être combinés. </font><font style="vertical-align: inherit;">En général, les capacités des filtres sont très étendues et sont principalement nécessaires pour effectuer un équilibre sélectif des données.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, btrfs, en raison de son architecture, est extrêmement sensible à un phénomène tel que la fragmentation. </font><font style="vertical-align: inherit;">Le fait est que les données sont toujours écrites dans un nouvel emplacement sur le disque. </font><font style="vertical-align: inherit;">Même si vous lisez le fichier, ne faites rien avec les données et réécrivez-les dans le même fichier, les données iront dans une nouvelle zone sur le disque. </font><font style="vertical-align: inherit;">La même chose se produit si vous ne mettez à jour que partiellement les données du fichier - les modifications sont écrites dans une nouvelle zone du disque. </font><font style="vertical-align: inherit;">Ainsi, les changements fréquents de fragments de fichiers très fortement, augmentant la «dispersion» des fragments, dans le cas général, sur plusieurs disques. </font><font style="vertical-align: inherit;">Cela entraîne une charge accrue sur le processeur et une consommation de mémoire inutile. </font><font style="vertical-align: inherit;">Les plus fragmentés sont les bases de données et les images de machines virtuelles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez évaluer la fragmentation des fichiers à l'aide de l'utilitaire </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filefrag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (non inclus dans btrfs-progs). </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il indique le nombre d'extensions utilisées pour stocker le fichier. </font><font style="vertical-align: inherit;">Autrement dit - moins il y a d'extensions, moins le fichier est fragmenté. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux méthodes pour lutter contre la fragmentation sur btrfs: la défragmentation et l'indicateur </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La défragmentation peut être appliquée à un seul fichier ou à un sous-volume / répertoire, y compris récursivement. </font><font style="vertical-align: inherit;">La commande est la suivante:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je dois dire que cette équipe ne conduit pas toujours aux résultats escomptés. </font><font style="vertical-align: inherit;">Les petits fichiers légèrement fragmentés (10 à 20 extensions) après la défragmentation peuvent être divisés en plusieurs parties. </font><font style="vertical-align: inherit;">De plus, la défragmentation btrfs sur certaines versions du noyau rompt la déduplication des fichiers, ce qui en fait de véritables copies physiques.</font></font> C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les instantanés au niveau physique deviendront des copies complètes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième façon de lutter contre la fragmentation consiste à utiliser un attribut de fichier </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'attribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut être défini que sur un fichier nouveau ou vide. </font><font style="vertical-align: inherit;">Il désactive le mécanisme de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copie en écriture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc btrfs fonctionnera toujours avec une zone de disque fixe lors de la mise à jour du contenu d'un fichier, en écrivant des données sur celles existantes (au niveau physique). </font><font style="vertical-align: inherit;">Parmi les inconvénients de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il désactive également la vérification de la somme de contrôle pour ce fichier. </font><font style="vertical-align: inherit;">En d'autres termes, pas de vache - pas de somme de contrôle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, définissez manuellement l'attribut</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque fichier est une tâche ingrate. Si cet indicateur du répertoire / sous-volume est défini, tous les nouveaux fichiers créés dans celui-ci hériteront automatiquement de l'indicateur. Il en va de même pour les répertoires imbriqués créés. Si au moment où l'attribut a été activé, des données étaient déjà dans le répertoire, cela ne les affectera en aucune façon - l'attribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut être défini que dans un fichier nouveau ou vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et une autre façon de définir l'indicateur automatiquement </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est de monter le système de fichiers avec l'option </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette option entraînera la connexion automatique de l'option </font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de sorte que pour les fichiers nouvellement créés, les sommes de contrôle ne seront pas calculées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme d'habitude, il y a une nuance: vous ne pouvez pas monter un seul subwoofer avec une option </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Soit tous les sous-volumes auront une option </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, soit aucune. Tout est décidé par le premier sous-volume monté: si une option était spécifiée </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tous les montages suivants iront automatiquement avec cette option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un moment non évident se produit si vous placez un indicateur sur un fichier </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et supprimez l'instantané du sous-volume dans lequel se trouve ce fichier. Dans ce cas, btrfs ignore l'indicateur </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si plusieurs sous-volumes font référence au bloc de données mis à jour. Par conséquent, malgré le drapeau</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(par ailleurs, le fichier en héritera également dans l'instantané), les modifications apportées à l'un des fichiers iront dans une nouvelle zone sur le disque et le fichier sera à nouveau fragmenté. </font><font style="vertical-align: inherit;">Si le bloc de données du fichier est mis à jour plusieurs fois, la première fois, il tombera dans une nouvelle zone sur le disque et, avec les entrées suivantes, il sera mis à jour dans cette nouvelle zone «en place».</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Astuces et échecs </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque vous utilisez btrfs-progs, vous pouvez omettre le nom complet de la commande: </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il suffit juste de la coïncidence des premiers caractères, qui déterminent uniquement la commande: </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense que le principe est clair. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hélas, btrfs ne peut pas créer un instantané du répertoire, mais il existe une solution:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> créer un sous-volume </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copiez les fichiers du répertoire dans le sous-volume: </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la clé </font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisera le mécanisme CoW, c'est-à-dire </font><font style="vertical-align: inherit;">les données ne seront pas copiées, mais des liens vers celles-ci seront créés à un btrfs de bas niveau.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, le sous-monde contient tous les fichiers qui se trouvaient dans le répertoire, et vous pouvez en supprimer l'instantané. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pouvez pas définir l' </font><font style="vertical-align: inherit;">attribut sur un </font><font style="vertical-align: inherit;">fichier de données existant. </font><font style="vertical-align: inherit;">Cependant, vous pouvez suivre le chemin suivant:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> créer un fichier vide </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lui mettre un drapeau </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allouer de l'espace disque pour un nouveau fichier </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copier le contenu d'un fichier existant dans </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si btrfs manque d'espace, même la suppression d'un fichier peut provoquer une erreur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Il ne reste plus d'espace sur le périphérique»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour la solution, il est recommandé de connecter un lecteur temporaire avec des tailles de préférence d'au moins 1 Go à btrfs. </font><font style="vertical-align: inherit;">Nettoyez ensuite les données. </font><font style="vertical-align: inherit;">Retirez ensuite le lecteur temporaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'opération d' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">équilibrage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , invoquée sans spécifier de profils d'écriture, les fait implicitement passer de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce qui est d'ailleurs écrit sur la page </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela se produit après l'ajout du disque à btrfs, qui utilise le profil d'écriture </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Rappelez-vous que le formatage d'un seul lecteur dans btrfs utilise le profil de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par défaut pour les métadonnées et les données système.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peut-être le plus important </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Évitez de créer des clones de bas niveau de périphériques de blocs avec btrfs. Étant un système de fichiers «intelligent», pour certaines opérations (le plus souvent, lors du montage), btrfs relit les données système sur les périphériques de bloc par lui-même pour trouver toutes les parties du système de fichiers. Si deux périphériques de bloc avec les mêmes UUID sont trouvés dans le processus de recherche, alors btrfs les acceptera comme faisant partie de la même instance. Si, cependant, ces deux périphériques s'avèrent être l'original et son clone, alors après le montage, le pilote seul sait comment le système de fichiers fonctionnera, mais il est clair que cela ne se terminera pas par quelque chose de bon. Dans le pire des cas, cela entraînera une corruption irréversible des données.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous voulez vraiment cloner des disques avec btrfs de manière basique, une extrême prudence doit être prise. </font><font style="vertical-align: inherit;">En général, un clone ne doit pas être visible par le noyau du système d'exploitation en tant que périphérique de bloc tant que l'original est présent dans le système, et vice versa. </font><font style="vertical-align: inherit;">En fournissant cette condition, vous pouvez changer l'UUID du clone (enfin, ou l'original, ici facultatif). </font><font style="vertical-align: inherit;">L'utilitaire </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fourni avec le package </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfs-progs vous aidera à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et encore: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , étant un utilitaire «intelligent», changera l'UUID non seulement sur le disque, mais sur l'ensemble du système de fichiers. </font><font style="vertical-align: inherit;">Cela signifie que lorsqu'elle sera appelée, elle lira tous les périphériques de bloc afin de remplacer l'UUID sur tous les périphériques liés au système de fichiers.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au lieu d'une conclusion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si en ce moment vous ne comprenez rien, c'est normal. Btrfs n'est pas trivial et peut ne pas succomber immédiatement. Chaque fois qu'il me semblait que maintenant je la comprenais, elle me faisait une surprise et lui faisait repenser les choses existantes. Je ne peux pas dire que j'ai tout compris à l'heure actuelle - en train d'écrire, j'ai trouvé quelque chose de nouveau, même si j'ai déjà écrit sur la base de mon expérience. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je comparerais le processus de maîtrise de btrfs avec la transition d'un style de programmation procédural à un style orienté objet. La première impression est «wow, comme c'est génial», mais ensuite vous continuez constamment à écrire du code procédural enveloppé dans des classes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'article, j'ai essayé de ne pas verser d'eau - d'écrire tout sur l'affaire. </font><font style="vertical-align: inherit;">Malgré cela, cela s'est avéré assez volumineux. </font><font style="vertical-align: inherit;">Mais loin de tout, il était possible de le dire - vous pouvez toujours écrire et écrire sur btrfs. </font><font style="vertical-align: inherit;">Cet article n'est que la pointe de l'iceberg. </font><font style="vertical-align: inherit;">Le tout début est de comprendre sa philosophie et de commencer à l'utiliser. </font><font style="vertical-align: inherit;">Et maintenant, il est temps de finir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci d'avoir lu jusqu'au bout. </font><font style="vertical-align: inherit;">J'espère pas fatigué. </font><font style="vertical-align: inherit;">Écrivez dans les commentaires ce que vous aimeriez savoir d'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites des sauvegardes, messieurs. </font><font style="vertical-align: inherit;">Et laissez-les ne jamais vous être utiles.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458250/">https://habr.com/ru/post/fr458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458240/index.html">Comment l'intelligence artificielle, les drones et les caméras assurent la sécurité des routes et des ponts</a></li>
<li><a href="../fr458242/index.html">Le nouvel opérateur de vaisseau spatial en C ++ 20</a></li>
<li><a href="../fr458244/index.html">Une liste interminable et ridicule de ce que vous devez savoir pour utiliser en toute sécurité les réseaux Wi-Fi publics</a></li>
<li><a href="../fr458246/index.html">Coïncidences aléatoires dans la vie, ou comment il s'est avéré qu'on vous a présenté un gâteau dans une usine de tracteurs</a></li>
<li><a href="../fr458248/index.html">Simplifiez votre code avec Rocket Science: l'opérateur de vaisseau spatial de C ++ 20</a></li>
<li><a href="../fr458252/index.html">Modèle mathématique d'un radiotélescope super long</a></li>
<li><a href="../fr458256/index.html">N'est-il pas temps pour le lavage de cerveau?</a></li>
<li><a href="../fr458260/index.html">Une autre façon d'optimiser les images Docker pour les applications Java</a></li>
<li><a href="../fr458262/index.html">Concepteur en ligne de la salle de réunion - sélection de la solution optimale pour la visioconférence</a></li>
<li><a href="../fr458264/index.html">10 principes du code auto-documenté</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>