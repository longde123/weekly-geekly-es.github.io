<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíº üßïüèº üñêÔ∏è Deux Z80 par machine: en quoi les machines d'arcade 8 bits diff√®rent-elles des ordinateurs personnels? üëê üë©üèø‚Äçü§ù‚Äçüë©üèª üîî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce que j'ai appris sur la machine d'arcade Bomb Jack en train de cr√©er son √©mulateur 


 J'ai r√©cemment √©crit un petit √©mulateur pour une machine Bomb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deux Z80 par machine: en quoi les machines d'arcade 8 bits diff√®rent-elles des ordinateurs personnels?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426291/"><h2>  Ce que j'ai appris sur la machine d'arcade Bomb Jack en train de cr√©er son √©mulateur </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ea/be5/eae/7eabe5eaeb49a7c8a77b543628df89bf.png"></div><br>  J'ai r√©cemment √©crit un petit √©mulateur pour une machine Bomb Jack, principalement pour comprendre en quoi ces premi√®res machines d'arcade 8 bits diff√©raient par leur conception des ordinateurs domestiques 8 bits. <br><br>  Comme je l'ai appris beaucoup plus tard, une r√©union dans une foire d'√©t√© dans ma ville natale avec des machines d'arcade comme Bomb Jack a √©t√© l'un de ces moments qui ont chang√© mon destin.  Un jour d'√©t√© normal, apr√®s avoir d√©pens√© toute ma r√©serve de pi√®ces de monnaie sur des machines d'arcade, je suis rentr√© chez moi et ma t√™te √©tait remplie de fleurs et d'effets sonores.  J'ai essay√© de comprendre comment ces jeux fonctionnaient.  Et puis jusqu'√† la fin de l'ann√©e, j'ai pass√© tout mon temps apr√®s l'√©cole √† cr√©er des copies plut√¥t fan√©es de ces jeux d'arcade sur mon ordinateur personnel.  J'√©tais comme un fan du culte du cargo des √Æles de l'oc√©an Pacifique, qui voulait cr√©er une station de radio militaire am√©ricaine √† partir de b√¢tons. <br><br>  Au d√©but, j'ai pens√© √† l'id√©e de cr√©er un √©mulateur <em>Pengo</em> , parce que mon cerveau d'adolescent √©tait beaucoup plus impressionn√© par ce jeu que Bomb Jack (au fait, voici ma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version culte de Pengo</a> ).  Mais l'√©quipement d'arcade Pengo n√©cessiterait la cr√©ation de nouveaux √©mulateurs de puces pour l'audio et la vid√©o, et pour Bomb Jack, il y avait suffisamment de pi√®ces que j'avais d√©j√† (Z80 en tant que CPU et AY-3-8910 pour le son), donc j'ai √©t√© le premier √† prendre Bomb Jack. <br><a name="habracut"></a><br>  De plus, Bomb Jack a √©t√© une excellente occasion d'ajouter enfin le support NMI (interruption non masquable) √† mon √©mulateur Z80.  Aucune des machines bas√©es sur Z80 que j'ai √©mul√©es auparavant n'utilisait NMI, et donc il n'y avait pas grand int√©r√™t √† recr√©er cette fonction - je ne pouvais toujours pas v√©rifier son fonctionnement. <br><br>  Si vous ne savez pas ce qu'est Bomb Jack, alors ce jeu ressemblait √† √ßa (je ne sais pas si j'ai choisi le bon rapport hauteur / largeur): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af7/79a/9ae/af779a9ae761839ee041300bc817c7f6.png" alt="Capture d'√©cran de Bomb Jack"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_jJzasm63DE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La version de l'√©mulateur sur WebAssembly peut √™tre trouv√©e ici: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://floooh.github.io/tiny8bit/bombjack.html</a> <br><br>  Une fois la proc√©dure de chargement termin√©e et le tableau des meilleurs scores affich√©, appuyez sur <strong>1</strong> pour d√©poser une pi√®ce, puis sur <strong>Entr√©e</strong> (ou sur toute autre touche √† l'exception des fl√®ches et de la barre d'espace) pour d√©marrer le jeu. <br><br>  Dans le jeu, utilisez les <strong>touches fl√©ch√©es</strong> pour changer de direction et la <strong>barre</strong> d' <strong>espace</strong> pour sauter.  En l'air, appuyez sur la <strong>barre</strong> d' <strong>espace</strong> pour ralentir la chute. <br><br>  Le code source est ici: <br><br>  <a href="">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a> <br><br>  Il utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des en-t√™tes de puce</a> pour fournir une √©mulation des Z80 et AY-3-8910, ainsi que des en- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√™tes sokol</a> comme un wrapper multiplateforme (pour entrer dans l'application, le rendu, l'entr√©e et le son). <br><br><h2>  √âtape 1: recherche </h2><br>  "Recherche" est un mot trop gros: je viens de cliquer sur "Sp√©cifications mat√©rielles de Bombjack arcade" de Google. <br><br>  Compar√© aux ordinateurs domestiques populaires des ann√©es 80 (ou m√™me aux myst√©rieux ordinateurs d'Europe de l'Est, qui ont souvent encore des communaut√©s actives), il y a tr√®s peu d'informations sur Bomb Jack sur Internet. <br><br>  J'ai trouv√© deux informations tr√®s importantes: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©ma √©lectrique de la</a> machine et, bien s√ªr, le <a href="">code source de l'√©mulateur MAME</a> . <br><br>  Il y a aussi un projet qui impl√©mente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bomb Jack sur FGPA</a> , √† partir des sources VHDL dont j'ai r√©ussi √† trouver des d√©tails qui ne sont pas dans le sch√©ma du circuit. <br><br>  Comprendre le code source de MAME serait d√©licat, car les √©mulateurs de machines d'arcade ne sont g√©n√©ralement qu'un tas de macros d√©crivant comment les diff√©rents √©quipements interagissent, mais il <em>n'y a</em> pas beaucoup de <em>code source</em> . <br><br>  N√©anmoins, les macro descriptions de l'√©quipement, et surtout les commentaires, se sont n√©anmoins r√©v√©l√©s tr√®s utiles pour comprendre le fonctionnement du mat√©riel, et l√† o√π ils sont devenus trop cryptiques (par exemple, la <a href="">partie sur le d√©codage vid√©o</a> ), la m√©thode d'essai et d'erreur √©tait suffisante, ainsi que √©tude d√©taill√©e du concept. <br><br><h2>  Pr√©sentation du mat√©riel </h2><br>  La chose la plus int√©ressante √† propos du mat√©riel Bomb Jack est qu'il s'agit en fait de <strong>deux ordinateurs</strong> connect√©s l'un √† l'autre par un ruban √©lectrique: il y a une <strong>carte principale</strong> avec un processeur Z80 et un √©quipement de d√©codage vid√©o et une <strong>carte son</strong> s√©par√©e avec son propre processeur Z80 et trois (oui, trois!) puces sonores AY-3-8910. <br><br>  L'√©quipement de d√©codage vid√©o n'est pas impl√©ment√© en tant que circuit int√©gr√© - c'est juste beaucoup de petites puces √† usage g√©n√©ral (leur circuit prend 6 pages sur 10 du sch√©ma de circuit de l'appareil).  Lors de la cr√©ation d'un √©mulateur, j'ai d√©cid√© d'aller un peu plus loin: au lieu d'√©muler des parties individuelles de l'√©quipement de d√©codage vid√©o, j'ai √©mul√© uniquement son comportement, cr√©ant la sortie correspondante √† partir des donn√©es d'entr√©e et ne me souciant pas vraiment du fonctionnement de l'√©quipement lui-m√™me au milieu. <br><br>  Une telle solution simplifi√©e est tout √† fait appropri√©e pour une machine d'arcade distincte, con√ßue pour ex√©cuter un seul programme.  Si le jeu d√©marre et fonctionne correctement, l'√©mulation peut √™tre consid√©r√©e comme "assez bonne". <br><br>  De plus, cette approche simplifi√©e est une diff√©rence importante par rapport √† l'√©mulation de la plupart des ordinateurs personnels: certains jeux n√©cessitent une √©mulation plus pr√©cise que d'autres, par exemple, des machines telles que C64 ou Amstrad CPC n√©cessitent une √©mulation tr√®s pr√©cise jusqu'√† des cycles d'horloge, de sorte que les syst√®mes vid√©o de certains jeux et graphiques les d√©mos fonctionnaient correctement. <br><br>  Cela signifie √©galement que mes √©mulateurs de processeur et de puce audio pr√™ts √† l'emploi sont en fait superflus pour Bomb Jack, par exemple, travailler avec des processeurs Z80 avec la mise en ≈ìuvre de la fractionnalit√© du cycle machine est une exag√©ration, une fragmentation plus simple et plus rapide au niveau de l'instruction suffirait. <br><br><h2>  Carte principale </h2><br>  Habituellement, la premi√®re chose que j'essaie de d√©couvrir lors de l'√©criture d'un nouvel √©mulateur est le sch√©ma d'allocation de m√©moire (o√π sont les zones de ROM et de RAM, de m√©moire vid√©o et d'adresses sp√©ciales ou de ports d'entr√©e / sortie). <br><br>  Il n'y a qu'une seule puce ¬´int√©ressante¬ª sur la carte principale de Bomb Jack - le CPU Z80 fonctionnant √† 4 MHz.  Tout l'espace restant sur la carte principale est occup√© par un √©quipement de d√©codage vid√©o (√† l'exception d'une paire de puces RAM et ROM). <br><br>  L'espace d'adressage 16 bits est le suivant: <br><br><ul><li>  <strong>0000..7FFF</strong> : 32 Ko de ROM </li><li>  <strong>8000..8FFF</strong> : 4 Ko de RAM √† usage g√©n√©ral </li><li>  <strong>9000..93FF</strong> : 1 Ko de m√©moire vid√©o </li><li>  <strong>9400..97FF</strong> : 1 Ko de RAM couleur </li><li>  <strong>9820..987F</strong> : 96 octets de RAM sprite </li><li>  <strong>9C00..9CFF</strong> : 256 octets de palette de couleurs RAM </li><li>  <strong>9E00, B000..B005, B800</strong> : ports d'entr√©e-sortie </li><li>  <strong>C000..DFFF</strong> : ROM 8 <strong>Ko</strong> </li></ul><br>  La zone du port d'E / S est la suivante.  Certains ports sont en √©criture seule, certains sont en lecture seule et certains ont des fonctions diff√©rentes lors de la lecture et de l'√©criture: <br><br><ul><li>  <strong>9E00</strong> : √©criture: num√©ro de l'image d'arri√®re-plan actuelle, lecture: - </li><li>  <strong>B000</strong> : lecture: √©tat du joystick du lecteur 1, √©criture: activation / d√©sactivation du masque NMI </li><li>  <strong>B001</strong> : lire: √©tat du joystick du joueur 2, √©crire: - </li><li>  <strong>B002</strong> : lire: pi√®ces et boutons D√©marrer, √©crire: - </li><li>  <strong>B003</strong> : lire: chien de garde CPU, √©crire: ??? </li><li>  <strong>B004</strong> : lecture: commutateurs DIP 1, √©criture: √©cran de commutation </li><li>  <strong>B005</strong> : lire: dip switches 2, √©crire: - </li><li>  <strong>B800</strong> : √©criture: commande carte son, lecture: - </li></ul><br>  Les √©l√©ments suivants m√©ritent d'√™tre mentionn√©s ici: <br><br><ul><li>  L'appareil a BEAUCOUP de ROM (40 Ko) et tr√®s peu de RAM (environ 7 Ko, et seulement 4 Ko sont de la ¬´RAM √† usage g√©n√©ral¬ª) </li><li>  Seulement 2 kilo-octets sont allou√©s pour la "RAM de l'affichage", divis√©e en deux fragments de 1 kilo-octet, ce qui semble tr√®s petit pour un √©cran couleur 256x256, dans lequel, il semble, les couleurs sont d√©finies pixel par pixel </li><li>  Il s'agit d'un syst√®me d'E / S dans un sch√©ma d'allocation de m√©moire! </li></ul><br>  Les E / S dans le sch√©ma d'allocation de m√©moire sont un peu inhabituelles pour une machine Z80, car l'une des caract√©ristiques du Z80 est son espace d'adressage 16 bits s√©par√© pour les E / S.  Ceci est fait pour √©conomiser de l'espace d'adressage m√©moire pr√©cieux.  Les E / S dans un sch√©ma d'allocation de m√©moire se trouvent g√©n√©ralement dans les ordinateurs √©quip√©s d'un processeur 6502. <br><br>  Un coup d'≈ìil au sch√©ma √©lectrique le confirme: la broche IORQ n'est pas d√©tect√©e sur le CPU de la carte principale, seule la broche MREQ est connect√©e (qui sert √† initialiser la lecture ou l'√©criture en m√©moire): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/99e/3d8/a5899e3d8384702517d0c7fe6c0de436.png" alt="Bomb Jack IORQ"></div><br>  Cela signifie que nous n'avons pas √† nous soucier des demandes d'E / S pour la fonction de minuterie CPU de la carte principale dans l'√©mulateur, mais seulement √† traiter les demandes de m√©moire. <br><br>  Apr√®s avoir √©tudi√© le sch√©ma de circuit, j'ai trouv√© un autre d√©tail int√©ressant sur le CPU de la carte principale: <br><br>  Seule la broche NMI est connect√©e, tandis que la broche INT maintient toujours un haut niveau de signal d'horloge / elle reste inactive (cela signifie que les interruptions masqu√©es "normales" ne sont pas ex√©cut√©es et que seules des interruptions non masqu√©es se produisent): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/acf/cb8/393acfcb88d846cc868e2fa0e490fbbd.png" alt="Bomb Jack IORQ"></div><br>  C'est √©galement assez inhabituel pour une voiture avec la Z80.  Dans tous les ordinateurs personnels bas√©s sur Z80 avec lesquels je faisais face, l'inverse √©tait vrai - ils n'utilisaient que des interruptions masquables et jamais des non masquables.  L'interruption masqu√©e Z80 est une am√©lioration tr√®s flexible et s√©rieuse par rapport au syst√®me d'interruption primitif de son ¬´p√®re ill√©gitime¬ª - Intel 8080, ou son concurrent - MOS 6502. Mais cette flexibilit√© accrue est en m√™me temps plus difficile √† mettre en ≈ìuvre dans les √©quipements (sauf comme source d'interruptions) d'autres puces de la famille Z80 sont utilis√©es, dans lesquelles il existe d√©j√† un protocole d'interruption complexe int√©gr√© lorsqu'elles sont connect√©es par bus). <br><br>  Eh bien, assez de d√©tails sur l'√©quipement, passons √† l'√©mulateur! <br><br><h2>  Proc√©dure de d√©marrage </h2><br>  L'√©tape suivante apr√®s avoir d√©termin√© la configuration de la m√©moire consiste √† connecter le processeur √©mul√© au sch√©ma d'allocation de m√©moire √©mul√©, √† enregistrer une sorte de visualisation du contenu de la m√©moire vid√©o et √† d√©marrer les cycles du processeur. <br><br>  √âtonnamment, une telle approche approximative est souvent suffisante pour passer par la proc√©dure de chargement et afficher <em>quelque chose</em> √† l'√©cran.  Lors de la conception de l'√©mulateur Bomb Jack, je viens de prendre le contenu de la m√©moire vid√©o de 1 Ko dans la plage de 0x9000 √† 0x93FF en tant que matrice 32x32 octets.  Lorsque l'octet √©tait 0, j'ai rendu un bloc de pixels noirs 8x8, et sinon - un bloc de pixels blancs. <br><br>  Ensuite, j'ai simplement ex√©cut√© le processeur √©mul√© et esp√©r√© le meilleur.  Voici!  Une sorte d'image lisible est apparue: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17d/7c2/198/17d7c2198881dbfd40978e26d832aaca.png" alt="Bomb jack boot 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3b/e04/b97/d3be04b970ff2c8b5905ed3f7f757a51.png" alt="Bombe jack boot 2"></div><br>  L'image du haut ressemble √† un √©cran de test mat√©riel au d√©marrage, et le bas ressemble √† un √©cran d'enregistrement de score qui appara√Æt une fois la proc√©dure de d√©marrage termin√©e: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f6/5ae/4b9/0f65ae4b9d00fa43e2da7582b9ceb5f3.png" alt="Bombe jack boot 3"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/649/5c8/db1/6495c8db1d035484ef03e32902f28cdf.png" alt="Bomb Jack Boot 4"></div><br>  ... mais tourn√© de 90 degr√©s (ce qui est logique, car l'√©cran des machines d'arcade √©tait souvent dans une orientation verticale "portrait"). <br><br>  G√©nial, le d√©but est prometteur! <br><br>  L'√©tape suivante consiste √† comprendre comment transformer ces blocs blancs en pixels de couleur ... (et c'est une √©tape √©norme, les d√©tails sont d√©crits ci-dessous dans la section sur le d√©codage vid√©o). <br><br>  Au d√©but, tout s'est pass√© assez rapidement, sur l'√©cran de test, les pixels et les couleurs √©taient affich√©s pendant le chargement (plus tard j'ai remarqu√© que le d√©codage des couleurs √©tait compl√®tement faux, et pourtant ...): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ecd/757/2c3ecd757e603194698f6f93b71e3127.png" alt="Bombe jack boot 5"></div><br>  Mais quand l'√©cran d'enregistrement devait appara√Ætre, j'ai eu un √©cran noir.  En piratant la couleur d'arri√®re-plan pour qu'elle ne soit ¬´pas noire¬ª, j'ai trouv√© que les pixels sont rendus, mais toute la palette de couleurs est noire.  Hmm ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e81/dac/2e4/e81dac2e4796b7bf90d43a711a52f37e.png" alt="Bombe jack boot 5"></div><br>  Apr√®s avoir regard√© cet √©cran pendant quelques minutes, je me suis souvenu que certaines des couleurs de l'√©cran des meilleurs scores √©taient anim√©es, et lorsqu'il y a animation, il devrait y avoir une sorte de minuteur.  La source logique de temps dans cette configuration d'√©quipement est le signal d'affichage VSYNC, et VSYNC est connect√© √† la broche NMI du CPU (ou plut√¥t, non VSYNC, mais VBLANK, qui est le bref instant entre le signal VSYNC et le faisceau de rayons cathodiques se d√©pla√ßant vers le coin sup√©rieur gauche). <br><br>  Et je n'ai pas encore impl√©ment√© tout √ßa ... <br><br>  Le lendemain soir, lorsque j'ai ajout√© la premi√®re version du traitement NMI √† l'√©mulation Z80 et que je l'ai connect√©e au premier compteur vsync / vblank dans la fonction de minuterie CPU de la carte principale, beaucoup de choses ont soudainement commenc√© √† se produire! <br><br>  Tout d'abord, des couleurs sont apparues sur l'√©cran des enregistrements, et certaines d'entre elles ont √©t√© anim√©es: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/163/661/72d/16366172d4eb6b8e2342acbbd74a64ac.png" alt="Bomb Jack NMI 1"></div><br>  Apr√®s quelques secondes, quelque chose d'encore plus excitant a commenc√©!  Le meilleur score a disparu et une √©trange visualisation de la premi√®re carte a √©t√© affich√©e.  Il √©tait clair qu'il s'agit d'un mode de d√©monstration d'une machine d'arcade pour attirer l'attention - j'ai vu plusieurs bombes avec des animations en couleur qui ont disparu lorsqu'un Bomb Jack imaginaire a saut√© sur une carte rassemblant ces bombes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/cd6/81d/d60cd681dedbdfbf4329410e0014f9f0.png" alt="Bomb Jack NMI 2"></div><br>  Les couleurs √©taient encore compl√®tement fausses, et pourtant c'est du PROGR√àS! <br><br>  C'est le bon moment pour faire le reste du d√©codage vid√©o: <br><br><h2>  Fer √† repasser vid√©o </h2><br>  √Ä premi√®re vue, l'√©quipement de traitement vid√©o de Bomb Jack semblait tr√®s puissant pour une machine 8 bits de 1984: malgr√© la r√©solution de seulement 256x256 pixels, il pouvait afficher simultan√©ment 128 (sur 4096) couleurs et rendre jusqu'√† 24 images-objets mat√©rielles (de 16 x 16) ou 32x32) avec une couleur pixel par pixel. <br><br>  Les ordinateurs personnels 8 bits de l'√©poque avaient √† peu pr√®s la m√™me r√©solution d'affichage, mais ils avaient de nombreuses restrictions de couleurs.  Ces restrictions sont tr√®s clairement visibles lorsque l'on compare les versions Bomb Jack pour le ZX Spectrum et Amstrad CPC avec la version pour la machine d'arcade: <br><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version du ZX Spectrum</a> avait une assez bonne r√©solution en pixels (256x192), mais tr√®s peu de couleurs, et elle souffrait de l'effet typique de ¬´conflit de couleurs¬ª de Spectrum (bien que les d√©veloppeurs aient fait de leur mieux pour que ce ne soit pas trop perceptible): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/176/fff/46d176fffb8404ad696883849dd880d1.png" alt="Bomb jack zx"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version pour Amstrad CPC est</a> plus en couleur, mais pour obtenir plus de couleurs, les d√©veloppeurs ont d√ª passer au mode d'affichage basse r√©solution (160x200).  √Ä la suite de cela, Jack et les monstres se sont transform√©s en un groupe illisible de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f33/3d8/bbdf333d8e4d8d44735047f99e53b49c.png" alt="Bomb jack cpc"></div><br>  Comparez cela avec la version de la machine d'arcade, qui avait la m√™me r√©solution en pixels que le ZX Spectrum, mais avec beaucoup plus de couleurs <em>et</em> une r√©solution de couleur pixel par pixel accrue: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/ac5/69f/112ac569f11f32d6c1ed4836bb8c2b51.png" alt="Bomb jack arcade"></div><br>  Ce qui est int√©ressant ici, c'est que la version arcade a de meilleurs graphismes, non pas parce qu'elle fonctionne sur un mat√©riel plus puissant (elle a plus de ROM pour stocker plus de donn√©es graphiques, mais la "puissance de calcul" est √† peu pr√®s la m√™me), mais parce que les d√©veloppeurs de l'appareil pourraient se concentrer sur la fabrication d'une machine sp√©cialis√©e pour un type sp√©cifique de jeu et ils n'avaient pas besoin de cr√©er un ordinateur domestique universel √† usage g√©n√©ral. <br><br>  Voici comment fonctionne le mat√©riel d'affichage (du moins dans mon interpr√©tation de haut niveau): <br><br><h2>  Trois couches d'affichage </h2><br>  Le signal vid√©o Bomb Jack fini est combin√© √† partir de trois couches: une couche d'arri√®re-plan, une couche avant et une couche sprite. <br><br>  Un tel syst√®me de couches pr√©sente deux avantages principaux: <br><br><ul><li>  Il impl√©mente une compression d'image mat√©rielle assez d√©licate pour g√©n√©rer une image couleur ¬´haute r√©solution¬ª √† partir d'une tr√®s petite quantit√© de donn√©es. </li><li>  Il r√©duit consid√©rablement la quantit√© de travail CPU n√©cessaire pour mettre √† jour les √©l√©ments d'√©cran dynamiques (m√™me √† une fr√©quence de 4 MHz, un CPU 8 bits n'a pas assez de puissance pour d√©placer autant d'objets sur un √©cran 256x256 avec une fr√©quence de 60 Hz) </li></ul><br>  Le fer √† repasser vid√©o est assez diff√©rent de ce que j'ai vu dans les ordinateurs personnels 8 bits, mais MAME impl√©mente des classes d'aide g√©n√©ralis√©es pour ce type d'√©quipement, donc je peux supposer qu'il est assez courant dans les machines d'arcade. <br><br><h3>  Couche d'arri√®re-plan </h3><br>  La couche d'arri√®re-plan peut restituer 1 image d'arri√®re-plan sur 5 int√©gr√©e dans la ROM.  L'image d'arri√®re-plan est s√©lectionn√©e en √©crivant une valeur de 1 √† 5 √† l'adresse 0x9E00 (il semble que la valeur 0 soit sp√©ciale et rend un arri√®re-plan compl√®tement noir). <br><br>  En fait, il semble que l'√©quipement soit capable de restituer 7 images diff√©rentes, mais seulement 5 sont utilis√©es dans le jeu. J'esp√©rais secr√®tement trouver des donn√©es d'image pr√©c√©demment non d√©tect√©es dans la ROM.  Mais h√©las, ils ne sont pas l√† (oui, je ne suis probablement pas le premier √† les chercher l√†-bas). <br><br>  Voici √† quoi ressemble la couche d'arri√®re-plan de la premi√®re carte sans les deux autres couches: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/75a/2c7/afe75a2c7386bb48fb3e90e2a24a655e.png" alt="Fond de cric de bombe"></div><br>  La couche d'arri√®re-plan est assembl√©e √† partir de carreaux <strong>16x16</strong> pixels. <br><br>  L'avantage de cr√©er des images d'arri√®re-plan √† partir de tuiles est que les m√™mes tuiles peuvent √™tre utilis√©es plusieurs fois, donc moins de donn√©es peuvent √™tre stock√©es dans la ROM.  Notez que le ciel bleu, des parties de la pyramide et du sable sous la pyramide utilisent les m√™mes tuiles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/613/0ee/4226130ee4b597ccbeccebbce664dbdf.png" alt="Tuiles de fond de bombe jack"></div><br>  Pour √©conomiser de la m√©moire, l'√©quipement de couche d'arri√®re-plan impl√©mente encore une autre astuce - les tuiles peuvent √™tre tourn√©es horizontalement.  J'ai failli manquer cela dans mon impl√©mentation car j'ai suppos√© que le logiciel n'utilisait pas cette fonction mat√©rielle, mais j'ai remarqu√© un petit bug en arri√®re-plan de la troisi√®me carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/397/d5c/22d397d5c5b984b8a7b1e7c53e5abd34.png" alt="Fond de prise de bombe 3"></div><br>  J'ai utilis√© la m√™me astuce sur la cinqui√®me carte, mais ici, c'est un peu plus difficile √† remarquer si vous ne savez pas quoi chercher: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/82d/430/4af82d430deab8804a795ac9fb142b87.png" alt="Fond de prise de bombe 5"></div><br><br><h3>  Couche avant: </h3><br>  Au-dessus de la couche d'arri√®re-plan se trouve la "couche avant", qui rend toutes les parties fixes de l'√©cran, qui doivent n√©anmoins √™tre mises √† jour par le CPU (principalement du texte, des plates-formes et des bombes).  La disposition est lue √† partir de la RAM (√† partir de fragments de 1 Ko de RAM et de 1 Ko de RAM couleur). <br><br>  Voici √† quoi ressemble la couche avant isol√©e de la premi√®re carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/5ac/fa8/8745acfa89c446ba9b5a9d9e719c8d31.png" alt="Plan de Bomb Jack Premier"></div><br>  La couche avant est √©galement constitu√©e de tuiles (ainsi que de l'arri√®re-plan), mais elle utilise des tuiles 8x8 plus petites: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/e26/f94/5a9e26f94d1d9e0df0f50f4f1d1beb78.png" alt="Tuiles de fond de bombe jack"></div><br>  Le principal avantage de diviser l'arri√®re-plan et l'avant en couches distinctes est que le CPU n'a pas √† se soucier du stockage et de la restauration des pixels d'arri√®re-plan lors de la cr√©ation ou de la suppression d'√©l√©ments avant. <br><br><h3>  Couche de sprite </h3><br>  Enfin, les sprites mat√©riels sont rendus sur la couche avant.  Tout ce qui se d√©place sur l'√©cran est impl√©ment√© dans les sprites.  L'√©quipement Bomb Jack peut rendre jusqu'√† 24 images-objets, et chaque image-objet peut avoir une taille de 16x16 ou 32x32 pixels.  Dans ce cas, les sprites peuvent √™tre positionn√©s avec une pr√©cision pixel par pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/66e/5a0/27666e5a0a266d28babf72dafe2e66bc.png" alt="Bombe sprites jack"></div><br><br><h2>  D√©codeur de tuiles 8x8 </h2><br>  Au c≈ìur de l'√©quipement de d√©codage vid√©o se trouve une palette de couleurs avec 128 √©l√©ments et un d√©codeur de tuiles de 8x8 pixels.  La t√¢che du d√©codeur de tuiles est de g√©n√©rer un index de palette de couleurs √† 7 bits pour chacun des 64 pixels de la tuile. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces tuiles 8x8 sont les blocs de construction pour tout ce qui est √† l'√©cran - tuiles de fond 16x16, tuiles de couche avant 8x8 et sprites mat√©riels 16x16 ou 32x32. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un sch√©ma de principe de ce d√©codeur de tuiles 8x8 pour le rendu de la couche avant (si j'ai bien compris):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/d6e/5d9/e79d6e5d9b5019923a37bc14658e8ec4.jpg" alt="Bomb Jack Tile Decoding"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explication du diagramme de haut en bas: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de d√©codage commence en haut par la lecture de l'octet du ¬´code de tuile¬ª de la m√©moire vid√©o (organis√© comme une matrice de codes de tuile 32x32) et un octet s√©par√© de la RAM couleur (√©galement une matrice 32x32). </font><font style="vertical-align: inherit;">L'obtention des codes de tuiles et de couleurs de la m√©moire vid√©o ne se produit que pour la couche avant, mais je l'ai ajout√©e pour rendre l'image dans son ensemble plus compr√©hensible. </font><font style="vertical-align: inherit;">Le d√©codeur de tuiles 8x8 lui-m√™me ne n√©cessite qu'une tuile et un code couleur √† l'entr√©e.</font></font></li><li>             .         (         ).         ,       ,    (       ). </li><li>       8   ,     8  (   ).            ,  ,       8x8  24    (3   ). </li><li>    64    7- .  3         ,   4  ‚Äî    .  ,  ,           16 ¬´¬ª,     8 .        8     . </li><li>  7- ,        ,    12-  RGB-    (4    ).            (  ,  ,       ;   ,          ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il s'agit d'un sch√©ma g√©n√©ral de d√©codage de tuiles utilis√© par chacune des trois couches d'affichage, mais le d√©codage de chaque couche est l√©g√®rement diff√©rent: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couche avant peut r√©ellement rendre 512 tuiles 8x8 diff√©rentes. </font><font style="vertical-align: inherit;">Cela n√©cessite des codes de mosa√Øque 9 bits, mais la m√©moire vid√©o ne fournit que 8 bits par mosa√Øque. </font><font style="vertical-align: inherit;">Le neuvi√®me bit est "emprunt√©" au cinqui√®me bit de la valeur de couleur (puisque seulement 4 bits de la valeur de couleur sont utilis√©s pour construire l'index de la palette de couleurs, il reste 4 bits de plus √† d'autres fins). </font><font style="vertical-align: inherit;">Si les 3 bits des couches de bits de tuiles 8x8 sont √©gaux √† z√©ro, le pixel avant est consid√©r√© comme transparent et le pixel d'arri√®re-plan le ¬´brille¬ª.</font></font></li><li>      16x16,     16x16=256     256           (512   ).    ,     16x16      8x8,        .   ,      ;      ¬´¬ª   :   7   ,    . </li><li>       16x16   32x32 ,       4  16   8x8    .  ,    16x16  96 ,    32x32 ‚Äî    384    .       ,   3      ,    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour mieux comprendre √† quoi ressemblent les couches de bits de tuile, j'ai √©crit un petit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programme C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui convertit les tuiles ROM en fichiers PNG (3 bits par pixel convertis en 8 niveaux de gris). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui suit montre les tuiles ROM de la couche avant. </font><font style="vertical-align: inherit;">Nous voyons les donn√©es des nombres et de la police du texte, des tuiles de plate-forme, des bombes (divis√©es en deux), des parties du logo de l'√©conomiseur d'√©cran Bomb Jack et le nombre de points multiplicateurs qui apparaissent en haut de l'√©cran (en passant, tout pivote de 90 degr√©s, car tout l'√©cran est √©galement pivot√© ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/681/ca4/fec/681ca4fec37418dffeb4d601b9e787cf.png" alt="ROM de tuile de premier plan de bombe Jack"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, consid√©rez les tuiles ROM de l'arri√®re-plan. </font><font style="vertical-align: inherit;">Cela ne semble pas tr√®s clair, car ce que nous observons est en fait le d√©codage de tuiles 16x16 en tuiles 8x8. </font><font style="vertical-align: inherit;">Chaque tuile 16x16 est cr√©√©e √† partir de quatre tuiles 8x8 adjacentes. </font><font style="vertical-align: inherit;">Mais vous pouvez reconna√Ætre des parties du temple grec sur la carte 2, le ch√¢teau de la carte 3 et des gratte-ciel de la carte 4.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/fa9/86d/ebcfa986da9add0a45acc02b54bcb69e.png" alt="ROM de tuile de fond de bombe Jack"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, les tuiles sprite ROM. </font><font style="vertical-align: inherit;">Les sprites 16x16 occupent la moiti√© sup√©rieure et les sprites 32x32 occupent la moiti√© inf√©rieure.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/974/01e/44497401e4d25c7915f1c15c9fb9f4ac.png" alt="Bomb Jack Sprite Tile ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un hack int√©ressant de l'√©conomiseur d'√©cran Bomb Jack est que le logo est assembl√© √† partir de tuiles avant et de sprites. </font><font style="vertical-align: inherit;">Je pense que les d√©veloppeurs manquaient de ROM de tuiles avant, mais il y avait peu d'espace dans la ROM de sprite:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/bd5/b69/939bd5b6999622ee26e337f033087234.png" alt="Bomb Jack Splash 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/fef/f2a/6d9feff2acdd4ee2aaa63b8dc4226692.png" alt="Bomb Jack Splash 2"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/bb9/072/819bb90727322463b2c8a9196f6f74c2.png" alt="Bomb Jack Splash 3"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âquipement de sprite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'√©quipement de sprite Bomb Jack est tr√®s puissant par rapport √† ce qui √©tait utilis√© dans les ordinateurs personnels de l'√©poque: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il pourrait rendre jusqu'√† 24 sprites mat√©riels. </font><font style="vertical-align: inherit;">Il semble qu'il n'y ait eu aucune restriction sur le nombre de sprites par ligne de balayage.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les sprites peuvent avoir une taille de 16x16 pixels ou 32x32 pixels </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque sprite peut choisir l'un des 16 emplacements de 8 couleurs dans une palette de couleurs commune </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les sprites avaient une r√©solution de couleur pixel par pixel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque sprite peut √™tre retourn√© verticalement ou horizontalement </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque sprite pouvait choisir l'une des 128 images de sprite flash√©es dans la ROM. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du d√©codage des pixels et des images-objets d'un syst√®me d'images-objets, la m√™me tuile de base 8x8 est utilis√©e comme dans les couches d'arri√®re-plan et avant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les attributs de sprite sont plac√©s dans la plage d'adresses de 0x9820 √† 0x987F - 96 octets, 4 octets par sprite. </font><font style="vertical-align: inherit;">Pour autant que je sache, cette zone est r√©serv√©e √† l'enregistrement; </font><font style="vertical-align: inherit;">au moins le CPU n'effectue pas d'acc√®s en lecture √† cette plage de m√©moire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque sprite est d√©crit par 4 octets:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Octet 0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : s'il est d√©fini, il s'agit d'un sprite 32x32, sinon 16x16</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 6..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 7 bits pour d√©finir le code de la tuile sprite utilis√© pour rechercher des couches de bits de l'image sprite dans les tuiles ROM.</font></font></li></ul></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Octet 1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : s'il est d√©fini, le sprite est retourn√© horizontalement</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : s'il est d√©fini, le sprite est retourn√© verticalement</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 3..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 4 bits pour r√©gler la valeur de couleur pour le d√©codeur de tuiles</font></font></li></ul><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Octet 2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position du sprite sur l'axe X sur l'√©cran</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Octet 3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : position du sprite sur l'√©cran le long de l'axe Y</font></font></li></ul><br>  On ne sait pas exactement ce que font les bits 4 et 5 de l'octet 1, le commentaire dans MAME dit ceci: <br><br> <code>e ? (,    ) <br> f ? (,     (B)?)</code> <br> <br><h2>  Ports d'E / S de m√©moire </h2><br>  Quelques notes sur les ports d'entr√©e / sortie de la carte principale.  Comme indiqu√© ci-dessus, les ports d'E / S ressemblent √† ceci: <br><br><ul><li>  <strong>9E00</strong> : √©criture: num√©ro de l'image d'arri√®re-plan actuelle, lecture: - </li><li>  <strong>B000</strong> : lecture: √©tat du joystick du lecteur 1, √©criture: activation / d√©sactivation du masque NMI </li><li>  <strong>B001</strong> : lire: √©tat du joystick du joueur 2, √©crire: - </li><li>  <strong>B002</strong> : lire: pi√®ces et boutons D√©marrer, √©crire: - </li><li>  <strong>B003</strong> : lire: chien de garde CPU, √©crire: ??? </li><li>  <strong>B004</strong> : lecture: commutateurs DIP 1, √©criture: √©cran de commutation </li><li>  <strong>B005</strong> : lire: dip switches 2, √©crire: - </li><li>  <strong>B800</strong> : √©criture: commande carte son, lecture: - </li></ul><br>  L'adresse 0x9E00 (s√©lection de l'image d'arri√®re-plan) que nous avons d√©j√† consid√©r√©e ci-dessus, et l'adresse 0xB800 (carte son de commande) nous consid√©rerons dans la section suivante.  Reste les adresses de 0xB000 √† 0xB005: <br><br>  La lecture des adresses 0xB000 et 0xB001 renvoie l'√©tat actuel des deux joysticks.  Les octets d√©finis indiquent les commutateurs ferm√©s du joystick: <br><br><ul><li>  <strong>bit 0</strong> : bonne direction </li><li>  <strong>bit 1</strong> : direction gauche </li><li>  <strong>bit 2</strong> : vers le haut </li><li>  <strong>bit 3</strong> : vers le bas </li><li>  <strong>bit 4</strong> : bouton de saut enfonc√© </li></ul><br>  Les 3 bits restants sont ignor√©s. <br><br>  La lecture de 0xB002 renvoie l'√©tat de l'accepteur de pi√®ces et des boutons D√©marrer: <br><br><ul><li>  <strong>bit 0</strong> : la pi√®ce du joueur 1 est lanc√©e </li><li>  <strong>bit 1</strong> : la pi√®ce du joueur 2 est lanc√©e </li><li>  <strong>bit 2</strong> : bouton de d√©marrage du joueur 1 </li><li>  <strong>bit 3</strong> : bouton de d√©marrage du joueur 2 </li></ul><br>  La lecture des adresses 0xB004 et 0xB005 renvoie l'√©tat des commutateurs DIP utilis√©s pour configurer le comportement de la machine d'arcade: <br><br><ul><li>  <strong>B004</strong> : <br><ul><li>  <strong>bits 0,1</strong> : combien de ¬´jeux¬ª sont donn√©s pour une pi√®ce (1, 2, 3 ou 5) </li><li>  <strong>bits 2,3</strong> : idem pour le joueur 2 </li><li>  <strong>bits 4,5</strong> : combien de vies par partie (3, 4, 5 ou 2) </li><li>  <strong>bit 6</strong> : l'emplacement de la borne d'arcade: ¬´table √† cocktail¬ª ou ¬´vertical¬ª. </li><li>  <strong>bit 7</strong> : s'il faut lire le son en mode veille </li></ul></li><li>  <strong>B005</strong> : <br><ul><li>  <strong>bits 3.4</strong> : difficult√© 1 (vitesse de l'oiseau) </li><li>  <strong>bits 5,6</strong> : difficult√© 2 (nombre et vitesse des ennemis) </li><li>  <strong>bit 7</strong> : fr√©quence d'apparition d'une pi√®ce particuli√®re </li></ul></li></ul><br>  Enfin, la lecture de l'adresse <strong>B003</strong> impl√©mente un chien de garde logiciel.  Le CPU doit souvent lire √† partir de cette adresse, sinon la machine d'arcade effectuera une r√©initialisation mat√©rielle.  Si pour une raison quelconque le jeu plante, l'√©quipement red√©marrera automatiquement. <br><br>  Vous pouvez √©crire sur certaines adresses de port d'E / S: <br><br><ul><li>  <strong>B000</strong> : s'il faut g√©n√©rer NMI pendant vblank;  semble √™tre d√©sactiv√© uniquement pendant la proc√©dure de d√©marrage </li><li>  <strong>B004</strong> : retourner l'√©cran entier;  Je n'ai jamais rencontr√© l'utilisation de cette fonction, mais j'ai une th√©orie √† ce sujet (voir ci-dessous) </li></ul><br>  La fonctionnalit√© de retournement d'√©cran est un peu d√©routante, car lorsque je joue √† un jeu, je n'ai jamais vu son utilisation.  Cependant, j'ai une id√©e de ce qu'il fait, mais pour le confirmer, vous devez √©crire du code.  Lorsque la borne d'arcade est en configuration ¬´table de cocktail¬ª, deux joueurs s'assoient l'un en face de l'autre.  Par cons√©quent, j'ai sugg√©r√© que lorsqu'un jeu passe du joueur 1 au joueur 2, cette fonction retourne l'√©cran.  Cependant, je n'ai pas encore impl√©ment√© le mode deux joueurs dans l'√©mulateur. <br><br><h2>  Carte son </h2><br>  La carte son elle-m√™me est un ordinateur complet dot√© d'un processeur Z80 (fonctionnant √† une fr√©quence de 3 MHz), de trois puces audio (AY-38910 fonctionnant √† une fr√©quence de 1,5 MHz), ainsi que de la RAM et de la ROM.  Le sch√©ma d'allocation de m√©moire de la carte son semble assez simple: <br><br><ul><li>  <strong>0000..2000</strong> : 8 Ko de ROM </li><li>  <strong>4000..4400</strong> : 1 Ko de RAM </li><li>  <strong>6000</strong> : commande sonore de la carte principale </li></ul><br>  Puisqu'il n'y a rien d'int√©ressant dans le sch√©ma d'allocation de m√©moire au-dessus de l'adresse 0x8000, le contact d'adresse le plus haut du CPU n'est m√™me pas connect√©: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2f/4ea/35e/b2f4ea35ee4d2861ea1baa502da10837.png" alt="Bomb Jack Sound A15"></div><br>  L'adresse sp√©ciale 0x6000 est le port d'E / S (verrou 8 bits) situ√© dans la m√©moire, ce qui ne correspond pas √† la RAM r√©elle.  Il s'agit du m√™me port que celui situ√© sur la carte principale √† 0xB800.  Il s'agit d'un canal de communication entre la carte principale et la carte son. <br><br>  Les trois puces sonores sont contr√¥l√©es par ces instructions de sortie Z80, et non via les ports m√©moire.  L'AY-3-8910 n'a que deux ports d'E / S ouverts, le premier est utilis√© pour stocker le num√©ro de registre et le second est utilis√© pour √©crire ou lire le contenu du registre sp√©cifi√© par le premier port. <br><br>  Le circuit d'E / S est le suivant: <br><br><ul><li>  <strong>0x00</strong> : premi√®re puce sonore: s√©lection du registre </li><li>  <strong>0x01</strong> : premi√®re puce sonore: acc√®s au registre s√©lectionn√© </li><li>  <strong>0x10</strong> : deuxi√®me puce sonore: s√©lection du registre </li><li>  <strong>0x11</strong> : deuxi√®me puce sonore: acc√®s au registre s√©lectionn√© </li><li>  <strong>0x80</strong> : troisi√®me puce sonore: s√©lection du registre </li><li>  <strong>0x81</strong> : troisi√®me puce sonore: acc√®s au registre s√©lectionn√© </li></ul><br>  Quelques mots sur la puce audio AY-3-8910: <br><br>  Il s'agit d'un appareil assez standard, tr√®s populaire dans les ordinateurs personnels de l'√©poque (par exemple, dans Amstrad CPC, ZX Spectrum 128, dans les ordinateurs MSX et bien d'autres).  L'AY-3-8910 a engendr√© de nombreuses variations et clones (par exemple, Yamaha YM2149, qui en soi est devenu la base de toute une famille de puces sonores plus puissantes). <br><br>  L'AY-3-8910 poss√®de 3 canaux de signaux rectangulaires, un g√©n√©rateur de bruit qui peut √™tre m√©lang√© avec trois canaux et un g√©n√©rateur d'enveloppe.  Comme il n'y avait qu'un seul g√©n√©rateur d'enveloppe pour les trois canaux, il n'√©tait pas particuli√®rement utile et la plupart des jeux utilisaient un processeur pour moduler le ton et le volume. <br><br>  Cela signifie que la puce AY-3-8910 n√©cessite plus d'intervention du processeur pour cr√©er un son de haute qualit√© (contrairement aux puces SID plus autonomes, par exemple, dans un ordinateur C64). <br><br>  Il est √©tonnant de voir ce qui peut √™tre fait sur trois puces sonores assez simples et sur le processeur qui les contr√¥le.  La musique et les effets sonores de Bomb Jack sont beaucoup plus riches que ce que j'ai entendu dans la plupart des jeux informatiques √† domicile. <br><br>  La seule chose qui est vraiment int√©ressante dans cette carte son est la fa√ßon dont elle re√ßoit ses commandes de la carte principale. <br><br><h2>  Verrou de commande sonore </h2><br>  Le ¬´verrou audio¬ª est un stockage √† un octet (verrou 8 bits) commun aux cartes son et principale.  Le verrou est li√© √† l'adresse 0xB800 sur la carte principale et √† l'adresse 0x6000 sur la carte son. <br><br>  Lorsque l'interruption NMI est activ√©e √† l'aide de VSYNC, la carte son ex√©cute une routine de service d'interruption tr√®s simple, qui lit le verrou mat√©riel, l'√©crit √† l'adresse m√©moire normale et d√©finit le ¬´bit de signal¬ª, qui indique √† la ¬´boucle principale¬ª qu'une nouvelle commande audio a √©t√© re√ßue: <br><br><pre> <code class="plaintext hljs"> ex af,af' ;0066 exx ;0067 ld hl,04390h ;0068 set 0,(hl) ;006b ld a,(06000h) ;006d ld (04391h),a ;0070 exx ;0073 ex af,af' ;0074 retn ;0075</code> </pre> <br>  La m√©thode d'activation des contacts NMI est l√©g√®rement diff√©rente de la m√©thode de la carte principale: <br><br>  Sur la carte principale, la broche NMI devient active pendant l'ex√©cution de VBLANK. <br><br>  Cependant, sur la carte son, NMI est activ√© lorsque VSYNC est d√©clench√© et reste actif non pendant VBLANK, mais jusqu'√† ce que la proc√©dure de service d'interruption lit les donn√©es du verrou √† 0x6000. <br><br>  Lorsque l'√©quipement reconna√Æt la lecture de l'adresse 0x6000, il effectue deux op√©rations cod√©es en dur: <br><br><ul><li>  contenu du clip audio remis √† 0 </li><li>  Le contact NMI devient inactif </li></ul><br>  En fait, il s'agit d'une simple √©limination du rebond de contact, qui ne permet pas d'ex√©cuter deux fois une commande sonore. <br><br>  La seule question demeure: √† quelle fr√©quence la carte principale √©crit-elle une nouvelle commande (car la fa√ßon de mettre en ≈ìuvre l'√©mulation de deux cartes en d√©pend). <br><br>  Apr√®s le d√©bogage avec printf, j'ai constat√© que la carte principale enregistre au plus une commande sonore par trame 60 Hz.  Cela a grandement simplifi√© la structure du "cycle principal" de l'√©mulateur. <br><br>  Le probl√®me du travail conjoint de deux ordinateurs √©mul√©s distincts qui doivent √©changer des donn√©es est que l'√©mulation d'un ordinateur n'est efficace que si elle peut effectuer plusieurs cycles √† la fois sans interf√©rence. <br><br>  Par exemple, le pire des cas serait: <br><br><ul><li>  nous ex√©cutons une instruction dans l'ordinateur 1 </li><li>  nous ex√©cutons une instruction dans l'ordinateur 2 </li><li>  r√©p√©ter ... </li></ul><br>  Mon √©mulateur Z80 n'est pas optimis√© pour sortir et entrer dans l'√©mulation pour chaque instruction, car dans ce cas, il doit vider en m√©moire et charger √† partir de la m√©moire l'√©tat du CPU au d√©but et √† la fin de chaque instruction.  Si le CPU peut traiter de nombreuses instructions sans interf√©rence, vous pouvez stocker (la plupart) l'√©tat du CPU dans les registres et r√©initialiser l'√©tat en m√©moire sur la derni√®re instruction. <br><br>  Autrement dit, une situation id√©ale serait la suivante: nous effectuons un syst√®me √©mul√© sans interf√©rence sur toute la trame du syst√®me h√¥te (pour un processeur avec une fr√©quence de 4 MHz et √† 60 Hz, cela signifie environ 67 000 cycles par trame, soit quelque part entre 3 000 et 16 000 instructions Z80). <br><br>  Lorsque je travaillais avec Bomb Jack, je devais m'assurer que la carte principale n'enregistrait pas de nouvelle commande avant que la carte son ne puisse lire la derni√®re commande.  Avant de d√©couvrir que la carte principale n'enregistre pas plus d'une commande par trame, j'ai consid√©r√© la n√©cessit√© de cr√©er une file d'attente complexe de commandes qui intercepterait les enregistrements dans le verrou sonore de la carte principale et stockerait le num√©ro de cycle et l'octet de commande dans la file d'attente. <br><br>  Ensuite, au moment o√π la carte son ex√©cutait sa trame, elle prendrait une nouvelle commande dans la file d'attente de commandes lorsque le num√©ro de cycle de commande √©tait atteint. <br><br>  Un tel syst√®me fonctionnerait et serait ¬´correct¬ª, mais augmenterait consid√©rablement la complexit√© du code. <br><br>  Au final, j'ai d√©cid√© d'utiliser une solution beaucoup plus simple sans file d'attente.  √âtant donn√© que la carte principale n'enregistre qu'une seule commande par trame, j'ai altern√© l'ex√©cution sur deux ordinateurs afin que chacun d'eux effectue deux tranches de temps par trame: <br><br><ul><li>  effectuer la premi√®re moiti√© du cadre sur la carte principale </li><li>  effectuer la premi√®re moiti√© du cadre sur la carte son </li><li>  effectuer la seconde moiti√© du cadre sur la carte principale </li><li>  effectuer la seconde moiti√© du cadre sur la carte son </li></ul><br>  Cela garantit que la carte son voit correctement chaque commande enregistr√©e par la carte principale et peut en m√™me temps ex√©cuter chaque √©mulation pendant des milliers de cycles. <br><br>  Bien s√ªr, le fait que le syst√®me h√¥te fonctionne √† une fr√©quence d'images de 60 Hz est une hypoth√®se tr√®s audacieuse :) <br><br><h2>  Et le dernier ... </h2><br>  Le dernier fait int√©ressant sur la version de l'√©mulateur sur WebAssembly: <br><br>  Taille compress√©e de tous les fichiers t√©l√©charg√©s lors de l'ex√©cution de l'√©mulateur sur WebAssembly <br>  environ √©gal √† 113 kilo-octets: <br><br><ul><li>  environ 2,5 Ko pour HTML, CSS et JS ¬´manuscrits¬ª </li><li>  26,8 ko par fichier JS d'ex√©cution emscripten </li><li>  83,7 Ko par fichier .wasm </li></ul><br>  Le fichier WASM contient les ROM int√©gr√©es de la machine d'arcade. <br><br>  Non compress√©es, ces ROM occupent 112 Ko. <br><br>  Autrement dit, l' <strong>ensemble</strong> de l'√©mulateur compress√© avec les ROM int√©gr√©es occupe presque le m√™me volume que les ROM non compress√©es :) <br><br>  Les ROM de 112 kilo-octets sont compress√©es √† environ 57 Ko, c'est-√†-dire que la taille r√©elle du code compress√© dans WASM sans donn√©es ROM est inf√©rieure √† 30 Ko (84-57). <br><br>  Cela me semble assez bon pour un √©mulateur complet d'un syst√®me 8 bits;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426291/">https://habr.com/ru/post/fr426291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426281/index.html">Les fondateurs d'Amazon, Google, Microsoft et Facebook ont ‚Äã‚Äãperdu plus de 30 milliards de dollars lors d'un krach boursier</a></li>
<li><a href="../fr426283/index.html">WeChat en Inde: d'un lancement puissant √† une perte totale d'int√©r√™t</a></li>
<li><a href="../fr426285/index.html">Dans l'un des ateliers AvtoVAZ a trouv√© une ferme pour l'exploitation mini√®re</a></li>
<li><a href="../fr426287/index.html">Envoi vers la lune</a></li>
<li><a href="../fr426289/index.html">Authentification asp .net core via IdentityServer4</a></li>
<li><a href="../fr426293/index.html">Quel v√©lo choisir pour la ville, la campagne et les voyages extr√™mes - un aper√ßu des mod√®les Airwheel et Twitter</a></li>
<li><a href="../fr426295/index.html">Comme je vois le navigateur parfait</a></li>
<li><a href="../fr426297/index.html">Pourquoi je n'aime pas le web moderne</a></li>
<li><a href="../fr426299/index.html">[Design Psychology] - La psychologie du design</a></li>
<li><a href="../fr426301/index.html">En est-il ainsi en Europe, alors qu'ils √©crivent √† ce sujet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>