<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèø üìá üë©‚Äç‚ù§Ô∏è‚Äçüë© Snippets vs Clover - Schlie√üe das beliebteste Echtzeit-Quiz ab üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üïµÔ∏è üë®üèø‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="April 2018. Ich war 14. Meine Freunde und ich spielten damals im sehr beliebten Online-Quiz ‚ÄûClover‚Äú von VKontakte. Einer von uns (normalerweise ich) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Snippets vs Clover - Schlie√üe das beliebteste Echtzeit-Quiz ab</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  April 2018.  Ich war 14. Meine Freunde und ich spielten damals im sehr beliebten Online-Quiz ‚ÄûClover‚Äú von VKontakte.  Einer von uns (normalerweise ich) sa√ü immer hinter einem Laptop, um schnell Fragen zu googeln und in den Suchergebnissen nach der richtigen Antwort zu suchen.  Aber pl√∂tzlich wurde mir klar, dass ich jedes Mal das Gleiche tat, und ich beschloss, es in Python 3 zu schreiben, das mir damals teilweise bekannt war. <br><br><h3>  Schritt 0. Was ist hier los? </h3><br>  Zun√§chst werde ich die Mechanik von ‚ÄûClover‚Äú in Ihrem Ged√§chtnis auffrischen. <br><br>  Das Spiel f√ºr alle beginnt zur gleichen Zeit - um 13:00 Uhr und um 20:00 Uhr Moskauer Zeit.  Um zu spielen, m√ºssen Sie zu diesem Zeitpunkt in die Anwendung gehen und eine Verbindung zur Live-√úbertragung herstellen.  Das Spiel dauert 15 Minuten. W√§hrend dieser Zeit werden Fragen an die Teilnehmer am Telefon gesendet.  Die Antwort ist <b>10 Sekunden.</b>  Dann wird die richtige Antwort bekannt gegeben.  Alle, die es erraten haben, gehen noch weiter.  Insgesamt gibt es 12 Fragen. Wenn Sie alle Fragen beantworten, erhalten Sie einen Geldpreis. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="Bild"><br>  Es stellt sich heraus, dass unsere Aufgabe darin besteht, neue Fragen sofort vom Clover-Server abzufangen, sie √ºber eine Suchmaschine zu verarbeiten und anhand der Suchergebnisse die richtige Antwort zu ermitteln.  Es wurde beschlossen, die Antwort in einem Telegramm-Bot auszugeben, damit Benachrichtigungen direkt w√§hrend des Spiels auf dem Telefon angezeigt werden.  Und das alles ist in wenigen Sekunden w√ºnschenswert, da die Reaktionszeit sehr begrenzt ist.  Wenn Sie sehen m√∂chten, wie ein ziemlich einfacher, aber funktionierender Code (und das Betrachten dieses Codes f√ºr Anf√§nger n√ºtzlich ist) uns geholfen hat, Clover zu schlagen - willkommen zum Schnitt. <br><a name="habracut"></a><br><h3>  Schritt 1. Fragen vom Server stellen </h3><br>  Zuerst schien es die schwierigste Etappe zu sein.  Ich holte bereits tief Luft und war bereit, wie Computer Vision, Abfangen des Datenverkehrs oder Dekompilieren der Anwendung in die Wildnis zu klettern ... Als pl√∂tzlich eine √úberraschung auf mich wartete - Clover hat eine offene API!  Es ist nirgendwo dokumentiert, aber wenn w√§hrend des Spiels, sobald allen Spielern eine Frage gestellt wurde, eine Anfrage auf api.vk.com gestellt wird, erhalten wir als Antwort die gestellten Fragen- und Antwortoptionen in JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="Bild"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  Als access_token ist es erforderlich, das API-Token eines beliebigen VKontakte-Benutzers zu √ºbertragen. Es ist jedoch wichtig, dass es urspr√ºnglich speziell f√ºr Clover ausgestellt wurde.  Seine app_id ist 6334949. <br><br><h3>  Schritt 2. Wir bearbeiten das Problem √ºber eine Suchmaschine </h3><br>  Es gab zwei M√∂glichkeiten: Verwenden Sie die offizielle Suchmaschinen-API oder f√ºgen Sie Suchargumente direkt zur Adressleiste hinzu und analysieren Sie die Ergebnisse.  Zuerst habe ich das zweite ausprobiert, aber manchmal habe ich nicht nur Captcha gefangen, sondern auch viel Zeit verloren, weil die Seiten durchschnittlich in 2 Sekunden geladen wurden.  Und ich erinnere Sie daran, dass es f√ºr uns ratsam ist, genau diese zwei Sekunden einzuhalten.  Nun und vor allem habe ich von den Suchmaschinen keine gro√üen und strukturierten Texte zum erforderlichen Thema erhalten, da nur kleine Teile des erforderlichen Materials, sogenannte <b>Snippets,</b> auf der Suchseite h√§ngen: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  Also suchte ich nach einer API.  Google passte nicht - ihre L√∂sungen waren sehr begrenzt und gaben nur sehr wenige Daten zur√ºck.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex.XML</a> erwies sich als das gro√üz√ºgigste - es erm√∂glicht Ihnen, 10.000 Anfragen pro Tag zu senden, nicht mehr als 5 pro Sekunde, und es gibt Daten sehr schnell zur√ºck.  Die Anforderung daf√ºr ist optional die Anzahl der Seiten (bis zu 100) und die Anzahl der Passagen - spezielle Werte, die zur Bildung von Snippets verwendet werden.  Wir erhalten die Daten in XML.  Dies sind jedoch alle die gleichen Schnipsel. <br><br>  Damit Sie sich mit den Ergebnissen von Yandex vertraut machen und mit ihnen spielen k√∂nnen, finden Sie hier ein Beispiel f√ºr eine Antwort auf die Frage ‚ÄûWie hei√üt der Hauptgegner in der Videoserie‚Äû The Legend of Zelda? ‚Äú: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fahren</a> . <br><br>  Ich hatte Gl√ºck und es stellte sich heraus, dass es in pypi bereits ein separates <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex-Suchmodul</a> daf√ºr gibt.  Und so habe ich versucht, die Frage vom Server zu bekommen, sie in Yandex zu finden, einen gro√üen Text aus Ausschnitten zu erstellen und ihn in S√§tze zu zerlegen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          ¬´   ¬ª?', 'answers': [{'id': 0, 'users_answered': 0, 'text': '¬´ ¬ª'}, {'id': 1, 'users_answered': 0, 'text': '¬´ ¬ª'}, {'id': 2, 'users_answered': 0, 'text': '¬´¬ª'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Schritt 3. Nach Antworten suchen </h3><br>  Anfangs schien mir die Aufgabe, die Antwort anhand von Ausschnitten genau zu erkennen, unrealistisch (ich erinnere Sie daran, dass ich zum Zeitpunkt des Schreibens des Codes ein absoluter Anf√§nger war).  Aus diesem Grund habe ich mich entschlossen, die von uns durchgef√ºhrte Aufgabe zun√§chst mit einer manuellen Suche zu vereinfachen. <br><br>  Was haben meine Freunde und ich getan, als wir unsere Frage in eine Suchmaschine eingegeben haben?  Sie begannen schnell durch die Augen nach Antworten in den Ergebnissen zu suchen.  Was ist das Problem bei diesem Ansatz?  In <s>Mehrfachbriefen</s> gibt es eine gro√üe Anzahl unn√∂tiger, nicht enthaltener Informationen zu Antworten und Vorschl√§gen.  Das Suchen mit meinen Augen dauerte manchmal lange.  Daher entschied ich mich als erstes, alle S√§tze mit einer Erw√§hnung einer der Antworten auszuw√§hlen und anzuzeigen, damit wir die Antwort in einem sehr kleinen Text suchen, der genau die Informationen enth√§lt, die wir ben√∂tigen. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Es scheint, dass Sie die richtigen Angebote erhalten, sie lesen und richtig antworten.  Aber was ist, wenn wir keinen einzigen Satz gefunden haben?  In diesem Fall habe ich beschlossen, die W√∂rter so zu k√ºrzen, dass sie nicht √ºbersehen werden, wenn sie sich in einem anderen Fall befinden.  Und auch um diejenigen zu erfassen, die aus der Quelle gebildet werden.  Kurz gesagt, ich habe ihr Ende nur in zwei Zeichen zerlegt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Aber auch nach einem solchen Sicherheitsnetz gab es immer noch F√§lle, in denen der Hinweis leer blieb, einfach weil die Ergebnisse die Antworten nicht immer ber√ºhrten.  Sagen Sie zu der Frage: <i>"Welcher dieser Autoren hat eine Geschichte, die genau wie das Lied der Gruppe Bi 2 benannt ist?"</i>  Es kann keine genaue Antwort gefunden werden.  In diesem Fall habe ich den umgekehrten Ansatz gew√§hlt - ich habe nach den Antworten gefragt und die Option basierend darauf abgeleitet, wie oft die W√∂rter aus der Frage in den Ergebnissen erw√§hnt werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  Zu diesem Zeitpunkt erhielt das Skript grundlegende Funktionen.  Und jetzt, nur anderthalb Wochen nach der Ver√∂ffentlichung von Clover, sitzen wir und spielen bereits mit solch einem selbstgemachten ‚ÄûCheat‚Äú.  Sie sollten unsere Gesichter mit einem Freund gesehen haben, als wir <b>das Spiel zum</b> ersten Mal <b>gewonnen haben,</b> indem Sie Vorschl√§ge auf der Befehlszeile wie von Zauberhand gelesen haben! <br><br><h3>  Schritt 4. Zeigen Sie klare Antworten an </h3><br>  Aber bald ist dieses Format m√ºde.  Zuerst musste man bei jedem Spiel mit einem Laptop sitzen.  Zweitens haben meine Freunde nach dem Skript gefragt, und ich bin es leid, allen zu erkl√§ren, wie sie ihr VKontakte-Token einf√ºgen, wie sie Yandex.XML konfigurieren (es ist an IP gebunden, dh es musste ein Konto f√ºr jeden Benutzer des Skripts erstellt werden) und wie Python auf dem Computer installiert wird. <br><br>  Es w√§re viel besser, wenn die Antworten direkt w√§hrend des Spiels in Push-Benachrichtigungen auf dem Telefon erscheinen w√ºrden!  Ich habe gerade auf den oberen Bildschirmrand geschaut und geantwortet, wie es in der Push-Benachrichtigung steht!  Und Sie k√∂nnen dies f√ºr alle organisieren, wenn Sie Ihren Telegrammkanal f√ºr das Skript erstellen!  Wunderbar! <br><br>  Es ist jedoch keine Option, einfach dieselben S√§tze in Telegrammen anzuzeigen.  Das Lesen von Ihrem Telefon ist √§u√üerst unpraktisch.  Daher musste ich das Skript selbst lernen, um zu verstehen, welche Antwort richtig ist. <br><br>  Wir importieren <b>Telebot</b> und √§ndern alle <b>print () -</b> Funktionen in <b>send_tg ()</b> und <b>notsure ()</b> , die wir in der letzten Methode verwenden werden, da sie etwas h√§ufiger fehlen als andere: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  Und in diesem Moment wurde mir klar, dass Schnipsel viel besser sind als lange Texte!  Weil die Suchmaschine sehr bem√ºht ist <b>, eine Antwort</b> auf unsere Anfrage zu <b>geben</b> und nicht nur √úbereinstimmungen in Worten zu finden.  Und es gelingt ihm - Schnipsel enthielten oft die richtigen Antworten als die falschen, das hei√üt, es bestand keine Notwendigkeit, den Text zu analysieren.  Und ich wusste tats√§chlich nicht wie. <br><br>  Wir sind also einfach, die Erw√§hnung von W√∂rtern in den Ergebnissen zu z√§hlen: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Was ist als Ergebnis passiert: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="Bild"><br><br><h3>  Weiteres Schicksal </h3><br>  Fairerweise muss ich sagen, dass mir die Todesmaschine nicht gelungen ist.  Im Durchschnitt beantwortete der Bot nur 9-10 von 12 Fragen richtig.  Es ist verst√§ndlich, weil es knifflige gab, die der Analyse der Yandex-Suche nicht erlegen waren.  Ich und meine Freunde hatten es satt, st√§ndig √ºber ein paar Fragen zu fliegen und auf ein erfolgreiches Spiel zu warten, in dem der Bot endlich alles richtig beantwortet.  Ein Wunder geschah nicht, ich wollte das Drehbuch nicht mehr wirklich √§ndern und nachdem wir aufgeh√∂rt hatten, auf einen leichten Sieg zu hoffen, gaben wir das Spiel auf. <br><br>  Mit der Zeit schlich sich meine Idee in die K√∂pfe anderer junger Entwickler.  Bis zum Sonnenuntergang 2018 gab es mindestens 10 Bots und Sites, die ihre Vermutungen zu Problemen in Clover zeigten.  Die Aufgabe ist nicht so schwierig.  Was jedoch √ºberrascht, ist, dass keiner von ihnen jemals die Grenze von 9 bis 10 Fragen pro Spiel √ºberschritten hat und sp√§ter alle wie mein Bot auf 7 bis 8 gefallen sind.  Anscheinend haben die Verfasser der Fragen klar gemacht, wie die Fragen zusammengesetzt werden sollen, so dass die Arbeit der Suchmaschinen irrelevant war. <br><br>  Leider kann der Bot nicht mehr finalisiert werden, da Clover am 31. Dezember die letzte Sendung ausgegeben hat und ich keine Fragen hatte.  Es war jedoch eine gro√üartige Erfahrung f√ºr einen unerfahrenen Programmierer.  Und f√ºr Fortgeschrittene w√§re es sicherlich eine gro√üe Herausforderung - stellen Sie sich das Duo word2vec und text2vec vor, asynchrone Anfragen an Yandex, Google und Wikipedia gleichzeitig, einen fortgeschrittenen Klassifikator von Fragen und einen Algorithmus zur Neuformulierung der Frage im Fehlerfall ... Eh!  Vielleicht habe ich dieses Spiel f√ºr solche Gelegenheiten mehr geliebt als f√ºr das Gameplay selbst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435360/">https://habr.com/ru/post/de435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435346/index.html">Abonnieren Sie Kafka √ºber HTTP oder vereinfachen Sie Ihre Web-Hooks</a></li>
<li><a href="../de435348/index.html">Simple MCerver - eine kleine Shell f√ºr den Minecraft-Server</a></li>
<li><a href="../de435352/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 2</a></li>
<li><a href="../de435354/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 1</a></li>
<li><a href="../de435358/index.html">Antiquit√§ten: Minidisk im Zeitalter des iPod</a></li>
<li><a href="../de435362/index.html">Geschwindigkeits-Hash</a></li>
<li><a href="../de435364/index.html">Anpassen der Abh√§ngigkeitsaufl√∂sung im Fr√ºhjahr</a></li>
<li><a href="../de435368/index.html">Pathologische Anatomie am Arbeitsplatz</a></li>
<li><a href="../de435372/index.html">Ein paar Worte zu FastPath und FastTrack bei MikroTik</a></li>
<li><a href="../de435374/index.html">Mathe in Gamedev ist einfach. Triangulation und Triangle.Net in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>