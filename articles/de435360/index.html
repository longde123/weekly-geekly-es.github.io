<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏿 📇 👩‍❤️‍👩 Snippets vs Clover - Schließe das beliebteste Echtzeit-Quiz ab 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🕵️ 👨🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="April 2018. Ich war 14. Meine Freunde und ich spielten damals im sehr beliebten Online-Quiz „Clover“ von VKontakte. Einer von uns (normalerweise ich) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Snippets vs Clover - Schließe das beliebteste Echtzeit-Quiz ab</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  April 2018.  Ich war 14. Meine Freunde und ich spielten damals im sehr beliebten Online-Quiz „Clover“ von VKontakte.  Einer von uns (normalerweise ich) saß immer hinter einem Laptop, um schnell Fragen zu googeln und in den Suchergebnissen nach der richtigen Antwort zu suchen.  Aber plötzlich wurde mir klar, dass ich jedes Mal das Gleiche tat, und ich beschloss, es in Python 3 zu schreiben, das mir damals teilweise bekannt war. <br><br><h3>  Schritt 0. Was ist hier los? </h3><br>  Zunächst werde ich die Mechanik von „Clover“ in Ihrem Gedächtnis auffrischen. <br><br>  Das Spiel für alle beginnt zur gleichen Zeit - um 13:00 Uhr und um 20:00 Uhr Moskauer Zeit.  Um zu spielen, müssen Sie zu diesem Zeitpunkt in die Anwendung gehen und eine Verbindung zur Live-Übertragung herstellen.  Das Spiel dauert 15 Minuten. Während dieser Zeit werden Fragen an die Teilnehmer am Telefon gesendet.  Die Antwort ist <b>10 Sekunden.</b>  Dann wird die richtige Antwort bekannt gegeben.  Alle, die es erraten haben, gehen noch weiter.  Insgesamt gibt es 12 Fragen. Wenn Sie alle Fragen beantworten, erhalten Sie einen Geldpreis. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="Bild"><br>  Es stellt sich heraus, dass unsere Aufgabe darin besteht, neue Fragen sofort vom Clover-Server abzufangen, sie über eine Suchmaschine zu verarbeiten und anhand der Suchergebnisse die richtige Antwort zu ermitteln.  Es wurde beschlossen, die Antwort in einem Telegramm-Bot auszugeben, damit Benachrichtigungen direkt während des Spiels auf dem Telefon angezeigt werden.  Und das alles ist in wenigen Sekunden wünschenswert, da die Reaktionszeit sehr begrenzt ist.  Wenn Sie sehen möchten, wie ein ziemlich einfacher, aber funktionierender Code (und das Betrachten dieses Codes für Anfänger nützlich ist) uns geholfen hat, Clover zu schlagen - willkommen zum Schnitt. <br><a name="habracut"></a><br><h3>  Schritt 1. Fragen vom Server stellen </h3><br>  Zuerst schien es die schwierigste Etappe zu sein.  Ich holte bereits tief Luft und war bereit, wie Computer Vision, Abfangen des Datenverkehrs oder Dekompilieren der Anwendung in die Wildnis zu klettern ... Als plötzlich eine Überraschung auf mich wartete - Clover hat eine offene API!  Es ist nirgendwo dokumentiert, aber wenn während des Spiels, sobald allen Spielern eine Frage gestellt wurde, eine Anfrage auf api.vk.com gestellt wird, erhalten wir als Antwort die gestellten Fragen- und Antwortoptionen in JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="Bild"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  Als access_token ist es erforderlich, das API-Token eines beliebigen VKontakte-Benutzers zu übertragen. Es ist jedoch wichtig, dass es ursprünglich speziell für Clover ausgestellt wurde.  Seine app_id ist 6334949. <br><br><h3>  Schritt 2. Wir bearbeiten das Problem über eine Suchmaschine </h3><br>  Es gab zwei Möglichkeiten: Verwenden Sie die offizielle Suchmaschinen-API oder fügen Sie Suchargumente direkt zur Adressleiste hinzu und analysieren Sie die Ergebnisse.  Zuerst habe ich das zweite ausprobiert, aber manchmal habe ich nicht nur Captcha gefangen, sondern auch viel Zeit verloren, weil die Seiten durchschnittlich in 2 Sekunden geladen wurden.  Und ich erinnere Sie daran, dass es für uns ratsam ist, genau diese zwei Sekunden einzuhalten.  Nun und vor allem habe ich von den Suchmaschinen keine großen und strukturierten Texte zum erforderlichen Thema erhalten, da nur kleine Teile des erforderlichen Materials, sogenannte <b>Snippets,</b> auf der Suchseite hängen: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  Also suchte ich nach einer API.  Google passte nicht - ihre Lösungen waren sehr begrenzt und gaben nur sehr wenige Daten zurück.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex.XML</a> erwies sich als das großzügigste - es ermöglicht Ihnen, 10.000 Anfragen pro Tag zu senden, nicht mehr als 5 pro Sekunde, und es gibt Daten sehr schnell zurück.  Die Anforderung dafür ist optional die Anzahl der Seiten (bis zu 100) und die Anzahl der Passagen - spezielle Werte, die zur Bildung von Snippets verwendet werden.  Wir erhalten die Daten in XML.  Dies sind jedoch alle die gleichen Schnipsel. <br><br>  Damit Sie sich mit den Ergebnissen von Yandex vertraut machen und mit ihnen spielen können, finden Sie hier ein Beispiel für eine Antwort auf die Frage „Wie heißt der Hauptgegner in der Videoserie„ The Legend of Zelda? “: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fahren</a> . <br><br>  Ich hatte Glück und es stellte sich heraus, dass es in pypi bereits ein separates <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex-Suchmodul</a> dafür gibt.  Und so habe ich versucht, die Frage vom Server zu bekommen, sie in Yandex zu finden, einen großen Text aus Ausschnitten zu erstellen und ihn in Sätze zu zerlegen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          «   »?', 'answers': [{'id': 0, 'users_answered': 0, 'text': '« »'}, {'id': 1, 'users_answered': 0, 'text': '« »'}, {'id': 2, 'users_answered': 0, 'text': '«»'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Schritt 3. Nach Antworten suchen </h3><br>  Anfangs schien mir die Aufgabe, die Antwort anhand von Ausschnitten genau zu erkennen, unrealistisch (ich erinnere Sie daran, dass ich zum Zeitpunkt des Schreibens des Codes ein absoluter Anfänger war).  Aus diesem Grund habe ich mich entschlossen, die von uns durchgeführte Aufgabe zunächst mit einer manuellen Suche zu vereinfachen. <br><br>  Was haben meine Freunde und ich getan, als wir unsere Frage in eine Suchmaschine eingegeben haben?  Sie begannen schnell durch die Augen nach Antworten in den Ergebnissen zu suchen.  Was ist das Problem bei diesem Ansatz?  In <s>Mehrfachbriefen</s> gibt es eine große Anzahl unnötiger, nicht enthaltener Informationen zu Antworten und Vorschlägen.  Das Suchen mit meinen Augen dauerte manchmal lange.  Daher entschied ich mich als erstes, alle Sätze mit einer Erwähnung einer der Antworten auszuwählen und anzuzeigen, damit wir die Antwort in einem sehr kleinen Text suchen, der genau die Informationen enthält, die wir benötigen. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Es scheint, dass Sie die richtigen Angebote erhalten, sie lesen und richtig antworten.  Aber was ist, wenn wir keinen einzigen Satz gefunden haben?  In diesem Fall habe ich beschlossen, die Wörter so zu kürzen, dass sie nicht übersehen werden, wenn sie sich in einem anderen Fall befinden.  Und auch um diejenigen zu erfassen, die aus der Quelle gebildet werden.  Kurz gesagt, ich habe ihr Ende nur in zwei Zeichen zerlegt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Aber auch nach einem solchen Sicherheitsnetz gab es immer noch Fälle, in denen der Hinweis leer blieb, einfach weil die Ergebnisse die Antworten nicht immer berührten.  Sagen Sie zu der Frage: <i>"Welcher dieser Autoren hat eine Geschichte, die genau wie das Lied der Gruppe Bi 2 benannt ist?"</i>  Es kann keine genaue Antwort gefunden werden.  In diesem Fall habe ich den umgekehrten Ansatz gewählt - ich habe nach den Antworten gefragt und die Option basierend darauf abgeleitet, wie oft die Wörter aus der Frage in den Ergebnissen erwähnt werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  Zu diesem Zeitpunkt erhielt das Skript grundlegende Funktionen.  Und jetzt, nur anderthalb Wochen nach der Veröffentlichung von Clover, sitzen wir und spielen bereits mit solch einem selbstgemachten „Cheat“.  Sie sollten unsere Gesichter mit einem Freund gesehen haben, als wir <b>das Spiel zum</b> ersten Mal <b>gewonnen haben,</b> indem Sie Vorschläge auf der Befehlszeile wie von Zauberhand gelesen haben! <br><br><h3>  Schritt 4. Zeigen Sie klare Antworten an </h3><br>  Aber bald ist dieses Format müde.  Zuerst musste man bei jedem Spiel mit einem Laptop sitzen.  Zweitens haben meine Freunde nach dem Skript gefragt, und ich bin es leid, allen zu erklären, wie sie ihr VKontakte-Token einfügen, wie sie Yandex.XML konfigurieren (es ist an IP gebunden, dh es musste ein Konto für jeden Benutzer des Skripts erstellt werden) und wie Python auf dem Computer installiert wird. <br><br>  Es wäre viel besser, wenn die Antworten direkt während des Spiels in Push-Benachrichtigungen auf dem Telefon erscheinen würden!  Ich habe gerade auf den oberen Bildschirmrand geschaut und geantwortet, wie es in der Push-Benachrichtigung steht!  Und Sie können dies für alle organisieren, wenn Sie Ihren Telegrammkanal für das Skript erstellen!  Wunderbar! <br><br>  Es ist jedoch keine Option, einfach dieselben Sätze in Telegrammen anzuzeigen.  Das Lesen von Ihrem Telefon ist äußerst unpraktisch.  Daher musste ich das Skript selbst lernen, um zu verstehen, welche Antwort richtig ist. <br><br>  Wir importieren <b>Telebot</b> und ändern alle <b>print () -</b> Funktionen in <b>send_tg ()</b> und <b>notsure ()</b> , die wir in der letzten Methode verwenden werden, da sie etwas häufiger fehlen als andere: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  Und in diesem Moment wurde mir klar, dass Schnipsel viel besser sind als lange Texte!  Weil die Suchmaschine sehr bemüht ist <b>, eine Antwort</b> auf unsere Anfrage zu <b>geben</b> und nicht nur Übereinstimmungen in Worten zu finden.  Und es gelingt ihm - Schnipsel enthielten oft die richtigen Antworten als die falschen, das heißt, es bestand keine Notwendigkeit, den Text zu analysieren.  Und ich wusste tatsächlich nicht wie. <br><br>  Wir sind also einfach, die Erwähnung von Wörtern in den Ergebnissen zu zählen: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Was ist als Ergebnis passiert: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="Bild"><br><br><h3>  Weiteres Schicksal </h3><br>  Fairerweise muss ich sagen, dass mir die Todesmaschine nicht gelungen ist.  Im Durchschnitt beantwortete der Bot nur 9-10 von 12 Fragen richtig.  Es ist verständlich, weil es knifflige gab, die der Analyse der Yandex-Suche nicht erlegen waren.  Ich und meine Freunde hatten es satt, ständig über ein paar Fragen zu fliegen und auf ein erfolgreiches Spiel zu warten, in dem der Bot endlich alles richtig beantwortet.  Ein Wunder geschah nicht, ich wollte das Drehbuch nicht mehr wirklich ändern und nachdem wir aufgehört hatten, auf einen leichten Sieg zu hoffen, gaben wir das Spiel auf. <br><br>  Mit der Zeit schlich sich meine Idee in die Köpfe anderer junger Entwickler.  Bis zum Sonnenuntergang 2018 gab es mindestens 10 Bots und Sites, die ihre Vermutungen zu Problemen in Clover zeigten.  Die Aufgabe ist nicht so schwierig.  Was jedoch überrascht, ist, dass keiner von ihnen jemals die Grenze von 9 bis 10 Fragen pro Spiel überschritten hat und später alle wie mein Bot auf 7 bis 8 gefallen sind.  Anscheinend haben die Verfasser der Fragen klar gemacht, wie die Fragen zusammengesetzt werden sollen, so dass die Arbeit der Suchmaschinen irrelevant war. <br><br>  Leider kann der Bot nicht mehr finalisiert werden, da Clover am 31. Dezember die letzte Sendung ausgegeben hat und ich keine Fragen hatte.  Es war jedoch eine großartige Erfahrung für einen unerfahrenen Programmierer.  Und für Fortgeschrittene wäre es sicherlich eine große Herausforderung - stellen Sie sich das Duo word2vec und text2vec vor, asynchrone Anfragen an Yandex, Google und Wikipedia gleichzeitig, einen fortgeschrittenen Klassifikator von Fragen und einen Algorithmus zur Neuformulierung der Frage im Fehlerfall ... Eh!  Vielleicht habe ich dieses Spiel für solche Gelegenheiten mehr geliebt als für das Gameplay selbst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435360/">https://habr.com/ru/post/de435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435346/index.html">Abonnieren Sie Kafka über HTTP oder vereinfachen Sie Ihre Web-Hooks</a></li>
<li><a href="../de435348/index.html">Simple MCerver - eine kleine Shell für den Minecraft-Server</a></li>
<li><a href="../de435352/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 2</a></li>
<li><a href="../de435354/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 1</a></li>
<li><a href="../de435358/index.html">Antiquitäten: Minidisk im Zeitalter des iPod</a></li>
<li><a href="../de435362/index.html">Geschwindigkeits-Hash</a></li>
<li><a href="../de435364/index.html">Anpassen der Abhängigkeitsauflösung im Frühjahr</a></li>
<li><a href="../de435368/index.html">Pathologische Anatomie am Arbeitsplatz</a></li>
<li><a href="../de435372/index.html">Ein paar Worte zu FastPath und FastTrack bei MikroTik</a></li>
<li><a href="../de435374/index.html">Mathe in Gamedev ist einfach. Triangulation und Triangle.Net in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>