<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🏫 🥈 👩🏽‍🤝‍👨🏾 Choisir la bonne structure de données dans Swift 🐢 🌅 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour encore. Avant de partir pour le week-end, nous voulons partager avec vous une traduction de matériel qui a été préparé spécifiquement pour le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Choisir la bonne structure de données dans Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Bonjour encore.</i>  <i>Avant de partir pour le week-end, nous voulons partager avec vous une traduction de matériel qui a été préparé spécifiquement pour le cours de base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Développeur iOS»</a> .</i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  Décider de la structure de données à utiliser pour représenter un ensemble de valeurs donné est souvent beaucoup plus difficile qu'il n'y paraît.  Étant donné que chaque type de structure de données est optimisé pour un certain nombre de cas d'utilisation, le choix du bon ajustement pour chaque ensemble de données peut souvent avoir un impact important sur les performances de notre code. <a name="habracut"></a><br><br>  La bibliothèque Swift standard est livrée avec trois structures de données principales - <code>Array</code> , <code>Dictionary</code> et <code>Set</code> , chacune ayant son propre ensemble d'optimisations, avantages et inconvénients.  Examinons certaines de leurs caractéristiques, ainsi que les cas où nous devrons peut-être aller au-delà de la bibliothèque standard pour trouver la bonne structure de données pour nos besoins. <br><br><h3>  Linéarité du tableau </h3><br>  <code>Array</code> est probablement l'une des structures de données les plus couramment utilisées dans Swift, et il y a de bonnes raisons à cela.  Il stocke ses éléments de manière séquentielle, ils sont facilement triés de manière prévisible et toutes les valeurs peuvent y être stockées: des structures aux instances de classes et autres collections. <br><br>  Par exemple, ici, nous utilisons un tableau pour stocker une collection de formes placées sur une <code>Canvas</code> dans une application de dessin.  Ensuite, lorsque nous devons rendre le canevas dans une image, nous <code>DrawingContext</code> simplement le tableau pour dessiner chaque élément à l'aide de <code>DrawingContext</code> - comme suit: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  En ce qui concerne le rendu séquentiel de toutes nos formes, comme nous l'avons fait ci-dessus, le tableau s'adapte parfaitement.  Les tableaux stockent non seulement leurs éléments de manière très efficace, ils ont également un ordre de tri garanti, qui fournit un ordre de rendu prévisible sans avoir à faire de travail supplémentaire. <br><br>  Cependant, comme toutes les autres structures de données, les tableaux ont leurs inconvénients.  Dans notre cas, nous rencontrerons l'un de ses inconvénients lorsque nous voulons supprimer des formes du canevas.  Étant donné que les éléments du tableau sont stockés par index, nous devons toujours trouver à quel index le chiffre est associé avant de pouvoir le supprimer: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Au début, le code ci-dessus peut ne pas sembler si problématique, mais il peut devenir un goulot d'étranglement de performances pour tout canevas contenant un grand nombre de formes, car <code>firstIndex</code> est linéaire (O (N)) en termes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complexité temporelle</a> . <br><br>  Bien que nous puissions contourner cette limitation lorsque nous utilisons notre type de canevas.  Par exemple, toujours se référer aux chiffres par index, et non par valeur ou ID - cela rendrait notre code plus complexe et plus fragile, car nous devrions toujours être sûrs que nos index n'expirent pas lorsque le canevas avec lequel nous travaillons va changer. <br><br><h3>  Ensembles de vitesse </h3><br>  À la place, voyons si nous pouvons optimiser le <code>Canvas</code> lui-même en modifiant sa structure de données sous-jacente.  Compte tenu du problème ci-dessus, l'une de nos premières idées pourrait être d'utiliser <code>Set</code> (sets) au lieu de <code>Array</code> .  Comme nous l'avons déjà expliqué dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La puissance des ensembles dans Swift</a> , l'un des avantages importants des ensembles par rapport aux tableaux est que l'insertion et la suppression peuvent toujours être effectuées dans un temps constant (O (1)), puisque les éléments sont stockés par valeur de hachage, pas par index. <br><br>  En mettant à jour <code>Canvas</code> pour utiliser des ensembles, nous obtenons ce qui suit: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Encore une fois, le code ci-dessus peut sembler correct et il se compile même sans problème.  Cependant, bien que nous ayons résolu le problème de suppression, nous avons également perdu notre ordre de rendu stable - car, contrairement aux tableaux, les ensembles ne nous donnent pas un ordre de tri garanti - ce qui est une pierre d'achoppement dans cette situation, car il semble que nous allons dessiner des formes personnalisées dans au hasard. <br><br><h3>  Indexation des index </h3><br>  Continuons d'expérimenter.  Voyons maintenant si nous pouvons optimiser le <code>Canvas</code> en introduisant un <code>Dictionary</code> , ce qui nous permet de rechercher l'index de n'importe quelle forme en fonction de son ID.  Nous allons commencer par changer le niveau d'accès de notre tableau de <code>shapes</code> en <code>private</code> afin de pouvoir contrôler l'insertion des éléments à l'aide de la nouvelle méthode <code>add</code> .  Et chaque fois qu'une nouvelle figure est ajoutée, nous ajoutons également son index à notre dictionnaire: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Puisque maintenant nous savons toujours à quel index une figure donnée est stockée, nous pouvons rapidement effectuer la suppression en temps constant, comme lors de l'utilisation d'un ensemble: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Cependant, il y a un bug assez sérieux dans notre nouvelle implémentation de <code>Canvas</code> .  Chaque fois que nous supprimons une forme, nous invalidons en fait tous les index qui sont supérieurs à celui que nous venons de supprimer - puisque chacun de ces éléments se déplacera d'une étape au début du tableau.  Nous pourrions résoudre ce problème en ajustant ces indices après chaque suppression, mais cela nous ramènerait à nouveau sur le territoire O (N), ce que nous avons essayé d'éviter dès le début. <br><br>  Notre dernière mise en œuvre a ses mérites.  En général, l'utilisation d'une combinaison de deux structures de données peut être une excellente idée dans de telles situations, car nous pouvons souvent utiliser les forces d'une structure de données pour compenser les lacunes de l'autre, et vice versa. <br><br>  Réessayons donc avec une combinaison différente, mais cette fois commençons par considérer nos <i>besoins réels</i> : <br><br><ul><li>  Nous avons besoin d'insertions et de suppressions pour avoir une complexité temporelle constante, et il devrait être possible de supprimer la figure sans connaître son index de base. </li><li>  Nous avons besoin d'un ordre de tri garanti afin de pouvoir maintenir un ordre de rendu stable. </li></ul><br>  En regardant les exigences ci-dessus, il s'avère que bien que nous ayons besoin d'un ordre de tri stable, nous n'avons en fait pas besoin d'index.  Cela rendrait la liste chaînée parfaite pour notre cas d'utilisation. <br><br>  Les listes liées sont constituées de nœuds, où chaque nœud contient un lien (ou lien) vers le nœud suivant dans la liste, ce qui signifie qu'il peut être trié de manière prévisible - sans avoir besoin de mises à jour d'index lorsqu'un élément est supprimé.  Cependant, la bibliothèque standard Swift (jusqu'à présent) ne contient pas de type de liste liée, donc si nous voulons l'utiliser, nous devons d'abord le créer. <br><br><h3>  Créer une liste chaînée </h3><br>  Commençons par déclarer une structure <code>List</code> qui suivra les premier et dernier nœuds de notre liste.  Nous allons rendre ces deux propriétés en lecture seule en dehors de notre type pour assurer la cohérence des données: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Ensuite, créons notre type de nœud (nœud), que nous allons créer une classe, car nous voulons pouvoir faire référence aux nœuds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par référence, et non par valeur</a> .  Notre liste sera doublement connectée, ce qui signifie que chaque nœud contiendra un lien vers son prochain voisin et le précédent.  Chaque nœud stockera également une valeur - comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  La raison pour laquelle nous rendons la propriété précédente faible est d'éviter les boucles de rétention qui apparaîtraient si nous conservions des liens solides dans les deux sens.  Pour en savoir plus sur la façon d'éviter les cycles de conservation, consultez l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Gestion de la mémoire»</a> . </blockquote>  C'est en fait tout le code dont nous avons besoin pour que les valeurs puissent être stockées dans notre liste chaînée.  Mais ce n'est que la première partie du puzzle, comme dans toute autre collection, nous voulons également pouvoir le parcourir et changer son contenu.  Commençons par les itérations qui, grâce à la conception Swift très orientée protocole, peuvent être facilement implémentées en garantissant la conformité au protocole <code>Sequence</code> et en implémentant la méthode <code>makeIterator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  Étant donné que l'itération ci-dessus est très simple, nous utilisons la bibliothèque standard <code>AnyIterator</code> pour éviter d'avoir à implémenter un type d'itérateur personnalisé.  Pour les scénarios plus complexes, il peut être implémenté en ajoutant une correspondance à <code>IteratorProtocol</code> . </blockquote>  Ensuite, ajoutons une API pour modifier notre liste de liens, en commençant par les insertions.  Nous allons étendre la <code>List</code> avec la méthode <code>append</code> , qui ajoute un nouveau nœud pour la valeur insérée, puis retourne ce nœud - comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Ci-dessus, nous utilisons l'attribut <code>@discardableResult</code> , qui indique au compilateur de ne générer aucun avertissement si le résultat de l'appel de notre méthode n'a pas été utilisé, car nous ne sommes pas toujours intéressés par le nœud qui a été créé. </blockquote>  Étant donné que les listes liées ne sont pas basées sur des index, mais sur le maintien d'une chaîne de valeurs via des liens, l'implémentation des suppressions consiste simplement à mettre à jour les voisins suivants et précédents des nœuds distants afin qu'ils se pointent à la place: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  « »,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Sur la base de ce qui précède, la version initiale de notre liste est terminée et nous sommes prêts à la vérifier en action.  Mettons à jour le canevas pour utiliser notre nouvelle liste, ainsi qu'un dictionnaire qui nous permet de trouver rapidement quel nœud correspond à un ID de forme donné: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Maintenant, nous avons à la fois des insertions et des suppressions rapides, et un ordre de tri prévisible, sans avoir besoin d'ajouter une complexité supplémentaire au processus d'appel - c'est plutôt cool!  Et, puisque notre nouvelle liste est un type complètement universel, nous pouvons maintenant l'utiliser chaque fois que nous devons à nouveau stocker des valeurs sans index de manière linéaire. <br><br><h3>  Conclusion </h3><br>  Malgré le fait que les structures de données sont si fondamentales qu'elles peuvent être trouvées dans toutes sortes de langages de programmation, la décision quant à celui à utiliser dans chaque situation spécifique peut encore nécessiter une quantité importante de réflexion, de test et d'expérimentation, surtout si nous voulons afin que notre code reste efficace à mesure que l'ensemble de données se développe. <br><br>  Il est également très probable que la structure de données appropriée pour chaque situation spécifique puisse changer au fil du temps à mesure que nos besoins changent, et parfois utiliser une combinaison de plusieurs structures de données, et pas seulement une, peut être un moyen d'atteindre les caractéristiques de performance requises. <br><br>  Nous continuerons d'explorer le monde des structures de données dans les articles suivants, en nous concentrant sur celles qui ne sont pas encore implémentées dans la bibliothèque standard.  Comme pour tant d'autres choses, nous devons parfois élargir notre réflexion au-delà de Swift pour choisir la bonne structure de données pour chaque situation. <br><br>  Vous pouvez me trouver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Twitter</a> ou m'envoyer un courriel si vous avez des questions, des commentaires ou des commentaires. <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468239/">https://habr.com/ru/post/fr468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468229/index.html">Une note sur void en JavaScript et TypeScript</a></li>
<li><a href="../fr468231/index.html">La sécurité dans AEM est-elle un problème de plate-forme ou d'implémentation?</a></li>
<li><a href="../fr468233/index.html">La façon de taper la vérification de 4 millions de lignes de code Python. partie 1</a></li>
<li><a href="../fr468235/index.html">La façon de taper la vérification de 4 millions de lignes de code Python. 2e partie</a></li>
<li><a href="../fr468237/index.html">La façon de taper la vérification de 4 millions de lignes de code Python. 3e partie</a></li>
<li><a href="../fr468241/index.html">TR-069 chez Mikrotik. Test de Freeacs en tant que serveur de configuration automatique pour RouterOS</a></li>
<li><a href="../fr468245/index.html">Nous n'avons pas besoin de corrections de traduction: notre traducteur sait mieux comment cela doit être traduit</a></li>
<li><a href="../fr468251/index.html">Il n'y a pas d'avenir</a></li>
<li><a href="../fr468253/index.html">Curseur d'image simple en CSS et Javascript</a></li>
<li><a href="../fr468259/index.html">Cinq temps forts du Helm Summit 2019 à Amsterdam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>