<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè´ ü•à üë©üèΩ‚Äçü§ù‚Äçüë®üèæ Choisir la bonne structure de donn√©es dans Swift üê¢ üåÖ üë©üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour encore. Avant de partir pour le week-end, nous voulons partager avec vous une traduction de mat√©riel qui a √©t√© pr√©par√© sp√©cifiquement pour le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Choisir la bonne structure de donn√©es dans Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Bonjour encore.</i>  <i>Avant de partir pour le week-end, nous voulons partager avec vous une traduction de mat√©riel qui a √©t√© pr√©par√© sp√©cifiquement pour le cours de base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´D√©veloppeur iOS¬ª</a> .</i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  D√©cider de la structure de donn√©es √† utiliser pour repr√©senter un ensemble de valeurs donn√© est souvent beaucoup plus difficile qu'il n'y para√Æt.  √âtant donn√© que chaque type de structure de donn√©es est optimis√© pour un certain nombre de cas d'utilisation, le choix du bon ajustement pour chaque ensemble de donn√©es peut souvent avoir un impact important sur les performances de notre code. <a name="habracut"></a><br><br>  La biblioth√®que Swift standard est livr√©e avec trois structures de donn√©es principales - <code>Array</code> , <code>Dictionary</code> et <code>Set</code> , chacune ayant son propre ensemble d'optimisations, avantages et inconv√©nients.  Examinons certaines de leurs caract√©ristiques, ainsi que les cas o√π nous devrons peut-√™tre aller au-del√† de la biblioth√®que standard pour trouver la bonne structure de donn√©es pour nos besoins. <br><br><h3>  Lin√©arit√© du tableau </h3><br>  <code>Array</code> est probablement l'une des structures de donn√©es les plus couramment utilis√©es dans Swift, et il y a de bonnes raisons √† cela.  Il stocke ses √©l√©ments de mani√®re s√©quentielle, ils sont facilement tri√©s de mani√®re pr√©visible et toutes les valeurs peuvent y √™tre stock√©es: des structures aux instances de classes et autres collections. <br><br>  Par exemple, ici, nous utilisons un tableau pour stocker une collection de formes plac√©es sur une <code>Canvas</code> dans une application de dessin.  Ensuite, lorsque nous devons rendre le canevas dans une image, nous <code>DrawingContext</code> simplement le tableau pour dessiner chaque √©l√©ment √† l'aide de <code>DrawingContext</code> - comme suit: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  En ce qui concerne le rendu s√©quentiel de toutes nos formes, comme nous l'avons fait ci-dessus, le tableau s'adapte parfaitement.  Les tableaux stockent non seulement leurs √©l√©ments de mani√®re tr√®s efficace, ils ont √©galement un ordre de tri garanti, qui fournit un ordre de rendu pr√©visible sans avoir √† faire de travail suppl√©mentaire. <br><br>  Cependant, comme toutes les autres structures de donn√©es, les tableaux ont leurs inconv√©nients.  Dans notre cas, nous rencontrerons l'un de ses inconv√©nients lorsque nous voulons supprimer des formes du canevas.  √âtant donn√© que les √©l√©ments du tableau sont stock√©s par index, nous devons toujours trouver √† quel index le chiffre est associ√© avant de pouvoir le supprimer: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Au d√©but, le code ci-dessus peut ne pas sembler si probl√©matique, mais il peut devenir un goulot d'√©tranglement de performances pour tout canevas contenant un grand nombre de formes, car <code>firstIndex</code> est lin√©aire (O (N)) en termes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complexit√© temporelle</a> . <br><br>  Bien que nous puissions contourner cette limitation lorsque nous utilisons notre type de canevas.  Par exemple, toujours se r√©f√©rer aux chiffres par index, et non par valeur ou ID - cela rendrait notre code plus complexe et plus fragile, car nous devrions toujours √™tre s√ªrs que nos index n'expirent pas lorsque le canevas avec lequel nous travaillons va changer. <br><br><h3>  Ensembles de vitesse </h3><br>  √Ä la place, voyons si nous pouvons optimiser le <code>Canvas</code> lui-m√™me en modifiant sa structure de donn√©es sous-jacente.  Compte tenu du probl√®me ci-dessus, l'une de nos premi√®res id√©es pourrait √™tre d'utiliser <code>Set</code> (sets) au lieu de <code>Array</code> .  Comme nous l'avons d√©j√† expliqu√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La puissance des ensembles dans Swift</a> , l'un des avantages importants des ensembles par rapport aux tableaux est que l'insertion et la suppression peuvent toujours √™tre effectu√©es dans un temps constant (O (1)), puisque les √©l√©ments sont stock√©s par valeur de hachage, pas par index. <br><br>  En mettant √† jour <code>Canvas</code> pour utiliser des ensembles, nous obtenons ce qui suit: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Encore une fois, le code ci-dessus peut sembler correct et il se compile m√™me sans probl√®me.  Cependant, bien que nous ayons r√©solu le probl√®me de suppression, nous avons √©galement perdu notre ordre de rendu stable - car, contrairement aux tableaux, les ensembles ne nous donnent pas un ordre de tri garanti - ce qui est une pierre d'achoppement dans cette situation, car il semble que nous allons dessiner des formes personnalis√©es dans au hasard. <br><br><h3>  Indexation des index </h3><br>  Continuons d'exp√©rimenter.  Voyons maintenant si nous pouvons optimiser le <code>Canvas</code> en introduisant un <code>Dictionary</code> , ce qui nous permet de rechercher l'index de n'importe quelle forme en fonction de son ID.  Nous allons commencer par changer le niveau d'acc√®s de notre tableau de <code>shapes</code> en <code>private</code> afin de pouvoir contr√¥ler l'insertion des √©l√©ments √† l'aide de la nouvelle m√©thode <code>add</code> .  Et chaque fois qu'une nouvelle figure est ajout√©e, nous ajoutons √©galement son index √† notre dictionnaire: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Puisque maintenant nous savons toujours √† quel index une figure donn√©e est stock√©e, nous pouvons rapidement effectuer la suppression en temps constant, comme lors de l'utilisation d'un ensemble: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Cependant, il y a un bug assez s√©rieux dans notre nouvelle impl√©mentation de <code>Canvas</code> .  Chaque fois que nous supprimons une forme, nous invalidons en fait tous les index qui sont sup√©rieurs √† celui que nous venons de supprimer - puisque chacun de ces √©l√©ments se d√©placera d'une √©tape au d√©but du tableau.  Nous pourrions r√©soudre ce probl√®me en ajustant ces indices apr√®s chaque suppression, mais cela nous ram√®nerait √† nouveau sur le territoire O (N), ce que nous avons essay√© d'√©viter d√®s le d√©but. <br><br>  Notre derni√®re mise en ≈ìuvre a ses m√©rites.  En g√©n√©ral, l'utilisation d'une combinaison de deux structures de donn√©es peut √™tre une excellente id√©e dans de telles situations, car nous pouvons souvent utiliser les forces d'une structure de donn√©es pour compenser les lacunes de l'autre, et vice versa. <br><br>  R√©essayons donc avec une combinaison diff√©rente, mais cette fois commen√ßons par consid√©rer nos <i>besoins r√©els</i> : <br><br><ul><li>  Nous avons besoin d'insertions et de suppressions pour avoir une complexit√© temporelle constante, et il devrait √™tre possible de supprimer la figure sans conna√Ætre son index de base. </li><li>  Nous avons besoin d'un ordre de tri garanti afin de pouvoir maintenir un ordre de rendu stable. </li></ul><br>  En regardant les exigences ci-dessus, il s'av√®re que bien que nous ayons besoin d'un ordre de tri stable, nous n'avons en fait pas besoin d'index.  Cela rendrait la liste cha√Æn√©e parfaite pour notre cas d'utilisation. <br><br>  Les listes li√©es sont constitu√©es de n≈ìuds, o√π chaque n≈ìud contient un lien (ou lien) vers le n≈ìud suivant dans la liste, ce qui signifie qu'il peut √™tre tri√© de mani√®re pr√©visible - sans avoir besoin de mises √† jour d'index lorsqu'un √©l√©ment est supprim√©.  Cependant, la biblioth√®que standard Swift (jusqu'√† pr√©sent) ne contient pas de type de liste li√©e, donc si nous voulons l'utiliser, nous devons d'abord le cr√©er. <br><br><h3>  Cr√©er une liste cha√Æn√©e </h3><br>  Commen√ßons par d√©clarer une structure <code>List</code> qui suivra les premier et dernier n≈ìuds de notre liste.  Nous allons rendre ces deux propri√©t√©s en lecture seule en dehors de notre type pour assurer la coh√©rence des donn√©es: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Ensuite, cr√©ons notre type de n≈ìud (n≈ìud), que nous allons cr√©er une classe, car nous voulons pouvoir faire r√©f√©rence aux n≈ìuds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par r√©f√©rence, et non par valeur</a> .  Notre liste sera doublement connect√©e, ce qui signifie que chaque n≈ìud contiendra un lien vers son prochain voisin et le pr√©c√©dent.  Chaque n≈ìud stockera √©galement une valeur - comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  La raison pour laquelle nous rendons la propri√©t√© pr√©c√©dente faible est d'√©viter les boucles de r√©tention qui appara√Ætraient si nous conservions des liens solides dans les deux sens.  Pour en savoir plus sur la fa√ßon d'√©viter les cycles de conservation, consultez l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Gestion de la m√©moire¬ª</a> . </blockquote>  C'est en fait tout le code dont nous avons besoin pour que les valeurs puissent √™tre stock√©es dans notre liste cha√Æn√©e.  Mais ce n'est que la premi√®re partie du puzzle, comme dans toute autre collection, nous voulons √©galement pouvoir le parcourir et changer son contenu.  Commen√ßons par les it√©rations qui, gr√¢ce √† la conception Swift tr√®s orient√©e protocole, peuvent √™tre facilement impl√©ment√©es en garantissant la conformit√© au protocole <code>Sequence</code> et en impl√©mentant la m√©thode <code>makeIterator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  √âtant donn√© que l'it√©ration ci-dessus est tr√®s simple, nous utilisons la biblioth√®que standard <code>AnyIterator</code> pour √©viter d'avoir √† impl√©menter un type d'it√©rateur personnalis√©.  Pour les sc√©narios plus complexes, il peut √™tre impl√©ment√© en ajoutant une correspondance √† <code>IteratorProtocol</code> . </blockquote>  Ensuite, ajoutons une API pour modifier notre liste de liens, en commen√ßant par les insertions.  Nous allons √©tendre la <code>List</code> avec la m√©thode <code>append</code> , qui ajoute un nouveau n≈ìud pour la valeur ins√©r√©e, puis retourne ce n≈ìud - comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Ci-dessus, nous utilisons l'attribut <code>@discardableResult</code> , qui indique au compilateur de ne g√©n√©rer aucun avertissement si le r√©sultat de l'appel de notre m√©thode n'a pas √©t√© utilis√©, car nous ne sommes pas toujours int√©ress√©s par le n≈ìud qui a √©t√© cr√©√©. </blockquote>  √âtant donn√© que les listes li√©es ne sont pas bas√©es sur des index, mais sur le maintien d'une cha√Æne de valeurs via des liens, l'impl√©mentation des suppressions consiste simplement √† mettre √† jour les voisins suivants et pr√©c√©dents des n≈ìuds distants afin qu'ils se pointent √† la place: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  ¬´ ¬ª,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Sur la base de ce qui pr√©c√®de, la version initiale de notre liste est termin√©e et nous sommes pr√™ts √† la v√©rifier en action.  Mettons √† jour le canevas pour utiliser notre nouvelle liste, ainsi qu'un dictionnaire qui nous permet de trouver rapidement quel n≈ìud correspond √† un ID de forme donn√©: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Maintenant, nous avons √† la fois des insertions et des suppressions rapides, et un ordre de tri pr√©visible, sans avoir besoin d'ajouter une complexit√© suppl√©mentaire au processus d'appel - c'est plut√¥t cool!  Et, puisque notre nouvelle liste est un type compl√®tement universel, nous pouvons maintenant l'utiliser chaque fois que nous devons √† nouveau stocker des valeurs sans index de mani√®re lin√©aire. <br><br><h3>  Conclusion </h3><br>  Malgr√© le fait que les structures de donn√©es sont si fondamentales qu'elles peuvent √™tre trouv√©es dans toutes sortes de langages de programmation, la d√©cision quant √† celui √† utiliser dans chaque situation sp√©cifique peut encore n√©cessiter une quantit√© importante de r√©flexion, de test et d'exp√©rimentation, surtout si nous voulons afin que notre code reste efficace √† mesure que l'ensemble de donn√©es se d√©veloppe. <br><br>  Il est √©galement tr√®s probable que la structure de donn√©es appropri√©e pour chaque situation sp√©cifique puisse changer au fil du temps √† mesure que nos besoins changent, et parfois utiliser une combinaison de plusieurs structures de donn√©es, et pas seulement une, peut √™tre un moyen d'atteindre les caract√©ristiques de performance requises. <br><br>  Nous continuerons d'explorer le monde des structures de donn√©es dans les articles suivants, en nous concentrant sur celles qui ne sont pas encore impl√©ment√©es dans la biblioth√®que standard.  Comme pour tant d'autres choses, nous devons parfois √©largir notre r√©flexion au-del√† de Swift pour choisir la bonne structure de donn√©es pour chaque situation. <br><br>  Vous pouvez me trouver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Twitter</a> ou m'envoyer un courriel si vous avez des questions, des commentaires ou des commentaires. <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468239/">https://habr.com/ru/post/fr468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468229/index.html">Une note sur void en JavaScript et TypeScript</a></li>
<li><a href="../fr468231/index.html">La s√©curit√© dans AEM est-elle un probl√®me de plate-forme ou d'impl√©mentation?</a></li>
<li><a href="../fr468233/index.html">La fa√ßon de taper la v√©rification de 4 millions de lignes de code Python. partie 1</a></li>
<li><a href="../fr468235/index.html">La fa√ßon de taper la v√©rification de 4 millions de lignes de code Python. 2e partie</a></li>
<li><a href="../fr468237/index.html">La fa√ßon de taper la v√©rification de 4 millions de lignes de code Python. 3e partie</a></li>
<li><a href="../fr468241/index.html">TR-069 chez Mikrotik. Test de Freeacs en tant que serveur de configuration automatique pour RouterOS</a></li>
<li><a href="../fr468245/index.html">Nous n'avons pas besoin de corrections de traduction: notre traducteur sait mieux comment cela doit √™tre traduit</a></li>
<li><a href="../fr468251/index.html">Il n'y a pas d'avenir</a></li>
<li><a href="../fr468253/index.html">Curseur d'image simple en CSS et Javascript</a></li>
<li><a href="../fr468259/index.html">Cinq temps forts du Helm Summit 2019 √† Amsterdam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>