<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíì üõÅ üëßüèø Los punteros en C son m√°s abstractos de lo que piensas ü§∂ üïì üßòüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El puntero se refiere a una celda de memoria, y desreferenciar un puntero significa leer el valor de la celda especificada. El valor del puntero en s√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los punteros en C son m√°s abstractos de lo que piensas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  El puntero se <i>refiere</i> a una celda de memoria, y <i>desreferenciar un</i> puntero significa leer el valor de la celda especificada.  El valor del puntero en s√≠ es la direcci√≥n de la celda de memoria.  El est√°ndar del lenguaje C no especifica la forma para representar las direcciones de memoria.  Este es un punto muy importante, ya que diferentes arquitecturas pueden usar diferentes modelos de direccionamiento.  La mayor√≠a de las arquitecturas modernas usan un espacio de direcciones lineal o similar.  Sin embargo, incluso esta pregunta no se especifica estrictamente, ya que las direcciones pueden ser f√≠sicas o virtuales.  Algunas arquitecturas utilizan una representaci√≥n no num√©rica en absoluto.  Entonces, Symbolics Lisp Machine opera con tuplas de la forma <i>(objeto, desplazamiento)</i> como direcciones. <br><a name="habracut"></a><table><tbody><tr><td>  Alg√∫n tiempo despu√©s, despu√©s de la publicaci√≥n de la traducci√≥n en Habr√©, el autor realiz√≥ grandes modificaciones al texto del art√≠culo.  Actualizar una traducci√≥n en Habr√© no es una buena idea, ya que algunos comentarios perder√°n su significado o se ver√°n fuera de lugar.  No quiero publicar el texto como un nuevo art√≠culo.  Por lo tanto, acabamos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">actualizar la traducci√≥n del art√≠culo</a> en viva64.com, y aqu√≠ dejamos todo tal como est√°.  Si es un lector nuevo, le sugiero que lea una traducci√≥n m√°s reciente en nuestro sitio haciendo clic en el enlace de arriba. </td></tr></tbody></table><br>  El est√°ndar no estipula la forma de presentaci√≥n de los punteros, sino que estipula, en mayor o menor medida, las operaciones con ellos.  A continuaci√≥n consideramos estas operaciones y las caracter√≠sticas de su definici√≥n en el est√°ndar.  Comencemos con el siguiente ejemplo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Si compilamos este c√≥digo GCC con el nivel de optimizaci√≥n 1 y ejecutamos el programa en Linux x86-64, imprimir√° lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Tenga en cuenta que los punteros <i>pyq se</i> refieren a la misma direcci√≥n.  Sin embargo, el resultado de la expresi√≥n <i>p == q</i> es <i>falso</i> , y esto a primera vista parece extra√±o.  ¬øNo deber√≠an ser iguales dos punteros a la misma direcci√≥n? <br><br>  As√≠ es como el est√°ndar C define el resultado de verificar la igualdad de dos punteros: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.9 p√°rrafo 6</b> <br><br>  Dos punteros son iguales si y solo si ambos son cero, ya sea que apunten al mismo objeto (incluido un puntero al objeto y el primer subobjeto en el objeto) o una funci√≥n, o apunten a la posici√≥n despu√©s del √∫ltimo elemento de la matriz, o un puntero se refiere a la posici√≥n despu√©s del √∫ltimo elemento de la matriz, y la otra se refiere al comienzo de otra matriz inmediatamente despu√©s de la primera en el mismo espacio de direcciones. </td></tr></tbody></table><br>  En primer lugar, surge la pregunta: ¬øqu√© es un "objeto <i>"</i> ?  Como estamos hablando del lenguaje C, es obvio que aqu√≠ los objetos no tienen nada que ver con objetos en lenguajes OOP como C ++.  En el est√°ndar C, este concepto no est√° completamente definido: <br><table><tbody><tr><td>  <b>C11 ¬ß 3.15</b> <br><br>  Un objeto es un √°rea de almacenamiento en tiempo de ejecuci√≥n cuyo contenido se puede usar para representar valores <br><br>  NOTA Cuando se menciona, se puede considerar que un objeto tiene un tipo espec√≠fico;  ver 6.3.2.1. </td></tr></tbody></table><br>  Vamos a hacerlo bien.  Una variable entera de 16 bits es un conjunto de datos en la memoria que puede representar valores enteros de 16 bits.  Por lo tanto, dicha variable es un objeto.  ¬øSer√°n iguales dos punteros si uno de ellos se refiere al primer byte de un entero dado y el segundo al segundo byte del mismo n√∫mero?  El comit√© de estandarizaci√≥n del idioma, por supuesto, no quiso decir esto en absoluto.  Pero aqu√≠ debe tenerse en cuenta que a este respecto no tiene explicaciones claras, y nos vemos obligados a adivinar lo que realmente significaba. <br><br><h3>  Cuando el compilador se interpone </h3><br>  Volvamos a nuestro primer ejemplo.  El puntero <i>p se</i> obtiene del objeto <i>a</i> , y el puntero <i>q</i> es del objeto <i>b</i> .  En el segundo caso, se usa la aritm√©tica de direcciones, que se define para los operadores m√°s y menos de la siguiente manera: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 cl√°usula 7</b> <br><br>  Cuando se usa con estos operadores, un puntero a un objeto que no es un elemento de la matriz se comporta como un puntero al comienzo de una matriz con una longitud de un elemento, cuyo tipo corresponde al tipo del objeto original. </td></tr></tbody></table><br>  Dado que cualquier puntero a un objeto que no sea una matriz en <i>realidad se</i> convierte en un puntero a una matriz con una longitud de un elemento, el est√°ndar define la aritm√©tica de direcciones solo para punteros a matrices; este es el punto 8. Nos interesa la siguiente parte: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 cl√°usula 8</b> <br><br>  Si se agrega o resta una expresi√≥n entera del puntero, el puntero resultante es del mismo tipo que el puntero original.  Si el puntero fuente se refiere a un elemento de matriz y la matriz tiene una longitud suficiente, entonces la fuente y los elementos resultantes se separan entre s√≠ para que la diferencia entre sus √≠ndices sea igual al valor de la expresi√≥n entera.  En otras palabras, si la expresi√≥n <i>P</i> apunta al elemento i-√©simo de la matriz, las expresiones <i>(P) + N</i> (o su equivalente <i>N + (P)</i> ) y <i>(P) -N</i> (donde <i>N</i> tiene el valor n) indican respectivamente (i + n) th y (i - n) th elementos de la matriz, siempre que existan.  Adem√°s, si la expresi√≥n <i>P</i> apunta al √∫ltimo elemento de la matriz, entonces la expresi√≥n <i>(P) +1</i> indica la posici√≥n despu√©s del √∫ltimo elemento de la matriz, y si la expresi√≥n <i>Q</i> indica la posici√≥n despu√©s del √∫ltimo elemento de la matriz, entonces la expresi√≥n <i>(Q) -1</i> indica el √∫ltimo elemento matriz.  Si tanto los punteros fuente como los punteros resultantes se refieren a elementos de la misma matriz o a la posici√≥n despu√©s del √∫ltimo elemento de la matriz, se excluye el desbordamiento;  de lo contrario, el comportamiento es indefinido.  Si el puntero resultante se refiere a la posici√≥n despu√©s del √∫ltimo elemento de la matriz, el operador unario <i>*</i> no se puede aplicar a √©l. </td></tr></tbody></table><br>  De ello se deduce que el resultado de la expresi√≥n <i>&amp; b + 1</i> definitivamente debe ser una direcci√≥n, y por lo tanto <i>pyq</i> son punteros v√°lidos.  Perm√≠tame recordarle c√≥mo se define la igualdad de dos punteros en el est√°ndar: " <i>Dos punteros son iguales si y solo [...] un puntero se refiere a la posici√≥n despu√©s del √∫ltimo elemento del conjunto, y el otro al comienzo de otro conjunto inmediatamente despu√©s del primero en el mismo espacio de direcciones "</i> (C11 ¬ß 6.5.9 cl√°usula 6).  Esto es exactamente lo que observamos en nuestro ejemplo.  El puntero q se refiere a la posici√≥n despu√©s del objeto b, seguido inmediatamente por el objeto a, al que se refiere el puntero p.  Entonces, ¬øhay un error en GCC?  Esta contradicci√≥n se describi√≥ en 2014 como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error n. ¬∞ 61502</a> , pero los desarrolladores de GCC no lo consideran un error y, por lo tanto, no lo solucionar√°n. <br><br>  Un problema similar fue encontrado en 2016 por los programadores de Linux.  Considere el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Los s√≠mbolos <i>_start</i> y <i>_end</i> especifican los l√≠mites del √°rea de memoria.  Como se transfieren a un archivo externo, el compilador no sabe c√≥mo se ubican realmente las matrices en la memoria.  Por esta raz√≥n, debe tener cuidado aqu√≠ y proceder de la suposici√≥n de que se siguen en el espacio de direcciones.  Sin embargo, GCC compila la condici√≥n del bucle para que siempre sea verdadera, lo que hace que el bucle sea infinito.  Este problema se describe aqu√≠ en esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n en LKML</a> : all√≠ se usa un fragmento de c√≥digo similar.  Parece que en este caso, los autores de GCC sin embargo tomaron en cuenta los comentarios y cambiaron el comportamiento del compilador.  Al menos no pude reproducir este error en GCC versi√≥n 7.3.1 bajo Linux x86_64. <br><br><h3>  ¬øSoluci√≥n - en el informe de error # 260? </h3><br>  Nuestro caso puede aclarar el informe de error <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 260</a> .  Se trata m√°s de valores inciertos, pero puede encontrar un curioso comentario del comit√© en √©l: <br><br>  <i>Las implementaciones del compilador [...] tambi√©n pueden distinguir los punteros obtenidos de diferentes objetos, incluso si estos punteros tienen el mismo conjunto de bits.</i> <br><br>  Si tomamos este comentario literalmente, entonces es l√≥gico que el resultado de la expresi√≥n <i>p == q</i> sea ‚Äã‚Äã"falso", ya que <i>pyq se</i> obtienen de diferentes objetos que no est√°n conectados de ninguna manera.  Parece que nos estamos acercando a la verdad, ¬øo no?  Hasta ahora, hemos tratado con operadores de igualdad, pero ¬øqu√© pasa con los operadores de relaci√≥n? <br><br><h3>  La pista final es en relaci√≥n a los operadores? </h3><br>  La definici√≥n de los operadores de relaci√≥n <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> y <i>&gt; =</i> en el contexto de las comparaciones de punteros contiene un pensamiento curioso: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.8 p√°rrafo 5</b> <br><br>  El resultado de comparar dos punteros depende de la posici√≥n relativa de los objetos indicados en el espacio de direcciones.  Si dos punteros a tipos de objeto se refieren al mismo objeto, o ambos se refieren a la posici√≥n despu√©s del √∫ltimo elemento de la misma matriz, entonces dichos punteros son iguales.  Si los objetos indicados son miembros del mismo objeto compuesto, los punteros a los miembros de la estructura declarada m√°s tarde son m√°s que punteros a los miembros declarados anteriormente, y los punteros a elementos de una matriz con √≠ndices m√°s altos son m√°s que punteros a elementos de la misma matriz con √≠ndices m√°s bajos.  Todos los punteros a los miembros de la misma asociaci√≥n son iguales.  Si la expresi√≥n <i>P</i> apunta a un elemento de la matriz y la expresi√≥n <i>Q</i> apunta al √∫ltimo elemento de la misma matriz, entonces el valor de la expresi√≥n de puntero <i>Q + 1 es</i> mayor que el valor de la expresi√≥n <i>P.</i>  En todos los dem√°s casos, el comportamiento no est√° definido. </td></tr></tbody></table><br>  Seg√∫n esta definici√≥n, el resultado de comparar punteros se determina solo si los punteros se obtienen del <i>mismo</i> objeto.  Mostramos esto con dos ejemplos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Aqu√≠, los punteros <i>p</i> y <i>q se</i> refieren a dos objetos diferentes que no est√°n interconectados.  Por lo tanto, el resultado de su comparaci√≥n no est√° definido.  Pero en el siguiente ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  Los punteros <i>pyq se</i> refieren al mismo objeto y, por lo tanto, est√°n interconectados.  Por lo tanto, se pueden comparar, a menos que <i>malloc</i> devuelva un valor nulo. <br><br><h3>  Resumen </h3><br>  El est√°ndar C11 no describe adecuadamente las comparaciones de punteros.  El punto m√°s problem√°tico que encontramos fue el p√°rrafo 6 ¬ß 6.5.9, donde se permite expl√≠citamente comparar dos punteros que hacen referencia a dos matrices diferentes.  Esto contradice el comentario del informe de error # 260.  Sin embargo, all√≠ estamos hablando de significados indefinidos, y no quisiera construir mi razonamiento sobre la base de este comentario solo e interpretarlo en otro contexto.  Al comparar punteros, los operadores de relaci√≥n se definen de manera ligeramente diferente que los operadores de igualdad, es decir, los operadores de relaci√≥n se definen solo si ambos punteros se obtienen del <i>mismo</i> objeto. <br><br>  Si ignoramos el texto del est√°ndar y preguntamos si es posible comparar dos punteros obtenidos de dos objetos diferentes, entonces, en cualquier caso, la respuesta probablemente sea "no".  El ejemplo al comienzo del art√≠culo demuestra un problema te√≥rico.  Como las variables <i>ayb</i> tienen duraciones de almacenamiento autom√°ticas, nuestras suposiciones sobre su ubicaci√≥n en la memoria no ser√°n confiables.  En algunos casos, podemos adivinar, pero es obvio que dicho c√≥digo no se puede portar de forma segura, y puede descubrir el significado del programa solo compilando, ejecutando o desensamblando el c√≥digo, y esto contradice cualquier paradigma de programaci√≥n serio. <br><br>  Sin embargo, en general, no estoy satisfecho con la redacci√≥n del est√°ndar C11, y dado que varias personas ya se han encontrado con este problema, la pregunta sigue siendo: ¬øpor qu√© no formular las reglas m√°s claramente? <br><br><h3>  Adem√°s <br>  Punteros a la posici√≥n despu√©s del √∫ltimo elemento de la matriz. </h3><br>  En cuanto a la regla sobre comparaci√≥n y direccionamiento aritm√©tico de punteros a la posici√≥n despu√©s del √∫ltimo elemento de la matriz, a menudo puede encontrar excepciones.  Suponga que el est√°ndar no permitir√≠a comparar dos punteros obtenidos de <i>la misma</i> matriz, aunque al menos uno de ellos se refiera a la posici√≥n m√°s all√° del final de la matriz.  Entonces el siguiente c√≥digo no funcionar√≠a: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Usando un bucle, recorremos toda la matriz <i>x</i> , que consta de 64 elementos, es decir  El cuerpo del bucle debe ejecutarse exactamente 64 veces.  Pero, de hecho, la condici√≥n se verifica 65 veces, una vez m√°s que el n√∫mero de elementos en la matriz.  En las primeras 64 iteraciones, el puntero <i>i</i> siempre se refiere al interior de la matriz <i>x</i> , mientras que la expresi√≥n <i>&amp; x [num]</i> siempre indica la posici√≥n despu√©s del √∫ltimo elemento de la matriz.  En la 65¬™ iteraci√≥n, el puntero <i>i</i> tambi√©n se referir√° a la posici√≥n m√°s all√° del final de la matriz <i>x</i> , por lo que la condici√≥n del bucle se vuelve falsa.  Esta es una forma conveniente de omitir toda la matriz, y se basa en una excepci√≥n a la regla de incertidumbre en el comportamiento al comparar dichos punteros.  Tenga en cuenta que el est√°ndar solo describe el comportamiento al comparar punteros;  la desreferenciaci√≥n es un tema aparte. <br><br>  ¬øEs posible cambiar nuestro ejemplo para que ning√∫n puntero se refiera a la posici√≥n despu√©s del √∫ltimo elemento de la matriz <i>x</i> ?  Es posible, pero ser√° m√°s dif√≠cil.  Tendremos que cambiar la condici√≥n del bucle y prohibir el incremento de la variable <i>i</i> en la √∫ltima iteraci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Este c√≥digo est√° lleno de sutilezas t√©cnicas, lo que hace que se distraiga de la tarea principal.  Adem√°s, apareci√≥ una rama adicional en el cuerpo del bucle.  Por lo tanto, considero razonable que el est√°ndar permita excepciones al comparar punteros de posici√≥n despu√©s del √∫ltimo elemento de una matriz. <br><br>  <b><i>Nota del equipo PVS-Studio</i></b> <br><br>  <i>Al desarrollar el analizador de c√≥digo PVS-Studio, a veces tenemos que lidiar con problemas sutiles para que los diagn√≥sticos sean m√°s precisos o para brindar consultas detalladas a nuestros clientes.</i>  <i>Este art√≠culo nos pareci√≥ interesante, ya que toca temas en los que nosotros mismos no nos sentimos completamente seguros.</i>  <i>Por lo tanto, le pedimos a la autora que publicara su traducci√≥n.</i>  <i>Esperamos que m√°s programadores de C y C ++ la conozcan y comprendan que no es tan simple y que cuando el analizador muestra de repente un mensaje extra√±o, no debe apresurarse a considerarlo como un falso positivo :).</i> <br><br>  <i>El art√≠culo se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>public√≥ por</i></a> primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>vez</i></a> en ingl√©s en stefansf.de.</i>  <i>Las traducciones se publican con permiso del autor.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418023/">https://habr.com/ru/post/es418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418009/index.html">Node.js y representaci√≥n del servidor en Airbnb</a></li>
<li><a href="../es418011/index.html">P√°ginas individuales y SEO. Secretos de optimizaci√≥n</a></li>
<li><a href="../es418013/index.html">El Intel Core i7-8086K (parte 3)</a></li>
<li><a href="../es418015/index.html">Nuevo Vasyuki. Desarrollo innovador de Mosc√∫ hasta 2100</a></li>
<li><a href="../es418017/index.html">An√°lisis del comportamiento del troyano Pegasus en la red.</a></li>
<li><a href="../es418025/index.html">El libro "Learning Java EE. Programaci√≥n moderna para grandes empresas ‚Äù</a></li>
<li><a href="../es418027/index.html">Microservice Blitz</a></li>
<li><a href="../es418029/index.html">ReactOS 0.4.9: los que odian tendr√°n que buscar nuevos argumentos</a></li>
<li><a href="../es418031/index.html">Apilamiento masivo de modelos ML en producci√≥n: ¬øreal o no?</a></li>
<li><a href="../es418035/index.html">Presentando Timeline en Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>