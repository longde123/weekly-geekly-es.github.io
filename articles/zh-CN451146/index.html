<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 🔔 🤙🏾 使用webpack加速Web应用程序构建 🚟 🐟 👩🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="随着应用程序的发展和增长，其构建时间也会增加-从开发模式的重新组装过程中的几分钟到“冷”生产组装过程中的几十分钟。 这是完全不能接受的。 我们的开发人员不喜欢在等待捆绑包准备就绪时想要切换上下文，并且希望尽早接收来自应用程序的反馈-理想情况下是从IDE切换到浏览器时。 


 如何实现呢？ 我们该怎...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用webpack加速Web应用程序构建</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451146/"><p> 随着应用程序的发展和增长，其构建时间也会增加-从开发模式的重新组装过程中的几分钟到“冷”生产组装过程中的几十分钟。 这是完全不能接受的。 我们的开发人员不喜欢在等待捆绑包准备就绪时想要切换上下文，并且希望尽早接收来自应用程序的反馈-理想情况下是从IDE切换到浏览器时。 </p><br><p> 如何实现呢？ 我们该怎么做才能优化构建时间？ </p><br><p> 本文概述了webpack生态系统中现有的可加快组装速度的工具，其经验和技巧。 </p><br><p> 本文中未考虑优化包大小和应用程序本身的性能。 </p><a name="habracut"></a><br><p> 文本中引用了该项目，并据此进行了组装速度的测量，该项目是一个相对较小的应用程序，使用webpack，Babel，PostCSS，Sass等在JS + Flow + React + Redux堆栈上编写，约有3万个代码行和1,500个模块。 依赖版本为2019年4月的最新版本。 </p><br><p> 研究是在装有Windows 10，Node.js 8、4核处理器，8 GB内存和SSD的计算机上进行的。 </p><br><h2 id="terminologiya"> 术语学 </h2><br><ul><li> 组装是将项目源文件转换为一起构成Web应用程序的一组相关资产的过程。 </li><li> dev-mode-带有选项<code>mode: 'development'</code>组装<code>mode: 'development'</code> ，通常使用webpack-dev-server和watch-mode。 </li><li>  prod-mode-具有以下选项<code>mode: 'production'</code>组装<code>mode: 'production'</code> ，通常具有全套捆绑优化。 </li><li> 增量构建-在开发模式下：仅重建有更改的文件。 </li><li>  “冷”构建-从头开始构建，没有任何缓存，但具有已安装的依赖项。 </li></ul><br><h2 id="keshirovanie"> 快取 </h2><br><p> 缓存使您可以保存计算结果，以备将来重用。 由于缓存的开销，第一个程序集可能会比平时慢一些，但由于重用了编译未修改模块的结果，因此后一个程序集会快得多。 </p><br><p> 默认情况下，监视模式下的webpack会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缓存内存中的内部生成</a>结果，以免每次更改都不会重新组装整个项目。 对于普通版本（不在监视模式下），此设置没有意义。 您也可以尝试打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缓存解析</a>以简化Webpack搜索模块的操作，并查看此设置是否对您的项目有明显的影响。 </p><br><p>  Webpack中没有持久性（保存到磁盘或其他存储）缓存，尽管他们<a href="">承诺</a>在版本5中<a href="">添加</a>它。 同时，我们可以使用以下工具： </p><br><p>  <strong>-在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TerserWebpackPlugin设置中</a>缓存</strong> </p><br><p> 默认禁用。 即使是单独使用，它也具有明显的积极作用：60.7 s→39 s（-36％），与其他缓存工具配合得很好。 </p><br><p> 开启和使用非常简单： </p><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">minimizer</span></span>: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TerserJsPlugin({ <span class="hljs-attr"><span class="hljs-attr">terserOptions</span></span>: { ... }, <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) ] }</code> </pre> <br><p>  <strong>- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缓存加载器</a></strong> </p><br><p> 缓存加载器可以放置在任何加载器链中，并缓存先前加载器的结果。 </p><br><p> 默认情况下，它将缓存保存到项目根目录下的.cache-loader文件夹中。 使用加载程序设置中的<code>cacheDirectory</code>选项，可以重新定义路径。 </p><br><p> 用法示例： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'cache-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cacheDirectory</span></span>: path.resolve( __dirname, <span class="hljs-string"><span class="hljs-string">'node_modules/.cache/cache-loader'</span></span> ), }, }, <span class="hljs-string"><span class="hljs-string">'babel-loader'</span></span> ] }</code> </pre> <br><p> 安全可靠的解决方案。 它几乎可以在任何加载程序上正常工作：脚本（babel-loader，ts-loader），样式（scss-，less-，postcss-，css-loader），图像和字体（image-webpack-loader，react-svg-加载器，文件加载器）等。 </p><br><p> 请注意： </p><br><ul><li> 当将cache-loader与style-loader或MiniCssExtractPlugin.loader结合使用时，应将其放在它们<em>之后</em> ： <br>  <code>['style-loader', 'cache-loader', 'css-loader', ...]</code> 。 </li><li> 与文档的建议相反，使用此加载器仅缓存费力的计算结果，对于“较轻”的加载器来说，它可能会带来很小但可测量的性能提升-您需要尝试并进行测量。 </li></ul><br><p> 结果： </p><br><ul><li>  dev：35.5 s→（启用缓存加载器）→36.2 s（+ 2％）→（重组）→7.9 s（-78％） </li><li> 产品：60.6 s→（启用缓存加载程序）→61.5 s（+ 1.5％）→（重新组装）→30.6 s（-49％）→（打开Terser的缓存）→15， 4秒（-75％） </li></ul><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-HardSourceWebpackPlugin</a></strong> </p><br><p> 一种更大规模，更“智能”的解决方案，用于在整个组装过程中进行缓存，而不是单个装载程序链。 在基本用例中，将插件添加到webpack配置中就足够了，标准设置对于正确的操作就足够了。 适合那些想要获得最佳性能而又不惧怕困难的人。 </p><br><pre> <code class="javascript hljs">plugins: [ ..., <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HardSourceWebpackPlugin() ]</code> </pre> <br><p> 该<a href="">文档</a>包含使用高级设置的示例以及解决可能出现的问题的提示。 在持续运行插件之前，值得在各种情况和组装模式下彻底测试其操作。 </p><br><p> 结果： </p><br><ul><li>  dev：35.5 s→（启用插件）→36.5 s（+ 3％）→（重新组装）→3.7 s（-90％） </li><li> 产品：60.6 s→（打开插件）→69.5 s（+ 15％）→（重组）→25 s（-59％）→（打开Terser的缓存）→10 s（-83％） </li></ul><br><p> 优点： </p><br><ul><li> 与缓存加载器相比，它可以更快地重新组装。 </li><li> 它不需要在配置的不同位置重复声明，就像在cache-loader中一样。 </li></ul><br><p> 缺点： </p><br><ul><li> 与cache-loader相比，它会减慢首次构建的速度（没有磁盘缓存时）； </li><li> 可能会稍微增加增量重建时间； </li><li> 在使用webpack-dev-server时可能会导致问题，并且需要对缓存分离和失效进行详细配置（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ）； </li><li>  GitHub上的许多错误。 </li></ul><br><p>  <strong>-在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel-loader设置中进行</a>缓存</strong> 。 默认禁用。 其效果比高速缓存加载器要差百分之几。 </p><br><p>  <strong>-在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint-loader设置中进行</a>缓存</strong> 。 默认禁用。 如果使用此加载程序，则缓存将帮助您避免在重新组装过程中浪费时间排列未更改的文件。 </p><br><hr><br><p> 使用cache-loader或HardSourceWebpackPlugin时，您需要禁用其他插件或加载器（TerserWebpackPlugin除外）中的内置缓存机制，因为它们在重复和增量构建中将不再有用，“冷”构建甚至会减慢速度。 如果HardSourceWebpackPlugin已经在使用，则同样适用于缓存加载器本身。 </p><br><hr><br><p> 设置缓存时，可能会出现以下问题： </p><br><p>  <em>缓存结果应存储在哪里？</em> </p><br><p>  <code>node_modules/.cache/&lt;_&gt;/</code>通常存储在<code>node_modules/.cache/&lt;_&gt;/</code>目录中。 默认情况下，大多数工具都使用此路径，如果要将缓存存储在其他位置，则可以覆盖它。 </p><br><p>  <em>什么时候以及如何使缓存无效？</em> </p><br><p> 对构建配置进行更改时刷新缓存非常重要，这会影响输出。 在这种情况下使用旧的缓存是有害的，并且可能导致未知性质的错误。 </p><br><p> 要考虑的因素： </p><br><ul><li> 依赖项及其版本列表：package.json，package-lock.json，yarn.lock，.yarn-integrity； </li><li> 加载程序和插件显式或隐式使用的webpack，Babel，PostCSS，浏览器列表和其他配置文件的内容。 </li></ul><br><p> 如果您不使用cache-loader或HardSourceWebpackPlugin（它们允许您重新定义源列表以形成程序集指纹），那么在添加，更新或删除依赖项时清除缓存的npm脚本将使您容易一些： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"prunecaches"</span></span>: <span class="hljs-string"><span class="hljs-string">"rimraf ./node_modules/.cache/"</span></span>, <span class="hljs-string"><span class="hljs-string">"postinstall"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prunecaches"</span></span>, <span class="hljs-string"><span class="hljs-string">"postuninstall"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prunecaches"</span></span></code> </pre> <br><p> 配置为在检测配置文件中的更改时清除缓存并重新启动webpack-dev-server的Nodemon也将有所帮助： </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"cross-env NODE_ENV=development nodemon --exec \"webpack-dev-server --config webpack.config.dev.js\""</span></span></code> </pre> <br><p>  nodemon.json </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"watch"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"webpack.config.dev.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"babel.config.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"more configs..."</span></span>, ], <span class="hljs-string"><span class="hljs-string">"events"</span></span>: { <span class="hljs-string"><span class="hljs-string">"restart"</span></span>: <span class="hljs-string"><span class="hljs-string">"yarn prunecaches"</span></span> } }</code> </pre> <br><p>  <em>我是否需要将缓存保存在项目存储库中？</em> </p><br><p> 实际上，由于缓存是程序集工件，因此不必将其提交到存储库。 缓存在node_modules文件夹中的位置（通常包含在.gitignore中）将对此有所帮助。 </p><br><p> 值得注意的是，如果有一个缓存系统可以在任何情况下（包括更改操作系统和Node.js版本）可靠地确定缓存的有效性，则缓存可以在开发机器之间或在CI中重用，这将极大地减少时间，即使在首次构建之后在分支之间切换。 </p><br><p>  <em>在哪种构建模式下值得使用缓存，在哪些构建模式下不值得使用缓存？</em> </p><br><p> 这里没有明确的答案：这取决于您在开发过程中使用dev-和prod模式以及在它们之间进行切换的强度。 通常，没有什么可以阻止在任何地方打开缓存，但是请记住，它通常会减慢第一次构建的速度。 在CI中，您可能始终需要“干净”的构建，在这种情况下，可以使用适当的环境变量来禁用缓存。 </p><br><hr><br><p> 有关在Webpack中缓存的有趣材料： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/webpack/webpack/issues/6527-HardSourcePlugin</a>向Webpack 5添加缓存系统的规范的草案和讨论 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://gist.github.com/mzgoddard/0b42ad50048f407c1f3ac434a874f8e1-HardSourcePlugin</a>的作者讨论了应如何在webpack中实现缓存系统 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/webpack-contrib/cache-loader/issues/11-</a>关于结合使用Hard-Loader和HardSourcePlugin的意见 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/webpack/webpack/issues/250-Webpack</a>缓存功能的讨论 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/mzgoddard/hard-source-webpack-plugin/issues/251-</a>关于结合使用HardSourcePlugin和AutoDllPlugin的意见 </li></ul><br><h2 id="parallelizaciya"> 并行化 </h2><br><p> 使用并行化，可以使用所有可用的处理器内核来提高性能。 每辆车的最终效果是不同的。 </p><br><p> 顺便说一下，这是一个简单的Node.js代码，用于获取可用的处理器内核数量（在设置下面列出的工具时可能会派上用场）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> os = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'os'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cores = os.cpus().length;</code> </pre> <br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-TerserWebpackPlugin设置中的</a>并行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">化</a></strong> </p><br><p> 默认禁用。 除了自身的缓存外，它还可以轻松打开并明显加快了装配速度。 </p><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">minimizer</span></span>: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TerserJsPlugin({ <span class="hljs-attr"><span class="hljs-attr">terserOptions</span></span>: { ... }, <span class="hljs-attr"><span class="hljs-attr">parallel</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) ] }</code> </pre> <br><p>  <strong>- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程加载器</a></strong> </p><br><p> 可以将线程加载器放置在执行大量计算的加载器链中，之后，之前的加载器将使用Node.js（处理器）子进程池。 </p><br><p> 它具有一组选项，可让您微调工作人员池的工作，尽管基本值看起来已经足够了。  <code>poolTimeout</code>和<code>workers</code>应特别注意-参见<a href="">示例</a> 。 </p><br><p> 它可以与cache-loader一起使用，如下所示（顺序很重要）： <code>['cache-loader', 'thread-loader', 'babel-loader']</code> 。 如果为线程加载器启用了“预热”，则应使用缓存仔细检查重复的程序集的稳定性-成功完成程序集后，webpack可能会挂起并且无法完成该过程。 在这种情况下，只需关闭预热。 </p><br><p> 如果在将线程加载器添加到Sass风格的编译链后遇到构建挂起的情况，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此技巧</a>可能会有所帮助。 </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-happypack</a></strong> </p><br><p> 一个插件，拦截加载程序的调用并将其工作分配到多个线程中。 目前，它处于支持模式（即未计划开发），其创建者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议使用</a>线程加载器作为替代。 因此，如果您的项目保持最新状态，最好不要使用HappyPack，尽管当然值得尝试并将结果与​​线程加载器进行比较。 </p><br><p>  HappyPack拥有易于理解的配置<a href="">文档</a> ，顺便说一句，它本身是很不寻常的：建议将加载程序配置移至插件构造函数调用，并用自己的happypack加载程序替换加载程序链本身。 在创建自定义Webpack“逐件”配置时，这种非标准方法可能会带来不便。 </p><br><p>  HappyPack支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有限数量的装载机</a> ; 列出了该列表中最主要和最广泛使用的内容，但由于API可能不兼容，因此无法保证其他内容的性能。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题中</a>可以找到更多信息。 </p><br><h2 id="otkaz-ot-vychisleniy"> 拒绝计算 </h2><br><p> 任何工作都需要时间。 为了减少时间，您需要避免工作量很少，可能被推迟到以后或在这种情况下根本不需要的工作。 </p><br><p>  <strong>-将装载程序应用于尽可能少的模块</strong> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试，排除和包含属性</a>指定加载程序在处理过程中包括模块的条件。 关键是要避免转换不需要此转换的模块。 </p><br><p> 一个流行的例子是通过Babel进行编译而产生的node_modules例外： </p><br><pre> <code class="javascript hljs">rules: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.jsx?$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">exclude</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/node_modules/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'babel-loader'</span></span> } ]</code> </pre> <br><p> 另一个例子是普通CSS文件不需要预处理器处理： </p><br><pre> <code class="javascript hljs">rules: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [<span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>, <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>, <span class="hljs-string"><span class="hljs-string">'sass-loader'</span></span>] }, { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [<span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>, <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>] } ]</code> </pre> <br><p>  <strong>-不要在开发人员模式下启用软件包大小优化</strong> </p><br><p> 在功能强大且具有稳定Internet的开发人员计算机上，即使本地部署的应用程序重达几兆字节，也通常会快速启动。 与节省负载相比，在组装过程中优化束可以占用更多的宝贵时间。 </p><br><p> 该建议涉及JS（Terser，Uglify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等</a> ），CSS（cssnano，optimize-css-assets-webpack-plugin），SVG和图像（SVGO，Imagemin，image-webpack-loader），HTML（html-minifier， html-webpack-plugin）等。 </p><br><p>  <strong>-不要在开发人员模式中包含polyfills和转换</strong> </p><br><p> 如果使用babel-preset-env，postcss-preset-env或Autoprefixer-为开发人员模式添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单独的Browserslist配置</a> ，仅包括在开发过程中使用的那些浏览器。 这些很有可能是最新版本的Chrome或Firefox，可以完美地支持现代标准，而无需进行polyfill和转换。 这样可以避免不必要的工作。 </p><br><p> 示例.browserslistrc： </p><br><pre> <code class="plaintext hljs">[production] your supported browsers go here... [development] last 2 Chrome versions last 2 Firefox versions last 1 Safari version</code> </pre> <br><p>  <strong>-审查源地图的使用</strong> </p><br><p> 生成最准确和完整的源地图需要花费大量时间（在我们的项目中-使用<code>devtool: 'source-map'</code>选项的产品构建时间约为30％）。 考虑是否需要在prod程序集中（本地和CI中）使用源映射。 仅在必要时才值得生成它们-例如，基于提交上的环境变量或标签。 </p><br><p> 在开发模式下，大多数情况下会有一个相当轻巧的选项<code>'cheap-eval-source-map'</code>或<code>'cheap-module-eval-source-map'</code> 。 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a>详细信息，请参见webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 </p><br><p>  <strong>-在Terser中设置压缩</strong> </p><br><p> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Terser文档</a> （适用于Uglify），在<code>compress</code>代码时， <code>mangle</code>和<code>compress</code>选项会消耗大部分时间。 通过对它们进行微调，您可以以略微增加捆束尺寸的代价实现装配加速。  vue-cli的来源中有<a href="">一个示例</a> ，Slack的工程师中有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个示例</a> 。 在我们的项目中，第一个实施例中的Terser调整将组装时间减少了约7％，而束尺寸增加了2.5％。 这场比赛是否值得，取决于您。 </p><br><p>  <strong>-从解析中排除外部依赖项</strong> </p><br><p> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>module.noParse</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>module.noParse</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>resolve.alias</code></a>您可以将库模块的导入重定向到已经编译的版本，然后将它们简单地插入捆绑中，而不会浪费时间解析。 在开发模式下，这将显着提高组装速度，包括增量速度。 </p><br><p> 该算法大致如下： </p><br><p>  （1）列出解析时需要跳过的模块。 </p><br><p> 理想情况下，这些都是捆绑包中的所有运行时依赖项（或至少是其中最大的运行时依赖项，例如react-dom或lodash），不仅是它们自己的（第一级），而且是可传递的（依赖项依赖）。 将来，您将必须自己维护此列表。 </p><br><p>  （2）对于选定的模块，写出其编译版本的路径。 </p><br><p> 您需要为收集器提供一个替代方案，而不是跳过依赖项，并且该替代方案不应依赖于环境-调用<code>module.exports</code> ， <code>require</code> ， <code>process</code> ， <code>import</code>等。 预编译（不一定是最小化）的单文件模块通常适合于此角色，这些模块通常位于依赖项源内的dist文件夹中。 要找到它们，您必须转到node_modules。 例如，对于axios，已编译模块的路径如下所示： <code>node_modules/axios/dist/axios.js</code> 。 </p><br><p>  （3）在webpack配置中，使用resolve.alias选项将依赖关系名称的导入替换为直接导入的文件，这些文件的路径是在上一步中编写的。 </p><br><p> 例如： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: { <span class="hljs-attr"><span class="hljs-attr">axios</span></span>: path.resolve( __dirname, <span class="hljs-string"><span class="hljs-string">'node_modules/dist/axios.min.js'</span></span> ), ... } } }</code> </pre> <br><p> 这里有一个很大的缺陷：如果您的代码或依赖项的代码未访问标准入口点（索引文件， <code>package.json</code> <code>main</code>字段），而是访问了依赖项源中的特定文件，或者是否将依赖项导出为ES模块，或者解决过程会干扰某些内容（例如babel-plugin-transform-imports），整个想法可能会失败。 捆绑包将组装，但应用程序将被破坏。 </p><br><p>  （4）在webpack配置中，使用module.noParse选项跳过使用正则表达式来解析步骤2的路径所请求的预编译模块。 </p><br><p> 例如： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">noParse</span></span>: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'node_modules/dist/axios.min.js'</span></span>), ... ] } }</code> </pre> <br><p> 底线：从表面上看，该方法看起来很有希望，但存在陷阱的非平凡设置至少会增加实施成本，至少会降低收益。 </p><br><p> 具有类似操作原理的替代方法是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>externals</code></a>选项。 在这种情况下，您将必须在HTML文件中独立插入指向外部脚本的链接，甚至具有与package.json对应的必需依赖项版本。 </p><br><p>  <strong>-将很少更改的代码分离到单独的包中，并且仅编译一次</strong> </p><br><p> 当然，您听说过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DllPlugin</a> 。 使用它，您可以将活动更改的代码（您的应用程序）分发到很少的代码（例如，依赖项）到不同的程序集中。 一旦将组装的依赖项捆绑包（相同的DLL）简单地连接到应用程序组装，就可以节省时间。 </p><br><p> 大致来说是这样的： </p><br><ol><li> 要构建DLL，将创建一个单独的Webpack配置，并将必要的模块作为入口点进行连接。 </li><li> 构建从此配置开始。  DllPlugin生成DLL捆绑包和带有映射名称和模块路径的清单文件。 </li><li> 将DllReferencePlugin添加到将清单传递到的主程序集的配置中。 </li><li> 使用清单将在组装过程中DLL中呈现的依赖项的导入映射到已编译的模块上。 </li></ol><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的文章中阅读更多内容。 </p><br><p> 开始使用这种方法，您将很快发现许多缺点： </p><br><ul><li>  DLL程序集与主程序集是隔离的，并且需要单独进行管理：准备特殊的配置，每次在分支切换或依赖关系更改时重新启动它。 </li><li> 由于DLL与主装配体的工件无关，因此需要使用其他插件之一将其与其他资产一起手动复制到文件夹中，并包含在HTML文件中： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1，2</a> 。 </li><li> 必须手动更新旨在包含在DLL捆绑包中的依赖项列表。 </li><li> 最可悲的是：摇树不适用于DLL捆绑包。 从理论上讲， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>entryOnly</code></a>选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>entryOnly</code></a>目的，但他们忘记了对其进行记录。 </li></ul><br><p> 您可以摆脱样板并使用AutoDllPlugin解决第一个问题（以及第二个问题，如果您使用html-webpack-plugin v3-不适用于版本4）。 但是，它仍然不支持“在<code>entryOnly</code>使用的<code>entryOnly</code>的<code>entryOnly</code>选项，并且该插件的作者对即将面世的webpack 5提出的使用其创造性思维的可行性表示怀疑。 </p><br><h2 id="raznoe"> 杂项 </h2><br><p> 定期更新您的软件和依赖项。    Node.js, npm / yarn     (webpack, Babel  .)    . ,          changelog, issues,   ,      . </p><br><p>   PostCSS  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">postcss-preset-env</a>     stage,      . ,      stage-3,     Custom Properties,    stage-4     13%. </p><br><p>    Sass (node-sass, sass-loader),  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dart Sass</a> ( Sass  Dart,   JS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fast-sass-loader</a> . ,        .      — dart-sass    ,  node-sass,     JS,     libsass. </p><br><p>   Dart Sass    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> sass-loader</a> .         Sass    fibers. </p><br><p>    CSS-,          dev-.     - ,   ,         ,   . </p><br><p> 一个例子： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">modules</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">localIdentName</span></span>: isDev ? <span class="hljs-string"><span class="hljs-string">'[path][name][local]'</span></span> : <span class="hljs-string"><span class="hljs-string">'[hash:base64:5]'</span></span> } }</code> </pre> <br><p> ,   , :      . </p><br><p> ,  -    webpack  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PrefetchPlugin</a> ,      ,    — .  webpack  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  issues</a>    ,     .     ? </p><br><ol><li>     .     CLI- <code>--json</code> ,  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . ,  ,   dev- . </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-</a>     Hints. </li><li>  ,  “Long module build chains”.   ,     — PrefetchPlugin  . </li><li>      PrefetchPlugin.     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  StackOverflow</a> . </li></ol><br><p> :         . </p><br><h2 id="v-kachestve-zaklyucheniya">    </h2><br><p>     ,       (TypeScript, Angular  .) —   ! </p><br><h2 id="istochniki"> 资料来源 </h2><br><p>     , ,   ,      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://webpack.js.org/guides/build-performance/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://survivejs.com/webpack/optimizing/performance/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/webpack/docs/wiki/build-performance</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://slack.engineering/keep-webpack-fast-a-field-guide-for-better-build-performance-f56a5995e8f1</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://medium.com/webpack/typescript-webpack-super-pursuit-mode-83cc568dea79</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://medium.com/ottofellercom/0-100-in-two-seconds-speed-up-webpack-465de691ed4a</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://medium.com/onfido-tech/speed-up-webpack-ff53c494b89c</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://blog.box.com/blog/how-we-improved-webpack-build-performance-95</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://engineering.bitnami.com/articles/optimizing-your-webpack-builds.html</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/skbkontur/blog/351080/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/ru/company/oleg-bunin/blog/433324/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/lcxfs1991/blog/issues/15</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/FrendEr/webpack-optimize-example</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451146/">https://habr.com/ru/post/zh-CN451146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451130/index.html">Swift：ARC和内存管理</a></li>
<li><a href="../zh-CN451132/index.html">消费者驱动合同或Gitlab CI眼质量检查测试自动化</a></li>
<li><a href="../zh-CN451138/index.html">Symfony CLI-新的本地开发工具</a></li>
<li><a href="../zh-CN451140/index.html">创建物联网解决方案需要多少费用？</a></li>
<li><a href="../zh-CN451144/index.html">上古：电视广告技术</a></li>
<li><a href="../zh-CN451148/index.html">图形语言中的面向对象编程</a></li>
<li><a href="../zh-CN451150/index.html">如果可以的话，赶上我。 管理员版本</a></li>
<li><a href="../zh-CN451152/index.html">门电路中的电阻或正确的方法</a></li>
<li><a href="../zh-CN451154/index.html">本地自治数据采集系统（续）</a></li>
<li><a href="../zh-CN451158/index.html">电路。 电路类型</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>