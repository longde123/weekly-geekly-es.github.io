<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòò üòå üßóüèø Asegurar protocolos inal√°mbricos utilizando LoRaWAN como ejemplo üöï üèØ üõ†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr 

 Una vez m√°s, me gustar√≠a hablar sobre c√≥mo se proporciona el nivel b√°sico (l√©ase: m√≠nimo necesario) de seguridad de datos en redes inal√°m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asegurar protocolos inal√°mbricos utilizando LoRaWAN como ejemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458394/"> Hola Habr <br><br>  Una vez m√°s, me gustar√≠a hablar sobre c√≥mo se proporciona el nivel b√°sico (l√©ase: m√≠nimo necesario) de seguridad de datos en redes inal√°mbricas utilizadas en dispositivos IoT, utilizando LoRaWAN como ejemplo. <br><br>  ¬øPor qu√© LoRaWAN?  En primer lugar, porque es un est√°ndar bien descrito y bien desarrollado que debe guiarse como referencia si est√° desarrollando alg√∫n tipo de protocolo inal√°mbrico.  En segundo lugar, porque es una soluci√≥n de IoT muy nativa y t√≠pica;  Por supuesto, puede desmontar la seguridad en Wi-Fi o LTE, pero para la mayor√≠a de los desarrolladores esto ser√° un an√°lisis in√∫til: es poco probable que necesite escribir su propia implementaci√≥n de Wi-Fi.  En tercer lugar, son los dispositivos IoT de baja potencia en los que los desarrolladores guardan cada byte que a menudo resultan ser los que tienen m√°s fugas: aqu√≠ LoRaWAN da una buena idea de c√≥mo guardar bytes y no ser atacado.  Cuarto, finalmente, porque literalmente en los √∫ltimos d√≠as, varios de nuestros clientes pidieron que les contaran m√°s sobre la protecci√≥n de datos en LoRaWAN, y con este art√≠culo mato dos p√°jaros de un tiro. <br><br><img src="https://habrastorage.org/webt/rt/-k/bb/rt-kbbrmazihfcgicxk0spcnexs.png"><br>  <i>Mensajer√≠a LoRaWAN entre servidor y dispositivo</i> <br><br>  Aunque el esquema de mensajes en LoRaWAN en la imagen parece bastante simple, esta simplicidad es enga√±osa: tiene mucho trabajo por hacer, y ni un solo p√≠xel es superfluo.  Ahora entender√°s por qu√©. <br><br>  Analizaremos el uso de LoRaWAN 1.0.2 como ejemplo y nos enfrentaremos a posibles amenazas, ya que un buen desarrollador siempre debe pensar no en c√≥mo se protege su sistema, sino en c√≥mo se puede romper.  De lo contrario, alguien m√°s lo pensar√° por √©l. <br><br>  Entonces, ¬øcu√°les son las principales amenazas en la red inal√°mbrica y c√≥mo protegerse de ellas? <br><a name="habracut"></a><br><h3>  Intercepci√≥n de datos del usuario. </h3><br>  La amenaza m√°s simple es una intercepci√≥n de datos regular:  Dado que las ondas de radio se propagan sin control, absolutamente cualquier persona puede tomar un receptor sintonizado al rango y tipo de modulaci√≥n deseado, y escuchar todo lo que transmite. <br><br>  La forma m√°s f√°cil de protegerse contra esto es el cifrado de datos. <br><br>  <b>En LoRaWAN, los datos del usuario se cifran utilizando el algoritmo AES-128</b> con una longitud de clave de 128 bits (16 bytes), respectivamente.  AES es un algoritmo confiable, sin embargo, en microcontroladores m√≠nimamente modernos que ni siquiera tienen un bloque de cifrado de hardware, su uso no implica una sobrecarga significativa: en un Cortex-M3 con una frecuencia de 48 MHz, un bloque de 16 bytes se cifra en aproximadamente 100 Œºs desde cero. <br><br><h3>  Repetici√≥n de datos </h3><br>  En algunos casos, un atacante no necesita saber exactamente qu√© est√° transmitiendo all√≠.  Por ejemplo, si su sensor tiene una ventana cerrada que transmite una cosa, y una abierta transmite otra cosa, entonces puede grabar una sin entrar en los detalles de su contenido, silenciar el sensor y para que el sistema no sospeche que algo est√° mal debido a la falta de paquetes desde el sensor: difunde el mensaje previamente grabado. <br><br>  <b>En LoRaWAN, se agrega un contador a cada paquete</b> .  Si un paquete llega al servidor de red con un contador igual o menor que el anterior, entonces este paquete simplemente se descarta.  Con dos bytes por metro y una velocidad t√≠pica de transmisi√≥n de mensajes en el sistema IoT, durar√° mucho tiempo; por ejemplo, incluso una estaci√≥n meteorol√≥gica dom√©stica que transmite la temperatura cada minuto la desbordar√° solo despu√©s de un mes y medio (LoRaWAN permite un contador de 4 bytes). <br><br>  Sin embargo, existe un problema obvio: despu√©s de un desbordamiento, un paquete con el n√∫mero 0 vendr√° del dispositivo, que, obviamente, ser√° menor que cualquier otro n√∫mero, pero el servidor de red deber√≠a percibirlo correctamente y comenzar el conteo de paquetes nuevamente.  Adem√°s, el dispositivo puede reiniciar el contador simplemente reiniciando. <br><br>  Esto se logra de dos maneras: <br><br><ul><li>  Antes de enviar dicho paquete, el dispositivo debe someterse al procedimiento de registro en la red (en la red LoRaWAN, este procedimiento se llama Join) </li><li>  el servidor permite la llegada del siguiente paquete con el n√∫mero 0, mientras que la cuenta regresiva comienza de nuevo </li></ul><br>  Ambos esquemas se usan en LoRaWAN dependiendo de c√≥mo se active el dispositivo: OTAA o ABP (hablaremos de ellos a continuaci√≥n).  La primera opci√≥n se usa para OTAA, mientras que el dispositivo tambi√©n recibe nuevas claves de cifrado, por lo que incluso un atacante que haya pasado un mes y medio debajo de su estaci√≥n meteorol√≥gica no podr√° transmitir ning√∫n paquete grabado previamente para que el sistema lo acepte. <br><br>  Para ABP, en el que no hay un procedimiento de registro en la red, se utiliza la segunda opci√≥n; sin embargo, si el per√≠odo de desbordamiento del contador excede significativamente la vida √∫til estimada del dispositivo y se puede desactivar.  En el caso de un reinicio accidental despu√©s de enviar cada paquete, dicho dispositivo final almacena el valor del contador en la memoria no vol√°til. <br><br>  El segundo esquema, por supuesto, es menos seguro, pero en la pr√°ctica es permisible: un atacante no debe registrar ning√∫n paquete, sino espec√≠ficamente cero.  Si lo desea, puede hacer que su contenido sea diferente de todos los dem√°s paquetes; por ejemplo, no transmita datos, sino informaci√≥n sobre el tipo y la configuraci√≥n del dispositivo;  entonces su intercepci√≥n y repetici√≥n no dar√° nada razonable. <br><br>  <b>Contador falsificado</b> <br><br>  Sin embargo, la pregunta surge de inmediato: ¬øqu√© pasa si el contador es falso?  Puede ponerlo en la parte encriptada del paquete, pero luego la cantidad real de datos del usuario disminuir√° en dos bytes.  No solo puede cifrar los datos del usuario, sino que, en primer lugar, debe adaptarse al tama√±o de bloque de 16 bytes y, en segundo lugar, la carga en el servidor de red aumentar√°, lo que tendr√° que descifrarlo primero para cualquier acci√≥n en el paquete (en el esquema, cuando solo se cifran los datos del usuario, si el paquete se ignora formalmente, entonces no es necesario descifrar nada). <br><br>  Es obvio que no nos importa si el atacante conoce o no el n√∫mero de paquete; en el esquema con el re-registro de la red (OTAA) este conocimiento no lo ayudar√° en absoluto, y en ABP esperar√° mucho tiempo junto al mar para conocer el clima, es decir.  La pr√≥xima llegada del paquete con el n√∫mero N-1. <br><br>  Por lo tanto, es suficiente no permitirle cambiar este n√∫mero. <br><br>  Para hacer esto, todo el paquete en LoRaWAN est√° firmado con una firma criptogr√°fica: AES-CMAC, esta firma en el est√°ndar se llama MIC, C√≥digo de integridad de mensajes.  Comprueba que el <i>paquete completo</i> , incluidos todos los encabezados y datos, ha llegado al servidor sin cambios. <br><br>  Es decir, despu√©s de haber aceptado el siguiente paquete, podemos examinar r√°pidamente su contador (direcci√≥n del remitente, etc.), y si es nuestro y correcto, entonces ya verificamos la firma (gastando recursos adicionales), y si la firma tambi√©n es correcta, descifre los datos y transmita ellos m√°s lejos. <br><br>  <b>Seguimiento de datos que no cambian</b> <br><br>  Desafortunadamente para nosotros, no es suficiente para evitar que un atacante entienda los datos o al menos los repita; en algunos casos ser√° suficiente para que entienda que no est√°n cambiando.  Un ejemplo de libro de texto son los medidores de agua en el hogar: si solo quiere saber si los propietarios est√°n en casa, no le importa exactamente cu√°ntos litros hay, es importante que sepa <i>si este valor est√° aumentando</i> . <br><br>  Obviamente, el cifrado de datos es un procedimiento reversible (se pueden descifrar), lo que significa que los mismos datos cifrados con la misma clave siempre se ven iguales.  Al recibir paquetes de un medidor de agua que no cambia las lecturas, puede, <i>sin descifrar el paquete</i> , comprender que no cambian. <br><br>  Hacer frente a esto es bastante simple: los datos o la clave deben cambiar.  Para cambiar los datos, puede agregarles sal, unos pocos bytes aleatorios que simplemente se descartan despu√©s del descifrado.  Lamentablemente, 16 bytes de un paquete ya son escasos, por lo que, en el caso general, no queremos gastar de 2 a 4 bytes en basura real. <br><br>  <b>LoRaWAN usa un esquema m√°s complicado</b> .  ¬øRecuerdas que tenemos un contador de paquetes?  Por lo tanto, este contador en particular m√°s informaci√≥n sobre el dispositivo y el paquete (direcci√≥n corta del dispositivo en la red LoRaWAN, direcci√≥n de transferencia de datos, contador de 16 bytes) se encriptan usando el algoritmo AES, y el resultado XOR est√° con el paquete de datos del usuario. <br><br>  Como resultado, los bytes de carga √∫til no se desperdician, y cada mensaje se ve diferente independientemente de si la carga ha cambiado o no. <br><br>  PD Hay otra opci√≥n, un poco m√°s simple: usar el contador de mensajes como los √∫ltimos N bytes de la clave.  En este caso, la clave ser√° nueva cada vez, pero porque  Dado que el servidor conoce el valor del contador de mensajes (est√° en la parte no cifrada del mensaje), podr√° restaurarlo.  Menos: si su paquete consta de varios bloques de 16 bytes y tienen los mismos datos, despu√©s del cifrado seguir√°n siendo los mismos. <br><br>  <b>El atacante ha aprendido la clave de cifrado.</b> <br><br>  Es una situaci√≥n muy real: IoT se caracteriza por el uso de una gran cantidad de dispositivos, sobre los cuales es posible que no tenga suficiente control confiable sobre el acceso a personas externas (y si tambi√©n es un operador de red, entonces sus clientes son, por definici√≥n, externos). <br><br>  Por lo tanto, si todos sus dispositivos tienen la misma clave de cifrado, el propietario de cualquiera de ellos puede escuchar el tr√°fico de cualquier otro dispositivo (en t√©rminos generales, si tiene la capacidad de modificar el firmware, entonces para tal operaci√≥n puede que ni siquiera conozca la clave expl√≠citamente). el nuevo firmware lo toma del mismo lugar que el anterior y solo nos da los datos de otras personas). <br><br>  LoRaWAN implementa dos esquemas para usar claves, individuales para cada dispositivo: <br><br><ul><li>  Activaci√≥n por aire, OTAA: el servidor de red genera claves cada vez que se registra un dispositivo en √©l </li><li>  Activaci√≥n por personalizaci√≥n: las claves las establece el fabricante y se almacenan en el dispositivo, sin cambiar nunca </li></ul><br>  Hay al menos dos claves en total: AppSKey, que cifra los datos del usuario, y NwkSKey, que firma el mensaje. <br><br>  Obviamente, el esquema OTAA es m√°s conveniente y confiable: las claves pueden cambiar con la frecuencia que desee, se garantiza que son √∫nicas y que nadie las conoce, excepto el servidor de red.  En ABP, las claves nunca cambian, la unicidad depende de la conciencia del fabricante del dispositivo (por ejemplo, generamos estas claves a partir de la ID √∫nica del microcontrolador, por lo que la probabilidad de su coincidencia en los dos dispositivos es insignificante), y deben almacenarse expl√≠citamente en alg√∫n lugar, por lo que al conectar el dispositivo a la red registrarlos en el servidor. <br><br>  Sin embargo, el procedimiento para obtener claves en OTAA es una historia separada que, si se implementa de manera incorrecta, puede dar lugar a varios tipos m√°s de ataques. <br><br><h3>  Intercepci√≥n de claves generadas. </h3><br>  Obviamente, si se generan nuevas claves cada vez durante el registro en la red, entonces deben sincronizarse entre el dispositivo y el servidor, lo que significa que un atacante puede interceptarlas, rompiendo as√≠ toda la protecci√≥n. <br><br>  Por lo tanto <b>, los dispositivos LoRaWAN tienen una tercera clave</b> : AppKey, bien conectada al dispositivo y utilizada en un solo momento: al registrarse en la red.  Con √©l, se firma un intercambio de claves de sesi√≥n entre el dispositivo y el servidor. <br><br>  Idealmente, la AppKey deber√≠a ser √∫nica para cada dispositivo, pero en muchos casos se permite el uso de la misma AppKey, ya que se necesita solo una vez, esto puede reconocerse como v√°lido. <br><br>  AppKey antes de conectar el dispositivo se ingresa en su configuraci√≥n en el servidor de red. <br><br>  Entonces, el dispositivo genera una solicitud de registro (JoinRequest), no la encripta (no tiene informaci√≥n confidencial), sino que la firma con la clave AppKey.  El servidor de red, despu√©s de recibir este paquete y verificar la direcci√≥n del remitente (si este es nuestro dispositivo) y luego la firma, responde con el paquete JoinAccept, en el que transfiere la configuraci√≥n de red, bueno, en realidad confirma el registro. <br><br>  ¬øDe d√≥nde vienen las teclas AppSKey y NwkSKey? <br><br>  Este es el resultado del cifrado AES-128 con la clave AppKey de una combinaci√≥n del n√∫mero aleatorio AppNonce, n√∫mero de clave (1 o 2), ID de red y otro n√∫mero aleatorio DevNonce enviado por el servidor en la respuesta: <br><br><pre><code class="plaintext hljs">NwkSKey = aes128_encrypt(AppKey, 0x01 | AppNonce | NetID | DevNonce) AppSKey = aes128_encrypt(AppKey, 0x02 | AppNonce | NetID | DevNonce)</code> </pre> <br>  Dado que tanto el dispositivo como el servidor despu√©s de intercambiar paquetes de registro conocen todos estos par√°metros, generar√°n las mismas claves.  Por lo tanto, en ning√∫n momento las claves se transmitir√°n por radio por s√≠ mismas, pero al mismo tiempo, el dispositivo y el servidor recibir√°n claves √∫nicas de cifrado y firma de paquetes. <br><br><h3>  Intercepci√≥n de un flujo de datos en s√≠ mismo </h3><br>  ¬°Pero eso no es todo! <br><br>  S√≠, el evento de registro en la red suele ser algo poco frecuente, pero imagine que un atacante pudo iniciarlo e interceptarlo. <br><br>  Luego, si simplemente env√≠a el paquete JoinRequest que grab√≥, sin cambiar nada en √©l, el servidor responder√° con el paquete JoinAccept, generando nuevas claves.  Despu√©s de esto, el dispositivo atacado simplemente deja de comunicarse con el servidor, porque no inici√≥ JoinRequest y no ve ninguna raz√≥n para actualizar las claves.  Es decir, se repite el mismo ataque, pero ya en el procedimiento de registro en la red. <br><br>  Un atacante no podr√° falsificar los datos, porque para esto necesita conocer las claves, y para obtenerlas necesita conocer la AppKey, que √©l no conoce.  Pero para sacar el dispositivo de la red, puede hacerlo. <br><br>  Para evitar esto, durante el registro, el dispositivo env√≠a un n√∫mero aleatorio de DevNonce al servidor (mira, est√° en los paquetes anteriores).  Adem√°s del hecho de que las claves se generan sobre la base, tiene otro prop√≥sito: el <b>servidor LoRaWAN almacena el archivo DevNonce</b> .  Si el dispositivo recibe una solicitud de registro repetida con el DevNonce ya utilizado, el servidor simplemente lo ignorar√°. <br><br>  A su vez, el dispositivo est√° obligado a generar un nuevo DevNonce en cada registro (es decir, el circuito con la retransmisi√≥n de paquetes convencionales - "no recibi√≥ una respuesta, escupi√≥ el mismo paquete en la radio por segunda vez" - no funciona aqu√≠, JoinRequest se vuelve a crear cada vez). <br><br><h3>  Conclusi√≥n </h3><br>  Aunque result√≥ que hab√≠a mucho texto y pocas im√°genes, incluso este no es un esquema completo de posibles ataques solo en la radio (las preguntas sobre por qu√©, por ejemplo, la configuraci√≥n debe estar encriptada en el dispositivo, y dejamos la clave con una clave individual para cada dispositivo fuera de los corchetes, esto ya no se trata de la radio).  Por ejemplo, en LoRaWAN 1.1, los esquemas de protecci√≥n se han vuelto a√∫n m√°s complicados. <br><br>  Sin embargo, este es un conjunto de caballeros de cualquier protocolo de radio que afirma tener una protecci√≥n m√≠nima de informaci√≥n digna y al mismo tiempo est√° dise√±ado para funcionar en dispositivos de baja potencia en redes de baja velocidad.  Adem√°s, este es un muy buen ejemplo de implementaci√≥n no solo de un protocolo seguro, sino de un protocolo escrito para dispositivos de baja potencia y minimizando el consumo de tiempo de uso y potencia de computaci√≥n siempre que sea posible sin da√±os significativos a la seguridad. <br><br>  Y si est√° dise√±ando su propio protocolo para IoT, entonces el bien especificado LoRaWAN, combinado con una comprensi√≥n de los m√©todos b√°sicos para realizar ataques, brinda una excelente oportunidad para aprender c√≥mo organizar adecuadamente esta protecci√≥n. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458394/">https://habr.com/ru/post/458394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458378/index.html">Usando Avocode para el dise√±o del sitio. Revisi√≥n para principiantes. Bonificaci√≥n: registre un per√≠odo de prueba de 30 d√≠as</a></li>
<li><a href="../458382/index.html">¬øPor qu√© estamos ense√±ando esto?</a></li>
<li><a href="../458384/index.html">HP 3D Structured Light Scanner Pro S3 Revisi√≥n y prueba</a></li>
<li><a href="../458388/index.html">Deep (Learning + Random) Forest y an√°lisis de art√≠culos</a></li>
<li><a href="../458390/index.html">Ceph - de "en la rodilla" a "producci√≥n" parte 2</a></li>
<li><a href="../458396/index.html">C√≥mo hice que el desarrollo en Vue.js sea conveniente con la representaci√≥n del lado del servidor</a></li>
<li><a href="../458398/index.html">Higiene del trabajo a distancia o los beneficios de la telepat√≠a.</a></li>
<li><a href="../458400/index.html">Arquitectura e implementaci√≥n de microservicios, paso a paso, parte 1</a></li>
<li><a href="../458404/index.html">Transici√≥n del monolito a los microservicios: historia y pr√°ctica.</a></li>
<li><a href="../458406/index.html">M√°s de 30 preguntas sobre programas de utilidad y no de utilidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>