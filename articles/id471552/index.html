<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ù ü§ôüèæ üë®üèº‚ÄçüöÄ Menulis klon mesin Doom: membaca informasi peta üç¥ üë©üèø‚Äçü§ù‚Äçüë©üèº ü§∑üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Tujuan dari proyek ini adalah untuk membuat tiruan dari mesin DOOM menggunakan sumber daya yang dirilis dengan Ultimate DOOM ( versi dar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis klon mesin Doom: membaca informasi peta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="gambar"></div><br><h2>  Pendahuluan </h2><br>  Tujuan dari proyek ini adalah untuk membuat tiruan dari mesin DOOM menggunakan sumber daya yang dirilis dengan Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">versi dari Steam</a> ). <br><br>  Ini akan disajikan dalam bentuk tutorial - Saya tidak ingin mencapai kinerja maksimum dalam kode, tetapi hanya membuat versi yang berfungsi, dan kemudian saya akan mulai meningkatkan dan mengoptimalkannya. <br><br>  Saya tidak memiliki pengalaman dalam membuat game atau mesin game, dan sedikit pengalaman dalam menulis artikel, sehingga Anda dapat menyarankan perubahan Anda sendiri atau bahkan sepenuhnya menulis ulang kode. <br><br>  Berikut adalah daftar sumber daya dan tautan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Buku Mesin Game Buku Hitam: DOOM Fabien Sanglar</a> .  Salah satu buku terbaik tentang internal DOOM. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Doom wiki</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber DOOM</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Sumber Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Persyaratan </h3><br><ul><li>  Visual Studio: setiap IDE akan melakukan;  Saya akan bekerja di Visual Studio 2017. </li><li>  SDL2: perpustakaan. </li><li>  DOOM: Salinan versi Steam dari Ultimate DOOM, kita hanya perlu file WAD darinya. </li></ul><br><h3>  Opsional </h3><br><ul><li>  Slade3: alat yang bagus untuk menguji pekerjaan kami. </li></ul><br><h3>  Pikiran </h3><br>  Saya tidak tahu, saya bisa menyelesaikan proyek ini, tetapi saya akan melakukan yang terbaik untuk ini. <br><br>  Windows akan menjadi platform target saya, tetapi karena saya menggunakan SDL, itu hanya akan membuat mesin bekerja di bawah platform lain. <br><br>  Sementara itu, instal Visual Studio! <br><br>  Proyek ini berganti nama dari Handmade DOOM menjadi Do It Yourself Doom dengan SLD (DIY Doom) sehingga tidak akan bingung dengan proyek lain yang disebut "Handmade".  Ada beberapa tangkapan layar dalam tutorial yang masih disebut Handmade DOOM. <br><br><h2>  File WAD </h2><br>  Sebelum memulai pengkodean, mari tetapkan tujuan dan pikirkan apa yang ingin kita capai. <br><br>  Pertama, mari kita periksa apakah kita dapat membaca file sumber daya DOOM.  Semua sumber daya DOOM ada di file WAD. <br><br><h2>  Apa itu file WAD? </h2><br>  "Di mana semua data saya"?  ("Di mana semua data saya?") Mereka ada di WAD!  WAD adalah arsip semua sumber daya DOOM (dan game berbasis DOOM) yang terletak di satu file. <br><br>  Pengembang malapetaka datang dengan format ini untuk menyederhanakan pembuatan modifikasi game. <br><br><h2>  WAD File Anatomy </h2><br>  File WAD terdiri dari tiga bagian utama: header (header), "pieces" (benjolan), dan direktori (direktori). <br><br><ol><li>  Header - berisi informasi dasar tentang file WAD dan direktori offset. </li><li>  Benjolan - di sini adalah sumber daya permainan yang tersimpan, data peta, sprite, musik, dll. </li><li>  Direktori - Struktur organisasi untuk menemukan data di bagian lump. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Format tajuk </h3><br><div class="scrollable-table"><table><thead><tr><th>  Ukuran bidang </th><th>  Tipe data </th><th>  Konten </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 karakter ASCII </td><td>  String ASCII (dengan nilai "IWAD" atau "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  Nomor item direktori. </td></tr><tr><td>  0x08-0x0b </td><td>  unsigned int </td><td>  Nilai offset direktori dalam file WAD. </td></tr></tbody></table></div><br><h3>  Format Direktori </h3><br><div class="scrollable-table"><table><thead><tr><th>  Ukuran bidang </th><th>  Tipe data </th><th>  Konten </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  unsigned int </td><td>  Nilai offset di awal data lump di file WAD. </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  Ukuran "benjolan" dalam byte. </td></tr><tr><td>  0x08-0x0f </td><td>  8 karakter ASCII </td><td>  ASCII berisi nama "bagian." </td></tr></tbody></table></div><br><h2>  Tujuan </h2><br><ol><li>  Buat proyek. </li><li>  Buka file WAD. </li><li>  Baca tajuk utama. </li><li>  Baca semua direktori dan tampilkan. </li></ol><br><h2>  Arsitektur </h2><br>  Jangan menyulitkan apa pun.  Buat kelas yang baru saja membuka dan memuat WAD, dan menyebutnya WADLoader.  Kemudian kami menulis kelas yang bertanggung jawab untuk membaca data tergantung pada format mereka, dan menyebutnya WADReader.  Kita juga membutuhkan fungsi <code>main</code> sederhana yang memanggil kelas-kelas ini. <br><br>  Catatan: arsitektur ini mungkin tidak optimal, dan jika perlu kami akan mengubahnya. <br><br><h2>  Mendapatkan kode </h2><br>  Mari kita mulai dengan membuat proyek C ++ kosong.  Di Visual Studio, klik File-&gt; New -&gt; Project.  Sebut saja DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  Mari kita tambahkan dua kelas baru: WADLoader dan WADReader.  Mari kita mulai dengan implementasi WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  Menerapkan konstruktor akan sederhana: menginisialisasi penunjuk data dan menyimpan salinan jalur yang ditransfer ke file WAD. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  Sekarang mari kita turun ke implementasi fungsi bantu memuat <code>OpenAndLoad</code> : coba saja buka file sebagai biner dan jika terjadi kegagalan kita akan menampilkan kesalahan. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Jika semuanya berjalan dengan baik, dan kita dapat menemukan dan membuka file, maka kita perlu mengetahui ukuran file untuk mengalokasikan memori untuk menyalin file ke dalamnya. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Sekarang kita tahu berapa banyak ruang yang dibutuhkan WAD penuh, dan kami akan mengalokasikan jumlah memori yang diperlukan. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Salin konten file ke memori ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  Anda mungkin memperhatikan bahwa saya menggunakan tipe <code>m_WADData</code> sebagai tipe data untuk <code>unint8_t</code> .  Ini berarti bahwa saya memerlukan array tepat 1 byte (panjang 1 byte *).  Menggunakan unint8_t memastikan bahwa ukurannya sama dengan byte (8 bit, yang dapat dipahami dari nama tipe).  Jika kita ingin mengalokasikan 2 byte (16 bit), kita akan menggunakan unint16_t, yang akan kita bicarakan nanti.  Dengan menggunakan jenis kode ini, kode tersebut menjadi platform independen.  Saya akan menjelaskan: jika kita menggunakan "int", maka ukuran yang tepat dari int dalam memori akan tergantung pada sistem.  Jika kita mengompilasi "int" dalam konfigurasi 32-bit, kita mendapatkan ukuran memori 4 byte (32 bit), dan ketika mengkompilasi kode yang sama dalam konfigurasi 64-bit, kita mendapatkan ukuran memori 8 byte (64 bit)!  Lebih buruk lagi, mengkompilasi kode pada platform 16-bit (Anda mungkin penggemar DOS) akan memberi kita 2 byte (16 bit)! <br><br>  Mari kita periksa kodenya secara singkat dan memastikan semuanya berfungsi.  Tetapi pertama-tama kita perlu mengimplementasikan LoadWAD.  Sementara LoadWAD akan memanggil "OpenAndLoad" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dan mari kita tambahkan ke kode fungsi utama yang membuat instance kelas dan mencoba memuat WAD <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Anda harus memasukkan jalur yang benar ke file WAD Anda.</strong>  Ayo jalankan! <br><br>  Aduh!  Kami mendapat jendela konsol yang hanya terbuka selama beberapa detik!  Tidak ada yang sangat berguna ... apakah program ini bekerja?  Idenya!  Mari kita lihat ingatannya dan lihat apa yang ada di dalamnya!  Mungkin di sana kita akan menemukan sesuatu yang istimewa!  Pertama, letakkan breakpoint dengan mengklik dua kali di sebelah kiri nomor baris.  Anda harus melihat sesuatu seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  Saya menempatkan breakpoint segera setelah membaca semua data dari file untuk melihat array memori dan melihat apa yang dimuat ke dalamnya.  Sekarang jalankan kodenya lagi!  Di jendela otomatis, saya melihat beberapa byte pertama.  4 byte pertama mengatakan "IWAD"!  Bagus, itu berhasil!  Saya tidak pernah berpikir bahwa hari ini akan datang!  Jadi, oke, Anda harus tenang, masih banyak pekerjaan di depan! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="Debug"></div><br><h2>  Baca tajuk </h2><br>  Ukuran total header adalah 12 byte (dari 0x00 hingga 0x0b), 12 byte ini dibagi menjadi 3 grup.  4 byte pertama adalah jenis WAD, biasanya "IWAD" atau "PWAD".  IWAD harus menjadi WAD resmi yang dirilis oleh ID Software, "PWAD" harus digunakan untuk mod.  Dengan kata lain, ini hanya cara untuk menentukan apakah file WAD adalah rilis resmi, atau dirilis oleh modder.  Perhatikan bahwa string tidak diakhiri NULL, jadi berhati-hatilah!  4 byte berikutnya adalah unsigned int, yang berisi jumlah total direktori di akhir file.  4 byte berikutnya menunjukkan offset dari direktori pertama. <br><br>  Mari kita tambahkan struktur yang akan menyimpan informasi.  Saya akan menambahkan file header baru dan beri nama "DataTypes.h".  Di dalamnya kita akan menjelaskan semua struct yang kita butuhkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Sekarang kita perlu mengimplementasikan kelas WADReader, yang akan membaca data dari array byte WAD yang dimuat.  Aduh!  Ada trik di sini - file WAD berada dalam format big-endian, yaitu, kita perlu menggeser byte untuk menjadikannya little-endian (hari ini, kebanyakan sistem menggunakan little endian).  Untuk melakukan ini, kita akan menambahkan dua fungsi, satu untuk memproses 2 byte (16 bit), yang lain untuk memproses 4 byte (32 bit);  jika kita hanya perlu membaca 1 byte, maka tidak ada yang perlu dilakukan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Sekarang kita siap untuk membaca tajuk: hitung empat byte pertama sebagai char, dan kemudian tambahkan NULL untuk menyederhanakan pekerjaan kita.  Dalam hal jumlah direktori dan ofsetnya, Anda cukup menggunakan fungsi bantu untuk mengubahnya menjadi format yang benar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Mari kita satukan semuanya, panggil fungsi-fungsi ini dan cetak hasilnya <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Jalankan program dan lihat apakah semuanya berfungsi! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  Hebat!  Garis IWAD terlihat jelas, tetapi apakah dua angka lainnya benar?  Mari kita coba membaca direktori menggunakan offset ini dan lihat apakah itu berfungsi! <br><br>  Kita perlu menambahkan struct baru untuk menangani direktori yang sesuai dengan opsi di atas. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  Sekarang mari kita tambahkan fungsi ReadDirectories: hitung offset dan outputnya! <br><br>  Dalam setiap iterasi, kita mengalikan i * 16 untuk menuju peningkatan offset direktori berikutnya. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Jalankan kode dan lihat apa yang terjadi.  Wow!  Daftar besar direktori. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Jalankan 2"></div><br>  Menilai dengan nama gumpalan, kita dapat mengasumsikan bahwa kita berhasil membaca data dengan benar, tetapi mungkin ada cara yang lebih baik untuk memeriksa ini.  Kami akan melihat entri Direktori WAD menggunakan Slade3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Tampaknya nama dan ukuran benjolan sesuai dengan data yang diperoleh dengan menggunakan kode kami.  Hari ini kami melakukan pekerjaan yang hebat! <br><br><h2>  Catatan lain </h2><br><ul><li>  Pada titik tertentu, saya pikir akan lebih baik menggunakan vektor untuk menyimpan direktori.  Mengapa tidak menggunakan Peta?  Ini akan lebih cepat daripada mendapatkan data dengan pencarian vektor linier.  Ini ide yang buruk.  Saat menggunakan peta, urutan entri direktori tidak akan dilacak, tetapi kami membutuhkan informasi ini untuk mendapatkan data yang benar. <br><br>  Dan kesalahpahaman lain: Peta di C ++ diimplementasikan sebagai pohon merah-hitam dengan waktu pencarian O (log N), dan iterasi pada peta selalu memberikan urutan kunci yang meningkat.  Jika Anda membutuhkan struktur data yang memberikan waktu rata-rata O (1) dan waktu terburuk O (N), maka Anda harus menggunakan peta yang tidak terurut. </li><li>  <s>Memuat semua file WAD ke dalam memori bukan metode implementasi yang optimal.</s>  <s>Akan lebih logis untuk hanya membaca direktori ke header memori, dan kemudian kembali ke file WAD dan memuat sumber daya dari disk.</s>  <s>Semoga suatu hari nanti kita akan belajar lebih banyak tentang caching.</s> <br><br>  <strong>DOOMReboot</strong> : <em>sama sekali tidak setuju.</em>  <em>15 MB RAM saat ini adalah hal yang agak lengkap, dan membaca dari memori akan jauh lebih cepat daripada fseek yang besar, yang harus digunakan setelah mengunduh semua yang diperlukan untuk level tersebut.</em>  <em>Ini akan menambah waktu pengunduhan tidak kurang dari satu hingga dua detik (saya butuh waktu kurang dari 20 mdetik untuk mengunduh sepanjang waktu).</em>  <em>fseek menggunakan OS.</em>  <em>File mana yang paling mungkin dalam cache RAM, tetapi mungkin tidak.</em>  <em>Tetapi bahkan jika dia ada di sana, itu adalah pemborosan sumber daya yang besar dan operasi ini akan membingungkan banyak pembacaan WAD dalam hal cache CPU.</em>  <em>Yang terbaik adalah Anda dapat membuat metode boot hybrid dan menyimpan data WAD untuk level yang sesuai dengan cache L3 prosesor modern, di mana penghematannya akan luar biasa.</em> </li></ul><br><h2>  Kode sumber </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> <br><br><h2>  Data Kartu Dasar </h2><br>  Setelah belajar membaca file WAD, mari kita coba menggunakan data baca.  Akan luar biasa mempelajari cara membaca data misi (dunia / tingkat) dan menerapkannya.  "Potongan" dari misi ini (Mission Lumps) harus menjadi sesuatu yang rumit dan rumit.  Karena itu, kita perlu memindahkan dan mengembangkan pengetahuan secara bertahap.  Sebagai langkah kecil pertama, mari kita buat sesuatu seperti fitur Automap: rencana dua dimensi peta dengan tampilan atas.  Pertama, mari kita lihat apa yang ada di dalam Mission Lump. <br><br><h2>  Anatomi kartu </h2><br>  Mari kita mulai lagi: deskripsi level DOOM sangat mirip dengan gambar 2D, yang dindingnya ditandai dengan garis.  Namun, untuk mendapatkan koordinat 3D, setiap dinding membutuhkan ketinggian lantai dan langit-langit (XY adalah bidang di mana kita bergerak secara horizontal, dan Z adalah ketinggian yang memungkinkan kita untuk bergerak ke atas dan ke bawah, misalnya, dengan mengangkat lift atau melompat dari platform. Ketiga ini komponen koordinat digunakan untuk membuat misi sebagai dunia 3D, namun, untuk memastikan kinerja yang baik, mesin memiliki batasan tertentu: tidak ada kamar yang terletak satu di atas yang lain di tingkat dan pemain tidak dapat melihat ke atas dan ke bawah. Fitur menarik lainnya: kerang dan  Rock, misalnya, roket, naik secara vertikal untuk mengenai target yang terletak pada platform yang lebih tinggi. <br><br>  Fitur-fitur yang aneh ini telah menyebabkan holival tak berujung tentang apakah DOOM adalah mesin 2D atau 3D.  Secara bertahap, kompromi diplomatik tercapai, yang menyelamatkan banyak nyawa: para pihak menyetujui penunjukan "2.5D" yang dapat diterima oleh keduanya. <br><br>  Untuk menyederhanakan tugas dan kembali ke topik, mari kita coba membaca data 2D ini dan melihat apakah itu dapat digunakan entah bagaimana.  Nanti kita akan mencoba membuatnya dalam 3D, tetapi untuk sekarang kita perlu memahami bagaimana masing-masing bagian mesin bekerja bersama. <br><br>  Setelah melakukan penelitian, saya menemukan bahwa setiap misi terdiri dari satu set "potongan".  "Benjolan" ini selalu direpresentasikan dalam file WAD game DOOM dalam urutan yang sama. <br><br><ol><li>  <strong>Vertex: Titik</strong> akhir dinding dalam 2D.  Dua VERTEX yang terhubung membentuk satu LINEDEF.  Tiga VERTEX yang terhubung membentuk dua dinding / LINEDEF, dan seterusnya.  Mereka hanya dapat dianggap sebagai titik koneksi dari dua dinding atau lebih.  (Ya, kebanyakan orang lebih suka ‚ÄúVertices‚Äù jamak, tetapi John Carmack tidak menyukainya. Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">merriam-webster</a> , kedua opsi berlaku. </li><li>  <strong>LINEDEFS:</strong> garis yang membentuk sambungan antara simpul dan dinding pembentuk.  Tidak semua garis (dinding) berperilaku sama, ada bendera yang menentukan perilaku garis tersebut. </li><li>  <strong>SIDEDDEFS:</strong> dalam kehidupan nyata, dinding memiliki dua sisi - kita melihat satu, yang kedua di sisi lain.  Kedua belah pihak dapat memiliki tekstur yang berbeda, dan SIDEDEFS adalah benjolan yang berisi informasi tekstur untuk dinding (LINEDEF). </li><li>  <strong>SEKTOR:</strong> sektor adalah "kamar" yang diperoleh oleh bergabung dengan LINEDEF.  Setiap sektor berisi informasi seperti ketinggian lantai dan langit-langit, tekstur, nilai pencahayaan, tindakan khusus, seperti lantai / platform / elevator yang bergerak.  Beberapa parameter ini juga mempengaruhi cara dinding diberikan, misalnya, tingkat pencahayaan dan perhitungan koordinat pemetaan tekstur. </li><li>  <strong>SSECTORS:</strong> (subsektor) membentuk area cembung dalam suatu sektor yang digunakan dalam rendering bersama dengan bypass BSP, dan juga membantu menentukan di mana pemain berada pada level tertentu.  Mereka sangat berguna dan sering digunakan untuk menentukan posisi vertikal pemain.  Setiap SSECTOR terdiri dari bagian-bagian sektor yang terhubung, misalnya, dinding yang membentuk sudut.  Bagian dinding seperti itu, atau "ruas," disimpan di Lump mereka sendiri yang disebut ... </li><li>  <strong>SEGS:</strong> bagian dinding / LINEDEF;  dengan kata lain, ini adalah "segmen" dari dinding / LINEDEF.  Dunia diberikan melewati pohon BSP untuk menentukan dinding mana yang akan digambar pertama (yang paling pertama adalah yang paling dekat).  Meskipun sistem bekerja dengan sangat baik, ini menyebabkan linedefs sering terpecah menjadi dua atau lebih SEG.  SEG seperti itu kemudian digunakan untuk membuat dinding daripada LINEDEF.  Geometri setiap SSECTOR ditentukan oleh segmen yang terkandung di dalamnya. </li><li>  <strong>NODES:</strong> Node BSP adalah node dari struktur pohon biner yang menyimpan data subsektor.  Ini digunakan untuk dengan cepat menentukan SSECTOR (dan SEG) yang ada di depan pemain.  Menghilangkan SEG yang terletak di belakang pemain, dan karenanya tidak terlihat, memungkinkan engine untuk fokus pada SEG yang berpotensi terlihat, yang secara signifikan mengurangi waktu render. </li><li>  <strong>HAL:</strong> Benjolan HAL yang disebut adalah daftar pemandangan dan misi aktor (musuh, senjata, dll).  Setiap elemen dari benjolan ini berisi informasi tentang satu instance dari aktor / set, misalnya, jenis objek, titik penciptaan, arah, dan sebagainya. </li><li>  <strong>Tolak:</strong> benjolan ini berisi data tentang sektor mana yang terlihat dari sektor lain.  Ini digunakan untuk menentukan kapan monster mengetahui tentang kehadiran pemain.  Ini juga digunakan untuk menentukan rentang distribusi suara yang dibuat oleh pemain, misalnya, bidikan.  Ketika suara seperti itu dapat ditransmisikan ke sektor monster, dia bisa belajar tentang pemain.  Tabel REJECT juga dapat digunakan untuk mempercepat pengenalan tumbukan peluru senjata. </li><li>  <strong>BLOCKMAP:</strong> informasi pengenalan tabrakan pemain dan gerakan HAL.  Terdiri dari kisi yang mencakup geometri seluruh misi.  Setiap sel kisi berisi daftar LINEDEF yang ada di dalam atau memotongnya.  Ini digunakan untuk secara signifikan mempercepat pengenalan tabrakan: pemeriksaan tabrakan diperlukan hanya untuk beberapa LINEDEF untuk setiap pemain / HAL, yang secara signifikan menghemat daya komputasi. </li></ol><br>  Saat membuat peta 2D kami, kami akan fokus pada VERTEX dan LINEDEFS.  Jika kita bisa menggambar simpul dan menghubungkannya dengan garis yang diberikan oleh linedef, maka kita perlu membuat model peta 2D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Demo peta"></div><br>  Kartu demo yang ditunjukkan di atas memiliki karakteristik sebagai berikut: <br><br><ul><li>  4 puncak <ul><li>  simpul 1 dalam (10.10) </li><li>  2 teratas di (10.100) </li><li>  3 teratas di (100, 10) </li><li>  puncak 4 dalam (100.100) </li></ul></li><li>  4 baris <ul><li>  baris dari atas 1 ke 2 </li><li>  garis dari atas 1 ke 3 </li><li>  garis dari atas 2 ke 4 </li><li>  baris dari 3 ke 4 teratas </li></ul></li></ul><br><h3>  Format vertex </h3><br>  Seperti yang Anda harapkan, data vertex sangat sederhana - hanya x dan y (titik) dari beberapa koordinat. <br><br><div class="scrollable-table"><table><thead><tr><th>  Ukuran bidang </th><th>  Tipe data </th><th>  Konten </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Ditandatangani pendek </td><td>  Posisi X </td></tr><tr><td>  0x02-0x03 </td><td>  Ditandatangani pendek </td><td>  Posisi Y </td></tr></tbody></table></div><br><h3>  Format linedef </h3><br>  Linedef berisi lebih banyak informasi, itu menggambarkan garis yang menghubungkan dua simpul dan sifat-sifat garis ini (yang nantinya akan menjadi tembok). <br><br><div class="scrollable-table"><table><thead><tr><th>  Ukuran bidang </th><th>  Tipe data </th><th>  Konten </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Tidak bertanda pendek </td><td>  Mulai puncak </td></tr><tr><td>  0x02-0x03 </td><td>  Tidak bertanda pendek </td><td>  Puncak tertinggi </td></tr><tr><td>  0x04-0x05 </td><td>  Tidak bertanda pendek </td><td>  Bendera (lihat di bawah untuk detail lebih lanjut) </td></tr><tr><td>  0x06-0x07 </td><td>  Tidak bertanda pendek </td><td>  Jenis Garis / Tindakan </td></tr><tr><td>  0x08-0x09 </td><td>  Tidak bertanda pendek </td><td>  Label sektor </td></tr><tr><td>  0x10-0x11 </td><td>  Tidak bertanda pendek </td><td>  Sisi depan (0xFFFF - tidak ada sisi) </td></tr><tr><td>  0x12-0x13 </td><td>  Tidak bertanda pendek </td><td>  Sisi belakang (0xFFFF - tidak ada sisi) </td></tr></tbody></table></div><br><h3>  Nilai Bendera Linedef </h3><br>  Tidak semua garis (dinding) ditarik.  Beberapa dari mereka memiliki perilaku khusus. <br><br><div class="scrollable-table"><table><thead><tr><th>  Sedikit </th><th>  Deskripsi </th></tr></thead><tbody><tr><td>  0 </td><td>  Memblokir jalan bagi pemain dan monster </td></tr><tr><td>  1 </td><td>  Blokir monster </td></tr><tr><td>  2 </td><td>  Dua sisi </td></tr><tr><td>  3 </td><td>  Tekstur atas dinonaktifkan (kami akan membicarakannya nanti) </td></tr><tr><td>  4 </td><td>  Tekstur bawah dinonaktifkan (kita akan membicarakan ini nanti) </td></tr><tr><td>  5 </td><td>  Rahasia (ditampilkan di peta sebagai dinding satu sisi) </td></tr><tr><td>  6 </td><td>  Menghambat suara </td></tr><tr><td>  7 </td><td>  Tidak pernah ditampilkan di autocard </td></tr><tr><td>  8 </td><td>  Selalu ditampilkan di autocard </td></tr></tbody></table></div><br><h2>  Tujuan </h2><br><ol><li>  Buat kelas Peta. </li><li>  Baca data titik. </li><li>  Baca data linedef. </li></ol><br><h2>  Arsitektur </h2><br>  Pertama, mari kita buat kelas dan menyebutnya peta.  Di dalamnya kami akan menyimpan semua data yang terkait dengan kartu. <br><br>  Untuk saat ini, saya berencana untuk hanya menyimpan simpul dan garis sebagai vektor, sehingga saya bisa menerapkannya nanti. <br><br>  Juga, mari kita melengkapi WADLoader dan WADReader sehingga kita dapat membaca dua informasi baru ini. <br><br><h2>  Coding </h2><br>  Kode akan mirip dengan kode pembacaan WAD, kami hanya akan menambahkan beberapa struktur lagi, dan kemudian mengisinya dengan data dari WAD.  Mari kita mulai dengan menambahkan kelas baru dan meneruskan nama peta. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  Sekarang tambahkan struktur untuk membaca bidang baru ini.  Karena kita sudah melakukan ini beberapa kali, cukup tambahkan semuanya sekaligus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selanjutnya, kita perlu fungsi untuk membacanya dari WADReader, itu akan dekat dengan apa yang kita lakukan sebelumnya. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir tidak ada yang baru untuk Anda di sini. </font><font style="vertical-align: inherit;">Dan sekarang kita perlu memanggil fungsi-fungsi ini dari kelas WADLoader. </font><font style="vertical-align: inherit;">Biarkan saya nyatakan faktanya: urutan benjolan itu penting di sini, kita akan menemukan nama peta di direktori benjolan, diikuti oleh semua benjolan yang terkait dengan peta dalam urutan yang diberikan. </font><font style="vertical-align: inherit;">Untuk menyederhanakan tugas kami dan tidak melacak indeks gumpalan secara terpisah, kami akan menambahkan enumerasi yang memungkinkan kami untuk menghilangkan angka ajaib.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga akan menambahkan fungsi untuk mencari peta dengan namanya di daftar direktori. </font><font style="vertical-align: inherit;">Nantinya, kita cenderung meningkatkan kinerja langkah ini dengan menggunakan struktur data peta, karena ada sejumlah besar catatan di sini, dan kita harus sering melewatinya, terutama pada awal pemuatan sumber daya seperti tekstur, sprite, suara, dll.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow, kita hampir selesai! </font><font style="vertical-align: inherit;">Sekarang, mari kita hitung VERTEX! </font><font style="vertical-align: inherit;">Saya ulangi, kami sudah melakukan ini sebelumnya, sekarang Anda harus mengerti ini.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, sepertinya kita terus-menerus menyalin kode yang sama; </font><font style="vertical-align: inherit;">Anda mungkin harus mengoptimalkannya di masa mendatang, tetapi untuk saat ini Anda akan mengimplementasikan ReadMapLinedef sendiri (atau melihat kode sumber dari tautan). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sentuhan akhir - kita perlu memanggil fungsi ini dan meneruskan objek peta ke sana.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita ubah fungsi utama dan lihat apakah semuanya berfungsi. </font><font style="vertical-align: inherit;">Saya ingin memuat peta "E1M1", yang akan saya transfer ke objek peta.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita jalankan semuanya. </font><font style="vertical-align: inherit;">Wow, banyak nomor yang menarik, tetapi apakah itu benar? </font><font style="vertical-align: inherit;">Mari kita periksa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat apakah slade dapat membantu kita dengan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menemukan peta di menu slade dan melihat detail gumpalan. </font><font style="vertical-align: inherit;">Mari kita bandingkan jumlahnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Vertex"></div><br>  Hebat! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagaimana dengan Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya juga menambahkan enumerasi ini, yang akan kami coba gunakan saat merender peta. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catatan lain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam proses penulisan kode, saya keliru membaca lebih banyak byte daripada yang diperlukan, dan menerima nilai yang salah. </font><font style="vertical-align: inherit;">Untuk debugging, saya mulai melihat offset WAD dalam memori untuk melihat apakah saya berada di offset yang tepat. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menggunakan jendela memori Visual Studio, yang merupakan alat yang sangat berguna untuk melacak byte atau memori (Anda juga dapat mengatur breakpoint di jendela ini). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak melihat jendela memori, buka Debug&gt; Memori&gt; Memori.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita melihat nilai dalam memori dalam heksadesimal. </font><font style="vertical-align: inherit;">Nilai-nilai ini dapat dibandingkan dengan tampilan hex dalam slade dengan mengklik kanan pada setiap benjolan dan menampilkannya sebagai hex.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bandingkan mereka dengan alamat WAD yang dimuat ke dalam memori. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan hal terakhir untuk hari ini: kami melihat semua nilai titik ini, tetapi apakah ada cara mudah untuk memvisualisasikannya tanpa menulis kode? </font><font style="vertical-align: inherit;">Saya tidak ingin membuang waktu untuk hal ini, hanya untuk mengetahui bahwa kita bergerak ke arah yang salah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentunya seseorang sudah membuat plotter. </font><font style="vertical-align: inherit;">Saya mencari "menggambar poin pada grafik" di Google dan hasil pertama adalah situs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points - Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Di atasnya, Anda dapat menempelkan angka dari clipboard, dan dia akan menggambarnya. </font><font style="vertical-align: inherit;">Mereka harus dalam format "(x, y)". </font><font style="vertical-align: inherit;">Untuk mendapatkannya, cukup ubah fungsi output ke layar.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow! </font><font style="vertical-align: inherit;">Itu sudah terlihat seperti E1M1! </font><font style="vertical-align: inherit;">Kami telah mencapai sesuatu!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="Poin Plot E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda malas melakukan ini, berikut adalah tautan ke bagan bertitik: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi mari kita ambil satu langkah lagi: setelah sedikit kerja, kita bisa menghubungkan titik-titik ini berdasarkan linedefs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut tautannya: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode sumber</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referensi </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471552/">https://habr.com/ru/post/id471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471538/index.html">Dari gagasan aplikasi seluler hingga MVP, investor akan berinvestasi</a></li>
<li><a href="../id471542/index.html">Pengenalan Teks OCR</a></li>
<li><a href="../id471544/index.html">Tentang cinta, atau Mengapa perwira Cossack mengubah seragamnya menjadi jubah Uzbek</a></li>
<li><a href="../id471548/index.html">5 Buku Teratas untuk Dibaca oleh Artis</a></li>
<li><a href="../id471550/index.html">Di mana mendapatkan audio untuk pengembangan game dan proyek komersial lainnya? Perpustakaan dengan suara alam</a></li>
<li><a href="../id471554/index.html">Bagaimana cara mengurangi risiko klaim pajak dari penjualan aplikasi dan konten?</a></li>
<li><a href="../id471556/index.html">Tur Dunia Fujitsu 2019. Bagaimana konferensi terbesar kami</a></li>
<li><a href="../id471558/index.html">Ibu, saya di TV: bagaimana final dari kontes Digital Breakthrough</a></li>
<li><a href="../id471562/index.html">Superinfeksi 2: Rubicon masalah, kegagalan teknologi dan harapan baru</a></li>
<li><a href="../id471564/index.html">Teman RaspberryPi dengan TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>