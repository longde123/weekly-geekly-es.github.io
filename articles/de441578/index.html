<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 😭 👐🏾 React Tutorial Teil 19: Methoden des Komponentenlebenszyklus 🕙 🚚 🎁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im heutigen Teil der Übersetzung des React-Lernprogramms erhalten Sie einen Überblick über die Methoden des Komponentenlebenszyklus. 

  

 → Teil 1: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React Tutorial Teil 19: Methoden des Komponentenlebenszyklus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  Im heutigen Teil der Übersetzung des React-Lernprogramms erhalten Sie einen Überblick über die Methoden des Komponentenlebenszyklus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="Bild"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Kursübersicht, Gründe für die Beliebtheit von React, ReactDOM und JSX</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Funktionskomponenten</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Komponentendateien, Projektstruktur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: übergeordnete und untergeordnete Komponenten</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Beginn der Arbeit an einer TODO-Anwendung, Grundlagen des Stylings</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Über einige Funktionen des Kurses, JSX und JavaScript</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Inline-Stile</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Fortsetzung der Arbeit an der TODO-Anwendung, Vertrautheit mit den Eigenschaften von Komponenten</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Komponenteneigenschaften</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 10: Workshop zum Arbeiten mit Komponenteneigenschaften und Styling</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 11: Dynamische Markup-Generierung und Map-Arrays-Methode</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 12: Workshop, dritte Phase der Arbeit an einer TODO-Anwendung</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 13: Klassenbasierte Komponenten</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 14: Workshop zu klassenbasierten Komponenten, Komponentenstatus</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 15: Komponentengesundheitsworkshops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 16: Die vierte Phase der Arbeit an einer TODO-Anwendung, die Ereignisbehandlung</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 17: Fünfte Phase der Arbeit an einer TODO-Anwendung, Änderung des Status von Komponenten</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 18: Die sechste Phase der Arbeit an einer TODO-Anwendung</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 19: Methoden des Komponentenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 20: Die erste Lektion in bedingtem Rendern</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 21: Zweite Lektion und Workshop zum bedingten Rendern</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 22: Die siebte Phase der Arbeit an einer TODO-Anwendung, bei der Daten aus externen Quellen heruntergeladen werden</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 23: Erste Lektion zum Arbeiten mit Formularen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 24: Lektion der zweiten Form</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 25: Workshop zum Arbeiten mit Formularen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 26: Anwendungsarchitektur, Container- / Komponentenmuster</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 27: Kursprojekt</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lektion 34. Methoden des Komponentenlebenszyklus, Teil 1</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original</a> <br><br>  Eines der Merkmale bei der Entwicklung von React-Anwendungen ist die Tatsache, dass wir ziemlich einfachen JavaScript-Code schreiben, der die internen Mechanismen von React steuert und uns dadurch großartige Möglichkeiten bietet, Anwendungsschnittstellen zu entwickeln und mit Daten zu arbeiten.  Gleichzeitig durchlaufen die Komponenten, die wir während ihres Lebenszyklus verwenden, bestimmte Phasen.  Oft wird das, was mit einer Komponente in einer Anwendung passiert, mit dem Leben einer Person verglichen.  Menschen werden geboren, leben, in ihrem Leben passieren einige bedeutende Ereignisse, nach denen sie sterben.  Die Komponenten von React sind ähnlich wie bei Menschen, da sie auch „geboren“, „leben“ und „sterben“.  Wenn wir mit Komponenten arbeiten, können wir dank der Methoden ihres Lebenszyklus, die zu bestimmten Zeitpunkten ihres „Lebens“ aufgerufen werden, auf das reagieren, was mit ihnen passiert. <br><br>  Vor kurzem hat das React-Entwicklungsteam drei Komponenten-Lebenszyklusmethoden veraltet.  Wir werden diese Methoden dennoch berücksichtigen, da sie weiterhin verwendet werden können und in vorhandenem Code enthalten sind.  Darüber hinaus wurden React zwei neue Methoden für den Lebenszyklus von Komponenten hinzugefügt, die wir in der nächsten Lektion diskutieren werden. <br><br>  Wir werden nur die wichtigsten Methoden betrachten, die für diejenigen am relevantesten sind, die gerade mit dem Studium von React begonnen haben.  Wenn Sie diese Bibliothek weiterhin beherrschen, können Sie mit anderen Methoden experimentieren. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden Sie</a> einige gute Informationen zu den Lebenszyklusmethoden von React-Komponenten, die vor React 16.3 relevant waren.  In einer Veröffentlichung aus dem offiziellen React-Entwicklerblog erfahren Sie hier, welche Änderungen in React 16.3 vorgenommen wurden. <br><br>  Beginnen wir nun mit der Diskussion über die Lebenszyklusmethoden der React-Komponenten, auf die Sie am häufigsten stoßen werden. <br><br>  Wir werden wie immer das Demo-Projekt hier verwenden.  In diesem Fall beginnen wir mit einem Standardprojekt, das mit create-react-app in der Datei <code>App.js</code> erstellt wurde und den folgenden Code enthält: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Schauen wir uns zunächst die Methode an, die Sie bereits für klassenbasierte Komponenten verwendet haben.  Dies ist die <code>render()</code> -Methode. <br><br>  Oft wird er nicht erwähnt, wenn er über die Methoden des Komponentenlebenszyklus spricht.  Ich denke, dass diese Methode beim Vergleich einer Komponente mit einer Person mit dem Anziehen vor dem Ausgehen verglichen werden kann.  Ziel dieser Methode ist es zu bestimmen, was auf dem Bildschirm angezeigt wird, dh wie die Komponente aussehen wird.  Die <code>render()</code> -Methode kann während der Lebensdauer einer Komponente mehrmals aufgerufen werden.  Wenn React feststellt, dass sich etwas in Bezug auf eine Komponente geändert hat, z. B. ein Status oder Eigenschaften, dh etwas, das das Erscheinungsbild einer Komponente beeinflussen kann, kann React diese Methode aufrufen.  Dies kann verglichen werden, wenn wir die Analogie mit Menschen fortsetzen, so dass eine Person entscheiden kann, sich umzuziehen.  Zum Beispiel, um sich nach einem Arbeitstag auf eine Art Urlaubsereignis vorzubereiten. <br><br>  Schauen wir uns nun eine andere Methode für den <code>componentDidMount()</code> - <code>componentDidMount()</code> .  Diese Methode wird wie alle anderen klassenbasierten Komponentenmethoden im Hauptteil einer Komponentenklasse deklariert: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Diese Methode wird zum Zeitpunkt des Lebenszyklus der Komponente aufgerufen, was mit der „Geburt“ dieser Komponente verglichen werden kann.  Diese Methode wird einmal ausgelöst, nachdem die Komponente in den DOM-Baum eingebunden (eingefügt) wurde.  Wenn beispielsweise nach dem Ändern einiger Daten, die sich auf das Erscheinungsbild der Komponente auswirken, diese erneut gerendert werden, wird die Methode <code>componentDidMount()</code> nicht aufgerufen.  Dies liegt daran, dass bei der Ausführung solcher Vorgänge die Komponente nicht aus dem DOM-Baum entfernt und dann wieder in den Baum aufgenommen wird. <br><br>  Die <code>componentDidMount()</code> -Methode wird normalerweise verwendet, um bestimmte APIs aufzurufen, wenn der Entwickler Daten aus externen Quellen benötigt.  Angenommen, die Komponente, die wir hier betrachten, heißt tatsächlich <code>TodoList</code> und ist eine Komponente, die eine <code>TodoList</code> in einer Todo-Anwendung bildet.  Die <code>componentDidMount()</code> -Methode einer solchen Komponente kann Materialien aus der Serverdatenbank laden, die für die korrekte Anzeige der auf dem Server gespeicherten Aufgabenliste erforderlich sind.  Infolgedessen können wir nach Abschluss der Installation der Komponente in der Methode <code>componentDidMount()</code> die Daten laden, die erforderlich sind, damit die Komponente korrekt auf der Seite angezeigt wird.  Wir werden auch über das Laden von Daten sprechen, die von Komponenten benötigt werden. Im Moment können Sie sich jedoch daran erinnern, dass dies der häufigste Anwendungsfall für <code>componentDidMount()</code> . <br><br>  Die nächste Methode zum Komponentenlebenszyklus, die wir diskutieren, heißt <code>componentWillReceiveProps()</code> .  Diese Methode kann mit dem verglichen werden, was passiert, wenn jemand ein Geschenk von jemandem erhält.  Eine Komponente kann also Eigenschaften von einer übergeordneten Komponente empfangen.  Jedes Mal, wenn eine Komponente Eigenschaften annimmt, wird diese Methode aufgerufen.  Gleichzeitig wird diese Methode jedes Mal aufgerufen, wenn die übergeordnete Komponente die Eigenschaften an die untergeordnete Komponente übergibt, und dies nicht nur, wenn dies zum ersten Mal geschieht.  Wenn die übergeordnete Komponente beispielsweise beschließt, die an die untergeordnete Komponente übergebenen Eigenschaften zu ändern, können wir in der Methode <code>componentWillReceiveProps()</code> beispielsweise überprüfen, ob sich die neuen Eigenschaften von denen unterscheiden, die bereits an die Komponente übergeben wurden.  Tatsache ist, dass, wenn sich die neuen Eigenschaften nicht von den alten unterscheiden, dies bedeutet, dass ihr Empfang nichts ändert, was bedeutet, dass wir nach dem Herausfinden nichts mehr tun können.  Wenn sich die neuen Eigenschaften von den alten unterscheiden, können wir bestimmte Aktionen ausführen.  In der Regel wird diese Methode im Hauptteil der Komponentenklasse wie folgt deklariert: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Hier wird es normalerweise als Parametername <code>nextProps</code> , aber Sie können diesen Parameter beliebig benennen.  Um eine bestimmte Eigenschaft, die bereits auf die Komponente übertragen wurde, mit der bereits zuvor übergebenen Eigenschaft zu vergleichen und weitere Aktionen festzulegen, können Sie diese Konstruktion verwenden: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Normalerweise wird diese Methode auf diese Weise verwendet. <br><br>  Wie bereits erwähnt, waren nach der Veröffentlichung von React 16.3 einige Methoden des Komponentenlebenszyklus veraltet, und <code>componentWillReceiveProps()</code> ist eine dieser Methoden. <br><br>  Bis React 17 können diese Legacy-Methoden weiterhin verwendet werden, obwohl dies besser nicht der Fall ist.  Wenn Sie auf die betreffende Methode nicht verzichten können, müssen Sie sie <code>UNSAFE_componentWillReceiveProps()</code> .  Nach React 17 bedeutet der Name der <code>componentWillReceiveProps()</code> -Methode nichts Besonderes. <br><br>  Es ist nützlich, diese Methode zu kennen, um veralteten Code verstehen zu können, sie wird jedoch bei der Entwicklung moderner React-Anwendungen nicht verwendet. <br><br>  Eine weitere interessante Methode für den Komponentenlebenszyklus heißt <code>shouldComponentUpdate()</code> .  Wenn wir die Komponente weiterhin mit einer Person vergleichen, erinnert er sich an den Moment, in dem eine Person darüber nachdenkt, ob sie sich umziehen muss oder nicht.  Wenn React unter normalen Bedingungen nicht ganz sicher ist, ob eine Komponente erneut gerendert werden soll, wird sie für alle Fälle gerendert.  Es spielt keine Rolle, ob dies gemäß der Anwendungslogik erforderlich ist oder nicht. <br><br>  Dies führt dazu, dass React Komponenten neu rendert, auch wenn sich nichts an der Komponente ändert.  Dies kann die Anwendung verlangsamen, da React nach diesem Prinzip alle Komponenten verarbeitet, aus denen die Anwendung besteht.  Mit der Methode <code>shouldComponentUpdate()</code> kann der Entwickler die Anwendung optimieren.  Hier können Sie eine Logik implementieren, mit deren Hilfe Sie herausfinden können, ob die Komponente aktualisiert werden muss.  Diese Methode wird normalerweise folgendermaßen deklariert: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  Darüber hinaus müssen Sie bei dieser Methode <code>true</code> , wenn die Komponente unter Berücksichtigung neuer Eigenschaften und Status neu gerendert werden muss.  Andernfalls muss <code>false</code> zurückgegeben werden.  Die Rückgabe von <code>false</code> von dieser Methode führt dazu, dass die Komponente nicht aktualisiert wird und die Anwendung schneller ausgeführt wird. Auf diese Weise müssen Sie jedoch sicherstellen, dass die Komponente nicht wirklich neu gerendert werden muss.  Wenn die Komponente aktualisiert werden muss und diese Methode <code>false</code> , führt dies zu Fehlern, die nur schwer zu beheben sind. <br><br>  Eine andere Methode für den Komponentenlebenszyklus, über die wir sprechen werden, heißt <code>componentWillUnmount()</code> .  Diese Methode markiert das Ende der „Lebensdauer“ der Komponente - den Moment, in dem sie aus dem DOM-Baum entfernt wird und vom Bildschirm verschwindet. <br><br>  Diese Methode wird hauptsächlich verwendet, um Ressourcen freizugeben, die von einer Komponente belegt werden, und um die Dinge in Ordnung zu bringen, bevor sie gelöscht wird.  Wenn die <code>componentDidMount()</code> -Methode beispielsweise mit einem Ereignis-Listener konfiguriert wurde, aufgrund dessen beim Scrollen der Seite durch den Benutzer Code ausgeführt wird, können Sie in <code>componentWillUnmount()</code> einen solchen Ereignis-Listener löschen.  Tatsächlich hat diese Methode viele Anwendungen, die darauf abzielen, alles aus der Anwendung zu entfernen, was sich nach dem Verschwinden der Komponente als unnötig herausstellt. <br><br>  Hier ist der vollständige Code unserer <code>App</code> Komponente, in der Lebenszyklusmethoden hinzugefügt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Damit ist diese Lektion abgeschlossen, obwohl zu beachten ist, dass die Lebenszyklusmethoden der React-Komponenten nicht auf die heute beschriebenen beschränkt sind. <br><br><h2>  <font color="#3AC1EF">Lektion 35. Methoden des Komponentenlebenszyklus, Teil 2</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original</a> <br><br>  Wie bereits in der vorherigen Lektion erwähnt, wurde beim Erscheinen von React 16.3 berichtet, dass die drei Komponenten-Lebenszyklusmethoden veraltet waren.  Diese Methoden sind <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> und <code>componentWillUpdate()</code> .  Zwei neue Methoden wurden ebenfalls berichtet.  Dies ist die statische Methode <code>getDerivedStateFromProps()</code> und die Methode <code>getSnapshotBeforeUpdate()</code> .  Es kann nicht gesagt werden, dass diese Methoden in zukünftigen Klassen dieses Kurses eine wichtige Rolle spielen werden, aber trotzdem werden wir sie hier kennenlernen. <br><br>  Wir werden in demselben Projekt experimentieren, das wir zuletzt verwendet haben. <br><br>  So sieht die Deklaration der Methode <code>getDerivedStateFromProps()</code> aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Beachten Sie das <code>static</code> vor dem Methodennamen.  Er muss auf der Grundlage der von ihm akzeptierten Eigenschaften einen aktualisierten Zustand zurückgeben.  Es wird in den Fällen verwendet, in denen eine bestimmte Komponente die eingehenden Eigenschaften, die sie von der übergeordneten Komponente empfängt, akzeptieren und ihren Status basierend auf diesen Eigenschaften konfigurieren muss.  Details zu dieser Methode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dieses im React-Blog veröffentlichte Material besagt, dass die Verwendung dieser Methode in all den Situationen, in denen sie nützlich erscheint, alles andere als gerechtfertigt ist.  Die unsachgemäße Verwendung kann zu verschiedenen Fehlern und zu einem Rückgang der Anwendungsleistung führen. Verwenden Sie sie daher mit Vorsicht.  Sie sollten nicht versuchen, Probleme mit seiner Hilfe zu lösen, für deren Lösung es nicht vorgesehen ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist die</a> Dokumentation für diese Methode. <br><br>  Lassen Sie uns nun über die Methode <code>getSnapshotBeforeUpdate()</code> sprechen.  So sieht seine Erklärung im Klassenkörper aus: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Es kann als Lebenszyklusmethode betrachtet werden, mit der Sie vor dem Aktualisieren eine Sicherungskopie der Komponenten erstellen können.  Es ähnelt einer Momentaufnahme des Status einer Anwendung.  Es sollte beachtet werden, dass die Entwickler von React sagen, dass der Umfang dieser Methode begrenzt ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist die</a> Dokumentation dafür. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir über Methoden des Komponentenlebenszyklus gesprochen.  Wenn Sie die Entwicklung von React-Anwendungen vorantreiben, werden diese sicherlich nützlich sein.  In den weiteren Klassen dieses Kurses werden wir uns mit diesen Methoden befassen, insbesondere mit <code>componentDidMount()</code> .  Nächstes Mal werden wir über bedingtes Rendern sprechen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie React-Anwendungen professionell entwickeln, teilen Sie uns bitte mit, wie Sie Methoden für den Lebenszyklus von Komponenten verwenden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441578/">https://habr.com/ru/post/de441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441568/index.html">Python-Speicherverwaltung</a></li>
<li><a href="../de441570/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 353 (17. - 24. Februar 2019)</a></li>
<li><a href="../de441572/index.html">Frontend Weekly Digest (18. - 24. Februar 2019)</a></li>
<li><a href="../de441574/index.html">Docker lernen Teil 6: Arbeiten mit Daten</a></li>
<li><a href="../de441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../de441580/index.html">React Tutorial Teil 20: Erste Lektion zum bedingten Rendern</a></li>
<li><a href="../de441582/index.html">Optimierung des LQR-Steuerungssystems</a></li>
<li><a href="../de441584/index.html">PHP Digest Nr. 150 (11. - 25. Februar 2019)</a></li>
<li><a href="../de441586/index.html">Wie man Musik empfiehlt, die fast niemand gehört hat. Yandex-Bericht</a></li>
<li><a href="../de441590/index.html">Die Entwicklung der Cluster-Interaktion. Wie wir ActiveMQ und Hazelcast implementiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>