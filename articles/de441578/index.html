<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø üò≠ üëêüèæ React Tutorial Teil 19: Methoden des Komponentenlebenszyklus üïô üöö üéÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im heutigen Teil der √úbersetzung des React-Lernprogramms erhalten Sie einen √úberblick √ºber die Methoden des Komponentenlebenszyklus. 

  

 ‚Üí Teil 1: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React Tutorial Teil 19: Methoden des Komponentenlebenszyklus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  Im heutigen Teil der √úbersetzung des React-Lernprogramms erhalten Sie einen √úberblick √ºber die Methoden des Komponentenlebenszyklus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="Bild"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Kurs√ºbersicht, Gr√ºnde f√ºr die Beliebtheit von React, ReactDOM und JSX</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Funktionskomponenten</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Komponentendateien, Projektstruktur</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: √ºbergeordnete und untergeordnete Komponenten</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Beginn der Arbeit an einer TODO-Anwendung, Grundlagen des Stylings</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: √úber einige Funktionen des Kurses, JSX und JavaScript</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Inline-Stile</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Fortsetzung der Arbeit an der TODO-Anwendung, Vertrautheit mit den Eigenschaften von Komponenten</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Komponenteneigenschaften</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 10: Workshop zum Arbeiten mit Komponenteneigenschaften und Styling</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 11: Dynamische Markup-Generierung und Map-Arrays-Methode</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 12: Workshop, dritte Phase der Arbeit an einer TODO-Anwendung</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 13: Klassenbasierte Komponenten</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 14: Workshop zu klassenbasierten Komponenten, Komponentenstatus</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 15: Komponentengesundheitsworkshops</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 16: Die vierte Phase der Arbeit an einer TODO-Anwendung, die Ereignisbehandlung</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 17: F√ºnfte Phase der Arbeit an einer TODO-Anwendung, √Ñnderung des Status von Komponenten</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 18: Die sechste Phase der Arbeit an einer TODO-Anwendung</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 19: Methoden des Komponentenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 20: Die erste Lektion in bedingtem Rendern</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 21: Zweite Lektion und Workshop zum bedingten Rendern</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 22: Die siebte Phase der Arbeit an einer TODO-Anwendung, bei der Daten aus externen Quellen heruntergeladen werden</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 23: Erste Lektion zum Arbeiten mit Formularen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 24: Lektion der zweiten Form</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 25: Workshop zum Arbeiten mit Formularen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 26: Anwendungsarchitektur, Container- / Komponentenmuster</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 27: Kursprojekt</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lektion 34. Methoden des Komponentenlebenszyklus, Teil 1</font> </h2><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original</a> <br><br>  Eines der Merkmale bei der Entwicklung von React-Anwendungen ist die Tatsache, dass wir ziemlich einfachen JavaScript-Code schreiben, der die internen Mechanismen von React steuert und uns dadurch gro√üartige M√∂glichkeiten bietet, Anwendungsschnittstellen zu entwickeln und mit Daten zu arbeiten.  Gleichzeitig durchlaufen die Komponenten, die wir w√§hrend ihres Lebenszyklus verwenden, bestimmte Phasen.  Oft wird das, was mit einer Komponente in einer Anwendung passiert, mit dem Leben einer Person verglichen.  Menschen werden geboren, leben, in ihrem Leben passieren einige bedeutende Ereignisse, nach denen sie sterben.  Die Komponenten von React sind √§hnlich wie bei Menschen, da sie auch ‚Äûgeboren‚Äú, ‚Äûleben‚Äú und ‚Äûsterben‚Äú.  Wenn wir mit Komponenten arbeiten, k√∂nnen wir dank der Methoden ihres Lebenszyklus, die zu bestimmten Zeitpunkten ihres ‚ÄûLebens‚Äú aufgerufen werden, auf das reagieren, was mit ihnen passiert. <br><br>  Vor kurzem hat das React-Entwicklungsteam drei Komponenten-Lebenszyklusmethoden veraltet.  Wir werden diese Methoden dennoch ber√ºcksichtigen, da sie weiterhin verwendet werden k√∂nnen und in vorhandenem Code enthalten sind.  Dar√ºber hinaus wurden React zwei neue Methoden f√ºr den Lebenszyklus von Komponenten hinzugef√ºgt, die wir in der n√§chsten Lektion diskutieren werden. <br><br>  Wir werden nur die wichtigsten Methoden betrachten, die f√ºr diejenigen am relevantesten sind, die gerade mit dem Studium von React begonnen haben.  Wenn Sie diese Bibliothek weiterhin beherrschen, k√∂nnen Sie mit anderen Methoden experimentieren. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden Sie</a> einige gute Informationen zu den Lebenszyklusmethoden von React-Komponenten, die vor React 16.3 relevant waren.  In einer Ver√∂ffentlichung aus dem offiziellen React-Entwicklerblog erfahren Sie hier, welche √Ñnderungen in React 16.3 vorgenommen wurden. <br><br>  Beginnen wir nun mit der Diskussion √ºber die Lebenszyklusmethoden der React-Komponenten, auf die Sie am h√§ufigsten sto√üen werden. <br><br>  Wir werden wie immer das Demo-Projekt hier verwenden.  In diesem Fall beginnen wir mit einem Standardprojekt, das mit create-react-app in der Datei <code>App.js</code> erstellt wurde und den folgenden Code enth√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Schauen wir uns zun√§chst die Methode an, die Sie bereits f√ºr klassenbasierte Komponenten verwendet haben.  Dies ist die <code>render()</code> -Methode. <br><br>  Oft wird er nicht erw√§hnt, wenn er √ºber die Methoden des Komponentenlebenszyklus spricht.  Ich denke, dass diese Methode beim Vergleich einer Komponente mit einer Person mit dem Anziehen vor dem Ausgehen verglichen werden kann.  Ziel dieser Methode ist es zu bestimmen, was auf dem Bildschirm angezeigt wird, dh wie die Komponente aussehen wird.  Die <code>render()</code> -Methode kann w√§hrend der Lebensdauer einer Komponente mehrmals aufgerufen werden.  Wenn React feststellt, dass sich etwas in Bezug auf eine Komponente ge√§ndert hat, z. B. ein Status oder Eigenschaften, dh etwas, das das Erscheinungsbild einer Komponente beeinflussen kann, kann React diese Methode aufrufen.  Dies kann verglichen werden, wenn wir die Analogie mit Menschen fortsetzen, so dass eine Person entscheiden kann, sich umzuziehen.  Zum Beispiel, um sich nach einem Arbeitstag auf eine Art Urlaubsereignis vorzubereiten. <br><br>  Schauen wir uns nun eine andere Methode f√ºr den <code>componentDidMount()</code> - <code>componentDidMount()</code> .  Diese Methode wird wie alle anderen klassenbasierten Komponentenmethoden im Hauptteil einer Komponentenklasse deklariert: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Diese Methode wird zum Zeitpunkt des Lebenszyklus der Komponente aufgerufen, was mit der ‚ÄûGeburt‚Äú dieser Komponente verglichen werden kann.  Diese Methode wird einmal ausgel√∂st, nachdem die Komponente in den DOM-Baum eingebunden (eingef√ºgt) wurde.  Wenn beispielsweise nach dem √Ñndern einiger Daten, die sich auf das Erscheinungsbild der Komponente auswirken, diese erneut gerendert werden, wird die Methode <code>componentDidMount()</code> nicht aufgerufen.  Dies liegt daran, dass bei der Ausf√ºhrung solcher Vorg√§nge die Komponente nicht aus dem DOM-Baum entfernt und dann wieder in den Baum aufgenommen wird. <br><br>  Die <code>componentDidMount()</code> -Methode wird normalerweise verwendet, um bestimmte APIs aufzurufen, wenn der Entwickler Daten aus externen Quellen ben√∂tigt.  Angenommen, die Komponente, die wir hier betrachten, hei√üt tats√§chlich <code>TodoList</code> und ist eine Komponente, die eine <code>TodoList</code> in einer Todo-Anwendung bildet.  Die <code>componentDidMount()</code> -Methode einer solchen Komponente kann Materialien aus der Serverdatenbank laden, die f√ºr die korrekte Anzeige der auf dem Server gespeicherten Aufgabenliste erforderlich sind.  Infolgedessen k√∂nnen wir nach Abschluss der Installation der Komponente in der Methode <code>componentDidMount()</code> die Daten laden, die erforderlich sind, damit die Komponente korrekt auf der Seite angezeigt wird.  Wir werden auch √ºber das Laden von Daten sprechen, die von Komponenten ben√∂tigt werden. Im Moment k√∂nnen Sie sich jedoch daran erinnern, dass dies der h√§ufigste Anwendungsfall f√ºr <code>componentDidMount()</code> . <br><br>  Die n√§chste Methode zum Komponentenlebenszyklus, die wir diskutieren, hei√üt <code>componentWillReceiveProps()</code> .  Diese Methode kann mit dem verglichen werden, was passiert, wenn jemand ein Geschenk von jemandem erh√§lt.  Eine Komponente kann also Eigenschaften von einer √ºbergeordneten Komponente empfangen.  Jedes Mal, wenn eine Komponente Eigenschaften annimmt, wird diese Methode aufgerufen.  Gleichzeitig wird diese Methode jedes Mal aufgerufen, wenn die √ºbergeordnete Komponente die Eigenschaften an die untergeordnete Komponente √ºbergibt, und dies nicht nur, wenn dies zum ersten Mal geschieht.  Wenn die √ºbergeordnete Komponente beispielsweise beschlie√üt, die an die untergeordnete Komponente √ºbergebenen Eigenschaften zu √§ndern, k√∂nnen wir in der Methode <code>componentWillReceiveProps()</code> beispielsweise √ºberpr√ºfen, ob sich die neuen Eigenschaften von denen unterscheiden, die bereits an die Komponente √ºbergeben wurden.  Tatsache ist, dass, wenn sich die neuen Eigenschaften nicht von den alten unterscheiden, dies bedeutet, dass ihr Empfang nichts √§ndert, was bedeutet, dass wir nach dem Herausfinden nichts mehr tun k√∂nnen.  Wenn sich die neuen Eigenschaften von den alten unterscheiden, k√∂nnen wir bestimmte Aktionen ausf√ºhren.  In der Regel wird diese Methode im Hauptteil der Komponentenklasse wie folgt deklariert: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Hier wird es normalerweise als Parametername <code>nextProps</code> , aber Sie k√∂nnen diesen Parameter beliebig benennen.  Um eine bestimmte Eigenschaft, die bereits auf die Komponente √ºbertragen wurde, mit der bereits zuvor √ºbergebenen Eigenschaft zu vergleichen und weitere Aktionen festzulegen, k√∂nnen Sie diese Konstruktion verwenden: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Normalerweise wird diese Methode auf diese Weise verwendet. <br><br>  Wie bereits erw√§hnt, waren nach der Ver√∂ffentlichung von React 16.3 einige Methoden des Komponentenlebenszyklus veraltet, und <code>componentWillReceiveProps()</code> ist eine dieser Methoden. <br><br>  Bis React 17 k√∂nnen diese Legacy-Methoden weiterhin verwendet werden, obwohl dies besser nicht der Fall ist.  Wenn Sie auf die betreffende Methode nicht verzichten k√∂nnen, m√ºssen Sie sie <code>UNSAFE_componentWillReceiveProps()</code> .  Nach React 17 bedeutet der Name der <code>componentWillReceiveProps()</code> -Methode nichts Besonderes. <br><br>  Es ist n√ºtzlich, diese Methode zu kennen, um veralteten Code verstehen zu k√∂nnen, sie wird jedoch bei der Entwicklung moderner React-Anwendungen nicht verwendet. <br><br>  Eine weitere interessante Methode f√ºr den Komponentenlebenszyklus hei√üt <code>shouldComponentUpdate()</code> .  Wenn wir die Komponente weiterhin mit einer Person vergleichen, erinnert er sich an den Moment, in dem eine Person dar√ºber nachdenkt, ob sie sich umziehen muss oder nicht.  Wenn React unter normalen Bedingungen nicht ganz sicher ist, ob eine Komponente erneut gerendert werden soll, wird sie f√ºr alle F√§lle gerendert.  Es spielt keine Rolle, ob dies gem√§√ü der Anwendungslogik erforderlich ist oder nicht. <br><br>  Dies f√ºhrt dazu, dass React Komponenten neu rendert, auch wenn sich nichts an der Komponente √§ndert.  Dies kann die Anwendung verlangsamen, da React nach diesem Prinzip alle Komponenten verarbeitet, aus denen die Anwendung besteht.  Mit der Methode <code>shouldComponentUpdate()</code> kann der Entwickler die Anwendung optimieren.  Hier k√∂nnen Sie eine Logik implementieren, mit deren Hilfe Sie herausfinden k√∂nnen, ob die Komponente aktualisiert werden muss.  Diese Methode wird normalerweise folgenderma√üen deklariert: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  Dar√ºber hinaus m√ºssen Sie bei dieser Methode <code>true</code> , wenn die Komponente unter Ber√ºcksichtigung neuer Eigenschaften und Status neu gerendert werden muss.  Andernfalls muss <code>false</code> zur√ºckgegeben werden.  Die R√ºckgabe von <code>false</code> von dieser Methode f√ºhrt dazu, dass die Komponente nicht aktualisiert wird und die Anwendung schneller ausgef√ºhrt wird. Auf diese Weise m√ºssen Sie jedoch sicherstellen, dass die Komponente nicht wirklich neu gerendert werden muss.  Wenn die Komponente aktualisiert werden muss und diese Methode <code>false</code> , f√ºhrt dies zu Fehlern, die nur schwer zu beheben sind. <br><br>  Eine andere Methode f√ºr den Komponentenlebenszyklus, √ºber die wir sprechen werden, hei√üt <code>componentWillUnmount()</code> .  Diese Methode markiert das Ende der ‚ÄûLebensdauer‚Äú der Komponente - den Moment, in dem sie aus dem DOM-Baum entfernt wird und vom Bildschirm verschwindet. <br><br>  Diese Methode wird haupts√§chlich verwendet, um Ressourcen freizugeben, die von einer Komponente belegt werden, und um die Dinge in Ordnung zu bringen, bevor sie gel√∂scht wird.  Wenn die <code>componentDidMount()</code> -Methode beispielsweise mit einem Ereignis-Listener konfiguriert wurde, aufgrund dessen beim Scrollen der Seite durch den Benutzer Code ausgef√ºhrt wird, k√∂nnen Sie in <code>componentWillUnmount()</code> einen solchen Ereignis-Listener l√∂schen.  Tats√§chlich hat diese Methode viele Anwendungen, die darauf abzielen, alles aus der Anwendung zu entfernen, was sich nach dem Verschwinden der Komponente als unn√∂tig herausstellt. <br><br>  Hier ist der vollst√§ndige Code unserer <code>App</code> Komponente, in der Lebenszyklusmethoden hinzugef√ºgt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Damit ist diese Lektion abgeschlossen, obwohl zu beachten ist, dass die Lebenszyklusmethoden der React-Komponenten nicht auf die heute beschriebenen beschr√§nkt sind. <br><br><h2>  <font color="#3AC1EF">Lektion 35. Methoden des Komponentenlebenszyklus, Teil 2</font> </h2><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original</a> <br><br>  Wie bereits in der vorherigen Lektion erw√§hnt, wurde beim Erscheinen von React 16.3 berichtet, dass die drei Komponenten-Lebenszyklusmethoden veraltet waren.  Diese Methoden sind <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> und <code>componentWillUpdate()</code> .  Zwei neue Methoden wurden ebenfalls berichtet.  Dies ist die statische Methode <code>getDerivedStateFromProps()</code> und die Methode <code>getSnapshotBeforeUpdate()</code> .  Es kann nicht gesagt werden, dass diese Methoden in zuk√ºnftigen Klassen dieses Kurses eine wichtige Rolle spielen werden, aber trotzdem werden wir sie hier kennenlernen. <br><br>  Wir werden in demselben Projekt experimentieren, das wir zuletzt verwendet haben. <br><br>  So sieht die Deklaration der Methode <code>getDerivedStateFromProps()</code> aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Beachten Sie das <code>static</code> vor dem Methodennamen.  Er muss auf der Grundlage der von ihm akzeptierten Eigenschaften einen aktualisierten Zustand zur√ºckgeben.  Es wird in den F√§llen verwendet, in denen eine bestimmte Komponente die eingehenden Eigenschaften, die sie von der √ºbergeordneten Komponente empf√§ngt, akzeptieren und ihren Status basierend auf diesen Eigenschaften konfigurieren muss.  Details zu dieser Methode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dieses im React-Blog ver√∂ffentlichte Material besagt, dass die Verwendung dieser Methode in all den Situationen, in denen sie n√ºtzlich erscheint, alles andere als gerechtfertigt ist.  Die unsachgem√§√üe Verwendung kann zu verschiedenen Fehlern und zu einem R√ºckgang der Anwendungsleistung f√ºhren. Verwenden Sie sie daher mit Vorsicht.  Sie sollten nicht versuchen, Probleme mit seiner Hilfe zu l√∂sen, f√ºr deren L√∂sung es nicht vorgesehen ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist die</a> Dokumentation f√ºr diese Methode. <br><br>  Lassen Sie uns nun √ºber die Methode <code>getSnapshotBeforeUpdate()</code> sprechen.  So sieht seine Erkl√§rung im Klassenk√∂rper aus: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Es kann als Lebenszyklusmethode betrachtet werden, mit der Sie vor dem Aktualisieren eine Sicherungskopie der Komponenten erstellen k√∂nnen.  Es √§hnelt einer Momentaufnahme des Status einer Anwendung.  Es sollte beachtet werden, dass die Entwickler von React sagen, dass der Umfang dieser Methode begrenzt ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist die</a> Dokumentation daf√ºr. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir √ºber Methoden des Komponentenlebenszyklus gesprochen.  Wenn Sie die Entwicklung von React-Anwendungen vorantreiben, werden diese sicherlich n√ºtzlich sein.  In den weiteren Klassen dieses Kurses werden wir uns mit diesen Methoden befassen, insbesondere mit <code>componentDidMount()</code> .  N√§chstes Mal werden wir √ºber bedingtes Rendern sprechen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie React-Anwendungen professionell entwickeln, teilen Sie uns bitte mit, wie Sie Methoden f√ºr den Lebenszyklus von Komponenten verwenden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441578/">https://habr.com/ru/post/de441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441568/index.html">Python-Speicherverwaltung</a></li>
<li><a href="../de441570/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 353 (17. - 24. Februar 2019)</a></li>
<li><a href="../de441572/index.html">Frontend Weekly Digest (18. - 24. Februar 2019)</a></li>
<li><a href="../de441574/index.html">Docker lernen Teil 6: Arbeiten mit Daten</a></li>
<li><a href="../de441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../de441580/index.html">React Tutorial Teil 20: Erste Lektion zum bedingten Rendern</a></li>
<li><a href="../de441582/index.html">Optimierung des LQR-Steuerungssystems</a></li>
<li><a href="../de441584/index.html">PHP Digest Nr. 150 (11. - 25. Februar 2019)</a></li>
<li><a href="../de441586/index.html">Wie man Musik empfiehlt, die fast niemand geh√∂rt hat. Yandex-Bericht</a></li>
<li><a href="../de441590/index.html">Die Entwicklung der Cluster-Interaktion. Wie wir ActiveMQ und Hazelcast implementiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>