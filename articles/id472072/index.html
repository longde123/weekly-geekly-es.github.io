<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍣 🧚🏼 😕 PG12: Patch Lusin dari Postgres Professional 🖊️ ⏺️ 👩🏾‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sangat menyenangkan melihat nama-nama yang sudah dikenal pada daftar Ucapan Terima Kasih dari rilis resmi PostgreSQL 12. Kami memutuskan untuk menyatu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PG12: Patch Lusin dari Postgres Professional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/472072/">  <i>Sangat menyenangkan melihat nama-nama yang sudah dikenal pada daftar Ucapan Terima Kasih dari rilis resmi PostgreSQL 12. Kami memutuskan untuk menyatukan inovasi dan beberapa perbaikan bug yang dilakukan oleh pengembang kami.</i> <br><br><h3>  1. Dukungan JSONPath </h3><br>  (Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan Rilis,</a> ini terdengar seperti <i>Tambahkan dukungan untuk bahasa jalur SQL / JSON (Nikita Glukhov, Teodor Sigaev, Alexander Korotkov, Oleg Bartunov, Liudmila Mantrova)</i> <br><br>  Tambalan ini sendiri, fitur JSONPath, dan riwayat masalah dibahas secara rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel terpisah di</a> sini di hub  JSONPath adalah pencapaian utama Postgres Professional dan salah satu inovasi utama PostgreSQL 12 secara umum. <br><br>  Pada tahun 2014, A. Korotkov, O. Bartunov, dan F. Sigaev mengembangkan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsquery</a> , yang dimasukkan sebagai hasil dalam Postgres Pro Standard 9.5 (dan kemudian versi Standard and Enterprise).  Ini menyediakan fitur tambahan yang sangat luas untuk bekerja dengan json (b). <br><br>  Ketika standar SQL: 2016 muncul, ternyata semantiknya tidak begitu berbeda dengan kita dalam ekstensi jsquery.  Ada kemungkinan bahwa penulis standar bahkan melirik jsquery, menciptakan JSONPath.  Tim kami harus menerapkan sedikit berbeda dari apa yang sudah kami miliki dan, tentu saja, banyak hal baru juga. <br><br>  Meskipun tambalan khusus dengan fungsi belum dilakukan, tambalan JSONPath sudah memiliki fungsi utama untuk bekerja dengan JSON (B), misalnya: <br><br><pre><code class="pgsql hljs">jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'{"a": [1,2,3,4,5]}'</span></span>, <span class="hljs-string"><span class="hljs-string">'$.a[*] ? (@ &gt; 2)'</span></span>)  <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'{"a": [1,2,3,4,5]}'</span></span>, <span class="hljs-string"><span class="hljs-string">'$.a[*] ? (@ &gt; 5)'</span></span>)  <span class="hljs-number"><span class="hljs-number">0</span></span> </code> </pre> <br>  Selain itu, beberapa fungsi yang sudah bekerja dengan JSON sebelumnya <a href="">dioptimalkan</a> .  Ini berhasil dilakukan oleh Nikita Glukhov. <br><br>  Misalnya, operator <code>#&gt;&gt;</code> , yang sesuai dengan fungsi <code>jsonb_each_text()</code> dan <code>jsonb_array_elements_text()</code> , digunakan untuk dengan cepat mengkonversi JsonbValue ke teks, tetapi bekerja lambat dengan tipe lain.  Sekarang semuanya bekerja dengan cepat. <br><a name="habracut"></a><br><h3>  2. Dukungan untuk pencarian cepat tetangga terdekat dalam indeks SP-GiST (KNN) </h3><br>  <i>(Tambahkan dukungan untuk pencarian tetangga terdekat (KNN) indeks SP-GiST. Nikita Glukhov, Alexander Korotkov, Vlad Sterzhanov)</i> <br><br>  Nikita Glukhov dan Alexander Korotkov dari perusahaan kami melanjutkan pekerjaan yang dimulai oleh Vlad Sterzhanov dari Minsk (alias Quadrocube).  Postgres adalah DBMS pertama yang mencari tetangga terdekatnya - sebelumnya Oracle dan MS, dan dengan cara yang lebih langsung dan nyaman - dan ini adalah kelebihan dari Oleg Bartunov dan timnya.  Ide pencarian ini adalah dalam algoritma traversal pohon asli, yang dalam banyak kasus memberikan keuntungan besar.  Pencarian tetangga terdekat banyak digunakan di mana, tetapi dalam GIS itu sangat umum. <br><br>  Vlad membuat patch pencarian KNN untuk bekerja dengan indeks spasial SP-GiST untuk quad-tree, ketika pesawat dibagi menjadi kotak dengan ukuran tetap, dan untuk KD-tree, yaitu, pohon k-dimensional. <br><br>  Alexander Korotkov, mentor GSoC Vlad (Google Summer of Code), melanjutkan pengembangan dengan seorang rekan dari Postgres Professional Nikita Glukhov.  Fungsionalitas diperkaya dengan serius: caching data internal ditingkatkan ketika melintasi pohon, kelas operator untuk lingkaran dan poligon dengan pemesanan menurut jarak ditambahkan. <br><br>  Untuk menggunakan algoritma pencarian tetangga terdekat, cukup tulis <code>ORDER BY [,   ]</code> , dan kemudian optimizer akan secara otomatis menghubungkan algoritma ini.  Sebagai contoh <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> polygons <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> poly &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(0,0)'</span></span>;</code> </pre><br>  Patch oleh Nikita Glukhov dapat dilihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di github</a> . <br><br><h3>  3. Optimalisasi kunci untuk mempercepat penyisipan ke indeks B-Tree </h3><br>  <i>(Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan Rilis,</a> ini adalah Meningkatkan kecepatan penyisipan indeks btree dengan mengurangi overhead penguncian. Alexander Korotkov)</i> <br><br>  Alexander Korotkov, kepala arsitek sistem di Postgres Professional, berhasil menghasilkan algoritma penguncian yang lebih masuk akal ketika dimasukkan ke dalam indeks B-tree.  Keuntungan setelah menerapkan tambalan ini terlihat dalam kasus di mana penyisipan terjadi lebih atau kurang "berturut-turut".  Pengukuran pada server 72-core menunjukkan bahwa dalam hal ini keuntungannya mencapai 50%.  Dengan penyisipan kacau, keuntungan tidak begitu terlihat. <br><br><h3>  4. WAL Ekonomis </h3><br>  <i>(Kurangi penulisan WAL overhead pembuatan indeks GiST, GIN, dan SP-GiST. Anastasia Lubennikova, Andrey V. Lepikhov)</i> <br><br>  Rangkaian tambalan ini <a href="">mengurangi lalu lintas WAL yang</a> dihasilkan saat membuat indeks GiST, GIN, dan SP-GiST.  Sekarang Anda dapat login halaman indeks tersebut hanya sekali - pada akhirnya, ketika indeks sudah dibangun.  Dan jika terjadi kesalahan ketika membangun indeks entri dalam WAL, upaya yang gagal tidak akan muncul sama sekali.  Sebelumnya, ini hanya mungkin saat membuat B-tree dan RUM.  Tambalan menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAL umum</a> . <br><br>  Script <code>xlog</code> untuk memeriksa ukuran <code>xlog</code> .  Pengujian pada database IMDB (format JSON), di mana 4M + catatan menempati 4GB, menunjukkan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> imdb <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin(jb jsonb_path_ops);</code> </pre> <br>  cara lama dijalankan 205 detik, WAL 3,2 GB, dan algoritma baru memberi 133 detik, dan WAL 0,4 GB. <br><br><h3>  5. Optimalisasi pemindaian hanya indeks dalam banyak kolom. </h3><br>  <i>(Izinkan pemindaian hanya indeks menjadi lebih efisien pada indeks dengan banyak kolom. Konstantin Knizhnik)</i> <br><br>  Ketika menganalisis operasi database dari salah satu klien perusahaan kami, <a href="">ditemukan</a> bahwa permintaan yang sama dieksekusi dalam beberapa kasus lebih lama sebesar 25% dengan pemindaian hanya indeks daripada dengan pemindaian indeks (enable_indexonlyscan = off). <br>  Ini terjadi ketika SELECT dilakukan pada banyak bidang, yang sebagian besar dari jenis <code>bytea</code> , dan offset mereka tidak di-cache, karena bidang tersebut tidak memiliki offset tetap (lihat juga laporan oleh Nikolai Shaplov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“What's Inside It”</a> ).  Untuk membongkar atribut k-th, Anda harus membongkar k-1 sebelumnya.  Membongkar catatan dengan satu atribut memerlukan waktu O (N * N), di mana N adalah jumlah bidang.  25% ini sudah terjadi di 10 bidang. <br><br>  Konstantin Knizhnik menggunakan algoritma yang digunakan ketika bekerja dengan pinggul: ketika mengakses atribut k-th, k-1 sebelumnya diambil dan diingat, waktu tumbuh secara linier dengan jumlah bidang.  Setelah menerapkan tambalan, runtime dengan pemindaian indeks dan hanya pemindaian indeks praktis sama. <br><br><h3>  6. Kontrol dumping segmen WAL ke disk </h3><br>  <i>(Tambahkan acara tunggu untuk fsync dari segmen WAL. Konstantin Knizhnik)</i> <br><br>  Kernel PostgreSQL memonitor penulisan ke WAL, tetapi tidak memantau pembilasan segmen WAL dari memori ke disk, mis. <code>fsync</code> .  K. Knizhnik membuat tambalan yang menciptakan jenis acara baru, sekarang disebut WALSync (nama internal variabelnya adalah WAIT_EVENT_WAL_SYNC).  Anda dapat melihatnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">label acara PG</a> dengan penjelasan "Menunggu file WAL dibuang ke penyimpanan yang dapat diandalkan".  Masalah ini <a href="">dibahas</a> pada milis <i>peretas</i> . <br><br>  Berapa lama waktu reset biasanya tidak diketahui: PostgreSQL standar tidak tahu bagaimana menggabungkan statistik tersebut.  Tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi pg_wait_sampling yang</a> ditulis dalam Postgres Professional.  Itu dapat berbicara tentang acara apa yang dihabiskan Postgres.  Sekarang acara telah ditambahkan, Anda dapat mengikuti <code>fsync</code> . <br><br><h3>  7. Dukungan untuk bahasa baru dalam kamus stemmer </h3><br>  <i>(Perbarui kamus stemmer Snowball dengan dukungan untuk bahasa baru. Arthur Zakirov)</i> <br><br>  Karena konferensi Postgres diadakan di Nepal, jauh lebih alami untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambahkan</a> bahasa Nepal ke dalam basis data!  Ini dilakukan.  Berkat upaya Arthur Zakirov, sekarang Anda dapat menggunakan kamus stemming Nepal di <i>Snowball</i> . <br><br><h3>  8. Fungsi to_timestamp () / to_date () menjadi lebih toleran terhadap data </h3><br>  <i>(Sesuaikan to_timestamp () / to_date () berfungsi untuk lebih memaafkan ketidakcocokan templat, Artur Zakirov, Alexander Korotkov, Liudmila Mantrova)</i> <br><br>  Fungsi <code>to_timestamp()</code> tidak berfungsi jika string format diproses dengan spasi tambahan.  Diskusi bug di <code>to_timestamp()</code> menghasilkan <a href="">diskusi panjang</a> tentang perilaku fungsi <code>to_timestamp()</code> dan, pada saat yang sama, <code>to_date()</code> dianggap benar.  Untuk keuntungan semua orang, kedua fungsi menjadi lebih toleran terhadap ruang ekstra di baris format dan jalur input. <br><br><h3>  9. Log dapat diputar melalui pg_ctl </h3><br>  <i>(Izinkan kontrol rotasi file log melalui pg_ctl. Kyotaro Horiguchi, Alexander Kuzmenkov, Alexander Korotkov)</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dengan kata lain,</a> utilitas <code>pg_ctl</code> telah memperoleh opsi baru: <br><br><pre> <code class="plaintext hljs">pg_ctl logrotate [-D _] [-s]</code> </pre> <br>  Ketika perintah ini dijalankan, server akan beralih ke file log baru atau membuka kembali yang sudah ada, tergantung pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfigurasi logging</a> .  Ini mungkin diperlukan dalam situasi darurat, terutama ketika file log yang besar dan cepat tumbuh perlu, misalnya, ditransfer untuk diagnosis. <br><br><h3>  10. Kemampuan untuk membuat jenis tabel baru (penyimpanan Pluggable) </h3><br>  <i>(Tambahkan perintah CREATE ACCESS METHOD untuk membuat jenis tabel baru. Andres Freund, Haribabu Kommi, Álvaro Herrera, Alexander Korotkov, Dmitry Dolgov)</i> <br><br>  Tambalan penting ini merupakan bagian penting dari infrastruktur API Penyimpanan Pluggable, karenanya komposisi internasional pengembang tempel.  Perintah CREATE ACCESS METHOD telah berjalan di Postgres sejak versi 9.6.  Tetapi sampai tanggal 12, Anda hanya bisa membuat metode akses indeks.  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk versi ke-11</a> : <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ACCESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">METHOD</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> __ <span class="hljs-keyword"><span class="hljs-keyword">HANDLER</span></span> _ &lt; ... &gt; __       .      <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>.</code> </pre> <br>  Dan dalam dokumentasi untuk tanggal 12 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah dibaca</a> : <i>saat ini hanya TABLE dan INDEX yang didukung.</i>  Kebetulan, dalam perintah CREATE ACCESS METHOD ke-11 disediakan oleh ekstensi Postgres Pro, dan pada tanggal 12 sudah PostgreSQL. <br><br>  Eksekusi operasi tergantung pada jenis metode akses;  jika ini adalah tipe TABLE, maka <code>table_am_handler</code> akan <code>table_am_handler</code> , dan jika ini adalah tipe INDEX, maka <code>index_am_handler</code> (sebelumnya: untuk metode akses tipe INDEX, ia harus <code>index_am_handler</code> ).  Seluruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab telah muncul dalam dokumentasi</a> tentang metode tabel. <br><br>  Saat membuat tabel, sekarang Anda dapat menentukan tipenya: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> [ [ <span class="hljs-keyword"><span class="hljs-keyword">GLOBAL</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">LOCAL</span></span> ] { <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">TEMP</span></span> } | <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> ] _ ( [ &lt; ... &gt; [ <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span>  ]</code> </pre> <br>  <i>metode</i> ini bertipe TABEL - ini adalah referensi untuk Penyimpanan Pluggable.  Sekarang <code>heap</code> secara default, dan sebelum yang lain, pada kenyataannya, itu tidak.  Tentang kelas operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br><br> <code>default_table_access_method (string)</code> <br> <br>  Parameter ini menetapkan metode akses tabel default yang akan digunakan saat membuat tabel atau tampilan terwujud jika metode akses tidak ditentukan secara spesifik dalam perintah CREATE, atau ketika menjalankan perintah SELECT ... INTO, di mana metode akses tidak dapat ditetapkan secara eksplisit.  Nilai defaultnya adalah <code>heap</code> .  Diskusi besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di peretas</a> membantu mengeluarkan detailnya. <br><br>  Hingga saat ini, kami berbicara tentang inovasi.  Tetapi perbaikan bug juga menggerogoti sumber daya waktu para programmer.  Yang utama adalah: <br><br><h3>  11. Bug: kesalahan di salah satu struktur </h3><br>  <i>Kutipan tambahan_all_identifiers di _dumpOptions.</i>  <i>Arthur Zakirov)</i> <br><br>  Secara umum, tidak ada yang istimewa, kesalahan ditemukan di salah satu struktur yang menggunakan <code>pg_dump</code> - itu dilewatkan oleh kompiler.  Tapi Bruce Momjyan sendiri <a href="">memuji</a> penemuan itu. <br><br>  Masalah lain dengan <code>DumpOptions</code> dapat ditemukan di <a href="">sini</a> . <br><br><h3>  12. Bug dalam replikasi: </h3><br>  <i>(xlogreader: jangan membaca blok file dua kali. Arthur Zakirov)</i> <br><br>  Karyawan lain dari perusahaan kami, pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_probackup</a> , Grigory Smolkin, menemukan bahwa salah satu utilitas kami melambat ketika xlogreader membaca arsip zlib.  Ternyata kadang-kadang dia membaca blok file WAL dua kali. <br><br>  Jika arsip dibaca tidak konsisten, maka kinerjanya buruk.  Pembacaan berulang blok selalu tidak konsisten, karena Anda harus kembali ke posisi yang dilewati dengan memanggil fungsi <code>gzseek()</code> .  <a href="">Sekarang</a> membaca ulang yang tidak perlu tidak terjadi. <br><br>  <i>PS Saya tidak akan menyembunyikan: selusin tambalan (tepatnya serangkaian tambalan) tidak hanya kebetulan kebetulan dengan nomor versi Postgres.</i>  <i>Daftarnya bisa saja di bawah lusinan atau di atas lusinan.</i>  <i>Saya pikir itu akan menjadi lebih indah, dan kecantikan adalah sebagian dari mesin pemrograman, belum lagi area lain dari aktivitas manusia.</i> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472072/">https://habr.com/ru/post/id472072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472054/index.html">Penyelenggara dan asisten pengajar tentang program online CS Center</a></li>
<li><a href="../id472060/index.html">Polisi Jerman menyerbu bunker militer, yang menampung pusat data yang baru diumumkan</a></li>
<li><a href="../id472062/index.html">Pemantauan + pengujian stres = perkiraan dan tidak ada kegagalan</a></li>
<li><a href="../id472064/index.html">Tarik otomatis + git di kluster mesin virtual di cloud</a></li>
<li><a href="../id472068/index.html">Menggunakan NVME SSD sebagai drive sistem pada komputer dengan BIOS lama dan OS Linux</a></li>
<li><a href="../id472076/index.html">Buku "Java for all"</a></li>
<li><a href="../id472078/index.html">Risiko Perbankan Terbuka</a></li>
<li><a href="../id472084/index.html">Kerentanan Smartphone</a></li>
<li><a href="../id472086/index.html">Menggunakan hukum psikologi gestalt dalam desain antarmuka pengguna</a></li>
<li><a href="../id472088/index.html">Bagaimana kami memilih ServiceDesk. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>