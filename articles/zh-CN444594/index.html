<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 ⛹🏻 ↪️ 大o 🤺 💅🏿 👏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意事项 缩写翻译，而不是用您自己的话说。 
 UPD：如评论中所述，示例并不完美。 作者并不是在寻找解决该问题的最佳方法，他的目的是解释“指尖”算法的复杂性。 

 需要使用大O表示法来描述算法的复杂性。 为此，使用了时间概念。 对于许多人来说，这个话题很可怕，程序员避免谈论“订货时间N”是很常见...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>大o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>注意事项</u></i>  <i>缩写翻译，而不是用您自己的话说。</i> <i><br></i>  <i>UPD：如评论中所述，示例并不完美。</i>  <i>作者并不是在寻找解决该问题的最佳方法，他的目的是解释“指尖”算法的复杂性。</i> <br><br> 需要使用大O表示法来描述算法的复杂性。 为此，使用了时间概念。 对于许多人来说，这个话题很可怕，程序员避免谈论“订货时间N”是很常见的事情。 <br><br> 如果您能够按照Big O评估代码，那么您很可能被视为“聪明人”。 而且很可能您将进行下一次面试。 您是否会被问到是否有可能将任何代码的复杂度降低到n log n而不是n ^ 2的问题。 <br><br><h2> 资料结构 </h2><br> 数据结构的选择取决于特定的任务：取决于数据的类型及其处理算法。 为某些类型的算法创建了各种数据结构（.NET或Java或Elixir）。 <br><br> 通常，选择一种或另一种结构，我们只是复制普遍接受的解决方案。 在大多数情况下，这就足够了。 但是实际上，如果不了解算法的复杂性，我们就无法做出明智的选择。 数据结构的主题只有在算法复杂之后才能通过。 <br><br> 在这里，我们将仅使用数字数组（就像在采访中一样）。  JavaScript示例。 <br><a name="habracut"></a><br><h2> 让我们从最简单的开始：O（1） </h2><br> 取一个由5个数字组成的数组： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br> 假设您需要获取第一个元素。 我们为此使用索引： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br> 这个算法有多复杂？ 我们可以说：“一点也不复杂-只取数组的第一个元素。” 的确如此，但是根据输入所执行的操作数量（达到输入结果）来描述复杂性更为正确。 <br><br> 换句话说：随着输入参数数量的增加，多少操作将增加。 <br><br> 在我们的示例中，有5个输入参数，因为数组中有5个元素。 要获得结果，您需要执行一项操作（按索引获取一个元素）。 如果数组中有100个元素，将需要执行多少个操作？ 还是1000？ 还是十万？ 一样，只需要一个操作。 <br><br> 即：“对所有可能的输入数据执行一次操作”-O（1）。 <br><br>  O（1）可以理解为“ 1阶复杂度”（1阶）或“算法以恒定/恒定时间运行”（恒定时间）。 <br><br> 您已经猜到O（1）算法是最有效的。 <br><br><h2> 迭代和“订购时间n”：O（n） </h2><br> 现在，让我们找到数组元素的总和： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br> 我们再次问自己：我们需要多少个输入操作？ 在这里您需要对所有元素进行排序，即 每个元素上的操作。 数组越大，操作越多。 <br><br> 使用大O表示法：O（n）或“ n阶（n阶）的复杂度”。 同样，这种算法被称为“线性”算法或“线性缩放”算法。 <br><br><h3> 分析方法 </h3><br> 我们可以使求和效率更高吗？ 通常不会。 而且，如果我们知道该数组保证从1开始，是否排序且没有间隙？ 然后我们可以应用公式S = n（n + 1）/ 2（其中n是数组的最后一个元素）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br> 这样的算法比O（n）有效得多，而且，它是在“恒定/恒定时间”执行的，即 它是O（1）。 <br><br> 实际上，有多个操作：您需要获取数组的长度，获取最后一个元素，执行乘法和除法。 那不是O（3）还是什么？ 用大O表示法，实际的步数并不重要，算法在恒定时间内运行很重要。 <br><br> 恒定时间算法始终为O（1）。 与线性算法相同，实际上，运算可以是O（n + 5），在Big O中，符号是O（n）。 <br><br><h2> 不是最佳解决方案：O（n ^ 2） </h2><br> 让我们编写一个检查数组是否重复的函数。 嵌套循环解决方案： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br> 我们已经知道数组迭代为O（n）。 我们有一个嵌套循环，对于每个元素，我们都会再次进行迭代-即  O（n ^ 2）或“ n阶复杂度”。 <br><br> 在同一集合上具有嵌套循环的算法始终为O（n ^ 2）。 <br><br><h2>  “ log n的顺序的复杂度”：O（log n） </h2><br> 在上面的示例中，嵌套循环本身（如果不考虑嵌套的话）的复杂度为O（n），因为 它是数组元素的枚举。 一旦找到所需元素，即该循环结束。 实际上，并非所有元素都会被列举。 但是Big O符号总是考虑最坏的情况-您正在寻找的项目可能是最后一个。 <br><br> 在这里，嵌套循环用于搜索数组中的给定元素。 在某些条件下，可以优化数组中元素的搜索-比线性O（n）更好。 <br><br> 让数组排序。 然后，我们可以使用二进制搜索算法：将数组分为两半，丢弃不必要的部分，再将剩余部分分为两部分，依此类推，直到找到所需的值。 这种算法称为分而治之分而治之。 <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="二进制搜索"><br><br> 该算法基于对数。 <br><br><h2> 对数快速概述 </h2><br> 考虑一个例子，x等于什么？ <br><br>  x ^ 3 = 8 <br><br> 我们需要取8的立方根-这将是2。现在更加困难 <br><br>  2 ^ x = 512 <br><br> 使用对数，问题可以写成 <br><br>  log2（512）= x <br><br>  “ 512的以2为底的对数是x。” 注意“基数2”，即 我们认为是二分之一-您需要将2乘以多少才能得到512。 <br><br> 在二分查找算法中，每一步都将数组分为两部分。 <br><br>  <i><u>我的加法。</u></i>  <i>即</i>  <i>在最坏的情况下，我们会进行尽可能多的操作，将数组分为两部分。</i>  <i>例如，我们可以将4个元素的数组分成两部分多少次？</i>  <i>2次</i>  <i>还有8个元素的数组？</i>  <i>3次</i>  <i>即</i>  <i>除法/运算数= log2（n）（其中n是数组中元素的数目）。</i> <i><br><br></i>  <i>事实证明，操作数对输入元素数的依赖性描述为log2（n）</i> <i><br></i> <br><br> 因此，使用Big O表示法，二进制搜索算法的复杂度为O（log n）。 <br><br><h2> 将O（n ^ 2）提高到O（n log n） </h2><br> 让我们回到检查数组是否重复的任务。 我们遍历了数组的所有元素，并再次遍历了每个元素。 他们在O（n）内做O（n），即  O（n * n）或O（n ^ 2）。 <br><br> 我们可以用二进制搜索*代替嵌套循环。 即 我们只需要遍历O（n）的所有元素，在内部进行O（log n）。 结果是O（n * log n）或O（n log n）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  *注意，以避免<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">压印</a> 。 使用二进制搜索来检查数组是否重复是一个不好的解决方案。 仅以Big O术语显示了如何评估上面代码清单中所示算法的复杂性。 对于本文而言，好的算法或不好的算法并不重要；可见性很重要。 <br><br><h2> 用大O来思考 </h2><br><ul><li> 获得收集项的结果为O（1）。 无论是通过数组中的索引获取还是通过Big O表示法的字典中的键获取，都将为O（1） </li><li> 对集合进行迭代为O（n） </li><li> 同一集合上的嵌套循环为O（n ^ 2） </li><li> 分而治之总是O（log n） </li><li> 使用Divide和Conquer的迭代为O（n log n） </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444594/">https://habr.com/ru/post/zh-CN444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444582/index.html">Palo Alto Networks NGFW安全策略优化器</a></li>
<li><a href="../zh-CN444584/index.html">Android将为欧洲用户提供首选的浏览器和搜索引擎</a></li>
<li><a href="../zh-CN444586/index.html">俄罗斯互联网网段架构</a></li>
<li><a href="../zh-CN444590/index.html">远程医疗公司的数据泄漏（可能已经发生但没有发生）</a></li>
<li><a href="../zh-CN444592/index.html">美国军方计划使用新型外骨骼</a></li>
<li><a href="../zh-CN444596/index.html">碘化物：Mozilla互动科学编辑器</a></li>
<li><a href="../zh-CN444598/index.html">CD已经40岁了，他已经死了（是吗？）</a></li>
<li><a href="../zh-CN444600/index.html">14个无头cms的评论2019</a></li>
<li><a href="../zh-CN444602/index.html">用C ++和C封装</a></li>
<li><a href="../zh-CN444610/index.html">实时统计和监视PHP脚本。 ClickHouse和Grafana去帮助Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>