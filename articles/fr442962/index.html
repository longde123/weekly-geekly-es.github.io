<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍⚖️ ⛎ 🤼 Un autre article sur les vies à Rust 👐🏿 🎄 👂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les premiers mois d'un émeutier novice se résument généralement à un en-tête sur le concept de vie et de possession. Certaines personnes se décomposen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un autre article sur les vies à Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442962/"><p> Les premiers mois d'un émeutier novice se résument généralement à un en-tête sur le concept de vie et de possession.  Certaines personnes se décomposent à ce sujet, mais pour ceux qui ont pu survivre, cela ne semble plus inhabituel ou faux.  Je décrirai les points clés qui, il me semble, ont aidé à s'adapter plus rapidement et mieux au concept de vie et de biens. <img src="https://habrastorage.org/webt/vm/qw/p5/vmqwp5m_uwm9ghbbtcm5be3xqre.png" align="right"></p><br><p>  Bien sûr, les nouvelles officielles sont plus complètes et plus détaillées, mais elles nécessitent également plus de temps et de patience pour bien comprendre et absorber toutes les informations.  J'ai essayé d'éviter un grand nombre de détails et de tout présenter par ordre croissant de complexité, dans le but de rendre cet article plus accessible à ceux qui ont juste commencé à regarder le rast ou qui n'ont pas vraiment compris les premiers moments du babillard officiel. </p><br><p>  Cela m'a également fait écrire que, par exemple, dans les monades, vous pouvez trouver du matériel de formation officiel, mais ils ne sont pas toujours bien compris, et la compréhension n'apparaît qu'après avoir lu quelque chose comme «une autre introduction» sur ce sujet. </p><br><h3 id="vremya-zhizni-lifetime">  À vie </h3><br><p>  Nous devons d'abord nous familiariser avec deux choses: la fin du bloc et le déplacement de la valeur vers un autre bloc.  Plus tard, nous commencerons à compliquer les choses en ajoutant «prêt», «mutabilité» et «mutabilité cachée». </p><a name="habracut"></a><br><p>  Tout d'abord, la durée de vie d'une valeur est déterminée par le segment suivant: </p><br><ul><li>  Le début de la vie: créer de la valeur.  Ceci est courant pour la plupart des langages de programmation, il ne supporte donc aucune charge inhabituelle. </li><li>  La fin de vie.  C'est là que Rust appellera automatiquement le destructeur et oubliera la valeur.  Dans un bloc de portée, cela se produira à la fin de ce bloc sans bouger.  C'est le suivi mental de la fin de vie qui est, à mon avis, la clé d'une interaction réussie avec le emprunteur. </li></ul><cut></cut><br><p>  J'ajouterai un détail qui peut être utile: s'il y a plusieurs valeurs dans la portée, elles seront détruites dans l'ordre inverse de la création. </p><br><p>  Un autre point: je vais créer une chaîne, car elle n'a pas de marqueur de copie, et les valeurs qui ont ce marqueur ne bougent pas mais sont copiées, ce qui est considéré comme une opération plutôt bon marché, mais modifie le comportement du déplacement (et facilite le travail avec les types primitifs), mais plus à ce sujet plus tard. </p><br><p>  Des exemples peuvent être exécutés ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.rust-lang.org/</a> </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { { <span class="hljs-comment"><span class="hljs-comment">//    let a = "a".to_string(); // &lt;-   "a" let b = 100; // &lt;-   "b" // &lt;-   b // &lt;-   a } //    //     "a"  "b" }</span></span></code> </pre> <br><p>  Avec un bloc simple, tout est relativement simple, l'étape suivante se produit lorsque nous utilisons des choses apparemment simples comme les fonctions et les fermetures: </p><br><h3 id="peremeschenie">  Déménagement </h3><br><p>  Ajoutez un concept comme déplacer une valeur.  En termes simples, «déplacer» signifie que le bloc actuel n'est plus intéressé par le sort de la valeur et qu'il l'oublie, et son destin est transféré vers un autre bloc, par exemple, vers une autre fonction, ou vers une fermeture, ou simplement vers une autre valeur. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>&lt;T: std::fmt::Display&gt;(x: T) { <span class="hljs-comment"><span class="hljs-comment">//   ,         . println!("{}", x); // &lt;-  ,   "a",    . } fn main() { let a = "a".to_string(); // "a"    let b = 2; f(a); //   "a"  f //        f(a) -   ,    "a"        .    a  b,    ,      Copy   . // "b" . }</span></span></code> </pre> <br><p>  Avec fermetures. </p><br><p>  Pour que la fermeture déplace la valeur capturée vers son bloc, le mot-clé move est utilisé, si vous n'écrivez pas move, la valeur est empruntée, sur laquelle j'écrirai très bientôt. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let b = 2; let f_1 = move || {println!("{}", a)}; //   "a" //    "a"    . // let f_2 = move || {println!("{}", a)}; f_1(); }</span></span></code> </pre> <br><p>  Vous pouvez vous déplacer à la fois vers la fonction et depuis la fonction ou vers une autre valeur. </p><br><p>  Cet exemple montre comment suivre les mouvements des valeurs afin de vivre en paix avec le emprunteur. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { x + <span class="hljs-string"><span class="hljs-string">" and x"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    x   +,     . //  +   String,    . } fn main() { let a = "a".to_string(); //  "a" let b = f(a); //  "a"  "f",  f     b. println!("{}", b); // "a"   . }</span></span></code> </pre> <br><h3 id="odalzhivanie">  Prêt </h3><br><p>  Nous introduisons ce nouveau concept: contrairement au déplacement, cela signifie que le bloc actuel réserve le contrôle de la valeur, il permet simplement à l'autre bloc d'utiliser sa valeur. </p><br><p>  Je note que l'emprunt a également lieu là où il s'est terminé, ce qui n'est pas très important dans ces exemples, mais apparaîtra dans le paragraphe suivant. </p><br><p>  Remarque: je n'écrirai pas sur la façon de spécifier la durée de vie directement dans la fonction, car la rouille moderne le fait automatiquement mieux que par le passé, et la divulgation de tout cela est de quelques pages de plus. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   &amp;,    . println!("{}", x); // &lt;-  ,  "x"     } fn main() { let a = "a".to_string(); // "a"    f(&amp;a); //   "a"  f //   f(&amp;a); //    -  . println!("{}", a); //   // "a"  . }</span></span></code> </pre> <br><p>  Avec des fermetures similaires: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.push_str("and x"); //   "a" let f_2 = || a.push_str("and x"); //   f_1(); f_2(); println!("{}", a); // "a"  . }</span></span></code> </pre> <br><p>  En fait, dans la plupart de ces constructions simples, l'utilisateur a juste besoin de décider où il veut mettre fin à la vie de la valeur: à la fin du bloc en cours et en le prêtant à certaines fonctions, ou, si nous savons que nous n'avons plus besoin de la valeur, puis déplacez-le vers la fonction à la fin par lequel il sera lui-même détruit, plus nous libérerons rapidement la mémoire, mais la valeur ne sera plus disponible dans le bloc actuel. </p><br><h3 id="mutabelnost">  Mutabilité </h3><br><p>  Dans le rasta, comme par exemple dans le kotlin, il y a une division en valeurs mutables et non stables.  Mais le problème se pose que la mutabilité a un effet sur les prêts: <br>  Vous pouvez emprunter plusieurs fois une valeur non stable et une valeur mutable ne peut être empruntée mutuellement qu'une seule fois.  Vous ne pouvez pas muter une valeur déjà empruntée précédemment. </p><br><p>  Un exemple qui n'est pas lié aux précédents, lorsque ce concept nous sauve des problèmes en interdisant les prêts simultanés mutables et non stables: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.chars() { <span class="hljs-comment"><span class="hljs-comment">//   a.push_str(" and "); //  .  . a.push(x); } }</span></span></code> </pre> <br><p>  Ici, il est déjà nécessaire de faire le plein de diverses astuces pour satisfaire, pour la plupart, les justes revendications du rasta.  Dans l'exemple ci-dessus, le plus simple serait de cloner "a" -&gt; le clone aura un prêt non stable et ne sera pas lié au "a" d'origine. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.clone().chars() { <span class="hljs-comment"><span class="hljs-comment">//  ,   . a.push_str(" and "); //  .      -   .</span></span></code> </pre> <br><p>  Mais je ferais mieux de revenir à nos exemples afin de maintenir la cohérence.  Nous devons changer "a" et nous ne pouvons pas le faire. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let mut f_1 = || a.push_str(" and x"); //   "a".   - ,  mut  mut. //      ,   f_1  . let mut f_2 = || a.push_str(" and y"); //     : second mutable borrow occurs here f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><h3 id="skrytoe-mutirovanie">  Mutation cachée </h3><br><p>  Théoriquement, une fermeture peut être transmise à une fonction qui traite, par exemple, de manière asynchrone dans un autre thread, puis nous aurions vraiment des problèmes, mais dans ce cas, le emprunteur est réassuré, bien que cela n'annule pas le fait que nous devons en quelque sorte l'accepter. . </p><br><p>  Conclusion: nous avons besoin de deux emprunts mutants, mais le rast ne permet qu'une seule chose, mais les inventeurs rusés du rasta proposent une «mutation cachée»: RefCell. </p><br><p>  RefCell - ce que nous encapsulons dans RefCell - le raster le considère nemable, cependant, en utilisant la fonction borrow_mut (), nous pouvons temporairement extraire un lien mutable par lequel il peut changer la valeur, <strong>mais il y a une nuance importante</strong> : le lien ne peut être obtenu que lorsque RefCell au moment de l'exécution s'assure qu'il n'y en a pas d'autres prêts actifs, sinon il lancera la panique ou retournera une erreur si try_borrow_mut () est utilisé.  C'est-à-dire  ici, la croissance donne tous les soucis du prêt aux soins de l'utilisateur, et il doit s'assurer lui-même qu'il n'emprunte pas la valeur à plusieurs endroits à la fois. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = RefCell::new(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string()); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.borrow_mut().push_str(" and x"); //    "a" let f_2 = || a.borrow_mut().push_str(" and y"); //    f_1(); //      a.borrow_mut() ,           mut    . f_2(); //   . println!("{}", a.borrow()); //         . }</span></span></code> </pre> <br><h3 id="schyotchik-ssylok-rc">  Compteur de liaison Rc </h3><br><p>  Cette construction est familière dans de nombreuses langues et est utilisée dans rast, lorsque, par exemple, nous ne pouvons pas emprunter une valeur pour une raison quelconque, et qu'il est nécessaire d'avoir plusieurs valeurs de référence pour une seule valeur.  Rc, comme son nom l'indique, est simplement un compteur de référence qui possède une valeur, il peut emprunter des liens non fiables, compter leur nombre et dès que leur nombre est réinitialisé, il détruit la valeur et lui-même.  Il s'avère que Rc permet, pour ainsi dire, d'étendre secrètement la durée de vie de la valeur qui y est contenue. </p><br><p>  J'ajouterai que le rast peut automatiquement faire le deref pour les structures pour lesquelles il est défini, ce qui signifie que pour travailler avec Rc, en règle générale, vous n'avez besoin d'aucune extraction supplémentaire de la valeur interne et nous travaillons simplement avec Rc comme avec la valeur à l'intérieur. </p><br><p>  Ici, un exemple simple a été pensé un peu dur, essayons d'émuler que la fermeture de l'exemple ci-dessus ne veut pas accepter &amp; T ou &amp; String, mais veut juste String: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  String,    &amp;String println!("{}", x); } fn main() { let a = "a".to_string(); let f_1 = move || f(a); //   move,    ... let f_2 = move || f(a); // ...     ,           f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><p>  Ce problème serait facilement résolu si nous pouvions changer la fonction en <code>fn f(x: &amp;String)</code> (ou &amp; str), mais imaginons que pour une raison quelconque nous ne pouvons pas utiliser &amp; </p><br><p>  Nous utilisons Rc </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Rc println!("{}", x); //     ,  println          ,           ,       ,    . } fn main() { let a_rc = Rc::new("a".to_string()); //  Rc   let a_ref_1 = a.clone(); //   -,  . let a_ref_2 = a.clone(); //   let f_1 = move || f(a_ref_1); //      - let f_2 = move || f(a_ref_2); //  f_1(); f_2(); println!("{}", a_rc); //     Rc  . //    a_rc       . }</span></span></code> </pre> <br><p>  J'ajouterai le dernier exemple, car l'une des paires de conteneurs les plus fréquentes que l'on peut trouver est Rc &lt;RefCell&gt; <br></p><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;) { x.borrow_mut().push_str(<span class="hljs-string"><span class="hljs-string">" and x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,       ,   . } fn main() { let a = Rc::new(RefCell::new("a".to_string())); //      let a_ref_1 = a.clone(); let a_ref_2 = a.clone(); let f_1 = move || f(a_ref_1); let f_2 = move || f(a_ref_2); f_1(); f_2(); println!("{}", a.borrow()); // Rc   ,   RefCell   }</span></span></code> </pre> <br><p>  De plus, il serait logique de déplacer ce didacticiel vers un analogue sans fil de Rc-Arc, puis de continuer à propos de Mutex, mais vous ne parlerez pas de la sécurité des threads et du emprunteur dans un paragraphe, et il n'est pas clair si ce type d'article est nécessaire du tout, car il existe un thread officiel.  Je conclus donc. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442962/">https://habr.com/ru/post/fr442962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442948/index.html">Rejeté par l'automatisation</a></li>
<li><a href="../fr442950/index.html">Donnez votre avis sur Cutra Wonder Cutter</a></li>
<li><a href="../fr442952/index.html">Nouveau Hackathon à Tinkoff.ru</a></li>
<li><a href="../fr442954/index.html">Utilisation de SQLite dans Unity (Unity + SQLite)</a></li>
<li><a href="../fr442958/index.html">Nikita Shamgunov a expliqué à The Bell avoir travaillé avec Microsoft et Facebook, parler avec Gates et la base de données MemSQL</a></li>
<li><a href="../fr442964/index.html">L'art d'analyser ou de bricoler DOM</a></li>
<li><a href="../fr442966/index.html">Le Bitcoin pour Starbucks Coffee pose d'importants problèmes de déclaration de revenus</a></li>
<li><a href="../fr442968/index.html">Obtention d'un CPE pour prendre en charge les certifications professionnelles (étude de cas ISACA)</a></li>
<li><a href="../fr442970/index.html">Jeu de société pour apprendre les bases des circuits électriques. Pourquoi pas?</a></li>
<li><a href="../fr442974/index.html">Le projet de loi sur la lutte contre les fausses informations adopté en troisième lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>