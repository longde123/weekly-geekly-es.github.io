<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’› ğŸ¤¶ğŸ¾ ğŸ¤´ğŸ¼ Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA ğŸšº ğŸ—ï¸ ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, dalam artikel pertama dari siklus dikatakan bahwa yang terbaik adalah menggunakan sistem prosesor untuk mengontrol peralatan kami diimplementasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454938/"><img src="https://habrastorage.org/webt/ze/eo/9f/zeeo9fw5rmqp8pk7lsmr0cytbve.jpeg"><br><br>  Jadi, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama dari siklus</a> dikatakan bahwa yang terbaik adalah menggunakan sistem prosesor untuk mengontrol peralatan kami diimplementasikan menggunakan FPGA untuk kompleks Redd, setelah itu ditunjukkan pada artikel pertama dan kedua bagaimana membuat sistem ini.  Ya, sudah selesai, kita bahkan dapat memilih beberapa kernel yang sudah jadi dari daftar untuk memasukkannya ke dalamnya, tetapi tujuan utamanya adalah mengelola kernel kustom kita sendiri.  Waktunya telah tiba untuk mempertimbangkan bagaimana memasukkan kernel yang sewenang-wenang dalam sistem prosesor. <br><a name="habracut"></a><br>  Semua artikel siklus: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program</a> <br><br>  Untuk memahami teori hari ini, Anda harus mencari dan mengunduh dokumen <b>Spesifikasi Antarmuka Avalon</b> , karena bus <b>Avalon</b> adalah bus dasar untuk sistem NIOS II.  Saya akan merujuk pada bagian, tabel dan gambar untuk revisi dokumen 26 September 2018. <br><br>  Kami membuka bagian 3 yang ditujukan untuk Memory Mapped Interfaces, atau lebih tepatnya - 3.2.  Tabel 9 mencantumkan sinyal bus.  Harap dicatat bahwa semua sinyal ini adalah opsional.  Saya tidak menemukan sinyal tunggal yang memiliki "Ya" di kolom Diperlukan.  Kami mungkin tidak meneruskan sinyal ini atau itu ke perangkat kami.  Oleh karena itu, dalam kasus yang paling sederhana, bus sangat sederhana untuk diimplementasikan.  Awal tabel terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/qj/et/kn/qjetkngv8gubiwwtqtx8atvab7c.png"><br><br>  Seperti yang Anda lihat, semua sinyal dijelaskan dengan sangat baik (kecuali bahwa ini dilakukan dalam bahasa Inggris).  Di bawah ini adalah bagan waktu untuk berbagai kasus.  Kasus yang paling sederhana tidak menimbulkan pertanyaan.  Sekarang saya akan mengambil grafik waktu dari dokumen dan mencakup beberapa baris dengan isian transparan (semuanya opsional, kami berhak mengecualikan salah satu pertimbangan). <br><br><img src="https://habrastorage.org/webt/q4/oz/w_/q4ozw_efgf6v6adbdhnkdeacply.png"><br><br>  Menakutkan  Tapi semuanya sederhana: kita diberi alamat dan strobo <b>baca</b> , kita harus mengatur data di bus readdata.  Dan sebaliknya: kita diberi alamat, data pada bus writedata dan strobo tulis, dan kita harus mengambil data.  Sama sekali tidak menakutkan, bus sinkron yang khas. <br><br>  Baris byteenable rahasia diperlukan untuk kasus ketika akses memori bukan kata-kata 32-bit.  Ini sangat penting ketika kita mendesain kernel universal.  Tetapi ketika kita merancang inti satu hari, kita cukup menulis dalam dokumen tentang inti ini (saya adalah lawan dari tanda di kepala saya, tetapi seseorang dapat membatasi itu untuk ini) bahwa kita perlu menggunakan kata-kata 32-bit dan hanya itu.  Nah, dan sinyal <b>respon</b> , itu sangat istimewa, dan itu tidak menarik bagi kita pada prinsipnya. <br><br>  Terkadang penting bahwa ketika peralatan tidak siap, adalah mungkin untuk menunda pengoperasian bus selama beberapa siklus jam.  Dalam hal ini, sinyal <b>WaitRequest</b> harus ditambahkan.  Bagan waktu akan berubah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/sy/hr/lf/syhrlf64dvm-zrr262xvveicea4.png"><br><br>  Sementara <b>WaitRequest</b> dikokang, penyihir tahu bahwa perangkat kami sedang sibuk.  Hati-hati jika sinyal ini tidak diatur ulang, seluruh sistem akan "membeku" saat ditangani, jadi hanya reboot dari FPGA yang dapat mengatur ulang.  JTAG hang dengan sistem.  Terakhir kali saya mengamati fenomena ini adalah dalam persiapan artikel ini, jadi ingatannya masih hidup. <br><br>  Lebih lanjut dalam dokumen perusahaan, kasus-kasus yang lebih produktif tentang perpipaan data dan transaksi batch dipertimbangkan, tetapi tugas artikel ini bukan untuk mempertimbangkan semua opsi yang mungkin, tetapi untuk menunjukkan kepada pembaca cara untuk bekerja, menekankan bahwa semua ini sama sekali tidak menakutkan, jadi kami akan membatasi diri kami pada dua opsi sederhana ini. <br><br>  Mari kita merancang beberapa perangkat sederhana yang secara berkala tidak tersedia di bus.  Hal pertama yang terlintas dalam pikiran adalah antarmuka serial.  Saat transmisi sedang berlangsung, kami akan membuat sistem menunggu.  Dan dalam kehidupan, saya sangat menyarankan untuk tidak melakukan ini: prosesor akan berhenti sampai akhir transaksi yang sibuk, tetapi ini adalah kasus yang ideal untuk sebuah artikel, karena kode implementasi akan dapat dimengerti dan tidak terlalu rumit.  Secara umum, kami akan membuat pemancar serial yang dapat mengirim data dan sinyal pemilihan chip ke dua perangkat. <br><br><img src="https://habrastorage.org/webt/fr/uj/_u/fruj_ufw0phhzgbovupezinxo6c.png"><br><br>  Mari kita mulai dengan opsi ban paling sederhana.  Mari kita buat port keluaran paralel, yang membentuk sinyal pilihan kristal. <br><br><img src="https://habrastorage.org/webt/rc/z6/yg/rcz6ygig6s3yz-bxsjwsbonygp4.png"><br><br>  Untuk ini, saya akan mengambil proyek yang diperoleh di artikel sebelumnya, tetapi untuk menghindari kebingungan, saya akan meletakkannya di direktori AVALON_DEMO.  Saya tidak akan mengubah nama file lain.  Di direktori ini, buat direktori <b>my_cores</b> .  Nama direktori bisa apa saja.  Kami akan menyimpan inti kami di dalamnya.  Benar, hari ini akan menjadi satu.  Buat file <b>CrazySerial.sv</b> dengan konten berikut: <br><pre><code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output reg [1:0] cs ); always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; end else begin if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; default:; endcase end end endmodule</code> </pre> <br>  Mari kita perbaiki.  Pertama-tama, garis antarmuka.  <b>CLK</b> dan <b>reset</b> adalah jam dan garis reset.  Nama <b>alamat</b> , <b>baris</b> <b>tulis</b> dan <b>writedata</b> diambil dari tabel dengan daftar sinyal dari dokumen <b>Antarmuka Memori yang Dipetakan</b> . <br><br><img src="https://habrastorage.org/webt/lz/q9/rv/lzq9rvmj8mekwwiqqene5mvbu7i.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/a-/pexza-dsswt01-shzs4sy0pkjay.png"><br><br>  Bahkan, saya bisa memberi nama.  Menghubungkan garis logis dengan yang fisik akan dilakukan nanti.  Tetapi jika Anda memberi nama, seperti dalam tabel, lingkungan pengembangan akan menghubungkannya dengan sendirinya.  Karena itu, lebih baik mengambil nama dari tabel. <br><br>  Nah, <b>cs</b> adalah garis pemilihan kristal yang akan keluar dari chip. <br><br>  Implementasinya sendiri sepele.  Saat diatur ulang, outputnya di-zeroed.  Jadi - pada setiap pengukuran kita memeriksa apakah ada sinyal <b>tulis</b> .  Jika ada alamat yang sama dengan nol, maka klik datanya.  Tentu saja, mungkin untuk menambahkan decoder di sini, yang akan mencegah pilihan dua perangkat sekaligus, tetapi apa yang baik dalam hidup akan membebani artikel.  Artikel ini hanya menyediakan langkah-langkah yang paling penting, namun, perlu dicatat bahwa dalam hidup semuanya bisa dilakukan lebih rumit. <br><br>  Bagus  Kami siap untuk memperkenalkan kode ini ke dalam sistem prosesor.  Kami pergi ke <b>Perancang Platform</b> , pilih sebagai file input sistem yang kami buat dalam percobaan sebelumnya: <br><br><img src="https://habrastorage.org/webt/vd/a3/mp/vda3mpnhkbmfl9gj037h7kyefs8.png"><br><br>  Kami menarik perhatian ke item <b>Komponen Baru</b> di sudut kiri atas: <br><br><img src="https://habrastorage.org/webt/iz/xq/hw/izxqhw8wg6jshahucg0ardu7ukg.png"><br><br>  Untuk menambahkan komponen Anda, klik pada item ini.  Dalam dialog yang terbuka, isi kolom.  Dan untuk artikel ini, isilah hanya nama komponen: <br><br><img src="https://habrastorage.org/webt/nn/l8/mt/nnl8mtcsdxmqyp6cjnkrcr-qlc0.png"><br><br>  Sekarang buka tab <b>File</b> dan klik <b>Add File</b> : <br><br><img src="https://habrastorage.org/webt/fo/rw/jx/forwjxin05orcsaaw7uuuiw1mra.png"><br><br>  Tambahkan file yang dibuat sebelumnya, pilih dalam daftar dan klik <b>Analisis File Sintesis</b> : <br><br><img src="https://habrastorage.org/webt/a_/-i/g0/a_-ig0-b-v--safmwwco-gcblvi.png"><br><br>  Tidak ada kesalahan dalam parsing <b>SystemVerilog</b> , tetapi ada beberapa kesalahan konseptual.  Mereka disebabkan oleh kenyataan bahwa beberapa jalur tidak terhubung dengan benar oleh lingkungan pengembangan.  Kami pergi ke tab <b>Sinyal &amp; Antarmuka</b> dan perhatikan di sini: <br><br><img src="https://habrastorage.org/webt/be/7s/nb/be7snb0yjnqj8qn-ku_dboeirjs.png"><br><br>  Baris <b>cs</b> tidak tepat ditugaskan ke antarmuka <b>avalon_slave0</b> , sinyal <b>readdata</b> .  Tapi kemudian semua baris lainnya dikenali dengan benar, berkat fakta bahwa kami memberi mereka nama dari tabel dokumen.  Tapi apa yang harus dilakukan dengan garis masalah?  Mereka harus ditugaskan ke antarmuka seperti <b>saluran</b> .  Untuk melakukan ini, klik pada item â€œtambahkan antarmukaâ€ <br><br><img src="https://habrastorage.org/webt/ur/ce/je/urcejebzbrayxcoyvs16vorleik.png"><br><br>  Di menu tarik-turun, pilih <b>saluran</b> : <br><br><img src="https://habrastorage.org/webt/2-/l-/45/2-l-45h1b_8jnat3uazcscgcpt0.png"><br><br>  Kami mendapatkan antarmuka baru: <br><br><img src="https://habrastorage.org/webt/g_/r4/j0/g_r4j0acbfvawp7plewjmsolw1e.png"><br><br>  Jika diinginkan, dapat diubah namanya.  Benar, ini tentu akan diperlukan jika kita ingin membuat beberapa antarmuka eksternal.  Sebagai bagian dari artikel, kami akan membiarkannya nama <b>conduit_end</b> .  Sekarang kita menghubungkan garis <b>cs</b> dengan mouse dan menariknya ke antarmuka ini.  Kita harus mengatur untuk melemparkan sinyal di bawah baris <b>conduit_end</b> , maka kita akan diizinkan untuk melakukan ini.  Di tempat lain, kursor akan muncul sebagai lingkaran dicoret.  Pada akhirnya, kita harus memiliki ini: <br><br><img src="https://habrastorage.org/webt/gb/2e/lw/gb2elw6dvx2iw11y28uq0qlye5q.png"><br><br>  Ganti tipe sinyal dengan <b>readdata</b> dengan, katakanlah, <b>chipselect</b> .  Gambar akhir: <br><br><img src="https://habrastorage.org/webt/6o/ur/gq/6ourgq054tn85rth2nixk33_pvs.png"><br><br>  Namun kesalahan tetap ada.  <b>Bus avalon</b> tidak diberi sinyal reset.  Kami memilih <b>avalon_slave_0</b> dari daftar dan melihat propertinya. <br><br><img src="https://habrastorage.org/webt/s6/0i/--/s60i--4ijigk6exutkovd5zlwi0.png"><br><br>  Ganti <b>tidak</b> dengan <b>reset</b> .  Pada saat yang sama, kami akan memeriksa properti antarmuka lainnya. <br><br><img src="https://habrastorage.org/webt/xn/4d/kf/xn4dkf5jpxsi-6ujubxeuptddo4.png"><br><br>  Dapat dilihat bahwa berbicara dengan kata-kata.  Nah, sejumlah hal lain dari dokumentasi tersebut dikonfigurasi di sini.  Diagram waktu apa yang diperoleh dalam kasus ini akan diambil di bagian paling bawah dari properti: <br><br><img src="https://habrastorage.org/webt/xc/nw/xq/xcnwxqjxkz7y4qgxtcmn6ulb5eu.png"><br><br>  Sebenarnya, tidak ada lagi kesalahan.  Anda bisa mengklik <b>Selesai</b> .  Modul yang kami buat muncul di pohon perangkat: <br><br><img src="https://habrastorage.org/webt/rt/qe/bz/rtqebza22wictmnw0cpgvw_uu3g.png"><br><br>  Tambahkan ke sistem prosesor, sambungkan sinyal jam dan setel ulang.  Kami menghubungkan bus data ke prosesor <b>Data Master</b> .  Klik dua kali <b>Conduit_end</b> dan beri nama eksternal sinyal, katakanlah, <b>baris</b> .  Ternyata entah bagaimana seperti ini: <br><br><img src="https://habrastorage.org/webt/ob/mm/al/obmmalo6x1jytho2mzkvy4emdbu.png"><br><br>  Penting untuk tidak lupa bahwa karena kami menambahkan blok ke sistem, kami harus memastikan bahwa itu tidak bertentangan dengan siapa pun di ruang alamat.  Dalam kasus khusus ini, tidak ada konflik dalam gambar, tapi bagaimanapun, saya akan memilih item menu <b>System-&gt; Assign Base Addresses</b> . <br><br>  Itu saja.  Blok dibuat, dikonfigurasi, ditambahkan ke sistem.  Klik tombol <b>Generate HDL</b> , lalu <b>Finish</b> . <br><br>  Kami membuat konsep kasar proyek, setelah itu kami pergi ke <b>Perencana Pin</b> dan menetapkan kaki.  Ternyata seperti ini: <br><br><img src="https://habrastorage.org/webt/mn/fs/39/mnfs39ezihwpwese2tsdto4ialc.png"><br><br>  Yang sesuai dengan kontak B22 dan C22 dari konektor antarmuka. <br><br>  Kami membuat perakitan akhir, memuat sistem prosesor ke dalam FPGA.  Sekarang kita perlu memperbaiki kode program.  Luncurkan Eclipse. <br><br>  Biarkan saya mengingatkan Anda bahwa saya saat ini bekerja dengan proyek yang terletak di direktori yang berbeda relatif terhadap pekerjaan terakhir saya dengan Redd.  Agar tidak bingung, saya akan menghapus proyek lama dari pohon (tetapi hanya dari pohon, tanpa menghapus file sendiri). <br><br><img src="https://habrastorage.org/webt/xm/jv/ch/xmjvchikm8_ukin_evoqdw28op8.png"><br><br>  Selanjutnya, saya klik tombol kanan mouse pada pohon kosong dan pilih <b>Impor</b> dari menu: <br><br><img src="https://habrastorage.org/webt/yp/kt/sf/ypktsfboxaxgfhqcubjnlwogoxq.png"><br><br>  Berikutnya - <b>Umum-&gt; Proyek yang Ada ke dalam Ruang Kerja</b> : <br><br><img src="https://habrastorage.org/webt/rb/dw/me/rbdwmebel6yu6hjmvyxn7hik0q8.png"><br><br>  Dan cukup pilih direktori di mana file proyek disimpan: <br><br><img src="https://habrastorage.org/webt/nd/3t/6h/nd3t6hwmddm9pfrwr4cjd4iw4hy.png"><br><br><img src="https://habrastorage.org/webt/ei/qg/de/eiqgdehf_klzhkyyleod_opnlgq.png"><br><br>  Kedua proyek yang diwarisi dari percobaan sebelumnya akan terhubung ke lingkungan pengembangan. <br><br><img src="https://habrastorage.org/webt/qq/vw/jk/qqvwjkfgoli7vu3wedt3qhbnsf0.png"><br><br>  Saya akan menyoroti item berikutnya dalam sebuah bingkai: <br><blockquote>  Setiap kali setelah mengubah konfigurasi perangkat keras, pilih <b>Nios II -&gt; Hasilkan</b> item menu <b>BSP</b> untuk proyek BSP lagi. </blockquote><br><br><img src="https://habrastorage.org/webt/ks/jn/mt/ksjnmtcdfbf2p0vej4qeeltlkxk.png"><br><br>  Sebenarnya, setelah operasi ini, sebuah blok baru muncul di file <b>\ AVALON_DEMO \ software \ SDRAMtest_bsp \ system.h</b> : <br><pre> <code class="plaintext hljs">/* * CrazySerial_0 configuration * */ #define ALT_MODULE_CLASS_CrazySerial_0 CrazySerial #define CRAZYSERIAL_0_BASE 0x4011020 #define CRAZYSERIAL_0_IRQ -1 #define CRAZYSERIAL_0_IRQ_INTERRUPT_CONTROLLER_ID -1 #define CRAZYSERIAL_0_NAME "/dev/CrazySerial_0" #define CRAZYSERIAL_0_SPAN 16 #define CRAZYSERIAL_0_TYPE "CrazySerial"</code> </pre><br>  Pertama-tama, kami tertarik pada <b>CRAZYSERIAL_0_BASE yang</b> konstan. <br><br>  Tambahkan kode berikut ke fungsi <b>utama ()</b> : <br><pre> <code class="plaintext hljs"> while (true) { IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x03); }</code> </pre><br>  Kami mulai men-debug dan melihat isi baris dengan osiloskop.  Harus ada kode biner tambahan.  Dia disana. <br><br><img src="https://habrastorage.org/webt/fm/xp/0z/fmxp0z5mactvzv-vdv2cahbvj1i.png"><br><br>  Selain itu, frekuensi akses ke port sangat bagus: <br><br><img src="https://habrastorage.org/webt/cm/rd/of/cmrdofrh6yzmo2xwdkjynz6gwwm.png"><br><br>  Sekitar 25 MHz adalah setengah frekuensi bus (2 siklus clock).  Terkadang waktu akses bukan 2 siklus, tetapi lebih lama.  Ini karena pelaksanaan operasi percabangan dalam program.  Secara umum, akses paling sederhana ke bus bekerja. <br><br>  Saatnya untuk menambahkan fungsi port serial misalnya.  Untuk melakukan ini, tambahkan sinyal antarmuka <b>waitrequest</b> terkait dengan bus dan sepasang sinyal port serial - <b>sck</b> dan <b>sdo</b> .  Total, kami mendapatkan fragmen kode berikut pada <b>systemverilog</b> : <br><br><img src="https://habrastorage.org/webt/dy/wc/vt/dywcvtwz6_h4ccubotauamcnnju.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo );</code> </pre><br></div></div><br>  Menurut aturan bentuk yang baik, Anda perlu membuat mesin sederhana yang akan mengirimkan data.  Sayangnya, mesin yang paling tidak rumit dalam artikel ini akan terlihat sangat sulit.  Tetapi pada kenyataannya, jika saya tidak meningkatkan fungsionalitas mesin (dan sebagai bagian dari artikel saya tidak akan melakukan ini), maka ia hanya akan memiliki dua status: transmisi sedang berlangsung dan transmisi tidak sedang berlangsung.  Karena itu, saya dapat menyandikan status dengan satu sinyal: <br>  pengiriman reg = 0; <br><br>  Selama transmisi, saya memerlukan penghitung bit, pembagi jam (saya melakukan perangkat yang sengaja lambat) dan register geser untuk data yang dikirimkan.  Tambahkan register yang sesuai: <br><pre> <code class="plaintext hljs"> reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0;</code> </pre><br>  Saya akan membagi frekuensi dengan 10 (dipandu oleh prinsip "mengapa tidak?").  Dengan demikian, pada langkah kelima saya akan memiringkan SCK, dan pada kesepuluh - jatuhkan baris ini, setelah itu - pergi ke bit data berikutnya.  Pada semua langkah lain, cukup tambahkan penghitung pembagi.  Penting untuk tidak lupa bahwa pada langkah keempat Anda juga perlu menambah penghitung, dan pada yang kesembilan - nol itu.  Jika kita menghilangkan transisi ke bit berikutnya, maka logika yang ditentukan terlihat seperti ini: <br><pre> <code class="plaintext hljs"> if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin sck &lt;= 0; clk_div &lt;= 0; // &lt;   &gt; end default: clk_div &lt;= clk_div + 1; endcase end else</code> </pre><br>  Pergi ke bit berikutnya itu mudah.  Mereka menggeser register geser, kemudian, jika bit saat ini adalah yang ketujuh, mereka berhenti bekerja dengan mengubah keadaan mesin, jika tidak mereka meningkatkan bit counter. <br><pre> <code class="plaintext hljs"> shifter &lt;= {shifter[6:0],1'b0}; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end</code> </pre><br>  Sebenarnya itu saja.  Bit output selalu diambil dari bit tinggi register shift: <br><pre> <code class="plaintext hljs"> assign sdo = shifter [7];</code> </pre><br>  Dan garis paling penting untuk revisi saat ini.  Sinyal <b>waitrequest</b> diiringi ke kesatuan selalu ketika data serial sedang dikirim.  Yaitu, itu adalah salinan dari sinyal <b>pengiriman</b> yang mengatur keadaan mesin: <br><pre> <code class="plaintext hljs"> assign waitrequest = sending;</code> </pre><br>  Nah, dan ketika menulis ke alamat 1 (ingat, di sini kami memiliki pengalamatan dalam kata-kata 32-bit), kami memasukkan data ke dalam register geser, nol penghitung dan memulai proses transfer: <br><pre> <code class="plaintext hljs"> if (write) //... 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Sekarang saya akan memberikan semua fragmen yang dijelaskan sebagai satu teks:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo ); reg sending = 0; reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0; always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; sck &lt;= 0; sending &lt;= 0; end else begin if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin clk_div &lt;= 0; shifter &lt;= {shifter[6:0],1'b0}; sck &lt;= 0; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end end default: clk_div &lt;= clk_div + 1; endcase end else if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end end assign sdo = shifter [7]; assign waitrequest = sending; endmodule</code> </pre><br></div></div><br>  Kami mulai memperkenalkan kode baru ke dalam sistem.  Sebenarnya, path sama dengan saat membuat komponen, tetapi beberapa langkah sudah bisa dihilangkan.  Sekarang kita akan berkenalan dengan proses penyempurnaan.  Pergi ke <b>Perancang Platform</b> .  Jika kita hanya mengubah kode Verilog, akan sangat sederhana untuk melakukan operasi <b>Hasilkan HDL</b> untuk sistem yang sudah selesai.  Tetapi karena modul memiliki garis-garis baru (yaitu, antarmuka telah berubah), itu perlu diulang.  Untuk melakukan ini, pilih di pohon, tekan tombol kanan mouse dan pilih <b>Edit</b> . <br><br><img src="https://habrastorage.org/webt/sg/el/hx/sgelhxlzgzwjz81z6q7xhkhbxzs.png"><br><br>  Kami sedang mengedit sistem yang ada.  Jadi cukup buka tab <b>File</b> dan klik <b>Analisis File Sinthesis</b> : <br><br><img src="https://habrastorage.org/webt/qy/nw/0q/qynw0q5tul7k26yaygdyzsigouu.png"><br><br>  Terjadi kesalahan yang dapat diprediksi.  Tapi kita sudah tahu bahwa garis yang salah yang harus disalahkan.  Oleh karena itu, kita pergi ke tab <b>Sinyal &amp; Antarmuka</b> , seret <b>sck</b> dan <b>sdo di</b> sepanjang baris yang sama dari antarmuka <b>avalon_slave_0</b> ke antarmuka <b>conduit_end</b> : <br><br><img src="https://habrastorage.org/webt/z_/rz/jj/z_rzjjaaiaqzey6gczf6ptt0vfa.png"><br><br>  Ganti nama bidang <b>Tipe Sinyal</b> untuknya.  Hasilnya harus sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ng/3_/t_/ng3_t_kiebqf_jw3wwljh0aqsig.png"><br><br>  Sebenarnya itu saja.  Klik <b>Selesai</b> , panggil <b>Hasilkan File HDL</b> untuk sistem prosesor, konsep proyek di Quartus, tetapkan kaki baru: <br><br><img src="https://habrastorage.org/webt/ul/hg/rh/ulhgrhytzp1y9149j8x11apyvcy.png"><br><br>  Ini adalah kontak A21 dan A22 dari konektor antarmuka, kami membuat perakitan akhir, mengisi "firmware" di FPGA. <br><br>  Besi diperbarui.  Sekarang programnya.  Mari kita pergi ke Eclipse.  Apa yang kita ingat lakukan di sana?  Benar juga, jangan lupa pilih <b>Generate BSP</b> . <br><br>  Sebenarnya itu saja.  Tetap menambahkan fungsionalitas ke program.  Mari mentransfer sepasang byte ke port serial, tetapi kami akan mengirimkan byte pertama ke perangkat yang dipilih oleh baris <b>cs [0]</b> , dan yang kedua - <b>cs [1]</b> . <br><pre> <code class="plaintext hljs"> IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x12); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x34); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00);</code> </pre><br>  Harap dicatat bahwa tidak ada pemeriksaan ketersediaan di sana.  Paket berjalan satu demi satu.  Namun demikian, pada osiloskop semuanya ternyata cukup konsisten <br><br><img src="https://habrastorage.org/webt/vh/qm/ig/vhqmigcblrnmmcizbs11jwdgsig.png"><br><br>  Sinar kuning adalah <b>cs [0]</b> , <b>sinar</b> hijau adalah <b>sdo</b> , <b>sinar</b> violet adalah <b>sck</b> , dan <b>sinar</b> biru adalah <b>cs [1]</b> .  Dapat dilihat bahwa kode 0x12 pergi ke perangkat pertama, 0x34 ke perangkat kedua. <br><br>  Membaca dilakukan dengan cara yang sama, tetapi saya tidak bisa memberikan contoh yang indah, kecuali untuk pembacaan dangkal dari isi kaki konektor.  Tetapi contoh itu begitu merosot sehingga tidak menarik untuk dilakukan.  Tetapi di sini perlu dicatat bahwa ketika membaca pengaturan bus ini bisa sangat penting: <br><br><img src="https://habrastorage.org/webt/m4/7g/i6/m47gi6xbkat-jct5iuuffqmyya8.png"><br><br>  Jika ada garis <b>Baca</b> , maka bagan waktu baca akan muncul di dialog pengaturan.  Dan itu akan menunjukkan pengaruh parameter ini.  Saat membaca kaki konektor, itu masih tidak akan terlihat, tetapi ketika membaca dari FIFO atau RAM yang sama - sepenuhnya.  RAM dapat dikonfigurasikan untuk mengeluarkan data segera setelah alamat dikirimkan, atau dapat dikeluarkan secara sinkron.  Dalam kasus kedua, latensi ditambahkan.  Lagi pula, bus mengatur alamat, mengatur strobo ... Tetapi tidak ada data di tepi terdekat dari sinyal jam.  Mereka akan muncul setelah bagian depan ini ... Yaitu, sistem memiliki latensi satu latensi.  Dan itu hanya perlu diperhitungkan dengan mengatur parameter ini.  Singkatnya, jika Anda tidak membaca apa yang diharapkan, pertama-tama periksa apakah Anda perlu mengkonfigurasi latensi.  Selebihnya - membaca tidak berbeda dengan menulis. <br><br>  Baiklah, izinkan saya mengingatkan Anda sekali lagi bahwa lebih baik tidak menghapus kesiapan bus untuk operasi jangka panjang, jika tidak sangat mungkin untuk secara drastis mengurangi kinerja sistem.  Sinyal siap baik untuk menahan transaksi selama beberapa siklus clock, dan tidak hingga 80 siklus clock, seperti dalam contoh saya.  Tetapi pertama-tama, contoh lain akan merepotkan untuk artikel, dan kedua, untuk kernel satu hari, ini cukup dapat diterima.  Anda akan sepenuhnya menyadari tindakan Anda dan akan menghindari situasi ketika bus diblokir.  Benar, jika inti bertahan waktu yang dialokasikan untuk itu, asumsi seperti itu dapat merusak kehidupan di masa depan, ketika semua orang lupa tentang hal itu, dan itu memperlambat segalanya.  Tapi nanti. <br><br>  Namun demikian, kami telah belajar membuat inti prosesor mengendalikan inti kami.  Semuanya jelas dengan dunia yang bisa dialamatkan, sekarang saatnya untuk berhadapan dengan dunia streaming.  Tetapi kita akan melakukan ini di artikel berikutnya, dan mungkin bahkan beberapa artikel. <br><br><h3>  Kesimpulan </h3><br>  Artikel tersebut menunjukkan bagaimana kernel Verilog yang sewenang-wenang dapat dihubungkan untuk mengontrol sistem prosesor Nios II.  Pilihan untuk koneksi paling sederhana ke bus Avalon, serta koneksi di mana bus bisa dalam keadaan sibuk, ditampilkan.  Tautan ke literatur diberikan, dari mana Anda dapat mengetahui mode operasi lain dari bus Avalon dalam mode Memory Mapped. <br><br>  Proyek yang dihasilkan dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454938/">https://habr.com/ru/post/id454938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454924/index.html">Pengaturan Otentikasi di Veeam Backup untuk Microsoft Office 365 v3</a></li>
<li><a href="../id454926/index.html">Semua yang Anda ketahui tentang word2vec tidak benar</a></li>
<li><a href="../id454928/index.html">Cara untuk Memintas Layar Kunci Windows pada Sesi RDP</a></li>
<li><a href="../id454930/index.html">Pengumpulan sampah di V8: cara kerja Orinoco GC baru</a></li>
<li><a href="../id454936/index.html">Vivaldi: Pemblokiran iklan harus menjadi pilihan pengguna</a></li>
<li><a href="../id454940/index.html">Asuransi kesehatan perjalanan: petunjuk terperinci</a></li>
<li><a href="../id454944/index.html">Cara kerja format JPEG</a></li>
<li><a href="../id454946/index.html">Negara global: mengapa dan bagaimana cara menghindarinya</a></li>
<li><a href="../id454958/index.html">Pandangan dari dalam: sekolah pascasarjana di EPFL. Bagian 4.1: kehidupan sehari-hari</a></li>
<li><a href="../id454960/index.html">Mikrobiota. Bagaimana obat memengaruhi bakteri usus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>