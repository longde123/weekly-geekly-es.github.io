<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈯️ 📟 🏟️ Comment ce sidecar est-il arrivé ici [à Kubernetes]? 🚎 👨🏽‍💼 📑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Avec cet article, écrit par Scott Rahner, ingénieur chez Dow Jones, nous continuons la série de nombreux documents qui expliquent co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ce sidecar est-il arrivé ici [à Kubernetes]?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/431252/">  <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Avec cet article, écrit par Scott Rahner, ingénieur chez Dow Jones, nous continuons la série de nombreux documents qui expliquent comment Kubernetes fonctionne, comment ses composants de base fonctionnent, sont interconnectés et utilisés.</i>  <i>Cette fois, il s'agit d'une note pratique avec un exemple de code pour créer un hook dans Kubernetes, démontrée par l'auteur «sous prétexte» de créer automatiquement des conteneurs sidecar.</i> <br><br><img src="https://habrastorage.org/webt/xg/bh/80/xgbh80h6dyzuokwsgrcttaiqtxs.jpeg"><br>  <i>(Photo de Gordon A. Maxwell, trouvée sur Internet.)</i> <br><br>  Lorsque j'ai commencé à apprendre les conteneurs side-car et le maillage de service, je devais comprendre comment fonctionne le mécanisme clé - l'insertion automatique des conteneurs side-car -.  En effet, dans le cas d'utilisation de systèmes comme Istio ou Consul, lorsque le conteneur avec l'application est déployé, le conteneur Envoy déjà configuré apparaît soudainement dans son pod <i>(une situation similaire se produit avec Conduit, dont nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé</a> au début de l'année - environ Transl.)</i> .  Quoi?  Comment?  Alors mes recherches ont commencé ... <a name="habracut"></a><br><br>  Pour ceux qui ne le savent pas, un sidecar-container est un conteneur qui est déployé à côté des conteneurs de l'application afin «d'aider» cette application d'une manière ou d'une autre.  Un exemple d'une telle utilisation est un proxy pour gérer le trafic et terminer les sessions TLS, un conteneur pour les journaux et les métriques en streaming, un conteneur pour analyser les problèmes de sécurité ... L'idée est d'isoler divers aspects de l'application entière de la logique métier en utilisant des conteneurs séparés pour chacun fonctions. <br><br>  Avant de poursuivre, je décrirai mes attentes.  Le but de cet article n'est pas d'expliquer les subtilités et les scénarios d'utilisation de Docker, Kubernetes, service mesh, etc., mais de démontrer une approche puissante pour étendre les capacités de ces technologies.  L'article est destiné à ceux qui connaissent déjà l'utilisation de ces technologies ou, au moins, ont beaucoup lu à leur sujet.  Pour essayer la partie pratique en action, vous aurez besoin d'une machine avec Docker et Kubernetes déjà configurés.  La manière la plus simple de procéder est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.docker.com/docker-for-windows/kubernetes/</a> (un manuel Windows qui fonctionne avec Docker pour Mac).  <i>(Remarque perev .: Comme alternative aux utilisateurs de Linux et * nix-systèmes, nous pouvons offrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minikube</a> .)</i> <br><br><h2>  Image globale </h2><br>  Pour commencer, jetons un coup d'œil à Kubernetes: <br><br><img src="https://habrastorage.org/webt/gf/dh/2d/gfdh2deneli8j1ikyuutjbf2uvm.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kube Arch</a> sous licence CC BY 4.0</i> <br><br>  Lorsque vous avez l'intention de déployer quelque chose sur Kubernetes, vous devez envoyer l'objet à kube-apiserver.  Cela se fait le plus souvent en passant des arguments ou un fichier YAML à kubectl.  Dans ce cas, le serveur API passe par plusieurs étapes avant de placer directement les données dans etcd et de planifier les tâches correspondantes: <br><br><img src="https://habrastorage.org/webt/g-/mv/hw/g-mvhwfhhsoxrdofk2be2ezkrow.jpeg"><br><br>  Cette séquence est importante pour comprendre le fonctionnement de l'insertion d'un conteneur side-car.  En particulier, vous devez faire attention au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôle d'admission</a> , dans lequel Kubernetes valide et, si nécessaire, modifie les objets avant de les stocker <i>(pour plus de détails sur cette étape, consultez le chapitre "Contrôle d'accès" dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> - environ Transl.)</i> .  Kubernetes vous permet également d'enregistrer des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webhooks</a> pouvant effectuer des validations et <i>mutations</i> définies par l'utilisateur. <br><br>  Cependant, le processus de création et d'enregistrement de vos hooks n'est pas si simple et bien documenté.  J'ai dû passer plusieurs jours à lire et relire la documentation, ainsi qu'à analyser le code Istio et Consul.  Et en ce qui concerne le code de certaines des réponses de l'API, j'ai passé au moins une demi-journée à faire des essais et des erreurs aléatoires. <br><br>  Une fois le résultat obtenu, je pense qu'il sera injuste de ne pas le partager avec vous tous.  C'est simple et en même temps efficace. <br><br><h2>  Code </h2><br>  Le nom webhook parle de lui-même - il s'agit d'un point de terminaison HTTP qui implémente l'API définie dans Kubernetes.  Vous créez un serveur API que Kubernetes peut appeler avant de traiter les déploiements.  J'ai dû faire face à des difficultés ici, car seuls quelques exemples sont disponibles, dont certains ne sont que des tests unitaires de Kubernetes, d'autres sont cachés au milieu d'une énorme base de code ... et tous sont écrits en Go.  Mais j'ai choisi une option plus abordable - Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(bodyParser.json()); app.post(<span class="hljs-string"><span class="hljs-string">'/mutate'</span></span>, (req, res) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body.request.object) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adminResp = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">allowed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">patch</span></span>: Buffer.from(<span class="hljs-string"><span class="hljs-string">"[{ \"op\": \"add\", \"path\": \"/metadata/labels/foo\", \"value\": \"bar\" }]"</span></span>).toString(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>), <span class="hljs-attr"><span class="hljs-attr">patchType</span></span>: <span class="hljs-string"><span class="hljs-string">"JSONPatch"</span></span>, }} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(adminResp) res.send(adminResp) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = https.createServer(options, app);</code> </pre> <br>  <i>( <a href="">index.js</a> )</i> <br><br>  Le chemin vers l'API - dans ce cas <code>/mutate</code> - peut être arbitraire (il ne devrait correspondre qu'à la YAML passée à Kubernetes à l'avenir).  Il est important pour lui de voir et de comprendre le JSON reçu du serveur API.  Dans ce cas, nous ne retirons rien de JSON, mais cela pourrait être utile dans d'autres scénarios.  Dans le code ci-dessus, nous mettons à jour JSON.  Deux choses sont nécessaires pour cela: <br><br><ol><li>  Apprenez et comprenez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif JSON</a> . </li><li>  Convertissez correctement une expression de patch JSON en un tableau d'octets codés en base64. </li></ol><br>  Une fois cela fait, il vous suffit de transmettre la réponse au serveur API avec un objet très simple.  Dans ce cas, nous ajoutons l'étiquette <code>foo=bar</code> tout pod qui nous parvient. <br><br><h2>  Déploiement </h2><br>  Eh bien, nous avons du code qui accepte les demandes du serveur API Kubernetes et y répond, mais comment le déployer?  Et comment faire en sorte que Kubernetes nous redirige ces demandes?  Vous pouvez déployer un tel point de terminaison partout où vous pouvez atteindre le serveur API Kubernetes.  Le moyen le plus simple consiste à déployer le code sur le cluster Kubernetes lui-même, ce que nous ferons dans cet exemple.  J'ai essayé de rendre l'exemple aussi simple que possible, donc pour toutes les actions, j'utilise uniquement Docker et kubectl.  Commençons par créer un conteneur dans lequel le code s'exécutera: <br><br><pre> <code class="plaintext hljs">FROM node:8 USER node WORKDIR /home/node COPY index.js . COPY package.json . RUN npm install #       TLS CMD node index.js</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dockerfile</a> )</i> <br><br>  Apparemment, tout est très simple ici.  Prenez l'image de la communauté du nœud et déposez-y le code.  Vous pouvez maintenant effectuer un assemblage simple: <br><br><pre> <code class="bash hljs">docker build . -t localserver</code> </pre> <br>  L'étape suivante consiste à créer un déploiement dans Kubernetes: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webhook-server spec: replicas: 1 selector: matchLabels: component: webhook-server template: metadata: labels: component: webhook-server spec: containers: - name: webhook-server imagePullPolicy: Never image: localserver</code> </pre> <br>  <i>( <a href="">deployment.yaml</a> )</i> <br><br>  Remarquez comment nous avons fait allusion à l'image que nous venons de créer?  Cela pourrait tout aussi bien être un pod, et quelque chose d'autre auquel nous pouvons connecter un service dans Kubernetes.  Définissez maintenant ce service: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: webhook-service spec: ports: - port: 443 targetPort: 8443 selector: component: webhook-server</code> </pre> <br>  Ainsi, dans Kubernetes, un point de terminaison apparaît avec un nom interne qui pointe vers notre conteneur.  La dernière étape consiste à dire à Kubernetes que nous voulons que le serveur API appelle ce service lorsqu'il est prêt à effectuer des <i>mutations</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: name: webhook webhooks: - name: webhook-service.default.svc failurePolicy: Fail clientConfig: service: name: webhook-service namespace: default path: "/mutate" #    base64-  rootCA.crt #    `cat rootCA.crt | base64 | tr -d '\n'` #    .  caBundle: "==" rules: - operations: [ "CREATE" ] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</code> </pre>  <i>( <a href="">hook.yaml</a> )</i> <br><br>  Le nom et le chemin ici peuvent être quelconques, mais j'ai essayé de les rendre aussi significatifs que possible.  Changer le chemin signifiera la nécessité de modifier le code correspondant en JavaScript.  Échec du <code>failurePolicy</code> La <code>failurePolicy</code> est également <code>failurePolicy</code> - elle détermine si l'objet doit être enregistré si le hook renvoie une erreur ou échoue.  Dans ce cas, nous demandons à Kubernetes de ne pas poursuivre le traitement.  Enfin, les règles: elles changeront en fonction des appels d'API auxquels vous attendez des actions de Kubernetes.  Dans ce cas, puisque nous essayons d'émuler l'insertion d'un conteneur de sidecar, nous devons intercepter les demandes pour créer un pod. <br><br>  C'est tout!  Si simple ... mais qu'en est-il de la sécurité?  RBAC est un aspect qui n'est pas couvert dans l'article.  Je suppose que vous exécutez l'exemple dans Minikube ou dans Kubernetes, fourni avec Docker pour Windows / Mac.  Cependant, je vais vous parler d'un autre élément nécessaire.  Le serveur Kubernetes API accède uniquement aux points de terminaison avec HTTPS, donc l'application nécessite des certificats SSL.  Vous devrez également indiquer à Kubernetes qui est l'autorité de certification du certificat racine. <br><br><h2>  TLS </h2><br>  <b>À des fins de démonstration uniquement (!!!),</b> j'ai ajouté du code au <code>Dockerfile</code> pour créer une autorité de certification racine et l'utiliser pour signer le certificat: <br><br><pre> <code class="plaintext hljs">RUN openssl genrsa -out rootCA.key 4096 RUN openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=*.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl genrsa -out webhook.key 4096 RUN openssl req -new -key webhook.key -out webhook.csr \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=webhook-service.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl x509 -req -in webhook.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out webhook.crt -days 1024 -sha256 RUN cat rootCA.crt | base64 | tr -d '\n'</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dockerfile</a> )</i> <br><br>  Remarque: la dernière étape consiste à afficher une seule ligne avec l'autorité de certification racine codée en base64.  C'est exactement ce qui est requis pour la configuration du hook, donc lors de vos tests ultérieurs, assurez-vous de copier cette ligne dans le champ <code>caBundle</code> fichier <code>caBundle</code> .  <code>Dockerfile</code> jette des certificats directement dans <code>WORKDIR</code> , donc JavaScript les prend simplement à partir de là et les utilise pour le serveur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateKey = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.key'</span></span>).toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> certificate = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.crt'</span></span>).toString(); <span class="hljs-comment"><span class="hljs-comment">//… const options = {key: privateKey, cert: certificate}; const server = https.createServer(options, app);</span></span></code> </pre> <br>  Maintenant, le code prend en charge le lancement HTTPS et a également indiqué à Kubernetes où nous trouver et quel centre de confiance faire confiance.  Il ne reste plus qu'à tout intégrer dans un cluster: <br><br><pre> <code class="bash hljs">kubectl create -f deployment.yaml kubectl create -f service.yaml kubectl create -f hook.yaml</code> </pre> <br><h3>  Résumer </h3><br><ul><li>  <code>Deployment.yaml</code> lance un conteneur qui sert l'API de raccordement via HTTPS et renvoie un correctif JSON pour modifier l'objet. </li><li>  <code>Service.yaml</code> fournit un point de terminaison pour le conteneur - <code>webhook-service.default.svc</code> . </li><li>  <code>Hook.yaml</code> indique au serveur API où nous trouver: <code>https://webhook-service.default.svc/mutate</code> . </li></ul><br><h2>  Essayons en affaires! </h2><br>  Tout est déployé dans un cluster - il est temps d'essayer le code en action, ce que nous ferons en ajoutant un nouveau pod / Déploiement.  Si tout fonctionne correctement, le crochet devra ajouter une étiquette supplémentaire <code>foo</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: test spec: replicas: 1 selector: matchLabels: component: test template: metadata: labels: component: test spec: containers: - name: test image: node:8 command: [ "/bin/sh", "-c", "--" ] args: [ "while true; do sleep 30; done;" ]</code> </pre> <br>  <i>( <a href="">test.yaml</a> )</i> <br><br><pre> <code class="bash hljs">kubectl create -f test.yaml</code> </pre> <br>  Ok, nous avons vu le <code>deployment.apps test created</code> ... mais cela a-t-il fonctionné? <br><br><pre> <code class="bash hljs">kubectl describe pods <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-6f79f9f8bd-r7tbd Namespace: default Node: docker-for-desktop/192.168.65.3 Start Time: Sat, 10 Nov 2018 16:08:47 -0500 Labels: component=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> foo=bar</code> </pre> <br>  Super!  Bien que <code>test.yaml</code> ait reçu une seule étiquette ( <code>component</code> ), le pod résultant en a reçu deux: <code>component</code> et <code>foo</code> . <br><br><h2>  Devoirs </h2><br>  Mais attends!  Allons-nous utiliser ce code pour créer un conteneur sidecar?  J'ai averti que je montrerais <b>comment</b> ajouter un side-car ... Et maintenant, avec les connaissances et le code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/dowjones/k8s-webhook</a> - expérimentez audacieusement et découvrez comment faire votre side-car inséré automatiquement.  C'est assez simple: il vous suffit de préparer le correctif JSON correct, qui ajoutera un conteneur supplémentaire dans le déploiement de test.  Bonne orchestration! <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alors, qu'est-ce qu'un pod dans Kubernetes?</a>  "; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment la haute disponibilité chez Kubernetes est assurée</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment fonctionne le planificateur Kubernetes?"</a>  "; </li><li>  "Que se passe-t-il dans Kubernetes lorsque l'exécution de kubectl démarre?"  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre RBAC chez Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notre expérience avec Kubernetes dans les petits projets</a> » <i>(reportage vidéo, qui comprend une introduction au dispositif technique de Kubernetes)</i> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce qu'un maillage de service et pourquoi en ai-je besoin?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431252/">https://habr.com/ru/post/fr431252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431242/index.html">TLS et certificats Web</a></li>
<li><a href="../fr431244/index.html">"Deux non filtré" ou un moyen facile de tirer une jambe</a></li>
<li><a href="../fr431246/index.html">@OpenStack Meetup at Mail.Ru Group: 30 novembre</a></li>
<li><a href="../fr431248/index.html">Qui sera responsable en agile de la qualité de développement de projets complexes, ou de la méthodologie Quality Gates</a></li>
<li><a href="../fr431250/index.html">Les adeptes de la frappe statique et dynamique ne se comprendront jamais. Et TypeScript ne les aidera pas</a></li>
<li><a href="../fr431254/index.html">Comment bien vivre sur un site distant</a></li>
<li><a href="../fr431256/index.html">Le Royaume-Uni et la Hollande condamnés à une amende de 1,2 million de dollars pour fuite de données personnelles</a></li>
<li><a href="../fr431258/index.html">Webinaires de décembre Kotlin 1.3</a></li>
<li><a href="../fr431260/index.html">Comment ça marche: le travail d'une équipe d'analystes sur l'exemple du développement d'un service digital</a></li>
<li><a href="../fr431262/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 19: «Anonymous Networks», partie 1 (conférence du créateur du réseau Tor)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>