<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 🖐🏻 😓 GTM中的自定义模板：一个示例 ❎ 👩‍🔬 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="5月底，Google在Google跟踪代码管理器（GTM）中引入了一项新功能：自定义模板或自定义模板。 让我们看看为什么需要它，如何使用它，与HTML标签和JavaScript变量有什么区别。 

 例如，请考虑为VKontakte动态重定向像素创建自定义模板，然后通过该模板进一步自定义GTM标签。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GTM中的自定义模板：一个示例</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458788/">  5月底，Google在Google跟踪代码管理器（GTM）中引入了一项新功能：自定义模板或自定义模板。 让我们看看为什么需要它，如何使用它，与HTML标签和JavaScript变量有什么区别。 <br><br> 例如，请考虑为VKontakte动态重定向像素创建自定义模板，然后通过该模板进一步自定义GTM标签。 <br><br><img src="https://habrastorage.org/webt/c-/62/zr/c-62zrfxks1t6c2gfsv0kn2brjm.png"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于自定义模板的简单词汇</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建自定义模板</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•信息选项卡</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•字段选项卡</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•代码标签</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•权限选项卡</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在创建的自定义模板上自定义和测试标签</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•浏览量</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•添加到购物车</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">•采矿测试</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> <br><br><a name="1"></a><h2> 关于自定义模板的简单词汇 </h2><br> 自定义模板是用户可以用来创建新标签或变量的模板。  GTM具有现成的模板（在“特色”或“推荐”部分），例如Google Analytics（分析）标记，Google Optimize等。 现在我们可以用我们的模板对其进行补充。 创建后，它们将出现在“自定义”选项卡中： <br><br><img src="https://habrastorage.org/webt/nx/q_/mu/nxq_mu_uxl6tyiumnl8xbzt6o2c.png"><br><br> 与HTML标记和JS变量的主要区别在于，当用户使用现成的模板创建标记或变量时，他不会与JS代码进行交互。 <br><br> 用户模板的代码由开发人员或网络分析师在其创建阶段编写。 然后，当根据用户模板创建标签或变量时，所有交互都通过接口执行（在创建用户模板时也进行了配置）： <br><br><img src="https://habrastorage.org/webt/pe/e2/te/pee2tevqbahm_nplbfgj0btis34.png"><br><br> 因此，与编写HTML标签或JS变量相比，根据用户模板自定义标签或变量变得容易一个数量级，因为这不需要使用JavaScript的知识和技能。 <br><br> 自定义模板的另一大优点是，由于标签的JS代码中的错误，“放置”网站的可能性降低了一个数量级。 <br><br> 在我们的示例中，要配置动态重定向标签“ VKontakte”，您不再需要与开发人员联系-一切都可以独立设置，即使商品的数据传输（在网站上配置了Google的高级电子商务），也只有GTM经验。 <br><br><a name="2"></a><h2> 创建自定义模板 </h2><br> 由于我们正在创建标签模板，因此需要转到“模板”部分，然后单击“标签模板”部分中的“新建”按钮。 <br><br><img src="https://habrastorage.org/webt/ca/bt/sa/cabtsaamxy-zoglccqgvt1v_tra.png"><br><br> 之后，模板编辑器将打开： <br><br><img src="https://habrastorage.org/webt/bf/c3/jf/bfc3jf2xgpkasmc3qvik2tp4wxy.png"><br><br> 编辑器的左侧是设置窗口，右侧是预览窗口和控制台。 设置窗口中有四个选项卡，它们是创建和使用模板所必需的。 <br><br><a name="3"></a><h3> 信息标签 </h3><br> 标签上的信息在此选项卡上填写：名称，描述，图标。 这是在模板列表中创建新标签时将看到的信息： <br><br><img src="https://habrastorage.org/webt/dd/nm/9f/ddnm9fvcygh2ob6jzkliccqgi1o.png"><br><br> 标记图标有以下要求：PNG，JPEG或GIF格式，至少64x64像素的分辨率和不超过50 KB的大小。 <br><br><a name="4"></a><h3> 字段标签 </h3><br> 本部分创建模板的界面。 该界面包含各种字段和形式，在创建新标签或变量的阶段，用户可以与之交互。 <br><br> 将来，模板代码中将使用用户使用界面创建标签时输入的信息。 <br><br> 要添加新元素，请单击“添加字段”按钮。 出现用于选择元素类型的窗口： <br><br><img src="https://habrastorage.org/webt/g5/ko/d7/g5kod7ox7dal761180kpdfhojto.png"><br><br>  GTM允许您选择以下类型的界面元素： <br><br><ul><li>  <b>文字框</b> </li><li>  <b>下拉菜单</b> </li><li>  <b>复选框</b> ; </li><li>  <b>开关</b> </li><li>  <b>简单表格</b> ，您可以在此处编辑每个单元格。 </li><li>  <b>扩展表</b> ，您只能编辑一行，这种类型的表很方便用于从键值对创建字典； </li><li>  <b>元素组</b> ，允许您将几种类型分组为一组； </li><li>  <b>快捷方式</b>用于向界面添加文本；它不需要用户输入任何数据。 </li></ul><br> 添加元素后，需要给它起一个友好的名称，该名称随后将在代码中使用。 这是一种变量名-应该易于理解并且可以揭示所创建接口元素的本质。 例如，名称“ ID”并不表示任何特定含义，但名称“ pixelIDs”已经表明用户输入的像素ID存储在此元素中： <br><br><img src="https://habrastorage.org/webt/fv/1h/ht/fv1hht_iaatbuhi1ejovajkehhc.png"><br><br> 接下来，转到每个元素的设置并激活必要的属性。 <br> 在不同情况下，需要接口元素的不同属性，因此默认情况下它们都是隐藏的，我们需要激活现在需要的那些属性： <br><br><img src="https://habrastorage.org/webt/ah/jx/o1/ahjxo1oz0w8fp6pntytshfs1y_o.png"><br><br> 对于不同类型的元素，可用属性有所不同，我将指出最常用的元素，几乎是所有元素： <br><br>  <b>1.显示名称</b> 。 这是用户在创建标签时将在界面中看到的名称： <br><br><img src="https://habrastorage.org/webt/jf/lk/-g/jflk-glzt0dahft6vpdx9qrzy8q.png"><br><br>  <b>2.示例值</b> 。 这向用户提示要在字段中输入哪些值： <br><br><img src="https://habrastorage.org/webt/b6/zz/sc/b6zzscielm1pjho74x22rk88c0c.png"><br><br>  <b>3.帮助文本</b> 。 这是用户将鼠标悬停在元素的帮助图标上时将看到的文本： <br><br><img src="https://habrastorage.org/webt/nv/wo/qr/nvwoqraide7hp-qrbdjaomwvg3e.png"><br><br>  <b>4.数据验证规则</b> 。 在此属性中，您可以设置某些规则来检查用户在字段中输入的数据，并在必要时设置尝试使用未通过测试的数据保存标签时显示的错误文本。 <br><br> 例如，您可以指定必须填写该字段。 第二个示例：您需要从用户那里获取电子邮件地址，然后可以验证用户输入的数据必须与正则表达式<b>。* @。* \ .. *</b>匹配。 <br><br><img src="https://habrastorage.org/webt/3s/ma/pb/3smapbl1aorsc4fsvhwpd-1oy4m.png"><br><br> 要指定在输入的数据不符合验证规则时出现的错误文本，您需要激活高级规则设置： <br><br><img src="https://habrastorage.org/webt/kb/zw/qr/kbzwqr32irigkreu9bbht9fxf1m.png"><br><br><img src="https://habrastorage.org/webt/ek/xh/hg/ekxhhgobsta59wpr6uxsbaqzdwg.png"><br><br> 另外，在高级设置中，您可以指定激活此规则的条件（“启用条件”字段）。 <br><br>  <b>5.纳入条款</b> 。 这些是用户拥有此界面元素的条件。 <br><br> 例如，为了不使模板中的界面元素超载，可以在选中复选框时使必要元素的外观。 也就是说，假设用户想要以像素为单位配置产品数据的传输（使用网站上配置的高级Google电子商务网站可以实现），那么他选中“使用dataLayer传输产品数据”复选框，并在选中该复选框后，元素将出现在标签界面中需要配置这样的传输。 如果未选中该框，则界面中没有元素。 <br><br><img src="https://habrastorage.org/webt/rp/ui/x_/rpuix__y-ya--_uat8taekcwpa0.png"><br><br> 我注意到在这里有必要指出元素的名称，在添加之后必须立即为其赋值。 <br><br> 添加设置并创建界面时，可以在预览窗口中立即查看和测试所有更改： <br><br><img src="https://habrastorage.org/webt/df/bl/l9/dfbll9mc0qvpwcxnbzzx-fbg71g.png"><br><br><a name="5"></a><h3> 代码标签 </h3><br> 此选项卡是代码编辑器。 <br><br>  GTM自定义模板代码是用精简的JavaScript ES6编写的，并在隔离的环境中运行，在该环境中，所有与全局数据（即直接与页面）的通信都是通过API完成的。 也没有分别使用常规方法的全局对象，例如窗口或文档。 例如，构造函数（新对象等），setTimeout，parseInt，delete等。  -所有这些都无法在“自定义模板”中使用。 <br><br> 但是所有这些都有一个API。 因此，编写自定义模板的代码应首先定义我们将在代码中使用的API： <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// API //     const copyFromWindow = require('copyFromWindow'); //     const setInWindow = require('setInWindow'); //      const injectScript = require('injectScript'); //    const callInWindow = require('callInWindow'); //  ,     ,    const makeTableMap = require('makeTableMap'); //   URL  const getUrl = require('getUrl'); //    const getQueryParameters = require('getQueryParameters'); //     const makeInteger = require('makeInteger'); //    const makeString = require('makeString'); //  setTimeout const callLater = require('callLater'); //  console.log const logToConsole = require('logToConsole');</span></span></code> </pre> <br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google Developer Help，以获取</a> API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>完整列表以及详细文档。 <br><br> 我将向您展示如何使用API​​的示例： <br><div class="scrollable-table"><table><tbody><tr><th> 动作说明 </th><th> 经典js </th><th> 自定义模板API </th></tr><tr><td> 控制台输出 </td><td>  console.log（'嗨'）; </td><td>  logToConsole（'Hi'）; </td></tr><tr><td> 设定计时器 </td><td>  setTimeout（函数，100）; </td><td>  callLater（函数）； </td></tr><tr><td> 转换为字符串 </td><td> 字符串（1234）; </td><td>  makeString（1234）; </td></tr><tr><td> 转换为整数 </td><td>  parseInt（'1234'，10）; </td><td>  makeInteger（'1234'）; </td></tr><tr><td> 页面主机 </td><td>  window.location.hostname </td><td>  getUrl（'host'）; </td></tr></tbody></table></div><br> 从示例表中可以看到，定义API后，必须使用它而不是标准JS构造。 <br><br> 定义API之后，最好使用用户输入的设置来定义对象。 例如，这也可以在可执行代码期间从用户的设置中请求必要的数据之后完成。 但是，如果我们从一开始就定义设置对象，那么使用代码将变得更加容易和易于理解，因为所有用户设置都存储在单独的对象中。 <br><br> 要从接口元素获取数据，必须使用数据构造。 <br><br>  {{元素名称}}： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const settings = { //  event: data.event, //ID  () pixelIDs: data.pixelIDs, //ID - (  1 -) priceListId: data.priceListId, //   -? fewPriceLists: data.fewPriceLists, //ID - (    ) priceListIds: data.priceListIds === undefined ? data.priceListIds : makeTableMap(data.priceListIds,'hostname','priceListId'), //  ecommerce   ? ecommerceUse: data.ecommerceUse, // ecommerce   eventEcommerce: data.eventEcommerce, //     siteSearchQueryParam: data.siteSearchQueryParam };</span></span></code> </pre><br> 注意：如果将undefined传递给makeTableMap方法，将导致脚本错误，因此我使用带有三元运算符的构造（if-else构造的缩写记录）来过滤掉此类脚本。 <br><br><div class="spoiler">  <b class="spoiler_title">关于makeTableMap方法。</b> <div class="spoiler_text"> 如果接口使用扩展表，则其中的数据将以以下形式存储： <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>}, <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'v2'</span></span>} ]</code> </pre><br> 使用makeTableMap方法处理后，数据将成为具有键值对的常规对象： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">'k1'</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-string"><span class="hljs-string">'k2'</span></span>: <span class="hljs-string"><span class="hljs-string">'v2'</span></span> }</code> </pre><br></div></div><br> 自定义模板代码的另一个要求：如果成功执行了标记，则必须调用data.gtmOnSuccess（）方法，如果发生错误，请调用data.gtmOnFailure（）方法。 <br><br> 例如，在我的代码中，成功发送请求后，将调用data.gtmOnSuccess（）方法，如果在外部脚本页面VK openapi.js上下载失败，则将调用data.gtmOnFailure（）方法。 <br><br> 在定义了API并使用设置定义了对象之后，您可以开始编写用于计算像素的算法。 <br><br> 这里要记住的主要事情是： <br><br>  •如果需要获取全局变量，请使用copyFromWindow API方法。 <br><br><pre> <code class="javascript hljs">copyFromWindow(<span class="hljs-string"><span class="hljs-string">'VK'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//VK -   ,    </span></span></code> </pre><br>  •如果需要设置全局变量，则使用setInWindow API方法。 <br><br><pre> <code class="javascript hljs">setInWindow(<span class="hljs-string"><span class="hljs-string">'openapiInject'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//openapiInject -   ,    //1 - ,    .</span></span></code> </pre><br>  •如果您需要运行全局函数，请使用callInWindow API方法。 <br><br><pre> <code class="javascript hljs">callInWindow(<span class="hljs-string"><span class="hljs-string">'VK.Retargeting.Init'</span></span>, p); <span class="hljs-comment"><span class="hljs-comment">//VK.Retargeting.Init -   ,    //p - ,     </span></span></code> </pre><br>  •如果需要在页面上添加外部脚本，请使用injectScript API方法。 <br><br><pre> <code class="javascript hljs">injectScript(<span class="hljs-string"><span class="hljs-string">'https://vk.com/js/api/openapi.js?159'</span></span>, pixel.setVkAsyncInit(), data.gtmOnFailure, <span class="hljs-string"><span class="hljs-string">'vkPixel'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//https://vk.com/js/api/openapi.js?159 -  ,      //pixel.setVkAsyncInit() - ,        //data.gtmOnFailure - ,        //vkPixel -  ,  ,   URL  .    ,   JavaScript      </span></span></code> </pre><br>  •如果需要获取URL（或URL的一部分），请使用getUrl API方法。 <br><br><pre> <code class="javascript hljs">getUrl(<span class="hljs-string"><span class="hljs-string">'host'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//host -  URL,  .  ,  host: protocol, port, path, extension, fragment, query.</span></span></code> </pre><br> 如我上面所写，自定义模板支持JS ES6。 建议使用此语法，因为它可以缩短代码并使代码更易读，并且JS的工作更可预测且类似于其他编程语言。 <br><br><div class="spoiler">  <b class="spoiler_title">有关JS ES6语法的更多信息</b> <div class="spoiler_text"> 需要使用的主要功能是箭头函数和const的声明，并让变量而不是var。 <br><br> 通过const声明的变量是一个常量，其值不能更改。 <br><br> 通过let声明的变量与通过var声明的变量不同，如下所示： <br><br><ul><li>  let不添加到全局窗口对象； </li><li> 让可见性仅限于声明块； </li><li> 通过let声明的变量无法重新声明。 </li></ul><br> 箭头功能是常用功能的缩写： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//1.   const func1 = function() { return 'test'; } //    const func1 = () =&gt; 'test'; //2.   const func2 = function(arg) { if (arg &gt; 0) return 'plus'; else return 'minus'; } //    const func2 = arg =&gt; { if (arg &gt; 0) return 'plus'; else return 'minus'; } //3.   const func3 = function(arg1, arg2){ if (arg1 &gt; arg2) return arg1; else return arg2; } //    const func3 = (arg1, arg2) =&gt; { if (arg1 &gt; arg2) return arg1; else return arg2; }</span></span></code> </pre><br></div></div><br> 现在，我们了解了如何使用自定义模板API，可以使用JavaScript ES6语法编写标签操作代码。 <br><br> 我的代码包含以下方法：启动像素，安装VK openapi.js，从dataLayer（配置了Google的高级电子商务网站）中检索产品数据，处理这些数据，使其转化为发送给VKontakte重定向像素所需的格式，以及事件分配方法。 <br><br> 像素触发方法支持三种情况： <br><br><ol><li> 像素在缺少openapi.js的页面上运行。 </li><li> 该像素在存在openapi.js的页面上运行，但尚未加载。 </li><li> 在加载了openapi.js的页面上启动像素。 </li></ol><br><div class="spoiler">  <b class="spoiler_title">我的VKontakte动态重定向像素的自定义GTM模板的完整代码</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//api const copyFromWindow = require('copyFromWindow'); const setInWindow = require('setInWindow'); const injectScript = require('injectScript'); const callInWindow = require('callInWindow'); const makeTableMap = require('makeTableMap'); const getUrl = require('getUrl'); const getQueryParameters = require('getQueryParameters'); const makeInteger = require('makeInteger'); const makeString = require('makeString'); const callLater = require('callLater'); //    const settings = { event: data.event, pixelIDs: data.pixelIDs, priceListId: data.priceListId, fewPriceLists: data.fewPriceLists, priceListIds: data.priceListIds === undefined ? data.priceListIds : makeTableMap(data.priceListIds,'hostname','priceListId'), ecommerceUse: data.ecommerceUse, eventEcommerce: data.eventEcommerce, siteSearchQueryParam: data.siteSearchQueryParam }; //       const pixel = { //    getPageHostname: () =&gt; getUrl('host'), //    VK getVK: () =&gt; copyFromWindow('VK'), //    VK setVkAsyncInit: () =&gt; { setInWindow('vkAsyncInit', pixel.sendEvent); }, //       getSiteSearchPhrase: () =&gt; { if (settings.event === 'view_search') return getQueryParameters(settings.siteSearchQueryParam); else return undefined; }, //      getEventParams: (products, currencyCode, revenue) =&gt; { let eventParamsClean= {}; let eventParams = { products: eventProducts.getProductParams(products), category_ids: eventProducts.getCategoryString(products), currency_code: currencyCode, total_price: eventProducts.getTotalPrice(products, revenue), search_string: pixel.getSiteSearchPhrase() }; if (eventParams.products !== undefined) eventParamsClean.products = eventParams.products; if (eventParams.category_ids !== undefined) eventParamsClean.category_ids = eventParams.category_ids; if (eventParams.currency_code !== undefined) eventParamsClean.currency_code = eventParams.currency_code; if (eventParams.total_price !== undefined) eventParamsClean.total_price = eventParams.total_price; if (eventParams.search_string !== undefined) eventParamsClean.search_string = eventParams.search_string; return eventParamsClean; }, //  - getPriceListId: hostname =&gt; { if (settings.fewPriceLists) return settings.priceListIds[hostname]; else return settings.priceListId; }, //  openapi.js openapiInit: () =&gt; { injectScript('https://vk.com/js/api/openapi.js?159', pixel.setVkAsyncInit(), data.gtmOnFailure, 'vkPixel'); setInWindow('openapiInject', 1); }, //   sendEvent: () =&gt; { if (settings.event === 'hit') { settings.pixelIDs.split(',').forEach(p =&gt; { callInWindow('VK.Retargeting.Init',p); callInWindow('VK.Retargeting.Hit'); }); } else { const pricelist = pixel.getPriceListId(pixel.getPageHostname()); const name = settings.event; let products = []; if(settings.ecommerceUse) products = name === 'view_home' || name === 'view_category' || name === 'view_search' || name === 'view_other' ? settings.eventEcommerce : settings.eventEcommerce.products; else products = undefined; const currencyCode = settings.ecommerceUse ? settings.eventEcommerce.currencyCode : undefined; const revenue = (settings.ecommerceUse &amp;&amp; name === 'purchase') ? settings.eventEcommerce.actionField.revenue : undefined; const eventParams = settings.ecommerceUse ? pixel.getEventParams(products, currencyCode, revenue) : undefined; settings.pixelIDs.split(',').forEach(p =&gt; { callInWindow('VK.Retargeting.Init',p); callInWindow('VK.Retargeting.ProductEvent', pricelist, name, eventParams); }); }, //   start: () =&gt; { if (pixel.getVK() === undefined &amp;&amp; copyFromWindow('openapiInject') !== 1) { pixel.openapiInit(); data.gtmOnSuccess(); } else if (pixel.getVK() === undefined &amp;&amp; copyFromWindow('openapiInject') === 1) { if (pixel.count &lt; 50) { callLater(pixel.start); pixel.count++; } else return; } else { pixel.sendEvent(); data.gtmOnSuccess(); }, //   count: 0 }; //       const eventProducts = { //    products   getProductParams: products =&gt; { let arr = []; products.forEach(i =&gt; { let productParamsClean = {}; let productParams = { id: makeString(i.id), group_id: makeString(i.brand), price: makeInteger(i.price * 100) / 100 }; if (productParams.id !== 'undefined') productParamsClean.id = productParams.id; if (productParams.group_id !== 'undefined') productParamsClean.group_id = productParams.group_id; if (productParams.price !== 0) productParamsClean.price = productParams.price; arr.push(productParamsClean); }); return arr; }, //       'a,b,c'       getCategoryString: products =&gt; { let categoryId = ''; let check = []; products.forEach(i =&gt; { if(check.indexOf(i.category) === -1) { check.push(i.category); categoryId += ',' + i.category; }); return categoryId.slice(1); }, //     getTotalPrice: (products, revenue) =&gt; { let sumPrice = 0; if (revenue !== undefined ) return makeInteger(revenue * 100) / 100; else { products.forEach(i =&gt; { if (i.hasOwnProperty('quantity')) sumPrice += (makeInteger(i.price * 100) / 100) * makeInteger(i.quantity); else sumPrice += makeInteger(i.price * 100) / 100; }); return sumPrice; }; //  pixel.start();</span></span></code> </pre> <br></div></div><br><a name="6"></a><h2> 权限标签 </h2><br> 编写完标记代码后，最后阶段仍然存在-发出与页面的全局数据进行交互的权限。 只需在“权限”选项卡上即可完成。 <br><br> 由于代码是在隔离的环境中执行的，并且通过API与全局数据进行交互，因此对于每种API方法（必要时），我们需要手动指定某些操作的权限。 <br><br> 这样做是为了尽可能审慎地使用全局页面数据，从而最大程度地减少了将网站“放入”模板代码错误的机会。 <br><br> 对于我的代码中使用的API方法，必须发出三种类型的权限： <br><br><img src="https://habrastorage.org/webt/29/og/lw/29oglwyra6zkhac7_2lr4jpqq5a.png"><br><br>  <b>1.访问全局变量</b> -读取，写入，执行对我们代码中使用的全局变量的访问。 必须手动添加变量，并且每个变量都指示我们允许执行的操作。 <br><br><img src="https://habrastorage.org/webt/f3/qb/6b/f3qb6b9sj6rn1v4q55t_z9f362e.png"><br><br> 例如，只能读取VK变量，可以读取和重新定义vkAsyncInit，并且只能执行VK.Retargeting.Hit方法。 <br><br>  <b>2.读取URL</b> 。 在这里，您必须指定允许接收URL的哪些部分。 我允许接收URL的任何部分： <br><br><img src="https://habrastorage.org/webt/do/um/li/doumlixqd-rw2cppm4ordw1svae.png"><br><br> 但是，如果您愿意，可以指定任何特定的： <br><br><img src="https://habrastorage.org/webt/sj/d3/ne/sjd3nefe52_foeat88kifeodi-w.png"><br><br>  <b>3.注入脚本</b> 。 在此必须注册可从中下载外部脚本的地址。 在我的代码中，仅加载了一个带有VK openapi.js的脚本，我指定了其地址： <br><br><img src="https://habrastorage.org/webt/xt/oy/hd/xtoyhd-yprd2sn_eu41mbquh2s0.png"><br><br> 就是这样，自定义模板设置已完成，您可以保存模板并进行测试。 <br><br><a name="7"></a><h2> 在创建的自定义模板上自定义和测试标签 </h2><br> 例如，我们将使用创建的自定义模板创建两个“ VKontakte”动态重定向标签：pageview和addToCart。 <br><br><a name="8"></a><h3> 浏览量 </h3><br> 我们将进入必要的GTM容器，创建一个新标签，然后在“自定义”部分中选择标签类型VK Pixel： <br><br><img src="https://habrastorage.org/webt/gd/s-/fi/gds-fi0tqxxcmfkkccsi8trowq4.png"><br><br> 填写标签名称，选择要跟踪的事件，选择“命中”（这是标准的网页浏览量），在“像素ID”字段中，将数据发送到的两个像素的ID，然后设置“所有页面”触发器： <br><br><img src="https://habrastorage.org/webt/vr/op/-0/vrop-0cjfqndkh35qnbtdsoxpc4.png"><br><br> 保存创建的标签。 <br><br><a name="9"></a><h3> 加入购物车 </h3><br> 为将产品添加到购物车的事件创建标签比点击标签要复杂一些。 <br><br> 首先，您需要转移添加到购物篮中的货物。 正如我在上文所述，通过在网站上配置Google的高级电子商务，这是有可能的。 在这种情况下，产品数据取自dataLayer。 <br><br> 为此，我们需要在GTM中创建dataLayer变量，该变量将存储addToCart事件的电子商务对象。 变量设置如下所示： <br><br><img src="https://habrastorage.org/webt/ko/r5/gu/kor5gumudjjzs9groemuo7nepco.png"><br><br> 其次，您需要创建一个触发器，该触发器将在电子商务addToCart事件发生时激活标签（当addToCart事件发生时，在推入dataLayer时，触发器将激活标签）： <br><br><img src="https://habrastorage.org/webt/og/xl/lt/ogxlltp_4_spurvq8fesqg3uy0m.png"><br><br> 在使用电子商务对象和触发器创建变量后，您可以开始创建代码： <br><br><img src="https://habrastorage.org/webt/dp/qg/zq/dpqgzqb27rcdydnjeen5fftp6ba.png"><br><br> 为了： <br><br><ol><li> 作为跟踪事件，选择“添加到购物车”。 </li><li> 我们填写两个像素的逗号分隔ID，必须将数据传输到其中。 </li><li> 设置复选框“使用多个价格表”：在我们的示例中，对于莫斯科和圣彼得堡，必须使用不同的价格表。 </li><li> 用价格表填写表格。 </li><li> 设置复选框“使用电子商务转移产品和参数”。 </li><li> 在此事件的电子商务对象中，指定先前创建的变量。 </li><li> 我们为受监控事件设置触发器，在本例中为AddToCart。 </li><li> 保存。 </li></ol><br><a name="10"></a><h3> 采矿测试 </h3><br> 要检查VKontakte上动态重定向的像素值，您需要在GTM中激活预览模式，请访问我们的网站并在浏览器控制台中打开“网络”部分，然后在“过滤器”字段中输入“ rtrg”： <br><img src="https://habrastorage.org/webt/ci/m9/z8/cim9z824mbc9dfvdz-4425fe02w.png"><br><br> 之后，我们刷新页面，并且应该有两个请求-以两个像素发送的Hit事件： <br><br><img src="https://habrastorage.org/webt/o0/5x/80/o05x80jeypiwcogusca_zgsnaju.png"><br><br> 状态200表示服务器已成功发送和接收请求。 <br><br> 同样在“预览GTM”窗口中，我们看到我们创建的标记对于“页面查看”事件正常工作。 <br><br> 要检查“添加到购物车”事件，请将产品添加到购物车，在控制台中，我们还有两个请求： <br><br><img src="https://habrastorage.org/webt/wt/jm/-k/wtjm-k50mmapqa1xtyva_yd3wcc.png"><br><br> 在“预览GTM”窗口中，我们看到第二个标签成功运行。 来自dataLayer的产品数据被正确提取并处理，正确的价格表也被替换。 <br><br> 对于第二个主机，价格表也可以正确替换： <br><br><img src="https://habrastorage.org/webt/n3/de/h3/n3deh30jep61h2kv9zefwruu8cy.png"><br><br> 其他事件的标签以相同的方式配置和检查。 <br><br><a name="11"></a><h2> 结论 </h2><br> 自定义模板正在改变使用GTM的熟悉范例。 每个人都习惯了HTML标签和JS变量，但是现在有一个很好的选择。 <br><br> 一次创建一个高质量的自定义模板就足够了，然后熟悉GTM的任何人都可以使用它。 <br><br> 鉴于可以共享创建的模板的功能，我认为它们应该在用户中越来越受欢迎。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>我们在本文中研究过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> VKontakte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义</a>动态重定向像素<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板</a> 。 <br><br> 要导入模板，您需要创建一个新的自定义模板，然后从菜单中选择导入： <br><br><img src="https://habrastorage.org/webt/mx/nn/jc/mxnnjc0419poxmshokabjcgeoye.png"><br><br>  <i>我为ppc.world准备的材料</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458788/">https://habr.com/ru/post/zh-CN458788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458774/index.html">功能数据库管理系统</a></li>
<li><a href="../zh-CN458778/index.html">Satellite 6.5报告引擎：什么以及为什么</a></li>
<li><a href="../zh-CN458782/index.html">通过现代手段将ZX Spectrum的程序改编为TR-DOS。 第三部分</a></li>
<li><a href="../zh-CN458784/index.html">从Altium Designer到PADS Professional广播项目和库</a></li>
<li><a href="../zh-CN458786/index.html">视频游戏管理员逐步保持游戏文化</a></li>
<li><a href="../zh-CN458790/index.html">CatBoost简介。 Yandex报告</a></li>
<li><a href="../zh-CN458792/index.html">“疲倦”的员工：有没有出路？</a></li>
<li><a href="../zh-CN458794/index.html">7月18日在Redmadrobot举行的业务分析师会议</a></li>
<li><a href="../zh-CN458796/index.html">如何为繁重的工作量做好站点准备：5个实用技巧和有用工具</a></li>
<li><a href="../zh-CN458798/index.html">营养机器人或我想如何从健身教练那里拿面包</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>