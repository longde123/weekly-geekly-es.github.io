<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵 👴🏾 😙 Wechseln Sie zu Next.js und beschleunigen Sie das Laden der Manifold.co-Homepage um das 7,5-fache 👎🏿 🏰 🕣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir eine Übersetzung einer Geschichte darüber, wie der Übergang von React Boilerplate zu Next.js , einem Framework für die Entwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wechseln Sie zu Next.js und beschleunigen Sie das Laden der Manifold.co-Homepage um das 7,5-fache</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442654/">  Heute veröffentlichen wir eine Übersetzung einer Geschichte darüber, wie der Übergang von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React Boilerplate</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Next.js</a> , einem Framework für die Entwicklung fortschrittlicher Webanwendungen auf der Basis von React, das Laden der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homepage</a> des Manifold.co-Projekts um das 7,5-fache beschleunigt hat.  Es wurden keine weiteren Änderungen am Projekt vorgenommen, und dieser Übergang erwies sich im Allgemeinen als für andere Teile des Systems völlig unsichtbar.  Was sich am Ende herausstellte, erwies sich als noch besser als erwartet. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ci/bc/g5/cibcg5cgvkbkyimgtleiv21hmgy.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ergebnisübersicht</font> </h2><br>  Tatsächlich können wir sagen, dass der Übergang zu Next.js uns so etwas wie eine „Steigerung der Projektproduktivität, die aus dem Nichts kam“ brachte.  So sieht die Ladezeit des Projekts aus, wenn verschiedene Hardwareressourcen und Netzwerkverbindungen verwendet werden. <br><table><tbody><tr><td>  Verbindung <br></td><td width="130">  CPU <br></td><td width="130">  Zu Sekunden <br></td><td width="130">  Nach Sekunden <br></td><td width="130">  % Verbesserung <br></td></tr><tr><td>  Schnell (200 Mbit / s) <br></td><td>  Schnell <br></td><td>  1.5 <br></td><td>  0,2 <br></td><td>  750 <br></td></tr><tr><td>  Medium (3G) <br></td><td>  Schnell <br></td><td>  5.6 <br></td><td>  1.1 <br></td><td>  500 <br></td></tr><tr><td>  Medium (3G) <br></td><td>  Mittel <br></td><td>  7.5 <br></td><td>  1.3 <br></td><td>  570 <br></td></tr><tr><td>  Langsam (langsame 3G-Verbindung) <br></td><td>  Mittel <br></td><td>  22 <br></td><td>  4 <br></td><td>  550 <br></td></tr></tbody></table><br>  Bei Verwendung einer Schnellverbindung und eines Geräts mit einem schnellen Prozessor verringerte sich die Ladezeit des Standorts von 1,5 s.  bis zu 0,2 s, dh dieser Indikator verbesserte sich um das 7,5-fache.  Bei einer Verbindung mittlerer Qualität und einem Gerät mit durchschnittlicher Leistung verringerte sich die Ladezeit des Standorts von 7,5 s.  bis zu 1,3 s <br><br><h2>  <font color="#3AC1EF">Was passiert, wenn ein Benutzer auf eine URL klickt?</font> </h2><br>  Um die Funktionen der Arbeit von progressiven Webanwendungen (Progressive Web App, PWA) zu verstehen, müssen Sie zunächst herausfinden, was zwischen dem Zeitpunkt, zu dem der Benutzer die URL (an der Adresse unserer Website) aufruft, und dem Zeitpunkt, zu dem er etwas sieht, geschieht in einem Browserfenster (in diesem Fall unsere React-Anwendung). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c6/f9b/060/8c6f9b060a4fd4ff13cd525b62c98477.jpg"></div><br>  <i><font color="#999999">Anwendungsstufen</font></i> <br><br>  Betrachten Sie die 5 Phasen der Arbeit mit der Anwendung, deren Diagramm oben angegeben ist. <br><br><ol><li>  Der Benutzer geht zur URL, das System ermittelt die Serveradresse über DNS und greift auf den Server zu.  All dies ist extrem schnell erledigt, normalerweise dauert es weniger als 100 Millisekunden, aber dieser Schritt dauert einige Zeit, weshalb er hier erwähnt wird. </li><li>  Jetzt gibt der Server den HTML-Code der Seite zurück, aber die Seite im Browser bleibt leer, bis die für die Anzeige erforderlichen Ressourcen geladen sind (es sei denn, die Ressourcen werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asynchron</a> geladen).  Tatsächlich finden zu diesem Zeitpunkt mehr Aktionen statt als in der Abbildung dargestellt, aber eine gemeinsame Überprüfung all dieser Prozesse wird uns auch gefallen. </li><li>  Nach dem Laden des HTML-Codes und der wichtigsten Ressourcen zeigt der Browser an, was angezeigt werden kann, und lädt weiterhin alles andere (z. B. Bilder) im Hintergrund.  Haben Sie sich jemals gefragt, warum Bilder manchmal plötzlich schneller als nötig auf einer Seite „auftauchen“ und manchmal zu lange geladen werden?  Genau deshalb passiert dies.  Mit diesem Ansatz können Sie schnell eine fertige Seite erstellen. </li><li> JavaScript-Code kann erst nach dem Laden analysiert und ausgeführt werden.  Abhängig von der Größe des auf der Seite verwendeten JS-Codes (und dies kann für eine typische React-Anwendung sehr groß sein, wenn der Code in einer einzelnen Datei gepackt ist) kann dies einige Sekunden oder sogar länger dauern (beachten Sie, dass JS Der Code muss nicht auf das Laden aller anderen Ressourcen warten, um mit der Ausführung zu beginnen, obwohl er im Diagramm genau so aussieht. </li><li>  Im Fall einer React-Anwendung kommt jetzt der Moment, in dem der Code das DOM ändert, wodurch der Browser die bereits angezeigte Seite neu zeichnet.  Dann beginnt ein weiterer Zyklus zum Laden von Ressourcen.  Die Zeit, die dieser Schritt benötigt, hängt von der Komplexität der Seite ab. </li></ol><br><h2>  <font color="#3AC1EF">Je schneller, desto besser.</font> </h2><br>  Da eine progressive Webanwendung React-Code verwendet und statischen HTML- und CSS-Code erzeugt, bedeutet dies, dass der Benutzer die React-Anwendung bereits in Schritt 3 des obigen Schemas und nicht in Schritt 5 sieht. In unseren Tests dauert dies 0,2 bis 4 Sekunden Dies hängt von der Geschwindigkeit der Verbindung des Benutzers mit dem Internet und seinem Gerät ab.  Dies ist viel besser als die vorherigen 1,5-22 Sekunden.  Progressive Webanwendungen sind eine zuverlässige Möglichkeit, React-Anwendungen schneller an den Benutzer zu liefern. <br><br>  Der Grund, warum progressive Webanwendungen und verwandte Frameworks wie Next.js immer noch nicht sehr beliebt sind, liegt darin, dass JS-Frameworks traditionell keinen besonders erfolgreichen statischen HTML-Code generieren.  Heute hat sich alles sehr verändert, da Frameworks wie React, Vue und Angular und andere das serverseitige Rendern hervorragend unterstützen.  Um diese Tools verwenden zu können, benötigen Sie jedoch noch ein tiefes Verständnis der Funktionen der Arbeit von Bundlern und Projektassemblierungswerkzeugen.  Die Arbeit mit all dem ist nicht ohne Probleme. <br><br>  Das jüngste Aufkommen von PWA-Frameworks wie Next.js und Gatsby (beide erschienen Ende 2016 - Anfang 2017) ist aufgrund der geringeren Eintrittsbarrieren und der Tatsache, dass die Verwendung solcher Frameworks eine einfache und unterhaltsame Aufgabe war, zu einem ernsthaften Schritt in Richtung einer breiten Akzeptanz von PWA geworden. <br><br>  Obwohl nicht jede Anwendung auf Next.js übertragen werden kann, bedeutet dieser Übergang für viele React-Anwendungen dieselbe „Leistung aus dem Nichts“, von der wir hier sprechen, ergänzt durch eine noch effizientere Nutzung der Netzwerkressourcen. <br><br><h2>  <font color="#3AC1EF">Wie schwierig ist die Migration zu Next.js?</font> </h2><br>  Im Allgemeinen ist festzustellen, dass die Übersetzung unserer Homepage in Next.js nicht sehr schwierig war.  Wir sind jedoch auf einige Schwierigkeiten gestoßen, die durch die Architekturfunktionen unserer Anwendung verursacht wurden. <br><br><h3>  <font color="#3AC1EF">▍ Ablehnen eines React Routers</font> </h3><br>  Wir mussten den React-Router aufgeben, da Next.js über einen eigenen integrierten Router verfügt, der besser mit Optimierungen hinsichtlich der Codetrennung kombiniert werden kann, die zusätzlich zur PWA-Architektur durchgeführt werden.  Auf diese Weise kann dieser Router viel schneller Seiten laden, als Sie es von einem clientseitigen Router erwarten würden. <br><br>  Der Next.js-Router ist ein bisschen wie ein Hochgeschwindigkeits-React-Router, aber immer noch kein React-Router. <br><br>  In der Praxis bestand der Übergang zum Next.js-Router für uns darin, einfach die Standardkomponente des React-Routers durch die entsprechende Next.js-Komponente zu ersetzen, da wir die besonders erweiterten Funktionen des React-Routers nicht genutzt haben: <br><br><pre><code class="plaintext hljs">/*   ( React) */ &lt;Link to="/my/page"&gt;  A link &lt;/Link&gt; /*   ( Next.js) */ &lt;Link href="/my/page" passHref&gt;  &lt;a&gt;    A link  &lt;/a&gt; &lt;/Link&gt;</code> </pre> <br>  Im Allgemeinen stellte sich heraus, dass alles nicht so schlecht war.  Wir mussten die Eigenschaft umbenennen und ein Tag für Server-Rendering-Zwecke hinzufügen.  Da wir auch die Bibliothek mit den <code>styled-components</code> verwendet haben, stellte sich heraus, dass wir in den meisten Fällen die <code>passHref</code> Eigenschaft hinzufügen <code>passHref</code> , um sicherzustellen, dass sich das System so verhält, dass <code>href</code> immer auf das generierte Tag verweist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/5dd/e79/d7c5dde797101c30c2cf0e6507e07881.png"></div><br>  <i><font color="#999999">Netzwerkanfragen für vielfältig.co</font></i> <br><br>  Um die Optimierung des Next.js-Routers in Aktion mit eigenen Augen zu sehen, öffnen Sie die Registerkarte Netzwerk der Browser-Entwicklertools, indem Sie die Seite manifestold.co anzeigen und auf einen Link klicken.  Die vorherige Abbildung zeigt das Ergebnis des Klickens auf den Link <code>/services</code> .  Wie Sie sehen, führt dies zur Ausführung einer Anforderung zum Laden von <code>services.js</code> anstatt eine reguläre Anforderung auszuführen. <br><br>  Ich spreche nicht nur von clientseitigem Routing, der React-Router eignet sich auch zur Lösung dieses Problems.  Ich spreche von einem echten Stück JavaScript-Code, der aus dem Rest des Codes extrahiert und auf Anfrage geladen wurde.  Dies erfolgt mit dem Standard Next.js.  Und das ist viel besser als das, was wir vorher hatten.  Es handelt sich nämlich um ein großes Paket von JS-Code mit einer Größe von 1,7 MB, das der Client herunterladen und verarbeiten musste, bevor er etwas sehen konnte. <br><br>  Obwohl die hier vorgestellte Lösung nicht perfekt ist, ist sie der Idee, dass Benutzer nur Code für die von ihnen angezeigten Seiten herunterladen, viel näher als die vorherige. <br><br><h3>  <font color="#3AC1EF">▍ Funktionen zur Verwendung von Redux</font> </h3><br>  Wenn man das Thema der Schwierigkeiten fortsetzt, die mit dem Übergang zu Next.js verbunden sind, kann man feststellen, dass alle interessanten Optimierungen, die Next.js der Anwendung unterzieht, einen gewissen Einfluss auf diese Anwendung haben.  Da Next.js eine Codetrennung auf Seitenebene durchführt, kann der Entwickler nicht auf die <code>React</code> Stammkomponente oder die <code>render()</code> -Methode der <code>React</code> <code>react-dom</code> Bibliothek zugreifen.  Wenn Sie bereits an der Konfiguration von Redux beteiligt waren, können Sie feststellen, dass dies alles darauf hinweist, dass wir für den normalen Betrieb mit Redux das Problem lösen müssen, da nicht klar ist, wo genau nach Redux gesucht werden soll. <br><br>  Next.js bietet mit Redux eine spezielle Komponente höherer Ordnung, die als Wrapper für alle Komponenten der obersten Ebene auf jeder Seite fungiert: <br><br><pre> <code class="plaintext hljs">export default withRedux(HomePage);</code> </pre> <br>  Dies alles ist zwar nicht so schlimm, aber wenn Sie <code>createStore()</code> -Methoden benötigen, z. B. bei Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux-Reducer-Injektoren</a> , müssen Sie zusätzliche Zeit zum Debuggen des Wrappers benötigen (und versuchen Sie es übrigens nie Verwenden Sie so etwas wie <code>redux-reducer-injectors</code> . <br><br>  Aufgrund der Tatsache, dass Redux jetzt eine „Black Box“ ist, wird die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unveränderlichen</a> Bibliothek damit problematisch.  Obwohl die Tatsache, dass Immutable mit Redux funktioniert, ziemlich offensichtlich ist, bin ich auf ein Problem gestoßen.  Entweder war der Status der obersten Ebene nicht unveränderlich ( <code>get is not a function</code> ), oder die Wrapper-Komponente hat versucht, die Punktnotation für die Arbeit mit JS-Objekten anstelle der Methode <code>.get()</code> verwenden ( <code>Can't get catalog of undefined</code> Fehler <code>Can't get catalog of undefined</code> <code>.get()</code> werden).  Um dieses Problem zu beheben, musste ich auf den Quellcode verweisen.  Schließlich zwingt Next.js den Entwickler aus einem bestimmten Grund, seine eigenen Mechanismen zu verwenden. <br><br>  Im Allgemeinen kann festgestellt werden, dass das Hauptproblem bei Next.js darin besteht, dass nur sehr wenig in diesem Framework gut dokumentiert ist.  Es gibt viele Beispiele in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation,</a> auf deren Grundlage Sie etwas Eigenes erstellen können. Wenn es jedoch keines gibt, das die Merkmale Ihres Projekts widerspiegelt, können Sie nur viel Glück wünschen. <br><br><h3>  <font color="#3AC1EF">▍Abweisung abrufen</font> </h3><br>  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Inlinesvg-Bibliothek verwendet</a> , die Styling-Optionen für eingebettete SVG-Bilder und das Zwischenspeichern von Abfragen bietet.  Hier hatten wir jedoch ein Problem: Beim Ausführen des Server-Renderings gibt es keine XHR-Anforderungen (zumindest nicht im Sinne von URLs, die von Webpack generiert wurden, wie zu erwarten).  Versuche, solche Anforderungen auszuführen, beeinträchtigen das Rendern des Servers. <br><br>  Obwohl es andere Bibliotheken für die Arbeit mit eingebetteten SVG-Daten gibt, die SSR unterstützen, habe ich beschlossen, diese Funktion aufzugeben, da SVG-Dateien noch selten verwendet wurden.  Ich habe sie entweder durch normale Bilder, <code>&lt;img&gt;</code> -Tags, ersetzt, wenn ich beim Anzeigen der entsprechenden Bilder kein Styling benötigte, oder ich habe sie in Form von React JSX in den Code eingebettet.  Wahrscheinlich ist jetzt alles besser geworden, da die JSX-Illustrationen jetzt beim ersten Laden der Seite in den Browser kamen und das an den Client gesendete JS-Bundle 1 Bibliothek weniger hatte. <br><br>  Wenn Sie <code>next.config.js</code> verwenden <code>whatwg-fetch</code> (ich brauchte diese Funktion für eine andere Bibliothek), können Sie dies mit <code>next.config.js</code> konfigurieren, indem Sie <code>whatwg-fetch</code> und <code>node-fetch</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     plugins: config.plugins.concat([       new webpack.ProvidePlugin(         config.isServer           ? {}           : { fetch: 'imports-loader?this=&gt;global!exports-loader?global.fetch!whatwg-fetch' }       ),     ]),   resolve: Object.assign(config.resolve, {     alias: Object.assign(       config.resolve.alias,       config.isServer ? {} : { fetch: 'node-fetch' }     ),   }), }), };</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Client und Server JS</font> </h3><br>  Die letzte Funktion von Next.js, die ich hier erwähnen möchte, ist, dass dieses Framework zweimal gestartet wird - einmal für den Server und erneut für den Client.  Dadurch wird die Grenze zwischen clientseitigem JavaScript und Node.js-Code in derselben Codebasis leicht verwischt, was zu ungewöhnlichen Fehlern wie <code>fs is undefined</code> Dies <code>fs is undefined</code> wenn versucht wird, die Funktionen von Node.js auf dem Client zu nutzen. <br><br>  Daher müssen wir solche Konstruktionen in <code>next.js.config</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     node: config.isServer ? undefined : { fs: 'empty' },   }), };</code> </pre> <br>  Das Flag <code>config.isServer</code> in Webpack ist Ihr bester Freund, wenn Sie denselben Code in verschiedenen Umgebungen ausführen müssen. <br><br>  Darüber hinaus unterstützt Next.js zusätzlich zu den Standardmethoden für den Lebenszyklus von React-Komponenten die Methode <code>getInitialProps()</code> , die nur aufgerufen wird, wenn der Code im <code>getInitialProps()</code> wird: <br><br><pre> <code class="plaintext hljs">class HomePage extends React.Component { static getInitialProps() {   //         } componentDidMount() {   //     ,    } … }</code> </pre> <br>  Ja, und vergessen wir nicht, dass unser guter Freund, das <code>window</code> , das zum Organisieren des Abhörens von Ereignissen, zum Bestimmen der Größe des Browserfensters und zum Zugriff auf viele nützliche Funktionen erforderlich ist, in Node.js nicht verfügbar ist: <br><br><pre> <code class="plaintext hljs">if (typeof window !== 'undefined') { // ,     `window`      }</code> </pre> <br>  Es sollte beachtet werden, dass selbst Next.js den Entwickler nicht vor der Notwendigkeit bewahren kann, Probleme zu lösen, die mit der Ausführung desselben Codes auf dem Server und auf dem Client verbunden sind.  Bei der Lösung solcher Probleme sind <code>config.isServer</code> und <code>getInitialProps()</code> jedoch sehr nützlich. <br><br><h2>  <font color="#3AC1EF">Ergebnisse: Was passiert nach Next.js?</font> </h2><br>  Kurzfristig entspricht das Next.js-Framework hinsichtlich der Leistung perfekt unseren Anforderungen an das Server-Rendering und der Möglichkeit, unsere Website auf Geräten mit deaktiviertem JavaScript anzuzeigen.  Außerdem können Sie jetzt erweiterte (Rich-) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Tags verwenden</a> . <br><br>  Vielleicht werden wir in Zukunft andere Optionen in Betracht ziehen, falls unsere Anwendung sowohl Server-Rendering als auch komplexere Serverlogik benötigt (zum Beispiel prüfen wir die Möglichkeit der Implementierung der Single Sign-On-Technologie bei manifestold.co und dashboard.manifold.co )  Bis dahin werden wir jedoch Next.js verwenden, da dieses Framework mit geringen Zeitkosten enorme Vorteile brachte. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie Next.js in Ihren Projekten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442654/">https://habr.com/ru/post/de442654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442644/index.html">Die meisten Nicht-Programmierkenntnisse erhöhen den Entwicklerwert</a></li>
<li><a href="../de442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../de442648/index.html">Go-Zuweisungsmechanismen</a></li>
<li><a href="../de442650/index.html">Analyse und Optimierung von React-Anwendungen</a></li>
<li><a href="../de442652/index.html">Verwenden von Fastify und Preact zum schnellen Prototypen von Webanwendungen</a></li>
<li><a href="../de442658/index.html">8 Tricks für die Arbeit mit CSS: Parallaxe, Sticky Footer und andere</a></li>
<li><a href="../de442660/index.html">Mathematik versöhnt Newton mit der Quantenwelt</a></li>
<li><a href="../de442662/index.html">So sehen Sie SDDL und brechen sich nicht die Augen auf Semikolons</a></li>
<li><a href="../de442664/index.html">QIWI Kitchen 6. Februar - wie es war + Referentenpräsentationen</a></li>
<li><a href="../de442666/index.html">Post-Post, Meta-Meta. Wir lernen auf Habr zu schreiben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>