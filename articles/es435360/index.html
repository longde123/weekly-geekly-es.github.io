<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë©üèª üöä üèÇ Snippets vs Clover: supera el cuestionario en tiempo real m√°s popular üë¥üèæ üë®üèæ‚Äçüöí üëÉüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abril 2018. Ten√≠a 14 a√±os. Mis amigos y yo jugamos en el muy popular cuestionario en l√≠nea "Clover" de VKontakte. Uno de nosotros (generalmente yo) si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Snippets vs Clover: supera el cuestionario en tiempo real m√°s popular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  Abril 2018.  Ten√≠a 14 a√±os. Mis amigos y yo jugamos en el muy popular cuestionario en l√≠nea "Clover" de VKontakte.  Uno de nosotros (generalmente yo) siempre estaba detr√°s de una computadora port√°til para tratar de buscar r√°pidamente en Google preguntas y buscar en los resultados de b√∫squeda la respuesta correcta.  Pero de repente me di cuenta de que estaba haciendo lo mismo cada vez, y decid√≠ intentar escribirlo en Python 3, parcialmente conocido por m√≠ entonces. <br><br><h3>  Paso 0. ¬øQu√© est√° pasando aqu√≠? </h3><br>  Para empezar, actualizar√© en tu memoria la mec√°nica de "Clover". <br><br>  El juego para todos comienza al mismo tiempo, a las 13:00 y a las 20:00 hora de Mosc√∫.  Para jugar, debe ingresar a la aplicaci√≥n en este momento y conectarse a la transmisi√≥n en vivo.  El juego dura 15 minutos, durante los cuales se env√≠an preguntas a los participantes por tel√©fono <b>al mismo tiempo</b> .  La respuesta es de <b>10 segundos.</b>  Entonces se anuncia la respuesta correcta.  Todos los que adivinaron van m√°s all√°.  Hay 12 preguntas en total, y si responde a todas, recibir√° un premio en efectivo. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="imagen"><br>  Resulta que nuestra tarea es capturar instant√°neamente nuevas preguntas del servidor Clover, procesarlas a trav√©s de un motor de b√∫squeda y determinar la respuesta correcta en funci√≥n de los resultados de la b√∫squeda.  Se decidi√≥ enviar la respuesta en un bot de telegramas para que las notificaciones aparecieran en el tel√©fono durante el juego.  Y todo esto es deseable en un par de segundos, porque el tiempo de respuesta es muy limitado.  Si quieres ver c√≥mo un c√≥digo bastante simple, pero funcional (y mirar este ser√° √∫til para los principiantes) nos ayud√≥ a vencer a Clover, bienvenido al corte. <br><a name="habracut"></a><br><h3>  Paso 1. Obtenga preguntas del servidor </h3><br>  Al principio parec√≠a la etapa m√°s dif√≠cil.  Ya respir√© hondo y estaba listo para subir a la naturaleza como la visi√≥n por computadora, interceptar el tr√°fico o descompilar la aplicaci√≥n ... Cuando de repente me esperaba una sorpresa: ¬°Clover tiene una API abierta!  No est√° documentado en ninguna parte, pero si durante el juego, tan pronto como se hizo una pregunta a todos los jugadores, haga una solicitud en api.vk.com, a cambio recibiremos la pregunta y las opciones de respuesta en JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="imagen"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  Como access_token, es necesario transferir el token API de cualquier usuario de VKontakte, pero es importante que se haya emitido originalmente espec√≠ficamente para Clover.  Su app_id es 6334949. <br><br><h3>  Paso 2. Procesamos el problema a trav√©s de un motor de b√∫squeda. </h3><br>  Hab√≠a dos opciones: utilizar la API oficial del motor de b√∫squeda o agregar argumentos de b√∫squeda directamente a la barra de direcciones y analizar los resultados.  Al principio prob√© el segundo, pero no solo capt√© captcha, sino que tambi√©n perd√≠ mucho tiempo, porque las p√°ginas se cargaron en promedio en 2 segundos.  Y les recuerdo que es aconsejable que nos encontremos estos dos segundos.  Bueno, y lo principal: no obtuve textos grandes y estructurados de los motores de b√∫squeda sobre el tema necesario, ya que solo peque√±as piezas del material necesario, que se llaman <b>fragmentos,</b> cuelgan en la p√°gina de b√∫squeda: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  Entonces comenc√© a buscar una API.  Google no encajaba: sus soluciones eran muy limitadas y devolv√≠an muy pocos datos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.XML</a> result√≥ ser el m√°s generoso: le permite enviar 10,000 solicitudes por d√≠a, no m√°s de 5 por segundo, y devuelve datos muy r√°pidamente.  La solicitud es opcionalmente el n√∫mero de p√°ginas (hasta 100) y el n√∫mero de pasajes, valores especiales que se utilizan para formar fragmentos.  Obtenemos los datos en XML.  Sin embargo, estos son todos los mismos fragmentos. <br><br>  Para que pueda familiarizarse y jugar con lo que Yandex devuelve, aqu√≠ hay un ejemplo de una respuesta a la pregunta "¬øCu√°l es el nombre del antagonista principal en la serie de videos" The Legend of Zelda? ": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conducir</a> <br><br>  Tuve suerte, y result√≥ que en pypi, ya existe un m√≥dulo separado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de b√∫squeda yandex</a> para esto.  Entonces, trat√© de obtener la pregunta del servidor, encontrarla en Yandex, hacer un gran texto con fragmentos y dividirlo en oraciones: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          ¬´   ¬ª?', 'answers': [{'id': 0, 'users_answered': 0, 'text': '¬´ ¬ª'}, {'id': 1, 'users_answered': 0, 'text': '¬´ ¬ª'}, {'id': 2, 'users_answered': 0, 'text': '¬´¬ª'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Paso 3. Buscando respuestas </h3><br>  Inicialmente, la tarea de reconocer con precisi√≥n la respuesta seg√∫n los fragmentos me parec√≠a poco realista (le recuerdo que al momento de escribir el c√≥digo era un principiante absoluto).  Por lo tanto, decid√≠ simplificar primero la tarea que realizamos con una b√∫squeda manual. <br><br>  ¬øQu√© hicimos mis amigos y yo cuando dirigimos nuestra pregunta a un motor de b√∫squeda?  Comenzaron a buscar r√°pidamente a trav√©s de los ojos las respuestas en los resultados.  ¬øCu√°l es el problema con este enfoque?  En <s>las letras m√∫ltiples,</s> hay una gran cantidad de innecesarias, que no contienen informaci√≥n sobre respuestas, propuestas.  Buscar con mis ojos a veces tomaba mucho tiempo.  Por lo tanto, lo primero que decid√≠ hacer fue seleccionar todas las oraciones con una menci√≥n de cualquiera de las respuestas y mostrarlas para buscar la respuesta en un texto muy peque√±o que contenga con precisi√≥n la informaci√≥n que necesitamos. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Parece que obtienes las ofertas correctas, las lees y respondes correctamente.  ¬øPero qu√© pasa si no encontramos una sola oraci√≥n?  En este caso, decid√≠ recortar las palabras para no perderlas si est√°n en otro caso.  Y tambi√©n para capturar los que se forman a partir de la fuente.  En resumen, acabo de recortar su final en dos caracteres: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Pero incluso despu√©s de dicha red de seguridad, todav√≠a hubo casos en que la pista permaneci√≥ vac√≠a, simplemente porque los resultados no siempre tocaban las respuestas.  Diga, a la pregunta <i>"¬øCu√°l de estos escritores tiene una historia, llamada as√≠ como la canci√≥n del grupo Bi 2?"</i>  No se puede encontrar una respuesta exacta.  En este caso, recurr√≠ al enfoque opuesto: pregunt√© sobre las respuestas y deduje la opci√≥n en funci√≥n de la frecuencia con que se mencionan las palabras de la pregunta en los resultados. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  En este punto, el script gan√≥ funcionalidad b√°sica.  Y ahora, solo una semana y media despu√©s del lanzamiento de Clover, estamos sentados y ya jugando con un "truco" hecho a s√≠ mismo.  ¬°Deber√≠as haber visto nuestras caras con un amigo la primera vez que <b>ganamos el juego</b> leyendo sugerencias en la l√≠nea de comando como por arte de magia! <br><br><h3>  Paso 4. Mostrar respuestas claras </h3><br>  Pero pronto este formato est√° cansado.  Primero, ten√≠as que sentarte con una computadora port√°til cada juego.  En segundo lugar, mis amigos pidieron el script, y estoy cansado de explicar a todos c√≥mo insertar su token VKontakte, c√≥mo configurar Yandex.XML (est√° vinculado a IP, es decir, era necesario crear una cuenta para cada usuario del script) y c√≥mo instalar Python en la computadora. <br><br>  ¬°Ser√≠a mucho mejor si las respuestas aparecen en notificaciones autom√°ticas en el tel√©fono durante el juego!  ¬°Solo mir√© la parte superior de la pantalla y respond√≠ como est√° escrito en la notificaci√≥n push!  ¬°Y puede organizar esto para todos si crea su canal de telegramas para el gui√≥n!  Maravilloso! <br><br>  Pero simplemente mostrar las mismas oraciones en telegramas no es una opci√≥n.  Leerlos desde su tel√©fono es extremadamente inconveniente.  Por lo tanto, tuve que aprender el gui√≥n yo mismo para comprender qu√© respuesta es correcta. <br><br>  Importamos <b>telebot</b> y cambiamos todas <b>las</b> funciones <b>print ()</b> a <b>send_tg ()</b> y <b>notsure ()</b> , que usaremos en el √∫ltimo m√©todo, ya que falla un poco m√°s a menudo que otros: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  ¬°Y en ese momento, me di cuenta de que los fragmentos son mucho mejores que los textos largos!  Debido a que el motor de b√∫squeda est√° tratando de <b>dar una respuesta</b> a nuestra solicitud, y no solo para encontrar coincidencias en palabras.  Y tiene √©xito: los fragmentos a menudo conten√≠an las respuestas correctas que las incorrectas, es decir, no hab√≠a necesidad de analizar el texto.  Y yo, de hecho, no sab√≠a c√≥mo. <br><br>  As√≠ que somos simples para contar la menci√≥n de palabras en los resultados: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Lo que sucedi√≥ como resultado: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="imagen"><br><br><h3>  M√°s destino </h3><br>  Para ser justos, debo decir que no tuve √©xito en la m√°quina de la muerte.  En promedio, el bot respondi√≥ correctamente solo 9-10 de las 12 preguntas.  Es comprensible, porque hubo personas dif√≠ciles que no sucumbieron al an√°lisis de la b√∫squeda de Yandex.  Yo y mis amigos nos cansamos de pasar constantemente por encima de un par de preguntas y esperar un juego exitoso, en el que el robot finalmente responder√° todo correctamente.  No ocurri√≥ un milagro, ya no quer√≠a modificar el gui√≥n y, despu√©s de haber dejado de esperar una victoria f√°cil, abandonamos el juego. <br><br>  Con el tiempo, mi idea comenz√≥ a aparecer en la cabeza de otros j√≥venes desarrolladores.  Para la puesta de sol de 2018, hab√≠a al menos 10 bots y sitios que mostraban sus conjeturas sobre problemas en Clover.  La tarea no es tan dif√≠cil.  Pero lo que es sorprendente, ninguno de ellos ha cruzado la barra de 9-10 preguntas por juego, y luego todos cayeron a 7-8, como mi bot.  Aparentemente, los compiladores de las preguntas dejaron en claro c√≥mo componer las preguntas para que el trabajo de los motores de b√∫squeda fuera irrelevante. <br><br>  Desafortunadamente, el bot ya no se puede finalizar, porque el 31 de diciembre Clover pas√≥ la √∫ltima transmisi√≥n y no ten√≠a ninguna pregunta.  Sin embargo, fue una gran experiencia para un programador novato.  Y seguramente habr√≠a un gran desaf√≠o para el avanzado: solo imagine el d√∫o word2vec y text2vec, solicitudes asincr√≥nicas a Yandex, Google y Wikipedia al mismo tiempo, un clasificador avanzado de preguntas y un algoritmo para reformular la pregunta en caso de falla ... ¬°Eh!  Tal vez, por tales oportunidades, me encant√≥ este juego m√°s que por el juego en s√≠. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435360/">https://habr.com/ru/post/es435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435346/index.html">Suscr√≠base a Kafka a trav√©s de HTTP o c√≥mo simplificar sus enlaces web</a></li>
<li><a href="../es435348/index.html">MCerver simple: un peque√±o shell para el servidor de Minecraft</a></li>
<li><a href="../es435352/index.html">Conferencia DEFCON 18. Espionaje pr√°ctico usando un tel√©fono m√≥vil. Parte 2</a></li>
<li><a href="../es435354/index.html">Conferencia DEFCON 18. Espionaje pr√°ctico usando un tel√©fono m√≥vil. Parte 1</a></li>
<li><a href="../es435358/index.html">Antig√ºedades: minidisco en la era del iPod</a></li>
<li><a href="../es435362/index.html">Speed ‚Äã‚Äãhash</a></li>
<li><a href="../es435364/index.html">Personalizaci√≥n de la resoluci√≥n de dependencias en Spring</a></li>
<li><a href="../es435368/index.html">Anatom√≠a patol√≥gica en el lugar de trabajo.</a></li>
<li><a href="../es435372/index.html">Algunas palabras sobre FastPath y FastTrack en MikroTik</a></li>
<li><a href="../es435374/index.html">Matem√°ticas en Gamedev es simple. Triangulaci√≥n y Triangle.Net en la Unidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>