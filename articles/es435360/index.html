<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏻 🚊 🏂 Snippets vs Clover: supera el cuestionario en tiempo real más popular 👴🏾 👨🏾‍🚒 👃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abril 2018. Tenía 14 años. Mis amigos y yo jugamos en el muy popular cuestionario en línea "Clover" de VKontakte. Uno de nosotros (generalmente yo) si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Snippets vs Clover: supera el cuestionario en tiempo real más popular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  Abril 2018.  Tenía 14 años. Mis amigos y yo jugamos en el muy popular cuestionario en línea "Clover" de VKontakte.  Uno de nosotros (generalmente yo) siempre estaba detrás de una computadora portátil para tratar de buscar rápidamente en Google preguntas y buscar en los resultados de búsqueda la respuesta correcta.  Pero de repente me di cuenta de que estaba haciendo lo mismo cada vez, y decidí intentar escribirlo en Python 3, parcialmente conocido por mí entonces. <br><br><h3>  Paso 0. ¿Qué está pasando aquí? </h3><br>  Para empezar, actualizaré en tu memoria la mecánica de "Clover". <br><br>  El juego para todos comienza al mismo tiempo, a las 13:00 y a las 20:00 hora de Moscú.  Para jugar, debe ingresar a la aplicación en este momento y conectarse a la transmisión en vivo.  El juego dura 15 minutos, durante los cuales se envían preguntas a los participantes por teléfono <b>al mismo tiempo</b> .  La respuesta es de <b>10 segundos.</b>  Entonces se anuncia la respuesta correcta.  Todos los que adivinaron van más allá.  Hay 12 preguntas en total, y si responde a todas, recibirá un premio en efectivo. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="imagen"><br>  Resulta que nuestra tarea es capturar instantáneamente nuevas preguntas del servidor Clover, procesarlas a través de un motor de búsqueda y determinar la respuesta correcta en función de los resultados de la búsqueda.  Se decidió enviar la respuesta en un bot de telegramas para que las notificaciones aparecieran en el teléfono durante el juego.  Y todo esto es deseable en un par de segundos, porque el tiempo de respuesta es muy limitado.  Si quieres ver cómo un código bastante simple, pero funcional (y mirar este será útil para los principiantes) nos ayudó a vencer a Clover, bienvenido al corte. <br><a name="habracut"></a><br><h3>  Paso 1. Obtenga preguntas del servidor </h3><br>  Al principio parecía la etapa más difícil.  Ya respiré hondo y estaba listo para subir a la naturaleza como la visión por computadora, interceptar el tráfico o descompilar la aplicación ... Cuando de repente me esperaba una sorpresa: ¡Clover tiene una API abierta!  No está documentado en ninguna parte, pero si durante el juego, tan pronto como se hizo una pregunta a todos los jugadores, haga una solicitud en api.vk.com, a cambio recibiremos la pregunta y las opciones de respuesta en JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="imagen"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  Como access_token, es necesario transferir el token API de cualquier usuario de VKontakte, pero es importante que se haya emitido originalmente específicamente para Clover.  Su app_id es 6334949. <br><br><h3>  Paso 2. Procesamos el problema a través de un motor de búsqueda. </h3><br>  Había dos opciones: utilizar la API oficial del motor de búsqueda o agregar argumentos de búsqueda directamente a la barra de direcciones y analizar los resultados.  Al principio probé el segundo, pero no solo capté captcha, sino que también perdí mucho tiempo, porque las páginas se cargaron en promedio en 2 segundos.  Y les recuerdo que es aconsejable que nos encontremos estos dos segundos.  Bueno, y lo principal: no obtuve textos grandes y estructurados de los motores de búsqueda sobre el tema necesario, ya que solo pequeñas piezas del material necesario, que se llaman <b>fragmentos,</b> cuelgan en la página de búsqueda: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  Entonces comencé a buscar una API.  Google no encajaba: sus soluciones eran muy limitadas y devolvían muy pocos datos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.XML</a> resultó ser el más generoso: le permite enviar 10,000 solicitudes por día, no más de 5 por segundo, y devuelve datos muy rápidamente.  La solicitud es opcionalmente el número de páginas (hasta 100) y el número de pasajes, valores especiales que se utilizan para formar fragmentos.  Obtenemos los datos en XML.  Sin embargo, estos son todos los mismos fragmentos. <br><br>  Para que pueda familiarizarse y jugar con lo que Yandex devuelve, aquí hay un ejemplo de una respuesta a la pregunta "¿Cuál es el nombre del antagonista principal en la serie de videos" The Legend of Zelda? ": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conducir</a> <br><br>  Tuve suerte, y resultó que en pypi, ya existe un módulo separado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de búsqueda yandex</a> para esto.  Entonces, traté de obtener la pregunta del servidor, encontrarla en Yandex, hacer un gran texto con fragmentos y dividirlo en oraciones: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          «   »?', 'answers': [{'id': 0, 'users_answered': 0, 'text': '« »'}, {'id': 1, 'users_answered': 0, 'text': '« »'}, {'id': 2, 'users_answered': 0, 'text': '«»'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Paso 3. Buscando respuestas </h3><br>  Inicialmente, la tarea de reconocer con precisión la respuesta según los fragmentos me parecía poco realista (le recuerdo que al momento de escribir el código era un principiante absoluto).  Por lo tanto, decidí simplificar primero la tarea que realizamos con una búsqueda manual. <br><br>  ¿Qué hicimos mis amigos y yo cuando dirigimos nuestra pregunta a un motor de búsqueda?  Comenzaron a buscar rápidamente a través de los ojos las respuestas en los resultados.  ¿Cuál es el problema con este enfoque?  En <s>las letras múltiples,</s> hay una gran cantidad de innecesarias, que no contienen información sobre respuestas, propuestas.  Buscar con mis ojos a veces tomaba mucho tiempo.  Por lo tanto, lo primero que decidí hacer fue seleccionar todas las oraciones con una mención de cualquiera de las respuestas y mostrarlas para buscar la respuesta en un texto muy pequeño que contenga con precisión la información que necesitamos. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Parece que obtienes las ofertas correctas, las lees y respondes correctamente.  ¿Pero qué pasa si no encontramos una sola oración?  En este caso, decidí recortar las palabras para no perderlas si están en otro caso.  Y también para capturar los que se forman a partir de la fuente.  En resumen, acabo de recortar su final en dos caracteres: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Pero incluso después de dicha red de seguridad, todavía hubo casos en que la pista permaneció vacía, simplemente porque los resultados no siempre tocaban las respuestas.  Diga, a la pregunta <i>"¿Cuál de estos escritores tiene una historia, llamada así como la canción del grupo Bi 2?"</i>  No se puede encontrar una respuesta exacta.  En este caso, recurrí al enfoque opuesto: pregunté sobre las respuestas y deduje la opción en función de la frecuencia con que se mencionan las palabras de la pregunta en los resultados. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  En este punto, el script ganó funcionalidad básica.  Y ahora, solo una semana y media después del lanzamiento de Clover, estamos sentados y ya jugando con un "truco" hecho a sí mismo.  ¡Deberías haber visto nuestras caras con un amigo la primera vez que <b>ganamos el juego</b> leyendo sugerencias en la línea de comando como por arte de magia! <br><br><h3>  Paso 4. Mostrar respuestas claras </h3><br>  Pero pronto este formato está cansado.  Primero, tenías que sentarte con una computadora portátil cada juego.  En segundo lugar, mis amigos pidieron el script, y estoy cansado de explicar a todos cómo insertar su token VKontakte, cómo configurar Yandex.XML (está vinculado a IP, es decir, era necesario crear una cuenta para cada usuario del script) y cómo instalar Python en la computadora. <br><br>  ¡Sería mucho mejor si las respuestas aparecen en notificaciones automáticas en el teléfono durante el juego!  ¡Solo miré la parte superior de la pantalla y respondí como está escrito en la notificación push!  ¡Y puede organizar esto para todos si crea su canal de telegramas para el guión!  Maravilloso! <br><br>  Pero simplemente mostrar las mismas oraciones en telegramas no es una opción.  Leerlos desde su teléfono es extremadamente inconveniente.  Por lo tanto, tuve que aprender el guión yo mismo para comprender qué respuesta es correcta. <br><br>  Importamos <b>telebot</b> y cambiamos todas <b>las</b> funciones <b>print ()</b> a <b>send_tg ()</b> y <b>notsure ()</b> , que usaremos en el último método, ya que falla un poco más a menudo que otros: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  ¡Y en ese momento, me di cuenta de que los fragmentos son mucho mejores que los textos largos!  Debido a que el motor de búsqueda está tratando de <b>dar una respuesta</b> a nuestra solicitud, y no solo para encontrar coincidencias en palabras.  Y tiene éxito: los fragmentos a menudo contenían las respuestas correctas que las incorrectas, es decir, no había necesidad de analizar el texto.  Y yo, de hecho, no sabía cómo. <br><br>  Así que somos simples para contar la mención de palabras en los resultados: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Lo que sucedió como resultado: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="imagen"><br><br><h3>  Más destino </h3><br>  Para ser justos, debo decir que no tuve éxito en la máquina de la muerte.  En promedio, el bot respondió correctamente solo 9-10 de las 12 preguntas.  Es comprensible, porque hubo personas difíciles que no sucumbieron al análisis de la búsqueda de Yandex.  Yo y mis amigos nos cansamos de pasar constantemente por encima de un par de preguntas y esperar un juego exitoso, en el que el robot finalmente responderá todo correctamente.  No ocurrió un milagro, ya no quería modificar el guión y, después de haber dejado de esperar una victoria fácil, abandonamos el juego. <br><br>  Con el tiempo, mi idea comenzó a aparecer en la cabeza de otros jóvenes desarrolladores.  Para la puesta de sol de 2018, había al menos 10 bots y sitios que mostraban sus conjeturas sobre problemas en Clover.  La tarea no es tan difícil.  Pero lo que es sorprendente, ninguno de ellos ha cruzado la barra de 9-10 preguntas por juego, y luego todos cayeron a 7-8, como mi bot.  Aparentemente, los compiladores de las preguntas dejaron en claro cómo componer las preguntas para que el trabajo de los motores de búsqueda fuera irrelevante. <br><br>  Desafortunadamente, el bot ya no se puede finalizar, porque el 31 de diciembre Clover pasó la última transmisión y no tenía ninguna pregunta.  Sin embargo, fue una gran experiencia para un programador novato.  Y seguramente habría un gran desafío para el avanzado: solo imagine el dúo word2vec y text2vec, solicitudes asincrónicas a Yandex, Google y Wikipedia al mismo tiempo, un clasificador avanzado de preguntas y un algoritmo para reformular la pregunta en caso de falla ... ¡Eh!  Tal vez, por tales oportunidades, me encantó este juego más que por el juego en sí. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435360/">https://habr.com/ru/post/es435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435346/index.html">Suscríbase a Kafka a través de HTTP o cómo simplificar sus enlaces web</a></li>
<li><a href="../es435348/index.html">MCerver simple: un pequeño shell para el servidor de Minecraft</a></li>
<li><a href="../es435352/index.html">Conferencia DEFCON 18. Espionaje práctico usando un teléfono móvil. Parte 2</a></li>
<li><a href="../es435354/index.html">Conferencia DEFCON 18. Espionaje práctico usando un teléfono móvil. Parte 1</a></li>
<li><a href="../es435358/index.html">Antigüedades: minidisco en la era del iPod</a></li>
<li><a href="../es435362/index.html">Speed ​​hash</a></li>
<li><a href="../es435364/index.html">Personalización de la resolución de dependencias en Spring</a></li>
<li><a href="../es435368/index.html">Anatomía patológica en el lugar de trabajo.</a></li>
<li><a href="../es435372/index.html">Algunas palabras sobre FastPath y FastTrack en MikroTik</a></li>
<li><a href="../es435374/index.html">Matemáticas en Gamedev es simple. Triangulación y Triangle.Net en la Unidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>