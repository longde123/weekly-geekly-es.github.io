<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏻 ⚙️ 🧞 Menggunakan matematika diskrit dalam pengujian 👨🏾‍🌾 🖐🏽 👬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertama-tama, saya ingin mengatakan bahwa matematika membantu menertibkan pikiran kita dan secara efektif mengembangkan pemikiran logis, dan ini adala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan matematika diskrit dalam pengujian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451886/"><p>  Pertama-tama, saya ingin mengatakan bahwa matematika membantu menertibkan pikiran kita dan secara efektif mengembangkan pemikiran logis, dan ini adalah beberapa kualitas yang paling penting dari para peserta dalam pengembangan perangkat lunak.  Berbicara tentang pengujian, ini terutama menyangkut perilaku sistem, yang ortogonal dengan representasi struktural yang umum bagi pengembang perangkat lunak.  Perbedaan antara representasi struktural dan perilaku adalah bahwa struktural berfokus pada apa perangkat lunak itu, dan pandangan perilaku memperhitungkan apa yang dilakukan perangkat lunak. </p><br><p>  Salah satu kesulitan penguji adalah bahwa dokumentasi teknis dasar atau manual pengembangan perangkat lunak biasanya ditulis oleh dan untuk pengembang, dan penekanan utama adalah pada informasi struktural daripada informasi perilaku.  Tentu saja, bagian struktural dan perilaku sangat penting untuk pengujian, karena kesalahan pemrograman dapat ditemukan di masing-masing bagian ini.  Itu sebabnya kita akan berbicara tentang metode matematika diskrit untuk menunjukkan hubungan antara struktur program dan perilakunya. </p><br><p>  Dalam pekerjaan sehari-hari mereka, insinyur jaminan kualitas perangkat lunak (QA) bekerja dengan operasi formula, perilaku fungsi, dan struktur data.  Mereka selalu memantau dan memverifikasi keadaan sistem yang selalu berubah, sehingga mereka harus memiliki pemikiran algoritmik dan matematis untuk memahami logika perangkat lunak. </p><a name="habracut"></a><br><p>  Jika seorang pengembang menggunakan pendekatan matematika dalam karyanya, sebagai akibatnya, semua operasi logis akan terhubung satu sama lain, tindakan akan mengikuti rantai logis, dan setiap fungsi akan dipertimbangkan secara struktural. </p><br><p>  Matematika diskrit membantu kita menemukan solusi terbaik dalam berbagai situasi.  Misalnya, Anda dapat menemukan serangkaian kasus uji yang paling cocok (Uji kasus), tanpa mencakup semua opsi yang memungkinkan.  Selain itu, matematika diskrit membantu kita memvisualisasikan bagian yang tepat dari perangkat lunak yang telah diterapkan dan dicakup dalam tes. </p><br><p>  Sayangnya, kita tidak hidup di dunia yang ideal, dan hasil nyata yang diharapkan dari menggunakan perangkat lunak dan hasil aktual dapat bervariasi.  Jadi, tujuan utama Departemen Jaminan Kualitas (QA) adalah untuk secara efektif mencakup sebanyak mungkin kasus uji. <br><br>  Untuk menunjukkan kepada Anda konsep ini secara lebih rinci, kami membuat diagram Venn berikut dengan contoh yang telah kami uraikan sebelumnya: </p><br><br><img src="https://habrastorage.org/webt/tk/bn/dn/tkbndngcvjil0jcix2nz0ilvfrc.png"><br><br>  Diagram Venn di atas menggambarkan banyak situasi, dengan demikian membantu untuk menggambarkan dan mendefinisikan set situasi.  Sebagai contoh, ini dapat membantu kita melihat perbedaan antara set objek.  Matematika diskrit membantu menganalisis dan mengoptimalkan serangkaian tindakan yang dapat memengaruhi perangkat lunak yang sedang dikembangkan. <br><br><h3>  Tetapkan teori </h3><br>  Menggunakan prinsip-prinsip teori himpunan dasar, kita dapat membuat pseudo-code untuk menggambarkan semua kasus yang mungkin untuk aplikasi Next Day (program yang menghitung hari mana yang akan berikutnya menggunakan tanggal yang dimasukkan): <br><br><pre><code class="plaintext hljs">M1={month:month has 30 days} M2={month:month has 31 days except December} M3={month:month is February} M4={month:month is December} D1={day:1&lt;=day&lt;=28} D2={day:1&lt;=day&lt;=29} D3={day:1&lt;=day&lt;=30} D4={day:1&lt;=day&lt;=31} Y1={year:year is a leap year} Y2={year:year is not a leap year}</code> </pre> <br>  Kodesemu ini sudah disiapkan untuk pengembangan dan pengujian aplikasi, sehingga penguji juga dapat menerapkan semua kasus uji yang mungkin berdasarkan data ini.  Menggunakan data dalam format ini membantu meningkatkan kecepatan pengembangan dan mengurangi kemungkinan kesalahan. <br><br><h3>  Teori grafik </h3><br>  Kebanyakan matematika diskrit adalah apa yang disebut "teori graf", yang mempelajari grafik.  Grafik digunakan untuk mewakili hubungan antara beberapa objek atau data, dan jaringan komputer adalah contoh grafik yang sesuai. <br><br><p>  Grafik juga merupakan hal mendasar dalam proses pengembangan perangkat lunak.  Misalnya, dengan menggunakan grafik, kita dapat menguraikan fungsi kompleks menjadi beberapa bagian yang lebih kecil, yang membantu kita untuk lebih memahami logika bisnis. </p><br><p>  Grafik dapat berupa directional dan non-directional, yang berarti bahwa kita dapat bergerak dari node ke node dalam satu arah atau dalam kedua arah (dalam kasus grafik yang diarahkan), atau kita tidak dapat bergerak dari satu node ke yang lain (jika grafik diarahkan secara ketat dalam satu arah) </p><br><p>  Jadi, mari kita kembali ke pengujian perangkat lunak dan bayangkan bahwa kita memiliki aliran dari beberapa proses (misalnya, memindahkan tugas dalam beberapa jenis sistem pelacakan tugas);  kita memiliki kondisi untuk beberapa masalah, dan kita dapat memindahkannya ke tahap lain (grafik berorientasi), atau kita dapat mencapai beberapa titik di mana kita tidak dapat melakukan apa pun dengan entitas (grafik tidak diarahkan).  Dengan pendekatan visualisasi ini, kami dapat dengan mudah mengumpulkan serangkaian tindakan yang mungkin tersedia untuk entitas ini: </p><br><img src="https://habrastorage.org/webt/or/xw/y0/orxwy03udeccjpqpbxna-sdrhg4.png"><br><p>  Mari kita lanjutkan dan lihat matriks adjacency, yang dapat dibangun berdasarkan grafik yang tidak diarahkan.  Dalam contoh di bawah ini, elemen-elemen dari matriks adjacency menunjukkan apakah pasangan simpul berdekatan atau tidak: </p><br><img src="https://habrastorage.org/webt/on/ce/ag/onceag0xnlefxc9o1wwg4ubyetm.png"><br><p>  Sekarang bayangkan bahwa node adalah kondisi dari beberapa entitas, dan jika kita membangun matriks adjacency untuk grafik ini (set entitas), kita akan melihat serangkaian tindakan terbatas yang bisa kita ambil.  Misalnya, mengubah status dari simpul "0" ke simpul "1" tersedia karena mereka terkait satu sama lain.  Tetapi entitas "0" tidak dapat diubah ke tahap "2" atau "3", seperti yang dapat kita lihat dari matriks kita - "nol" ditulis dalam sel.  Dengan menggunakan matriks ini, kita bisa menghilangkan set langkah entitas yang tidak perlu dan mengurangi set kasus uji. </p><br><p>  Matriks lain yang dapat kita gunakan untuk mengumpulkan kasus uji adalah matriks kejadian, yang menunjukkan hubungan antara dua kelas objek.  Pada gambar berikut ini kita melihat grafik tidak berarah dan matriks kejadiannya: "1", "2", "3" dan "4" adalah simpul (entitas), "e1", "e2", "e3" "e4" adalah ujung-ujung grafik , dan matriks menggambarkan entitas dan tindakan yang dapat kita lakukan dengannya.  Dengan simpul "1" kita dapat melakukan tindakan "e1", "e2" dan "e3", tetapi tindakan "e4" tidak tersedia untuk simpul "1.".  Metode ini sangat membantu dalam membuat satu set kasus uji. </p><br><img src="https://habrastorage.org/webt/bd/_-/yn/bd_-yn1sglzxbic4gtks1xaqyg0.png"><br><p>  Bayangkan bahwa penguji menerima daftar entitas dan tindakan yang dapat dilakukan dengan entitas ini.  Dengan matriks ini, ia dapat mengurangi set kasus uji.  Mengurangi jumlah tes adalah bagian yang sangat penting dari proses pengujian perangkat lunak.  Pengujian perangkat lunak sangat tergantung pada pengurangan jumlah kasus pengujian, dan dengan pendekatan ini, cakupan pengujian dan penghindaran redundansi dimaksimalkan. </p><br><p>  Tujuan penguji perangkat lunak adalah untuk melindungi produk menggunakan case uji efektif yang memungkinkan Anda menguji semua kombinasi tindakan yang mungkin.  Penguji dapat berhasil dengan upaya minimal menggunakan pendekatan matematika diskrit (algoritma) untuk menemukan set kasus uji yang optimal dan memaksimalkan efektivitas proses pengujian perangkat lunak. </p><br><p>  Matematika diskrit juga membantu kita memahami bagaimana perangkat lunak sebenarnya dibuat, karena semua perangkat lunak menggunakan algoritma dan metode matematika diskrit dan logika matematika.  Karenanya, jika kami memahami cara kerjanya, kami dapat menemukan kesalahan atau masalah dalam program yang tidak dapat dideteksi oleh pengguna. </p><br><h3>  Petri nets </h3><br><p>  Mari kita lihat contoh bagaimana aplikasi bekerja pada teknologi microservice menggunakan Petri Nets (grafik dinamis): </p><br><img src="https://habrastorage.org/webt/wi/wd/ls/wiwdls-wxquw4ee3xvwwhhwchzu.png"><br><p>  Di sini kita melihat bahwa sistem memiliki keadaan awal dan harus menerima beberapa sinyal yang dikirim dari layanan lain (sebuah penanda muncul).  Bergantung pada hasilnya, tindakan berikut harus dilakukan.  Dengan demikian, jaring Petri menggambarkan dinamika seluruh sistem.  Jika ada masalah, kami dapat melokalisasi cacat lebih cepat. </p><br><h3>  Jaringan saraf </h3><br><p>  Jaringan saraf tiruan juga didasarkan pada prinsip-prinsip grafik.  Mereka meniru pemrosesan informasi oleh neuron otak manusia.  Setiap bagian dari sistem saraf didasarkan pada grafik yang berisi "input" node, "tersembunyi" lapisan dan "output" node. </p><br><img src="https://habrastorage.org/webt/xm/hs/0d/xmhs0dsbxczbvcxieu6u5jt4df8.png"><br><p>  Beberapa data masuk ke lapisan input, dan algoritma lapisan tersembunyi memproses data ini dan mengirimkan hasilnya ke tahap output.  Dengan demikian, jaringan saraf dapat melakukan tindakan berdasarkan data ini.  Jaringan saraf juga terdiri dari banyak grafik serupa dengan logika berbeda, sehingga mereka dapat mengambil keputusan berdasarkan parameter input. </p><br><h3>  Pengujian Milenium </h3><br><p>  Contoh terakhir kami menggunakan matematika diskrit dalam pengujian melibatkan membangun proses pengujian perangkat lunak.  Saat ini, ada banyak metodologi dan pendekatan yang disebut "pengujian milenium", yang dikembangkan jauh sebelum penggunaannya yang sebenarnya, mulai dari tahun 2000-an, ketika pengembangan perangkat lunak mulai berkembang pesat. </p><br><p>  BDD (Behaviour Driven Development) adalah bagian dari apa yang disebut Pengujian Millenium, metodologi ini merupakan perpanjangan dari TDD (Test Driven Development).  BDD memungkinkan penguji untuk membangun hubungan yang lebih dekat antara kriteria penerimaan untuk fungsi yang diberikan dan tes yang digunakan untuk menguji fungsi ini.  BDD dapat mengubah pernyataan terstruktur dalam bahasa alami menjadi tes yang dapat dieksekusi, sehingga memperkenalkan lebih banyak kejelasan dan pemahaman ke sisi bisnis dan sisi pengembangan, ketika mereka mulai berbicara satu bahasa yang sama.  Struktur dasar alur kerja BDD juga didasarkan pada grafik dinamis (Petri Net). </p><br><img src="https://habrastorage.org/webt/xu/fw/ip/xufwip8q38dxyr0vaff1uo6qwro.png"><br><p>  Seperti dapat dilihat dari struktur ini, setiap proses disertai oleh proses yang berbeda, dan tidak dapat pindah ke tahap berikutnya sampai tahap sebelumnya selesai.  Sekali lagi, prinsip-prinsip matematika diskrit membantu kita memahami proses dengan lebih efisien. </p><br><br>  Sebagai kesimpulan, saya ingin sekali lagi daftar keuntungan menggunakan matematika diskrit dalam proses pengembangan perangkat lunak: <br><br><ul><li>  Bantuan dalam memahami logika bisnis dari fungsionalitas yang diperlukan </li><li>  Sederhanakan kemampuan untuk membagi tugas yang kompleks menjadi tugas yang lebih sederhana </li><li>  Memungkinkan profesional untuk melakukan pengujian yang efektif dengan sedikit usaha </li><li>  Membantu dalam memahami dan memvisualisasikan struktur dari semua yang kita inginkan </li></ul><br>  Contoh di atas menunjukkan bagaimana matematika diskrit dapat digunakan untuk secara efektif meningkatkan kinerja tes.  Setiap aspek dari matematika diskrit dapat membantu pengembang memahami alur kerja perangkat lunak umum dan prinsip-prinsipnya sepanjang siklus hidup pengembangan perangkat lunak. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451886/">https://habr.com/ru/post/id451886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451874/index.html">Tren SEO Teratas di Google</a></li>
<li><a href="../id451876/index.html">Pusat data Frankfurt: Pusat data Telehouse</a></li>
<li><a href="../id451878/index.html">Streaming langsung video stereo ke kacamata VR (Oculus Go)</a></li>
<li><a href="../id451880/index.html">DevPRO'19: pemandangan dari bilik Wrike</a></li>
<li><a href="../id451884/index.html">Tujuh tahun bekerja sebagai pengembang: pelajaran apa yang telah saya pelajari</a></li>
<li><a href="../id451890/index.html">Delegasi zona reverse subnet kurang dari / 24 di BIND. Bagaimana cara kerjanya</a></li>
<li><a href="../id451894/index.html">Tinjauan singkat dan segar arsitektur kompiler</a></li>
<li><a href="../id451896/index.html">EyeDisk "yang tidak dapat dipecahkan" dilindungi oleh pemindaian iris, tetapi mengirimkan kata sandi dalam teks yang jelas</a></li>
<li><a href="../id451898/index.html">Inovasi dalam bahasa Rusia</a></li>
<li><a href="../id451900/index.html">Kontribusi pertama ke API browser dari Facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>