<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏿 💟 🛁 OpenID Connect 1.0 sur les doigts 👇🏿 💇🏼 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenID Connect a une spécification , il y a des tutoriels, des articles sur le hub et non sur le hub Il est plutôt inutile de sculpter une autre instr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenID Connect 1.0 sur les doigts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422765/"><p>  <strong>OpenID Connect</strong> a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification</a> , il y a des tutoriels, des articles sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub</a> et non sur le hub  Il est plutôt inutile de sculpter une autre instruction étape par étape, menant de la confusion profonde au travail en passant par l'autorisation et l'authentification.  La tâche du texte ci-dessous est différente, pour décrire les idées sous-jacentes aux spécifications (il y en a plusieurs). </p><br><p>  Je ne vais pas sauter immédiatement sur le sujet de l'article, mais je vais commencer par des choses simples et beaucoup évidentes.  Je vais continuer avec la façon dont ils se sont développés et ce qu'ils ont emballé selon les exigences des clients.  Je vais l'aborder historiquement, c'est-à-dire de la manière même dont il est né. </p><br><p><img src="https://habrastorage.org/webt/bh/5i/br/bh5ibr5bu0wxmial0gdp6uxy_bg.png"></p><a name="habracut"></a><br><p>  1. </p><br><p>  La tâche minimale est simplement de ne laisser personne accéder à aucune de ses ressources.  Nous le fermons avec un nom d'utilisateur / mot de passe, qui sait que la bonne paire de noms d'utilisateur et de mots de passe arrivera à la ressource, qui ne le fait pas - non.  Cette chose est appelée <strong>authentification</strong> , car vous pouvez utiliser non seulement des connexions avec des mots de passe (code SMS, par exemple, ou une clé USB matérielle), mais ces détails ne sont pas essentiels pour notre sujet.  Je vais également omettre le paragraphe obligatoire sur le danger de transmettre des mots de passe sur Internet sous une forme ouverte, pour laquelle nous n'aimons pas tous l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">authentification d'accès de base</a> . </p><br><p>  Mieux vaut noter ceci: aucun des utilisateurs n'aime entrer des identifiants avec des mots de passe.  Les codes SMS ne sont pas meilleurs et les clés USB sont tout simplement détestées.  Afin de ne pas forcer l'utilisateur à entrer une connexion avec un mot de passe pour chaque demande, le serveur en réponse leur envoie une ligne de charabia appelée <strong>clé de session</strong> .  Et puis cette clé s'accroche à chaque demande de serveur par le client (généralement avec un en-tête HTTP, mais ce n'est pas essentiel), et le serveur vérifie s'il a une telle session. </p><br><p>  <em>Session avec une clé - les phénomènes, par définition, sont temporaires, le nombre d'or pour la durée de vie d'une session est d'environ "lorsque l'onglet du navigateur est ouvert, mais pas plus d'une journée"</em> </p><br><p>  2. </p><br><p>  Ils ont laissé entrer n'importe qui - c'est bien.  Maintenant, vous devez comprendre exactement qui nous lâchons.  Et non seulement pour déduire ce qu'il a entré comme nom dans le coin supérieur droit, mais aussi pour décider quoi le laisser entrer et quoi ne pas le faire. </p><br><p>  Et tout cela s'appelle - <strong>autorisation</strong> .  Et je ne suis pas sûr de vous, mais je le confond tout le temps avec l'authentification.  Afin de ne pas confondre - une règle relativement mnémonique, "autorisation" - avec les mots "auteur", "auteur", ils écrivent sur les couvertures de livres, et ils n'y écrivent jamais "un membre valide de l'Union des écrivains".  Un auteur est toujours une personne très spécifique.  L'autorisation est donc un processus lorsque nous comprenons qui nous avons exactement lancé par identifiant et mot de passe. </p><br><p>  3. </p><br><p>  Ok  Nous avons un site, il y a quelque chose de secret sur le site, à l'entrée de la partie secrète nous avons besoin d'un mot de passe, chacun ne montre que ses secrets, et nous ne montrons pas d'étrangers.  La vie ne s'arrête pas et nous avons un autre site.  Et ici, nous rencontrons à nouveau le problème du point 1, personne n'aime entrer les noms d'utilisateur et les mots de passe!  Vous pouvez combiner la base d'utilisateurs et cela leur évitera de devoir s'inscrire deux fois, mais comment les éviter de ressaisir le login et le mot de passe à l'entrée?  Étant donné l'existence d'une telle chose que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">même politique d'origine</a> (et nos sites sont situés, bien sûr, sur différents domaines, les cookies avec une clé de session ne sont pas visibles pour l'autre)?  Ici, pour donner de l'importance au moment, je vais commencer un nouveau point. </p><br><p>  4. </p><br><p><img src="https://habrastorage.org/webt/yg/4j/7l/yg4j7l4kjiavq0v3jictaduihw4.jpeg"></p><br><p>  <strong>SSO</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Single Sign On</a> - quelle que soit l'implémentation, Microsoft Kerberos, SAML, ou quelque chose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OAuth 2.0</a> , sur lequel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenID Connect</a> est construit, à propos duquel je vous écris ici, en fait, sous le capot, il y a toujours la même chose: il y a un <strong>serveur</strong> séparé <strong>autorisation</strong> , et toute personne qui souhaite autoriser un utilisateur le redirige.  Si l'utilisateur est déjà autorisé, la session est récupérée et il s'envole immédiatement du serveur d'autorisation et obtient où il voulait.  S'il n'est pas autorisé, le serveur d'autorisation résout ce problème du mieux qu'il peut, en demandant une connexion avec un mot de passe, en règle générale, et si la solution réussit, il renvoie l'utilisateur. </p><br><p>  De plus, SAML pour le moment la solution, pour ainsi dire, est dépassée.  Et Kerberos est généralement une magie Microsoft fermée complètement distincte qui va bien au-delà de la portée du protocole HTTP.  Eh bien, nous allons nous concentrer là-dessus.  Et puis nous arrivons au problème suivant. </p><br><br><p>  Il existe déjà un scénario de travail compréhensible - dans toute situation incompréhensible, envoyez l'utilisateur au serveur d'autorisation, laissez-le décider quoi faire de lui et retournez une réponse toute prête.  Mais comment exactement le serveur d'autorisation indique-t-il à cet autre serveur que l'utilisateur est autorisé?  Nous revenons ici aux idées du premier paragraphe, à savoir la clé de session.  Revenons à l'essentiel: la présence d'une clé de session est un signe d'autorisation, la clé de session elle-même ouvre la porte aux informations utilisateur et, vous ne le croirez pas, aux informations de session.  Le serveur d'autorisation autorise et donne donc la clé de session à un autre serveur. </p><br><p>  Maintenant, cependant, il n'est plus appelé une clé de session, mais un <strong>jeton</strong> . <br>  Plus précisément, (selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protocole OAuth 2.0</a> , au-dessus duquel OpenID Connect est écrit), ce sont deux jetons à la fois - <strong>Access Token</strong> , pour l'accrocher à toutes les demandes en tant que clés de session coupées par les grands-pères, et <strong>Refresh Token</strong> , pour mettre à jour le jeton d'accès quand il s'éteint. </p><br><p>  Pour résumer le sous-total.  Au lieu de demander à l'utilisateur un nom d'utilisateur et un mot de passe, le serveur les envoie à un autre serveur, un serveur d'autorisation distinct.  Il fait tout le travail, puis donne les premiers jetons.  Dans exactement ce scénario, les applications sont autorisées, mobiles et parfois de bureau., Elles ne font simplement aucune redirection, elles envoient simplement le serveur d'autorisation JSON avec un nom d'utilisateur et un mot de passe, et il leur envoie des jetons en réponse. </p><br><p>  Les applications mobiles et de bureau peuvent le faire.  Pour une raison quelconque, ils sont considérés comme plus sûrs que le Web, mais le Web a une vie plus compliquée. </p><br><p>  6. </p><br><p>  D'une part, ce n'est pas plus compliqué, mais au contraire plus simple.  Vous pouvez faire une redirection et ne pas vous soucier de rendre un formulaire de connexion-mot de passe.  D'un autre côté, je ne veux vraiment, vraiment pas faire glisser les jetons à travers le navigateur en clair.  C'est presque aussi dégoûtant que le mot de passe non chiffré dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">authentification d'accès de base</a> .  Mais personne ne veut répéter cette vieille et terrible erreur. </p><br><p>  Il n'y avait pas de solution au problème pour qu'il soit très élégant, mais fonctionnel.  Tout d'abord, tout se passe comme d'habitude, en passant à l'autorisation, l'autorisation elle-même.  Ensuite, quand vient le temps de revenir avec des jetons, la redirection inverse se produit.  Mais au lieu des jetons, un code à usage unique est attaché à l'adresse de retour.  Le code à usage unique vient d'être généré par le serveur d'autorisation uniquement pour ce moment particulier.  Il a une durée de vie très courte.  Ayant à peine reçu un code à usage unique, un autre serveur devrait arracher ses jupes, gonfler ses yeux et se précipiter à nouveau vers le serveur d'autorisation, afin de recevoir les jetons convoités du code à usage unique. </p><br><p>  Il existe une ressource spéciale pour un voyage avec un code pour les jetons sur le serveur d'autorisation.  Il accepte, par spécification, non GET, mais POST.  Cela nous indique en quelque sorte que cette demande doit être faite non pas à partir du navigateur, mais d'un serveur à l'autre. </p><br><p>  <em>Pour la même raison, sur tout serveur d'autorisation CORS qui se respecte, les requêtes POST sont interdites.</em> </p><br><p>  7. </p><br><p>  Au fait, vous souvenez-vous encore de l'authentification et de l'autorisation?  L'authentification, c'est quand quelqu'un est simplement autorisé à entrer par login et mot de passe, ou n'est pas autorisé.  Et l'autorisation, c'est qu'après avoir déjà démarré, ils commencent à comprendre qui exactement ils ont démarré. </p><br><p>  Vous souvenez-vous d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OAuth 2.0</a> ?  Je l'ai mentionné plusieurs fois ci-dessus, comme une sorte de fondation pour OpenID Connect. </p><br><p>  Vous souvenez-vous d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenID Connect</a> ?  Cet article est juste stupide. </p><br><p>  Ainsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OAuth 2.0</a> est l'authentification.  L'ensemble de la procédure légèrement déroutante décrite précédemment avec trois participants, un mot de passe, un code et un jeton est une question d'authentification, qui consiste simplement à faire exécuter quelqu'un quelque part.  Protocole OAuth 2.0. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenID Connect</a> est une autorisation.  C'est-à-dire qu'il ajoute à OAuth les parties où il s'avère qui ils ont lâché. </p><br><p>  Pour ce faire, un autre est ajouté à la liste des jetons, il s'appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ID Token</a> .  Ceux qui suivent le lien sont probablement surpris de ne rien voir sur aucun ID de jeton.  Que la surprise ne se transforme pas en frayeur, <strong>ID Token</strong> est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JWT</a> retourné sous forme de poupée imbriquée encodée en base64 dans le même JSON que Access Token et Refresh Token.  En tout cas, tout ce que vous vouliez savoir sur l'utilisateur est en lui. </p><br><p>  Et il y a aussi une ressource spéciale sur le serveur d'autorisation appelée userinfo, où vous pouvez frapper avec Access Token et obtenir le même JSON en réponse que dans Token ID.  Mais pourquoi est-il nécessaire si l'ID de jeton est déjà là?  Question aux auteurs de la spécification. </p><br><p>  OpenID Connect contient également une description des différents champs d'informations utilisateur.  Comment puis-je obtenir ces informations, directement pendant l'autorisation ou à tout moment après.  Et une description de comment et quand l'utilisateur vous autorisera à utiliser ces informations. <br>  Ou ne le permettez pas.  Donc, en bref, OpenID Connect 1.0 est conçu. </p><br><p>  8. </p><br><p>  Un petit clinquant dans le protocole.  J'espère que vous en avez assez de lire l'article pour le moment, afin de ne pas faire très attention à cet article, juste en le passant dans les yeux.  Ici, je mentionnerai les paramètres qui sont dans la spécification, et ils portent une certaine charge sémantique, mais ils ne sont pas directement liés à la mise en œuvre de l'idée elle-même.  Fondamentalement, ils ajoutent de la sécurité, ou tout simplement vous permettent de transférer des informations d'un des participants au processus à un autre, si nécessaire. </p><br><p>  <strong>ID client et secret client</strong> .  Le client dans la langue du protocole OpenID Connect n'est pas du tout un navigateur, mais le tout autre serveur qui doit autoriser l'utilisateur.  Supposons que vous ayez un site Web et que vous souhaitiez y attacher une autorisation à la mode via Facebook.  Et par googol.  Et pas si à la mode via Twitter.  La mise en œuvre du protocole dans le code ne sera pas suffisante.  Vous devrez également vous inscrire sur Facebook, sur Google et sur Twitter, mais pas en tant qu'utilisateur, mais en tant que client même qui, en tant que serveur, peut utiliser son autorisation.  Lors de votre inscription, vous recevrez un identifiant client et un secret client du facebook conditionnel.  Et lorsque vous demandez une autorisation, entre autres, envoyez un identifiant client.  Et lorsque vous utilisez un code à usage unique pour un jeton, Client Secret vous demandera également. </p><br><p>  <strong>Rediriger l'URI</strong> .  Ici, tout est simple.  Lorsque vous envoyez un utilisateur à un Facebook conditionnel pour vous connecter, vous devez indiquer à Facebook où lui retourner les codes et les jetons après l'autorisation.  Bien sûr, vous lui donnez toujours votre identifiant client.  Mais un URI de redirection séparé vous permet de rediriger après autorisation différents utilisateurs vers différentes pages, par exemple les administrateurs vers le panneau d'administration, et les utilisateurs ordinaires vers leurs pages personnelles.  Pratique.  De plus, la liste autorisée des URI de redirection possibles spécifiés dans les paramètres du client sur le Facebook conditionnel est une sécurité supplémentaire. </p><br><p>  <strong>Portée</strong> .  Il s'agit d'une liste de ce que le serveur veut savoir sur l'utilisateur à partir du serveur d'autorisation.  Les valeurs de la liste sont séparées par des espaces, openid doit être obligatoire parmi elles, puis lisez la spécification. </p><br><p>  <strong>État</strong> .  Vous vous souvenez du code unique, par lequel les jetons sont émis, comme un ticket dans une file d'attente électronique?  Ainsi, l'état est un code, au contraire, si le serveur d'autorisation émet un code vers un autre serveur afin qu'il le renvoie rapidement, cet état donne un autre serveur d'autorisation à ce serveur pour le renvoyer lors de la redirection.  Il est nécessaire, si je comprends bien, si un autre serveur a déjà réussi à créer sa propre session afin qu'elle ne soit pas perdue dans toutes ces redirections. </p><br><p>  Il existe d'autres paramètres, tels que le type de demande d'autorisation et la durée de vie du jeton, mais pour comprendre pourquoi vous n'en avez pas besoin. </p><br><br><p>  En conclusion.  J'espère vraiment qu'une lecture pas trop réfléchie et ciblée du texte ci-dessus vous a aidé à saisir les idées qui sous-tendent certains protocoles de contrôle d'accès modernes.  Mais en commençant à mettre en œuvre, ou tout simplement à configurer l'un d'entre eux, ouvrez les spécifications, trouvez un bon tutoriel et suivez attentivement chaque mot et chaque lettre.  Et laissez la compréhension des idées éveiller en vous l'intuition.  Et intuition, laissez-vous mordre à la couronne chaque fois que vous manquez un paramètre qui n'est pas si important à première vue, ou un réglage, et laissez-le un trou pour les petites mains enjouées et moites. </p><br><p>  N'oubliez pas qu'il s'agit de la même sécurité et que ses règles, aussi stupides et dénuées de sens qu'elles puissent paraître, sont écrites dans le sang.  Eh bien, peut-être pas avec du sang, ce n'est pas une mesure de sécurité dans la fonderie, après tout, mais l'argent et la réputation sont sûrs, et l'argent et la réputation ne sont pas non plus les choses que vous devriez facilement jeter comme ça. </p><br><p>  Merci à <strong>JM</strong> pour le fait que le texte que vous avez lu était bien meilleur que celui que j'ai écrit. </p><br><p>  Bonne chance et n'oubliez pas de renouveler vos certificats à temps. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422765/">https://habr.com/ru/post/fr422765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422755/index.html">Le portefeuille protégera-t-il contre les affaissements cryptographiques?</a></li>
<li><a href="../fr422757/index.html">Pas de politique. Comment transformer durablement les manifestations de rue à l'aide d'une application mobile?</a></li>
<li><a href="../fr422759/index.html">Carte interactive pour une application Web en quelques heures</a></li>
<li><a href="../fr422761/index.html">Quatre façons de l'école d'analyse de données Yandex</a></li>
<li><a href="../fr422763/index.html">Événements numériques à Moscou du 10 au 16 septembre</a></li>
<li><a href="../fr422767/index.html">Conférence DEFCON 16. Fedor, InSecure.org Hacker. Analyse NMAP en ligne</a></li>
<li><a href="../fr422769/index.html">Les gagnants du Startup Battlefield TechCrunch Disrupt San Francisco 2018</a></li>
<li><a href="../fr422771/index.html">Les règles du design, atteindre un nouveau niveau et la pensée design</a></li>
<li><a href="../fr422773/index.html">NVIDIA. Révéler les secrets de l'architecture GPU Turing de nouvelle génération: double ray tracing, GDDR6, etc.</a></li>
<li><a href="../fr422775/index.html">Conférence DEFCON 22. Andrew "Zoz" Brooks. Ne le gâchez pas! Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>