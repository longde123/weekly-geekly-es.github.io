<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚌 🧑🏿‍🤝‍🧑🏼 🧙🏾 Perbedaan antara Phoenix dan Rails melalui mata seorang mualaf 🌜 🧗🏿 🗒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yang paling mengejutkan bagi orang yang keranjingan ketika ia baru mulai mempelajari Elixir dengan Phoenix. 

 Catatan 


 Saya orang yang sederhana d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perbedaan antara Phoenix dan Rails melalui mata seorang mualaf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423459/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/sv/xv/n3/svxvn3p0h86vabqr0a1mxbvxmfs.png" height="70%" width="70%"></div>  Yang paling mengejutkan bagi orang yang keranjingan ketika ia baru mulai mempelajari Elixir dengan Phoenix. <a name="habracut"></a><br><br><h2 id="primechanie">  Catatan </h2><br><p>  Saya orang yang sederhana dan saya tidak akan terlalu dalam.  Oleh karena itu, akan ada perbedaan dalam tingkat kerja-tani, tetapi tidak ada yang akan dikatakan tentang perbedaan dalam tingkat peluncuran aplikasi, tentang prinsip-prinsip operasi mesin virtual Erlang dan protokol OTP. </p><br><h2 id="glavnoe-vpechatlenie">  Kesan utama </h2><br><p>  Elixir / Phoenix sangat mirip dengan Rails dan pada saat yang sama sama sekali tidak menyukainya.  Seperti beberapa frasa bahasa Inggris: secara individual, kata-katanya akrab, tetapi bersama-sama itu tidak jelas. </p><br><h2 id="erlang-vs-ruby">  Erlang vs Ruby </h2><br><p>  Berpikir dalam rubel dan mencoba menulis di ramuan itu sulit.  Secara teratur Anda menemui jalan buntu, karena apa yang Anda inginkan dilakukan benar-benar berbeda dari apa yang Anda lakukan sebelumnya ... atau, pada kenyataannya, Anda tidak menginginkannya sama sekali. </p><br><p> Adapun sisanya, orang menulis buku tentang perbedaan Erlang dan Ruby, jadi saya akan singkat.  Bagi saya, penyergapan utama adalah dengan penggantian “lokomotif uap” rel dengan pipa, dengan reorientasi pemikiran ke fungsionalisme (manfaatnya adalah pengalaman lama <code>inject</code> dan kecintaan yang sama terhadap <code>inject</code> / <code>foldr</code> ) dan, secara subyektif, persyaratan yang lebih ketat untuk tipe data (meskipun, secara resmi, , kedua bahasa dengan pengetikan dinamis yang ketat). </p><br><p>  Pencocokan pola tidak menimbulkan kejutan, dan saya masih tidak mengerti mengapa ada begitu banyak pembicaraan tentang dia.  Hanya alat yang menarik. </p><br><h2 id="obschiy-skoup">  Ruang lingkup umum </h2><br><p>  Dalam Elixir, semuanya terletak pada modul.  Tidak ada ruang lingkup global.  Panggilan C #. </p><br><p>  Dengan kata lain: relnya rata dan di beberapa tempat mengganggu pembuatan hierarki (saya ingat pernah ada bug dengan pengontrol yang terbaring di modul).  Elixir - sebaliknya, semuanya ada dalam modul.  Di rel, Anda bisa menebak tujuan objek oleh kelas induk, dan di elixir, dengan nama lengkap kelas / modul. </p><br><h2 id="kompiliruemost">  Compilability </h2><br><p>  Di satu sisi, inilah yang terkadang tidak saya miliki di pagar.  Karena Anda dapat menemukan setengah kesalahan yang baik saat dikompilasi, dan tidak di runtime saat produksi.  Kompilasi, di sisi lain, membutuhkan waktu.  Tetapi di pihak ketiga, itu perlu sedikit, dan saya belum melihat proyek besar pada elixir (dan bukan dengan aturan erlang untuk menulis monolith besar).  Terlebih lagi, para elixir melakukan pekerjaan yang hebat untuk secara dinamis memuat kembali kode dan halaman.  Dan sejauh ini, kecepatan kerja, ditambah dengan kurangnya zeus / musim semi yang tak bertuhan, menghangatkan jiwa saya. </p><br><p>  Tentu saja, ini juga menimbulkan kontra, tetapi mereka keluar kemudian.  Di suatu tempat di bidang lingkungan produksi dan penyebaran.  Lebih lanjut tentang ini di bawah ini. </p><br><p>  Berikut ini adalah hal menarik yang secara fisik tidak dapat terjadi pada rel: migrasi dan hal-hal lain yang dalam rel melalui <code>rake</code> in elixir memerlukan kompilasi proyek dan hal seperti ini dapat terjadi: lupa menulis rute, jalur helper dalam pandangan merujuk kepada mereka, tetapi migrasi jatuh.  Pada awalnya - sangat tidak biasa. </p><br><h2 id="dokumentaciya">  Dokumentasi </h2><br><p>  Situs dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi elixir</a> terlihat jauh lebih kuat daripada rubidock dan apidok.  Tapi di sini ada jumlah dokumentasi dan contoh - di sinilah letak ruby ​​/ rail jauh di depan.  Elixir tidak memiliki contoh untuk semuanya yang sedikit lebih rumit daripada feses.  Dan deskripsi beberapa metode, pada kenyataannya, tidak melampaui tanda tangan.  Itu sulit bagi saya, karena saya terbiasa dengan banyak contoh dan deskripsi, dengan beberapa metode elixir.  Kadang-kadang saya harus melihat-lihat dan bereksperimen dalam waktu yang lama untuk memahami cara menggunakan metode ini atau itu, karena saya tidak begitu mengerti bahasa sehingga saya bisa membaca kode sumber paket dengan bebas. </p><br><h2 id="nezavisimost-raspolozheniya-fayla-ot-ego-soderzhimogo">  Independensi lokasi file dari isinya </h2><br><p>  Seperti yang mereka katakan "dengan kekuatan besar datang tanggung jawab besar".  Di satu sisi, Anda dapat membuat bacchanalia dan menguraikan benda-benda sehingga musuh pasti tidak akan lewat.  Dan di sisi lain, Anda dapat memberi nama path dengan lebih logis dan jelas, menambahkan level logis dari direktori yang tidak ada dalam hirarki kelas.  Secara khusus, kita dapat mengingat trailblazer dan sejenisnya dengan ide menggabungkan segala sesuatu yang berkaitan dengan aksi di satu tempat.  Dalam elixir, ini bisa dilakukan tanpa pustaka pihak ketiga dan banyak kelas hanya dengan memindahkan file yang ada dengan benar. </p><br><h2 id="prozrachnyy-put-zaprosa">  Jalur permintaan transparan </h2><br><p>  Jika dalam Rails pertanyaan tentang rack adalah atribut yang sangat diperlukan dari setiap wawancara, karena rail adalah puncak gunung es dan dari waktu ke waktu Anda ingin membuat middleware Anda.  Bahwa dalam ramuan keinginan seperti itu tidak muncul sama sekali (walaupun mungkin aku masih muda dan semuanya di depan).  Ada serangkaian saluran pipa yang secara eksplisit dilewati permintaan.  Dan di sana Anda dapat dengan jelas melihat di mana sesi diambil, di mana flash-messge diproses, di mana csrf divalidasi dan semua ini dapat dikontrol sesuka Anda di satu tempat.  Di rel, seluruh pertanian ini sebagian dipaku, dan sebagian tersebar di berbagai tempat. </p><br><h2 id="routy-naiznanku">  Rute dalam ke luar </h2><br><p>  Dalam Rails, situasi di mana satu tindakan dapat merespons dalam beberapa format adalah norma.  Bahkan di sana <code>(.:format)</code> diletakkan tepat di rute.  Dalam elixir, karena properti yang disebutkan di atas dengan pipa, pemikiran format analog tidak muncul sama sekali.  Format yang berbeda menggunakan saluran pipa yang berbeda dan memiliki url yang berbeda.  Bagi saya itu sangat sehat. </p><br><h2 id="shema-v-modeli">  Sirkuit dalam model </h2><br><p>  Ini umumnya dongeng.  Saat Anda menggambarkan bidang model, itu akan menjadi begitu.  Tidak ada jenis pemeran tersirat.  Plus, tidak ada kruk untuk membatasi akses ke bidang, yang ada di database, tetapi karena alasan tertentu tidak dapat digunakan dalam aplikasi web. </p><br><h2 id="validacii-i-kolbeki">  Validasi dan Callback </h2><br><p>  Tidak ada panggilan balik di elixir.  Di sana semuanya lebih mudah.  Dan saya pikir saya menyukainya. </p><br><p>  Alih-alih rails-way dalam elixir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">changeset</a> , yang menggabungkan strong_parameters, validasi, dan beberapa callback.  Dan sisa panggilan balik melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multi</a> , yang memungkinkan untuk mengumpulkan banyak operasi, melakukan transaksi dan memproses hasilnya. </p><br><p>  Singkatnya, semuanya hanya berbeda.  Awalnya ini tidak biasa.  Kemudian di tempat-tempat itu membuat saya marah, karena Anda tidak bisa menahan panggilan balik lain untuk semuanya dan tidak memikirkan kasus bisnis yang berbeda.  Dan kemudian Anda mulai memperhatikan <a href="">"pesona yang tidak bisa dijelaskan"</a> , karena Anda harus melakukannya dengan benar, dan tidak seperti dulu. </p><br><h2 id="rabota-s-bd">  Bekerja dengan DB </h2><br><p>  Alih-alih ActiveRecord, beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ecto.Repo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ecto.Query,</a> dan beberapa saudara mereka muncul.  Untuk mengatakan semua perbedaan adalah artikel terpisah.  Karena itu, saya akan mengatakan sensasi subyektif utama. </p><br><p>  Dalam debug lebih nyaman daripada AR.  Karena ada ruang lingkup umum, konstanta dari jalur beban dimuat ketika mengaksesnya dan Anda cukup membuka <code>rails c</code> , tulis <code>User.where(email: 'Kane@nod.tb').order(:id).first</code> dan dapatkan hasilnya. </p><br><p>  Di Elixir, konsol tidak cukup.  Sejumlah tindakan perlu dilakukan: </p><br><ul><li>  mengimpor metode untuk membangun kueri sql: <code>import Ecto.Query, only: [from: 2]</code> ; </li><li>  tambahkan kelas untuk menghindari mengeja nama lengkap mereka: <br><ul><li>  <code>alias MyLongApplicationName.User</code> - untuk menulis <code>User</code> alih-alih <code>MyLongApplicationName.User</code> ; </li><li>  <code>alias MyLongApplicationName.Repo</code> - sama untuk mengakses kelas yang dapat mengeksekusi sql dan mengembalikan hasil; </li></ul></li><li>  dan hanya sekarang Anda dapat menulis <code>from(u in User, where: u.email == "Kane@nod.tb") |&gt; Repo.one</code> </li></ul><br><p>  Di sisi lain, dalam kode aplikasi, "formalitas" ini memberikan kode yang lebih mudah dibaca, ditambah ada perasaan bahwa Anda mengendalikan apa yang terjadi, dan bukan menjalani kehidupannya sendiri.  Artinya, Anda memilih metode, model, dan objek apa yang perlu Anda kerjakan, Anda memuatnya secara eksplisit dan menggunakannya. </p><br><h2 id="nazvanie-prilozheniya">  Nama aplikasi </h2><br><p>  Dalam gambar dan rupa Rails, saya berasumsi bahwa nama aplikasi digunakan dalam sepasang konfigurasi dan hanya itu.  Karena itu, saya tidak memperhatikan panjang nama.  Namun sia-sia.  Di Elixir, modul dengan nama aplikasi adalah level teratas dalam hierarki modul aplikasi web dan akan muncul di mana-mana. </p><br><p>  Saya menelepon kotak pasir Comindivion saya.  Dan sekarang saya sedikit menderita, karena ini nama yang agak panjang dan Anda harus menulisnya terus-menerus.  Baik di file kelas dan di konsol saat memanggil apa pun.  Ngomong-ngomong, ya, siapa yang peduli, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini kotak pasir di GitHub</a> . </p><br><h2 id="n1">  N +1 </h2><br><p>  Di Rails, kami memilikinya di luar kotak, tetapi di Elixir di luar kotak tidak ada masalah seperti itu.  Di sana, pada tahap perakitan permintaan, Anda dapat menentukan hubungan mana yang diperlukan dan mereka akan dimuat selama pelaksanaan permintaan ini.  Tidak diunggah?  Anda tidak akan memiliki akses ke hubungan ini.  Semuanya sederhana dan indah. </p><br><h2 id="obrabotka-zaprosa-i-otvet-na-nego">  Permintaan pemrosesan dan respons </h2><br><p>  Singkatnya: di phoenix, semuanya lebih jelas daripada di pagar. </p><br><h3 id="vezde-conn">  Di mana-mana samb </h3><br><p>  Karena negara tidak disimpan dalam tumpukan objek yang berbeda, maka harus diseret dalam satu objek.  Mengingatkan <code>request</code> dari <code>ActionController</code> , hanya lebih komprehensif.  Dia disebut <code>connection</code> Phoenix.  Ini berisi segalanya: <code>request</code> , <code>flash</code> , <code>session</code> dan segalanya.  Dia muncul dalam panggilan semua yang berhubungan dengan pemrosesan permintaan yang tiba. </p><br><p>  Di sini dan kontra, karena yang pertama sangat malas untuk memahat di mana-mana <code>conn</code> dan tidak sepenuhnya mengerti mengapa.  Rel dalam hal ini korup.  Anda menulis render atau flash dan tidak ada pikiran bahwa tindakan ini berkaitan.  Dan di Phoenix <code>conn</code> selalu mengingatkan Anda untuk bekerja dengan koneksi atau soket tertentu, dan bukan hanya metode yang dipanggil dan keajaiban terjadi di dalam. </p><br><h3 id="partialtemplate">  Sebagian &amp; templat </h3><br><p>  Di Phoenix, tidak ada pemisahan antara parsial dan templat.  Akhirnya seluruh fungsinya.  Ada satu lagi pesona di sini: rel, bahkan di lingkungan prod, terus-menerus merangkak di balik tampilan pada disk dan menghasilkan IO plus overhead untuk mengubahnya dari erb / haml / etc ke html.  Dan di Elixir semuanya adalah fungsi, termasuk pandangan.  Kompilasi tampilan sekali dan semua: dapatkan argumen, keluarkan html, tidak masuk ke disk. </p><br><h3 id="views">  Tampilan </h3><br><p>  Dalam Rails, view dipahami sebagai sebagian dan templat, sedangkan di Phoenix mereka terletak pada templat, dan dalam view, secara kasar, ada berbagai cara penyajian data.  Secara khusus, ada ganti render. </p><br><p>  Artinya, secara default, controller tidak membuat apa pun.  Semuanya disebut secara eksplisit.  Dan jika Anda tidak memiliki sebagian dan Anda tidak benar-benar membutuhkannya (misalnya, dalam kasus json, ketika mudah dibangun oleh kelas layanan), Anda mendefinisikan ulang render dengan cara seperti ini: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">def</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">render</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">show</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.json</span></span>", %{<span class="hljs-attribute"><span class="hljs-attribute">groups</span></span>: groups}) <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> %{ <span class="hljs-attribute"><span class="hljs-attribute">groups</span></span>: groups } <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br><p>  Dan sebagian tidak lagi dibutuhkan. </p><br><h3 id="heplers">  Heplers </h3><br><p>  Tidak ada di Phoenix.  Dan ini luar biasa!  Karena di rel kereta, biasanya, semua sampah dikumpulkan, yang entah malas didorong di sudut-sudut, atau hanya perlu mengisi sesuatu dengan cepat. </p><br><p>  Namun, metode dalam pengontrol, tampilan, dll.  Anda bisa menambahkan.  Ini dilakukan di tempat khusus <code>web/web.ex</code> dan terlihat lumayan. </p><br><h2 id="statika">  Statika </h2><br><p>  Dalam perkembangannya, semuanya seperti biasa, kecuali bahwa di phoenix mereka masih mengacaukan isi ulang live, yang pertama memanggil "Wow!"  efek.  Ini adalah ketika saya mengubah css, kembali ke browser, dan di sana perubahan itu sendiri sudah dimuat. </p><br><p>  Dalam produksi di Phoenix, perilaku statika sedikit berbeda dari rel.  Secara default, tempat-tempat di mana Anda dapat menyeret statika terdaftar secara eksplisit dan Anda tidak bisa hanya menambahkan file ke aset untuk mendistribusikannya.  Masih ada pemetaan aset default, sehingga Anda tidak berkeliaran di sekitar FS sekali lagi, tetapi segera mengambil file yang diinginkan dan memberikannya. </p><br><h2 id="assety">  Aset </h2><br><p>  Keluar dari kotak di Phoenix - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makan siang</a> .  Anda bisa menggantinya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpack</a> .  Tetapi ada lelucon yang cukup jujur ​​tentang fakta bahwa banyak proyek yang bengkok pada tahap pengaturan webpack. </p><br><p>  Singkatnya, js dan css lebih atau kurang terkumpul, tetapi dengan sisa statis di brunch tidak terlalu.  Salin dengan tangan Anda langsung ke proyek dari node_modules (saya tidak suka opsi ini sama sekali), atau menulis kait di bash.  Contohnya <a href="">seperti itu</a> . </p><br><h2 id="rabota-s-ssl">  Bekerja dengan SSL </h2><br><p>  Out of the box di Phoenix adalah server http kecil yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koboi</a> .  Tampak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cougar</a> ruby.  Mereka bahkan memiliki jumlah bintang yang sama di GitHub.  Tetapi entah bagaimana saya tidak mendapatkan pengaturan SSL di salah satu di atas.  Terutama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Let's Encrypt</a> , file konfigurasi server web tambahan dan perpanjangan sertifikat reguler.  Jadi sebagai server http - ok, tapi untuk ssl saya mengambil proxy ke localhost melalui apache / nginx. </p><br><h2 id="deploy">  Sebarkan </h2><br><p>  Secara umum berbeda dibandingkan dengan rel.  Di Rails, dalam versi minimum, ia mengendarai lobak ke server, menari dengan rebana untuk bundel, konfigurasi, aset, dan meluncurkan aplikasi.  Dan elixir menyusun dan <del>  menggali trem </del>  untuk meyakinkan lobak tidak akan naik.  Perlu mengumpulkan paket.  Dan di sini dimulai: </p><br><ul><li>  Anda akan mengetahui mengapa aplikasi diperlukan di <code>mix.exs</code> , karena tanpa menunjukkannya dengan benar di <code>mix.exs</code> , kesalahan yang luar biasa; </li><li>  Anda belajar bahwa variabel lingkungan dikompilasi pada saat paket itu dibuat, dan bukan pada saat diluncurkan, dan ini untuk pertama kalinya kejutan yang mengejutkan;  maka Anda belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">relx</a> bersama dengan <code>RELX_REPLACE_OS_VARS=true</code> dan membiarkannya sedikit; </li><li>  Anda terkejut bahwa dalam paket yang dikompilasi untuk produksi tidak ada yang mirip dengan menyapu, khususnya tidak ada migrasi dan Anda perlu entah bagaimana menjalankannya secara terpisah, misalnya, dari lingkungan dev melalui port forwarding ke database (atau melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eDeliver</a> , yang akan melakukan hal yang sama) . </li></ul><br><p>  Dan kemudian, saat Anda berurusan dengan hal di atas, pro memulai: </p><br><ul><li>  Anda dapat membuat paket swasembada dan tidak menaruh apa pun dari ketergantungan pada kendaraan tempur;  unzip tarball dan jalankan isinya;  kecuali erlang mungkin diperlukan untuk diluncurkan, karena versi kompilasi silangnya sedikit tidak penting dalam perakitan; </li><li>  Anda dapat melakukan rilis upgrade untuk digunakan tanpa downtime. </li></ul><br><h2 id="debag">  Debag </h2><br><p>  Elixir memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pry</a> dan bekerja seperti batu delima.  Bahkan ada <code>rails c</code> mitra yang terlihat seperti <code>iex -S mix</code> . </p><br><p>  Tetapi dalam produksi, Anda harus menggunakan konsol secara berbeda, karena paket dibuat dan <code>mix</code> tidak ada di dalamnya.  Anda harus terhubung ke proses kerja.  Ini sangat berbeda dari rail dan pada awalnya Anda menghabiskan banyak waktu mencari cara untuk meluncurkan konsol elixir dalam produksi, karena Anda mencari sesuatu yang mirip dengan rail.  Akibatnya, Anda memahami bahwa Anda perlu melakukan segalanya secara berbeda dan memanggil sesuatu seperti: <code>iex --name trace@127.0.0.1 --cookie 'from_env' --remsh 'my_app_name@127.0.0.1'</code> . </p><br><h2 id="prodolzhenie-sleduet">  Dilanjutkan ... </h2><br><p>  Fuh, saya lupa sesuatu.  Oh baiklah  Anda sebaiknya memberi tahu kami apa yang mengejutkan Anda di Elixir, dibandingkan dengan bahasa lain. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423459/">https://habr.com/ru/post/id423459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423445/index.html">Membuat struktur toko online: skema kategori</a></li>
<li><a href="../id423447/index.html">GLPH: Podcast Pemasaran Konten Baru</a></li>
<li><a href="../id423453/index.html">ZFS dan kecepatan akses disk di hypervisors</a></li>
<li><a href="../id423455/index.html">Tablet yang benar</a></li>
<li><a href="../id423457/index.html">Timlid bekerja pada 2018</a></li>
<li><a href="../id423461/index.html">Musim gugur suborbital</a></li>
<li><a href="../id423463/index.html">Seperti yang kami tulis algoritma analisis RFM lain</a></li>
<li><a href="../id423465/index.html">Apa yang harus dibaca tentang ITSM: buku, blog, dan artikel terbaru</a></li>
<li><a href="../id423467/index.html">Pengembang Rusia akan merilis katalog kompatibilitas produk</a></li>
<li><a href="../id423469/index.html">Nomor floating point liar barat tercepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>