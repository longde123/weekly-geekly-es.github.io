<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèΩ üëÇüèø üòó M√©todos de otimiza√ß√£o de c√≥digo para Redd. Parte 2: mem√≥ria n√£o armazen√°vel em cache e opera√ß√£o de barramento paralelo üõÄ ‚ôèÔ∏è üêü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo artigo, descobrimos que o cache √© certamente uma coisa √∫til, mas no que diz respeito √† l√≥gica do controlador, √†s vezes cria dificuldades. Em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todos de otimiza√ß√£o de c√≥digo para Redd. Parte 2: mem√≥ria n√£o armazen√°vel em cache e opera√ß√£o de barramento paralelo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468027/">  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo,</a> descobrimos que o cache √© certamente uma coisa √∫til, mas no que diz respeito √† l√≥gica do controlador, √†s vezes cria dificuldades.  Em particular, introduz imprevisibilidade de dura√ß√µes de pulso ou outros atrasos na forma√ß√£o program√°tica de diagramas de tempo.  Bem, e no plano "program√°tico geral", a m√° localiza√ß√£o da fun√ß√£o pode reduzir o ganho do cache para nada, constantemente provocando a reinicializa√ß√£o da mem√≥ria lenta.  Mencionei que h√° 15 anos t√≠nhamos que criar um pr√©-processador especial que solucionasse os problemas que surgiam para o processador SPARC-8, e prometi dizer como seria f√°cil corrigir essas dificuldades ao desenvolver um processador Nios II sintetizado recomendado para uso em Redd.  Chegou a hora de cumprir a promessa. <br><br><img src="https://habrastorage.org/webt/pr/sx/ix/prsxixkamqwdpusqqagnx0xnh1q.png"><br><a name="habracut"></a><br><h4>  Artigos anteriores da s√©rie: </h4><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados no Redd e depura√ß√£o usando o teste de mem√≥ria como exemplo.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. C√≥digo do programa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de n√∫cleo pr√≥prio para incorpora√ß√£o em um sistema de processador baseado em FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de programas para o processador central Redd no exemplo de acesso ao FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As primeiras experi√™ncias usando o protocolo de streaming no exemplo da comunica√ß√£o da CPU e do processador no FPGA do Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Merry Quartusel, ou como o processador ganhou vida.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√©todos de otimiza√ß√£o de c√≥digo para Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: efeito de cache.</a> </li></ol><br>  Hoje, nosso livro de refer√™ncia ser√° o <b>Embedded Design Handbook</b> , ou melhor, sua se√ß√£o <b>7.5.</b>  <b>Usando a mem√≥ria firmemente acoplada com o tutorial do processador Nios II</b> .  A se√ß√£o em si √© colorida.  Hoje, projetamos sistemas de processador para FPGAs da Intel no programa Platform Designer.  Nos dias de Altera, era chamado QSys (da√≠ a extens√£o <b>.qsys</b> do arquivo do projeto).  Por√©m, antes que o QSsys aparecesse, todos usavam seu ancestral, SOPC Builder (em cuja mem√≥ria a extens√£o do arquivo <b>.sopcinfo</b> foi <b>deixada</b> ).  Portanto, embora o documento esteja marcado com o logotipo da Intel, mas as imagens nele s√£o capturas de tela deste SOPC Builder.  Foi claramente escrito h√° mais de dez anos e, desde ent√£o, apenas os termos foram corrigidos.  √â verdade que os textos s√£o bastante modernos, portanto este documento √© bastante √∫til como um manual de treinamento. <br><br><h2>  Prepara√ß√£o de Equipamentos </h2><br>  Ent√£o  Queremos adicionar mem√≥ria ao nosso sistema de processador Spartan, que nunca √© armazenado em cache e, ao mesmo tempo, √© executado na velocidade mais alta poss√≠vel.  Obviamente, essa ser√° a mem√≥ria interna do FPGA.  Adicionaremos mem√≥ria para c√≥digo e dados, mas esses ser√£o blocos diferentes.  Vamos come√ßar com a mem√≥ria de dados como a mais simples.  <b>Adicionamos a mem√≥ria OnChip</b> j√° conhecida ao sistema. <br><br><img src="https://habrastorage.org/webt/4g/vv/nx/4gvvnxooo_8rfteiku1wm4l6yr8.png"><br><br>  Bem, digamos que seu volume ser√° de 2 kilobytes (o principal problema com a mem√≥ria interna do FPGA √© que ele √© pequeno, ent√£o voc√™ precisa salv√°-lo).  O resto √© mem√≥ria comum, que j√° adicionamos. <br><br><img src="https://habrastorage.org/webt/jd/et/sj/jdetsj-2tvd6ou6xdr_rzggote4.png"><br><br>  Mas n√£o vamos conect√°-lo ao barramento de dados, mas a um barramento especial.  Para faz√™-lo aparecer, entramos nas propriedades do processador, na guia <b>Caches and Memory Interfaces</b> e na lista de sele√ß√£o <b>N√∫mero de portas principais de dados fortemente acopladas,</b> selecione o valor 1. <br><br><img src="https://habrastorage.org/webt/bt/rj/m4/btrjm4ihtix-btomqh6ttgyjifs.png"><br><br>  Aqui est√° uma nova porta para o processador: <br><br><img src="https://habrastorage.org/webt/lm/j7/xu/lmj7xu6jk4lofwv9kdmdi1m4--u.png"><br><br>  Recentemente, conectamos o bloco de mem√≥ria rec√©m-adicionado a ele! <br><br><img src="https://habrastorage.org/webt/ea/vf/t_/eavft_i05i9qb9sn5duyrxvgyda.png"><br><br>  Outro truque √© atribuir endere√ßos a essa nova mem√≥ria.  O documento tem uma longa linha de racioc√≠nio sobre a otimiza√ß√£o da decodifica√ß√£o de endere√ßo.  Ele afirma que a mem√≥ria n√£o armazenada em cache deve ser diferenciada de todos os outros tipos de mem√≥ria por um bit claramente expresso do endere√ßo.  Portanto, no documento, toda a mem√≥ria n√£o armazen√°vel em cache pertence ao intervalo 0x2XXXXXXX.  Portanto, digite manualmente o endere√ßo 0x2000000 e bloqueie-o para que n√£o seja alterado com as seguintes atribui√ß√µes autom√°ticas. <br><br><img src="https://habrastorage.org/webt/nf/l3/qn/nfl3qn1zegllimprcc6xtol3yim.png"><br><br>  Bem, e puramente para est√©tica, renomeie o bloco ... Vamos cham√°-lo, digamos, <b>NonCachedData</b> . <br><br><img src="https://habrastorage.org/webt/7z/l-/8p/7zl-8pvknmn3thqgvx7cahpzzw8.png"><br><br>  Com hardware para mem√≥ria de dados n√£o em cache, √© isso.  Passamos para a mem√≥ria para armazenamento de c√≥digo.  Tudo √© quase o mesmo aqui, mas um pouco mais complicado.  De fato, tudo pode ser feito de forma totalmente id√™ntica, apenas a porta mestre do barramento √© aberta na lista <b>N√∫mero de portas mestre de instru√ß√µes fortemente acopladas</b> , no entanto, n√£o ser√° poss√≠vel depurar esse sistema.  Quando o programa √© preenchido com o depurador, ele flui para l√° atrav√©s do barramento de dados.  Quando parado, o c√≥digo desmontado tamb√©m √© lido pelo depurador atrav√©s do barramento de dados.  E mesmo que o programa seja carregado a partir de um carregador externo (ainda n√£o consideramos esse m√©todo, especialmente porque na vers√£o gratuita do ambiente de desenvolvimento somos obrigados a trabalhar apenas com o depurador JTAG conectado, mas em geral, ningu√©m pro√≠be isso), o preenchimento tamb√©m passa pelo barramento dados.  Portanto, a mem√≥ria ter√° que fazer porta dupla.  Para uma porta, conecte um assistente de instru√ß√µes n√£o armazenado em cache que funcione no hor√°rio principal e √† outra - um barramento de dados auxiliar em tempo integral.  Ele ser√° usado para baixar o programa de fora e obter o conte√∫do da RAM pelo depurador.  O resto do tempo esse pneu ficar√° inativo.  √â assim que tudo fica na parte te√≥rica do documento: <br><br><img src="https://habrastorage.org/webt/ks/sv/vt/kssvvtij9hdnujtgehodhaqwjmu.png"><br><blockquote>  Observe que o documento n√£o explica o motivo, mas observe que, mesmo com mem√≥ria de porta dupla, apenas uma porta pode ser conectada a um mestre n√£o armazenado em cache.  O segundo deve estar conectado ao habitual. </blockquote>  Vamos adicionar 8 kilobytes de mem√≥ria, torn√°-lo de porta dupla, deixar o restante por padr√£o: <br><br><img src="https://habrastorage.org/webt/kl/1q/_k/kl1q_kgyv67kvcjjzyiw-obrrm4.png"><br><br>  Adicione uma porta de instru√ß√µes n√£o armazen√°vel em cache ao processador: <br><br><img src="https://habrastorage.org/webt/tk/ib/2y/tkib2ydvc6f_lfi9nprwkzai0cu.png"><br><br>  Chamamos a mem√≥ria de <b>NonCachedCode</b> , conectamos a mem√≥ria aos barramentos, atribu√≠mos a ela o endere√ßo 0x20010000 e travamos (para as duas portas).  Total, temos algo parecido com isto: <br><br><img src="https://habrastorage.org/webt/84/1d/o_/841do_ssmf-r_a4ibqdyr2kksly.png"><br><br>  S√≥ isso.  Salvamos e geramos o sistema, coletamos o projeto.  O hardware est√° pronto.  Passamos para a parte do software. <br><br><h2>  Prepara√ß√£o do BSP na parte do software </h2><br>  Normalmente, depois de alterar o sistema do processador, basta selecionar o item de menu <b>Generate BSP</b> , mas hoje temos que abrir o BSP Editor.  Como raramente fazemos isso, deixe-me lembr√°-lo de onde o item de menu correspondente est√° localizado: <br><br><img src="https://habrastorage.org/webt/x4/nk/ub/x4nkubzhbxq26krtzce8nhuxmcw.png"><br><br>  L√° vamos para a guia <b>Script</b> do <b>vinculador</b> .  Vimos que adicionamos regi√µes que herdam nomes de blocos de RAM: <br><br><img src="https://habrastorage.org/webt/qs/_t/af/qs_taf1wiql9vccnl_7s_frbqci.png"><br><br>  Vou mostrar como adicionar uma se√ß√£o na qual o c√≥digo ser√° colocado.  Na se√ß√£o se√ß√£o, clique em Adicionar: <br><br><img src="https://habrastorage.org/webt/qa/8o/lu/qa8olur0jjxjhj2oz-dqwzmf3iy.png"><br><br>  Na janela exibida, forne√ßa o nome da se√ß√£o (para evitar confus√£o no artigo, o nomeei muito diferente do nome da regi√£o, ou seja, nccode) e associei-o √† regi√£o (selecionei <b>NonCachedCode</b> da lista): <br><br><img src="https://habrastorage.org/webt/ji/eo/to/jieotoad61gc1i-xarabcynmqyy.png"><br><br>  √â isso, gere o BSP e feche o editor. <br><br><h2>  Colocando c√≥digo em uma nova se√ß√£o de mem√≥ria </h2><br>  Deixe-me lembr√°-lo de que temos duas fun√ß√µes no programa herdadas do artigo anterior: <b>MagicFunction1 ()</b> e <b>MagicFunction2 ()</b> .  Na primeira passagem, os dois carregaram seus corpos no cache, vis√≠vel no oscilosc√≥pio.  Al√©m disso - dependendo da situa√ß√£o no ambiente, eles trabalhavam √† velocidade m√°xima ou constantemente se esfregavam com seus corpos, provocando downloads constantes da SDRAM. <br><br>  Vamos mover a primeira fun√ß√£o para um novo segmento n√£o armazenado em cache, deixar a segunda no lugar e, em seguida, executar algumas execu√ß√µes. <br><blockquote>  Para colocar uma fun√ß√£o em uma nova se√ß√£o, adicione o atributo de <b>se√ß√£o</b> a ela. </blockquote>  Antes de definir a fun√ß√£o <b>MagicFunction1 ()</b> , tamb√©m colocamos sua declara√ß√£o com este atributo: <br><br><pre><code class="plaintext hljs">void MagicFunction1()__attribute__ ((section("nccode"))); void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre> <br>  Realizamos a primeira execu√ß√£o de uma itera√ß√£o do loop (coloquei um ponto de interrup√ß√£o na linha while): <br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  Vemos o seguinte resultado: <br><br><img src="https://habrastorage.org/webt/vh/1q/jx/vh1qjxzrvwbudd99po6eerz47ja.png"><br><br>  Como voc√™ pode ver, a primeira fun√ß√£o √© realmente executada na velocidade m√°xima, a segunda √© carregada da SDRAM.  Execute a segunda execu√ß√£o: <br><br><img src="https://habrastorage.org/webt/l9/ce/iv/l9ceivh_xyn8ip_xtyqv18u4i2a.png"><br><br>  Ambas as fun√ß√µes operam na velocidade m√°xima.  E a primeira fun√ß√£o n√£o descarrega a segunda do cache, apesar do fato de que entre elas est√° a inser√ß√£o que eu deixei depois de escrever o √∫ltimo artigo: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Essa inser√ß√£o n√£o afeta mais a posi√ß√£o relativa das duas fun√ß√µes, pois a primeira delas foi deixada em uma √°rea completamente diferente da mem√≥ria. <br><br><h2>  Algumas palavras sobre dados </h2><br>  Da mesma forma, voc√™ pode criar uma se√ß√£o de dados n√£o armazenados em cache e colocar vari√°veis ‚Äã‚Äãglobais l√°, atribuindo-lhes o mesmo atributo, mas para economizar espa√ßo, n√£o darei exemplos. <br><br>  Criamos uma regi√£o para essa mem√≥ria, o mapeamento para a se√ß√£o pode ser feito da mesma maneira que para a se√ß√£o de c√≥digo.  Resta apenas entender como atribuir o atributo correspondente a uma vari√°vel.  Aqui est√° o primeiro exemplo de declara√ß√£o desses dados encontrados nas entranhas do c√≥digo gerado automaticamente: <br><br><pre> <code class="plaintext hljs">volatile alt_u32 alt_log_boot_on_flag \ __attribute__ ((section (".sdata"))) = ALT_LOG_BOOT_ON_FLAG_SETTING;</code> </pre><br><h2>  O que isso nos d√° </h2><br>  Bem, na verdade, a partir de coisas √≥bvias: agora podemos colocar a parte principal do c√≥digo no SDRAM e, na se√ß√£o n√£o armazen√°vel em cache, podemos destacar as fun√ß√µes que formam diagramas de tempo programaticamente ou cujo desempenho deve ser m√°ximo, o que significa que elas n√£o devem desacelerar devido a que alguma outra fun√ß√£o despeja constantemente o c√≥digo correspondente do cache. <br><br><h2>  D√™ uma olhada nos pneus. </h2><br>  Agora, observe atentamente os pneus no sistema de processador resultante.  Temos quase quatro deles.  Eu circulei em vermelho o √¥nibus principal (que √© a uni√£o dos dois, e √© por isso que escrevi ‚Äúquase‚Äù: fisicamente - existem dois pneus, mas logicamente - um).  Destaquei em verde o barramento que conduz √† mem√≥ria de instru√ß√µes n√£o armazenada em cache, em azul - para a mem√≥ria de dados n√£o armazenados em cache.  <b>Estes tr√™s pneus trabalham em paralelo e independentemente um do outro!</b> <br><br><img src="https://habrastorage.org/webt/kg/rv/wf/kgrvwfw1kncypo4x6mn4uehagng.png"><br><br>  Lembre-se, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre DMA,</a> argumentei que um dos fatores limitadores de desempenho √© que os dados s√£o transmitidos no mesmo barramento?  O bloco DMA l√™ dados do barramento, grava dados nele e, ao mesmo tempo, o n√∫cleo do processador usa o mesmo barramento.  Como voc√™ pode ver, essa desvantagem de sistemas fechados √© completamente eliminada no FPGA.  Nos controladores prontos, os fabricantes, ao estabelecer as conex√µes, s√£o for√ßados a se separar entre necessidades e capacidades.  O programador pode precisar dessa op√ß√£o.  E tal.  E tal.  E ent√£o ... Muitas coisas podem ser necess√°rias.  Mas os recursos custam dinheiro e nem sempre h√° espa√ßo suficiente para eles no cristal selecionado.  Voc√™ n√£o pode postar tudo.  Temos que escolher o que todos realmente precisam e o que √© necess√°rio em casos isolados.  E quais casos isolados devem ser introduzidos e quais devem ser esquecidos.  E, em seguida, aparecem solu√ß√µes de compromisso, cujas sutilezas, se houver um desejo de us√°-las, o programador deve ter em mente.  No nosso caso, podemos agir sem mais delongas.  O que precisamos hoje √© hoje colocado.  Nosso recurso √© flex√≠vel.  N√≥s o gastamos para que o equipamento seja ideal para a tarefa de hoje.  Para as tarefas de amanh√£ e de ontem, os recursos n√£o precisam ser reservados.  Por√©m, nos dias de hoje, colocaremos tudo de forma que o programa funcione da maneira mais eficiente poss√≠vel, sem a necessidade de del√≠cias especiais de programa√ß√£o. <br><br>  Era uma vez, em uma universidade em um curso sobre processadores de sinais, aprendemos a arte de usar dois √¥nibus em paralelo com uma equipe.  Tanto quanto sei, nos modernos controladores ARM, o conhecimento detalhado da matriz de barramento tamb√©m permite a otimiza√ß√£o.  Mas tudo isso √© bom quando um desenvolvedor trabalha com o mesmo sistema h√° anos.  Se voc√™ precisar montar pe√ßas de hardware completamente diferentes de projeto para projeto, n√£o poder√° memorizar tudo.  No caso dos FPGAs, n√£o estudamos os recursos do ambiente, somos livres para personalizar o ambiente para n√≥s mesmos. <br><blockquote>  Em rela√ß√£o √† abordagem "n√£o gastamos muito tempo em desenvolvimento", soa assim: <br>  N√£o precisamos nos esfor√ßar para otimizar o uso de pneus padr√£o prontos, podemos coloc√°-los rapidamente da maneira mais ideal para a tarefa a ser resolvida, concluir rapidamente esse desenvolvimento auxiliar e garantir rapidamente o processo de depura√ß√£o ou teste do projeto principal. </blockquote>  Vamos dar uma olhada em um exemplo de inclus√£o de um bloco DMA no <b>Guia do Usu√°rio de IP de Perif√©ricos Incorporados</b> para consolidar o material. <br><br><img src="https://habrastorage.org/webt/ww/hw/yg/wwhwygxdtfoxpuyftp00h2p_xde.png"><br><br>  Vemos tr√™s conex√µes independentes.  Dados de entrada (nesta figura, √© um barramento projetado na mem√≥ria), dados de sa√≠da (nesta figura, √© um tipo completamente diferente de barramento - uma interface de fluxo) e comunica√ß√£o com o processador de controle.  Ningu√©m se preocupa em conectar tudo a barramentos diferentes, ent√£o o trabalho ser√° paralelo.  Os dados de entrada (por exemplo, da SDRAM) ir√£o para um fluxo, com o qual ningu√©m interfere;  a sa√≠da ir√° para um fluxo diferente, digamos, para o canal FT245-FIFO, que j√° consideramos;  e o processador central n√£o corroer√° esses barramentos de rel√≥gio, pois o barramento principal est√° isolado.  Embora neste caso, √© claro, a mem√≥ria no SDRAM, estando em um barramento separado, esteja indispon√≠vel de forma program√°tica.  Mas ningu√©m impedir√° que seja lido pelo DMA.  Se o objetivo √© alcan√ßar alto desempenho com o buffer, ele deve ser alcan√ßado a todo custo.  A menos que o programa inteiro precise caber na mem√≥ria incorporada no FPGA, pois n√£o h√° outras unidades de armazenamento no hardware Redd. <br><br>  Para paralelizar pneus, voc√™ tamb√©m pode usar pneus sem cache, porque vimos que pode haver v√°rios.  V√°rias restri√ß√µes s√£o impostas aos escravos conectados a esses barramentos: <br><br><ul><li>  o escravo √© sempre um no √¥nibus; </li><li>  o escravo n√£o usa o mecanismo de atraso do barramento; </li><li>  a lat√™ncia de grava√ß√£o √© sempre zero; a lat√™ncia de leitura √© sempre uma. </li></ul><br>  Se essas condi√ß√µes forem atendidas, esse dispositivo escravo poder√° ser conectado a um barramento n√£o armazenado em cache.  Obviamente, provavelmente, ser√° um barramento de dados. <br><br>  Em geral, conhecendo esses princ√≠pios b√°sicos, voc√™ certamente pode us√°-los em tarefas reais.  Mas, em geral, voc√™ pode.  Voc√™ pode ficar sem isso, se o resultado for alcan√ßado por meios convencionais.  Mas tenha isso em mente.  √Äs vezes, otimizar um sistema por meio desses mecanismos √© mais simples do que ajustar o programa. <br><br><h2>  Conclus√£o </h2><br>  Examinamos uma t√©cnica para transferir se√ß√µes de c√≥digo cr√≠ticas para o desempenho ou para a previsibilidade da execu√ß√£o do processamento na mem√≥ria n√£o armazen√°vel em cache.  Ao longo do caminho, examinamos a possibilidade de otimizar o desempenho atrav√©s do uso de v√°rios pneus operando em paralelo e independentemente um do outro. <br><br>  Para finalizar o t√≥pico, ainda precisamos aprender como aumentar a frequ√™ncia do clock do sistema (agora ele est√° limitado aos componentes que geram pulsos de clock para o chip SDRAM).  Mas como os artigos seguem o princ√≠pio de ‚Äúuma coisa - um artigo‚Äù, faremos isso na pr√≥xima vez. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468027/">https://habr.com/ru/post/pt468027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468017/index.html">O Maybe Monad via ass√≠ncrono / espera em C # (sem a tarefa Ov!)</a></li>
<li><a href="../pt468019/index.html">Desenvolvimento de site no WebAssembly usando NetCore 3 e Blazor</a></li>
<li><a href="../pt468021/index.html">PHP, quanta abstra√ß√£o para as pessoas?</a></li>
<li><a href="../pt468023/index.html">Intelig√™ncia artificial no jogo de luta Shadow Fight 3</a></li>
<li><a href="../pt468025/index.html">Como configurar o SNI no Zimbra OSE?</a></li>
<li><a href="../pt468031/index.html">Portamos um jogo multiplayer de C ++ para a web com Cheerp, WebRTC e Firebase</a></li>
<li><a href="../pt468035/index.html">Fa√ßa o download da impressora usando um controlador de jogo ou 8 patentes incomuns para dispositivos de entrada</a></li>
<li><a href="../pt468039/index.html">Moscow Kubernetes Meetup # 6 em Acronis (Fiztehpark) 03/03/2019</a></li>
<li><a href="../pt468041/index.html">An√∫ncio da interface da web do Kubernetes Web View (e uma breve vis√£o geral de outras UIs da web para o Kubernetes)</a></li>
<li><a href="../pt468043/index.html">Como criar um kit de interface do usu√°rio que est√° √† venda. Etapas do desenvolvimento de um sistema de design comercial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>