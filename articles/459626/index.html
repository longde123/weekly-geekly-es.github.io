<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÑÔ∏è üìç ‚ôøÔ∏è Windows Notification Facility: la superficie de ataque m√°s indocumentada üë©üèΩ üçª üíáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Debajo del corte hay una traducci√≥n de la presentaci√≥n "La instalaci√≥n de notificaciones de Windows: la superficie de ataque de kernel m√°s indocumenta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: la superficie de ataque m√°s indocumentada</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Debajo del corte hay una traducci√≥n de la <strong>presentaci√≥n</strong> "La instalaci√≥n de notificaciones de Windows: la superficie de ataque de kernel m√°s indocumentada hasta ahora" presentada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alex Ionescu</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gabrielle Viala</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la conferencia BlackHat 2018</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Lo que se discutir√° en la publicaci√≥n.</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© es Windows Notification Facility (WNF)?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPor qu√© apareci√≥ WNF?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nombres de estado WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistema de llamadas para trabajar con WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de modo de usuario de alto nivel (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de nivel de kernel de alto nivel (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WNF Analysis Utilities</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Superficie de ataque WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nombres de estado WNF interesantes y sensibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proceso de inyecci√≥n usando WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones para futuras investigaciones</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  ¬øQu√© es Windows Notification Facility (WNF)? </h3><br><p>  Windows Notification Facility es un mecanismo de notificaci√≥n (disponible tanto en el n√∫cleo como en el modo de usuario), que se basa en un modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editor-suscriptor</a> ( <em>pubsub</em> , Publisher / Subscriber).  El mecanismo se agreg√≥ en Windows 8: en parte para resolver algunas limitaciones de dise√±o de larga data en el sistema operativo, pero tambi√©n sirvi√≥ como base para la implementaci√≥n de notificaciones push similares a iOS / Android. </p><br><p>  Su caracter√≠stica clave es que es un modelo <em>ciego</em> (en su mayor√≠a sin registro) que permite la suscripci√≥n y publicaci√≥n sin orden.  Esto implica que un consumidor puede suscribirse a una notificaci√≥n incluso antes de que la fuente haya publicado la notificaci√≥n.  Y que el que genera los eventos no est√° obligado a "registrar" el aviso por adelantado. </p><br><p>  Adem√°s, el mecanismo admite: </p><br><ul><li>  notificaciones permanentes y temporales </li><li>  identificadores √∫nicos que aumentan mon√≥tonamente </li><li>  b√∫fer de carga √∫til (hasta 4 kilobytes) para cada evento </li><li>  modelo de notificaci√≥n de grupo de subprocesos con serializaci√≥n basada en grupos </li><li>  Un modelo de seguridad basado en el alcance que implementa descriptores de seguridad a trav√©s del mecanismo est√°ndar <abbr title="Lista de control de acceso discrecional">DACL</abbr> / <abbr title="Lista de control de acceso al sistema">SACL</abbr> </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  ¬øPor qu√© apareci√≥ WNF? </h3><br><p>  Considere un ejemplo can√≥nico: hay un controlador que quiere saber que se ha conectado un volumen con acceso de lectura y escritura.  Para notificarle esto, Autochk (un an√°logo de <abbr title="verificaci√≥n de consistencia del sistema de archivos">fsck</abbr> en Windows) informa un evento llamado VolumesSafeForWriteAccess.  Pero para informar un evento, primero debe crear el objeto del evento en s√≠. </p><br><p>  Tambi√©n necesitamos saber que Autochk ya est√° trabajando en el volumen, pero a√∫n no ha se√±alado el evento que estamos esperando.  Mala soluci√≥n: sentarse en un bucle con sleep (), verificar la presencia de un evento y, cuando se crea el evento, espere. </p><br><p>  Pero despu√©s de salir de la aplicaci√≥n de Windows, todos sus descriptores est√°n cerrados.  Y cuando el objeto no tiene descriptores, se destruye.  Entonces, ¬øqui√©n llevar√° a cabo este evento? </p><br><p>  Sin WNF, la soluci√≥n es que el n√∫cleo del sistema operativo genere un evento antes de que se cargue cualquier controlador, y que Autochk lo abra como lo har√≠a un consumidor, pero en lugar de esperar, deber√≠a se√±alar este evento. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Nombres de estado WNF </h3><br><p>  En el mundo WNF, un nombre de estado es un n√∫mero de 64 bits.  Pero hay un truco: de hecho, es una estructura codificada.  El nombre del estado tiene una <em>versi√≥n</em> , <em>una vida √∫til</em> , un <em>alcance</em> , un <em>indicador de persistencia de datos</em> y un <em>n√∫mero de serie √∫nico</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Pero estos datos estar√°n disponibles solo si pro-XOR es un n√∫mero de 64 bits con una constante m√°gica: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Vida del nombre del estado </h4><br><p>  El nombre del estado de WNF puede ser (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bien conocido </li><li>  permanente </li><li>  persistente </li><li>  temporal </li></ul><br><p>  Los primeros tres est√°n asociados con las claves correspondientes en el registro, donde se almacenar√° la informaci√≥n de estado: </p><br><ul><li>  los nombres conocidos viven en HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notificaciones </li><li>  los nombres persistentes viven en HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notificaciones </li><li>  los nombres persistentes viven en HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Los nombres conocidos tienen su propia peculiaridad: no se pueden registrar.  Dicho nombre ya deber√≠a presentarse en el registro en el momento del inicio del sistema.  Los nombres persistentes y persistentes requieren el privilegio SeCreatePermanentPrivilege incluido (como otros objetos globales) para crearlos.  Los nombres persistentes viven fuera del proceso de registro, mientras que los nombres persistentes sobreviven al reinicio del sistema. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Alcance de los datos </h4><br><p>  El √°mbito de datos define el primer l√≠mite de seguridad alrededor del nombre de estado WNF; determina qui√©n lo ve y tiene acceso a √©l.  El alcance del nombre del estado puede ser: </p><br><ul><li>  el sistema </li><li>  el carro </li><li>  sesi√≥n de usuario </li><li>  el usuario </li><li>  el proceso </li></ul><br><p>  Adem√°s de proporcionar l√≠mites de seguridad, los √°mbitos WNF se pueden usar para proporcionar diferentes instancias de datos para el mismo nombre.  El n√∫cleo (como con otros mecanismos de seguridad) omite las comprobaciones de acceso de estado.  El privilegio TCB permite el acceso de alcance cruzado a los nombres de estado WNF. </p><br><p>  El "sistema" de alcance y la "m√°quina" de alcance son √°mbitos globales.  No tienen sus propios identificadores (usan contenedores globales diferentes).  El alcance de la sesi√≥n del usuario utiliza el identificador de sesi√≥n (ID de sesi√≥n) como ID.  El alcance de un usuario espec√≠fico utiliza el SID de este usuario como identificador.  La direcci√≥n del objeto EPROCESS es el identificador del alcance del proceso. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  N√∫meros de secuencia </h4><br><p>  Para garantizar la unicidad, cada nombre de estado tiene un n√∫mero de secuencia √∫nico de 51 bits.  Los nombres conocidos incluyen una etiqueta de familia de 4 caracteres en su n√∫mero de serie, y los 21 bits restantes se utilizan como un identificador √∫nico.  Los nombres permanentes almacenan su n√∫mero incremental con el valor de registro "SequenceNumber".  Los nombres persistentes y temporales usan un contador de incremento com√∫n, que se encuentra en una variable global.  Estos datos se almacenan y procesan por separado para cada contenedor (por silo) y est√°n disponibles en PspHostSiloGlobals-&gt; WnfSiloState. </p><br><p>  Dentro de Microsoft, cada nombre WNF tiene un identificador "amigable" que se usa en el c√≥digo, a veces se almacena en el espacio de nombres global con el mismo nombre.  Por ejemplo, el s√≠mbolo nt! WNF_BOOT_DIRTY_SHUTDOWN, que tiene el valor 0x1589012fa3bc0875.  Despu√©s de XOR con la constante m√°gica <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY</abbr> obtenemos el valor 0x544f4f4200000801, que puede interpretarse a nivel de bits como: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Sistema de llamadas para trabajar con WNF </h3><br><p>  Las llamadas al sistema Kernel le permiten registrar y eliminar nombres de estado de WNF, publicar y recibir datos de nombres de estado de WNF y tambi√©n recibir varias notificaciones de WNF. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Registrar nombre de estado WNF </h4><br><p>  Con la excepci√≥n de nombres conocidos (como se mencion√≥ anteriormente), el nombre de estado WNF se puede registrar mientras se ejecuta el sistema operativo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Hay un sistema sim√©trico llamado ZwDeleteWnfStateName con el que puede eliminar el nombre del estado registrado (de nuevo, excepto los conocidos). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Publicar datos de estado de WNF </h4><br><p>  Para establecer o cambiar los datos del nombre de estado WNF, puede usar la llamada al sistema ZwUpdateWnfStateData: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Hay un sistema sim√©trico que llama a ZwDeleteWnfStateData para eliminar (limpiar) los datos del nombre de estado WNF. </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Obtener datos de estado de WNF </h4><br><p>  Para solicitar los datos del nombre de estado WNF, se puede utilizar la siguiente llamada al sistema (la mayor√≠a de los par√°metros son similares a la funci√≥n Actualizar): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  La verdadera fortaleza radica en el hecho de que las funciones API Actualizar y Consultar no requieren de hecho un nombre de estado WNF <u>registrado</u> .  Y si el nombre no es temporal (y el c√≥digo de llamada tiene suficientes privilegios), ¬°se puede registrar una instancia del nombre en tiempo real! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  Notificaciones de WNF </h4><br><p>  Hasta ahora, hemos asumido que el consumidor sabe cu√°ndo llamar a la funci√≥n de adquisici√≥n de datos.  Pero tambi√©n est√° <em>bloqueando la lectura</em> , que funciona utilizando un sistema de notificaci√≥n (que est√° m√°s cerca del verdadero modelo de editor-suscriptor). </p><br><p>  Primero, el proceso debe registrar el evento llamando a la funci√≥n ZwSetWnfProcessNotificationEvent.  Luego debe llamar a la funci√≥n ZwSubscribeWnfStateChange, especificando una m√°scara de evento para obtener el identificador de suscripci√≥n en la salida.  Los eventos pueden ser de dos tipos: </p><br><ul><li>  Notificaciones de datos: <br><ul><li>  0x01 - apariencia de datos </li><li>  0x10 - destrucci√≥n de nombre </li></ul></li><li>  Meta Metanotificaciones <br><ul><li>  0x02: aparici√≥n de un suscriptor que recibe notificaciones de datos (suscriptor de datos) </li><li>  0x04: aparici√≥n de un suscriptor que recibe meta notificaciones (Meta suscriptor) </li><li>  0x08: aparici√≥n de un suscriptor que recibe notificaciones de datos y metanotificaciones (suscriptor gen√©rico) </li></ul></li></ul><br><p>  Entonces debe esperar el evento que se grab√≥.  Y cada vez que el evento se convierte en una se√±al, debe llamar a la funci√≥n ZwGetCompleteWnfStateSubscription, que devuelve WNF_DELIVERY_DESCRIPTOR. </p><br><p>  Pero estas funciones API de bajo nivel tienen un problema (gracias a Gabi por investigarlo): cada proceso solo puede tener un evento registrado. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  API de modo de usuario de alto nivel (ntdll) </h3><br><p>  Cuando se trata de notificaciones, las cosas se complican, por lo que la capa rtl de ntdll.dll proporciona una interfaz m√°s simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  De hecho, no es necesario llamar directamente a los servicios del sistema: solo use una √∫nica cola de eventos controlada por ntdll.dll. </p><br><p>  Detr√°s de escena, el contenido de WNF_DELIVERY_DESCRIPTOR se convierte en par√°metros de devoluci√≥n de llamada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Para cada nueva suscripci√≥n, se realiza una entrada, que se coloca en la lista a la que apunta la variable global RtlpWnfProcessSubscriptions.  La lista se basa en uno de los campos WNF_NAME_SUBSCRIPTION, que es de tipo LIST_ENTRY.  Cada WNF_NAME_SUBSCRIPTION, a su vez, tiene otro campo LIST_ENTRY para organizar una lista de WNF_USER_SUBSCRIPTION con una devoluci√≥n de llamada y contexto. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  API de nivel de kernel de alto nivel (Ex) </h3><br><p>  WNF tambi√©n proporciona funciones casi id√©nticas para el c√≥digo del modo kernel (que se puede usar desde el controlador): tanto a trav√©s de llamadas al sistema exportadas como a trav√©s de funciones API de alto nivel en el tiempo de ejecuci√≥n (capa Ex). </p><br><p>  La funci√≥n ExSubscribeWnfStateChange acepta el nombre de estado, las m√°scaras de tipo y la direcci√≥n de la funci√≥n de devoluci√≥n de llamada + contexto como entrada, y devuelve un descriptor de suscripci√≥n.  Las funciones de devoluci√≥n de llamada reciben el nombre de destino, la m√°scara de eventos, la etiqueta de cambio, pero no el b√∫fer o su tama√±o. </p><br><p>  La funci√≥n ExQueryWnfStateData, basada en el descriptor de suscripci√≥n pasado, lee los datos del estado actual.  De hecho, cada devoluci√≥n de llamada termina llamando a la funci√≥n ExQueryWnfStateData para obtener los datos asociados con la notificaci√≥n. </p><br><p>  Tanto para las suscripciones en modo kernel como para las suscripciones en modo usuario, WNF (para rastrear suscripciones) crea una instancia de la estructura WNF_SUBSCRIPTION.  Pero para el modo de usuario, algunos campos no se completar√°n, por ejemplo, Devoluci√≥n de llamada y Contexto, porque para el modo de usuario, ntdll.dll almacena y procesa las direcciones de los controladores. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  Estructuras de datos WNF </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>De un traductor</em></u> : vea la siguiente secci√≥n. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  WNF Analysis Utilities </h3><br><p>  <u><em>De un traductor</em></u> : aqu√≠ vale la pena recordar nuevamente que la presentaci√≥n fue realizada no solo por Alex, sino tambi√©n por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gabrielle Viala</a> .  En particular, su autor√≠a pertenece al m√≥dulo WnfCom que se describe a continuaci√≥n.  Adem√°s, Gabrielle describi√≥ las estructuras internas de WNF con suficiente detalle (vea la ilustraci√≥n en la secci√≥n anterior).  Desafortunadamente, la mayor√≠a de sus diapositivas est√°n ausentes en el pdf de la presentaci√≥n (indicado como el original) o se indican exclusivamente por t√≠tulos.  Pero: </p><br><ul><li>  Esta es una excelente ocasi√≥n para ver una grabaci√≥n de su actuaci√≥n conjunta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Windows Notification Facility: Pelando la cebolla de la superficie de ataque de kernel m√°s indocumentada hasta</a> el momento (el comienzo de Gabrielle ~ 19: 27).  ¬°All√≠ (adem√°s de las estructuras de datos) habr√° una historia sobre c√≥mo arreglaron la extensi√≥n del depurador! Wnf (spoiler - usando el m√©todo descrito en The NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reparando extensiones de depurador rotas</a> ) </li><li>  Gabrielle tiene un buen art√≠culo por separado (detallado, no como una presentaci√≥n): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jugar con Windows Notification Facility (WNF)</a> , que tambi√©n es muy recomendable para leer a todos los interesados. </li></ul><br><p>  <u><em>Y del traductor</em></u> : si alguien quiere complementar la traducci√≥n actual con el contenido de las diapositivas de Gabrielle o ampliar la traducci√≥n de la taquigraf√≠a de cualquier parte del video del discurso, bienvenido.  Para la conveniencia de agregar / cambiar fragmentos grandes, puedo publicar la fuente de traducci√≥n en github (u otro servidor de control de versiones). </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom es un m√≥dulo de Python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente de github</a> ) que muestra la interoperabilidad a trav√©s de WNF.  Caracter√≠sticas clave: </p><br><ul><li>  le permite leer / escribir datos de instancias de instancias existentes </li><li>  le permite crear nombres de estado temporales (como <em>servidor</em> ) </li><li>  le permite obtener una instancia de un objeto del lado del <em>cliente</em> que procesar√° notificaciones sobre el cambio de una instancia espec√≠fica de un nombre </li></ul><br><p>  Ejemplo de uso: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump es una utilidad de l√≠nea de comandos escrita en C. El archivo ejecutable se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ionescu007/wnfun</a> seleccionando el subdirectorio de la profundidad de bits requerida.  La utilidad se puede utilizar para buscar informaci√≥n sobre nombres de estado WNF: </p><br><ul><li>  -d ( <u>D</u> ump) Volcar todos los nombres de estado WNF utilizando una enumeraci√≥n basada en el registro.  Se puede complementar con opciones: <br><ul><li>  -v ( <u>V</u> erbose) Una salida detallada que incluye un volcado hexadecimal de datos de estado WNF; </li><li>  -s (Seguridad) Descriptores de seguridad: cadenas de permisos SDDL para el nombre de estado WNF. </li></ul></li><li>  -b ( <u>B</u> rute-force) Enumeraci√≥n directa de nombres de estado WNF temporales (m√°s sobre esto a continuaci√≥n) </li><li>  -i (Informaci√≥n) Muestra informaci√≥n sobre un solo nombre de estado WNF especificado </li><li>  -r ( <u>R</u> ead) Lee datos del nombre de estado WNF especificado </li><li>  -w ( <u>W</u> rite) Escribe datos en el nombre de estado WNF especificado </li><li>  -n ( <u>N</u> otificaci√≥n) Registre un suscriptor de notificaciones para el nombre de estado WNF especificado (en adelante ser√° un caso de uso m√°s espec√≠fico con Edge) </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  Superficie de ataque WNF </h3><br><p>  Esta secci√≥n (m√°s precisamente, sus subsecciones) discutir√° posibles ataques y datos WNF sensibles e interesantes. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Divulgaci√≥n de datos privilegiados </h4><br><p>  Al leer los miles de nombres de estado WNF que existen en el sistema, se pueden observar varios, cuyos datos parecen muy interesantes.  Entre ellos, algunos cuyos datos son sospechosamente similares a los punteros u otros datos privilegiados. </p><br><p>  Despu√©s de jugar en varias m√°quinas, en algunos casos fue posible encontrar un mont√≥n, una pila y otra informaci√≥n privilegiada que se divulg√≥ a trav√©s de los l√≠mites de privilegios.  Los informes de errores / vulnerabilidades se enviaron a MSRC en julio, pero se corrigieron en noviembre (despu√©s de la presentaci√≥n).  Por ejemplo: ¬°4 kilobytes de pila se filtraron a trav√©s del evento WNF_AUDC *! </p><br><p>  Los principales problemas son los mismos que vimos en estudios anteriores de j00ro, taviso y otros.  Ciertos nombres de estado WNF contienen estructuras de datos codificados con varios problemas de relleno y / o alineaci√≥n.  En algunos casos, las p√©rdidas de memoria no inicializadas. <br>  <u><em>Del traductor</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n de la parte introductoria del documento Detecci√≥n de la divulgaci√≥n de la memoria del n√∫cleo con emulaci√≥n x86 y seguimiento de manchas de Mateusz Jurczyk, tambi√©n conocido como j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Descubrimiento de nombres de estado y permisos </h4><br><p>  El primer enfoque fue descubrir todos los posibles nombres de estado que podr√≠an manipularse maliciosamente.  Para nombres conocidos, permanentes y persistentes, la enumeraci√≥n es factible enumerando las claves de registro.  Luego, los valores encontrados se pueden comparar con identificadores amigables (hay varios lugares donde puede encontrarlos :)) </p><br><p>  Luego, tambi√©n podemos ver el descriptor de seguridad en el registro (esto es lo primero en el b√∫fer de datos).  El descriptor de seguridad no es can√≥nico: no tiene un propietario y un grupo, por lo que t√©cnicamente no es v√°lido.  Pero no hay problema en sustituir un propietario y un grupo falsos para <em>corregir</em> el descriptor de seguridad. </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Detecci√≥n de nombres de estado temporales y sus permisos. </h4><br><p>  Pero con nombres temporales, los trucos descritos anteriormente no funcionar√°n: no est√°n en el registro.  Y solo el n√∫cleo almacena estructuras de datos para ellos (! Wnf) en la memoria.  Pero los nombres temporales en realidad no son tan dif√≠ciles de forzar: </p><br><ul><li>  La versi√≥n siempre importa 1 </li><li>  La vida siempre importa WnfTemporaryStateName </li><li>  La marca permanente siempre se borra (el nombre de estado temporal no puede tener datos permanentes) </li><li>  El alcance (alcance) puede tomar uno de los 4 valores </li></ul><br><p>  S√≠, ¬°pero el n√∫mero de secuencia restante es de 51 bits!  De hecho ... pero no olvides que los n√∫meros de serie est√°n creciendo de forma mon√≥tona.  Y para los nombres temporales, la secuencia se restablece a 0 en cada arranque.  Convencionalmente, puede tomar una ventana de un mill√≥n de n√∫meros de serie: en un bucle, verifique la existencia de cada nombre (comenzando desde 0) llamando a ZwQueryWnfStateNameInformation con la clase de informaci√≥n solicitada WnfInfoStateNameExist (dado que el error de acceso tambi√©n indica la existencia de un nombre).  Si no existen otros millones de nombres, puede detener la b√∫squeda. </p><br><p>  Los descriptores de seguridad de nombres temporales (como otros datos de nombres temporales) se almacenan en el n√∫cleo.  Por lo tanto, la √∫nica forma de solicitarlos es la extensi√≥n! Wnf al depurar el modo kernel.  Pero podemos: </p><br><ul><li>  Haga una conclusi√≥n sobre los permisos de lectura cuando intente leer datos. </li><li>  Para concluir que se permite la grabaci√≥n al intentar escribir datos.  Pero vale la pena considerar que una escritura exitosa de incluso 0 bytes destruye los datos que el consumidor real a√∫n no ha logrado obtener.  Y nuevamente, hay un truco: podemos aplicar el sello de cambio apropiado.  Estamos tratando de escribir con la etiqueta 0xFFFFFFFF: la etiqueta se verifica despu√©s de la verificaci√≥n de acceso, por lo tanto, el valor del error produce una p√©rdida de permiso de escritura. </li></ul><br><p>  Esto no nos da un descriptor de seguridad completo, pero al ejecutar el c√≥digo con diferentes privilegios podemos tener una idea de las restricciones para diferentes cuentas del sistema (IL / Usuario / Administrador / SISTEMA bajo). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Listado de suscriptores </h4><br><p>  En la estructura WNF_PROCESS_CONTEXT, uno de los campos es el encabezado de la lista (LIST_ENTRY) de todas las suscripciones de este proceso.  Cada suscripci√≥n es una instancia separada de WNF_SUBSCRIPTION. </p><br><p>  Los suscriptores en modo kernel son principalmente propiedad del proceso del Sistema.  Podemos usar el comando! List debugger para volcar controladores y sus par√°metros registrados en el proceso del sistema WNF_SUBSCRIPTION.  Vale la pena se√±alar que, en algunos casos, se utiliza un agregador de eventos (CEA.SYS), que oculta las direcciones de devoluci√≥n de llamada reales en su estructura de contexto. </p><br><p>  Podemos repetir este enfoque para los procesos en modo de usuario, pero la direcci√≥n de devoluci√≥n de llamada ser√° NULL, ya que estos son suscriptores en modo de usuario.  Por lo tanto, debemos unirnos al espacio de usuario del proceso, obtener la tabla RtlpWnfProcessSubscriptions y luego volcar la lista de instancias WNF_USER_SUBSCRIPTION, cada una de las cuales ya contiene la direcci√≥n de devoluci√≥n de llamada.  Desafortunadamente, este personaje es est√°tico, lo que significa que no est√° en caracteres abiertos, pero se puede encontrar al desarmarlo.  Y nuevamente vale la pena prestar atenci√≥n (por analog√≠a con el modo de n√∫cleo CEA.SYS) que muchos de los controladores de modo de usuario usan el agregador de eventos (EventAggregation.dll), que almacena la devoluci√≥n de llamada en su contexto. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Nombres de estado WNF interesantes y sensibles </h3><br><p>  Esta secci√≥n proporcionar√° algunos ejemplos interesantes de c√≥mo algunos nombres de estado WNF revelan informaci√≥n del sistema. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Determinar el estado del sistema y el comportamiento del usuario utilizando WNF </h4><br><p>  Algunos identificadores WNF se pueden usar para obtener informaci√≥n sobre el estado de la m√°quina que le interesa: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Estado inal√°mbrico </li><li>  WNF_BLTH_BLUETOOTH_STATUS - de manera similar, pero para Bluetooth (tambi√©n WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE: muestra la fuente de alimentaci√≥n (bater√≠a o adaptador de corriente) </li><li>  WNF_SEB_BATTERY_LEVEL: contiene el nivel de bater√≠a </li><li>  WNF_CELL_ *: en Windows Phone contiene informaci√≥n sobre: ‚Äã‚Äãred, n√∫mero, intensidad de la se√±al, EDGE o 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER ‚Äî   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT ‚Äî    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED ‚Äî    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      ‚Äî       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE ‚Äî     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST ‚Äî   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK ‚Äî ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND ‚Äì   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory ‚Äî    </li><li>   ( ) ‚Äî               </li><li>   (Atom) ‚Äî            </li><li>    ‚Äî  ,   WM_COPYDATA  DDE,       </li><li> GUI  ‚Äî    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Llamada a procedimiento asincr√≥nico">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " ‚Äî  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Control de protecci√≥n de flujo">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> github</a> )   explorer (  ‚Äî  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restaurar el controlador original a WNF_USER_SUBSCRIPTION y recursos asignados gratis </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459626/">https://habr.com/ru/post/459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459616/index.html">MIPT abre el primer programa de maestr√≠a avanzada de Rusia en Inform√°tica e Ingenier√≠a de Software</a></li>
<li><a href="../459618/index.html">Algunas caracter√≠sticas poco conocidas de docker-compose</a></li>
<li><a href="../459620/index.html">TDDx2, BDD, DDD, FDD, MDD y PDD, o lo que quieras saber sobre el desarrollo impulsado</a></li>
<li><a href="../459622/index.html">Como los juegos para Sega Saturn fueron escritos en 1995</a></li>
<li><a href="../459624/index.html">Drones militares</a></li>
<li><a href="../459628/index.html">La Red de Invenci√≥n Abierta tiene m√°s de tres mil licenciatarios, ¬øqu√© significa para el software de c√≥digo abierto?</a></li>
<li><a href="../459630/index.html">Tic Tac Toe Parte 2: Deshacer / Rehacer sin estado</a></li>
<li><a href="../459638/index.html">Crear una base de conocimiento global sobre bater√≠as</a></li>
<li><a href="../459640/index.html">Documentos como c√≥digo. Parte 1: automatizar la actualizaci√≥n</a></li>
<li><a href="../459642/index.html">Acceso seguro para registrar campos en C ++ sin sacrificar la eficiencia (utilizando CortexM como ejemplo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>