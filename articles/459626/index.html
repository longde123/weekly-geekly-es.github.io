<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛄️ 📍 ♿️ Windows Notification Facility: la superficie de ataque más indocumentada 👩🏽 🍻 💇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Debajo del corte hay una traducción de la presentación "La instalación de notificaciones de Windows: la superficie de ataque de kernel más indocumenta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: la superficie de ataque más indocumentada</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Debajo del corte hay una traducción de la <strong>presentación</strong> "La instalación de notificaciones de Windows: la superficie de ataque de kernel más indocumentada hasta ahora" presentada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alex Ionescu</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gabrielle Viala</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la conferencia BlackHat 2018</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Lo que se discutirá en la publicación.</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué es Windows Notification Facility (WNF)?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Por qué apareció WNF?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nombres de estado WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistema de llamadas para trabajar con WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de modo de usuario de alto nivel (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de nivel de kernel de alto nivel (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WNF Analysis Utilities</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Superficie de ataque WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nombres de estado WNF interesantes y sensibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proceso de inyección usando WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones para futuras investigaciones</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  ¿Qué es Windows Notification Facility (WNF)? </h3><br><p>  Windows Notification Facility es un mecanismo de notificación (disponible tanto en el núcleo como en el modo de usuario), que se basa en un modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editor-suscriptor</a> ( <em>pubsub</em> , Publisher / Subscriber).  El mecanismo se agregó en Windows 8: en parte para resolver algunas limitaciones de diseño de larga data en el sistema operativo, pero también sirvió como base para la implementación de notificaciones push similares a iOS / Android. </p><br><p>  Su característica clave es que es un modelo <em>ciego</em> (en su mayoría sin registro) que permite la suscripción y publicación sin orden.  Esto implica que un consumidor puede suscribirse a una notificación incluso antes de que la fuente haya publicado la notificación.  Y que el que genera los eventos no está obligado a "registrar" el aviso por adelantado. </p><br><p>  Además, el mecanismo admite: </p><br><ul><li>  notificaciones permanentes y temporales </li><li>  identificadores únicos que aumentan monótonamente </li><li>  búfer de carga útil (hasta 4 kilobytes) para cada evento </li><li>  modelo de notificación de grupo de subprocesos con serialización basada en grupos </li><li>  Un modelo de seguridad basado en el alcance que implementa descriptores de seguridad a través del mecanismo estándar <abbr title="Lista de control de acceso discrecional">DACL</abbr> / <abbr title="Lista de control de acceso al sistema">SACL</abbr> </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  ¿Por qué apareció WNF? </h3><br><p>  Considere un ejemplo canónico: hay un controlador que quiere saber que se ha conectado un volumen con acceso de lectura y escritura.  Para notificarle esto, Autochk (un análogo de <abbr title="verificación de consistencia del sistema de archivos">fsck</abbr> en Windows) informa un evento llamado VolumesSafeForWriteAccess.  Pero para informar un evento, primero debe crear el objeto del evento en sí. </p><br><p>  También necesitamos saber que Autochk ya está trabajando en el volumen, pero aún no ha señalado el evento que estamos esperando.  Mala solución: sentarse en un bucle con sleep (), verificar la presencia de un evento y, cuando se crea el evento, espere. </p><br><p>  Pero después de salir de la aplicación de Windows, todos sus descriptores están cerrados.  Y cuando el objeto no tiene descriptores, se destruye.  Entonces, ¿quién llevará a cabo este evento? </p><br><p>  Sin WNF, la solución es que el núcleo del sistema operativo genere un evento antes de que se cargue cualquier controlador, y que Autochk lo abra como lo haría un consumidor, pero en lugar de esperar, debería señalar este evento. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Nombres de estado WNF </h3><br><p>  En el mundo WNF, un nombre de estado es un número de 64 bits.  Pero hay un truco: de hecho, es una estructura codificada.  El nombre del estado tiene una <em>versión</em> , <em>una vida útil</em> , un <em>alcance</em> , un <em>indicador de persistencia de datos</em> y un <em>número de serie único</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Pero estos datos estarán disponibles solo si pro-XOR es un número de 64 bits con una constante mágica: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Vida del nombre del estado </h4><br><p>  El nombre del estado de WNF puede ser (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bien conocido </li><li>  permanente </li><li>  persistente </li><li>  temporal </li></ul><br><p>  Los primeros tres están asociados con las claves correspondientes en el registro, donde se almacenará la información de estado: </p><br><ul><li>  los nombres conocidos viven en HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notificaciones </li><li>  los nombres persistentes viven en HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notificaciones </li><li>  los nombres persistentes viven en HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Los nombres conocidos tienen su propia peculiaridad: no se pueden registrar.  Dicho nombre ya debería presentarse en el registro en el momento del inicio del sistema.  Los nombres persistentes y persistentes requieren el privilegio SeCreatePermanentPrivilege incluido (como otros objetos globales) para crearlos.  Los nombres persistentes viven fuera del proceso de registro, mientras que los nombres persistentes sobreviven al reinicio del sistema. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Alcance de los datos </h4><br><p>  El ámbito de datos define el primer límite de seguridad alrededor del nombre de estado WNF; determina quién lo ve y tiene acceso a él.  El alcance del nombre del estado puede ser: </p><br><ul><li>  el sistema </li><li>  el carro </li><li>  sesión de usuario </li><li>  el usuario </li><li>  el proceso </li></ul><br><p>  Además de proporcionar límites de seguridad, los ámbitos WNF se pueden usar para proporcionar diferentes instancias de datos para el mismo nombre.  El núcleo (como con otros mecanismos de seguridad) omite las comprobaciones de acceso de estado.  El privilegio TCB permite el acceso de alcance cruzado a los nombres de estado WNF. </p><br><p>  El "sistema" de alcance y la "máquina" de alcance son ámbitos globales.  No tienen sus propios identificadores (usan contenedores globales diferentes).  El alcance de la sesión del usuario utiliza el identificador de sesión (ID de sesión) como ID.  El alcance de un usuario específico utiliza el SID de este usuario como identificador.  La dirección del objeto EPROCESS es el identificador del alcance del proceso. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  Números de secuencia </h4><br><p>  Para garantizar la unicidad, cada nombre de estado tiene un número de secuencia único de 51 bits.  Los nombres conocidos incluyen una etiqueta de familia de 4 caracteres en su número de serie, y los 21 bits restantes se utilizan como un identificador único.  Los nombres permanentes almacenan su número incremental con el valor de registro "SequenceNumber".  Los nombres persistentes y temporales usan un contador de incremento común, que se encuentra en una variable global.  Estos datos se almacenan y procesan por separado para cada contenedor (por silo) y están disponibles en PspHostSiloGlobals-&gt; WnfSiloState. </p><br><p>  Dentro de Microsoft, cada nombre WNF tiene un identificador "amigable" que se usa en el código, a veces se almacena en el espacio de nombres global con el mismo nombre.  Por ejemplo, el símbolo nt! WNF_BOOT_DIRTY_SHUTDOWN, que tiene el valor 0x1589012fa3bc0875.  Después de XOR con la constante mágica <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY</abbr> obtenemos el valor 0x544f4f4200000801, que puede interpretarse a nivel de bits como: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Sistema de llamadas para trabajar con WNF </h3><br><p>  Las llamadas al sistema Kernel le permiten registrar y eliminar nombres de estado de WNF, publicar y recibir datos de nombres de estado de WNF y también recibir varias notificaciones de WNF. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Registrar nombre de estado WNF </h4><br><p>  Con la excepción de nombres conocidos (como se mencionó anteriormente), el nombre de estado WNF se puede registrar mientras se ejecuta el sistema operativo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Hay un sistema simétrico llamado ZwDeleteWnfStateName con el que puede eliminar el nombre del estado registrado (de nuevo, excepto los conocidos). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Publicar datos de estado de WNF </h4><br><p>  Para establecer o cambiar los datos del nombre de estado WNF, puede usar la llamada al sistema ZwUpdateWnfStateData: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Hay un sistema simétrico que llama a ZwDeleteWnfStateData para eliminar (limpiar) los datos del nombre de estado WNF. </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Obtener datos de estado de WNF </h4><br><p>  Para solicitar los datos del nombre de estado WNF, se puede utilizar la siguiente llamada al sistema (la mayoría de los parámetros son similares a la función Actualizar): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  La verdadera fortaleza radica en el hecho de que las funciones API Actualizar y Consultar no requieren de hecho un nombre de estado WNF <u>registrado</u> .  Y si el nombre no es temporal (y el código de llamada tiene suficientes privilegios), ¡se puede registrar una instancia del nombre en tiempo real! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  Notificaciones de WNF </h4><br><p>  Hasta ahora, hemos asumido que el consumidor sabe cuándo llamar a la función de adquisición de datos.  Pero también está <em>bloqueando la lectura</em> , que funciona utilizando un sistema de notificación (que está más cerca del verdadero modelo de editor-suscriptor). </p><br><p>  Primero, el proceso debe registrar el evento llamando a la función ZwSetWnfProcessNotificationEvent.  Luego debe llamar a la función ZwSubscribeWnfStateChange, especificando una máscara de evento para obtener el identificador de suscripción en la salida.  Los eventos pueden ser de dos tipos: </p><br><ul><li>  Notificaciones de datos: <br><ul><li>  0x01 - apariencia de datos </li><li>  0x10 - destrucción de nombre </li></ul></li><li>  Meta Metanotificaciones <br><ul><li>  0x02: aparición de un suscriptor que recibe notificaciones de datos (suscriptor de datos) </li><li>  0x04: aparición de un suscriptor que recibe meta notificaciones (Meta suscriptor) </li><li>  0x08: aparición de un suscriptor que recibe notificaciones de datos y metanotificaciones (suscriptor genérico) </li></ul></li></ul><br><p>  Entonces debe esperar el evento que se grabó.  Y cada vez que el evento se convierte en una señal, debe llamar a la función ZwGetCompleteWnfStateSubscription, que devuelve WNF_DELIVERY_DESCRIPTOR. </p><br><p>  Pero estas funciones API de bajo nivel tienen un problema (gracias a Gabi por investigarlo): cada proceso solo puede tener un evento registrado. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  API de modo de usuario de alto nivel (ntdll) </h3><br><p>  Cuando se trata de notificaciones, las cosas se complican, por lo que la capa rtl de ntdll.dll proporciona una interfaz más simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  De hecho, no es necesario llamar directamente a los servicios del sistema: solo use una única cola de eventos controlada por ntdll.dll. </p><br><p>  Detrás de escena, el contenido de WNF_DELIVERY_DESCRIPTOR se convierte en parámetros de devolución de llamada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Para cada nueva suscripción, se realiza una entrada, que se coloca en la lista a la que apunta la variable global RtlpWnfProcessSubscriptions.  La lista se basa en uno de los campos WNF_NAME_SUBSCRIPTION, que es de tipo LIST_ENTRY.  Cada WNF_NAME_SUBSCRIPTION, a su vez, tiene otro campo LIST_ENTRY para organizar una lista de WNF_USER_SUBSCRIPTION con una devolución de llamada y contexto. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  API de nivel de kernel de alto nivel (Ex) </h3><br><p>  WNF también proporciona funciones casi idénticas para el código del modo kernel (que se puede usar desde el controlador): tanto a través de llamadas al sistema exportadas como a través de funciones API de alto nivel en el tiempo de ejecución (capa Ex). </p><br><p>  La función ExSubscribeWnfStateChange acepta el nombre de estado, las máscaras de tipo y la dirección de la función de devolución de llamada + contexto como entrada, y devuelve un descriptor de suscripción.  Las funciones de devolución de llamada reciben el nombre de destino, la máscara de eventos, la etiqueta de cambio, pero no el búfer o su tamaño. </p><br><p>  La función ExQueryWnfStateData, basada en el descriptor de suscripción pasado, lee los datos del estado actual.  De hecho, cada devolución de llamada termina llamando a la función ExQueryWnfStateData para obtener los datos asociados con la notificación. </p><br><p>  Tanto para las suscripciones en modo kernel como para las suscripciones en modo usuario, WNF (para rastrear suscripciones) crea una instancia de la estructura WNF_SUBSCRIPTION.  Pero para el modo de usuario, algunos campos no se completarán, por ejemplo, Devolución de llamada y Contexto, porque para el modo de usuario, ntdll.dll almacena y procesa las direcciones de los controladores. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  Estructuras de datos WNF </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>De un traductor</em></u> : vea la siguiente sección. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  WNF Analysis Utilities </h3><br><p>  <u><em>De un traductor</em></u> : aquí vale la pena recordar nuevamente que la presentación fue realizada no solo por Alex, sino también por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gabrielle Viala</a> .  En particular, su autoría pertenece al módulo WnfCom que se describe a continuación.  Además, Gabrielle describió las estructuras internas de WNF con suficiente detalle (vea la ilustración en la sección anterior).  Desafortunadamente, la mayoría de sus diapositivas están ausentes en el pdf de la presentación (indicado como el original) o se indican exclusivamente por títulos.  Pero: </p><br><ul><li>  Esta es una excelente ocasión para ver una grabación de su actuación conjunta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Windows Notification Facility: Pelando la cebolla de la superficie de ataque de kernel más indocumentada hasta</a> el momento (el comienzo de Gabrielle ~ 19: 27).  ¡Allí (además de las estructuras de datos) habrá una historia sobre cómo arreglaron la extensión del depurador! Wnf (spoiler - usando el método descrito en The NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reparando extensiones de depurador rotas</a> ) </li><li>  Gabrielle tiene un buen artículo por separado (detallado, no como una presentación): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jugar con Windows Notification Facility (WNF)</a> , que también es muy recomendable para leer a todos los interesados. </li></ul><br><p>  <u><em>Y del traductor</em></u> : si alguien quiere complementar la traducción actual con el contenido de las diapositivas de Gabrielle o ampliar la traducción de la taquigrafía de cualquier parte del video del discurso, bienvenido.  Para la conveniencia de agregar / cambiar fragmentos grandes, puedo publicar la fuente de traducción en github (u otro servidor de control de versiones). </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom es un módulo de Python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código fuente de github</a> ) que muestra la interoperabilidad a través de WNF.  Características clave: </p><br><ul><li>  le permite leer / escribir datos de instancias de instancias existentes </li><li>  le permite crear nombres de estado temporales (como <em>servidor</em> ) </li><li>  le permite obtener una instancia de un objeto del lado del <em>cliente</em> que procesará notificaciones sobre el cambio de una instancia específica de un nombre </li></ul><br><p>  Ejemplo de uso: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump es una utilidad de línea de comandos escrita en C. El archivo ejecutable se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ionescu007/wnfun</a> seleccionando el subdirectorio de la profundidad de bits requerida.  La utilidad se puede utilizar para buscar información sobre nombres de estado WNF: </p><br><ul><li>  -d ( <u>D</u> ump) Volcar todos los nombres de estado WNF utilizando una enumeración basada en el registro.  Se puede complementar con opciones: <br><ul><li>  -v ( <u>V</u> erbose) Una salida detallada que incluye un volcado hexadecimal de datos de estado WNF; </li><li>  -s (Seguridad) Descriptores de seguridad: cadenas de permisos SDDL para el nombre de estado WNF. </li></ul></li><li>  -b ( <u>B</u> rute-force) Enumeración directa de nombres de estado WNF temporales (más sobre esto a continuación) </li><li>  -i (Información) Muestra información sobre un solo nombre de estado WNF especificado </li><li>  -r ( <u>R</u> ead) Lee datos del nombre de estado WNF especificado </li><li>  -w ( <u>W</u> rite) Escribe datos en el nombre de estado WNF especificado </li><li>  -n ( <u>N</u> otificación) Registre un suscriptor de notificaciones para el nombre de estado WNF especificado (en adelante será un caso de uso más específico con Edge) </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  Superficie de ataque WNF </h3><br><p>  Esta sección (más precisamente, sus subsecciones) discutirá posibles ataques y datos WNF sensibles e interesantes. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Divulgación de datos privilegiados </h4><br><p>  Al leer los miles de nombres de estado WNF que existen en el sistema, se pueden observar varios, cuyos datos parecen muy interesantes.  Entre ellos, algunos cuyos datos son sospechosamente similares a los punteros u otros datos privilegiados. </p><br><p>  Después de jugar en varias máquinas, en algunos casos fue posible encontrar un montón, una pila y otra información privilegiada que se divulgó a través de los límites de privilegios.  Los informes de errores / vulnerabilidades se enviaron a MSRC en julio, pero se corrigieron en noviembre (después de la presentación).  Por ejemplo: ¡4 kilobytes de pila se filtraron a través del evento WNF_AUDC *! </p><br><p>  Los principales problemas son los mismos que vimos en estudios anteriores de j00ro, taviso y otros.  Ciertos nombres de estado WNF contienen estructuras de datos codificados con varios problemas de relleno y / o alineación.  En algunos casos, las pérdidas de memoria no inicializadas. <br>  <u><em>Del traductor</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducción de la parte introductoria del documento Detección de la divulgación de la memoria del núcleo con emulación x86 y seguimiento de manchas de Mateusz Jurczyk, también conocido como j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Descubrimiento de nombres de estado y permisos </h4><br><p>  El primer enfoque fue descubrir todos los posibles nombres de estado que podrían manipularse maliciosamente.  Para nombres conocidos, permanentes y persistentes, la enumeración es factible enumerando las claves de registro.  Luego, los valores encontrados se pueden comparar con identificadores amigables (hay varios lugares donde puede encontrarlos :)) </p><br><p>  Luego, también podemos ver el descriptor de seguridad en el registro (esto es lo primero en el búfer de datos).  El descriptor de seguridad no es canónico: no tiene un propietario y un grupo, por lo que técnicamente no es válido.  Pero no hay problema en sustituir un propietario y un grupo falsos para <em>corregir</em> el descriptor de seguridad. </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Detección de nombres de estado temporales y sus permisos. </h4><br><p>  Pero con nombres temporales, los trucos descritos anteriormente no funcionarán: no están en el registro.  Y solo el núcleo almacena estructuras de datos para ellos (! Wnf) en la memoria.  Pero los nombres temporales en realidad no son tan difíciles de forzar: </p><br><ul><li>  La versión siempre importa 1 </li><li>  La vida siempre importa WnfTemporaryStateName </li><li>  La marca permanente siempre se borra (el nombre de estado temporal no puede tener datos permanentes) </li><li>  El alcance (alcance) puede tomar uno de los 4 valores </li></ul><br><p>  Sí, ¡pero el número de secuencia restante es de 51 bits!  De hecho ... pero no olvides que los números de serie están creciendo de forma monótona.  Y para los nombres temporales, la secuencia se restablece a 0 en cada arranque.  Convencionalmente, puede tomar una ventana de un millón de números de serie: en un bucle, verifique la existencia de cada nombre (comenzando desde 0) llamando a ZwQueryWnfStateNameInformation con la clase de información solicitada WnfInfoStateNameExist (dado que el error de acceso también indica la existencia de un nombre).  Si no existen otros millones de nombres, puede detener la búsqueda. </p><br><p>  Los descriptores de seguridad de nombres temporales (como otros datos de nombres temporales) se almacenan en el núcleo.  Por lo tanto, la única forma de solicitarlos es la extensión! Wnf al depurar el modo kernel.  Pero podemos: </p><br><ul><li>  Haga una conclusión sobre los permisos de lectura cuando intente leer datos. </li><li>  Para concluir que se permite la grabación al intentar escribir datos.  Pero vale la pena considerar que una escritura exitosa de incluso 0 bytes destruye los datos que el consumidor real aún no ha logrado obtener.  Y nuevamente, hay un truco: podemos aplicar el sello de cambio apropiado.  Estamos tratando de escribir con la etiqueta 0xFFFFFFFF: la etiqueta se verifica después de la verificación de acceso, por lo tanto, el valor del error produce una pérdida de permiso de escritura. </li></ul><br><p>  Esto no nos da un descriptor de seguridad completo, pero al ejecutar el código con diferentes privilegios podemos tener una idea de las restricciones para diferentes cuentas del sistema (IL / Usuario / Administrador / SISTEMA bajo). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Listado de suscriptores </h4><br><p>  En la estructura WNF_PROCESS_CONTEXT, uno de los campos es el encabezado de la lista (LIST_ENTRY) de todas las suscripciones de este proceso.  Cada suscripción es una instancia separada de WNF_SUBSCRIPTION. </p><br><p>  Los suscriptores en modo kernel son principalmente propiedad del proceso del Sistema.  Podemos usar el comando! List debugger para volcar controladores y sus parámetros registrados en el proceso del sistema WNF_SUBSCRIPTION.  Vale la pena señalar que, en algunos casos, se utiliza un agregador de eventos (CEA.SYS), que oculta las direcciones de devolución de llamada reales en su estructura de contexto. </p><br><p>  Podemos repetir este enfoque para los procesos en modo de usuario, pero la dirección de devolución de llamada será NULL, ya que estos son suscriptores en modo de usuario.  Por lo tanto, debemos unirnos al espacio de usuario del proceso, obtener la tabla RtlpWnfProcessSubscriptions y luego volcar la lista de instancias WNF_USER_SUBSCRIPTION, cada una de las cuales ya contiene la dirección de devolución de llamada.  Desafortunadamente, este personaje es estático, lo que significa que no está en caracteres abiertos, pero se puede encontrar al desarmarlo.  Y nuevamente vale la pena prestar atención (por analogía con el modo de núcleo CEA.SYS) que muchos de los controladores de modo de usuario usan el agregador de eventos (EventAggregation.dll), que almacena la devolución de llamada en su contexto. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Nombres de estado WNF interesantes y sensibles </h3><br><p>  Esta sección proporcionará algunos ejemplos interesantes de cómo algunos nombres de estado WNF revelan información del sistema. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Determinar el estado del sistema y el comportamiento del usuario utilizando WNF </h4><br><p>  Algunos identificadores WNF se pueden usar para obtener información sobre el estado de la máquina que le interesa: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Estado inalámbrico </li><li>  WNF_BLTH_BLUETOOTH_STATUS - de manera similar, pero para Bluetooth (también WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE: muestra la fuente de alimentación (batería o adaptador de corriente) </li><li>  WNF_SEB_BATTERY_LEVEL: contiene el nivel de batería </li><li>  WNF_CELL_ *: en Windows Phone contiene información sobre: ​​red, número, intensidad de la señal, EDGE o 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER —   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT —    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED —    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      —       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE —     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST —   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK — ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND –   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory —    </li><li>   ( ) —               </li><li>   (Atom) —            </li><li>    —  ,   WM_COPYDATA  DDE,       </li><li> GUI  —    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Llamada a procedimiento asincrónico">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " —  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Control de protección de flujo">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> github</a> )   explorer (  —  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restaurar el controlador original a WNF_USER_SUBSCRIPTION y recursos asignados gratis </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459626/">https://habr.com/ru/post/459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459616/index.html">MIPT abre el primer programa de maestría avanzada de Rusia en Informática e Ingeniería de Software</a></li>
<li><a href="../459618/index.html">Algunas características poco conocidas de docker-compose</a></li>
<li><a href="../459620/index.html">TDDx2, BDD, DDD, FDD, MDD y PDD, o lo que quieras saber sobre el desarrollo impulsado</a></li>
<li><a href="../459622/index.html">Como los juegos para Sega Saturn fueron escritos en 1995</a></li>
<li><a href="../459624/index.html">Drones militares</a></li>
<li><a href="../459628/index.html">La Red de Invención Abierta tiene más de tres mil licenciatarios, ¿qué significa para el software de código abierto?</a></li>
<li><a href="../459630/index.html">Tic Tac Toe Parte 2: Deshacer / Rehacer sin estado</a></li>
<li><a href="../459638/index.html">Crear una base de conocimiento global sobre baterías</a></li>
<li><a href="../459640/index.html">Documentos como código. Parte 1: automatizar la actualización</a></li>
<li><a href="../459642/index.html">Acceso seguro para registrar campos en C ++ sin sacrificar la eficiencia (utilizando CortexM como ejemplo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>