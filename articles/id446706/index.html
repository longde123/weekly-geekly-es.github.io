<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐿️ 👩🏻‍🤝‍👨🏿 👩🏽‍🏫 Kueri Paralel di PostgreSQL 😴 🔚 👃🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak core dalam CPU modern. Selama bertahun-tahun, aplikasi telah mengirim permintaan ke basis data secara paralel. Jika ini adalah permintaan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kueri Paralel di PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/446706/"><p><img src="https://habrastorage.org/webt/kx/ht/dl/kxhtdlsry_f8p1jv2ve_1ziks7e.jpeg"></p><br><p>  Ada banyak core dalam CPU modern.  Selama bertahun-tahun, aplikasi telah mengirim permintaan ke basis data secara paralel.  Jika ini adalah permintaan pelaporan untuk banyak baris dalam sebuah tabel, ini akan berjalan lebih cepat ketika menggunakan banyak CPU, dan dalam PostgreSQL dimungkinkan mulai dari versi 9.6. </p><br><p>  Butuh 3 tahun untuk menerapkan fungsi kueri paralel - saya harus menulis ulang kode pada berbagai tahapan pelaksanaan kueri.  PostgreSQL 9.6 memperkenalkan infrastruktur untuk lebih meningkatkan kode.  Dalam versi berikutnya, tipe kueri lain dieksekusi secara paralel. </p><a name="habracut"></a><br><h3 id="ogranicheniya">  Keterbatasan </h3><br><ul><li>  Jangan aktifkan eksekusi paralel jika semua core sudah diambil, jika tidak, permintaan lain akan melambat. </li><li>  Yang paling penting, pemrosesan paralel dengan nilai WORK_MEM tinggi menghabiskan banyak memori - setiap hash bergabung atau mengurutkan mengambil memori dalam jumlah work_mem. </li><li>  Permintaan OLTP latensi rendah tidak dapat dipercepat dengan eksekusi paralel.  Dan jika kueri mengembalikan satu baris, pemrosesan paralel hanya akan memperlambatnya. </li><li>  Pengembang senang menggunakan tolok ukur TPC-H.  Mungkin Anda memiliki pertanyaan serupa untuk eksekusi paralel yang sempurna. </li><li>  Hanya kueri SELECT tanpa kunci predikat yang dieksekusi secara paralel. </li><li>  Terkadang pengindeksan yang benar lebih baik daripada pemindaian tabel berurutan secara paralel. </li><li>  Menunda permintaan dan kursor tidak didukung. </li><li>  Fungsi jendela dan fungsi agregat set yang dipesan tidak paralel. </li><li>  Anda tidak mendapatkan apa-apa dalam beban kerja I / O. </li><li>  Tidak ada algoritma pengurutan paralel.  Tetapi kueri yang diurutkan dapat dieksekusi secara paralel dalam beberapa aspek. </li><li> Ganti CTE (DENGAN ...) dengan SELECT bersarang untuk mengaktifkan pemrosesan paralel. </li><li>  Pembungkus data pihak ketiga belum mendukung pemrosesan paralel (tetapi mereka bisa!) </li><li>  FULL OUTER JOIN tidak didukung. </li><li>  max_rows menonaktifkan pemrosesan paralel. </li><li>  Jika permintaan memiliki fungsi yang tidak ditandai sebagai PARALLEL SAFE, itu akan menjadi utas tunggal. </li><li>  Level isolasi transaksi SERIALIZABLE menonaktifkan pemrosesan paralel. </li></ul><br><h3 id="testovaya-sreda">  Lingkungan uji </h3><br><p>  Pengembang PostgreSQL telah mencoba mengurangi waktu respons dari permintaan benchmark TPC-H.  Unduh patokan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesuaikan ke PostgreSQL</a> .  Ini adalah penggunaan tidak resmi dari patok TPC-H - bukan untuk membandingkan basis data atau perangkat keras. </p><br><ol><li>  Unduh TPC-H_Tools_v2.17.3.zip (atau versi yang lebih baru) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari TPC di luar situs</a> . </li><li>  Ganti nama makefile.suite menjadi Makefile dan ubah seperti dijelaskan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/tvondra/pg_tpch</a> .  Kompilasi kode dengan perintah make. </li><li> Hasilkan data: <code>./dbgen -s 10</code> membuat database 23 GB.  Ini cukup untuk melihat perbedaan dalam kinerja permintaan paralel dan non-paralel. </li><li>  Konversi file <code>tbl</code> ke <code>csv  for</code> dan <code>sed</code> . </li><li>  Klon repositori pg_tpch dan salin <code>csv</code> ke <code>pg_tpch/dss/data</code> . </li><li>  Buat kueri dengan perintah <code>qgen</code> . </li><li>  Unggah data ke database dengan perintah <code>./tpch.sh</code> . </li></ol><br><h3 id="parallelnoe-posledovatelnoe-skanirovanie">  Pemindaian sekuensial paralel </h3><br><p>  Mungkin lebih cepat bukan karena pembacaan paralel, tetapi karena data tersebar di banyak core CPU.  Pada sistem operasi modern, file data PostgreSQL di-cache dengan baik.  Dengan baca-depan, Anda bisa mendapatkan lebih banyak dari penyimpanan daripada permintaan daemon PG.  Oleh karena itu, kinerja kueri tidak dibatasi oleh disk I / O.  Mengkonsumsi siklus CPU untuk: </p><br><ul><li>  baca baris satu per satu dari halaman tabel; </li><li>  Bandingkan nilai string dan klausa <code>WHERE</code> . </li></ul><br><p>  Mari kita jalankan kueri <code>select</code> sederhana: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select l_quantity as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN -------------------------------------------------------------------------------------------------------------------------- Seq Scan on lineitem (cost=0.00..1964772.00 rows=58856235 width=5) (actual time=0.014..16951.669 rows=58839715 loops=1) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 1146337 Planning Time: 0.203 ms Execution Time: 19035.100 ms</code> </pre> <br><p>  Pemindaian berurutan menghasilkan terlalu banyak baris tanpa agregasi, sehingga permintaan dijalankan oleh satu inti CPU. </p><br><p>  Jika Anda menambahkan <code>SUM()</code> , Anda melihat bahwa dua alur kerja akan membantu mempercepat permintaan: </p><br><pre> <code class="plaintext hljs">explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1589702.14..1589702.15 rows=1 width=32) (actual time=8553.365..8553.365 rows=1 loops=1) -&gt; Gather (cost=1589701.91..1589702.12 rows=2 width=32) (actual time=8553.241..8555.067 rows=3 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Partial Aggregate (cost=1588701.91..1588701.92 rows=1 width=32) (actual time=8547.546..8547.546 rows=1 loops=3) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1527393.33 rows=24523431 width=5) (actual time=0.038..5998.417 rows=19613238 loops=3) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 382112 Planning Time: 0.241 ms Execution Time: 8555.131 ms</code> </pre> <br><h3 id="parallelnaya-agregaciya">  Agregasi paralel </h3><br><p>  Node Pemindaian Seq Paralel menghasilkan string untuk agregasi parsial.  Node Agregat Parsial memotong garis-garis ini menggunakan <code>SUM()</code> .  Pada akhirnya, penghitung SUM dari setiap alur kerja dikumpulkan oleh simpul Kumpulkan. </p><br><p>  Hasil akhir dihitung oleh simpul "Finalisasi Agregat".  Jika Anda memiliki fungsi agregasi Anda sendiri, pastikan untuk menandainya sebagai "parallel parallel". </p><br><h3 id="kolichestvo-rabochih-processov">  Jumlah Alur Kerja </h3><br><p>  Jumlah alur kerja dapat ditingkatkan tanpa memulai ulang server: </p><br><pre> <code class="plaintext hljs">alter system set max_parallel_workers_per_gather=4; select * from pg_reload_conf();</code> </pre> <br><p>  Sekarang kita melihat 4 pekerja menjelaskan output: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1440213.58..1440213.59 rows=1 width=32) (actual time=5152.072..5152.072 rows=1 loops=1) -&gt; Gather (cost=1440213.15..1440213.56 rows=4 width=32) (actual time=5151.807..5153.900 rows=5 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial Aggregate (cost=1439213.15..1439213.16 rows=1 width=32) (actual time=5147.238..5147.239 rows=1 loops=5) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1402428.00 rows=14714059 width=5) (actual time=0.037..3601.882 rows=11767943 loops=5) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 229267 Planning Time: 0.218 ms Execution Time: 5153.967 ms</code> </pre> <br><p>  Apa yang sedang terjadi di sini?  Ada alur kerja 2 kali lebih banyak, dan permintaan itu hanya 1,6599 kali lebih cepat.  Perhitungannya menarik.  Kami memiliki 2 proses kerja dan 1 pemimpin.  Setelah perubahan, itu menjadi 4 +1. </p><br><p>  Akselerasi maksimum kami dari pemrosesan paralel: 5/3 = 1.66 (6) kali. </p><br><h2 id="kak-eto-rabotaet">  Bagaimana cara kerjanya? </h2><br><h3 id="processy">  Prosesnya </h3><br><p>  Eksekusi permintaan selalu dimulai dengan proses utama.  Pemimpin melakukan segala sesuatu yang non-paralel dan bagian dari pemrosesan paralel.  Proses lain yang melakukan permintaan yang sama disebut alur kerja.  Pemrosesan paralel menggunakan infrastruktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alur kerja latar belakang yang dinamis</a> (sejak versi 9.4).  Karena bagian lain dari PostgreSQL menggunakan proses daripada utas, kueri dengan 3 alur kerja bisa 4 kali lebih cepat daripada pemrosesan tradisional. </p><br><h3 id="vzaimodeystvie">  Interaksi </h3><br><p>  Alur kerja berkomunikasi dengan pemimpin melalui antrian pesan (berdasarkan memori bersama).  Setiap proses memiliki 2 antrian: untuk kesalahan dan untuk tupel. </p><br><h3 id="skolko-nuzhno-rabochih-processov">  Berapa banyak proses kerja yang Anda butuhkan? </h3><br><p>  Batas minimum ditentukan oleh parameter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_parallel_workers_per_gather</code></a> .  Kemudian, pelaksana kueri mengambil alur kerja dari kumpulan yang dibatasi oleh parameter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_parallel_workers size</code></a> .  Batasan terakhir adalah proses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_worker_processes</code></a> , yaitu jumlah total proses latar belakang. </p><br><p>  Jika tidak mungkin mengalokasikan alur kerja, pemrosesan akan menjadi proses tunggal. </p><br><p>  Perencana kueri dapat mempersingkat alur kerja tergantung pada ukuran tabel atau indeks.  Ada parameter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>min_parallel_index_scan_size</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>min_parallel_index_scan_size</code></a> untuk ini. </p><br><pre> <code class="plaintext hljs">set min_parallel_table_scan_size='8MB' 8MB table =&gt; 1 worker 24MB table =&gt; 2 workers 72MB table =&gt; 3 workers x =&gt; log(x / min_parallel_table_scan_size) / log(3) + 1 worker</code> </pre> <br><p>  Setiap kali sebuah tabel 3 kali lebih besar dari <code>min_parallel_(index|table)_scan_size</code> , Postgres menambahkan alur kerja.  Jumlah proses kerja tidak berdasarkan biaya.  Ketergantungan sirkuler mempersulit implementasi yang kompleks.  Sebagai gantinya, penjadwal menggunakan aturan sederhana. </p><br><p>  Dalam praktiknya, aturan ini tidak selalu cocok untuk produksi, sehingga Anda dapat mengubah jumlah alur kerja untuk tabel tertentu: ALTER TABEL ... SET ( <code>parallel_workers = N</code> ). </p><br><h3 id="pochemu-parallelnaya-obrabotka-ne-ispolzuetsya">  Mengapa pemrosesan paralel tidak digunakan? </h3><br><p>  Selain daftar panjang pembatasan, ada juga pemeriksaan biaya: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>parallel_setup_cost</code></a> - untuk melakukannya tanpa pemrosesan paralel permintaan pendek.  Parameter ini memperkirakan waktu untuk menyiapkan memori, memulai proses, dan pertukaran data awal. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>parallel_tuple_cost</code></a> : komunikasi antara pemimpin dan pekerja dapat ditunda secara proporsional dengan jumlah tupel dari proses kerja.  Parameter ini menghitung biaya pertukaran data. </p><br><h3 id="soedineniya-vlozhennyh-ciklov--nested-loop-join">  Nested Loop Bergabung </h3><br><pre> <code class="plaintext hljs">PostgreSQL 9.6+      —   . explain (costs off) select c_custkey, count(o_orderkey) from customer left outer join orders on c_custkey = o_custkey and o_comment not like '%special%deposits%' group by c_custkey; QUERY PLAN -------------------------------------------------------------------------------------- Finalize GroupAggregate Group Key: customer.c_custkey -&gt; Gather Merge Workers Planned: 4 -&gt; Partial GroupAggregate Group Key: customer.c_custkey -&gt; Nested Loop Left Join -&gt; Parallel Index Only Scan using customer_pkey on customer -&gt; Index Scan using idx_orders_custkey on orders Index Cond: (customer.c_custkey = o_custkey) Filter: ((o_comment)::text !~~ '%special%deposits%'::text)</code> </pre> <br><p>  Koleksi berlangsung pada tahap terakhir, sehingga Nested Loop Left Join adalah operasi paralel.  Pemindaian Indeks Paralel Hanya muncul hanya dalam versi 10. Ini berfungsi mirip dengan pemindaian paralel.  Kondisi <code>c_custkey = o_custkey</code> membaca satu urutan untuk setiap baris klien.  Jadi tidak paralel. </p><br><h3 id="hesh-soedinenie--hash-join">  Hash Join - Hash Join </h3><br><p>  Setiap alur kerja membuat tabel hash sendiri sebelum PostgreSQL 11. Dan jika ada lebih dari empat proses ini, kinerja tidak akan meningkat.  Di versi baru, tabel hash dibagikan.  Setiap alur kerja dapat menggunakan WORK_MEM untuk membuat tabel hash. </p><br><pre> <code class="plaintext hljs">select l_shipmode, sum(case when o_orderpriority = '1-URGENT' or o_orderpriority = '2-HIGH' then 1 else 0 end) as high_line_count, sum(case when o_orderpriority &lt;&gt; '1-URGENT' and o_orderpriority &lt;&gt; '2-HIGH' then 1 else 0 end) as low_line_count from orders, lineitem where o_orderkey = l_orderkey and l_shipmode in ('MAIL', 'AIR') and l_commitdate &lt; l_receiptdate and l_shipdate &lt; l_commitdate and l_receiptdate &gt;= date '1996-01-01' and l_receiptdate &lt; date '1996-01-01' + interval '1' year group by l_shipmode order by l_shipmode LIMIT 1; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=1964755.66..1964961.44 rows=1 width=27) (actual time=7579.592..7922.997 rows=1 loops=1) -&gt; Finalize GroupAggregate (cost=1964755.66..1966196.11 rows=7 width=27) (actual time=7579.590..7579.591 rows=1 loops=1) Group Key: lineitem.l_shipmode -&gt; Gather Merge (cost=1964755.66..1966195.83 rows=28 width=27) (actual time=7559.593..7922.319 rows=6 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial GroupAggregate (cost=1963755.61..1965192.44 rows=7 width=27) (actual time=7548.103..7564.592 rows=2 loops=5) Group Key: lineitem.l_shipmode -&gt; Sort (cost=1963755.61..1963935.20 rows=71838 width=27) (actual time=7530.280..7539.688 rows=62519 loops=5) Sort Key: lineitem.l_shipmode Sort Method: external merge Disk: 2304kB Worker 0: Sort Method: external merge Disk: 2064kB Worker 1: Sort Method: external merge Disk: 2384kB Worker 2: Sort Method: external merge Disk: 2264kB Worker 3: Sort Method: external merge Disk: 2336kB -&gt; Parallel Hash Join (cost=382571.01..1957960.99 rows=71838 width=27) (actual time=7036.917..7499.692 rows=62519 loops=5) Hash Cond: (lineitem.l_orderkey = orders.o_orderkey) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1552386.40 rows=71838 width=19) (actual time=0.583..4901.063 rows=62519 loops=5) Filter: ((l_shipmode = ANY ('{MAIL,AIR}'::bpchar[])) AND (l_commitdate &lt; l_receiptdate) AND (l_shipdate &lt; l_commitdate) AND (l_receiptdate &gt;= '1996-01-01'::date) AND (l_receiptdate &lt; '1997-01-01 00:00:00'::timestamp without time zone)) Rows Removed by Filter: 11934691 -&gt; Parallel Hash (cost=313722.45..313722.45 rows=3750045 width=20) (actual time=2011.518..2011.518 rows=3000000 loops=5) Buckets: 65536 Batches: 256 Memory Usage: 3840kB -&gt; Parallel Seq Scan on orders (cost=0.00..313722.45 rows=3750045 width=20) (actual time=0.029..995.948 rows=3000000 loops=5) Planning Time: 0.977 ms Execution Time: 7923.770 ms</code> </pre> <br><p>  Permintaan 12 dari TPC-H menggambarkan koneksi hash paralel.  Setiap alur kerja terlibat dalam membuat tabel hash bersama. </p><br><h3 id="soedinenie-sliyaniem--merge-join">  Gabung Bergabung </h3><br><p>  Gabungan gabungan tidak bersifat paralel.  Jangan khawatir jika ini adalah tahap terakhir dari permintaan - masih dapat dieksekusi secara paralel. </p><br><pre> <code class="plaintext hljs">-- Query 2 from TPC-H explain (costs off) select s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment from part, supplier, partsupp, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and p_size = 36 and p_type like '%BRASS' and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' and ps_supplycost = ( select min(ps_supplycost) from partsupp, supplier, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' ) order by s_acctbal desc, n_name, s_name, p_partkey LIMIT 100; QUERY PLAN ---------------------------------------------------------------------------------------------------------- Limit -&gt; Sort Sort Key: supplier.s_acctbal DESC, nation.n_name, supplier.s_name, part.p_partkey -&gt; Merge Join Merge Cond: (part.p_partkey = partsupp.ps_partkey) Join Filter: (partsupp.ps_supplycost = (SubPlan 1)) -&gt; Gather Merge Workers Planned: 4 -&gt; Parallel Index Scan using &lt;strong&gt;part_pkey&lt;/strong&gt; on part Filter: (((p_type)::text ~~ '%BRASS'::text) AND (p_size = 36)) -&gt; Materialize -&gt; Sort Sort Key: partsupp.ps_partkey -&gt; Nested Loop -&gt; Nested Loop Join Filter: (nation.n_regionkey = region.r_regionkey) -&gt; Seq Scan on region Filter: (r_name = 'AMERICA'::bpchar) -&gt; Hash Join Hash Cond: (supplier.s_nationkey = nation.n_nationkey) -&gt; Seq Scan on supplier -&gt; Hash -&gt; Seq Scan on nation -&gt; Index Scan using idx_partsupp_suppkey on partsupp Index Cond: (ps_suppkey = supplier.s_suppkey) SubPlan 1 -&gt; Aggregate -&gt; Nested Loop Join Filter: (nation_1.n_regionkey = region_1.r_regionkey) -&gt; Seq Scan on region region_1 Filter: (r_name = 'AMERICA'::bpchar) -&gt; Nested Loop -&gt; Nested Loop -&gt; Index Scan using idx_partsupp_partkey on partsupp partsupp_1 Index Cond: (part.p_partkey = ps_partkey) -&gt; Index Scan using supplier_pkey on supplier supplier_1 Index Cond: (s_suppkey = partsupp_1.ps_suppkey) -&gt; Index Scan using nation_pkey on nation nation_1 Index Cond: (n_nationkey = supplier_1.s_nationkey)</code> </pre> <br><p>  Node Gabung Gabung terletak di atas Gabungkan Gabung.  Jadi penggabungan tidak menggunakan pemrosesan paralel.  Tetapi simpul Indeks Pemindaian Paralel masih membantu dengan segmen <code>part_pkey</code> . </p><br><h3 id="soedinenie-po-sekciyam">  Koneksi Bagian </h3><br><p>  Di PostgreSQL 11, partisi dinonaktifkan secara default: memiliki penjadwalan yang sangat mahal.  Tabel dengan partisi yang sama dapat digabungkan bagian demi bagian.  Jadi Postgres akan menggunakan tabel hash yang lebih kecil.  Setiap koneksi bagian bisa paralel. </p><br><pre> <code class="plaintext hljs">tpch=# set enable_partitionwise_join=t; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN --------------------------------------------------- Append -&gt; Hash Join Hash Cond: (t2.b = t1.a) -&gt; Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p1 t1 Filter: (b = 0) -&gt; Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p2 t1_1 Filter: (b = 0) tpch=# set parallel_setup_cost = 1; tpch=# set parallel_tuple_cost = 0.01; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN ----------------------------------------------------------- Gather Workers Planned: 4 -&gt; Parallel Append -&gt; Parallel Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Parallel Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p2 t1_1 Filter: (b = 0) -&gt; Parallel Hash Join Hash Cond: (t2.b = t1.a) -&gt; Parallel Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p1 t1 Filter: (b = 0)</code> </pre> <br><p>  Yang utama adalah bahwa koneksi di bagian-bagian itu paralel hanya jika bagian-bagian ini cukup besar. </p><br><h3 id="parallelnoe-dopolnenie--parallel-append">  Parallel Append - Parallel Append </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paralel Tambah</a> dapat digunakan sebagai pengganti blok yang berbeda dalam alur kerja yang berbeda.  Ini biasanya terjadi dengan UNION ALL queries.  Kerugiannya adalah paralelisme yang kurang, karena setiap alur kerja hanya memproses 1 permintaan. </p><br><p>  2 alur kerja sedang berjalan di sini, meskipun 4 disertakan. </p><br><pre> <code class="plaintext hljs">tpch=# explain (costs off) select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day union all select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '2000-12-01' - interval '105' day; QUERY PLAN ------------------------------------------------------------------------------------------------ Gather Workers Planned: 2 -&gt; Parallel Append -&gt; Aggregate -&gt; Seq Scan on lineitem Filter: (l_shipdate &lt;= '2000-08-18 00:00:00'::timestamp without time zone) -&gt; Aggregate -&gt; Seq Scan on lineitem lineitem_1 Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone)</code> </pre> <br><h3 id="samye-vazhnye-peremennye">  Variabel yang paling penting </h3><br><ul><li>  WORK_MEM membatasi jumlah memori untuk setiap proses, tidak hanya untuk permintaan: <em>proses</em> koneksi work_mem = banyak memori. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_parallel_workers_per_gather</code></a> - berapa banyak proses kerja yang akan digunakan oleh program pelaksana untuk pemrosesan paralel dari paket. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_worker_processes</code></a> - menyesuaikan jumlah total proses kerja dengan jumlah core CPU di server. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max_parallel_workers</code></a> adalah sama, tetapi untuk alur kerja paralel. </li></ul><br><h3 id="itogi">  Ringkasan </h3><br><p>  Dimulai dengan versi 9.6, pemrosesan paralel dapat secara serius meningkatkan kinerja kueri kompleks yang memindai banyak baris atau indeks.  Di PostgreSQL 10, pemrosesan paralel diaktifkan secara default.  Ingatlah untuk menonaktifkannya di server dengan beban kerja OLTP yang besar.  Pemindaian sekuensial atau pemindaian indeks menghabiskan banyak sumber daya.  Jika Anda tidak melaporkan seluruh dataset, kueri dapat dibuat lebih efisien dengan hanya menambahkan indeks yang hilang atau menggunakan partisi yang benar. </p><br><h3 id="ssylki">  Referensi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.postgresql.org/docs/11/how-parallel-query-works.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.postgresql.org/docs/11/parallel-plans.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://ashutoshpg.blogspot.com/2017/12/partition-wise-joins-divide-and-conquer.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://rhaas.blogspot.com/2016/04/postgresql-96-with-parallel-query-vs.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://amitkapila16.blogspot.com/2015/11/parallel- berikutnyaential-scans-in-play.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://write-skew.blogspot.com/2018/01/parallel-hash-for-postgresql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://rhaas.blogspot.com/2017/03/parallel-query-v2.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blog.2ndquadrant.com/parallel-monster-benchmark/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blog.2ndquadrant.com/parallel-aggregate/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.depesz.com/2018/02/12/waiting-for-postgresql-11-support-parallel-btree-index-builds/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konkurensi dalam PostgreSQL 11</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446706/">https://habr.com/ru/post/id446706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446690/index.html">Electrolux meluncurkan pembersih udara pintar untuk kota-kota yang paling tercemar</a></li>
<li><a href="../id446694/index.html">Penyimpanan modular JBOD dan derajat kebebasan</a></li>
<li><a href="../id446696/index.html">Mitos tentang 152-FZ, yang bisa mahal untuk operator data pribadi</a></li>
<li><a href="../id446700/index.html">Lazydocker - GUI untuk Docker langsung di terminal</a></li>
<li><a href="../id446702/index.html">Dan headphone aneh lainnya - untuk tidur</a></li>
<li><a href="../id446708/index.html">Perbandingan sistem komunikasi luar angkasa</a></li>
<li><a href="../id446710/index.html">Empat kisah nyata bekerja dengan arsitektur layanan mikro - laporan dari mitigasi Backend United 3: Kholodets</a></li>
<li><a href="../id446712/index.html">HTTPS tidak selalu seaman kelihatannya. Kerentanan ditemukan di 5,5% dari situs HTTPS</a></li>
<li><a href="../id446714/index.html">Penasaran Penasaran dari Dunia IT - 4</a></li>
<li><a href="../id446716/index.html">Kesadaran dan Argumen Kiamat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>