<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 👩🏿‍🚀 🍱 n-皇后完成问题-线性解算法 👵🏼 📣 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="埃里格里格 



 前言 
 在开始研究之初，我想对敖德萨的两位出色程序员表示感谢，他们是Andrei Kiper（洛基卡（Lohica））和Timur Giorgadze（Luxoft），以对我的结果进行独立验证。 



1. 2020年第一天开始在（arXiv.org）上发表了文章“求解n皇...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>n-皇后完成问题-线性解算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/"> 埃里格里格 <br><p><br></p><h4> 前言 </h4><br> 在开始研究之初，我想对敖德萨的两位出色程序员表示感谢，他们是Andrei Kiper（洛基卡（Lohica））和Timur Giorgadze（Luxoft），以对我的结果进行独立验证。 <br><br><ol><li>  2020年第一天开始在<a href="https://arxiv.org/pdf/1912.05935.pdf">（arXiv.org）</a>上发表了文章“求解n皇后完成问题的线性算法”。 最初，该文章是用俄语撰写的，因此此处提供了基本介绍，并提供了翻译。 </li><li> 此任务以及其他许多NP-完全集（满足布尔公式（3-SAT）的任务，寻找最大集团或给定大小的集团...的任务）在不同的时间都在我感兴趣的领域。 我一直在寻找一种基于各种计算实验的算法解决方案，但是并没有取得具体的成功。 就像一个人试图学习如何使一只手的单杠适应。 没有结果，但是每次都有希望一切都会很快解决的希望。 我最后一次决定，我应该在n-Queens完成任务上停留更长的时间（作为家庭成员之一），并尝试做一些事情。 在这里，您应该回想一下敖德萨的一个有趣的笑话：“在傍晚颠簸的道路上返回郊区的拥挤公交车中，听到了女人的声音-男人，如果您完全躺在我身上，至少可以做点什么。” </li><li> 该研究持续了足够长的时间-将近一年半。 一方面，这是由于在研究过程中考虑了其他任务，另一方面，在此过程中存在许多难题，没有这些问题我们就无法前进。 我将列出其中一些： <br><br><ul><li> 决策矩阵中有n行，如果这种选择的可能性为n，则应按什么顺序选择行索引！ </li><li> 当制作一行时，应选择该行中剩余的空闲位置中的哪一个，因为这种选择的可能性很大，以至于可以将其视为无穷大的“近亲”（例如，为大小为100的棋盘在所有行中选择一个空闲位置的可能方式的数目x 100约为<sup>10124</sup> ） </li><li> 这两个指标一起形成一个状态空间（一个选择空间）。 似乎有很多机会，您可以选择想要的。 但是在每个步骤的每个特定选择之后，还有另一个问题-所有后续步骤中选择的局限性。 此外，这在解决问题的最后阶段特别敏感。 我们可以说决策矩阵是“报仇性的”。 您在前一阶段做出选择时所犯的所有“无意识的错误”都是“累积的”，而在决定的最后，这一事实表明，在您应该放置女王/王后的那一行中，没有空位，搜索分支陷入停顿。 。 就像兹瓦涅茨基所说的：“一个错误的举动，你就怀孕了。” </li><li> 当搜索解决方案的分支陷入停顿时，我们就有机会回到一些先前的位置（“后退跟踪”），以便从该位置开始，我们将再次开始形成搜索解决方案的分支。 这是非确定性问题的自然“属性”。 问题是应返回先前的哪个级别。 这与选择行索引或在该行中选择自由头寸的问题是相同的未解决问题。 </li><li> 最后，应注意与算法速度有关的问题。 如果没有目标来创建快速运行的算法，那将是可悲的。 在建模过程中，不可能开发出一种能够在问题解决方案的所有领域中快速有效地工作的算法。 我必须开发三种算法。 他们像指挥棒一样将结果相互传递。 其中一个工作非常迅速，但是粗鲁地工作，另一个-相反，工作缓慢但有效。 他们每个人都在“职责范围”内工作。 </li></ul></li><li> 最初，研究的目的仅仅是找到至少一些解决方案。 在开发第一个解决方案之前，我有很多事情要弄清楚。 花了四个多月的时间。 可以在那里停下来，实现了目标-好的，好的。 但是在我看来，并不是所有用算法解决此问题的可能性都被穷尽了。 自然地，需要改进开发的算法，以使算法的时间复杂度为线性-O（n）。 当找到这样的线性解决方案时，“又有一个愿望”-减少在解决方案搜索分支的形成中使用反向跟踪（BT）程序的情况。 将任务从不确定性转移到有条件确定（尽可能）是“无礼的”愿望。 它花费了很多时间，但达到了目标，例如，在棋盘大小的值的间隔n =（320，...，22500）中，从未使用过BT程序的情况数量超过了50％。 事实证明，在启动程序的50％的情况下，算法“有目的地”构成了解决方案，而从未“绊脚石”。  （回想起关于金鱼的童话故事，我停止了这两个愿望……） </li><li> 通过比较研究过程中我能结识的出版物，我得出的结论是，无法基于严格的数学方法（即仅基于定义，引理和定理证明）来解决该问题和此类问题。 文章中对此有“哲学评论”。 我相信，只有借助计算机建模，才能在算法数学的基础上解决许多NP-Complete中的许多问题。 这样的结论并不意味着限制数学，相反，它意味着通过算法数学方法的发展来扩展数学的能力。 对于每个问题系列，您都需要使用自己的适当数学方法。  （如果已知没有什么真正意义的话，为什么要指派一名研究生来解决NP-Complete家族的问题而不应用算法数学和计算机建模方法）。 </li><li> 任何算法（程序）都具有简单的属性-不管是否起作用！ 我想向我们的Habro社区的那些在无障碍区域中装有装有Matlab的计算机的成员发出呼吁。 我想请您测试考虑的算法来解决<i>n皇后完成问题</i> 。 这仅需5-10分钟。 要测试算法，您需要执行一些简单的步骤： <br><br><ul><li> 从<i>k个</i>皇后生成一个随机构图，并检查此构图的正确性。 </li><li> 基于提出的决策算法，完成此组合以得到完整的解决方案。 否则程序必须确定此组合没有解决方案。 </li><li> 检查作为配置结果获得的解决方案的正确性。 </li></ul><br><br> 您不必为此类测试编写任何代码。 除了主程序外，我还用Matlab语言编写了两个程序： <br><br>  1. <i>Generarion_k_Queens_Composition-</i>为大小为<i>nxn</i>的任意棋盘生成大小为<i>k</i>的随机组合 <br><br>  2. <i>Completion_k_Queens_Composition.m-</i>完成任意组合直到完成一个完整的决定，或者确定该组合没有解决方案（ <b>主程序</b> ）。 <br><br>  3. <i>Validation_n_Queens_Solution.m-</i>检查<i>n皇后问题</i>的解的正确性，或<i>k个</i>皇后的组成的正确性。 <br><br> 他们工作非常快。 例如，对于大小为<i>1000 x 1000</i>格的棋盘，平均生成一个任意成分的总时间（0.0015 s。），完成此成分（0.0622 s。），并验证所获得溶液的正确性（0.0003 s。）不超过0.1秒。  （不包括下载数据或保存结果所需的时间） <br><br> 给我发送电子邮件（ericgrig@gmail.com），如果您有机会帮助朋友，我会立即向您发送这三个程序。 我将感谢所有能够客观地测试算法并在讨论中表达意见的同事。 </li><li> 我准备了程序的源代码，并附有详细的注释，希望不久后可以在Habré上发布。 我认为那些对解决<i>NP-Complete</i>家庭的复杂问题感兴趣的人会为自己找到一些有趣的东西。 </li><li> 我想再次呼吁Habr社区的成员，但是出于另一个原因。 在这里，法国的马赛（France <i>Fold Group）</i>团队正在组建中，其目的是研究和开发用于预测高分子量化合物的理化性质的算法。 我认为不应该说这是一项艰巨的任务，历史悠久，而且不同国家的认真团队正在致力于解决此问题，包括<i>Deep Mind</i>的<i>Khasabis</i>团队（您可以在Habré <a href="https://habr.com/ru/post/431948/">（habr.com_Folding）</a>上看到该文章。我们的目标是创建一个不怕解决复杂问题的强大团队，以分散的形式开展联合工作，每个团队成员都居住在自己的城市并在业余时间从事项目工作，我们需要程序员和研究人员（物理学家，化学家，数学家，生物学家） ）等  osto“鲁re的”程序员-（平方）如果您觉得有趣，请写信给我，上面是我的电子邮件，我可以在回复信中详细说明。 </li></ol><br> 文章的序言与文章本身一样长。 哈布雷（Habré）上的家庭介绍形式使我可以更自由地表达自己的想法，但是从规模上来看，我相当自由地利用了它。 我想简短地写，但“结果还是一如既往”。 <br><br>  PS：我认为Habr社区的成员很想知道我在尝试发布研究结果时遇到的困难。 在准备本文时，我根据《人工智能研究杂志》（JAIR）的要求将其重新格式化为.tex格式，并将其发送到那里。 曾经有过类似主题的出版物。 特别值得注意的是<i>C. Gent，I.-P。</i>  <i>Jefferson and P.Nightingale（2017）</i> <a href="https://jair.org/index.php/jair/article/view/11079/26262">（n-皇后完成的复杂度）</a> ，作者证明了所讨论的问题属于NP-完全集，并讨论了尝试解决该问题时遇到的困难。 在结论中，作者写道：“对于任何了解国际象棋规则的人，n-Queens完成可能是所有最自然的NP-Complete问题之一”（ <i>对于每个了解国际象棋规则的人，n-Queens完成任务可以成为其中一项最自然的NP完成任务</i> ）。 <br><br>  10天后，我收到JAIR的拒绝，其措词是：“该文章与期刊的格式不符”，即 甚至没有考虑这篇文章。 我没想到会有这样的答案。 我认为，如果期刊发表的文章认为作者很难解决给定的问题并且不提供任何具体解决方案，那么提供有效解决方案算法的文章肯定会被接受。 但是，编辑对此事有自己的见解。  （我相信有能力的专家在那里工作，并且他们很可能受到“无礼的”文章标题和那里所说的一切的质疑。我们认为，“最有可能是某种错误，我轻率地把我送走了，指的是格式”）。 <br><br> 我不得不选择另一本有关主题的同行评审期刊科学出版物。 在这里，我面临着严峻的现实。 事实是，大约80％的杂志都是付费的：要么我必须向该杂志支付一定数额的费用，以便所有读者可以免费获得该文章，要么他们需要把该文章作为礼物“送礼”，并且他们将向所有想了解这项研究。 从根本上说，第一和第二种选择是我无法接受的。 当我试图使自己熟悉一些出版物时，我对这种发行人球拍的方法感觉很好。 <br><br> 另一本以免费获取信息为原则的杂志是<i>《 SMAI计算数学杂志》</i> 。 他们也拒绝了同样的措辞，尽管速度更快了-两天之内。 <br><br> 然后选择了期刊： <i>离散数学与理论计算机科学</i> 。 这里的要求很简单，首先您需要在arXiv.org中发布文章，然后再注册该文章以供考虑。 好的，我们会遵守规则-我在<i>arXiv.org中</i>提交了一篇文章。 他们写信给我说，他们将在8小时内发布该文章。 但是，这不会在8小时后发生，而不是在8天后发生。 该文章由导师“持有”，并且仅在9天后才发表。 在文章的形式和本质上没有任何抱怨。 我认为，与JAIR一样，导师对“这样做并编写”的可能性表示怀疑。 一段时间后，纠正了技术错误后，文章进行了更新，最终形式在新年之夜发布。 <br><br> 我必须详细说明这一点，以表明在研究结果发表的阶段可能存在无法逻辑解释的问题。 <br><br> 以下是在<a href="https://arxiv.org/pdf/1912.05935.pdf">（arXiv.org）上</a>发布了其英语翻译的文章。 <br><br><h3>  1.简介 </h3><br> 在制定<i>n皇后问题</i>的各种选择中，有<i>问题</i> <i>的n皇后完成</i>任务由于其复杂性而处于特殊位置。 在他们的工作中<a href="https://jair.org/index.php/jair/article/view/11079/26262">（Gent at all（2017））</a>显示<i>n-皇后完成问题</i>属于集合<i>NP-完成</i> （ <i>表明n-皇后完成既是NP-完成又是＃P-完成</i> ）。 假定该问题的解决方案可以为我们解决<i>NP-Complete</i>集中的其他问题打开道路。 <br><br> 问题被表述如下。 由<i>k个</i>皇后组成，一贯分布在大小为<i>nxn</i>的棋盘上。 需要证明该组合物可以完成为完整的溶液，并给出至少一种溶液，或者证明不存在这种溶液。 在这里，通过一致性，我们指的是满足以下三个条件的<i>k个</i>皇后的组合：在每一行，每一列以及穿过女王所在的单元格的左右对角线上，最多只能有一个皇后。 这种形式的问题最早由<i>Nauk（1850）提出</i> 。 <br><br>  <b>1.1定义</b> <br><br> 在下文中，我们将用符号<i>n</i>表示棋盘侧面的尺寸。 如果将所有<i>n个</i>皇后号始终放在棋盘上，则该解决方案将称为“完整”。 所有其他解决方案，当正确放置的皇后数<i>k</i>小于<i>n时</i> ，我们将其称为合成。 如果可以在完整的解决方案之前完成，我们称<i>k个</i>皇后组合为正。 因此，直到完成解决方案才能完成的构图称为否定构图。 作为大小为<i>nxn</i>的“棋盘”的类似物，我们还将考虑大小为<i>nxn</i>的“解决方案矩阵”。 例如，将使用Matlab语言介绍为解决该问题而开发的所有算法。 <br><br> 该研究是在计算机仿真（计算仿真）的基础上进行的。 为了检验这个假设或该假设，我们在各种值<i>n</i> =（10，20，30，40，50，60，70，80，90，100，200，300，500，800，1000，3000， 5000，10000，30,000，50,000，80,000，10 5，3 * 10 <sup>5，5</sup> * 10 <sup>5，10</sup> 6，3 * 10 <sup>6，5</sup> * 10 <sup>6，10</sup> 7，3 * 10 <sup>7，5</sup> * 10 <sup>7，8</sup> * 10 <sup>7，10</sup> <sup>8</sup> ），并根据<i>n</i>的值生成足够大的样本进行分析。 我们称此类列表为进行计算实验的“ <i>n个值的基本列表</i> ”。 所有计算均在常规计算机上进行。 在组装时（2013年初），它的配置相当成功： <i>CPU-Intel Core i7-3820、3.60 GH，RAM-32.0 GB，GPU-NVIDIA Ge Forse GTX 550 Ti，磁盘设备-ATA Intel SSD，SCSI，OS- 64位操作系统Windows 7 Professional</i> 。 我们将此套件简称为<i>-desktop-13</i> 。 <br><br><h3>  2.数据准备 </h3><br> 该算法首先读取一个文件，该文件包含一维数据数组，该数据数组包含<i>k个</i>皇后的任意成分的分布。 假定以以下方式准备数据。 设一个归零数组<i>Q（i）= 0，i =（1，...，n）</i> ，其中该数组的单元格索引对应于解矩阵的行索引。 如果在解决方案矩阵的任意行<i>i中</i>的位置<i>j处</i>有一个皇后，则执行赋值<i>Q（i）= j</i> 。 因此，合成大小<i>k</i>将等于数组<i>Q</i>的非零像元数<i>。</i>  （例如， <i>Q =（0，0，5，0，4，0，0，3，0，0）</i>表示我们正在考虑在矩阵<i>n = 10</i>上构成<i>k = 3个</i>皇后，其中皇后位于第3个，第5和第8行，分别位于：5、4、3）。 <br><br><h3>  3.验证解n-Queens问题正确性的算法 </h3><br> 为了进行研究，我们需要一种算法，该算法将使我们能够在短时间内确定<i>n-Queens问题</i>解的正确性。 控制皇后在每一行和每一列中的位置很简单。 问题是对角线限制。 如果我们可以将解决方案矩阵的每个像元映射到某个控制向量的某个像元，那么它可以唯一地描述对角线限制对所讨论像元的影响，那么我们可以为这种核算建立一个有效的算法。 然后，基于控制向量的单元格是空闲还是繁忙，可以判断决策矩阵的相应单元格是空闲还是关闭。<font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic＆Gu（1990）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先使用了这种想法</font><font style="vertical-align: inherit;">，以考虑并积累皇后不同位置之间的冲突情况。我们在下面介绍的算法中使用了类似的想法，但只是要考虑解决方案矩阵的单元格是空闲还是繁忙。例如，图1显示了一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 x 8的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">棋盘，</font><font style="vertical-align: inherit;">上面有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元格</font><font style="vertical-align: inherit;">的序列</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图1.矩阵单元的对角线投影与控制阵列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相应单元的对应关系的演示示例</font><font style="vertical-align: inherit;">，（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将前15个单元视为控制矢量</font><i><font style="vertical-align: inherit;">D1的</font></i><font style="vertical-align: inherit;">元素</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。来自解矩阵的任何单元的所有左对角线的投影落入控制向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的单元之一</font><font style="vertical-align: inherit;">。实际上，所有这些投影都位于两个平行的线段内，其中一个将矩阵</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（8.1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的单元与向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第一个单元</font><font style="vertical-align: inherit;">相连</font><font style="vertical-align: inherit;">，将第二个-矩阵（1.8）的单元与控制向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第15个单元</font><font style="vertical-align: inherit;">相连</font><font style="vertical-align: inherit;">。对于右对角线投影，我们给出了类似的定义。为此，将原点从单元格1移动到右侧的单元格9，并将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元格</font><font style="vertical-align: inherit;">的序列</font><font style="vertical-align: inherit;">视为控制向量</font><i><font style="vertical-align: inherit;">D2的</font></i><font style="vertical-align: inherit;">元素</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在图中，这些是从9号到24号的像元。）从解决方案矩阵的任何像元开始的所有对角线的投影将从第二个像元到第16个像元（从图中的第10个像元开始）落入此控制向量的一个像元中。 24）。在这里，所有这些投影都位于两条平行线段之间：将溶液矩阵的单元格（8,8）与向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元格16 </font><font style="vertical-align: inherit;">（图中的单元格24）相连接的段以及将溶液矩阵的单元格（1,1）与单元格之间的连接段控制向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第2 </font><i><font style="vertical-align: inherit;">步</font></i><font style="vertical-align: inherit;">（图中的单元10）。位于同一左对角线上的解矩阵的所有单元的投影都落在左控制向量</font><i><font style="vertical-align: inherit;">D1</font></i><font style="vertical-align: inherit;">的同一单元中</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分别位于相同右对角线上的解矩阵的所有单元的投影分别落入右控制向量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相同单元中</font><font style="vertical-align: inherit;">。因此，这两个控制矢量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许完全控制决策矩阵的任何单元的所有对角线抑制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要注意，在控制向量的单元上使用对角线投影来确定具有坐标</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的求解矩阵的单元</font><i><font style="vertical-align: inherit;">是</font></i><font style="vertical-align: inherit;">空闲还是繁忙的想法</font><font style="vertical-align: inherit;">后来在</font><i><font style="vertical-align: inherit;">Richards（1997）中得到了</font></i><font style="vertical-align: inherit;">实现。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它基于带位掩码的操作，为所有解决方案提供了最快的递归搜索算法之一。一个重要的区别是，所示算法设计用于从解决方案矩阵的第一行（向下）或从矩阵的最后一行（向上）开始的所有解决方案的顺序搜索。我们提出的算法基于以下条件：皇后位置的每行编号选择必须是任意的。对于正在考虑的算法，这是至关重要的。请注意，上面的图1是我们与本文所发表的内容类似地构建的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n皇后问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的给定解是否</font><font style="vertical-align: inherit;">正确或</font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;">的给定组成是否正确的程序</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后如下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.要控制对角线禁令，请创建两个数组</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（1：n2）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（1：n2）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中n2 = 2 * n，以及一个数组</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B（1：n），</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以控制解决方案矩阵各列的占用率。将这三个数组清零。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.我们介绍正确安装的皇后数量（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的计数器</font><font style="vertical-align: inherit;">。一致地，从第一行开始，在一个周期中，我们考虑所有皇后位置。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（i）&gt; 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则根据第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">的索引和该行中女王的位置的索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q（i），我们</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为控制数组</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形成相应的索引</font><font style="vertical-align: inherit;">：</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j-i </font></font></i> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.如果满足所有条件（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）= 0，D2（t）= 0，B（j）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），则意味着该单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ i，j）是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自由的，并且不属于先前建立的女王形成的对角线限制的投影区域。女王在这个位置上的位置是正确的。如果不满足这些条件中的至少一个，则分别选择该位置将是错误的，并且该决定将是错误的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.如果解决方案是正确的，则增加正确安装的皇后数的计数器（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = totPos + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并关闭控制数组的相应单元格：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（D1（r）= 1，D2（t）= 1，B（j）= 1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。所以我们关闭列中的所有单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及沿着矩阵的左，右对角线与单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相交的解矩阵的单元格</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.对所有剩余职位重复验证过程。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许这是用于评估</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n皇后问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解的正确性的最快算法之一</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">桌面13</font></i><font style="vertical-align: inherit;">上</font><font style="vertical-align: inherit;">的解决方案10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩阵的一百万个位置的验证时间</font><font style="vertical-align: inherit;">为0.175秒，大约对应于按下“ Enter”键的时间。</font><font style="vertical-align: inherit;">显然，该算法相对于</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">计数时间是线性的</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.解决问题的算法说明 </font></font></h3><br>  <b>一般</b> 。  <i>n-皇后完成问题</i>是一个经典的不确定性问题。 它的解决方案的主要困难与在状态空间很大的情况下在该行中选择行索引和位置索引的问题有关。 当寻找所有可能的解决方案时，不会出现这样的问题。 我们必须考虑状态空间中的所有有效搜索分支，并且考虑它们的顺序无关紧要。 但是，当需要完成<i>k个</i>皇后的任意组合直到完成一个完整的解决方案时，在这种情况下，我们需要一种用于选择行和列索引的算法，该算法应能充分感知现有的组合并比其他方法更快地得出解决方案。 在此项目中，我们根据以下一般位置决定了选择问题- <i>如果我们无法制定优先于任何行或该行中任何位置优先于其他条件的条件，则我们将基于均匀分布的随机数</i> 。 解决状态空间巨大的问题的类似随机选择方法是很自然的。  <i>DIMACS研讨会</i>论文集<i>（1999）中</i>的一个版本完全致力于在解决复杂问题的算法开发中使用随机选择。 尽管这是完成解决方案的必要条件，但不是充分条件，但是随机选择算法的正确实现可以是一种非常有效的解决方案。  <i>Sosic and Gu（1990）</i>是最早使用随机选择算法解决<i>n-Queens问题的研究之一</i> 。 他们检查的算法基于一个相当简单而简洁的想法。 假设有一个从<i>1</i>到<i>n</i>的数字序列，它们是随机重新排列的。 这样的一组数字具有重要的性质。 它包含以下事实：无论这些数字如何作为皇后位置分布在解决方案矩阵的不同行上（每行一个数字），前两个规则始终会在问题的陈述中得到满足：每一行和每一列都不会不止一位女王。 然而，仅由此获得的位置的一部分将没有对角线限制。 另一部分将与先前建立的皇后区处于“冲突”状态。 为了摆脱这种情况，作者使用比较和互换冲突位置的方法来获得完整的解决方案。 在我们提出的算法中，冲突情况是不可能的，因为在解决问题的每个步骤中，仅在有空的单元格中，才将女王安装在有问题的单元格中。 <br><br>  <b>4.1选择回溯模型（BT）</b> <br><br> 在寻找问题的解决方案的过程中，当解决方案的顺序链导致死胡同时，可能会出现这种情况。 这是非确定性问题的“遗传”性质。 在这种情况下，您需要返回到先前的步骤之一，按照此级别还原任务的状态，然后从该位置再次开始寻找解决方案。 问题是应该返回哪个先前的级别，以及应该返回多少个此类级别（按级别，这意味着要使用给定数量的正确安装的女王/王后解决该问题的特定步骤）。 显然，选择要返回的解决方案级别与在该行中选择行索引或位置索引一样重要。 因此，不管解决该问题的方法如何，都必须首先确定用于返回的基本级别的数目，以及用于返回到这些级别之一的机制和条件。 在我们提出的算法中，我们将解决方案矩阵分为三个基本级别。 这些是返回点。 如果作为解决方案的结果，发生死锁，那么根据任务的参数，我们将返回到这三个基本级别之一。 第一基本级别（ <i>baseLevel1</i> ）对应于所讨论的构图的数据验证完成时的状态。 这是程序的开始。 以下两个基本级别（ <i>baseLevel2</i>和<i>baseLevel3</i> ）的值取决于矩阵<i>n</i>的大小。 这些基本值对解决方案矩阵大小的经验依赖性是根据大量计算实验确定的。 为了更准确地表示这种依赖性，我们将整个考虑的间隔从7到10 <sup>8</sup>分为两部分。 令<i>u = log（n）</i> ，然后如果<i>n &lt;30 000</i> ，则 <br><br>  <i>baseLevel2 = n-舍入（12.749568 * u3-46.535838 * u2 + 120.011829 * u-89.600272）</i> <br>  <i>baseLevel3 = n-舍入（9.717958 * u3-46.144187 * u2 + 101.296409 * u-50.669273）</i> <br><br> 否则 <br><br>  <i>baseLevel2 = n-舍入（-0.886344 * u3 + 56.136743 * u2 + 146.486415 * u + 227.967782）</i> <br>  <i>baseLevel3 = n-舍入（14.959815 * u3-253.661725 * u2 + 1584.713376 * u-3060.691342）</i> <br><br>  <b>4.2区块结构</b> <br><br> 该算法以<i>五个事件块</i>的序列的形式构造，其中每个事件与问题解决方案的特定部分的执行相关。 每个块中的处理算法互不相同。 五个模块中只有三个用于形成解决方案的顺序链，其余两个模块是准备性的。 开始计算的块编号的选择取决于<i>n</i>的值以及将合成大小<i>k</i>与<i>baseLeve2</i>和<i>baseLevel3</i>的值进行比较的结果。  <i>n =（7，...，99）</i>的值是一个例外<i>，</i>由于本节中算法行为的特殊性，可以将其称为“湍流区”。 对于<i>n =（7，...，49）的值</i> ，无论构图的大小如何，在输入和监视数据后，计算将从第4块开始。 对于值<i>n =（50，...，99）</i> ，根据构图的大小，计算从第二个块开始或从第四个块开始。 如上所述，在解决问题的每个步骤中，仅认为生产线上的那些位置不属于先前确定的女王/王后创建的限制区域。 这些职位<i>被称为自由</i>职位。 <br> 让我们简要地描述在程序的这五个模块中的每个模块中执行什么计算。 <br><br>  <b>4.3算法开始</b> <br><br> 输入数据并检查组成是否正确。 在每个验证步骤，将更改控制阵列的单元。 计算正确安装的女王/王后的数量。 如果合成中没有错误，则解决方案继续，否则显示错误消息。 验证完成后，将创建主阵列的副本，以供在此级别重用。 此后，控制权转移到<i>Block-1</i> 。 <br><br>  <b>4.4区块1</b> <br><br> 搜索分支形成的开始。 我们以位于棋chess上的<i>k个</i>皇后为起点。 需要继续完成此组合并将皇后区放置在棋盘上，直到其总数等于<i>baseLevel2为止</i> 。 这里使用的算法称为<i>randSet＆randSet</i> 。 这是由于以下事实：我们在这里不断比较两个随机的索引列表，以寻找没有对应对角线限制的对。 为此，执行以下操作： <br><br>  a）形成两个列表：一个自由行索引列表和一个自由列索引列表； <br><br>  b）随机重新排列每个列表中的数字； <br><br>  c）在一个循环中，每对连续的值对<i>（i，j）</i> ，其中从自由行索引列表中选择索引<i>（i）</i> ，从自由列索引列表中选择索引<i>（j）</i> ，被视为潜在的皇后位置，并检查是否对角线例外的投影区域中的位置。 <br><br> 如果不违反对角线例外规则，则认为该位置正确，并且将女王放置在该位置。 之后，将计数器增加正确安装的皇后区的数量，并更改控制阵列的相应单元。 如果位置<i>（i，j）</i>落入由先前建立的皇后区形成的对角线限制区域，则没有任何变化，并且过渡到考虑下一对值。 <br><br> 当列表中所有对的比较周期完成时，然后，根据对角线排除区域中的其余索引，再次形成剩余空闲行和空闲列的索引列表，并重复此过程，直到正确放置的皇后总数<i>（totPos ）</i>将不等于或超过<i>baseLevel2</i>的限制值。 一旦满足此条件，控制权就会转移到<i>Block-2</i> 。 如果发现由于寻找解决方案而导致的情况是，从剩余的空闲行和空闲列的整个索引列表中发现，没有一个对适合女王/王后的位置，那么在这种情况下，将根据先前生成的副本恢复控制数组的原始值，控制权将转移到<i>Block-1</i>的开头进行重新计数。 <br><br>  <b>4.5第2区</b> <br><br> 该块用作过渡到<i>块3</i>的准备阶段。 在此级别上，剩余的自由行数（ <i>freeRows</i> ）明显少于<i>n</i> 。 这使您可以将事件从大小为<i>nxn</i>的原始矩阵传输到大小为<i>L</i>的矩阵<i>（1：freeRows，1：freeRows）</i> 。 此外，基于关于原始解矩阵中剩余的空闲行和空闲列的信息，将零写入阵列<i>L</i>的相应单元中，指示这些单元是空闲的。 通过这种<i>“投影”</i>过渡，新矩阵的行和列索引与原始矩阵的相应索引的对应关系得以保留。 重要的是要注意，尽管在解决此问题的过程中，所有事件都在大小为<i>nxn</i>的原始矩阵上展开，并且这样的矩阵是主要的活动场所，但<i>实际上并没有创建此矩阵</i> ，而仅控制占行索引<i>A（1：n）</i>和此矩阵的<i>B</i>列<i>（1：n）</i> 。 <br><br> 与L数组一起，在此块中还形成了两个工作数组<i>rAr（1：freeRows）</i>和<i>tAr（1：freeRows）</i> ，以保存控制数组<i>D1</i>和<i>D2</i>的相应索引。 这是由于以下事实：当我们在大小为<i>nxn</i> <i>的</i>初始矩阵的像元<i>（i，j）中</i>安装下一个皇后时，然后我们必须排除落入原始<i>``</i>大''数组对角线例外投影区域的数组<i>L的</i>像元。 由于对角线约束的控制仅在大小为<i>nxn</i>的原始矩阵内执行，因此工作数组<i>rAr</i>和<i>tAr</i>的存在使<i>我们</i>能够保持对应关系并将禁止的单元格转换为数组L的边界。这大大简化了排除位置的核算。 <br> 在完成该块中的准备工作之后，将创建主阵列的副本以在此级别上重复使用，并将控制权转移到<i>Block-3</i> 。 <br><br>  <b>4.6方块3</b> <br><br> 在此块中，根据上一个块中准备的数据继续进行求解搜索分支的形成。 正确设置了皇后的行数等于或大于<i>baseLevel-2</i> 。 您需要继续选择，直到安装的皇后数量等于<i>baseLevel-3为止</i> 。 在这里，我们使用<i>rand＆rand</i>解决方案搜索算法，即 为了形成女王的位置，而不是使用自由索引列表，仅使用两个索引，一个自由行的随机索引值和该行中一个自由位置的随机索引值。 循环重复此过程，直到放置的皇后总数等于<i>baseLevel-3</i>的值<i>为止</i> 。 满足此条件后，控制权立即转移到<i>Block-4</i> 。 如果作为计算结果，搜索分支变成死胡同，则关闭搜索分支形式的这一部分，并返回到<i>Block-3</i>的开头，从此处再次重复计算。 为此，将还原所有控制数组的初始值。 <br><br>  <b>4.7方块4</b> <br><br> 在此块中，准备了将控制权转移到<i>块5的数据</i> 。 到此步骤，在完成<i>块3中</i>的过程之后，空闲行数（ <i>nRow</i> ）变得更少了。 因此，将事件从较大的数组转换为较小的数组也是有益的。 这种方法使我们有机会快速确定在此阶段需要的其余生产线的必要特性。 特别重要的事实是，基于这样的阵列，可以在不完成计算的情况下预测搜索分支前进许多步的前景。 条件很简单。 如果发现剩余的空闲行中有一条没有空闲位置的行，则所考虑的搜索分支将关闭，控制权将转移到较低级别的块之一。 此处执行的准备操作在很大程度上与<i>Block-2中的</i>操作类似。 基于自由行和自由列的原始索引，形成一个新的二维数组，其零值对应于原始解决方案矩阵中的自由位置。 另外，在此块中创建了一个特殊的数组<i>E（1：nRow，1：nRow）</i> ，根据该数组，您可以确定如果选择位置<i>（i，j）</i>设置女王/王后将要关闭的剩余空闲行中的空闲位置数。源矩阵。 在将控制权转移到<i>块5</i>之前，执行以下操作： <br><br>  a）确定所有剩余行中的空缺职位数量， <br><br>  b）对于有问题的行，其空缺头寸数量的数组按升序排序， <br><br>  c）如果所有剩余的空闲行都具有空闲位置（即，此排序列表中的最小值不同于0），则控制权转移到Block-5。 <br><br> 如果发现在其余任何行中都没有空闲位置，则根据存储的副本还原必要的数组，然后根据任务的参数将控制转移到基本级别之一。 <br><br>  d）形成此第4级所有控制阵列的备份副本。 <br><br>  <b>4.8区块5</b> <br><br> 这个阶段是最后的阶段，此处搜索分支的形成更加“平衡”和“合理”。 这是“最后一英里”，仅剩下少量的免费线路。 但是同时，这是最困难的部分。 总体上，在寻找解决方案的分支的形成的先前阶段中可能已经犯下的所有错误，都以该行中缺少自由位置的形式出现。 <br><br> 该块的算法基于两个嵌套循环执行，在其中执行第三个循环。 第三个循环的一个特点是可以重复执行，而无需更改两个外部循环的参数。 如果生成的搜索分支处于死锁状态，则会发生这种情况。 此类重复的数量不超过<i>repeatBound</i>的边界值，其最佳值是根据计算实验确定的。 <br><br> 外循环索引与行索引的顺序选择相关联，这些行索引在第三基本级别进行计算后仍然保持空闲。 这是根据先前排序的行列表（通过该行中的空闲位置的数量）完成的。 选择从一条线开始，该线具有最少的自由位置，然后在后续步骤中按升序排列。 在此循环内，形成第二个循环，该循环的索引通过所讨论行中所有空闲位置的索引。 第一个循环的目的仅是选择该级别上空闲线之一的索引。 因此，第二个循环的目的仅仅是在所考虑的行中选择一个自由位置。 这些操作仅在第三基本级别上发生。 选择此选项后，安装的皇后数量将增加，并且所有控制阵列的相应单元也将更改。 此外，控制在嵌套（第三）循环内转移，该循环的活动区域已经是所有剩余的自由线。 在此循环内，将根据以下规则执行行索引的选择和该行中自由位置的选择： <br><br>  a） <b>选择一条空闲线路</b> 。 考虑所有剩余的自由行，并确定每行中的自由位置数。 选择该行的空闲位置数量最少。 这样可以最大程度地减少与以下可能性有关的风险：排除剩余的某些行中的最后一个空缺职位，这些状态对于空缺职位的数量而言是最小且至关重要的（ <b>最小风险规则</b> ）。 顺便说一句，牢记这一规则是，在第五个块中的第一个循环的索引始于对行的顺序选择，其中行的空闲位置数为最小值。 如果在某一步骤上发现这两行具有相同的最小空缺职位数，则将随机选择排名列表中最先列出的两个职位之一的索引。 如果具有相同的最小空闲位置数的行数大于2，则将随机选择排名列表中最先列出的三个位置之一的索引。 <br><br>  b） <b>连续选择自由位置</b> 。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从所讨论的行中所有空缺位置的列表中，选择一个对所有其余行中的空缺位置造成最小损害的设备。这是在先前生成的数组E的基础上完成的。“最小损坏”是指在给定行中选择这样的位置，该位置排除了所有其余行中最少的自由位置（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小损坏规则）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）如果事实证明，根据损坏标准，一行中的两个或多个空闲位置具有相同的最小值，则将随机选择列表中最先列出的两个位置之一的索引。选择一个在剩余行中排除最少数量自由位置的位置可以最大程度地减少与女王位置在该位置相关的“损坏”。使用这两个规则，可以在形成搜索分支的每个步骤中更合理地使用资源。如果所讨论的组合物具有解决方案，这将大大降低风险，并增加选择任意组合物成为完整解决方案的可能性。如果在解决方案的某个步骤中发现在要考虑的其余行之一中没有空缺位置，则关闭此搜索分支。在这种情况下，基于备份，将还原所有控制阵列，并且如果重复次数计数器不超过限制值</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在不更改第一外部循环和第二外部循环的索引的情况下，再次重复第三嵌套循环的工作。这是因为在相关标准的最小值一致的情况下，我们进行了随机选择。在基本级别的相同条件下重新形成搜索分支可以更有效地利用此级别提供的“启动资源”。限制第三个嵌套循环的重复启动次数，如果超出极限值，则该循环的操作将中断。之后，恢复控制数组的值，并将控制转移到第三基本级别的循环以转到下一个索引值。循环重复此过程，直到获得完整的解决方案，或者事实证明我们在此基本级别上使用了所有自由行和这些行中的所有自由位置。在这种情况下，根据在各个基本级别上重复计算的总数，并考虑决策矩阵的大小和构图的大小，可以返回到较低的级别之一进行重复计算，或者判断为所讨论的构图不能配备完整的解决方案。在程序中，为了限制账单的总时间，程序被接受或做出判断，直到完成一个完整的决定才能完成所涉及的构图。在程序中，为了限制账单的总时间，程序被接受或做出判断，直到完成一个完整的决定才能完成所涉及的构图。在程序中，为了限制账单的总时间，程序被接受</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论返回的是先前的哪个级别，都可以执行不超过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totSimBound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次的</font><i><font style="vertical-align: inherit;">Back Tracking</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">基于计算实验针对n的各种值选择该边界值。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.选择算法的有效性分析 </font></font></h3><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的效率</font><font style="vertical-align: inherit;">。为了分析该算法的功能，进行了计算实验，其中包括在</font><font style="vertical-align: inherit;">存在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型的情况下</font><font style="vertical-align: inherit;">将皇后区放置在解决方案矩阵中。一旦搜索分支达到死胡同，或获得了完整的溶液，就确定了组成尺寸，溶液时间，并再次重复了测试。对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值的整个基本列表进行了计算实验</font><font style="vertical-align: inherit;">。值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（30，40，...，90，100，200，300，500，800，1000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的重复测试次数</font><font style="vertical-align: inherit;">等于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一百万次</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，对于剩余值，测试次数随着</font><i><font style="vertical-align: inherit;">n的</font></i><font style="vertical-align: inherit;">增加而增加</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从100000逐渐减少到100。对计算实验结果的分析使我们得出以下结论：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）仅由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet过程</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第一个循环</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">平均正确放置了所有皇后区的60％。对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100，正确放置的皇后数为60.05％。随着n值的增加，该值逐渐减小，对于n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7，其</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值为59.97％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）无论决策矩阵</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">的大小如何，获得的组合物的长度值分布的直方图都具有相同的形式</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此外，它们都具有特征-分布的左侧（至模态值）与右侧不同。在图2中，作为一个例子，示出了对应的直方图</font></font><br><br><img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所示。 2. randSet和randSet模型（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100，样本大小= 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的各种长度的溶液分布的直方图</font><font style="vertical-align: inherit;">。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100。似乎直方图是从两个不同事件的频率分布中收集的，因为分布的左右部分中事件发生的频率不同。为了描述这种分布，最有可能适合使用正态分布密度的两个函数，其中一个覆盖模态值的间隔，另一个覆盖模态值之后的间隔。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c）</font><font style="vertical-align: inherit;">基于该算法的决策矩阵中可以设置</font><font style="vertical-align: inherit;">的皇后数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的平均值</font><font style="vertical-align: inherit;">随</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加</font><font style="vertical-align: inherit;">。从图3中可以看到，其中显示了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比值</font><font style="vertical-align: inherit;">与矩阵大小</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的依赖关系图</font><font style="vertical-align: inherit;">，该比值随矩阵大小的增加而增加。例如，</font></font><br><img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图3.比率</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ñ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为矩阵尺寸的各种解决方案。模型是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是解决方案长度的平均值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果对于大小为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的矩阵，</font><font style="vertical-align: inherit;">选择位置</font><i><font style="vertical-align: inherit;">的</font></i><font style="vertical-align: inherit;">算法为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许“不停”将皇后区平均放置在89行上，然后对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000x1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩阵</font><font style="vertical-align: inherit;">，此类行的数量平均增加到967。d </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）基于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet算法，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以获得完整的解决方案，但是这种方法的“生产率”极低。从图4可以看出，对于</font></font><br><br><img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 4.随着</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">的增加，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中获得完整解的可能性降低</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">值</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> = 7，获得完全解的概率为</font><i><font style="vertical-align: inherit;">0.057</font></i><font style="vertical-align: inherit;">。此外，随着</font><i><font style="vertical-align: inherit;">n的</font></i><font style="vertical-align: inherit;">增加</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得完整解的概率迅速降低，渐近接近零。从值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48开始，获得完整解的概率约为10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在阈值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70之后，对于后续的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">未获得一个完整的解决方案（测试数量等于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一百万</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以很高的速度生成搜索分支。对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＝ 1000，获得组成的平均时间为0.0015秒。组合物的平均长度为967。因此，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均时间为2.6754秒，平均歌曲长度为999793。f </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）除很小的间隔</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70外，当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在极少数情况下可以</font><i><font style="vertical-align: inherit;">得出</font></i><font style="vertical-align: inherit;">完整的解决方案时，在所有其他情况下，决策分支都以否定乐曲结尾。在完成解决方案之前无法完成。所以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它具有一个重要的优点-搜索分支的形成速度很高，并且一个显着的缺点是，如果合成物的大小超过某个阈值，则此算法会导致形成合成物，直到完成完整的求解。为克服此缺点，当达到阈值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时，我们停止了搜索分支的形成</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法的效率</font><font style="vertical-align: inherit;">。为了确定</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">算法的功能，</font><font style="vertical-align: inherit;">对</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">值的基本列表进行了相当详细的计算机仿真</font><font style="vertical-align: inherit;">。与</font><i><font style="vertical-align: inherit;">randSet和randSet模型一样</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在大多数情况下，重新测试的次数等于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一百万</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于其他值，测试数量从100,000逐渐减少到100。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这两种算法均基于随机选择的原理。因此，应该期望这里得出的结论与为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制定的结论基本上相同</font><font style="vertical-align: inherit;">。但是，它们之间有根本的区别，它包括以下内容：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型</font><font style="vertical-align: inherit;">不像</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那样“困难” </font><font style="vertical-align: inherit;">。如果我们谈论一些“合理利用所提供的机会的指标”，那么</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">模型</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每一步都更加合理地使用资源。这导致这样一个事实，例如，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30时，在此模型中获得0.00170的完全解的概率是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相似值0.00011的15倍</font><font style="vertical-align: inherit;">。另外，在此，直到阈值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370，仍保留了在一百万次测试中获得至少一个完整解的可能性。在此阈值之后，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后续值（</font><font style="vertical-align: inherit;">测试数量等于一百万），在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型的基础上</font><font style="vertical-align: inherit;">没有获得一个完整的解。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）该算法比</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要慢得多</font><font style="vertical-align: inherit;">。如果是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000以生成大小为967的合成，获得一个合成的平均时间将为0.0497秒，这比</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相应值0.0015多33 </font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种基本相似的随机选择方法之间存在差异的原因是由于在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，为了加快计算速度，并未在每个步骤中从其余列表中进行随机选择。而是从两个列表中顺序选择一对索引，它们的元素被随机重新排列。这样的选择并不是完全随机的，但是，它很适合问题的逻辑，可以让您快速地进行计数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直观地演示</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">算法的操作</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则进行了以下实验：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）对于大小为</font><i><font style="vertical-align: inherit;">100x100</font></i><font style="vertical-align: inherit;">的棋盘</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在女王/王后在任意行中的位置的每一步之后，确定其余所有空闲行中的空闲位置数。因此，在解决问题的每个步骤之后，我们都会收到一个空行列表和一个相应的空行数量列表。这样就可以构造一个图表，其中所讨论的矩阵的列的索引沿横坐标轴绘制，剩余的自由位置数沿纵坐标轴绘制。为了进行比较，还对职位的顺序选择模型进行了计算。顺序选择是指以下内容。考虑第一行，其中选择了列表中的第一自由位置。然后，考虑第二行，其中还选择了列表中的第一自由位置等。在图5和6中</font></font><br><br><img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图5.减少放置皇后后剩余空闲线中的空闲位置数。顺序定期选择职位。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给出了与正在考虑的模型相对应的结果。为了清楚起见，该图仅显示步骤（10、40、60）之后的结果。对于顺序选择位置的模型，最后一个是第62步之后的图形，因为搜索分支由于第63行中缺少自由位置而终止。另一方面，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型中</font><font style="vertical-align: inherit;">，最后一张图是在放置皇后的第70步之后显示的，尽管在这里，正确放置的皇后的平均数目达到89，比顺序模型多了26步。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">模型中图形的奇异视图</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于行索引是在剩余的空闲行中随机选择的，因此它们在整个求解矩阵中是随机分散的。这两个图的比较表明，在头寸选择的顺序模型中，自由头寸数量的变化范围大于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型</font><font style="vertical-align: inherit;">。这是由于以下事实：在常规选择中，对角线约束会不均匀地排除其余行中的自由位置，这导致以下事实：在某些行中，空位数量的减少率高于其他行。</font></font><br><br><img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图6.放置皇后后，减少剩余空闲线中的空闲位置数。定位模型为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand和rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相反，在自由行索引和自由列索引的随机选择下，女王的位置均匀分布在决策矩阵的“区域”上，从而降低了剩余行中自由位置数量的“平均”减少率。因此，考虑到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法的功能</font><font style="vertical-align: inherit;">，我们在程序中使用它来继续形成解决方案搜索分支，直到达到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">级别为止</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该注意的是，即使选择算法（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet，rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）不是那么有效，在开发算法时我们仍然必须使用其他随机选择方法。这是由于问题的陈述所致。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-皇后完成问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果我们想象有一个解决该问题的最佳算法，那么在输入时，这种算法将始终接收到行和列索引的某个随机集合。每次都会有来自各种可能性的一组新的随机行和列索引集。为了能够“接受”算法中的各种随机成分，必须在随机选择的基础上构建算法本身。匹配应该</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像一把锁的钥匙</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果我们根据此原理构造算法，则来自</font><i><font style="vertical-align: inherit;">k的</font></i><font style="vertical-align: inherit;">任何一致组成</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后将被视为决策周期中的初始（开始）位置。</font><font style="vertical-align: inherit;">而且，目标仅是继续形成寻找解决方案的分支，直到找到给定成分的解决方案，或者证明不存在这种解决方案。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.使用最小风险规则的示例（n = 100） </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在寻找解决方案的初始阶段，当行中空闲位置的数量不是关键时，那么选择空闲行的索引或该行中位置的索引并不是致命的。但是，在最后阶段，当某些行中的空缺职位数为1或2时，在这种情况下，您应该选择其他选择算法。在此级别上，随机选择算法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不再起作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面的简单示例可以解释随机选择算法不起作用的原因。在某个问题的解决步骤中，对于其余任意行</font><i><font style="vertical-align: inherit;">i </font></i><i><sub><font style="vertical-align: inherit;">1</font></sub></i><i><font style="vertical-align: inherit;">，i </font></i><i><sub><font style="vertical-align: inherit;">2</font></sub></i><i><font style="vertical-align: inherit;">，...，i </font></i><i><sub><font style="vertical-align: inherit;">k</font></sub></i><font style="vertical-align: inherit;">为n的任意值</font></font><i><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空位的数量（在方括号中表示）为：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1），i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2），i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4），i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5），i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3），i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。如果您随机选择任何行，但没有选择第i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行，而</font><font style="vertical-align: inherit;">其中只有一个自由位置，则当与所选行中女王/王后位置相关的对角线禁止会导致该行中唯一自由位置的关闭时，可能会导致风险情况</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这将导致解决方案陷入僵局。在所有行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，...，i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对行索引的选择最脆弱和最敏感的是第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">。在这种情况下，您应该首先选择状态最关键的行，这会带来解决问题的风险。因此，在解决问题的最后阶段，在每个步骤中，都必须基于最小风险的简单算法来选择生产线的位置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了清楚起见，让我们以一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩阵为例，它</font><font style="vertical-align: inherit;">是第88步之后形成真实解的最后阶段。在任务完成之前，还剩下12条空行，每个空行都找到了空缺职位（这些行按空缺职位的数量递增顺序排列）：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤89-25（1），12（2），22（2），82（2），88（2），7（3），64（3），3（4），76（4），91 （4），4（5），96（5）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -表示自由线的索引，括号中-表示该行中自由位置的数量。根据最小风险规则，在解决问题的第89步中，选择第25行，并选择其中的一个自由位置。重新计票的结果是，我们还有11条空闲行：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Step-90-7（2），12（2），22（2），82（2），88（2），3（3），64（3）， 76（3），4（4），91（4），96（4）。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，前五行中的空闲位置数量相同且等于2。因此，前三行之一的索引是随机选择的。</font><font style="vertical-align: inherit;">在这种情况下，选择了第12行，而这两个行的位置仍保留在该行中，因此损害最小。</font><font style="vertical-align: inherit;">因此，在溶液形成的第91步中，我们有10条自由线：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤91-22（1），3（2），7（2），82（2），88（2），64（3） 76（3），91（3），4（4），96（4）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在此步骤中，选择了第22行以及其中的一个自由位置。</font><font style="vertical-align: inherit;">以类似的方式继续，形成了以下决策序列（表1）。</font><font style="vertical-align: inherit;">所选行的索引以粗体显示。</font></font><br><div class="scrollable-table"><table><caption> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1.最小风险规则的使用说明（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100）</font></font></b> <br></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 步骤 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 89 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25（1）</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12（2） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22（2） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82（2） </font></font></td><td> 7(3) </td><td> 64(3) </td><td> 3(4) </td><td> 76(4) </td><td> 91(4) </td><td> 4(5) </td><td> 96(5) </td></tr><tr><td> 90 </td><td> 7(2) </td><td> <b>12(2)</b> </td><td> 22(2) </td><td> 82(2) </td><td> 3(3) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 91(4) </td><td> 96(4) </td><td></td></tr><tr><td> 91 </td><td> <b>22(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 76(3) </td><td> 91(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td> 92 </td><td> <b>88(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td> 93 </td><td> <b>3(1)</b> </td><td> 7(2) </td><td> 76(2) </td><td> 82(2) </td><td> 91(2) </td><td> 4(3) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td></tr><tr><td> 94 </td><td> <b>76(1)</b> </td><td> 4(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td><td></td></tr><tr><td> 95 </td><td> <b>91(1)</b> </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 96 </td><td> <b>4(1)</b> </td><td> 82(1) </td><td> 7(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 97 </td><td> <b>7(1)</b> </td><td> 82(1) </td><td> 64(2) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 98 </td><td> <b>82(1)</b> </td><td> 64(2) </td><td> 96(2) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 99 </td><td> 64(1) </td><td> <b>96(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 100 </td><td> <b>64(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此特定示例中，在12个案例中有11个出现了这样的情况：在剩余的空闲行列表中，至少有一行仅保留一个空闲位置。如果我们不使用最低风险规则，那么我们将无法解决问题。由于在选择自由线的索引时出现“错误的举动”，因此很可能导致销毁剩余自由线之一中唯一的自由位置。这就是为什么仅使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet x randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">获得完整解决方案的原因，在最后阶段，解决方案将走到尽头。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该注意的是，最小风险算法具有简单的日常含义，并且经常用于决策中。</font><font style="vertical-align: inherit;">例如，医生首先对病情至关重要的病人进行手术，同样地，农民在严重干旱期间试图保存农作物，首先浇灌那些病情最严重的地区...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.算法效率分析 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了评估各种n值算法的效率，进行了相当长的（就总时间而言）计算实验。最初，开发了一种相当快速的算法，用于生成任意值n的解决方案数组nQueens问题。然后，基于该程序，为n值的基本列表形成了较大的解样本。对于各个n值，分别获得的nQueens问题解决方案样本的大小相等：（10）-1000，（20，30，...，90，100，200，300，500，800，1000，3000，5000，10,000）- -10000，（30000，50000，80000）-5000，（105，3 * 105）-3000，（5 * 105，8 * 105，106）-1000，（3 * 106）-300，（ 5 * 106）-200，（10 * 106）-100，（30 * 106）-50，（50 * 106）-30，（80 * 106、100 * 106）-20。此处，在方括号中指示了n个值的列表，并且双破折号指示了获得的溶液的样本量。之后，基于溶液的每个样品形成任意大小的无规组合物。例如，对于n = 1000的10,000个溶液中的每一个，形成了100个任意大小的随机组合物。结果是一百万首歌曲的样本。由于在现有解决方案的基础上形成的任意大小的成分都可以至少完成一次，直到完成一个完整的解决方案，因此任务是基于n皇后完成问题解决方案算法，完成从生成的样本到完整解决方案的每个成分。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能在溶液的每个样品的基础上形成任意大小的无规组合物。例如，对于n = 1000的10,000个溶液中的每一个，形成了100个任意大小的随机组合物。结果是一百万首歌曲的样本。由于在现有解决方案的基础上形成的任意大小的成分都可以至少完成一次，直到完成一个完整的解决方案，因此任务是基于n皇后完成问题解决方案算法，完成从生成的样本到完整解决方案的每个成分。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能在溶液的每个样品的基础上形成任意大小的无规组合物。例如，对于n = 1000的10,000个溶液中的每一个，形成了100个任意大小的随机组合物。结果是一百万首歌曲的样本。由于在现有解决方案的基础上形成的任意大小的成分都可以至少完成一次，直到完成一个完整的解决方案，因此任务是基于n皇后完成问题解决方案算法，完成从生成的样本到完整解决方案的每个成分。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能形成了100个任意大小的随机组合物。结果是一百万首歌曲的样本。由于在现有解决方案的基础上形成的任意大小的成分都可以至少完成一次，直到完成一个完整的解决方案，因此任务是基于n皇后完成问题解决方案算法，完成从生成的样本到完整解决方案的每个成分。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能形成了100个任意大小的随机组合物。结果是一百万首歌曲的样本。由于在现有解决方案的基础上形成的任意大小的成分都可以至少完成一次，直到完成一个完整的解决方案，因此任务是基于n皇后完成问题解决方案算法，完成从生成的样本到完整解决方案的每个成分。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能那么任务就是根据n皇后完成问题解决方案算法，从生成的样本中完成每个构图，最后完成一个完整的解决方案。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能那么任务就是根据n皇后完成问题解决方案算法，从生成的样本中完成每个构图，最后完成一个完整的解决方案。由于在所考虑的算法中，每一步都检查了皇后在棋盘上的正确放置，因此原则上不能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的积极</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定（即我们错误地认为正确的错误决定）。但是，可能会有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案-如果在解决方案完成之前，程序无法完成基于现有解决方案形成的任何组合物（尽管我们知道所有组合物都有解决方案）。在如此广泛的n值范围内进行计算实验，我们为自己设定了以下目标：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）确定算法的时间复杂度，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）确定n的各个值的假阴性解的概率，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c）确定使用反向跟踪程序进行测量的频率n的不同值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表2列出了这种计算实验的结果。</font></font><br><div class="scrollable-table"><table><caption> <b> 2.         n.</b> <br> <i>n</i> –   ; <i>m</i> –   ; t <sub>mean</sub> , t <sub>min</sub> , t <sub>max</sub> – ,     ; t90 <sub>mean</sub> –   ,    10%    ; FalseNeg( FalseNegative) –  ,      ; <i>t <sub>row</sub> = t <sub>mean</sub> *10 <sup>6</sup> / n</i> ,   10 <sup>6</sup>   ,            <i>nxn</i> . <br></caption><tbody><tr><th> n </th><th> m </th><th> t <sub>mean</sub> </th><th> t90 <sub>mean</sub> </th><th> t <sub>min</sub> </th><th> t <sub>max</sub> </th><th> FalseNeg </th><th> t <sub>row</sub> </th></tr><tr><td>  10 </td><td> 5000 </td><td> <b>0.001010</b> </td><td> 0.000532 </td><td> 0.000168 </td><td> 0.080673 </td><td>  2 </td><td> 1.0102 </td></tr><tr><td>  20 </td><td> 10 <sup>5</sup> </td><td> <b>0.003589</b> </td><td> 0.001809 </td><td> 0.000197 </td><td> 0.363096 </td><td>  5 </td><td> 1.7945 </td></tr><tr><td>  30 </td><td> 10 <sup>5</sup> </td><td> <b>0.008025</b> </td><td> 0.003793 </td><td> 0.000244 </td><td> 0.495716 </td><td>  10 </td><td> 2.6752 </td></tr><tr><td> 40 </td><td> 10 <sup>5</sup> </td><td> <b>0.014323</b> </td><td> 0.009127 </td><td> 0.000252 </td><td> 0.965817 </td><td>  7 </td><td> 3.5807 </td></tr><tr><td> 50 </td><td> 10 <sup>5</sup> </td><td> <b>0.005357</b> </td><td> 0.003589 </td><td> 0.000313 </td><td> 0.441711 </td><td>  9 </td><td> 10.7146 </td></tr><tr><td> 60 </td><td> 10 <sup>5</sup> </td><td> <b>0.005991</b> </td><td> 0.004103 </td><td> 0.000340 </td><td> 0.013738 </td><td>  10 </td><td> 9.9852 </td></tr><tr><td> 70 </td><td> 10 <sup>5</sup> </td><td> <b>0.006533</b> </td><td> 0.004566 </td><td> 0.000368 </td><td> 0.583897 </td><td>  8 </td><td> 9.3328 </td></tr><tr><td> 80 </td><td> 10 <sup>5</sup> </td><td> <b>0.006975</b> </td><td> 0.004987 </td><td> 0.000394 </td><td> 0.635676 </td><td>  7 </td><td> 8.7187 </td></tr><tr><td> 90 </td><td> 10 <sup>5</sup> </td><td> <b>0.006912</b> </td><td> 0.004763 </td><td> 0.000393 </td><td> 1.012710 </td><td>  4 </td><td> 7.6840 </td></tr><tr><td> 100 </td><td> 10 <sup>5</sup> </td><td> <b>0.007264</b> </td><td> 0.005107 </td><td> 0.000419 </td><td> 0.692387 </td><td>  4 </td><td> 7.2641 </td></tr><tr><td> 300 </td><td> 10 <sup>5</sup> </td><td> <b>0.013518</b> </td><td> 0.009496 </td><td> 0.000986 </td><td> 3.349766 </td><td>  3 </td><td> 4.5060 </td></tr><tr><td> 500 </td><td> 10 <sup>5</sup> </td><td> <b>0.028194</b> </td><td> 0.014554 </td><td> 0.001541 </td><td> 4.558749 </td><td>  2 </td><td> 5.6388 </td></tr><tr><td> 800 </td><td> 10 <sup>5</sup> </td><td> <b>0.049385</b> </td><td> 0.022735 </td><td> 0.002367 </td><td> 6.192782 </td><td>  1个 </td><td> 6.1731 </td></tr><tr><td> 1000 </td><td> <b>10 <sup>6</sup></b> </td><td> <b>0.062157</b> </td><td> 0.027727 </td><td> 0.002943 </td><td> 8.015123 </td><td>  0 </td><td> 6.2156 </td></tr><tr><td> 3000 </td><td> 10 <sup>5</sup> </td><td> <b>0.177290</b> </td><td> 0.088507 </td><td> 0.008537 </td><td> 16.713140 </td><td>  0 </td><td> 5.9097 </td></tr><tr><td> 5000 </td><td> 10 <sup>5</sup> </td><td> <b>0.159239</b> </td><td> 0.136047 </td><td> 0.014224 </td><td> 42.181080 </td><td>  0 </td><td> 3.1849 </td></tr><tr><td> 10 <sup>4</sup> </td><td> 10 <sup>5</sup> </td><td> <b>0.321003</b> </td><td> 0.270927 </td><td> 0.028594 </td><td> 79.321174 </td><td>  0 </td><td> 3.2100 </td></tr><tr><td> 3*10 <sup>4</sup> </td><td> 10 <sup>4</sup> </td><td> <b>0.968795</b> </td><td> 0.651618 </td><td> 0.084936 </td><td> 139.28827 </td><td>  0 </td><td> 3.2293 </td></tr><tr><td> 5*10 <sup>4</sup> </td><td> 5000 </td><td> <b>1.147196</b> </td><td> 0.864045 </td><td> 0.143005 </td><td> 154.38225 </td><td>  0 </td><td> 2.2944 </td></tr><tr><td> 8*10 <sup>4</sup> </td><td> 4000 </td><td> <b>2.112079</b> </td><td> 1.215612 </td><td> 0.229532 </td><td> 204.27321 </td><td>  0 </td><td> 2.6401 </td></tr><tr><td> 10 <sup>5</sup> </td><td>  2000 </td><td> <b>2.253118</b> </td><td> 1.433197 </td><td> 0.290566 </td><td> 224.34623 </td><td>  0 </td><td> 2.2531 </td></tr><tr><td> 3*10 <sup>5</sup> </td><td>  2000 </td><td> <b>4.330649</b> </td><td> 3.181905 </td><td> 0.990932 </td><td> 340.29584 </td><td>  0 </td><td> 1.4435 </td></tr><tr><td> 5*10 <sup>5</sup> </td><td>  2000 </td><td> <b>5.985339</b> </td><td> 4.532205 </td><td> 1.488209 </td><td> 382.20016 </td><td>  0 </td><td> 1.1971 </td></tr><tr><td> 8*10 <sup>5</sup> </td><td>  2000 </td><td> <b>8.297512</b> </td><td> 6.554302 </td><td> 2.902425 </td><td> 75.87513 </td><td>  0 </td><td> 1.0372 </td></tr><tr><td> 10 <sup>6</sup> </td><td> 1000 </td><td> <b>11.376632</b> </td><td> 7.932194 </td><td> 2.954968 </td><td> 510.6265 </td><td>  0 </td><td> 1.1377 </td></tr><tr><td> 3*10 <sup>6</sup> </td><td> 400 </td><td> <b>23.138609</b> </td><td> 18.521503 </td><td> 10.433580 </td><td> 122.7597 </td><td>  0 </td><td> 0.7713 </td></tr><tr><td> 5*10 <sup>6</sup> </td><td> 300 </td><td> <b>33.103386</b> </td><td> 28.057816 </td><td> 14.937556 </td><td> 155.0890 </td><td>  0 </td><td> 0.6621 </td></tr><tr><td> 10*10 <sup>6</sup> </td><td> 200 </td><td> <b>61.444001</b> </td><td> 52.269241 </td><td> 31.624475 </td><td> 228.3087 </td><td>  0 </td><td> 0.6144 </td></tr><tr><td> 30*10 <sup>6</sup> </td><td> 50 </td><td> <b>149.71717</b> </td><td> 136.66441 </td><td> 84.556686 </td><td> 352.0534 </td><td>  0 </td><td> 0.4991 </td></tr><tr><td> 50*10 <sup>6</sup> </td><td> 40 </td><td> <b>253.86220</b> </td><td> 228.93732 </td><td> 105.37934 </td><td> 558.4629 </td><td>  0 </td><td> 0.5077 </td></tr><tr><td> 80*10 <sup>6</sup> </td><td>  30 </td><td> <b>372.29294</b> </td><td> 341.56397 </td><td> 250.80182 </td><td> 728.4806 </td><td>  0 </td><td> 0.4654 </td></tr><tr><td> 100*10 <sup>6</sup> </td><td>  20 </td><td> <b>508.43573</b> </td><td> 474.04890 </td><td> 354.80864 </td><td> 831.3753 </td><td>  0 </td><td> 0.5084 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据获得的结果可以得出的一般结论如下：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）该算法工作足够快。例如，</font><font style="vertical-align: inherit;">基于</font><b><font style="vertical-align: inherit;">一百万次</font></b><font style="vertical-align: inherit;">计算实验</font><font style="vertical-align: inherit;">获得</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小的棋盘的任意合成物的平均编译时间</font><font style="vertical-align: inherit;">为0.062157秒。这意味着，如果合成物有溶液，则可以在按</font><i><font style="vertical-align: inherit;">“ Enter”</font></i><font style="vertical-align: inherit;">键后立即找到它</font><font style="vertical-align: inherit;">。对于所有</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">值，</font><font style="vertical-align: inherit;">范围从7到30,000，</font><font style="vertical-align: inherit;">任意合成的平均编译时间</font><font style="vertical-align: inherit;">不超过一秒钟。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）在每个样品中，大约有10％的组合物需要更多的时间才能完成。这样的组成在分布直方图中形成了一条长长的右尾。如果我们排除这10％的成分，并对其余90％的溶液进行计算，那么计算时间（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t90 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均值</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）将大大减少。例如，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">棋盘</font><font style="vertical-align: inherit;">，平均计数时间将为0.027727秒，比从整个样本获得的平均时间少2.24倍。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c）对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≤800的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，在组合物样本中存在直到完全解决才完成的值。这是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假阴性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定。在程序指定的限制内，允许执行</font><font style="vertical-align: inherit;">多达1000次</font><font style="vertical-align: inherit;">的“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回溯”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程</font><font style="vertical-align: inherit;">，该算法未能完成这些合成。他们被错误地归类为负面作品，即那些没有解决方案的人。此类</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假阴性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案的数量微不足道，并且它们在样本中的份额小于0.0001。此外，随着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假阴性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解</font><font style="vertical-align: inherit;">的比例会</font><font style="vertical-align: inherit;">减少。对于所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800的</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，在该系列计算实验中，没有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假负</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解的情况。但是，很明显，如果样本数量增加很多倍，</font><i><font style="vertical-align: inherit;">则</font></i><font style="vertical-align: inherit;">不会排除出现</font><i><font style="vertical-align: inherit;">假阴性</font></i><font style="vertical-align: inherit;">的可能性。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案，尽管发生此类事件的可能性很小。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法的时间复杂度</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。图7示出了对于各种</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值的随机组合物的平均拾取时间的变化图</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图7. </font><font style="vertical-align: inherit;">随机成分</font><font style="vertical-align: inherit;">的平均选取时间（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">与决策矩阵</font><font style="vertical-align: inherit;">大小（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的关系。</font><i><font style="vertical-align: inherit;">n</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值的十进制对数绘制在横坐标轴上</font><font style="vertical-align: inherit;">，平均计数时间增加1000倍的对数绘制在纵坐标轴上。为了清楚起见，该图还显示了象限对角线的虚线。可以看出，拾取时间随着n的增加而线性增加。在n从50到10 </font><sup><font style="vertical-align: inherit;">8</font></sup><font style="vertical-align: inherit;">的整个范围内</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数时间的实验值形成一条直线，其</font><font style="vertical-align: inherit;">线性回归方程</font><i><font style="vertical-align: inherit;">log（1000 * t）=-0.628927 + 0.781568 * log（n）</font></i><font style="vertical-align: inherit;">具有较高的相关性（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0.9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font><font style="vertical-align: inherit;">仅当值</font><i><font style="vertical-align: inherit;">n =（ 10，... 49）</font></i><font style="vertical-align: inherit;">，这是由于在该范围内仅使用第五个计算块来解决该问题，该算法的算法与第一个和第三个块的算法明显不同。在得出的相关性中，线性系数（</font><b><font style="vertical-align: inherit;">0.781568</font></b></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）小于1，这导致以下事实：随着n值的增加，回归线和象限的对角线发散。为了清楚地说明这种差异的原因，而不是最初的时间，我们考虑将一位女王/王后排成一行的平均时间。将平均计数时间除以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们称这种指标为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少时间</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。显然，如果减少的时间不随</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加而变化</font><font style="vertical-align: inherit;">，则这样的解将是线性的（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。如所看到的在图8中，对给定的时间，对数的，其中的曲线</font></font><br><br><img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 8平均时间依赖性（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），这对于将女王/王后从</font><font style="vertical-align: inherit;">求解矩阵</font><font style="vertical-align: inherit;">的大小（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">定位在任意一条线上是必需的</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">从溶液矩阵大小的对数</font><font style="vertical-align: inherit;">增加10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倍，在n从50到10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的范围内</font><font style="vertical-align: inherit;">，减少的时间随着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加而减少</font><font style="vertical-align: inherit;">。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的减少时间为</font><font style="vertical-align: inherit;">10.7146 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒，则n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的对应时间</font><sup><font style="vertical-align: inherit;">将</font></sup><font style="vertical-align: inherit;">减少21次，为0.5084 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒。乍看之下，这种算法的行为似乎是错误的，因为没有客观的原因，为什么对于n的小值，算法认为它比大的值要慢。但是，没有错误，这是该算法的客观属性。这是由于以下事实：该算法是三种以不同速度运行的算法的组合。而且，由这些算法中的每一个处理的行数随着n值的增加而变化。由于这个原因，计数时间在值n =（10，20，30，40）的初始范围内增加，因为在这个小区域内的所有计算仅基于第五步程序进行，该程序非常有效，但速度不如第一步程序。因此，考虑到将皇后放在一条线上所需的计数时间，随棋盘大小的增加而减小，这种算法的时间复杂度可以称为减小-线性。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向跟踪（BT）</font></font></i></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">的次数</font></b><font style="vertical-align: inherit;">。在计算实验的所有案例中，我们使用BT程序跟踪了解决每个问题的案例数。不管使用何种BT返回解决方案，都对使用BT的所有情况进行了累积求和。这使我们有机会为每个样本确定从未使用BT程序的那些决策的比例。图9显示了</font></font><br><br><img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 9.从未在</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图表中</font><font style="vertical-align: inherit;">使用“回溯”过程的样本中的决策比例，该</font><font style="vertical-align: inherit;">图表显示了不使用BT（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零“回溯”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">而解决方案的案例比例如何</font><font style="vertical-align: inherit;">随着</font><i><font style="vertical-align: inherit;">n的</font></i><font style="vertical-align: inherit;">增加</font><font style="vertical-align: inherit;">而变化的情况。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。可以看出，在值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7，...，100000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的范围内，</font><font style="vertical-align: inherit;">从未使用BT程序的解决方案数量超过35％。此外，在值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n ＝（320，...，22500）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的范围内</font><font style="vertical-align: inherit;">，这种情况的数量超过50％。对于大小为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 x 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的棋盘，获得了最有效的结果</font><font style="vertical-align: inherit;">，其中在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10,000个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成分</font><font style="vertical-align: inherit;">的样本中</font><font style="vertical-align: inherit;">，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61.92％的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况下，执行</font><font style="vertical-align: inherit;">了</font><i><font style="vertical-align: inherit;">非确定性</font></i><font style="vertical-align: inherit;">问题</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“确定性”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font><font style="vertical-align: inherit;">，因为BT程序</font><i><font style="vertical-align: inherit;">占61.92％</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">案件从未使用过。在其余的解决方案中，在21.87％的情况下，使用了BT程序1次，在9.07％的情况下使用了2次，在3.77％的情况下使用了3次。一起，占案件的96.63％。在值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000之后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不使用BT程序解决配置问题的情况逐渐减少的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">选择模型有关，该模型用于选择</font><i><font style="vertical-align: inherit;">baseLevel2</font></i><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的边界值</font><font style="vertical-align: inherit;">。您可以更改这些参数，并且无需使用BT程序即可增加解决方案的数量。然而，这将导致计算时间的增加，因为第五块对算法操作的参与将增加。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间分配分布的直方图</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在图10中，对于</font><i><font style="vertical-align: inherit;">n = 1000</font></i><font style="vertical-align: inherit;">的值</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给出了一百万个解决方案的选取时间分布的直方图。分布直方图的视图不是很普通（很可能类似于高层建筑的夜间轮廓），与间隔长度或间隔数选择中的错误无关。这是该算法的自然属性。要了解，</font></font><br><br><img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 10.任意大小组成的汇编时间的直方图。 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样本大小= 1,000,000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么直方图具有这种形式，请考虑具有相同大小的组合物的选取时间分布。为此，举例来说，我们将从初始样本中选择大小为800的所有成分。一百万个样本中有998种成分。图11展示了该样品的计数时间分布的直方图。从图中可以看出，分布由六个独立的直方图组成，并且大小逐渐减小。</font></font><br><br><img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图11.相同大小的组合（k = 800）的编译时间的直方图。 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样本大小= 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之所以将998个作品的编译时间（其中每个800个皇后随机分配）的时间“汇总”为6组，是因为使用了</font><i><font style="vertical-align: inherit;">Back Tracking</font></i><font style="vertical-align: inherit;">程序</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。图中的第一个直方图具有最大的样本量，是从未使用过BT程序的那些拣选解决方案。这是一组最快的解决方案。第二个直方图的大小明显小于第一个直方图，是那些仅使用BT程序一次的解决方案。因此，该组中的决策时间比第一组中的决策时间稍长。因此，在第三组中，BT程序被使用了两次，在第四组中被使用了三遍，等等。较长时间执行了重复使用BT程序的决策。这样的解决方案形成了所需分布的右长尾。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的负解</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果我们将所有可能的成分除以</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">的任意值</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从正数到负数，则在正数构成中有一些可以被该算法归类为负数。这是由于以下事实：在搜索参数设置的限制内，算法找不到正确的方法来完成此类合成。如实验结果（表2）所示，此类情况的数量不超过样本量的0.0001，并且该误差的值随</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加而减小</font><font style="vertical-align: inherit;">。另外，对于所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值，</font><font style="vertical-align: inherit;">没有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假负</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解的情况。即使在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000的情况下</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将样本量增加到一百万，</font><font style="vertical-align: inherit;">也不会导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假阴性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定。</font><font style="vertical-align: inherit;">结果使我们能够制定以下规则来解决该问题：“任何</font><font style="vertical-align: inherit;">连续地分布在大小为</font><i><font style="vertical-align: inherit;">nxn的</font></i><font style="vertical-align: inherit;">棋盘上的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后区的</font><font style="vertical-align: inherit;">随机组成</font><font style="vertical-align: inherit;">都可以完成，直到提出完整的解决方案为止，否则将确定该组成为负，并且不能待完成。</font><font style="vertical-align: inherit;">做出此决定的可能性不超过</font><i><font style="vertical-align: inherit;">0.0001</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">随着棋盘的尺寸增加，做出错误决定的可能性减小。</font><font style="vertical-align: inherit;">该算法的时间复杂度是线性的。”</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.结论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.提出了一种算法，该算法允许在线性时间内解决完整集的问题，直到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后</font><font style="vertical-align: inherit;">区的随机组成的完整解</font><font style="vertical-align: inherit;">，并一致地分布在任意大小</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的棋盘上</font><font style="vertical-align: inherit;">。此外，对于任何</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1≤k &lt;n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的组合，都提供一个解决方案（如果有的话），或者确定该组合无法完成。做出这样的决定时出错的概率不超过0.0001，并且该值随着棋盘尺寸的增加而减小。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.此算法的操作基于两个重要规则的使用：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）在解决问题的最后阶段，从所有剩余的空闲行中选择一个空闲位置最少的行（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小风险规则</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。这将与排除某些剩余生产线中最后一个空缺职位的可能性相关的风险降至最低。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）在相关生产线的所有空缺位置中，选择该位置对剩余的自由生产线中的自由位置造成最小损坏（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小损坏规则</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。 “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小损坏</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”是指在一条线中选择这样一种位置，该位置排除了所有其余自由线中最少的自由位置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.已经确定，由于该算法的操作，将女王放置在一条线上的平均时间随着n值的增加而减少。在n为10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的情况下将皇后放在一行上的平均时间</font><font style="vertical-align: inherit;">比在n = 50的情况下的相应时间少21倍。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.发现在值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7，...，100000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的范围内，</font><font style="vertical-align: inherit;">从未使用反向跟踪过程的解决方案数量超过35％。此外，在值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（320，...，22500）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的范围内，</font><font style="vertical-align: inherit;">此类情况的数量超过50％，这表明该算法的效率很高。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.提出了组织</font><i><font style="vertical-align: inherit;">回溯</font></i><font style="vertical-align: inherit;">程序的模型。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，基于基础层上决策步骤的分离。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等级意味着一定的决策步骤，正确放置一定数量的皇后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。给出了用于根据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算第二和第三基本级别的值的回归公式</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.给出了两种随机选择方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的比较分析结果</font><font style="vertical-align: inherit;">。据该算法发现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速而粗糙。因此，在达到第二基本级别时，其使用受到限制。之后，使用</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">算法。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，执行速度不是很快，但可以更有效地将皇后放在棋盘上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.给出了一种验证</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解的正确性的有效算法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该程序还旨在验证任意大小的随机成分的正确性。</font><font style="vertical-align: inherit;">该程序运行足够快。</font><font style="vertical-align: inherit;">例如，验证包含500万个职位的解决方案所需的时间为0.85秒。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.评论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.如本文开头所述，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值范围内（</font><font style="vertical-align: inherit;">从7到1亿）进行了研究。但是，该程序已在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">（最多10亿）</font><font style="vertical-align: inherit;">的更宽范围内进行了测试</font><font style="vertical-align: inherit;">。的确，在后一种情况下，鉴于数组的大小，该程序必须稍作调整。因此，如果RAM的大小允许，则可以对大的n值进行计算。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.优化基线指标的值以及各个级别重复次数的边界值，以解决整个研究范围内的问题。可以在较小范围内更改它们，并减少计数时间。重要的是不要增加</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">误报</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font><font style="vertical-align: inherit;">的份额</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.在本文中，我使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键按下时间</font><font style="vertical-align: inherit;">作为时间量度，以评估算法的运行速度。如果结果在按下键后立即出现，则在用户感知的级别上，该程序似乎“非常”快速地工作。无论该算法以多快的速度运行，在完成按键之前，结果都不会出现在屏幕上。因此，在我看来，这种时间的条件度量可以用作阈值级别，用于不严格比较各种算法的速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.哲学...在研究过程中，考虑了许多与解决非确定性问题有关的出版物。在大多数情况下，这些任务需要在给定限制条件下在很大的国家空间中做出选择。比较它们，很有趣的是知道使用标准数学方法可以解决这些问题的程度。我的印象是，仅根据定义，引理陈述和定理证明不可能解决这些问题。在我看来，要解决此类问题，有必要使用通过计算机仿真的算法数学方法。为了证明此结论的有效性，作为一个简单示例，我准备了一个大小为10的棋盘</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个相同大小的合成，包括999,999,482个皇后。它们按照本文开头所述进行准备，并以.mat格式显示为两个文件。可以从此链接下载它们</font></font><a href="https://drive.google.com/drive/folders/1p5VJO4fAEs8vNp_EonFIitd1o6EJqzQt%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（两个测试文件）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。文件非常“繁重”，每个文件的大小约为3.97 Gb。在999 997 976行（在99.9998％的情况下）中，两个组合中的皇后位置都重合，并且仅在任意1506行中，皇后的位置不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要完成构图数据以获得完整的解决方案，您需要将皇后区正确放置在其余518条自由行中。在剩余的空闲行中排列518个皇后的可能方式的数量（仅考虑在所选行中选择空闲位置的方式的数量）约为10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1466</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这两种成分之间的区别仅在于，其中一个成分为正，可以完成直到完全溶解，而另一个成分为负-直到完全溶解才可以完成。问题：“是否有可能基于严格的数学方法（即不执行算法计算操作）来确定这两个组成中的哪个为正？”如果这无法解决，则我们可以假设所提出的命题是矛盾的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我要指出的是，无论采用什么数学方法严格解决这个问题，都必须确定状态518 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剩余的空闲行中的单元格。为此，有必要考虑先前设立的女王/王后的每个职位，并且几乎有十亿个女王/王后，以便确定每个设立的女王/王后对其余518行中的自由职位施加的限制。我没有找到一个“支点”，只能在严格的数学方法的基础上进行这项工作，而无需进行算法计算。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在这里给出了一个仅包含两个组成部分的最小示例。如果需要，可以增加这种组合物的数量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该注意的是，在提出的线性算法的基础上，该算法略微适合于处理大型合成，可以完成两个测试合成中的哪一个的任务，直到在</font><i><font style="vertical-align: inherit;">Desktop-13</font></i><font style="vertical-align: inherit;">上执行完整的解决方案为止</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ，大约需要4.5分钟（不包括输入数据加载时间）。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.加法 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教授建议有能力的任务供学生发展和研究的教授的举动值得尊重。</font><font style="vertical-align: inherit;">这需要付出巨大的努力，但要克服困难，研究人员对其他复杂任务的看法有所不同。</font><font style="vertical-align: inherit;">我认为为此类目的扩展设置n皇后问题的选项将很有用。</font><font style="vertical-align: inherit;">如果从不同的角度看待同一任务，您会看到不同的事情。</font><font style="vertical-align: inherit;">以下是其中一些。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.考虑在</font><font style="vertical-align: inherit;">大小为</font><i><font style="vertical-align: inherit;">nxm</font></i><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">矩形“象棋”板上</font></b><font style="vertical-align: inherit;">布置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后</font><font style="vertical-align: inherit;">的问题</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">表示</font><i><font style="vertical-align: inherit;">k = m-n</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">假设得到了一些解决方案，并且每个的</font><i><font style="vertical-align: inherit;">Ñ</font></i></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每行有一个女王。我们不再考虑皇后所在的位置。现在每行有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-1个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自由位置。在剩余的空缺职位中，我们再次找到一个解决方案。和以前一样，我们不再考虑第二个解决方案的皇后所在的位置。现在每行有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-2个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空缺职位。显然，第一和第二解在任何行中的位置都不相交-它们是正交的。需要确定各种</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值的相互正交解的最大数量</font><font style="vertical-align: inherit;">。如果找到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互正交的解，其值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后将建造皇家拉丁广场。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">备注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。纸张</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan的E.（2018）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表明，对于任何解决方案</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正皇后问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一种补充的解决方案，其不干扰它。这意味着对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的任意值，</font><i><font style="vertical-align: inherit;">n </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Queens问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的所有解的集合</font><font style="vertical-align: inherit;">被分为两个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相等大小的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子集。来自第二子集的任何解决方案都是对来自第一子集的相应解决方案的补充解决方案。规则很简单，如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q1（i）是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一组的解，则对应的互补解</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2（i）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过公式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2（i）= n + 1-Q1（i）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定第二个子集中的</font><i><font style="vertical-align: inherit;">i，其中i =（1，...，n）</font></i><font style="vertical-align: inherit;">。正是这个规则解释了以下事实：对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的任意值，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">皇后问题</font></i><font style="vertical-align: inherit;">的所有解的</font><font style="vertical-align: inherit;">数量始终是偶数。 （这条规则可以让你在任何尺寸的完整解决方案的计算一半的时间削减</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">棋盘。如果我们用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 * K</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有的解决方案的总数量，价值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ķ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等于指数中的所有解决方案的顺序列表，当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（K）+ Q（ k + 1）= n + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.在问题</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Qeens问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的初始表述中</font><font style="vertical-align: inherit;">，将女王放置在位置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）之后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将执行以下操作：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）</font><font style="vertical-align: inherit;">排除</font><font style="vertical-align: inherit;">第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">和第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列的</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有单元格； b）排除通过单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左右对角线上的所有单元格</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在问题陈述中更改条件b）。代替消除单元，我们将使用单元切换。如果位于左或右对角线上的单元格是空闲的，则将其关闭；如果该单元格关闭，则将其打开。这样可以更轻松地找到解决方案。但是，</font><font style="vertical-align: inherit;">我们考虑大小为</font><i><font style="vertical-align: inherit;">nx（n-k）</font></i><font style="vertical-align: inherit;">的矩形矩阵</font><font style="vertical-align: inherit;">，而不是正方形矩阵</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于给定的</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，需要找到</font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;">的最大值</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少可以得到三个正交解。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值如何</font><font style="vertical-align: inherit;">随着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加而</font><font style="vertical-align: inherit;">变化</font><font style="vertical-align: inherit;">？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.更改</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n皇后问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题的初始公式中的某些条件</font><font style="vertical-align: inherit;">。如果女王/王后位于</font><font style="vertical-align: inherit;">大小为</font><i><font style="vertical-align: inherit;">nxn</font></i><font style="vertical-align: inherit;">的棋盘上的</font><font style="vertical-align: inherit;">位置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">a）排除第</font><i><font style="vertical-align: inherit;">i</font></i><font style="vertical-align: inherit;">行中的所有单元格</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">b）如果索引</font><i><font style="vertical-align: inherit;">j为</font></i><font style="vertical-align: inherit;">偶数，则：</font><font style="vertical-align: inherit;">b1）排除第j列偶数行中的</font><font style="vertical-align: inherit;">单元格</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">b2）排除第</font><font style="vertical-align: inherit;">i列中的</font><font style="vertical-align: inherit;">单元格与左右对角线相交的偶数行穿过像元</font><i><font style="vertical-align: inherit;">（i，j）</font></i><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">c）如果索引</font><i><font style="vertical-align: inherit;">j</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇数，则满足位于奇数行上的单元的项目b1）和b2）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1已知</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Sloane-2016）</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">n </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">皇后问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的所有解决方案的值列表</font><font style="vertical-align: inherit;">，其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">8，9，10，11，12，12，13，14，15，16 </font></i><i><font style="vertical-align: inherit;">）</font></i><font style="vertical-align: inherit;">分别为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（92，352，724，2680， 14200、73712、365596、2279184、14772512）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果在问题陈述中，将对角线例外的标准条件更改为b）或c）段，所有解决方案的数量将如何变化？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 Grigoryan（2018）知道，如果我们确定解决方案矩阵的不同单元参与形成所有解决方案列表的频率，我们会发现所有单元之间都存在对应频率的垂直和水平对称形式的和谐关系。这意味着，如果我们假设</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k &lt;n / 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行的单元频率将与行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的单元频率相同</font><font style="vertical-align: inherit;">。类似地，第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列的单元的频率将与列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的单元的频率相同</font><font style="vertical-align: inherit;">。问题：“这些和谐关系在任务范围内将如何变化？”</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.棋盘的所有单元格按其颜色分为两类。据信一种颜色是白色，另一种颜色是黑色。考虑两个棋盘，并将其中一个放在另一个上，以使边缘完全重合。结果，我们从两个棋盘上得到一个“三明治”，白色和黑色单元格的排列重合。任务是在两个板上同时找到解决方案，并遵守以下条件：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）如果在一块板上，皇后位于索引为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的黑色单元上</font><font style="vertical-align: inherit;">，则：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-在两个板上，所有出现的黑色单元在第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">和第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列</font><font style="vertical-align: inherit;">，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-在两个板上</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排除了沿穿过单元</font><i><font style="vertical-align: inherit;">（i，j）的</font></i><font style="vertical-align: inherit;">左右对角线的所有黑色单元</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）如果皇后位于一个带有索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的白色单元格上</font><font style="vertical-align: inherit;">，则仅对白色单元格执行a）段的所有操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.想象一下，在大小为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的解决方案矩阵中</font><font style="vertical-align: inherit;">，行可以以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元</font><font style="vertical-align: inherit;">为单位相对于彼此左右滑动</font><font style="vertical-align: inherit;">。此外，例如，如果前一行向左移动，那么下一行应向右移动，即每行的下一行都与上一行的方向相反。作为这种构造的结果，我们获得了尺寸为1的矩形矩阵。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx（n + k）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中在每行中，从行的开头或结尾开始的k个单元将被排除在外。任务是为任意一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值找到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的最大值，</font><font style="vertical-align: inherit;">对于该值</font><font style="vertical-align: inherit;">至少存在一个解</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑问题的一种变体，其中一条线相对于另一条线的偏移是一个从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的随机数</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. </font><b><i><font style="vertical-align: inherit;">nQueens问题</font></i></b><font style="vertical-align: inherit;">的一</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维表述</font></font><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个任意长度的段（从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1到n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编号）</font><font style="vertical-align: inherit;">布置在半轴上</font><font style="vertical-align: inherit;">。将每个细分除以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意大小的像元，并且在每个段中，将像元从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1到n进行编号</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们称这种细胞为开放的。它要求在每个段靠近一个小区，考虑以下限制：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）我们可以选择具有索引开孔</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ĵ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个片段，如果：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（R）= 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）= 0；</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j-i，t = j + i，D1和D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一维控制数组，由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先前为零的像元组成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）选择之后，段</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和编号为</font><i><font style="vertical-align: inherit;">j的</font></i><font style="vertical-align: inherit;">单元格</font><font style="vertical-align: inherit;">将关闭</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有剩余的免费细分中。还必须关闭控制数组中的相应单元：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）= 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）= 1；</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此设置下，任务与原始任务完全相同。有趣的是在其他约束条件下解决此问题。例如，如果代替公式：</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R =正+ J - I，T = J + I， </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将被认为是其它比例，这在功能上相关联的索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- [R</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（I，J）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的制备基体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于带球an的任务措辞</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（与之前的措辞相同）。假设有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">骨灰盒，编号从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1到n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每个中都有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">球，编号也从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1到n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。需要瓮从每一个球距，考虑以下限制：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）我们可以选择以数字球囊</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ĵ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个瓮如果：</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（R）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（T）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R =正+ J -i，t = j + i，D1和D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一维控制数组，其中包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先前被置零的像元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）选择此选项后，</font><font style="vertical-align: inherit;">所有剩余的免费投票箱中的</font><font style="vertical-align: inherit;">投票箱</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和编号为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">球</font><font style="vertical-align: inherit;">都将关闭</font><font style="vertical-align: inherit;">。还需要关闭控件数组中的相应单元格：</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）= 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）= 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此设置下，任务与原始任务完全相同。与前面的情况一样，该问题的陈述还有其他条件，这些条件在功能上将索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">决策矩阵</font><font style="vertical-align: inherit;">的索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接</font><font style="vertical-align: inherit;">在一起</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。考虑大小为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的棋盘</font><font style="vertical-align: inherit;">。让我们将颜色返回皇后区，让一些皇后区具有白色，而其他皇后区则为黑色。我们还根据索引为</font><i><font style="vertical-align: inherit;">（1，n）</font></i><font style="vertical-align: inherit;">的单元格的事实，将黑白交替的颜色返回到棋盘格的单元格</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该是白色的。游戏开始时的所有单元格均视为免费。白皇后走出第一步。玩家将女王放置在带有索引</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的任意空闲单元格中</font><font style="vertical-align: inherit;">。让它成为一个白细胞。由于此选择，它们被关闭：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行的所有白色单元格</font><font style="vertical-align: inherit;">，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）第</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列的所有白色单元格</font><font style="vertical-align: inherit;">，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c）穿过单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左右对角线上的所有白色单元格</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果单元格</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i，j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变成黑色，则满足所有点</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a，b，c）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此，所有黑色单元格均关闭。接下来，布莱克执行移动，将女王放置在任何剩余的自由单元中。之后，如上所述，以类似的方式关闭单元。考虑下一步行动的时间是固定的，并由双方协商确定。如果在指定时间内，其中一个玩家未完成其移动，则将游戏转移到另一个。如果两个玩家，一个接一个，都未能在指定时间内完成回合，则游戏结束。可以在董事会中放置更多皇后的人将获胜。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.关于稳定性的随机选择。考虑</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通过比较</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机的行和列索引对，在循环的第一阶段，有可能平均建立皇后</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">可以被认为是等于0.6的常数。其值从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10时的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.605701变化</font><font style="vertical-align: inherit;">到n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6时的</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.599777 </font><font style="vertical-align: inherit;">，并且随着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">增加</font><font style="vertical-align: inherit;">，该值的方差减小。这种“恒定”的原因是什么？为什么在随机选择行索引和女王/王后在该行中的位置索引时，基于从1到n的数字随机排列而获得的两个数字列表，能否将女王/王后（平均）始终放置在60％的行上？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.令棋盘的大小为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。基于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet和randSet过程</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将皇后放在棋盘上，直到搜索分支达到死胡同为止。用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示由此获得的合成物的长度</font><font style="vertical-align: inherit;">。如果对于给定的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">重复此过程多次，并建立</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值分布的直方图</font><font style="vertical-align: inherit;">，那么事实证明，事件发生频率向分布模式值的变化与该值之后事件发生频率的变化不同。如果基于模态值将直方图分为两部分，则左侧部分将与右侧部分不一致。此模式是</font><i><font style="vertical-align: inherit;">n的</font></i><font style="vertical-align: inherit;">任何值的特征</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为什么在成分的长度通过模态值过渡后，事件开始的频率采用不同的形式？所谓事件，是指在陷入僵局之前接受给定大小的组成。</font></font><br><br><h4> 文学作品 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Nauck，F.（1850）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Illustrierte Zeitung，15，182。2 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><a href="https://jair.org/index.php/jair/article/view/11079/26262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent，IP，Jefferson，C。 ＆Nightingale，P.（2017年）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-皇后完成的复杂性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《人工智能研究杂志》，第59卷，第815-848页。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sosic，R.，＆Gu，J.（1990）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n皇后问题的多项式时间算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 SIGART公告，1（3），7-11。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards，M.（1997）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCPL中使用位模式和递归的回溯算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科技剑桥大学计算机实验室代表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法设计中的随机化方法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，DIMACS研讨会论文集，美国新泽西州普林斯顿，1997年12月12日至14日。DIMACS系列离散数学和理论计算机科学43，DIMACS / AMS 1999，ISBN 978-0-8218-0916-7 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. </font></font><a href="http://ejournal11.com/journals_n/1537458681.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E.（2018）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解n皇后问题形成规律的研究</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">人工智能建模，5（1），3-21 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><a href="http://oeis.org/A000170,%25202016"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sloane N.-JA（2016）。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数序列的在线百科全书。</font></font><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483036/">https://habr.com/ru/post/zh-CN483036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483018/index.html">Mask-R CNN从初学者到专业人士</a></li>
<li><a href="../zh-CN483024/index.html">“公司如何处理您的隐私？”，Arthur Khachuyan（Tazeros Global）</a></li>
<li><a href="../zh-CN483026/index.html">Java / Spring：如何使用Speedment完全生成CRUD REST API</a></li>
<li><a href="../zh-CN483030/index.html">让你哭泣的API</a></li>
<li><a href="../zh-CN483032/index.html">从独联体到捷克共和国，自己的经验（第2部分）</a></li>
<li><a href="../zh-CN483038/index.html">熟练地重新启动游戏世界</a></li>
<li><a href="../zh-CN483040/index.html">远东组装Excel 97的魔术起子</a></li>
<li><a href="../zh-CN483042/index.html">9 Vue性能技巧</a></li>
<li><a href="../zh-CN483048/index.html">终极乐趣：10个经典的控制台笑话</a></li>
<li><a href="../zh-CN483050/index.html">前5个ReactJS开发公司</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>