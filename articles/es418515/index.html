<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>  锔 Reemplazar Equals y GetHashCode. 驴Pero es necesario?   锔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si est谩 familiarizado con C #, lo m谩s probable es que sepa que siempre debe anular Equals , as铆 como GetHashCode , para evitar la GetHashCode rendimie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reemplazar Equals y GetHashCode. 驴Pero es necesario?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Si est谩 familiarizado con C #, lo m谩s probable es que sepa que siempre debe anular <code>Equals</code> , as铆 como <code>GetHashCode</code> , para evitar la <code>GetHashCode</code> rendimiento.  Pero, 驴qu茅 pasar谩 si esto no se hace?  Hoy, comparamos el rendimiento con dos opciones de ajuste y consideramos herramientas para ayudar a evitar errores. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  驴Qu茅 tan serio es este problema? </h2><br>  No todos los posibles problemas de rendimiento afectan el tiempo de ejecuci贸n de la aplicaci贸n.  El m茅todo <code>Enum.HasFlag</code> no <code>Enum.HasFlag</code> muy eficiente (*), pero si no lo utiliza en un c贸digo de uso intensivo de recursos, no habr谩 problemas serios en el proyecto.  Este tambi茅n es el caso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las copias protegidas</a> creadas por tipos de estructura no solo de lectura en el contexto de solo lectura.  El problema existe, pero es poco probable que se note en aplicaciones ordinarias. <br><br>  <i>(*) Se corrigi贸 en .NET Core 2.1 y, como mencion茅 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en una publicaci贸n anterior</a> , ahora las consecuencias pueden mitigarse utilizando el HasFlag autoconfigurado para versiones anteriores.</i> <br><br>  Pero el problema del que hablaremos hoy es especial.  Si los m茅todos <code>Equals</code> y <code>GetHashCode</code> no se crean en la estructura, <code>System.ValueType</code> sus versiones est谩ndar de <code>System.ValueType</code> .  Y pueden reducir significativamente el rendimiento de la aplicaci贸n final. <br><br><h2>  驴Por qu茅 las versiones est谩ndar son lentas? </h2><br>  Los autores de CLR hicieron todo lo posible para que las versiones est谩ndar de Equals y GetHashCode fueran lo m谩s eficientes posible para los tipos de valor.  Pero hay varias razones por las cuales estos m茅todos pierden en la efectividad de la versi贸n del usuario, escrita para cierto tipo manualmente (o generada por el compilador). <br><br>  1. Distribuci贸n de la conversi贸n de envases.  El CLR est谩 dise帽ado de tal manera que cada llamada a un elemento definido en los tipos <code>System.ValueType</code> o <code>System.Enum</code> desencadena una transformaci贸n de <code>System.ValueType</code> (**). <br><br>  <i>(**) Si el m茅todo no admite la compilaci贸n JIT.</i>  <i>Por ejemplo, en Core CLR 2.1, el compilador JIT reconoce el m茅todo <code>Enum.HasFlag</code> y genera un c贸digo adecuado que no comienza a ajustarse.</i> <br><br>  2. Posibles conflictos en la versi贸n est谩ndar del m茅todo <code>GetHashCode</code> .  Cuando implementamos una funci贸n hash, nos enfrentamos a un dilema: hacer que la distribuci贸n de la funci贸n hash sea buena o r谩pida.  En algunos casos, puede hacer ambas cosas, pero en el tipo <code>ValueType.GetHashCode</code> , esto suele ser dif铆cil. <br><br>  Una funci贸n hash tradicional de tipo struct "combina" los c贸digos hash de todos los campos.  Pero la 煤nica forma de obtener el c贸digo hash de campo en el m茅todo <code>ValueType</code> es usar la reflexi贸n.  Es por eso que los autores de CLR decidieron sacrificar la velocidad por el bien de la distribuci贸n, y la versi贸n est谩ndar de <code>GetHashCode</code> solo devuelve el c贸digo hash del primer campo distinto de cero y lo <a href="">"estropea" con un identificador de tipo</a> (***) (para m谩s detalles, consulte <code>RegularGetValueTypeHashCode</code> en coreclr repo en github). <br><br>  <i>(***) A juzgar por los comentarios en el repositorio de CoreCLR, la situaci贸n puede cambiar en el futuro.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Este es un algoritmo razonable hasta que algo sale mal.  Pero si no tiene suerte y el valor del primer campo de su tipo de estructura es el mismo en la mayor铆a de los casos, entonces la funci贸n hash siempre producir谩 el mismo resultado.  Como habr谩s adivinado, si guardas estas instancias en un conjunto de hash o una tabla de hash, entonces el rendimiento caer谩 en picado. <br><br>  3. La velocidad de implementaci贸n basada en la reflexi贸n es baja.  Muy bajo  La reflexi贸n es una herramienta poderosa si se usa correctamente.  Pero las consecuencias ser谩n terribles si lo ejecuta en un c贸digo de uso intensivo de recursos. <br><br>  Veamos c贸mo una funci贸n hash fallida, que puede resultar de (2) y la implementaci贸n basada en la reflexi贸n, afecta el rendimiento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Si el valor del primer campo es siempre el mismo, de manera predeterminada la funci贸n hash devuelve un valor igual para todos los elementos y el conjunto hash se convierte efectivamente en una lista vinculada con operaciones de inserci贸n y b煤squeda O (N).  El n煤mero de operaciones para llenar la colecci贸n se convierte en O (N ^ 2) (donde N es el n煤mero de insertos con complejidad O (N) para cada inserto).  Esto significa que insertar en un conjunto de 1000 elementos producir谩 casi 500,000 llamadas a <code>ValueType.Equals</code> .  隆Aqu铆 est谩n las consecuencias de un m茅todo que usa la reflexi贸n! <br><br>  Como muestra la prueba, el rendimiento ser谩 aceptable si tiene suerte y el primer elemento de la estructura es 煤nico (en el caso de <code>Position_Path_DefaultEquality</code> ).  Pero si esto no es as铆, entonces la productividad ser谩 extremadamente baja. <br><br><h2>  Problema real </h2><br>  Creo que ahora puedes adivinar qu茅 problema encontr茅 recientemente.  Hace un par de semanas recib铆 un mensaje de error: el tiempo de ejecuci贸n de la aplicaci贸n en la que estoy trabajando aument贸 de 10 a 60 segundos.  Afortunadamente, el informe fue muy detallado y conten铆a un rastro de eventos de Windows, por lo que el punto del problema se descubri贸 r谩pidamente: <code>ValueType.Equals</code> carg贸 50 segundos. <br><br>  Despu茅s de un r谩pido vistazo al c贸digo, qued贸 claro cu谩l era el problema: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  Us茅 una tupla que conten铆a un tipo de estructura personalizada con la versi贸n est谩ndar de <code>Equals</code> .  Y desafortunadamente, ten铆a un primer campo opcional, que casi siempre equival铆a a <code>String.equals</code> .  La productividad se mantuvo alta hasta que el n煤mero de elementos en el conjunto aument贸 significativamente.  En cuesti贸n de minutos, se inicializ贸 una colecci贸n con decenas de miles de elementos. <br><br><h2>  驴La <code>ValueType.Equals/GetHashCode</code> predeterminada de <code>ValueType.Equals/GetHashCode</code> siempre se ejecuta lentamente? </h2><br>  Tanto <code>ValueType.Equals</code> como <code>ValueType.GetHashCode</code> tienen m茅todos de optimizaci贸n especiales.  Si el tipo no tiene "punteros" y est谩 correctamente empaquetado (mostrar茅 un ejemplo en un minuto), entonces se usan versiones optimizadas: las iteraciones <code>GetHashCode</code> se realizan en bloques de instancias, se usa XOR de 4 bytes, el m茅todo <code>Equals</code> compara dos instancias usando <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  La comprobaci贸n en s铆 se realiza en <code>ValueTypeHelper::CanCompareBits</code> , se llama tanto por la iteraci贸n de <code>ValueType.Equals</code> como por la iteraci贸n de <code>ValueType.GetHashCode</code> . <br><br>  Pero la optimizaci贸n es una cosa muy insidiosa. <br><br>  En primer lugar, es dif铆cil de entender cuando est谩 encendido;  Incluso peque帽os cambios en el c贸digo pueden activarlo y desactivarlo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Para obtener m谩s informaci贸n sobre la estructura de la memoria, consulte mi blog, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Elementos internos de un objeto administrado, Parte 4. Estructura del campo"</a> . <br><br>  En segundo lugar, comparar la memoria no necesariamente te da el resultado correcto.  Aqu铆 hay un ejemplo simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> y <code>+0,0</code> son iguales, pero tienen diferentes representaciones binarias.  Esto significa que <code>Double.Equals</code> es verdadero y <code>MyDouble.Equals</code> es falso.  En la mayor铆a de los casos, la diferencia no es significativa, pero imagine cu谩ntas horas pasar谩 solucionando el problema causado por esta diferencia. <br><br><h2>  驴C贸mo evitar un problema similar? </h2><br>  驴Puedes preguntarme c贸mo puede suceder lo anterior en una situaci贸n real?  Una forma obvia de ejecutar los m茅todos <code>Equals</code> y <code>GetHashCode</code> en los tipos de estructura es usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regla</a> FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CA1815</a> .  Pero hay un problema: este es un enfoque demasiado estricto. <br><br>  Una aplicaci贸n para la que el rendimiento es cr铆tico puede tener cientos de tipos de estructura que no se usan necesariamente en conjuntos hash o diccionarios.  Por lo tanto, los desarrolladores de aplicaciones pueden deshabilitar la regla, lo que causar谩 consecuencias desagradables si el tipo de estructura utiliza funciones modificadas. <br><br>  Un enfoque m谩s correcto es advertir al desarrollador si la estructura de tipo "inapropiada" con los mismos valores predeterminados de elementos (definidos en la aplicaci贸n o una biblioteca de terceros) se almacena en un conjunto hash.  Por supuesto, estoy hablando de <a href="">ErrorProne.NET</a> y la regla que agregu茅 all铆 tan pronto como me encontr茅 con este problema: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  La versi贸n ErrorProne.NET no es perfecta y "culpar谩" al c贸digo correcto si se utiliza un solucionador de igualdad personalizado en el constructor: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Pero sigo pensando que vale la pena advertir si una estructura con elementos iguales por defecto no se usa cuando se est谩 produciendo.  Por ejemplo, cuando revis茅 mi regla, me di cuenta de que la estructura <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> definida en mscorlib no sobrescribe <code>Equals</code> y <code>GetHashCode</code> .  Es poco probable que alguien defina una variable como <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> hoy, pero creo que incluso BCL puede romper la regla.  Por lo tanto, es 煤til descubrir esto antes de que sea demasiado tarde. <br><br><h2>  Conclusi贸n </h2><br><ul><li>  La implementaci贸n de la igualdad predeterminada para los tipos de estructura puede tener serias consecuencias para su aplicaci贸n.  Este es un problema real, no te贸rico. </li><li>  Los elementos de igualdad predeterminados para los tipos de valor se basan en la reflexi贸n. </li><li>  La distribuci贸n realizada por la versi贸n est谩ndar de <code>GetHashCode</code> ser谩 muy mala si el primer campo de muchas instancias tiene el mismo valor. </li><li>  Existen versiones optimizadas para los m茅todos est谩ndar <code>Equals</code> y <code>GetHashCode</code> , pero no debe confiar en ellos porque incluso un peque帽o cambio de c贸digo puede desactivarlos. </li><li>  Use la regla FxCop para asegurarse de que cada tipo de estructura anula los elementos de igualdad.  Sin embargo, es mejor evitar el problema con el analizador si la estructura "inapropiada" se almacena en un conjunto hash o en una tabla hash. </li></ul><br><h2>  Recursos Adicionales </h2><br><ul><li>  <a href="">ErrorProne.NET en github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de ErrorProne.NET en la tienda</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418515/">https://habr.com/ru/post/es418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418503/index.html">Despu茅s de 2020, el Reino Unido adquirir谩 el primer puerto espacial, en Escocia</a></li>
<li><a href="../es418505/index.html">Descripci贸n general y comparaci贸n de las plataformas de software Quantum de nivel de puerta</a></li>
<li><a href="../es418507/index.html">驴Qu茅 nos dio la cosmonautica?</a></li>
<li><a href="../es418509/index.html">Amazon Rekognition reconoce a 28 congresistas estadounidenses como criminales</a></li>
<li><a href="../es418513/index.html">C贸mo escribir solo un buen c贸digo</a></li>
<li><a href="../es418517/index.html">Cobertura del c贸digo: c贸mo mejorar la calidad de las pruebas</a></li>
<li><a href="../es418519/index.html">驴Qu茅 se puede encontrar en el c贸digo de otra persona? Una selecci贸n de materiales 煤tiles para .NET</a></li>
<li><a href="../es418521/index.html">El velo del secreto sobre el lanzamiento desde Alaska</a></li>
<li><a href="../es418523/index.html">驴Por qu茅 los minoristas escuchan a escondidas a sus empleados y por qu茅 todav铆a usan la tecnolog铆a de audio?</a></li>
<li><a href="../es418525/index.html">Opera se hizo p煤blica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>