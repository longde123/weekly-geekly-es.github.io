<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏽 🔸 ♉️ Reemplazar Equals y GetHashCode. ¿Pero es necesario? 🛌🏽 💫 ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si está familiarizado con C #, lo más probable es que sepa que siempre debe anular Equals , así como GetHashCode , para evitar la GetHashCode rendimie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reemplazar Equals y GetHashCode. ¿Pero es necesario?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Si está familiarizado con C #, lo más probable es que sepa que siempre debe anular <code>Equals</code> , así como <code>GetHashCode</code> , para evitar la <code>GetHashCode</code> rendimiento.  Pero, ¿qué pasará si esto no se hace?  Hoy, comparamos el rendimiento con dos opciones de ajuste y consideramos herramientas para ayudar a evitar errores. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  ¿Qué tan serio es este problema? </h2><br>  No todos los posibles problemas de rendimiento afectan el tiempo de ejecución de la aplicación.  El método <code>Enum.HasFlag</code> no <code>Enum.HasFlag</code> muy eficiente (*), pero si no lo utiliza en un código de uso intensivo de recursos, no habrá problemas serios en el proyecto.  Este también es el caso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las copias protegidas</a> creadas por tipos de estructura no solo de lectura en el contexto de solo lectura.  El problema existe, pero es poco probable que se note en aplicaciones ordinarias. <br><br>  <i>(*) Se corrigió en .NET Core 2.1 y, como mencioné <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en una publicación anterior</a> , ahora las consecuencias pueden mitigarse utilizando el HasFlag autoconfigurado para versiones anteriores.</i> <br><br>  Pero el problema del que hablaremos hoy es especial.  Si los métodos <code>Equals</code> y <code>GetHashCode</code> no se crean en la estructura, <code>System.ValueType</code> sus versiones estándar de <code>System.ValueType</code> .  Y pueden reducir significativamente el rendimiento de la aplicación final. <br><br><h2>  ¿Por qué las versiones estándar son lentas? </h2><br>  Los autores de CLR hicieron todo lo posible para que las versiones estándar de Equals y GetHashCode fueran lo más eficientes posible para los tipos de valor.  Pero hay varias razones por las cuales estos métodos pierden en la efectividad de la versión del usuario, escrita para cierto tipo manualmente (o generada por el compilador). <br><br>  1. Distribución de la conversión de envases.  El CLR está diseñado de tal manera que cada llamada a un elemento definido en los tipos <code>System.ValueType</code> o <code>System.Enum</code> desencadena una transformación de <code>System.ValueType</code> (**). <br><br>  <i>(**) Si el método no admite la compilación JIT.</i>  <i>Por ejemplo, en Core CLR 2.1, el compilador JIT reconoce el método <code>Enum.HasFlag</code> y genera un código adecuado que no comienza a ajustarse.</i> <br><br>  2. Posibles conflictos en la versión estándar del método <code>GetHashCode</code> .  Cuando implementamos una función hash, nos enfrentamos a un dilema: hacer que la distribución de la función hash sea buena o rápida.  En algunos casos, puede hacer ambas cosas, pero en el tipo <code>ValueType.GetHashCode</code> , esto suele ser difícil. <br><br>  Una función hash tradicional de tipo struct "combina" los códigos hash de todos los campos.  Pero la única forma de obtener el código hash de campo en el método <code>ValueType</code> es usar la reflexión.  Es por eso que los autores de CLR decidieron sacrificar la velocidad por el bien de la distribución, y la versión estándar de <code>GetHashCode</code> solo devuelve el código hash del primer campo distinto de cero y lo <a href="">"estropea" con un identificador de tipo</a> (***) (para más detalles, consulte <code>RegularGetValueTypeHashCode</code> en coreclr repo en github). <br><br>  <i>(***) A juzgar por los comentarios en el repositorio de CoreCLR, la situación puede cambiar en el futuro.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Este es un algoritmo razonable hasta que algo sale mal.  Pero si no tiene suerte y el valor del primer campo de su tipo de estructura es el mismo en la mayoría de los casos, entonces la función hash siempre producirá el mismo resultado.  Como habrás adivinado, si guardas estas instancias en un conjunto de hash o una tabla de hash, entonces el rendimiento caerá en picado. <br><br>  3. La velocidad de implementación basada en la reflexión es baja.  Muy bajo  La reflexión es una herramienta poderosa si se usa correctamente.  Pero las consecuencias serán terribles si lo ejecuta en un código de uso intensivo de recursos. <br><br>  Veamos cómo una función hash fallida, que puede resultar de (2) y la implementación basada en la reflexión, afecta el rendimiento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Si el valor del primer campo es siempre el mismo, de manera predeterminada la función hash devuelve un valor igual para todos los elementos y el conjunto hash se convierte efectivamente en una lista vinculada con operaciones de inserción y búsqueda O (N).  El número de operaciones para llenar la colección se convierte en O (N ^ 2) (donde N es el número de insertos con complejidad O (N) para cada inserto).  Esto significa que insertar en un conjunto de 1000 elementos producirá casi 500,000 llamadas a <code>ValueType.Equals</code> .  ¡Aquí están las consecuencias de un método que usa la reflexión! <br><br>  Como muestra la prueba, el rendimiento será aceptable si tiene suerte y el primer elemento de la estructura es único (en el caso de <code>Position_Path_DefaultEquality</code> ).  Pero si esto no es así, entonces la productividad será extremadamente baja. <br><br><h2>  Problema real </h2><br>  Creo que ahora puedes adivinar qué problema encontré recientemente.  Hace un par de semanas recibí un mensaje de error: el tiempo de ejecución de la aplicación en la que estoy trabajando aumentó de 10 a 60 segundos.  Afortunadamente, el informe fue muy detallado y contenía un rastro de eventos de Windows, por lo que el punto del problema se descubrió rápidamente: <code>ValueType.Equals</code> cargó 50 segundos. <br><br>  Después de un rápido vistazo al código, quedó claro cuál era el problema: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  Usé una tupla que contenía un tipo de estructura personalizada con la versión estándar de <code>Equals</code> .  Y desafortunadamente, tenía un primer campo opcional, que casi siempre equivalía a <code>String.equals</code> .  La productividad se mantuvo alta hasta que el número de elementos en el conjunto aumentó significativamente.  En cuestión de minutos, se inicializó una colección con decenas de miles de elementos. <br><br><h2>  ¿La <code>ValueType.Equals/GetHashCode</code> predeterminada de <code>ValueType.Equals/GetHashCode</code> siempre se ejecuta lentamente? </h2><br>  Tanto <code>ValueType.Equals</code> como <code>ValueType.GetHashCode</code> tienen métodos de optimización especiales.  Si el tipo no tiene "punteros" y está correctamente empaquetado (mostraré un ejemplo en un minuto), entonces se usan versiones optimizadas: las iteraciones <code>GetHashCode</code> se realizan en bloques de instancias, se usa XOR de 4 bytes, el método <code>Equals</code> compara dos instancias usando <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  La comprobación en sí se realiza en <code>ValueTypeHelper::CanCompareBits</code> , se llama tanto por la iteración de <code>ValueType.Equals</code> como por la iteración de <code>ValueType.GetHashCode</code> . <br><br>  Pero la optimización es una cosa muy insidiosa. <br><br>  En primer lugar, es difícil de entender cuando está encendido;  Incluso pequeños cambios en el código pueden activarlo y desactivarlo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Para obtener más información sobre la estructura de la memoria, consulte mi blog, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Elementos internos de un objeto administrado, Parte 4. Estructura del campo"</a> . <br><br>  En segundo lugar, comparar la memoria no necesariamente te da el resultado correcto.  Aquí hay un ejemplo simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> y <code>+0,0</code> son iguales, pero tienen diferentes representaciones binarias.  Esto significa que <code>Double.Equals</code> es verdadero y <code>MyDouble.Equals</code> es falso.  En la mayoría de los casos, la diferencia no es significativa, pero imagine cuántas horas pasará solucionando el problema causado por esta diferencia. <br><br><h2>  ¿Cómo evitar un problema similar? </h2><br>  ¿Puedes preguntarme cómo puede suceder lo anterior en una situación real?  Una forma obvia de ejecutar los métodos <code>Equals</code> y <code>GetHashCode</code> en los tipos de estructura es usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regla</a> FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CA1815</a> .  Pero hay un problema: este es un enfoque demasiado estricto. <br><br>  Una aplicación para la que el rendimiento es crítico puede tener cientos de tipos de estructura que no se usan necesariamente en conjuntos hash o diccionarios.  Por lo tanto, los desarrolladores de aplicaciones pueden deshabilitar la regla, lo que causará consecuencias desagradables si el tipo de estructura utiliza funciones modificadas. <br><br>  Un enfoque más correcto es advertir al desarrollador si la estructura de tipo "inapropiada" con los mismos valores predeterminados de elementos (definidos en la aplicación o una biblioteca de terceros) se almacena en un conjunto hash.  Por supuesto, estoy hablando de <a href="">ErrorProne.NET</a> y la regla que agregué allí tan pronto como me encontré con este problema: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  La versión ErrorProne.NET no es perfecta y "culpará" al código correcto si se utiliza un solucionador de igualdad personalizado en el constructor: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Pero sigo pensando que vale la pena advertir si una estructura con elementos iguales por defecto no se usa cuando se está produciendo.  Por ejemplo, cuando revisé mi regla, me di cuenta de que la estructura <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> definida en mscorlib no sobrescribe <code>Equals</code> y <code>GetHashCode</code> .  Es poco probable que alguien defina una variable como <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> hoy, pero creo que incluso BCL puede romper la regla.  Por lo tanto, es útil descubrir esto antes de que sea demasiado tarde. <br><br><h2>  Conclusión </h2><br><ul><li>  La implementación de la igualdad predeterminada para los tipos de estructura puede tener serias consecuencias para su aplicación.  Este es un problema real, no teórico. </li><li>  Los elementos de igualdad predeterminados para los tipos de valor se basan en la reflexión. </li><li>  La distribución realizada por la versión estándar de <code>GetHashCode</code> será muy mala si el primer campo de muchas instancias tiene el mismo valor. </li><li>  Existen versiones optimizadas para los métodos estándar <code>Equals</code> y <code>GetHashCode</code> , pero no debe confiar en ellos porque incluso un pequeño cambio de código puede desactivarlos. </li><li>  Use la regla FxCop para asegurarse de que cada tipo de estructura anula los elementos de igualdad.  Sin embargo, es mejor evitar el problema con el analizador si la estructura "inapropiada" se almacena en un conjunto hash o en una tabla hash. </li></ul><br><h2>  Recursos Adicionales </h2><br><ul><li>  <a href="">ErrorProne.NET en github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de ErrorProne.NET en la tienda</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418515/">https://habr.com/ru/post/es418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418503/index.html">Después de 2020, el Reino Unido adquirirá el primer puerto espacial, en Escocia</a></li>
<li><a href="../es418505/index.html">Descripción general y comparación de las plataformas de software Quantum de nivel de puerta</a></li>
<li><a href="../es418507/index.html">¿Qué nos dio la cosmonautica?</a></li>
<li><a href="../es418509/index.html">Amazon Rekognition reconoce a 28 congresistas estadounidenses como criminales</a></li>
<li><a href="../es418513/index.html">Cómo escribir solo un buen código</a></li>
<li><a href="../es418517/index.html">Cobertura del código: cómo mejorar la calidad de las pruebas</a></li>
<li><a href="../es418519/index.html">¿Qué se puede encontrar en el código de otra persona? Una selección de materiales útiles para .NET</a></li>
<li><a href="../es418521/index.html">El velo del secreto sobre el lanzamiento desde Alaska</a></li>
<li><a href="../es418523/index.html">¿Por qué los minoristas escuchan a escondidas a sus empleados y por qué todavía usan la tecnología de audio?</a></li>
<li><a href="../es418525/index.html">Opera se hizo pública</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>