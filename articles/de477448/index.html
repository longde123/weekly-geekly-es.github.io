<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 ✳️ 🐡 Programmiertheorie: Variante 🌙 📕 🉐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Dmitry Karlovsky und ich ... ich möchte Ihnen etwas über die grundlegenden Merkmale von Typsystemen erzählen, die durch das Prism...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmiertheorie: Variante</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477448/"><p> Hallo, mein Name ist Dmitry Karlovsky und ich ... ich möchte Ihnen etwas über die grundlegenden Merkmale von Typsystemen erzählen, die durch das Prisma der Implementierung einer bestimmten Sprache, die aufgrund der evolutionären Entwicklung viele Atavismen aufweist, häufig oder nicht oder nicht richtig verstanden werden.  Versuchen Sie daher, die Probleme mit einem neuen Blick zu betrachten, auch wenn Sie glauben, zu wissen, was „Variation“ ist.  Wir werden von den Grundlagen ausgehen, sodass auch Anfänger alles verstehen.  Und wir machen ohne Wasser weiter, so dass auch die Profis nützlich sind, um ihr Wissen zu strukturieren.  Codebeispiele werden in einer Pseudosprache ähnlich wie TypeScript vorliegen.  Anschließend werden die Ansätze mehrerer realer Sprachen untersucht.  Und wenn Sie Ihre eigene Sprache entwickeln, hilft Ihnen dieser Artikel dabei, nicht auf den Rechen eines anderen zu treten. </p><br><p><img src="https://habrastorage.org/webt/uz/yw/ly/uzywlybdb47qium0-khvukslzwc.png" alt="Was ist, wenn es Füchse gibt?"></p><a name="habracut"></a><br><h1 id="argumenty-i-parametry">  Argumente und Parameter </h1><br><p>  <strong>Der Parameter</strong> ist das, was wir akzeptieren.  Bei der Beschreibung des Parametertyps legen wir eine Einschränkung für die Typen fest, die an uns übergeben werden können.  Einige Beispiele: </p><br><pre><code class="plaintext hljs">//   function log( id : string | number ) {} //   class Logger { constructor( readonly id : Natural ) {} } //   class Node&lt; Id extends Number &gt; { id : Id }</code> </pre> <br><p>  <strong>Ein Argument</strong> ist das, was wir weitergeben.  Zum Zeitpunkt der Übertragung hat das Argument immer einen bestimmten Typ.  Bei der statischen Analyse ist ein bestimmter Typ möglicherweise nicht bekannt, weshalb der Compiler wieder mit Typeinschränkungen arbeitet.  Einige Beispiele: </p><br><pre> <code class="plaintext hljs">log( 123 ) //   new Logger( promptStringOrNumber( 'Enter id' ) ) //       new Node( 'root' ) //   ,  </code> </pre> <br><h1 id="podtipy">  Untertypen </h1><br><p>  Typen können eine Hierarchie bilden.  <em>Ein Subtyp</em> ist ein Sonderfall eines <em>Supertyps</em> .  Ein Subtyp kann gebildet werden, indem <strong>die</strong> Menge der möglichen Werte eines Supertyps eingegrenzt wird.  Beispielsweise ist der Typ Natural ein Subtyp von Integer und Positive.  Und alle drei sind gleichzeitig Untertypen von Real.  Und der Prime-Typ ist ein Subtyp von allen oben genannten.  Gleichzeitig überlappen sich die Typen Positive und Integer, aber keiner von ihnen schränkt den anderen ein. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ca8/220/c10/ca8220c10205146b59dc7f9b4a479c4b.png" alt="Bild"></p><br><p>  Eine andere Möglichkeit, einen Untertyp zu bilden, besteht <strong>darin,</strong> ihn <strong>zu erweitern</strong> , indem Sie ihn mit einem anderen orthogonal dazu stehenden Typ kombinieren.  Beispielsweise gibt es eine „Farbfigur“ mit der Eigenschaft „Farbe“ und ein „Quadrat“ mit der Eigenschaft „Höhe“.  Durch die Kombination dieser Typen erhalten wir ein "Farbquadrat".  Wenn wir einen "Kreis" mit seinem "Radius" hinzufügen, erhalten wir einen "Farbzylinder". </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/484/181/21d/48418121d846dc7aa19d4cd7472638c6.png" alt="Bild"></p><br><h1 id="ierarhii">  Hierarchien </h1><br><p>  Für die weitere Darstellung benötigen wir eine kleine Hierarchie von Tieren und eine ähnliche Hierarchie von Zellen. </p><br><pre> <code class="plaintext hljs">abstract class Animal {} abstract class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p>  Alles unten ist eine Verengung wie oben.  Ein Käfig mit einem Haustier kann nur Haustiere enthalten, jedoch keine Wildtiere.  Ein Käfig mit einem Hund kann nur Hunde enthalten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/397/a01/046/397a01046371d0316d2231db9771de24.png" alt="Bild"></p><br><h1 id="kovariantnost">  Kovarianz </h1><br><p>  Das einfachste und verständlichste ist die <strong>Einschränkung eines Supertyps</strong> oder einer Kovarianz.  Im folgenden Beispiel ist der Funktionsparameter kovariant zu dem für ihn angegebenen Typ.  Das heißt, die Funktion kann sowohl diesen Typ selbst als auch einen beliebigen Subtyp davon akzeptieren, jedoch keine Supertypen oder andere Typen. </p><br><pre> <code class="plaintext hljs">function touchPet( cage : PetCage ) : void { log( `touch ${cage.content}` ) } touchPet( new AnimalCage ) // forbid touchPet( new PetCage ) // allow touchPet( new CatCage ) // allow touchPet( new DogCage ) // allow touchPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/a68/94b/667/a6894b667d46336844466ff63a972011.png" alt="Bild"></p><br><p>  Da wir im Käfig nichts verändern, können wir mit der Katze sicher Funktionen auf den Käfig übertragen, da es sich nur um einen Sonderfall des Käfigs mit einem Haustier handelt. </p><br><h1 id="kontravariantnost">  Zuwiderhandlung </h1><br><p>  Etwas schwieriger ist es, die <strong>Einschränkung</strong> oder Kontravarianz von <strong>Subtypen</strong> zu verstehen.  Im folgenden Beispiel steht der Funktionsparameter im Widerspruch zu dem dafür angegebenen Typ.  Das heißt, die Funktion kann sowohl diesen Typ selbst als auch einen ihrer Supertypen akzeptieren, jedoch keine Subtypen oder anderen Typen. </p><br><pre> <code class="plaintext hljs">function pushPet( cage : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new AnimalCage ) // allow pushPet( new PetCage ) // allow pushPet( new CatCage ) // forbid pushPet( new DogCage ) // forbid pushPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9b/a03/b2d/e9ba03b2d3e4f0b82a6f3d9a4f85c05f.png" alt="Bild"></p><br><p>  Wir können den Käfig nicht mit der Katze passieren, da die Funktion den Hund dorthin bringen kann, was nicht zulässig ist.  Der Käfig kann aber mit jedem Tier sicher überführt werden, da sowohl die Katze als auch der Hund dort untergebracht werden können. </p><br><h1 id="invariantnost">  Invarianz </h1><br><p>  <strong>Subtyp und Supertyp</strong> können gleichzeitig begrenzt werden.  Ein solcher Fall heißt Invarianz.  Im folgenden Beispiel ist der Funktionsparameter für den dafür angegebenen Typ unveränderlich.  Das heißt, die Funktion kann nur den angegebenen Typ akzeptieren und nicht mehr. </p><br><pre> <code class="plaintext hljs">function replacePet( cage : PetCage ) : void { touchPet( cage ) pushPet( cage ) } replacePet( new AnimalCage ) // forbid replacePet( new PetCage ) // allow replacePet( new CatCage ) // forbid replacePet( new DogCage ) // forbid replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/3c3/bec/d6d/3c3becd6de5faa045963dc7c45774d19.png" alt="Bild"></p><br><p>  Die Funktion <code>replacePet</code> erbt die Einschränkungen der intern verwendeten Funktionen: Sie hat die Einschränkung des Typs von <code>pushPet</code> und die Einschränkung des Subtyps von <code>pushPet</code> .  Wenn wir ihr mit einem Tier einen Käfig geben, kann sie ihn nicht auf die touchPet-Funktion übertragen, die nicht weiß, wie man mit Füchsen arbeitet (ein wildes Tier beißt einfach einen Finger ab).  Und wenn wir den Käfig mit der Katze übertragen, funktioniert es nicht, <code>pushPet</code> . </p><br><h1 id="bivariantnost">  Bivarianz </h1><br><p>  Man kann nur die exotische <strong>Abwesenheit von Beschränkungen</strong> erwähnen - Bivarianz.  Im folgenden Beispiel kann eine Funktion jeden Typ akzeptieren, der ein Subtyp oder ein Subtyp ist. </p><br><pre> <code class="plaintext hljs">function enshurePet( cage : PetCage ) : void { if( cage.content instanceof Pet ) return pushPet( cage ) } replacePet( new AnimalCage ) // allow replacePet( new PetCage ) // allow replacePet( new CatCage ) // allow replacePet( new DogCage ) // allow replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b8/b85/66f/8b8b8566f8c6db9cd3959f1152202957.png" alt="Bild"></p><br><p>  Darin können Sie den Käfig mit dem Tier übertragen.  Dann prüft sie, ob sich ein Haustier im Käfig befindet, andernfalls steckt sie es in ein zufälliges Haustier.  Und Sie können zum Beispiel einen Käfig mit einer Katze übertragen, dann wird sie einfach nichts tun. </p><br><h1 id="obobscheniya">  Verallgemeinerungen </h1><br><p>  Einige glauben, dass Varianz irgendwie mit Verallgemeinerungen zusammenhängt.  Oft, weil Abweichungen häufig am Beispiel von generischen Containern erklärt werden.  In der ganzen Geschichte haben wir jedoch noch keine einzige Verallgemeinerung gehabt - es sind ganz konkrete Klassen: </p><br><pre> <code class="plaintext hljs">class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p>  Dies wurde gemacht, um zu zeigen, dass die Varianzprobleme nicht mit Verallgemeinerungen zusammenhängen.  Verallgemeinerungen sind nur erforderlich, um das Kopieren und Einfügen zu reduzieren.  Zum Beispiel kann der obige Code durch eine einfache Verallgemeinerung umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">class Cage&lt;Animal&gt; { content : Animal }</code> </pre> <br><p>  Und jetzt können Sie Instanzen beliebiger Zellen erstellen: </p><br><pre> <code class="plaintext hljs">const animalCage = new Cage&lt;Animal&gt;() const petCage = new Cage&lt;Pet&gt;() const catCage = new Cage&lt;Cat&gt;() const dogCage = new Cage&lt;Dog&gt;() const foxCage = new Cage&lt;Fox&gt;()</code> </pre> <br><h1 id="deklaraciya-ogranicheniy">  Verjährungserklärung </h1><br><p>  Bitte beachten Sie, dass die Signaturen aller vier zuvor aufgelisteten Funktionen genau gleich sind: </p><br><pre> <code class="plaintext hljs">( cage : PetCage )=&gt; void</code> </pre> <br><p>  Das heißt, eine solche Beschreibung der akzeptierten Parameter der Funktion ist nicht vollständig - daraus kann nicht abgeleitet werden, dass sie auf die Funktion übertragen werden kann.  Nun, es sei denn, es ist deutlich zu sehen, dass es sich definitiv nicht lohnt, den Käfig mit dem Fuchs hinein zu führen. </p><br><p>  Daher gibt es in modernen Sprachen ein Mittel, um explizit anzugeben, welche Typeinschränkungen ein Parameter hat.  Zum Beispiel die <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-generic-modifier">in</a> und <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-generic-modifier">out</a> Modifikatoren <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-generic-modifier">in</a> C #: </p><br><pre> <code class="plaintext hljs">interface ICageIn&lt;in T&gt; { T content { set; } } // contravariant generic parameter interface ICageOut&lt;out T&gt; { T content { get; } } // covariant generic parameter interface ICageInOut&lt;T&gt; { T content { get; set; } } // invariant generic parameter</code> </pre> <br><p>  Leider ist es in C # für jede Variante von Modifikatoren erforderlich, auf einer separaten Schnittstelle zu starten.  Soweit ich weiß, ist die Bivarianz in C # im Allgemeinen unaussprechlich. </p><br><h1 id="vyhodnye-parametry">  Ausgabeparameter </h1><br><p>  Funktionen können nicht nur Werte akzeptieren, sondern auch zurückgeben.  Im Allgemeinen darf der Rückgabewert nicht eins sein.  Nehmen Sie zum Beispiel die Funktion, einen Käfig mit einem Haustier zu nehmen und zwei Haustiere zurückzugeben. </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage ) : [ Pet , Pet ] { return [ input.content , new Cat ] }</code> </pre> <br><p>  Eine solche Funktion entspricht einer Funktion, die zusätzlich zu einem Eingangsparameter zwei weitere Ausgänge erhält. </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage , output1 : PetCage , output2 : PetCage ) : void { output1.content = input.content output2.content = new Cat }</code> </pre> <br><p>  Externer Code reserviert zusätzlichen Speicher auf dem Stapel, sodass die Funktion alles ablegt, was sie zurückgeben möchte.  Nach Fertigstellung kann der aufrufende Code diese Container bereits für eigene Zwecke verwenden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2c3/292/0b5/2c32920b5a5aeb4ed22923ac97de9267.png" alt="Bild"></p><br><p>  Aus der Äquivalenz dieser beiden Funktionen folgt, dass die von der Funktion zurückgegebenen Werte im Gegensatz zu den Parametern immer dem angegebenen Ausgabetyp widersprechen.  Denn eine Funktion kann in sie schreiben, aber nicht aus ihnen lesen. </p><br><h1 id="metody-obektov">  Objektmethoden </h1><br><p>  Objektmethoden sind Funktionen, die einen zusätzlichen Zeiger auf ein Objekt als impliziten Parameter verwenden.  Das heißt, die folgenden zwei Funktionen sind äquivalent. </p><br><pre> <code class="plaintext hljs">class PetCage { pushPet() : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet } }</code> </pre> <br><pre> <code class="plaintext hljs">function pushPet( this : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet }</code> </pre> <br><p>  Es ist jedoch wichtig zu beachten, dass eine Methode im Gegensatz zu einer regulären Funktion auch Mitglied der Klasse ist, die eine Erweiterung des Typs darstellt.  Dies führt dazu, dass für Funktionen, die diese Methode aufrufen, eine zusätzliche Supertypeinschränkung angezeigt wird: </p><br><pre> <code class="plaintext hljs">function fillPetCage( cage : PetCage ) { cage.pushPet() }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/44e/f44/c67/44ef44c670ebef55ab1d8f248da44b11.png" alt="Bild"></p><br><p>  Wir können einen solchen <code>pushPet</code> nicht übergeben, wenn die <code>pushPet</code> Methode noch nicht definiert ist.  Dies ist ähnlich wie bei der Invarianz, da sowohl von unten als auch von oben eine Einschränkung vorliegt.  Die Position der <code>pushPet</code> Methode kann jedoch hierarchisch höher sein.  Und hier wird die Überschreibbegrenzung sein. </p><br><h1 id="princip-podstanovki--barbary-liskov-lsp">  Barbara-Lisk-Substitutionsprinzip (LSP) </h1><br><p>  Viele Leute denken, dass das Verhältnis eines Untertyps zu einem Untertyp nicht auf der Grundlage der zuvor erwähnten Methoden zum Eingrenzen und Erweitern des Typs bestimmt wird, sondern vielmehr durch die Möglichkeit, den Untertyp an jedem Ort zu ersetzen, an dem der Supertyp verwendet wird.  Anscheinend liegt der Grund für diesen Fehler genau im LSP.  Lesen wir jedoch die Definition dieses Prinzips sorgfältig durch und achten Sie darauf, was primär und was sekundär ist: </p><br><blockquote>  Funktionen, die den Basistyp verwenden, sollten in der Lage sein, Untertypen des Basistyps zu verwenden, ohne es zu wissen und ohne die Korrektheit des Programms zu verletzen. </blockquote><p>  Bei unveränderlichen Objekten (einschließlich Objekten, die nicht auf veränderbare Objekte verweisen) wird dieses Prinzip automatisch ausgeführt, da es keinen Platz gibt, von dem die Subtypeinschränkung abgeleitet werden kann. </p><br><p>  Bei Mutables wird es immer schwieriger, da sich die folgenden beiden Situationen für das LSP-Prinzip gegenseitig ausschließen: </p><br><ol><li>  Klasse <code>A</code> hat eine Unterklasse von <code>B</code> , wobei das Feld <code>B::foo</code> ein Subtyp von <code>A::foo</code> . </li><li>  Klasse <code>A</code> hat eine Methode, die das <code>A::foo</code> Feld ändern kann. </li></ol><br><p>  Dementsprechend gibt es nur noch drei Möglichkeiten: </p><br><ol><li>  Verhindern Sie, dass Objekte ihre Feldtypen einschränken.  Aber dann können Sie einen Elefanten für eine Katze in den Käfig schieben. </li><li>  Geleitet nicht von LSP, sondern von der Variabilität jedes Parameters jeder Funktion separat.  Aber dann muss man viel nachdenken und dem Compiler erklären, wo die Typeinschränkungen liegen. </li><li>  Auf alles spucken und los geht's <del>  das Kloster </del>  funktionale Programmierung, bei der alle Objekte unveränderlich sind, was bedeutet, dass ihre akzeptierten Parameter kovariant zum deklarierten Typ sind. </li></ol><br><h1 id="typescript">  TypeScript </h1><br><p>  Im Zeitskript ist die Logik einfach: Alle Parameter der Funktion werden als kovariant (was nicht wahr ist) und die Rückgabewerte als kontravariant (was wahr ist) betrachtet.  Es wurde zuvor gezeigt, dass die Parameter einer Funktion absolut beliebig variieren können, je nachdem, was diese Funktion mit diesen Parametern macht.  Daher sind dies die folgenden Vorfälle: </p><br><pre> <code class="plaintext hljs">abstract class Animal { is! : 'cat' | 'dog' | 'fox' } abstract class Pet extends Animal { is! : 'cat' | 'dog' } class Cat extends Pet { is! : 'cat' } class Dog extends Pet { is! : 'dog' } class Fox extends Animal { is! : 'fox' } class Cage&lt;Animal&gt; { content! : Animal } function pushPet( cage : Cage&lt;Pet&gt; ) : void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // forbid to push Pet to Animal Cage :-( pushPet( new Cage&lt;Cat&gt;() ) // allow to push Dog to Cat Cage :-(</code> </pre> <br><p>  Um dieses Problem zu lösen, müssen Sie dem Compiler mit nicht trivialem Code helfen: </p><br><pre> <code class="plaintext hljs">function pushPet&lt; PetCage extends Cage&lt;Animal&gt; &gt;( cage: Cage&lt;Pet&gt; extends PetCage ? PetCage : never ): void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // allow :-) pushPet( new Cage&lt;Pet&gt;() ) // allow :-) pushPet( new Cage&lt;Cat&gt;() ) // forbid :-) pushPet( new Cage&lt;Dog&gt;() ) // forbid :-) pushPet( new Cage&lt;Fox&gt;() ) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uesu87y"><strong>Versuchen Sie es online</strong></a> </p><br><h1 id="flowjs">  Flowjs </h1><br><p>  FlowJS verfügt über ein fortschrittlicheres Typensystem.  Insbesondere kann in der <a href="https://flow.org/en/docs/types/generics/">Typbeschreibung die Variabilität</a> für verallgemeinerte Parameter und für Objektfelder angegeben werden.  In unserem Zellenbeispiel sieht es ungefähr so ​​aus: </p><br><pre> <code class="plaintext hljs">class Animal {} class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class Cage&lt; Animal &gt; { content : Animal } function touchPet( cage : { +content : Pet } ) : void { console.log( `touch ${typeof cage.content}` ) } function pushPet( cage: { -content: Pet } ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet } function replacePet( cage : { content : Pet } ) : void { touchPet( cage ) pushPet( cage ) } touchPet( new Cage&lt;Animal&gt; ) // forbid :-) touchPet( new Cage&lt;Pet&gt; ) // allow :-) touchPet( new Cage&lt;Cat&gt; ) // allow :-) touchPet( new Cage&lt;Dog&gt; ) // allow :-) touchPet( new Cage&lt;Fox&gt; ) // forbid :-) pushPet( new Cage&lt;Animal&gt; ) // allow :-) pushPet( new Cage&lt;Pet&gt; ) // allow :-) pushPet( new Cage&lt;Cat&gt; ) // forbid :-) pushPet( new Cage&lt;Dog&gt; ) // forbid :-) pushPet( new Cage&lt;Fox&gt; ) // forbid :-) replacePet( new Cage&lt;Animal&gt; ) // forbid :-) replacePet( new Cage&lt;Pet&gt; ) // allow :-) replacePet( new Cage&lt;Cat&gt; ) // forbid :-) replacePet( new Cage&lt;Dog&gt; ) // forbid :-) replacePet( new Cage&lt;Fox&gt;) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uak4hne"><strong>Versuchen Sie es online</strong></a> </p><br><p>  Bivarianz ist hier unbeschreiblich.  Leider konnte ich keine Möglichkeit finden, die Varianz bequemer einzustellen, ohne die Typen aller Felder explizit zu beschreiben.  Zum Beispiel so etwas: </p><br><pre> <code class="plaintext hljs">function pushPet( cage: Contra&lt; Cage&lt;Pet&gt; , 'content' &gt; ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet }</code> </pre> <br><h1 id="c-sharp">  Cis </h1><br><p>  C # wurde ursprünglich ohne Verständnis von Variationen entwickelt.  Später wurden jedoch Out- und Parameter-Modifikatoren hinzugefügt, die es dem Compiler ermöglichten, die übergebenen Argumenttypen korrekt zu überprüfen.  Leider ist die Verwendung dieser Modifikatoren wiederum nicht sehr praktisch. </p><br><pre> <code class="plaintext hljs">using System; abstract class Animal {} abstract class Pet : Animal {} class Cat : Pet {} class Dog : Pet {} class Fox : Animal {} interface ICageIn&lt;in T&gt; { T content { set; } } interface ICageOut&lt;out T&gt; { T content { get; } } interface ICageInOut&lt;T&gt; { T content { get; set; } } class Cage&lt;T&gt; : ICageIn&lt;T&gt;, ICageOut&lt;T&gt;, ICageInOut&lt;T&gt; { public T content { get; set; } } public class Program { static void touchPet( ICageOut&lt;Pet&gt; cage ) { Console.WriteLine( cage.content ); } static void pushPet( ICageIn&lt;Pet&gt; cage ) { cage.content = new Dog(); } static void replacePet( ICageInOut&lt;Pet&gt; cage ) { touchPet( cage as ICageOut&lt;Pet&gt; ); pushPet( cage as ICageIn&lt;Pet&gt; ); } void enshurePet( Cage&lt;Pet&gt; cage ) { if( cage.content is Pet ) return; pushPet( cage as ICageIn&lt;Pet&gt; ); } public static void Main() { var animalCage = new Cage&lt;Animal&gt;(); var petCage = new Cage&lt;Pet&gt;(); var catCage = new Cage&lt;Cat&gt;(); var dogCage = new Cage&lt;Dog&gt;(); var foxCage = new Cage&lt;Fox&gt;(); touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</code> </pre> <br><p>  <a href="https://dotnetfiddle.net/jAx53p"><strong>Versuchen Sie es online</strong></a> </p><br><h1 id="java">  Java </h1><br><p>  In Java wurde die Möglichkeit, Variationen umzuschalten, erst spät und nur für verallgemeinerte Parameter hinzugefügt, die selbst erst vor relativ kurzer Zeit erschienen.  Wenn der Parameter nicht verallgemeinert ist, treten Probleme auf. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T content; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? extends Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ System.out.println( cage.content ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enshurePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( cage.content <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Pet ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Cage&lt;Animal&gt; animalCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Animal&gt;(); Cage&lt;Pet&gt; petCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Pet&gt;(); Cage&lt;Cat&gt; catCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Cat&gt;(); Cage&lt;Dog&gt; dogCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Dog&gt;(); Cage&lt;Fox&gt; foxCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Fox&gt;(); touchPet( animalCage ); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</span></span></code> </pre> <br><p>  <a href="https://paiza.io/projects/pIBVVcjarSB0j0RJY8iNTw%3Flanguage%3Djava"><strong>Versuchen Sie es online</strong></a> </p><br><h1 id="c">  C ++ </h1><br><p>  C ++ kann dank seines leistungsstarken Template-Systems verschiedene Variationen ausdrücken, aber es gibt natürlich viel Code. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;typeinfo&gt; #include &lt;type_traits&gt; class Animal {}; class Pet: public Animal {}; class Cat: public Pet {}; class Dog: public Pet {}; class Fox: public Animal {}; template&lt;class T&gt; class Cage { public: T *content; }; template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;Pet, T&gt;::value&gt;&gt; void touchPet(const Cage&lt;T&gt; &amp;cage) { std::cout &lt;&lt; typeid(T).name(); } template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;T, Pet&gt;::value&gt;&gt; void pushPet(Cage&lt;T&gt; &amp;cage) { cage.content = new Dog(); } void replacePet(Cage&lt;Pet&gt; &amp;cage) { touchPet(cage); pushPet(cage); } int main(void) { Cage&lt;Animal&gt; animalCage {new Fox()}; Cage&lt;Pet&gt; petCage {new Cat()}; Cage&lt;Cat&gt; catCage {new Cat()}; Cage&lt;Dog&gt; dogCage {new Dog()}; Cage&lt;Fox&gt; foxCage {new Fox()}; touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="http://cpp.sh/8aqxm"><strong>Versuchen Sie es online</strong></a> </p><br><h1 id="d">  D </h1><br><p>  D hat keine vernünftigen Mittel, um Varianz explizit anzuzeigen, aber er weiß, wie man Typen basierend auf ihrer Verwendung ableitet. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.random; abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span>} abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> :</span></span> Animal { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> :</span></span> Animal {} <span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ T content; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ writeln( cage.content.name ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = ( uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog() : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Cage!Animal animalCage; Cage!Pet petCage; Cage!Cat catCage; Cage!Dog dogCage; Cage!Fox foxCage; animalCage.touchPet(); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) petCage.touchPet(); // allow :-) catCage.touchPet(); // allow :-) dogCage.touchPet(); // allow :-) foxCage.touchPet(); // forbid :-) animalCage.pushPet(); // allow :-) petCage.pushPet(); // allow :-) catCage.pushPet(); // forbid :-) dogCage.pushPet(); // forbid :-) foxCage.pushPet(); // forbid :-) animalCage.replacePet(); // forbid :-) petCage.replacePet(); // allow :-) catCage.replacePet(); // forbid :-) dogCage.replacePet(); // forbid :-) foxCage.replacePet(); // forbid :-) }</span></span></code> </pre> <br><p>  <a href="https://tinyurl.com/qwxwzqg"><strong>Versuchen Sie es online</strong></a> </p><br><h1 id="epilog">  Nachwort </h1><br><p>  Das ist alles für jetzt.  Ich hoffe, das vorgestellte Material hat Ihnen geholfen, die Einschränkungen für Typen und deren Implementierung in verschiedenen Sprachen besser zu verstehen.  Irgendwo besser, irgendwo schlechter, irgendwo auf keinen Fall, aber im Großen und Ganzen - so lala.  Vielleicht sind Sie es, der die Sprache entwickelt, in der all dies bequem und typsicher implementiert wird.  Nehmen Sie in der Zwischenzeit an unserem <a href="https://teleg.run/lang_idioms">Telegramm-Chat teil, in dem wir manchmal die theoretischen Konzepte von Programmiersprachen diskutieren</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477448/">https://habr.com/ru/post/de477448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477434/index.html">Servicegitter für Microservices. Teil II, die Grundlagen der Arbeit mit Istio</a></li>
<li><a href="../de477436/index.html">So schreiben Sie einen einfachen Client-Server-Rechner (JavaFX + EJB + WildFly)</a></li>
<li><a href="../de477438/index.html">Wie Sie die Kontrolle wiedererlangen und die Abhängigkeit von Smartphones und Benachrichtigungen verringern können</a></li>
<li><a href="../de477440/index.html">Flipper Zero - Tomagotchi Patsan Multitool für Pentester</a></li>
<li><a href="../de477442/index.html">56 Open-Source-Python-Projekte</a></li>
<li><a href="../de477450/index.html">9 Ansätze zur Erkennung von Anomalien</a></li>
<li><a href="../de477452/index.html">Die zweite Programmiermeisterschaft: Wir analysieren die Aufgaben der ML-Strecke</a></li>
<li><a href="../de477454/index.html">Konfigurationsdateien. Libconfig-Bibliothek und Definition nicht verwendeter Einstellungen</a></li>
<li><a href="../de477458/index.html">Vor- und Nachteile des IT-Lebens in Schottland</a></li>
<li><a href="../de477460/index.html">Ausgabe Nr. 26: IT-Schulungen - Aktuelle Fragen und Herausforderungen führender Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>