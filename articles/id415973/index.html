<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏾 💃🏻 🧓🏾 Bagaimana tidak memecah gugus Apache Ignite dari awal 🔖 🧛🏾 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Di bawah ini adalah transkrip dari video pidato di reli komunitas Apache Ignite di St. Petersburg pada 20 Juni. Anda dapat mengunduh slide di sini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana tidak memecah gugus Apache Ignite dari awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/415973/"><p>  Hai  Di bawah ini adalah transkrip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> pidato di reli komunitas Apache Ignite di St. Petersburg pada 20 Juni.  Anda dapat mengunduh slide di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zrMWgNyvQVI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ada seluruh kelas masalah yang dihadapi pengguna pemula.  Mereka baru saja mengunduh Apache Ignite, menjalankan dua, tiga, sepuluh kali pertama, dan mendatangi kami dengan pertanyaan yang diselesaikan dengan cara yang sama.  Oleh karena itu, saya mengusulkan untuk membuat daftar periksa yang akan menghemat banyak waktu dan saraf ketika Anda membuat aplikasi Apache Ignite pertama Anda.  Kami akan berbicara tentang persiapan peluncuran;  cara membuat cluster berkumpul;  cara memulai beberapa perhitungan di Compute Grid;  Cara menyiapkan model dan kode data sehingga Anda dapat menulis data Anda ke Ignite dan kemudian membacanya dengan sukses.  Dan yang paling penting: bagaimana tidak merusak apa pun dari awal. </p><a name="habracut"></a><br><h2>  Persiapan untuk peluncuran - konfigurasi logging </h2><br><p>  Kami membutuhkan log.  Jika Anda pernah mengajukan pertanyaan di mailing list Apache Ignite atau di StackOverflow, seperti "mengapa semuanya ditutup", kemungkinan besar hal pertama yang diminta untuk Anda kirim adalah semua log dari semua node. </p><br><p> Secara alami, Apache Ignite logging diaktifkan secara default.  Namun ada nuansa.  Pertama, Apache Ignite menulis sedikit di <code>stdout</code> .  Secara default, ini dimulai dalam apa yang disebut mode senyap.  Di <code>stdout</code> Anda hanya akan melihat kesalahan paling mengerikan, dan semua yang lain akan disimpan dalam file, jalur yang ditampilkan Apache Ignite di awal (secara default - <code>${IGNITE_HOME}/work/log</code> ).  Anda tidak menghapusnya dan menyimpan log lebih lama, ini bisa sangat berguna. </p><br><p>  <b><code>stdout</code> dinyalakan saat startup standar</b> </p><br><p><img src="https://habrastorage.org/webt/dg/wf/4r/dgwf4rf9on5vckayvxqzcbtr5tk.png"></p><br><p>  Untuk membuatnya lebih mudah untuk mencari tahu tentang masalah tanpa masuk ke file yang terpisah dan mengatur pemantauan terpisah untuk Apache Ignite, Anda dapat menjalankannya dalam mode-verbose dengan perintah </p><br><pre> <code class="bash hljs">ignite.sh -v</code> </pre> <br><p>  dan kemudian sistem akan mulai menulis tentang semua peristiwa di <code>stdout</code> bersama dengan sisa dari pendataan aplikasi. </p><br><p>  Periksa log!  Sangat sering di dalamnya Anda dapat menemukan solusi untuk masalah Anda.  Jika cluster telah runtuh, sangat sering di log Anda dapat melihat pesan seperti "Tambah batas waktu ini dan itu dalam konfigurasi ini dan itu.  Kami jatuh karena dia.  Dia terlalu kecil.  Jaringannya tidak cukup baik. " </p><br><h2>  Perakitan klaster </h2><br><h3>  Tamu tak diundang </h3><br><p>  Masalah pertama yang dihadapi banyak orang adalah tamu tak diundang di kluster Anda.  Atau Anda sendiri berubah menjadi tamu yang tidak diundang: mulailah sebuah cluster baru dan tiba-tiba Anda melihat bahwa dalam snapshot topologi pertama alih-alih satu node Anda memiliki dua server dari awal.  Bagaimana bisa begitu?  Anda hanya meluncurkan satu. </p><br><p>  <b>Pesan yang menunjukkan bahwa cluster memiliki dua node</b> </p><br><p><img src="https://habrastorage.org/webt/l9/fd/kd/l9fdkdt9vvoaryo1fk84agizhvi.png"></p><br><p>  Faktanya adalah bahwa secara default Apache Ignite menggunakan Multicast, dan saat startup itu akan mencari semua Apache Ignite lain yang berada di subnet yang sama, di grup Multicast yang sama.  Dan jika ya, itu akan mencoba untuk terhubung.  Dan jika koneksi gagal, itu tidak akan memulai sama sekali.  Oleh karena itu, di cluster di laptop pekerjaan saya, node tambahan dari cluster di laptop rekan secara teratur muncul secara teratur, yang tentu saja tidak terlalu nyaman. </p><br><p>  Bagaimana cara melindungi diri dari ini?  Cara termudah untuk mengkonfigurasi IP statis.  Alih-alih <code>TcpDiscoveryMulticastIpFinder</code> , yang digunakan secara default, ada <code>TcpDiscoveryVmIpFinder</code> .  Di sana, tuliskan semua IP dan port yang Anda hubungkan.  Ini jauh lebih nyaman dan akan melindungi Anda dari sejumlah besar masalah, terutama di lingkungan pengembangan dan pengujian. </p><br><h3>  Alamat terlalu banyak </h3><br><p>  Masalah selanjutnya.  Anda menonaktifkan Multicast, memulai cluster, dalam satu konfigurasi, Anda mengatur jumlah IP yang layak dari lingkungan yang berbeda.  Dan itu terjadi bahwa Anda meluncurkan simpul pertama dalam gugus baru selama 5-10 menit, meskipun semua yang berikutnya terhubung dengannya dalam 5-10 detik. </p><br><p>  Ambil daftar tiga alamat IP.  Untuk masing-masing, kami meresepkan kisaran 10 port.  Secara total, 30 alamat TCP diperoleh.  Karena Apache Ignite harus berusaha menyambung ke cluster yang ada sebelum membuat cluster baru, itu akan memeriksa setiap IP pada gilirannya.  Mungkin tidak ada salahnya pada laptop Anda, tetapi perlindungan pemindaian port sering kali termasuk dalam beberapa lingkungan berawan.  Artinya, ketika mengakses port pribadi pada beberapa alamat IP, Anda tidak akan menerima respons apa pun sampai batas waktu berlalu.  Secara default, ini adalah 10 detik.  Dan jika Anda memiliki 3 alamat dari 10 port, maka Anda mendapatkan 3 * 10 * 10 = 300 detik menunggu - 5 menit yang sama untuk terhubung. </p><br><p>  Solusinya jelas: jangan mendaftar port yang tidak perlu.  Jika Anda memiliki tiga IP, maka Anda benar-benar membutuhkan kisaran 10 port default.  Ini nyaman ketika Anda menguji sesuatu pada mesin lokal dan menjalankan 10 node.  Tetapi dalam sistem nyata, satu port biasanya cukup.  Atau nonaktifkan perlindungan terhadap pemindaian port pada jaringan internal, jika Anda memiliki kesempatan seperti itu. </p><br><p>  Masalah umum ketiga adalah IPv6.  Anda dapat melihat pesan kesalahan jaringan yang aneh: tidak bisa terhubung, tidak bisa mengirim pesan, simpul tersegmentasi.  Ini berarti bahwa Anda telah jatuh dari kluster.  Sangat sering, masalah seperti itu disebabkan oleh lingkungan campuran dari IPv4 dan IPv6.  Ini bukan untuk mengatakan bahwa Apache Ignite tidak mendukung IPv6, tetapi saat ini ada masalah tertentu. </p><br><p>  Solusi termudah adalah dengan memberikan opsi ke mesin Java </p><br><pre> <code class="hljs objectivec">-Djava.net.preferIPv4Stack=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Kemudian Java dan Apache Ignite tidak akan menggunakan IPv6.  Ini memecahkan bagian penting dari masalah dengan runtuh cluster. </p><br><h2>  Persiapan basis kode - kami membuat cerita bersambung dengan benar </h2><br><p>  Cluster telah berkumpul, perlu untuk memulai sesuatu di dalamnya.  Salah satu elemen terpenting dalam interaksi kode Anda dengan kode Apache Ignite adalah Marshaller, atau serialisasi.  Untuk menulis sesuatu ke memori, untuk kegigihan, untuk mengirim melalui jaringan, Apache Ignite terlebih dahulu membuat serial objek Anda.  Anda dapat melihat pesan yang dimulai dengan kata-kata: "tidak dapat ditulis dalam format biner" atau "tidak dapat diserialisasi menggunakan BinaryMarshaller".  Hanya akan ada satu peringatan seperti itu di log, tetapi terlihat.  Ini berarti Anda perlu sedikit mengubah kode Anda untuk berteman dengan Apache Ignite. </p><br><p>  Apache Ignite menggunakan tiga mekanisme untuk serialisasi: </p><br><ul><li>  <code>JdkMarshaller</code> - serialisasi Java biasa; </li><li>  <code>OptimizedMarshaller</code> - serialisasi Java sedikit dioptimalkan, tetapi mekanismenya sama; </li><li>  <code>BinaryMarshaller</code> adalah serialisasi yang ditulis khusus untuk Apache Ignite, digunakan di mana-mana di bawah kapnya.  Dia memiliki sejumlah keunggulan.  Di suatu tempat kita dapat menghindari serialisasi dan deserialisasi tambahan, dan di suatu tempat kita bahkan bisa mendapatkan objek non-deserialisasi di API, bekerja dengannya secara langsung dalam format biner, seperti dengan sesuatu seperti JSON. </li></ul><br><p>  <code>BinaryMarshaller</code> akan dapat membuat cerita bersambung dan <code>BinaryMarshaller</code> serialisasi POJO Anda yang tidak memiliki apa-apa selain bidang dan metode sederhana.  Tetapi jika Anda memiliki serialisasi khusus melalui <code>readObject()</code> dan <code>writeObject()</code> , jika Anda menggunakan <code>Externalizable</code> , maka <code>BinaryMarshaller</code> tidak akan mengatasinya.  Dia akan melihat bahwa objek Anda tidak dapat diserialisasi dengan rekaman bidang non-transient yang biasa dan akan menyerah - itu akan bergulir kembali ke <code>OptimizedMarshaller</code> . </p><br><p>  Untuk berteman dengan objek-objek tersebut dengan Apache Ignite, Anda perlu mengimplementasikan antarmuka <code>Binarylizable</code> .  Dia sangat sederhana. </p><br><p>  Misalnya, ada <code>TreeMap</code> standar dari Jawa.  Ini memiliki serialisasi khusus dan deserialisasi melalui objek membaca dan menulis.  Pertama menjelaskan beberapa bidang, dan kemudian menulis panjang dan data itu sendiri ke <code>OutputStream</code> . </p><br><p>  <b>Implementasi <code>TreeMap.writeObject()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> java.io.IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } }</span></span></code> </pre> <br><p>  <code>writeBinary()</code> dan <code>readBinary()</code> dari karya <code>Binarylizable</code> dengan cara yang persis sama: <code>BinaryTreeMap</code> membungkus dirinya dalam <code>TreeMap</code> biasa dan menulisnya ke <code>OutputStream</code> .  Metode ini mudah ditulis, dan akan sangat meningkatkan produktivitas. </p><br><p>  <b><code>BinaryTreeMap.writeBinary()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBinary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryWriter writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BinaryObjectException </span></span>{ BinaryRawWriter rewriter = writer. rewrite (); rawWriter.writeObject(map.comparator()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = map.size(); rawWriter.writeInt(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;Object, Object&gt; entry : ((TreeMap&lt;Object, Object&gt;)map).entrySet()) { rawWriter.writeObject(entry.getKey()); rawWriter.writeObject(entry.getValue()); } }</code> </pre> <br><h2>  Luncurkan di Compute Grid </h2><br><p>  Menyalakan tidak hanya memungkinkan Anda untuk menyimpan data, tetapi juga menjalankan komputasi terdistribusi.  Bagaimana kita menjalankan semacam lambda sehingga mencerai-beraikan semua server dan berjalan? <br>  Sebagai permulaan, apa masalahnya dengan contoh kode ini? </p><br><p>  <b>Apa masalahnya?</b> </p><br><pre> <code class="java hljs">Foo foo = …; Bar bar = ...; ignite.compute().broadcast( () -&gt; doStuffWithFooAndBar(foo, bar) );</code> </pre> <br><p>  <b>Dan jika demikian?</b> </p><br><pre> <code class="java hljs">Foo foo = …; Bar bar = ...; ignite.compute().broadcast(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IgniteRunnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ doStuffWithFooAndBar(foo, bar); } });</code> </pre> <br><p>  Seperti yang Anda duga, banyak yang akrab dengan perangkap lambdas dan kelas anonim, masalahnya adalah dalam menangkap variabel dari luar.  Misalnya, kami mengirim lambda.  Ini menggunakan beberapa variabel yang dideklarasikan di luar lambda.  Ini berarti bahwa variabel-variabel ini akan bepergian dengannya dan terbang melintasi jaringan ke semua server.  Dan kemudian semua pertanyaan yang sama muncul: apakah benda-benda ini bersahabat dengan <code>BinaryMarshaller</code> ?  Apa ukurannya?  Apakah kita umumnya ingin mereka dipindahkan ke suatu tempat, atau apakah benda-benda ini begitu besar sehingga lebih baik untuk melewati semacam ID dan menciptakan kembali benda-benda di dalam lambda sudah di sisi lain? </p><br><p>  Kelas anonim bahkan lebih buruk.  Jika lambda tidak dapat membawa ini, membuangnya, jika tidak digunakan, maka kelas anonim pasti akan membawanya, dan ini biasanya tidak mengarah pada sesuatu yang baik. </p><br><p>  Contoh berikut.  Lambda lagi, tetapi yang menggunakan API Apache Ignite sedikit. </p><br><p>  <b>Menggunakan ignite dalam penutupan komputasi <em>salah</em></b> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = ignite.cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre> <br><p>  Dalam versi asli, dibutuhkan cache dan secara lokal membuat semacam query SQL di dalamnya.  Ini adalah pola seperti itu ketika Anda perlu mengirim tugas yang hanya berfungsi dengan data lokal pada node jarak jauh. </p><br><p>  Apa masalahnya di sini?  Lambda lagi menangkap tautan, tetapi sekarang bukan ke objek, tetapi ke Ignite lokal pada node yang kami kirimkan.  Dan itu bahkan berfungsi, karena objek Ignite memiliki metode <code>readResolve()</code> , yang memungkinkan deserialisasi untuk menggantikan Ignite yang datang melalui jaringan dengan yang lokal pada node tempat kami mengirimkannya.  Tetapi ini juga terkadang membawa konsekuensi yang tidak diinginkan. </p><br><p>  Pada dasarnya, Anda hanya mentransfer lebih banyak data melalui jaringan daripada yang Anda inginkan.  Jika Anda perlu mendapatkan dari beberapa kode yang Anda tidak mengontrol peluncuran ke Apache Ignite atau beberapa antarmuka, maka yang paling sederhana adalah menggunakan metode <code>Ignintion.localIgnite()</code> .  Anda dapat memanggilnya dari utas apa pun yang dibuat oleh Apache Ignite dan mendapatkan tautan ke objek lokal.  Jika Anda memiliki lambda, layanan, apa pun, dan Anda mengerti bahwa Anda perlu Ignite di sini, maka saya merekomendasikan metode ini. </p><br><p>  <strong>Kami menggunakan Ignite inside compute closure dengan benar - melalui <code>localIgnite()</code></strong> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = Ignition.localIgnite().cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre><br><p>  Dan contoh terakhir di bagian ini.  Apache Ignite memiliki Grid Layanan yang dapat digunakan untuk menggunakan layanan microser secara langsung dalam sebuah cluster, dan Apache Ignite akan membantu menjaga jumlah instance yang tepat secara online.  Katakanlah dalam layanan ini kita juga memerlukan tautan ke Apache Ignite.  Bagaimana cara mendapatkannya?  Kita bisa menggunakan <code>localIgnite()</code> , tetapi kemudian tautan ini harus disimpan secara manual di bidang tersebut. </p><br><p>  <strong>Layanan menyimpan Ignite di bidang yang <em>salah</em> - menganggapnya sebagai argumen untuk konstruktor</strong> </p><br><pre> <code class="java hljs">MyService s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(ignite) ignite.services().deployClusterSingleton(<span class="hljs-string"><span class="hljs-string">"svc"</span></span>, s); ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ignite ignite)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ignite = ignite; } ... }</code> </pre> <br><p>  Ada cara yang lebih sederhana.  Kami masih memiliki kelas penuh, dan bukan lambda, sehingga kami dapat membuat anotasi bidang sebagai <code>@IgniteInstanceResource</code> .  Ketika layanan dibuat, Apache Ignite akan menempatkan dirinya di sana, dan Anda dapat menggunakannya dengan aman.  Saya sangat menyarankan Anda untuk melakukan hal itu, dan jangan mencoba untuk memberikan Apache Ignite dan anak-anaknya ke konstruktor. </p><br><p>  <strong>Layanan menggunakan <code>@IgniteInstanceResource</code></strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IgniteInstanceResource</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } ... }</code> </pre> <br><h2>  Menulis dan membaca data </h2><br><h3>  Memperhatikan garis dasar </h3><br><p>  Sekarang kami memiliki gugus Apache Ignite dan kode yang disiapkan. </p><br><p>  Mari kita bayangkan skenario ini: </p><br><ul><li>  Satu cache <code>REPLICATED</code> - salinan data tersedia di semua node; </li><li>  Kegigihan asli sedang dalam proses penulisan ke disk. </li></ul><br><p>  Kami memulai satu simpul.  Karena kegigihan asli diaktifkan, kita perlu mengaktifkan cluster sebelum bekerja dengannya.  Aktifkan.  Lalu kami meluncurkan beberapa node lagi. <br>  Segalanya tampak bekerja: menulis dan membaca baik-baik saja.  Semua node memiliki salinan data, Anda dapat dengan aman menghentikan satu node.  Tetapi jika Anda menghentikan simpul pertama dari mana Anda memulai peluncuran, maka semuanya rusak: data hilang, dan operasi berhenti lewat. </p><br><p>  Alasannya adalah topologi dasar - banyak node yang menyimpan data kegigihan pada mereka.  Semua node lain tidak akan memiliki data persisten. </p><br><p>  Set node ini untuk pertama kali ditentukan pada saat aktivasi.  Dan simpul-simpul yang Anda tambahkan kemudian tidak lagi termasuk dalam jumlah simpul dasar.  Artinya, banyak topologi dasar hanya terdiri dari satu, simpul pertama, ketika berhenti, semuanya rusak.  Untuk mencegah hal ini terjadi, mulailah semua node terlebih dahulu, lalu aktifkan cluster.  Jika Anda perlu menambah atau menghapus simpul menggunakan perintah </p><br><pre> <code class="bash hljs">control.sh --baseline</code> </pre> <br><p>  Anda dapat melihat node mana yang terdaftar di sana.  Script yang sama dapat memperbarui baseline ke keadaan saat ini. </p><br><p>  <b>Contoh <code>control.sh</code></b> </p><br><p><img src="https://habrastorage.org/webt/nw/6d/fy/nw6dfy5onsssvkwsw1vmwaxczm4.png"></p><br><h3>  Colokasi data </h3><br><p>  Sekarang kita tahu bahwa data tersebut disimpan, cobalah untuk membacanya.  Kami memiliki dukungan SQL, Anda dapat melakukan <code>SELECT</code> - hampir seperti di Oracle.  Tetapi pada saat yang sama, kita dapat skala dan berjalan pada sejumlah node, data disimpan secara terdistribusi.  Mari kita lihat model seperti itu: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long orgId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Organization</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p>  Minta </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Organization</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.orgId = o.id</code> </pre> <br><p>  tidak akan mengembalikan semua data.  Apa yang salah </p><br><p>  Orang ( <code>Person</code> ) mengacu pada organisasi ( <code>Organization</code> ) dengan ID.  Ini adalah kunci asing klasik.  Tetapi jika kita mencoba untuk menggabungkan dua tabel dan mengirimkan query SQL, maka dengan beberapa node dalam cluster kita tidak akan menerima semua data. </p><br><p>  Faktanya adalah, secara default, SQL <code>JOIN</code> hanya berfungsi dalam satu node.  Jika SQL terus-menerus pergi ke seluruh cluster untuk mengumpulkan data dan mengembalikan hasil lengkap, itu akan sangat lambat.  Kami akan kehilangan semua manfaat dari sistem terdistribusi.  Jadi alih-alih, Apache Ignite hanya melihat data lokal. </p><br><p>  Untuk mendapatkan hasil yang benar, kita perlu menempatkan data bersama (colocation).  Yaitu, untuk kombinasi Person dan Organisasi yang benar, data dari kedua tabel harus disimpan pada node yang sama. </p><br><p>  Bagaimana cara melakukannya?  Solusi termudah adalah mendeklarasikan kunci afinitas.  Ini adalah nilai yang menentukan pada simpul mana, di mana partisi, di mana kelompok catatan ini atau nilai itu akan ditemukan.  Jika kami mendeklarasikan ID organisasi di <code>Person</code> sebagai kunci afinitas, ini berarti bahwa orang-orang dengan ID organisasi ini harus berada di simpul yang sama dengan organisasi dengan ID yang sama. </p><br><p>  Jika karena alasan tertentu Anda tidak dapat melakukan ini, ada solusi lain yang kurang efektif - aktifkan sambungan terdistribusi.  Ini dilakukan melalui API, dan prosedurnya tergantung pada apa yang Anda gunakan - Java, JDBC atau yang lainnya.  Kemudian <code>JOIN</code> akan dieksekusi lebih lambat, tetapi kemudian mereka akan mengembalikan hasil yang benar. </p><br><p>  Mari kita pertimbangkan cara bekerja dengan kunci afinitas.  Bagaimana kita memahami bahwa ID ini dan itu, bidang ini dan itu cocok untuk menentukan afinitas?  Jika kita mengatakan bahwa semua orang dengan <code>orgId</code> sama akan disimpan bersama, maka <code>orgId</code> adalah satu grup yang tidak dapat dibagi.  Kami tidak dapat mendistribusikannya di beberapa node.  Jika database berisi 10 organisasi, maka akan ada 10 grup yang tidak dapat dibagi yang dapat diletakkan di 10 node.  Jika ada lebih banyak node di cluster, maka semua node "ekstra" akan tetap tanpa grup.  Ini sangat sulit untuk didefinisikan dalam runtime, jadi pikirkan sebelumnya. </p><br><p>  Jika Anda memiliki satu organisasi besar dan 9 organisasi kecil, maka ukuran grup akan berbeda.  Tetapi Apache Ignite tidak melihat jumlah catatan dalam grup afinitas ketika mendistribusikannya di seluruh node.  Oleh karena itu, ia tidak akan menempatkan satu grup pada satu node, tetapi 9 grup lainnya pada yang lain untuk menaikkan level distribusi.  Sebaliknya, ia akan menempatkan mereka 5 dan 5, (atau 6 dan 4, atau bahkan 7 dan 3). </p><br><p>  Bagaimana cara membuat data terdistribusi secara merata?  Semoga kita punya </p><br><ul><li>  Kunci K; </li><li>  Berbagai kunci afinitas; </li><li>  Partisi P, yaitu kelompok besar data yang akan didistribusikan oleh Apache Ignite di antara node; </li><li>  N node. </li></ul><br><p>  Maka perlu bahwa kondisi </p><br><pre> <code class="hljs ruby">K <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>A &gt;&gt; P &gt;&gt; N</code> </pre> <br><p>  di mana <code>&gt;&gt;</code> adalah "lebih banyak" dan data akan didistribusikan secara relatif merata. </p><br><p>  Omong-omong, standarnya adalah P = 1024. </p><br><p>  Kemungkinan besar Anda tidak akan berhasil dalam distribusi yang seragam.  Ini adalah kasus di Apache Ignite 1.x hingga 1.9.  Ini disebut <code>FairAffinityFunction</code> dan tidak berfungsi dengan baik - ini menyebabkan terlalu banyak lalu lintas antar node.  Sekarang algoritma ini disebut <code>RendezvousAffinityFunction</code> .  Itu tidak memberikan distribusi yang benar-benar jujur, kesalahan antara node akan menjadi plus atau minus 5-10%. </p><br><h2>  Daftar periksa untuk pengguna baru Apache Ignite </h2><br><ol><li>  Siapkan, baca, simpan log </li><li>  Matikan multicast, catat hanya alamat dan port yang Anda gunakan </li><li>  Nonaktifkan IPv6 </li><li>  Persiapkan Kelas Anda untuk <code>BinaryMarshaller</code> </li><li>  Melacak garis dasar Anda </li><li>  Atur kolokasi afinitas </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415973/">https://habr.com/ru/post/id415973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415961/index.html">Penyimpanan terdistribusi Rusia. Bagaimana cara kerjanya</a></li>
<li><a href="../id415963/index.html">Naif Bayes, atau bagaimana matematika memungkinkan Anda untuk memfilter spam</a></li>
<li><a href="../id415965/index.html">Apa yang harus dibaca pada bulan Juli: 19 buku baru untuk para profesional digital</a></li>
<li><a href="../id415967/index.html">SolidFire - Penyimpanan untuk penyimpanan ** cking hate</a></li>
<li><a href="../id415969/index.html">HyperX Pulsefire Surge RGB - pembunuh alami</a></li>
<li><a href="../id415975/index.html">Cina memperkenalkan senjata laser dengan jangkauan hampir satu kilometer</a></li>
<li><a href="../id415977/index.html">Terowongan dan VPN Tahan DPI</a></li>
<li><a href="../id415979/index.html">Security Week 24: Rowhammer di Android dan kerumitan kerentanan perangkat keras</a></li>
<li><a href="../id415981/index.html">Google dan HTTP</a></li>
<li><a href="../id415983/index.html">Early Universe 5. Redshift kosmologis dan dinamika semesta yang mengembang seragam, bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>