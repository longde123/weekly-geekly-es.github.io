<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏿 🙇🏼 🍗 Recherche en texte intégral: fonctionnalités spécifiques à Elasticsearch pour les tâches complexes 👆🏻 😇 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut tout le monde, je m'appelle Andrey et je suis développeur. Il y a longtemps - il semble, vendredi dernier - notre équipe avait un projet où elle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recherche en texte intégral: fonctionnalités spécifiques à Elasticsearch pour les tâches complexes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413075/"><img src="https://habrastorage.org/webt/yb/hh/1r/ybhh1rxmqt9yswla3tfbiexyluo.png" alt="image"><br><br>  Salut tout le monde, je m'appelle Andrey et je suis développeur.  Il y a longtemps - il semble, vendredi dernier - notre équipe avait un projet où elle avait besoin d'une recherche des ingrédients qui composent les produits.  Disons la composition de la saucisse.  Au tout début du projet, la recherche ne demandait pas grand-chose: montrer toutes les recettes dans lesquelles l'ingrédient souhaité est contenu en une certaine quantité;  répéter pour N ingrédients. <br><a name="habracut"></a><br>  Cependant, à l'avenir, le nombre de produits et d'ingrédients devait être considérablement augmenté, et la recherche devrait non seulement faire face à l'augmentation du volume de données, mais également fournir des options supplémentaires - par exemple, la compilation automatique d'une description de produit basée sur ses ingrédients dominants. <br><br>  <b>Prérequis</b> <br><br><ul><li>  Créez une recherche sur Elacsticsearch en utilisant une base de données d'au moins 50 000 documents. </li><li>  Fournit une réponse rapide aux demandes - moins de 300 ms. </li><li>  Pour s'assurer que les demandes étaient petites et que le service était disponible même dans les pires conditions de l'Internet mobile. </li><li>  Rendez la logique de recherche aussi intuitive que possible dans une perspective UX.  C'était essentiellement que l'interface refléterait la logique de recherche - et vice versa. </li><li>  Minimisez le nombre d'intercouches entre les éléments du système pour de meilleures performances et moins de dépendances. </li><li>  Offrir à tout moment la possibilité de compléter l'algorithme par de nouvelles conditions (par exemple, génération automatique d'une description de produit). </li><li>  Rendre le support pour la partie recherche du projet aussi simple et pratique que possible. </li></ul><br>  Nous avons décidé de ne pas nous précipiter et de commencer simplement. <br><br>  Tout d'abord, nous avons stocké tous les ingrédients de la composition du produit dans une base de données, après avoir reçu au début 10 000 entrées.  Malheureusement, même à cette taille, la recherche dans la base de données a pris trop de temps, même en tenant compte de l'utilisation des jointures et des index.  Et dans un avenir proche, le nombre d'enregistrements devait dépasser 50 000. En outre, le client a insisté pour utiliser Elasticsearch (ci-après - ES), car il est tombé sur cet outil et, apparemment, avait des sentiments chaleureux pour lui.  Nous ne travaillions pas avec ES auparavant, mais nous connaissions ses avantages et étions d'accord avec ce choix, car, par exemple, il était prévu que nous aurions souvent de nouvelles entrées (selon diverses estimations de 50 à 500 par jour), ce qui serait nécessaire donner immédiatement à l'utilisateur. <br><br>  Nous avons décidé d'abandonner les intercouches au niveau du pilote et d'utiliser simplement les requêtes REST, car la synchronisation avec la base de données se fait uniquement au moment de la création du document et n'est plus nécessaire.  C'était un autre avantage - jusqu'à l'envoi de requêtes de recherche directement à ES à partir d'un navigateur. <br><br>  Nous avons monté le premier prototype dans lequel nous avons transféré la structure d'une base de données (PostgreSQL) vers des documents ES: <br><br><pre><code class="php hljs">{<span class="hljs-string"><span class="hljs-string">"mappings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_source"</span></span> : { <span class="hljs-string"><span class="hljs-string">"enabled"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"integer"</span></span>}, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"text"</span></span>}, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"nested"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-string"><span class="hljs-string">"float"</span></span> } } } } }}</code> </pre> <br>  Sur la base de ce mappage, nous obtenons approximativement le document suivant (nous ne pouvons pas montrer le travailleur du projet en raison de NDA): <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA &amp; BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 4"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } ] }</code> </pre> <br>  Tout cela a été fait en utilisant le package PHP Elasticsearch.  Les extensions pour Laravel (Elastiquent, Laravel Scout, etc.) ont décidé de ne pas l'utiliser pour une raison - le client exigeait des performances élevées, jusqu'au point mentionné ci-dessus que «300 ms pour une demande, c'est beaucoup».  Et tous les packages pour Laravel ont agi comme un surcoût supplémentaire et ont ralenti.  Cela aurait pu être fait directement sur Guzzle, mais nous avons décidé de ne pas aller aux extrêmes. <br><br>  Tout d'abord, la recherche la plus simple de recettes a été effectuée directement sur les tableaux.  Oui, tout cela a été retiré des fichiers de configuration, mais la demande s'est quand même avérée trop importante.  La recherche a eu lieu sur les documents joints (les mêmes ingrédients), sur les expressions booléennes utilisant `` devrait '' et `` doit '', il y avait aussi une directive pour le passage obligatoire sur les documents joints - en conséquence, la demande a pris cent lignes et son volume était de trois kilo-octets. <br><br>  N'oubliez pas les exigences de vitesse et de taille de la réponse - à ce moment-là, les réponses dans l'API étaient formatées de manière à augmenter la quantité d'informations utiles: les clés de chaque objet json étaient réduites à une lettre.  Par conséquent, les requêtes dans les ES de quelques kilo-octets sont devenues un luxe inacceptable. <br><br>  Et à ce moment, nous avons réalisé que la construction de requêtes géantes sous la forme de tableaux associatifs en PHP est une sorte de dépendance féroce.  De plus, les contrôleurs sont devenus complètement illisibles, voyez par vous-même: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.ingredient_id"</span></span> =&gt; $ingredient_id]], [<span class="hljs-string"><span class="hljs-string">"range"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span>=&gt;[ <span class="hljs-string"><span class="hljs-string">"lte"</span></span>=&gt;$percent + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"gte"</span></span>=&gt;$percent - <span class="hljs-number"><span class="hljs-number">5</span></span> ]]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>] = $conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $equal_conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span> =&gt; $percent]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'must'</span></span>] = $equal_conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;client-&gt;search($parameters); }</code> </pre> <br>  Digression lyrique: en ce qui concerne les champs imbriqués dans le document, il s'est avéré que nous ne pouvons pas répondre à une requête du formulaire: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ ... ] } } } }</code> </pre> <br>  pour une raison simple: vous ne pouvez pas effectuer de recherche multiple dans un filtre imbriqué.  Par conséquent, je devais faire ceci: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { ... } } }} ] } }</code> </pre> <br>  c'est-à-dire  tout d'abord, un tableau de conditions devrait être déclaré, et à l'intérieur de chaque condition une recherche a été appelée par le champ imbriqué.  Du point de vue d'Elasticsearch, c'est plus correct et logique.  En conséquence, nous avons nous-mêmes vu que cela était logique lorsque nous avons ajouté des termes de recherche supplémentaires. <br><br>  Et ici, nous avons découvert les modèles <s>Google</s> intégrés à ES.  Le choix s'est porté sur Moustache - un moteur de modèle sans logique assez pratique.  Il a été possible d'y mettre pratiquement sans modification tout le corps de la demande et toutes les données transmises, à la suite de quoi la demande finale a pris la forme: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"template1"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: params{} }</code> </pre> <br>  Le corps du modèle s'est avéré plutôt modeste et lisible - uniquement JSON et les directives de Moustache elle-même.  Le modèle est stocké dans Elasticsearch lui-même et est appelé par son nom. <br><br><pre> <code class="hljs smalltalk">/* search_similar.mustache */ { <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimum_should_match"</span></span>: {{ minimumShouldMatch }}, <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientsList</span></span>}} // mustache         ingredientsList {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredients</span></span>}} //         ingredients {<span class="hljs-comment"><span class="hljs-comment">"nested"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"path"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"score_mode"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"max"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.flavor_id"</span></span>: {{ id }} }}, {<span class="hljs-comment"><span class="hljs-comment">"range"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.percent"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: {{ lte }}, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: {{ gte }} }}} ] } } }} {{^isLast}},{{/isLast}} //    {{/ingredients}} {{/ingredientsList}} ] }} ] } } } /*  */ { <span class="hljs-comment"><span class="hljs-comment">"template"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"search_similar"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"params"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimumShouldMatch"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"ingredientsList"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"isLast"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } ] } } }</code> </pre> <br>  En conséquence, à la sortie, nous avons obtenu un modèle dans lequel nous avons simplement passé un tableau des ingrédients nécessaires.  Logiquement, la demande ne diffère pas beaucoup, conditionnellement, de ce qui suit: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ingredients <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> recipes <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipes.id = ingredient.recipe_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.percent <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">20.0</span></span></code> </pre> <br>  mais il a travaillé plus vite, et c'était une base toute faite pour de nouvelles demandes. <br><br>  Ici, en plus de la recherche en pourcentage, nous avions besoin de plusieurs autres types d'opérations: une recherche par nom parmi les ingrédients, les groupes et les noms des recettes;  recherche par identifiant d'ingrédient en tenant compte de la tolérance de son contenu dans la recette;  la même requête, mais avec le calcul des résultats sous quatre conditions (par la suite a été refait pour une autre tâche), ainsi que la requête finale. <br><br>  La demande exigeait la logique suivante: pour chaque ingrédient, il y a cinq étiquettes qui le relient à n'importe quel groupe.  Par convention, le porc et le bœuf sont de la viande, et le poulet et la dinde sont de la volaille.  Chacune des balises est située à son propre niveau.  Sur la base de ces balises, nous avons pu créer une description conditionnelle de la recette, ce qui nous a permis de générer automatiquement un arbre de recherche et / ou une description.  Par exemple, la viande de saucisse et le lait aux épices, le foie et le soja, le poulet halal.  Une même recette peut avoir plusieurs ingrédients avec la même étiquette.  Cela nous a permis de ne pas remplir la chaîne d'étiquettes avec nos mains - en fonction de la composition de la recette, nous pouvions déjà la décrire clairement.  La structure du document joint a également changé: <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"level_1"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"level_2"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"level_3"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"level_4"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-string"><span class="hljs-string">"level_5"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre> <br>  Il était également nécessaire de spécifier une recherche par la condition de «pureté» de la recette.  Par exemple, nous avions besoin d'une recette où il n'y aurait que du bœuf, du sel et du poivre.  Ensuite, nous avons dû éliminer les recettes où seul le bœuf était au premier niveau et uniquement les épices au second (la première étiquette pour les épices était zéro).  Ici, je devais tricher: puisque la moustache est un modèle sans logique, il ne pouvait être question de calculs;  ici, il était nécessaire d'implémenter une partie du script dans la requête dans le langage de script ES - Indolore.  Sa syntaxe est aussi proche que possible de Java, il n'y a donc pas eu de difficultés.  En conséquence, nous avions un modèle Moustache générant du JSON, dans lequel une partie des calculs, à savoir le tri et le filtrage, étaient implémentés sur Indolore: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levelsList}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levels}}</span></span><span class="xml"><span class="xml"> {"script": { "script": " int total=0; for (ingredient in params._source.ingredients){ if ([0,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tag}}</span></span><span class="xml"><span class="xml">].contains(ingredient.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{id}}</span></span><span class="xml"><span class="xml">)) total+=1; } return (total==params._source.ingredients.length); " }} </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levels}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levelsList}}</span></span><span class="xml"><span class="xml"> ]</span></span></code> </pre><br>  Ci-après, le corps du script est formaté pour plus de lisibilité, les sauts de ligne ne peuvent pas être utilisés dans les requêtes. <br><br>  À ce moment-là, nous avons supprimé la tolérance pour le contenu de l'ingrédient et trouvé un goulot d'étranglement - nous ne pouvions considérer la saucisse de boeuf que parce que cet ingrédient s'y trouve.  Ensuite, nous avons ajouté - tous sur les mêmes scripts indolores - un filtrage à condition que cet ingrédient prévale dans la composition: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ {"script":{ "script": " double nest=0,rest=0; for (ingredient in params._source.ingredients){ if([</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#tags}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{tagId}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{/tags}}</span></span><span class="xml"><span class="xml">].contains(flavor.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tags.0.levelId}}</span></span><span class="xml"><span class="xml">)){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){rest = ingredient.percent} } } return(nest&gt;=rest); " }} ]</span></span></code> </pre> <br>  Comme vous pouvez le voir, Elasticsearch manquait de beaucoup de choses pour ce projet, donc elles devaient être assemblées à partir des «moyens disponibles».  Mais cela n'est pas surprenant - le projet est suffisamment atypique pour une machine utilisée pour la recherche en texte intégral. <br><br>  À l'une des étapes intermédiaires du projet, nous avions besoin de la chose suivante: afficher une liste de tous les groupes d'ingrédients disponibles et le nombre de positions dans chacun.  Le même problème a été révélé ici que dans la requête dominante: sur 10 000 recettes, environ 10 groupes ont été générés en fonction du contenu.  Cependant, environ 40 000 recettes au total se sont révélées appartenir à ces groupes, ce qui ne correspondait pas du tout à la réalité.  Ensuite, nous avons commencé à creuser vers des requêtes parallèles. <br><br>  La première demande, nous avons reçu une liste de tous les groupes qui sont au premier niveau sans le nombre d'entrées.  Après cela, une multi-requête a été générée: pour chaque groupe, une requête a été faite pour recevoir le nombre réel de recettes selon le principe du pourcentage en vigueur.  Toutes ces demandes ont été rassemblées en une seule et envoyées à Elasticsearch.  Le temps de réponse pour la demande générale était égal au temps de traitement de la demande la plus lente.  L'agrégation en masse a permis de les paralléliser.  Une logique similaire (simplement en regroupant par condition dans une requête) en SQL prenait environ 15 fois plus de temps. <br><br><pre> <code class="hljs markdown">/<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/ $params = config('elastic.params'); $params[<span class="hljs-string"><span class="hljs-string">'body'</span></span>] = config('elastic.top_list'); return (Elastic::getClient()-&gt;search($params))[<span class="hljs-string"><span class="hljs-string">'aggregations'</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">'tags'</span></span>][<span class="hljs-string"><span class="hljs-string">'buckets'</span></span>]; /<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/</code> </pre><br>  Après cela, nous devions évaluer: <br><br><ol><li>  combien de recettes sont disponibles pour la composition actuelle; </li><li>  quels autres ingrédients pouvons-nous ajouter à la composition (parfois nous avons ajouté l'ingrédient et obtenu un échantillon vide); </li><li>  quels ingrédients parmi les sélectionnés, nous pouvons marquer comme les seuls à ce niveau. </li></ol><br>  Sur la base de la tâche, nous avons combiné la logique de la dernière demande reçue pour la liste de recettes et la logique d'obtention de nombres exacts à partir de la liste de tous les groupes disponibles: <br><br><pre> <code class="hljs smalltalk">/*  */ <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { //      <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ //    <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } //    ,    } } /*   */ foreach (<span class="hljs-string"><span class="hljs-string">$n</span></span>ot_only as <span class="hljs-string"><span class="hljs-string">$e</span></span>lement) { <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, collect(<span class="hljs-string"><span class="hljs-string">$o</span></span>nly-&gt;all())-&gt;push(<span class="hljs-string"><span class="hljs-string">$e</span></span>lement), <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); } /*   */ <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, <span class="hljs-string"><span class="hljs-string">$o</span></span>nly, <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-string"><span class="hljs-string">$f</span></span>rom, <span class="hljs-string"><span class="hljs-string">$s</span></span>ize<span class="hljs-string"><span class="hljs-string">') ); /*     */ $parameters['</span></span>max_concurrent_searches<span class="hljs-string"><span class="hljs-string">'] = 1 + $not_only-&gt;count(); return (Elastic::getClient()-&gt;msearchTemplate($parameters))['</span></span>responses<span class="hljs-string"><span class="hljs-string">'];</span></span></code> </pre> <br>  En conséquence, nous avons reçu une demande qui trouve toutes les recettes nécessaires et leur nombre total (il a été extrait de la réponse ["hits"] ["total"]).  Par souci de simplicité, cette demande a été enregistrée à la dernière place de la liste. <br><br>  De plus, grâce à l'agrégation, nous avons reçu tous les ingrédients d'identification pour le niveau suivant.  Pour chacun des ingrédients qui n'étaient pas marqués comme «uniques», nous avons créé une requête où nous l'avons marqué en conséquence, puis nous avons simplement compté le nombre de documents trouvés.  S'il était supérieur à zéro, l'ingrédient était alors considéré comme disponible pour l'attribution de la clé "unique".  Je pense qu'ici, vous pouvez restaurer le modèle entier sans moi, que nous avons obtenu à la sortie: <br><br><pre> <code class="hljs smalltalk">{ <span class="hljs-comment"><span class="hljs-comment">"from"</span></span>: {{ from }}, <span class="hljs-comment"><span class="hljs-comment">"size"</span></span>: {{ size }}, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientTags</span></span>}} {{<span class="hljs-symbol"><span class="hljs-symbol">#tagList</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"level_{{ levelId }}"</span></span>: {{ tagId }} }} ] }} {{^isLast}},{{/isLast}} {{/tagList}} {{/ingredientTags}} ], <span class="hljs-comment"><span class="hljs-comment">"filter"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>:{ <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" double nest=0,rest=0; for(ingredient in params._source. ingredients){ if([{{#tags}}{{tagId}}{{^isLast}},{{/isLast}}{{/tags}}].contains(ingredient.level_{{tags.0.levelId}})){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){ rest= ingredient.percent } } } return(nest&gt;=rest); "</span></span> }} {{<span class="hljs-symbol"><span class="hljs-symbol">#levelsList</span></span>}}, {{<span class="hljs-symbol"><span class="hljs-symbol">#levels</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" int total=0; for(ingredient in params._source.ingredients){ if ([0,{{tag}}].contains(ingredient.level_{{id}})) total+=1; } return (total==params._source.ingredients.length); "</span></span> }} {{^isLast}},{{/isLast}} {{/levels}} {{/levelsList}} ] } }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } } }, <span class="hljs-comment"><span class="hljs-comment">"sort"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"_score"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"order"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"desc"</span></span>}} ] }</code> </pre><br>  Bien sûr, nous mettons en cache une partie de ce tas de modèles et de requêtes (comme la page de tous les groupes disponibles avec le nombre de recettes disponibles), ce qui nous ajoute un peu de performance sur la page principale.  Cette décision a permis de collecter les données principales en 50 ms. <br><br>  <b>Résultats du projet</b> <br><br>  Nous avons effectué une recherche dans la base de données d'au moins 50 000 documents sur Elasticsearch, ce qui vous permet de rechercher des ingrédients dans les produits et d'obtenir une description du produit par les ingrédients qu'il contient.  Bientôt, cette base de données augmentera d'environ six fois (les données sont en cours de préparation), nous sommes donc très satisfaits de nos résultats et d'Elasticsearch en tant qu'outil de recherche. <br><br>  Sur la question des performances, nous avons répondu aux exigences du projet, et nous nous réjouissons nous-mêmes que le temps de réponse moyen à une demande soit de 250-300 ms. <br><br>  Trois mois après avoir commencé à travailler avec Elasticsearch, cela ne semble plus si déroutant et inhabituel.  Et les avantages du modèle sont évidents: si nous constatons que la demande redevient trop importante, nous transférons simplement la logique supplémentaire au modèle et envoyons à nouveau la demande d'origine au serveur sans presque aucun changement. <br><br>  "Tout le meilleur et merci pour le poisson!"  (c) <br><br>  <b>PS</b> Au dernier moment, nous avions également besoin d'un tri par caractères russes dans le nom.  Et il s'est avéré qu'Elasticsearch ne percevait pas correctement l'alphabet russe.  La saucisse conditionnelle «Ultra méga porc 9000 calories» a été transformée à l'intérieur du tri simplement en «9000» et était à la fin de la liste.  Il s'est avéré que ce problème est assez facilement résolu en convertissant les caractères russes en notation unicode de la forme u042B. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413075/">https://habr.com/ru/post/fr413075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413063/index.html">Test d'une tasse thermo maison sur une transition de phase</a></li>
<li><a href="../fr413065/index.html">Nouvelles fonctionnalités prévues dans C # 8.0</a></li>
<li><a href="../fr413069/index.html">Recherche audio, référencement audio et aide pour les podcasts - les spécialistes Google y travaillent déjà</a></li>
<li><a href="../fr413071/index.html">DeepMind a appris à l'IA à jouer à des jeux vidéo YouTube</a></li>
<li><a href="../fr413073/index.html">Comment travailler avec le cloud: 30 documents, guides pratiques et conseils sur le thème du PD, du SI et de l'IaaS</a></li>
<li><a href="../fr413077/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 255 (28 mai - 3 juin)</a></li>
<li><a href="../fr413083/index.html">Les développeurs du MIT créent une prothèse bionique avec une coordination précise des mouvements</a></li>
<li><a href="../fr413087/index.html">Assistant de voiture homme</a></li>
<li><a href="../fr413091/index.html">Journalisation pratique dans SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../fr413093/index.html">En prévision de la course des commerçants de l'espace aux États-Unis et en Chine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>