<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏽 🆑 🧖🏽 Interne und externe Verknüpfung in C ++ 🛫 🤬 🚥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle! 

 Wir präsentieren Ihnen die Übersetzung eines interessanten Artikels, der im Rahmen des Kurses "C ++ Developer" für Sie vorbereit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interne und externe Verknüpfung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/432834/">  Guten Tag an alle! <br><br>  Wir präsentieren Ihnen die Übersetzung eines interessanten Artikels, der im Rahmen des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer"</a> für Sie vorbereitet wurde.  Wir hoffen, dass es sowohl für Sie als auch für unsere Zuhörer nützlich und interessant sein wird. <br><br>  Lass uns gehen. <br><br>  Haben Sie jemals die Begriffe interne und externe Kommunikation kennengelernt?  Möchten Sie wissen, wofür das Schlüsselwort extern verwendet wird oder wie sich die Deklaration von etwas Statischem auf den globalen Bereich auswirkt?  Dann ist dieser Artikel für Sie. <br><br>  <b>Kurzgesagt</b> <br><br>  Die Übersetzungseinheit (.c / .cpp) und alle ihre Header-Dateien (.h / .hpp) sind in der Übersetzungseinheit enthalten.  Wenn ein Objekt oder eine Funktion innerhalb einer Übersetzungseinheit eine interne Bindung aufweist, ist dieses Symbol für den Linker nur innerhalb dieser Übersetzungseinheit sichtbar.  Wenn das Objekt oder die Funktion einen externen Link hat, kann der Linker diesen sehen, wenn er andere Übersetzungseinheiten verarbeitet.  Die Verwendung des statischen Schlüsselworts im globalen Namespace gibt dem Zeichen eine interne Bindung.  Das Schlüsselwort extern gibt eine externe Bindung an. <br>  Der Standard-Compiler gibt Zeichen die folgenden Bindungen: <br><br><ul><li>  Nicht konstante globale Variablen - externe Bindung; </li><li>  Const globale Variablen - interne Bindung; </li><li>  Funktionen - Externe Verknüpfung. </li></ul><br><img src="https://habrastorage.org/webt/m5/bl/8d/m5bl8d7e6yb-7qlgsoqf8duzuku.png"><br><a name="habracut"></a><br>  <b>Die Grundlagen</b> <br><br>  Lassen Sie uns zunächst über zwei einfache Konzepte sprechen, die zur Erörterung der Bindung erforderlich sind. <br><br><ul><li>  Der Unterschied zwischen einer Erklärung und einer Definition; </li><li>  Broadcast-Einheiten. </li></ul><br>  Achten Sie auch auf die Namen: Wir werden das Konzept des "Symbols" verwenden, wenn es um eine "Code-Entität" geht, mit der der Linker arbeitet, beispielsweise mit einer Variablen oder Funktion (oder mit Klassen / Strukturen, aber wir werden uns nicht auf sie konzentrieren). <br><br>  <b>Ankündigung VS.</b>  <b>Definition</b> <br><br>  Wir diskutieren kurz den Unterschied zwischen einer Deklaration und einer Symboldefinition: Eine Ansage (oder Deklaration) informiert den Compiler über die Existenz eines bestimmten Symbols und ermöglicht den Zugriff auf dieses Symbol in Fällen, in denen keine genaue Speicheradresse oder Symbolspeicherung erforderlich ist.  Die Definition teilt dem Compiler mit, was im Hauptteil der Funktion enthalten ist oder wie viel Speicher die Variable zuweisen muss. <br><br>  In einigen Situationen reicht eine Deklaration für den Compiler nicht aus, z. B. wenn ein Klassendatenelement eine Referenz oder einen Werttyp hat (dh keine Referenz und keinen Zeiger).  Gleichzeitig ist ein Zeiger auf einen deklarierten (aber nicht definierten) Typ zulässig, da er unabhängig vom Typ, auf den er verweist, eine feste Speichermenge benötigt (z. B. 8 Byte in 64-Bit-Systemen).  Um den Wert mit diesem Zeiger zu erhalten, ist eine Definition erforderlich.  Um eine Funktion zu deklarieren, müssen Sie außerdem alle Parameter (unabhängig davon, ob sie nach Wert, Referenz oder Zeiger verwendet werden) und den Rückgabetyp deklarieren (aber nicht definieren).  Das Bestimmen der Art des Rückgabewerts und der Parameter ist nur zum Definieren einer Funktion erforderlich. <br><br>  <b>Funktionen</b> <br><br>  Der Unterschied zwischen dem Definieren und Deklarieren einer Funktion ist sehr offensichtlich. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  int f() { return 42; } // </span></span></code> </pre> <br>  <b>Variablen</b> <br><br>  Bei Variablen ist das etwas anders.  Erklärung und Definition werden normalerweise nicht geteilt.  Die Hauptsache ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x;</code> </pre> <br>  Deklariert nicht nur <code>x</code> , sondern definiert es auch.  Dies ist auf den Aufruf des Standardkonstruktors int zurückzuführen.  (In C ++ initialisiert der Konstruktor einfacher Typen (z. B. int) im Gegensatz zu Java den Wert standardmäßig nicht auf 0. Im obigen Beispiel entspricht x dem Müll, der in der vom Compiler zugewiesenen Speicheradresse liegt.) <br><br>  Sie können die Variablendeklaration und ihre Definition jedoch explizit mit dem Schlüsselwort <code>extern</code> trennen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  int x = 42; // </span></span></code> </pre> <br>  Beim Initialisieren und Hinzufügen von <code>extern</code> zur Deklaration wird der Ausdruck jedoch zu einer Definition, und das Schlüsselwort <code>extern</code> wird unbrauchbar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,   int x = 5;</span></span></code> </pre> <br>  <b>Anzeigenvorschau</b> <br><br>  In C ++ gibt es das Konzept, ein Zeichen vorab zu deklarieren.  Dies bedeutet, dass wir den Typ und den Namen des Symbols für Situationen deklarieren, für die keine Definition erforderlich ist.  Daher müssen wir nicht die vollständige Definition eines Zeichens (normalerweise eine Header-Datei) einschließen, ohne dass dies offensichtlich erforderlich ist.  Somit reduzieren wir die Abhängigkeit von der Datei, die die Definition enthält.  Der Hauptvorteil besteht darin, dass beim Ändern einer Datei mit einer Definition die Datei, in der wir dieses Symbol vorläufig deklarieren, nicht neu kompiliert werden muss (was bedeutet, dass alle anderen Dateien, einschließlich dieser). <br><br>  <i>Beispiel</i> <br><br>  Angenommen, wir haben eine Funktionsdeklaration (als Prototyp bezeichnet) für f, die ein Objekt vom Typ <code>Class</code> nach Wert annimmt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp void f(Class object);</span></span></code> </pre> <br>  Fügen Sie sofort die Definition von <code>Class</code> - naiv hinzu.  Da wir gerade <code>f</code> deklariert haben, reicht es aus, dem Compiler eine Klassendeklaration zu geben.  Auf diese Weise kann der Compiler die Funktion an seinem Prototyp erkennen und die Abhängigkeit von file.hpp von der Datei, die die Definition von <code>Class</code> , wie beispielsweise class.hpp, beseitigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp class Class; void f(Class object);</span></span></code> </pre> <br>  Angenommen, file.hpp ist in 100 anderen Dateien enthalten.  Nehmen wir an, wir ändern die Definition von Class in class.hpp.  Wenn Sie class.hpp zu file.hpp hinzufügen, müssen file.hpp und alle 100 Dateien, die es enthalten, neu kompiliert werden.  Dank der vorläufigen Deklaration von Class müssen nur class.hpp und file.hpp neu kompiliert werden (vorausgesetzt, dort ist f definiert). <br><br>  <b>Verwendungshäufigkeit</b> <br><br>  Ein wichtiger Unterschied zwischen einer Deklaration und einer Definition besteht darin, dass ein Symbol mehrmals deklariert, aber nur einmal definiert werden kann.  Sie können eine Funktion oder Klasse also beliebig oft vordeklarieren, es kann jedoch nur eine Definition geben.  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regel einer Definition bezeichnet</a> .  In C ++ funktioniert Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  Und das funktioniert nicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre><br>  <b>Broadcast-Einheiten</b> <br><br>  Programmierer arbeiten normalerweise mit Header- und Implementierungsdateien.  Aber keine Compiler - sie arbeiten mit Übersetzungseinheiten (kurz Übersetzungseinheiten - TU), die manchmal als Kompilierungseinheiten bezeichnet werden.  Die Definition einer solchen Einheit ist recht einfach: Jede Datei, die nach ihrer vorläufigen Verarbeitung an den Compiler übertragen wird.  Um genau zu sein, ist dies eine Datei, die aus der Arbeit eines Erweiterungsmakro-Präprozessors resultiert, der Quellcode enthält, der von den Ausdrücken <code>#ifdef</code> und <code>#ifndef</code> abhängt, und das Kopieren und Einfügen aller <code>#include</code> Dateien. <br><br>  Folgende Dateien stehen zur Verfügung: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> VALUE struct Foo { private: int ryan; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int strlen(const char* string); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* HEADER_HPP */</span></span></span></span></code> </pre> <br>  program.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> int strlen(const char* string) { int length = 0; while(string[length]) ++length; return length + VALUE; }</span></span></code> </pre> <br>  Der Präprozessor erzeugt die folgende Übersetzungseinheit, die dann an den Compiler übergeben wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[length]) ++length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length + <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  <b>Kommunikation</b> <br><br>  Nachdem Sie die Grundlagen besprochen haben, können Sie die Beziehung beginnen.  Im Allgemeinen ist Kommunikation die Sichtbarkeit von Zeichen für den Linker bei der Verarbeitung von Dateien.  Die Kommunikation kann entweder extern oder intern erfolgen. <br><br>  <b>Externe Kommunikation</b> <br><br>  Wenn ein Symbol (Variable oder Funktion) eine externe Verbindung hat, wird es für Linker aus anderen Dateien sichtbar, dh "global" sichtbar und für alle Übersetzungseinheiten zugänglich.  Dies bedeutet, dass Sie ein solches Symbol an einer bestimmten Stelle einer Übersetzungseinheit definieren müssen, normalerweise in der Implementierungsdatei (.c / .cpp), damit es nur eine sichtbare Definition hat.  Wenn Sie versuchen, das Symbol gleichzeitig mit der Deklaration des Symbols zu definieren, oder wenn Sie die Definition in eine Datei für die Deklaration einfügen, besteht die Gefahr, dass Sie den Linker verärgern.  Der Versuch, eine Datei zu mehr als einer Implementierungsdatei hinzuzufügen, führt dazu, dass mehr als einer Übersetzungseinheit eine Definition hinzugefügt wird - Ihr Linker wird weinen. <br><br>  Das Schlüsselwort extern in C und C ++ deklariert (explizit), dass ein Zeichen eine externe Verbindung hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; argument)</span></span></span></span>;</code> </pre><br>  Beide Zeichen haben eine externe Verbindung.  Es wurde oben angemerkt, dass konstante globale Variablen standardmäßig eine interne Bindung haben, nicht konstante globale Variablen eine externe Bindung.  Dies bedeutet, dass int x;  - wie extern int x ;, richtig?  Nicht wirklich.  int x;  eigentlich analog zu extern int x {};  (Verwenden der Universal / Bracket-Initialisierungssyntax, um das unangenehmste Parsen (das ärgerlichste Parsen) zu vermeiden), da int x;  deklariert nicht nur, sondern definiert auch x.  Fügen Sie daher int nicht extern zu int x hinzu.  global ist so schlecht wie das Definieren einer Variablen, wenn sie extern deklariert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//   ,   extern int x{}; //      . extern int x; //      ,  </span></span></code> </pre> <br>  <i>Schlechtes Beispiel</i> <br><br>  Deklarieren wir eine Funktion <code>f</code> mit externem Link in file.hpp und definieren sie dort: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP extern int f(int x); /* ... */ int f(int) { return x + 1; } /* ... */ #endif /* FILE_HPP */</span></span></code> </pre> <br>  Bitte beachten Sie, dass Sie hier kein externes hinzufügen müssen, da alle Funktionen explizit extern sind.  Eine Trennung von Erklärung und Definition ist ebenfalls nicht erforderlich.  Schreiben wir es also einfach so um: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP int f(int) { return x + 1; } #endif /* FILE_HPP */</span></span></code> </pre> <br>  Ein solcher Code könnte vor dem Lesen dieses Artikels oder nach dem Lesen unter dem Einfluss von Alkohol oder schweren Substanzen (z. B. Zimtschnecken) geschrieben werden. <br><br>  Mal sehen, warum sich das nicht lohnt.  Jetzt haben wir zwei Implementierungsdateien: a.cpp und b.cpp, beide in file.hpp enthalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// b.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br>  Lassen Sie nun den Compiler arbeiten und generieren Sie zwei Übersetzungseinheiten für die beiden obigen Implementierungsdateien (denken Sie daran, dass <code>#include</code> wörtlich Kopieren / Einfügen bedeutet): <br><br><pre> <code class="plaintext hljs">// TU A, from a.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br><pre> <code class="plaintext hljs">// TU B, from b.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br>  Zu diesem Zeitpunkt greift der Linker ein (die Bindung erfolgt nach der Kompilierung).  Der Linker nimmt das Zeichen <code>f</code> und sucht nach einer Definition.  Heute hat er Glück, er findet bis zu zwei!  Einer in Übersetzungseinheit A, der andere in B. Der Linker friert vor Glück ein und sagt Ihnen so etwas: <br><br><pre> <code class="cpp hljs">duplicate symbol __Z1fv in: /path/to/ao /path/to/bo</code> </pre> <br>  Der Linker findet zwei Definitionen für ein <code>f</code> Zeichen.  Da <code>f</code> eine externe Bindung hat, ist sie für den Linker sichtbar, wenn sowohl A als auch B verarbeitet werden. Dies verstößt offensichtlich gegen die Regel einer Definition und verursacht einen Fehler.  Genauer gesagt führt dies zu einem doppelten Symbolfehler, den Sie nicht weniger als einen undefinierten Symbolfehler erhalten, der auftritt, wenn Sie ein Symbol deklarieren, aber vergessen haben, es zu definieren. <br><br>  <b>Verwenden Sie</b> <br><br>  Ein Standardbeispiel für die Deklaration externer Variablen sind globale Variablen.  Angenommen, Sie arbeiten an einem selbstbackenden Kuchen.  Sicherlich gibt es globale Variablen, die mit dem Kuchen verbunden sind und in verschiedenen Teilen Ihres Programms verfügbar sein sollten.  Angenommen, die Taktfrequenz eines essbaren Schaltkreises in Ihrem Kuchen.  Dieser Wert wird natürlich in verschiedenen Teilen für den Synchronbetrieb der gesamten Schokoladenelektronik benötigt.  Der (böse) C-Weg, eine solche globale Variable zu deklarieren, ist ein Makro: <br><br><pre> <code class="plaintext hljs">#define CLK 1000000</code> </pre><br>  Ein C ++ - Programmierer, der von Makros angewidert ist, schreibt echten Code besser.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// global.hpp namespace Global { extern unsigned int clock_rate; } // global.cpp namespace Global { unsigned int clock_rate = 1000000; }</span></span></code> </pre> <br>  (Ein moderner C ++ - Programmierer möchte Trennungsliterale verwenden: unsigned int clock_rate = 1'000'000;) <br><br>  <b>Gegensprechanlage</b> <br><br>  Wenn das Symbol eine interne Verbindung hat, ist es nur innerhalb der aktuellen Übersetzungseinheit sichtbar.  Verwechseln Sie Sichtbarkeit nicht mit Zugriffsrechten wie privat.  Sichtbarkeit bedeutet, dass der Linker dieses Symbol nur bei der Verarbeitung der Übersetzungseinheit verwenden kann, in der das Symbol deklariert wurde, und nicht später (wie bei Symbolen mit externer Kommunikation).  In der Praxis bedeutet dies, dass beim Deklarieren eines Symbols mit einem internen Link in der Header-Datei jede Broadcast-Einheit, die diese Datei enthält, eine eindeutige Kopie dieses Symbols erhält.  Als hätten Sie jedes dieser Symbole in jeder Übersetzungseinheit vorgegeben.  Für Objekte bedeutet dies, dass der Compiler jeder Übersetzungseinheit buchstäblich eine völlig neue, eindeutige Kopie zuweist, was natürlich zu hohen Speicherkosten führen kann. <br><br>  Um ein miteinander verbundenes Symbol zu deklarieren, ist das statische Schlüsselwort in C und C ++ vorhanden.  Diese Verwendung unterscheidet sich von der Verwendung von static in Klassen und Funktionen (oder im Allgemeinen in beliebigen Blöcken). <br><br>  <i>Beispiel</i> <br><br>  Hier ist ein Beispiel: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  file1.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file2.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file1.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function1() { variable = 10; }</span></span></code> </pre> <br><br>  file2.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function2() { variable = 123; }</span></span></code> </pre> <br>  main.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file2.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; auto main() -&gt; int { function1(); function2(); std::cout &lt;&lt; variable &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Jede Übersetzungseinheit, einschließlich header.hpp, erhält aufgrund ihrer internen Verbindung eine eindeutige Kopie der Variablen.  Es gibt drei Übersetzungseinheiten: <br><br><ol><li>  file1.cpp </li><li>  file2.cpp </li><li>  main.cpp </li></ol><br>  Wenn function1 aufgerufen wird, erhält eine Kopie der Variablen file1.cpp den Wert 10. Wenn function2 aufgerufen wird, erhält eine Kopie der Variablen file2.cpp den Wert 123. Der in main.cpp zurückgegebene Wert ändert sich jedoch nicht und bleibt gleich 42. <br><br>  <b>Anonyme Namespaces</b> <br><br>  In C ++ gibt es eine andere Möglichkeit, ein oder mehrere intern verknüpfte Zeichen zu deklarieren: anonyme Namespaces.  Ein solches Leerzeichen stellt sicher, dass die darin deklarierten Zeichen nur in der aktuellen Übersetzungseinheit sichtbar sind.  Im Wesentlichen ist dies nur eine Möglichkeit, mehrere statische Zeichen zu deklarieren.  Für eine Weile wurde die Verwendung des statischen Schlüsselworts zum Deklarieren eines intern verknüpften Zeichens zugunsten anonymer Namespaces aufgegeben.  Sie begannen jedoch erneut damit, eine Variable oder Funktion mit interner Kommunikation zu deklarieren.  Es gibt noch ein paar kleinere Unterschiede, auf die ich nicht näher eingehen werde. <br><br>  In jedem Fall ist dies: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Tut (fast) dasselbe wie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <b>Verwenden Sie</b> <br><br>  In welchen Fällen sollten interne Verbindungen verwendet werden?  Es ist eine schlechte Idee, sie für Objekte zu verwenden.  Der Speicherverbrauch großer Objekte kann aufgrund des Kopierens für jede Übersetzungseinheit sehr hoch sein.  Aber im Grunde verursacht es nur seltsames, unvorhersehbares Verhalten.  Stellen Sie sich vor, Sie haben einen Singleton (eine Klasse, in der Sie nur eine Instanz einer Instanz erstellen) und plötzlich erscheinen mehrere Instanzen Ihres „Singletons“ (eine für jede Übersetzungseinheit). <br><br>  Interne Kommunikation kann jedoch verwendet werden, um die Übersetzungseinheit vor dem globalen Bereich lokaler Hilfsfunktionen zu verbergen.  Angenommen, in file1.hpp gibt es eine foo-Hilfsfunktion, die Sie in file1.cpp verwenden.  Gleichzeitig haben Sie die Funktion foo in file2.hpp, die in file2.cpp verwendet wird.  Das erste und das zweite foo unterscheiden sich voneinander, aber Sie können sich keine anderen Namen einfallen lassen.  Daher können Sie sie als statisch deklarieren.  Wenn Sie nicht sowohl file1.hpp als auch file2.hpp zur selben Übersetzungseinheit hinzufügen, wird foo voneinander ausgeblendet.  Wenn dies nicht getan wird, haben sie implizit eine externe Verbindung und die Definition des ersten foo trifft auf die Definition des zweiten, was einen Linkerfehler über die Verletzung der Regel einer Definition verursacht. <br><br>  DAS ENDE <br><br>  Sie können hier jederzeit Ihre Kommentare und / oder Fragen hinterlassen oder uns an einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen Tür</a> besuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432834/">https://habr.com/ru/post/de432834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432824/index.html">Beschleunigung der Erstellung von ConcurrentReferenceHashMap</a></li>
<li><a href="../de432826/index.html">Moderne Android-Entwicklung auf Kotlin. Teil 2</a></li>
<li><a href="../de432828/index.html">Testen und Debuggen von MapReduce</a></li>
<li><a href="../de432830/index.html">Automatisiertes System zur Verhängung von Geldstrafen für verlassenen Müll</a></li>
<li><a href="../de432832/index.html">So "kleben" Sie einen Intel-basierten Server und überwinden die Scale-up-Obergrenze von 8 Prozessoren</a></li>
<li><a href="../de432836/index.html">Die erste gute Glühbirne von Aliexpress</a></li>
<li><a href="../de432838/index.html">Softwareentwicklung durch das Prisma des Milgram-Experiments "Submission to Authority"</a></li>
<li><a href="../de432840/index.html">So steigern Sie die Effektivität des Englischlernens und beginnen besser zu schreiben: Wählen Sie einen Online-Assistenten</a></li>
<li><a href="../de432842/index.html">Einige Hinweise zum Aufbau von Informationssystemen</a></li>
<li><a href="../de432844/index.html">Pre-Design-Umfrage bei der Entwicklung eines Informationssystems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>