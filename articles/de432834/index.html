<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèΩ üÜë üßñüèΩ Interne und externe Verkn√ºpfung in C ++ üõ´ ü§¨ üö•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle! 

 Wir pr√§sentieren Ihnen die √úbersetzung eines interessanten Artikels, der im Rahmen des Kurses "C ++ Developer" f√ºr Sie vorbereit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interne und externe Verkn√ºpfung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/432834/">  Guten Tag an alle! <br><br>  Wir pr√§sentieren Ihnen die √úbersetzung eines interessanten Artikels, der im Rahmen des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer"</a> f√ºr Sie vorbereitet wurde.  Wir hoffen, dass es sowohl f√ºr Sie als auch f√ºr unsere Zuh√∂rer n√ºtzlich und interessant sein wird. <br><br>  Lass uns gehen. <br><br>  Haben Sie jemals die Begriffe interne und externe Kommunikation kennengelernt?  M√∂chten Sie wissen, wof√ºr das Schl√ºsselwort extern verwendet wird oder wie sich die Deklaration von etwas Statischem auf den globalen Bereich auswirkt?  Dann ist dieser Artikel f√ºr Sie. <br><br>  <b>Kurzgesagt</b> <br><br>  Die √úbersetzungseinheit (.c / .cpp) und alle ihre Header-Dateien (.h / .hpp) sind in der √úbersetzungseinheit enthalten.  Wenn ein Objekt oder eine Funktion innerhalb einer √úbersetzungseinheit eine interne Bindung aufweist, ist dieses Symbol f√ºr den Linker nur innerhalb dieser √úbersetzungseinheit sichtbar.  Wenn das Objekt oder die Funktion einen externen Link hat, kann der Linker diesen sehen, wenn er andere √úbersetzungseinheiten verarbeitet.  Die Verwendung des statischen Schl√ºsselworts im globalen Namespace gibt dem Zeichen eine interne Bindung.  Das Schl√ºsselwort extern gibt eine externe Bindung an. <br>  Der Standard-Compiler gibt Zeichen die folgenden Bindungen: <br><br><ul><li>  Nicht konstante globale Variablen - externe Bindung; </li><li>  Const globale Variablen - interne Bindung; </li><li>  Funktionen - Externe Verkn√ºpfung. </li></ul><br><img src="https://habrastorage.org/webt/m5/bl/8d/m5bl8d7e6yb-7qlgsoqf8duzuku.png"><br><a name="habracut"></a><br>  <b>Die Grundlagen</b> <br><br>  Lassen Sie uns zun√§chst √ºber zwei einfache Konzepte sprechen, die zur Er√∂rterung der Bindung erforderlich sind. <br><br><ul><li>  Der Unterschied zwischen einer Erkl√§rung und einer Definition; </li><li>  Broadcast-Einheiten. </li></ul><br>  Achten Sie auch auf die Namen: Wir werden das Konzept des "Symbols" verwenden, wenn es um eine "Code-Entit√§t" geht, mit der der Linker arbeitet, beispielsweise mit einer Variablen oder Funktion (oder mit Klassen / Strukturen, aber wir werden uns nicht auf sie konzentrieren). <br><br>  <b>Ank√ºndigung VS.</b>  <b>Definition</b> <br><br>  Wir diskutieren kurz den Unterschied zwischen einer Deklaration und einer Symboldefinition: Eine Ansage (oder Deklaration) informiert den Compiler √ºber die Existenz eines bestimmten Symbols und erm√∂glicht den Zugriff auf dieses Symbol in F√§llen, in denen keine genaue Speicheradresse oder Symbolspeicherung erforderlich ist.  Die Definition teilt dem Compiler mit, was im Hauptteil der Funktion enthalten ist oder wie viel Speicher die Variable zuweisen muss. <br><br>  In einigen Situationen reicht eine Deklaration f√ºr den Compiler nicht aus, z. B. wenn ein Klassendatenelement eine Referenz oder einen Werttyp hat (dh keine Referenz und keinen Zeiger).  Gleichzeitig ist ein Zeiger auf einen deklarierten (aber nicht definierten) Typ zul√§ssig, da er unabh√§ngig vom Typ, auf den er verweist, eine feste Speichermenge ben√∂tigt (z. B. 8 Byte in 64-Bit-Systemen).  Um den Wert mit diesem Zeiger zu erhalten, ist eine Definition erforderlich.  Um eine Funktion zu deklarieren, m√ºssen Sie au√üerdem alle Parameter (unabh√§ngig davon, ob sie nach Wert, Referenz oder Zeiger verwendet werden) und den R√ºckgabetyp deklarieren (aber nicht definieren).  Das Bestimmen der Art des R√ºckgabewerts und der Parameter ist nur zum Definieren einer Funktion erforderlich. <br><br>  <b>Funktionen</b> <br><br>  Der Unterschied zwischen dem Definieren und Deklarieren einer Funktion ist sehr offensichtlich. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  int f() { return 42; } // </span></span></code> </pre> <br>  <b>Variablen</b> <br><br>  Bei Variablen ist das etwas anders.  Erkl√§rung und Definition werden normalerweise nicht geteilt.  Die Hauptsache ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x;</code> </pre> <br>  Deklariert nicht nur <code>x</code> , sondern definiert es auch.  Dies ist auf den Aufruf des Standardkonstruktors int zur√ºckzuf√ºhren.  (In C ++ initialisiert der Konstruktor einfacher Typen (z. B. int) im Gegensatz zu Java den Wert standardm√§√üig nicht auf 0. Im obigen Beispiel entspricht x dem M√ºll, der in der vom Compiler zugewiesenen Speicheradresse liegt.) <br><br>  Sie k√∂nnen die Variablendeklaration und ihre Definition jedoch explizit mit dem Schl√ºsselwort <code>extern</code> trennen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  int x = 42; // </span></span></code> </pre> <br>  Beim Initialisieren und Hinzuf√ºgen von <code>extern</code> zur Deklaration wird der Ausdruck jedoch zu einer Definition, und das Schl√ºsselwort <code>extern</code> wird unbrauchbar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,   int x = 5;</span></span></code> </pre> <br>  <b>Anzeigenvorschau</b> <br><br>  In C ++ gibt es das Konzept, ein Zeichen vorab zu deklarieren.  Dies bedeutet, dass wir den Typ und den Namen des Symbols f√ºr Situationen deklarieren, f√ºr die keine Definition erforderlich ist.  Daher m√ºssen wir nicht die vollst√§ndige Definition eines Zeichens (normalerweise eine Header-Datei) einschlie√üen, ohne dass dies offensichtlich erforderlich ist.  Somit reduzieren wir die Abh√§ngigkeit von der Datei, die die Definition enth√§lt.  Der Hauptvorteil besteht darin, dass beim √Ñndern einer Datei mit einer Definition die Datei, in der wir dieses Symbol vorl√§ufig deklarieren, nicht neu kompiliert werden muss (was bedeutet, dass alle anderen Dateien, einschlie√ülich dieser). <br><br>  <i>Beispiel</i> <br><br>  Angenommen, wir haben eine Funktionsdeklaration (als Prototyp bezeichnet) f√ºr f, die ein Objekt vom Typ <code>Class</code> nach Wert annimmt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp void f(Class object);</span></span></code> </pre> <br>  F√ºgen Sie sofort die Definition von <code>Class</code> - naiv hinzu.  Da wir gerade <code>f</code> deklariert haben, reicht es aus, dem Compiler eine Klassendeklaration zu geben.  Auf diese Weise kann der Compiler die Funktion an seinem Prototyp erkennen und die Abh√§ngigkeit von file.hpp von der Datei, die die Definition von <code>Class</code> , wie beispielsweise class.hpp, beseitigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp class Class; void f(Class object);</span></span></code> </pre> <br>  Angenommen, file.hpp ist in 100 anderen Dateien enthalten.  Nehmen wir an, wir √§ndern die Definition von Class in class.hpp.  Wenn Sie class.hpp zu file.hpp hinzuf√ºgen, m√ºssen file.hpp und alle 100 Dateien, die es enthalten, neu kompiliert werden.  Dank der vorl√§ufigen Deklaration von Class m√ºssen nur class.hpp und file.hpp neu kompiliert werden (vorausgesetzt, dort ist f definiert). <br><br>  <b>Verwendungsh√§ufigkeit</b> <br><br>  Ein wichtiger Unterschied zwischen einer Deklaration und einer Definition besteht darin, dass ein Symbol mehrmals deklariert, aber nur einmal definiert werden kann.  Sie k√∂nnen eine Funktion oder Klasse also beliebig oft vordeklarieren, es kann jedoch nur eine Definition geben.  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regel einer Definition bezeichnet</a> .  In C ++ funktioniert Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  Und das funktioniert nicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre><br>  <b>Broadcast-Einheiten</b> <br><br>  Programmierer arbeiten normalerweise mit Header- und Implementierungsdateien.  Aber keine Compiler - sie arbeiten mit √úbersetzungseinheiten (kurz √úbersetzungseinheiten - TU), die manchmal als Kompilierungseinheiten bezeichnet werden.  Die Definition einer solchen Einheit ist recht einfach: Jede Datei, die nach ihrer vorl√§ufigen Verarbeitung an den Compiler √ºbertragen wird.  Um genau zu sein, ist dies eine Datei, die aus der Arbeit eines Erweiterungsmakro-Pr√§prozessors resultiert, der Quellcode enth√§lt, der von den Ausdr√ºcken <code>#ifdef</code> und <code>#ifndef</code> abh√§ngt, und das Kopieren und Einf√ºgen aller <code>#include</code> Dateien. <br><br>  Folgende Dateien stehen zur Verf√ºgung: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> VALUE struct Foo { private: int ryan; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int strlen(const char* string); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* HEADER_HPP */</span></span></span></span></code> </pre> <br>  program.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> int strlen(const char* string) { int length = 0; while(string[length]) ++length; return length + VALUE; }</span></span></code> </pre> <br>  Der Pr√§prozessor erzeugt die folgende √úbersetzungseinheit, die dann an den Compiler √ºbergeben wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[length]) ++length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length + <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  <b>Kommunikation</b> <br><br>  Nachdem Sie die Grundlagen besprochen haben, k√∂nnen Sie die Beziehung beginnen.  Im Allgemeinen ist Kommunikation die Sichtbarkeit von Zeichen f√ºr den Linker bei der Verarbeitung von Dateien.  Die Kommunikation kann entweder extern oder intern erfolgen. <br><br>  <b>Externe Kommunikation</b> <br><br>  Wenn ein Symbol (Variable oder Funktion) eine externe Verbindung hat, wird es f√ºr Linker aus anderen Dateien sichtbar, dh "global" sichtbar und f√ºr alle √úbersetzungseinheiten zug√§nglich.  Dies bedeutet, dass Sie ein solches Symbol an einer bestimmten Stelle einer √úbersetzungseinheit definieren m√ºssen, normalerweise in der Implementierungsdatei (.c / .cpp), damit es nur eine sichtbare Definition hat.  Wenn Sie versuchen, das Symbol gleichzeitig mit der Deklaration des Symbols zu definieren, oder wenn Sie die Definition in eine Datei f√ºr die Deklaration einf√ºgen, besteht die Gefahr, dass Sie den Linker ver√§rgern.  Der Versuch, eine Datei zu mehr als einer Implementierungsdatei hinzuzuf√ºgen, f√ºhrt dazu, dass mehr als einer √úbersetzungseinheit eine Definition hinzugef√ºgt wird - Ihr Linker wird weinen. <br><br>  Das Schl√ºsselwort extern in C und C ++ deklariert (explizit), dass ein Zeichen eine externe Verbindung hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; argument)</span></span></span></span>;</code> </pre><br>  Beide Zeichen haben eine externe Verbindung.  Es wurde oben angemerkt, dass konstante globale Variablen standardm√§√üig eine interne Bindung haben, nicht konstante globale Variablen eine externe Bindung.  Dies bedeutet, dass int x;  - wie extern int x ;, richtig?  Nicht wirklich.  int x;  eigentlich analog zu extern int x {};  (Verwenden der Universal / Bracket-Initialisierungssyntax, um das unangenehmste Parsen (das √§rgerlichste Parsen) zu vermeiden), da int x;  deklariert nicht nur, sondern definiert auch x.  F√ºgen Sie daher int nicht extern zu int x hinzu.  global ist so schlecht wie das Definieren einer Variablen, wenn sie extern deklariert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//   ,   extern int x{}; //      . extern int x; //      ,  </span></span></code> </pre> <br>  <i>Schlechtes Beispiel</i> <br><br>  Deklarieren wir eine Funktion <code>f</code> mit externem Link in file.hpp und definieren sie dort: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP extern int f(int x); /* ... */ int f(int) { return x + 1; } /* ... */ #endif /* FILE_HPP */</span></span></code> </pre> <br>  Bitte beachten Sie, dass Sie hier kein externes hinzuf√ºgen m√ºssen, da alle Funktionen explizit extern sind.  Eine Trennung von Erkl√§rung und Definition ist ebenfalls nicht erforderlich.  Schreiben wir es also einfach so um: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP int f(int) { return x + 1; } #endif /* FILE_HPP */</span></span></code> </pre> <br>  Ein solcher Code k√∂nnte vor dem Lesen dieses Artikels oder nach dem Lesen unter dem Einfluss von Alkohol oder schweren Substanzen (z. B. Zimtschnecken) geschrieben werden. <br><br>  Mal sehen, warum sich das nicht lohnt.  Jetzt haben wir zwei Implementierungsdateien: a.cpp und b.cpp, beide in file.hpp enthalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// b.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br>  Lassen Sie nun den Compiler arbeiten und generieren Sie zwei √úbersetzungseinheiten f√ºr die beiden obigen Implementierungsdateien (denken Sie daran, dass <code>#include</code> w√∂rtlich Kopieren / Einf√ºgen bedeutet): <br><br><pre> <code class="plaintext hljs">// TU A, from a.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br><pre> <code class="plaintext hljs">// TU B, from b.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br>  Zu diesem Zeitpunkt greift der Linker ein (die Bindung erfolgt nach der Kompilierung).  Der Linker nimmt das Zeichen <code>f</code> und sucht nach einer Definition.  Heute hat er Gl√ºck, er findet bis zu zwei!  Einer in √úbersetzungseinheit A, der andere in B. Der Linker friert vor Gl√ºck ein und sagt Ihnen so etwas: <br><br><pre> <code class="cpp hljs">duplicate symbol __Z1fv in: /path/to/ao /path/to/bo</code> </pre> <br>  Der Linker findet zwei Definitionen f√ºr ein <code>f</code> Zeichen.  Da <code>f</code> eine externe Bindung hat, ist sie f√ºr den Linker sichtbar, wenn sowohl A als auch B verarbeitet werden. Dies verst√∂√üt offensichtlich gegen die Regel einer Definition und verursacht einen Fehler.  Genauer gesagt f√ºhrt dies zu einem doppelten Symbolfehler, den Sie nicht weniger als einen undefinierten Symbolfehler erhalten, der auftritt, wenn Sie ein Symbol deklarieren, aber vergessen haben, es zu definieren. <br><br>  <b>Verwenden Sie</b> <br><br>  Ein Standardbeispiel f√ºr die Deklaration externer Variablen sind globale Variablen.  Angenommen, Sie arbeiten an einem selbstbackenden Kuchen.  Sicherlich gibt es globale Variablen, die mit dem Kuchen verbunden sind und in verschiedenen Teilen Ihres Programms verf√ºgbar sein sollten.  Angenommen, die Taktfrequenz eines essbaren Schaltkreises in Ihrem Kuchen.  Dieser Wert wird nat√ºrlich in verschiedenen Teilen f√ºr den Synchronbetrieb der gesamten Schokoladenelektronik ben√∂tigt.  Der (b√∂se) C-Weg, eine solche globale Variable zu deklarieren, ist ein Makro: <br><br><pre> <code class="plaintext hljs">#define CLK 1000000</code> </pre><br>  Ein C ++ - Programmierer, der von Makros angewidert ist, schreibt echten Code besser.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// global.hpp namespace Global { extern unsigned int clock_rate; } // global.cpp namespace Global { unsigned int clock_rate = 1000000; }</span></span></code> </pre> <br>  (Ein moderner C ++ - Programmierer m√∂chte Trennungsliterale verwenden: unsigned int clock_rate = 1'000'000;) <br><br>  <b>Gegensprechanlage</b> <br><br>  Wenn das Symbol eine interne Verbindung hat, ist es nur innerhalb der aktuellen √úbersetzungseinheit sichtbar.  Verwechseln Sie Sichtbarkeit nicht mit Zugriffsrechten wie privat.  Sichtbarkeit bedeutet, dass der Linker dieses Symbol nur bei der Verarbeitung der √úbersetzungseinheit verwenden kann, in der das Symbol deklariert wurde, und nicht sp√§ter (wie bei Symbolen mit externer Kommunikation).  In der Praxis bedeutet dies, dass beim Deklarieren eines Symbols mit einem internen Link in der Header-Datei jede Broadcast-Einheit, die diese Datei enth√§lt, eine eindeutige Kopie dieses Symbols erh√§lt.  Als h√§tten Sie jedes dieser Symbole in jeder √úbersetzungseinheit vorgegeben.  F√ºr Objekte bedeutet dies, dass der Compiler jeder √úbersetzungseinheit buchst√§blich eine v√∂llig neue, eindeutige Kopie zuweist, was nat√ºrlich zu hohen Speicherkosten f√ºhren kann. <br><br>  Um ein miteinander verbundenes Symbol zu deklarieren, ist das statische Schl√ºsselwort in C und C ++ vorhanden.  Diese Verwendung unterscheidet sich von der Verwendung von static in Klassen und Funktionen (oder im Allgemeinen in beliebigen Bl√∂cken). <br><br>  <i>Beispiel</i> <br><br>  Hier ist ein Beispiel: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  file1.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file2.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file1.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function1() { variable = 10; }</span></span></code> </pre> <br><br>  file2.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function2() { variable = 123; }</span></span></code> </pre> <br>  main.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file2.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; auto main() -&gt; int { function1(); function2(); std::cout &lt;&lt; variable &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Jede √úbersetzungseinheit, einschlie√ülich header.hpp, erh√§lt aufgrund ihrer internen Verbindung eine eindeutige Kopie der Variablen.  Es gibt drei √úbersetzungseinheiten: <br><br><ol><li>  file1.cpp </li><li>  file2.cpp </li><li>  main.cpp </li></ol><br>  Wenn function1 aufgerufen wird, erh√§lt eine Kopie der Variablen file1.cpp den Wert 10. Wenn function2 aufgerufen wird, erh√§lt eine Kopie der Variablen file2.cpp den Wert 123. Der in main.cpp zur√ºckgegebene Wert √§ndert sich jedoch nicht und bleibt gleich 42. <br><br>  <b>Anonyme Namespaces</b> <br><br>  In C ++ gibt es eine andere M√∂glichkeit, ein oder mehrere intern verkn√ºpfte Zeichen zu deklarieren: anonyme Namespaces.  Ein solches Leerzeichen stellt sicher, dass die darin deklarierten Zeichen nur in der aktuellen √úbersetzungseinheit sichtbar sind.  Im Wesentlichen ist dies nur eine M√∂glichkeit, mehrere statische Zeichen zu deklarieren.  F√ºr eine Weile wurde die Verwendung des statischen Schl√ºsselworts zum Deklarieren eines intern verkn√ºpften Zeichens zugunsten anonymer Namespaces aufgegeben.  Sie begannen jedoch erneut damit, eine Variable oder Funktion mit interner Kommunikation zu deklarieren.  Es gibt noch ein paar kleinere Unterschiede, auf die ich nicht n√§her eingehen werde. <br><br>  In jedem Fall ist dies: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Tut (fast) dasselbe wie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <b>Verwenden Sie</b> <br><br>  In welchen F√§llen sollten interne Verbindungen verwendet werden?  Es ist eine schlechte Idee, sie f√ºr Objekte zu verwenden.  Der Speicherverbrauch gro√üer Objekte kann aufgrund des Kopierens f√ºr jede √úbersetzungseinheit sehr hoch sein.  Aber im Grunde verursacht es nur seltsames, unvorhersehbares Verhalten.  Stellen Sie sich vor, Sie haben einen Singleton (eine Klasse, in der Sie nur eine Instanz einer Instanz erstellen) und pl√∂tzlich erscheinen mehrere Instanzen Ihres ‚ÄûSingletons‚Äú (eine f√ºr jede √úbersetzungseinheit). <br><br>  Interne Kommunikation kann jedoch verwendet werden, um die √úbersetzungseinheit vor dem globalen Bereich lokaler Hilfsfunktionen zu verbergen.  Angenommen, in file1.hpp gibt es eine foo-Hilfsfunktion, die Sie in file1.cpp verwenden.  Gleichzeitig haben Sie die Funktion foo in file2.hpp, die in file2.cpp verwendet wird.  Das erste und das zweite foo unterscheiden sich voneinander, aber Sie k√∂nnen sich keine anderen Namen einfallen lassen.  Daher k√∂nnen Sie sie als statisch deklarieren.  Wenn Sie nicht sowohl file1.hpp als auch file2.hpp zur selben √úbersetzungseinheit hinzuf√ºgen, wird foo voneinander ausgeblendet.  Wenn dies nicht getan wird, haben sie implizit eine externe Verbindung und die Definition des ersten foo trifft auf die Definition des zweiten, was einen Linkerfehler √ºber die Verletzung der Regel einer Definition verursacht. <br><br>  DAS ENDE <br><br>  Sie k√∂nnen hier jederzeit Ihre Kommentare und / oder Fragen hinterlassen oder uns an einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen T√ºr</a> besuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432834/">https://habr.com/ru/post/de432834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432824/index.html">Beschleunigung der Erstellung von ConcurrentReferenceHashMap</a></li>
<li><a href="../de432826/index.html">Moderne Android-Entwicklung auf Kotlin. Teil 2</a></li>
<li><a href="../de432828/index.html">Testen und Debuggen von MapReduce</a></li>
<li><a href="../de432830/index.html">Automatisiertes System zur Verh√§ngung von Geldstrafen f√ºr verlassenen M√ºll</a></li>
<li><a href="../de432832/index.html">So "kleben" Sie einen Intel-basierten Server und √ºberwinden die Scale-up-Obergrenze von 8 Prozessoren</a></li>
<li><a href="../de432836/index.html">Die erste gute Gl√ºhbirne von Aliexpress</a></li>
<li><a href="../de432838/index.html">Softwareentwicklung durch das Prisma des Milgram-Experiments "Submission to Authority"</a></li>
<li><a href="../de432840/index.html">So steigern Sie die Effektivit√§t des Englischlernens und beginnen besser zu schreiben: W√§hlen Sie einen Online-Assistenten</a></li>
<li><a href="../de432842/index.html">Einige Hinweise zum Aufbau von Informationssystemen</a></li>
<li><a href="../de432844/index.html">Pre-Design-Umfrage bei der Entwicklung eines Informationssystems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>