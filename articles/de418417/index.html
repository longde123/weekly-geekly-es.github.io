<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍️ 🧕🏿 👴 Apollo: 9 Monate - normaler Flug 💅🏿 🍷 🧑🏻‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, mein Name ist Semyon Levenson, ich arbeite als Teamleiter am Stream- Projekt der Rambler Group und möchte über unsere Erfahrungen mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apollo: 9 Monate - normaler Flug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rambler-co/blog/418417/"><p><img src="https://habrastorage.org/webt/ww/0p/je/ww0pjeoegdfxhlx-zfh54jbxvyw.png" alt="Bild"></p><br><p>  Hallo allerseits, mein Name ist Semyon Levenson, ich arbeite als Teamleiter am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-</a> Projekt der Rambler Group und möchte über unsere Erfahrungen mit Apollo sprechen. </p><br><p>  Ich werde erklären, was der "Stream" ist.  Dies ist ein automatisierter Service für Unternehmer, mit dem Sie Kunden aus dem Internet für das Geschäft gewinnen können, ohne sich auf Werbung einzulassen, und schnell einfache Websites erstellen können, ohne ein Experte für Layout zu sein. </p><a name="habracut"></a><br><p>  Der Screenshot zeigt einen der Schritte zum Erstellen einer Zielseite. </p><br><p><img src="https://habrastorage.org/webt/rf/vg/dj/rfvgdjmcvzpwydgz9qcdu8_3eay.png"></p><br><h3 id="chto-bylo-vnachale">  Was war der Anfang? </h3><br><p> Und am Anfang gab es MVP, viele Twig, jQuery und sehr enge Fristen.  Aber wir gingen einen nicht standardmäßigen Weg und beschlossen, ein Redesign vorzunehmen.  Das Redesign ist nicht im Sinne von "gepatchten Stilen", sondern hat beschlossen, das System vollständig zu überprüfen.  Und dies war eine gute Bühne für uns, um das perfekte Frontend zusammenzustellen.  Schließlich unterstützen wir als Entwicklungsteam dies weiterhin und setzen auf dieser Grundlage weitere Aufgaben um, um neue vom Produktteam gesetzte Ziele zu erreichen. </p><br><p>  Unsere Abteilung hat bereits genügend Fachwissen in der Verwendung von React gesammelt.  Ich wollte keine 2 Wochen damit verbringen, das Webpack einzurichten, deshalb habe ich mich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRA</a> (Create React App) entschieden.  Für Stile wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styled Components verwendet</a> , und wo ohne Eingabe - sie nahmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow</a> .  Sie haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux</a> für das State Management genommen, aber als Ergebnis stellte sich heraus, dass wir es überhaupt nicht brauchen, aber dazu später mehr. </p><br><p>  Wir stellten unser perfektes Frontend zusammen und stellten fest, dass wir etwas vergessen hatten.  Wie sich herausstellte, haben wir das Backend oder vielmehr die Interaktion damit vergessen.  Als Sie darüber nachdachten, wie wir diese Interaktion organisieren können, fiel Ihnen als Erstes natürlich Ruhe ein.  Nein, wir haben uns nicht ausgeruht (lächeln), sondern über die RESTful-API gesprochen.  Im Prinzip ist die Geschichte bekannt, erstreckt sich über eine lange Zeit, aber wir kennen auch die Probleme damit.  Wir werden darüber reden. </p><br><p>  Das erste Problem ist die Dokumentation.  RESTful sagt natürlich nicht aus, wie die Dokumentation zu organisieren ist.  Hier besteht die Möglichkeit, dieselbe Prahlerei zu verwenden, aber tatsächlich ist es die Einführung einer zusätzlichen Entität und die Komplikation von Prozessen. </p><br><p>  Das zweite Problem besteht darin, die Unterstützung für die Versionierung der API zu organisieren. </p><br><p>  Das dritte wichtige Problem ist eine große Anzahl von Abfragen oder benutzerdefinierten Endpunkten, die wir belohnen können.  Angenommen, wir müssen Beiträge für diese Beiträge anfordern - Kommentare und weitere Autoren dieser Kommentare.  Im klassischen Rest müssen wir mindestens 3 Abfragen machen.  Ja, wir können benutzerdefinierte Endpunkte belohnen, und all dies kann auf eine Anfrage reduziert werden, aber dies ist bereits eine Komplikation. </p><br><p><img src="https://habrastorage.org/webt/mo/os/uv/moosuvdayfwhr7r2dqswlg9nuuk.png"><br>  <em>Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sashko Stubailo</a> für die Illustration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a></em> </p><br><h3 id="reshenie">  Lösung </h3><br><p>  Und in diesem Moment hilft uns Facebook mit GraphQL.  Was ist GraphQL?  Dies ist eine Plattform, aber heute werden wir uns einen ihrer Teile ansehen - dies ist die Abfragesprache für Ihre API, nur eine Sprache und eine ziemlich primitive.  Und es funktioniert so einfach wie möglich - da wir eine Art Entität anfordern, bekommen wir es auch. </p><br><p>  Anfrage: </p><br><pre><code class="hljs objectivec">{ me { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> isAcceptedFreeOffer balance } }</code> </pre> <br><p>  Die Antwort lautet: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"me"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"balance"</span></span>: <span class="hljs-number"><span class="hljs-number">100000</span></span> } }</code> </pre> <br><p>  Bei GraphQL geht es aber nicht nur ums Lesen, sondern auch um das Ändern von Daten.  Dazu gibt es Mutationen in GraphQL.  Mutationen sind insofern bemerkenswert, als wir die gewünschte Antwort vom Backend mit einer erfolgreichen Änderung deklarieren können.  Es gibt jedoch einige Nuancen.  Zum Beispiel, wenn unsere Mutation Daten außerhalb der Grenzen des Diagramms beeinflusst. </p><br><p>  Ein Beispiel für eine Mutation, bei der wir ein kostenloses Angebot verwenden: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">mutation</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">acceptOffer</span></span> (_type: FREE) { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> isAcceptedFreeOffer } }</code> </pre> <br><p>  Als Antwort erhalten wir die gleiche Struktur, die angefordert wurde </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"acceptOffer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p>  Die Interaktion mit dem GraphQL-Backend kann mithilfe des regulären Abrufs erfolgen. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, body: <span class="hljs-type"><span class="hljs-type">JSON</span></span>.stringify({ query: <span class="hljs-string"><span class="hljs-string">'{me { id balance } }'</span></span> }) });</code> </pre> <br><h3 id="kakie-zhe-plyusy-u-graphql">  Was sind die Vorteile von GraphQL? </h3><br><p>  Das erste und sehr coole Plus, das Sie zu Beginn Ihrer Arbeit zu schätzen wissen, ist, dass diese Sprache stark typisiert und selbstdokumentierend ist.  Durch das Entwerfen des GraphQL-Schemas auf dem Server können Typen und Attribute sofort direkt im Code beschrieben werden. </p><br><p><img src="https://habrastorage.org/webt/7l/oh/ze/7lohze1ioujv7qchctics80_qd8.png"></p><br><p>  Wie oben erwähnt, hat RESTful ein Versionsproblem.  GraphQL hat dafür eine sehr elegante Lösung implementiert - veraltet. </p><br><p><img src="https://habrastorage.org/webt/zr/la/rr/zrlarrevkaenkyjdx7yzm6wbm5a.png"></p><br><p>  Angenommen, wir haben einen Film, wir erweitern ihn, also haben wir einen Regisseur.  Und irgendwann machen wir den Regisseur einfach zu einem separaten Typ.  Die Frage ist, was mit dem letzten Director-Feld zu tun ist.  Es gibt zwei Antworten: Entweder löschen wir dieses Feld oder wir markieren es als veraltet und es verschwindet automatisch aus der Dokumentation. </p><br><p>  Wir entscheiden unabhängig, was wir brauchen. </p><br><p>  Wir erinnern uns an das vorherige Bild, in dem alles mit REST ging, aber hier ist alles in einer Anfrage zusammengefasst und erfordert keine Anpassung durch die Backend-Entwicklung.  Sobald sie es alle beschrieben haben und wir uns drehen, drehen, jonglieren. </p><br><p><img src="https://habrastorage.org/webt/k2/rs/rp/k2rsrp234e3xoe6gs8jmwpy1rse.png"></p><br><p>  Aber nicht ohne eine Fliege in der Salbe.  Grundsätzlich weist GraphQL im Frontend nicht so viele Nachteile auf, da es ursprünglich entwickelt wurde, um Frontend-Probleme zu lösen.  Aber das Backend läuft nicht so reibungslos ... Sie haben ein Problem wie N + 1.  Nehmen Sie die Abfrage als Beispiel: </p><br><pre> <code class="hljs objectivec">{ landings(_page: <span class="hljs-number"><span class="hljs-number">0</span></span>, limit: <span class="hljs-number"><span class="hljs-number">20</span></span>) { nodes { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> title } totalCount } }</code> </pre> <br><p>  Eine einfache Anfrage, wir fordern 20 Websites und die Anzahl der Websites, die wir haben.  Im Backend können daraus 21 Datenbankabfragen werden.  Dieses Problem ist bekannt, gelöst.  Für Node JS gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenlader-</a> Paket von Facebook.  Für andere Sprachen können Sie Ihre eigenen Lösungen finden. </p><br><p>  Es gibt auch das Problem der tiefen Verschachtelung.  Zum Beispiel haben wir Alben, diese Alben haben Songs und durch den Song können wir auch Alben bekommen.  Stellen Sie dazu folgende Abfragen: </p><br><pre> <code class="hljs objectivec">{ album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { title artists } } }</code> </pre> <br><pre> <code class="hljs dos">{ song(id: <span class="hljs-number"><span class="hljs-number">1337</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> album { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br><p>  Somit erhalten wir eine rekursive Abfrage, die uns auch elementar eine Basis legt. </p><br><pre> <code class="hljs objectivec">query evil { album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { album { songs { album {</code> </pre> <br><p>  Dieses Problem ist ebenfalls bekannt. Die Lösung für Node JS ist die GraphQL-Tiefenbegrenzung. Für andere Sprachen gibt es ebenfalls Lösungen. </p><br><p>  Daher haben wir uns für GraphQL entschieden.  Es ist Zeit, eine Bibliothek auszuwählen, die mit der GraphQL-API funktioniert.  Das oben gezeigte Beispiel in einigen Zeilen mit Abruf ist nur ein Transport.  Dank des Schemas und der Deklarativität können wir aber auch Abfragen an der Vorderseite zwischenspeichern und mit dem GraphQL-Backend mit höherer Leistung arbeiten. </p><br><p>  Wir haben also zwei Hauptakteure - Relay und Apollo. </p><br><h3 id="relay">  Relais </h3><br><p>  Relay ist eine Facebook-Entwicklung, die sie selbst nutzen.  Wie Oculus, Circle CI, Arsti und Friday. </p><br><h4 id="kakie-plyusy-est-u-relay">  Was sind die Vorteile von Relay? </h4><br><p>  Das unmittelbare Plus ist, dass der Entwickler Facebook ist.  React, Flow und GraphQL sind Facebook-Entwicklungen, bei denen es sich um Puzzles handelt, die auf einander zugeschnitten sind.  Wo sind wir ohne Sterne auf Github, Relay hat fast 11.000, Apollo hat 7600 zum Vergleich. Das Coole, was Relay hat, ist Relay-Compiler, ein Tool, das Ihre GraphQL-Abfragen auf Build-Ebene Ihres Projekts optimiert und analysiert .  Wir können davon ausgehen, dass dies nur für GraphQL hässlich ist: </p><br><pre> <code class="hljs scala">#  <span class="hljs-type"><span class="hljs-type">Relay</span></span>-compiler foo { # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span></span>{ # matches the parent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extraneous</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">#</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span></span>{ id }</code> </pre> <br><h4 id="kakie-minusy-u-relay">  Was sind die Nachteile von Relay? </h4><br><p>  Das erste Minus * ist das Fehlen einer sofort einsatzbereiten SSR.  Github hat noch ein offenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> .  Warum unter dem Sternchen - weil es bereits Lösungen gibt, diese aber von Drittanbietern stammen und darüber hinaus ziemlich zweideutig sind. </p><br><p><img src="https://habrastorage.org/webt/ee/1b/rc/ee1brchbmmgdpqka4kpf3ogo2my.png"></p><br><p>  Auch hier ist Relais eine Spezifikation.  Tatsache ist, dass GraphQL bereits eine Spezifikation ist und Relay eine Spezifikation über einer Spezifikation ist. </p><br><p><img src="https://habrastorage.org/webt/f6/ds/nl/f6dsnlwzog77hrwpboaru95u7_y.png"></p><br><p>  Beispielsweise wird die Relay-Paginierung anders implementiert. Hier werden Cursor angezeigt. </p><br><pre> <code class="hljs pgsql">{ friends(first: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">after</span></span>: "opaqueCursor") { edges { <span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> node { id <span class="hljs-type"><span class="hljs-type">name</span></span> } } pageInfo { hasNextPage } } }</code> </pre> <br><p>  Wir verwenden nicht mehr die üblichen Offsets und Limits.  Für Feeds im Feed ist dies ein großartiges Thema, aber wenn wir anfangen, alle Arten von Gittern zu erstellen, gibt es Schmerzen. </p><br><p>  Facebook löste sein Problem, indem es eine Bibliothek für React schrieb.  Es gibt Lösungen für andere Bibliotheken, zum Beispiel für vue.js - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vue-Relay</a> .  Aber wenn wir auf die Anzahl der Sterne und Commits achten, dann ist auch hier nicht alles so glatt und kann instabil sein.  Beispielsweise verhindert die Create React App aus dem CRA-Feld, dass Sie den Relay-Compiler verwenden können.  Sie können diese Einschränkung jedoch mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-App-Rewired umgehen</a> . </p><br><p><img src="https://habrastorage.org/webt/dj/wb/i2/djwbi2it6brz4qxdipg0wcdyhpa.png"></p><br><h2 id="apollo">  Apollo </h2><br><p>  Unser zweiter Kandidat ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apollo</a> .  Entwickelt von seinem Team <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meteor</a> .  Apollo verwendet so bekannte Befehle wie: AirBnB, Ticketmaster, Opentable usw. </p><br><h3 id="kakie-est-plyusy-u-apollo">  Was sind die Vorteile von Apollo? </h3><br><p>  Das erste bedeutende Plus ist, dass Apollo als Framework-Agnostic-Bibliothek entwickelt wurde.  Wenn wir jetzt beispielsweise alles auf Angular neu schreiben möchten, ist dies kein Problem. Apollo arbeitet damit.  Und Sie können sogar alles in Vanille schreiben. </p><br><p>  Apollo hat eine coole Dokumentation, es gibt fertige Lösungen für häufig auftretende Probleme. </p><br><p><img src="https://habrastorage.org/webt/tq/wu/ko/tqwukoydh-b7fem6dwusyuwklgw.png"></p><br><p>  Ein weiteres Plus Apollo - eine leistungsstarke API.  Im Prinzip finden diejenigen, die mit Redux gearbeitet haben, hier gemeinsame Ansätze: Es gibt ApolloProvider (wie Provux für Redux), und anstelle von Apollo wird dies als Client bezeichnet: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloProvider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ApolloClient'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">client</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{ApolloClient}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><p>  Auf der Ebene der Komponente selbst haben wir graphql HOC als Verbindung bereitgestellt.  Und wir schreiben die GraphQL-Abfrage bereits in MapStateToProps in Redux. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { graphql } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gql <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Landing } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Landing'</span></span>; graphql(gql<span class="hljs-string"><span class="hljs-string">` { landing(id: 1) { id title } } `</span></span>)(Landing);</code> </pre> <br><p>  Wenn wir jedoch MapStateToProps in Redux ausführen, erfassen wir die lokalen Daten.  Wenn keine lokalen Daten vorhanden sind, geht Apollo selbst zum Server.  Sehr praktische Requisiten fallen in die Komponente selbst. </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ data, loading, error, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Das: <br>  • Daten; <br>  • Download-Status; <br>  • ein Fehler, wenn er aufgetreten ist; <br>  Hilfsfunktionen wie Refetch zum erneuten Laden von Daten oder FetchMore zum Paginieren.  Es gibt auch ein großes Plus für Apollo und Relay, nämlich die optimistische Benutzeroberfläche.  Sie können das Rückgängigmachen / Wiederherstellen auf Anforderungsebene festlegen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.setNotificationStatusMutation({ variables: { … }, optimisticResponse: { … } });</code> </pre> <br><p>  Zum Beispiel klickte der Benutzer auf die Schaltfläche "Gefällt mir" und das "Gefällt mir" zählte sofort.  In diesem Fall wird im Hintergrund eine Anfrage an den Server gesendet.  Wenn während des Sendevorgangs ein Fehler auftritt, kehren die veränderlichen Daten von selbst in ihren ursprünglichen Zustand zurück. </p><br><p>  Das serverseitige Rendern ist gut implementiert, wir setzen ein Flag auf dem Client und alles ist bereit. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ApolloClient</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">ssrMode</span></span>: true, ... });</code> </pre> <br><p>  Aber hier möchte ich über den Anfangszustand sprechen.  Wenn Apollo es selbst kocht, funktioniert alles gut. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = client.extract(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Wir haben jedoch kein serverseitiges Rendering und das Backend verschiebt eine bestimmte GraphQL-Abfrage in die globale Variable.  Hier benötigen Sie eine kleine Krücke, Sie müssen eine Transformationsfunktion schreiben, damit die GraphQL-Antwort vom Backend bereits das für Apollo benötigte Format annimmt. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = transform({…}); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Ein weiteres Plus von Apollo ist, dass es gut anpassbar ist.  Wir alle erinnern uns an Middleware von Redux, hier ist alles gleich, nur das nennt man Link. </p><br><p><img src="https://habrastorage.org/webt/va/gw/-z/vagw-zeeg2j0t7pjuawtw4tllq8.png"></p><br><p>  Ich möchte zwei Links separat erwähnen: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apollo-Link-Status</a> , der zum Speichern des lokalen Status in Abwesenheit von Redux benötigt wird, und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apollo-Link-Rest</a> , wenn wir GraphQL-Abfragen in die Rest-API schreiben möchten.  Bei letzteren müssen Sie jedoch äußerst vorsichtig sein, weil  Es können bestimmte Probleme auftreten. </p><br><h4 id="minusy-u-apollo-tozhe-est">  Apollo hat auch Nachteile </h4><br><p>  Schauen wir uns ein Beispiel an.  Es gab ein unerwartetes Leistungsproblem: 2.000 Elemente wurden im Frontend angefordert (es war ein Verzeichnis), und Leistungsprobleme wurden gestartet.  Nachdem es im Debugger angezeigt wurde, stellte sich heraus, dass Apollo beim Lesen viele Ressourcen verschlingt. Das Problem ist im Grunde genommen geschlossen. Jetzt ist alles in Ordnung, aber es gab eine solche Sünde. </p><br><p>  Auch das erneute Abrufen erwies sich als sehr offensichtlich ... </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ loading, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Es scheint, dass bei einer erneuten Datenanforderung das Laden wahr werden sollte, wenn die vorherige Anforderung mit einem Fehler endete.  Aber nein! </p><br><p>  Dazu müssen Sie notifyOnNetworkStatusChange: true im graphql-HOC angeben oder den Neuabrufstatus lokal speichern. </p><br><h3 id="apollo-vs-relay">  Apollo vs.  Relais </h3><br><p>  So haben wir einen solchen Tisch bekommen, wir haben alle gewogen, gezählt und wir hatten 76% hinter Apollo. </p><br><p><img src="https://habrastorage.org/webt/ry/if/wx/ryifwxtkdmb4yvc2xczme5xoqkc.png"></p><br><p>  Also haben wir uns für die Bibliothek entschieden und sind zur Arbeit gegangen. </p><br><p>  Aber ich möchte mehr über die Toolchain sagen. </p><br><p>  Hier ist alles sehr gut, es gibt verschiedene Add-Ons für Redakteure, irgendwo besser, irgendwo schlechter.  Es gibt auch Apollo-Codegen, das nützliche Dateien, z. B. Flusstypen, generiert und das Schema grundsätzlich aus der GraphQL-API abruft. </p><br><h3 id="rubrika-ochumelye-ruchki-ili-chto-my-sdelali-u-sebya">  Die Überschrift "Crazy Hands" oder was wir zu Hause gemacht haben </h3><br><p>  Das erste, was uns begegnete, war, dass wir grundsätzlich Daten anfordern müssen. </p><br><pre> <code class="hljs lisp">graphql(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>)(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Wir haben gemeinsame Bedingungen: Laden, Fehlerbehandlung.  Wir haben unseren eigenen Falken (asyncCard) geschrieben, der über die Zusammensetzung von graqhql und asyncCard verbunden ist. </p><br><pre> <code class="hljs lisp">compose( <span class="hljs-name"><span class="hljs-name">graphql</span></span>(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>), AsyncCard )(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Ich möchte auch über Fragmente sprechen.  Es gibt eine LandingItem-Komponente, die weiß, welche Daten sie von der GraphQL-API benötigt.  Wir haben die Fragment-Eigenschaft festgelegt, in der wir die Felder der Landing-Entität angegeben haben. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); LandingItem.fragment = gql<span class="hljs-string"><span class="hljs-string">` fragment LandingItem on Landing { ... } `</span></span>;</code> </pre> <br><p>  Auf der Ebene der Komponentennutzung verwenden wir nun das Fragment in der endgültigen Anforderung. </p><br><pre> <code class="hljs bash">query LandingsDashboard { landings(...) { nodes { ...LandingItem } totalCount } <span class="hljs-variable"><span class="hljs-variable">${LandingItem.Fragment}</span></span> }</code> </pre> <br><p>  Nehmen wir an, eine Aufgabe fliegt ein, um dieser Zielseite den Status hinzuzufügen - kein Problem.  Wir fügen dem Rendering und dem Fragment eine Eigenschaft hinzu.  Und alles ist fertig.  Prinzip der Einzelverantwortung in seiner ganzen Pracht. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStatus</span></span></span></span><span class="xml"><span class="hljs-tag"> … /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); LandingItem.fragment = gql` fragment LandingItem on Landing { ... status } `;</span></span></code> </pre> <br><h4 id="kakaya-u-nas-esche-byla-problema">  Welches andere Problem hatten wir? </h4><br><p>  Wir haben eine Reihe von Widgets auf unserer Website, die ihre individuellen Anfragen gestellt haben. </p><br><p><img src="https://habrastorage.org/webt/ab/li/-x/abli-xjzcmoq9_p2rtnorl-y3qu.png"></p><br><p>  Während des Tests stellte sich heraus, dass dies alles langsamer wird.  Wir haben sehr lange Sicherheitskontrollen und jede Anfrage ist sehr teuer.  Dies stellte sich auch als kein Problem heraus, es gibt Apollo-Link-Batch-http </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BatchHttpLink</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">batchMax</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, batchInterval: <span class="hljs-number"><span class="hljs-number">10</span></span> });</code> </pre> <br><p>  Es ist wie folgt konfiguriert: Wir übergeben die Anzahl der Anforderungen, die wir kombinieren können, und wie lange dieser Link wartet, nachdem die erste Anforderung angezeigt wurde. <br>  Und es stellte sich so heraus: Gleichzeitig wird alles geladen und gleichzeitig kommt alles.  Es ist anzumerken, dass, wenn während dieser Zusammenführung eine der Unterabfragen mit einem Fehler zurückgegeben wird, der Fehler nur bei ihm und nicht bei der gesamten Anforderung auftritt. </p><br><h4 id="hochetsya-otdelno-rasskazat-chto-proshloy-osenyu-proizoshlo-obnovlenie-s-pervogo-apollo-na-vtoroy">  Ich möchte separat sagen, dass es im letzten Herbst ein Update vom ersten Apollo zum zweiten gab </h4><br><p>  Am Anfang waren Apollo und Redux </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span></code> </pre> <br><p>  Dann wurde Apollo modularer und erweiterbarer, diese Module können unabhängig voneinander entwickelt werden.  Das gleiche Apollo-Cache-Gedächtnis. </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-client'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-link-batch-http'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-cache-inmemory'</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span></code> </pre> <br><p>  Es ist erwähnenswert, dass Redux nicht benötigt wird und wie sich herausstellte, im Prinzip nicht benötigt wird. </p><br><h2 id="vyvody">  Schlussfolgerungen: </h2><br><ol><li>  Die Bereitstellungszeit für Funktionen hat sich verringert. Wir verschwenden keine Zeit damit, Aktionen zu beschreiben, Redux zu reduzieren und das Backend weniger zu berühren </li><li>  Antifragilität erschien, weil  Durch die statische Analyse der API können Sie die Probleme aufheben, wenn das Frontend eine Sache erwartet und das Backend eine völlig andere zurückgibt. </li><li>  Wenn Sie mit GraphQL arbeiten - versuchen Sie es mit Apollo. Seien Sie nicht enttäuscht. </li></ol><br><p>  PS Sie können sich auch ein Video von meiner Präsentation auf Rambler Front &amp; Meet up # 4 ansehen </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rCEoy-V3x8k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418417/">https://habr.com/ru/post/de418417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418403/index.html">Beispiel für die Programmierung eines FPGA-Beschleunigers</a></li>
<li><a href="../de418405/index.html">Das Prinzip der umgekehrten Pyramide in der Analytik. Wir erstellen ein verständliches Dashboard</a></li>
<li><a href="../de418407/index.html">Hashflare Cloud Mining wurde geschlossen. Geld kehrt nicht zurück</a></li>
<li><a href="../de418411/index.html">Browser-Netzwerk-Shooter auf Node.js.</a></li>
<li><a href="../de418415/index.html">Telegram führte einen eigenen Passport-Dienst zur Überprüfung und Autorisierung von Benutzern ein</a></li>
<li><a href="../de418419/index.html">Wie Dodo Pizza geschäftliche Probleme mithilfe von maschinellem Lernen löst</a></li>
<li><a href="../de418423/index.html">Smart Home: Eine neue Dimension des Komforts und das Streben nach Spitzenleistungen. Teil eins</a></li>
<li><a href="../de418427/index.html">Mobile-First-Indizierung. Wie und warum ändert sich das Linkdiagramm?</a></li>
<li><a href="../de418429/index.html">Meine Berufserfahrung für die Rolle des agilen Coach in Europa, Teil Zwei</a></li>
<li><a href="../de418431/index.html">Imaginäre Probleme - die Wurzel schlechter Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>