<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💶 ⛹🏼 🙋🏿 En quoi les composants React fonctionnels sont-ils différents des composants basés sur les classes? 👨🏼‍💻 🈸 🔛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En quoi les composants React fonctionnels sont-ils différents des composants basés sur les classes? Depuis un certain temps maintenant, la réponse tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>En quoi les composants React fonctionnels sont-ils différents des composants basés sur les classes?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/">  En quoi les composants React fonctionnels sont-ils différents des composants basés sur les classes?  Depuis un certain temps maintenant, la réponse traditionnelle à cette question est: "L'utilisation de classes vous permet d'utiliser un grand nombre de fonctionnalités de composants, par exemple l'état."  Maintenant, avec l'avènement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crochets</a> , cette réponse ne reflète plus la véritable situation. <br><br>  Vous avez peut-être entendu dire que l'un de ces types de composants a de meilleures performances que l'autre.  Mais lequel?  La plupart des repères qui testent cela ont des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">défauts</a> , donc je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tirerais des conclusions</a> basées sur leurs résultats avec une grande prudence.  Les performances dépendent principalement de ce qui se passe dans le code, et non de la sélection des composants fonctionnels ou des composants basés sur les classes pour implémenter certaines fonctionnalités.  Notre étude a montré que la différence de performance entre les différents types de composants est négligeable.  Cependant, il convient de noter que les stratégies d'optimisation utilisées pour travailler avec elles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diffèrent</a> légèrement. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br>  En tout cas, je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne recommande pas de</a> réécrire les composants existants à l'aide de nouvelles technologies s'il n'y a pas de bonnes raisons à cela, et si cela ne vous dérange pas de faire partie de ceux qui ont commencé à utiliser ces technologies avant tout le monde.  Les crochets sont encore une nouvelle technologie (identique à la bibliothèque React en 2014), et certaines «meilleures pratiques» pour leur application n'ont pas encore été incluses dans les manuels React. <br><a name="habracut"></a><br>  Où en sommes-nous finalement arrivés?  Existe-t-il des différences fondamentales entre les composants fonctionnels de React et les composants basés sur les classes?  Bien sûr, il existe de telles différences.  Ce sont des différences dans le modèle mental d'utilisation de ces composants.  Dans cet article, je considérerai leur différence la plus sérieuse.  Il existe depuis que, en 2015, des composants fonctionnels sont apparus, mais il est souvent négligé.  Elle consiste dans le fait que les composants fonctionnels capturent les valeurs rendues.  Parlons de ce que cela signifie vraiment. <br><br>  Il convient de noter que ce matériel ne constitue pas une tentative d'évaluation de composants de différents types.  Je viens de décrire la différence entre les deux modèles de programmation dans React.  Si vous souhaitez en savoir plus sur l'utilisation des composants fonctionnels à la lumière des innovations, reportez-vous à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> liste de questions et réponses sur les crochets. <br><br><h2>  <font color="#3AC1EF">Quelles sont les caractéristiques du code des composants basés sur des fonctions et des classes?</font> </h2><br>  Considérez ce composant: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br>  Il affiche un bouton qui, en appuyant sur la fonction <code>setTimeout</code> , imite une demande réseau, puis affiche une boîte de message confirmant que l'opération est terminée.  Par exemple, si « <code>props.user</code> <code>'Dan'</code> est stocké dans <code>props.user</code> , alors dans la fenêtre de message, après trois secondes, <code>'Followed Dan'</code> s'affiche. <br><br>  Notez que peu importe si des fonctions fléchées ou des déclarations de fonctions sont utilisées ici.  Une construction de la <code>function handleClick()</code> formulaire <code>function handleClick()</code> fonctionnera exactement de la même manière. <br><br>  Comment réécrire ce composant en classe?  Si vous venez de refaire le code que vous venez d'examiner, en le convertissant en code d'un composant basé sur une classe, vous obtenez ce qui suit: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Il est généralement admis que deux de ces fragments de code sont équivalents.  Et les développeurs sont souvent totalement libres, au cours du refactoring de code, se transforment les uns en les autres, sans penser aux conséquences possibles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">Ces morceaux de code semblent être équivalents</font></i> <br><br>  Cependant, il existe une légère différence entre ces extraits de code.  Regardez-les de plus près.  Tu vois la différence?  Par exemple, je ne l'ai pas vue tout de suite. <br><br>  De plus, nous considérerons cette différence, par conséquent, pour ceux qui veulent comprendre l'essence de ce qui se passe eux-mêmes, un exemple de travail de ce code. <br><br>  Avant de continuer, je voudrais souligner que la différence en question n'a rien à voir avec les crochets React.  Dans les exemples précédents, d'ailleurs, les crochets ne sont même pas utilisés.  Il s'agit de la différence entre les fonctions et les classes dans React.  Et si vous prévoyez d'utiliser de nombreux composants fonctionnels dans vos applications React, vous souhaiterez peut-être comprendre cette différence. <br><br>  En fait, nous illustrerons la différence entre les fonctions et les classes par l'exemple d'une erreur qui est souvent rencontrée dans les applications React. <br><br><h2>  <font color="#3AC1EF">L'erreur courante dans les applications React.</font> </h2><br>  Ouvrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page d'exemple</a> qui affiche une liste qui vous permet de sélectionner des profils utilisateur et deux boutons <code>Follow</code> qui sont affichés par les <code>ProfilePageClass</code> <code>ProfilePageFunction</code> et <code>ProfilePageClass</code> , fonctionnels et basés sur la classe, dont le code est illustré ci-dessus. <br><br>  Essayez, pour chacun de ces boutons, d'effectuer la séquence d'actions suivante: <br><br><ol><li>  Cliquez sur le bouton. </li><li>  Modifiez le profil sélectionné avant 3 secondes après avoir cliqué sur le bouton. </li><li>  Lisez le texte affiché dans la boîte de message. </li></ol><br>  Cela fait, vous remarquerez les fonctionnalités suivantes: <br><br><ul><li>  Lorsque vous cliquez sur le bouton formé par le composant fonctionnel avec le profil <code>Dan</code> sélectionné, puis que vous passez au profil <code>Sophie</code> , <code>'Followed Dan'</code> s'affiche dans la boîte de message. </li><li>  Si vous faites de même avec un bouton formé par un composant basé sur une classe, <code>'Followed Sophie'</code> s'affichera. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">Caractéristiques des composants basés sur les classes</font></i> <br><br>  Dans cet exemple, le comportement du composant fonctionnel est correct.  Si je me suis abonné au profil de quelqu'un, puis suis passé à un autre profil, mon composant ne devrait pas douter du profil auquel je me suis abonné.  De toute évidence, la mise en œuvre du mécanisme en question basé sur l'utilisation de classes contient une erreur (à propos, vous devriez certainement devenir abonné à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sofia</a> ). <br><br><h2>  <font color="#3AC1EF">Causes de dysfonctionnement d'un composant basé sur une classe</font> </h2><br>  Pourquoi un composant basé sur une classe se comporte-t-il de cette façon?  Afin de comprendre cela, jetons un coup d'œil à la méthode <code>showMessage</code> dans notre classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br>  Cette méthode lit les données de <code>this.props.user</code> .  Les propriétés de React sont immuables, elles ne changent donc pas.  Cependant, comme toujours, il s'agit d'une entité mutable. <br><br>  En fait, le but d'avoir <code>this</code> dans une classe réside dans la capacité de <code>this</code> à changer.  La bibliothèque React elle-même effectue périodiquement <code>this</code> mutations, ce qui permet de travailler avec les dernières versions de la méthode de <code>render</code> et des méthodes de cycle de vie des composants. <br><br>  Par conséquent, si notre composant effectue un nouveau rendu pendant l'exécution de la demande, <code>this.props</code> changera.  Après cela, la méthode <code>showMessage</code> lira la valeur <code>user</code> de l'entité d' <code>props</code> "trop ​​nouveau". <br><br>  Cela vous permet de faire une observation intéressante concernant les interfaces utilisateur.  Si nous disons que l'interface utilisateur, conceptuellement, est fonction de l'état actuel de l'application, alors les gestionnaires d'événements font partie des résultats de rendu - tout comme les résultats de rendu visibles.  Nos gestionnaires d'événements «appartiennent» à une opération de rendu spécifique avec des propriétés et un état spécifiques. <br><br>  Cependant, la planification d'un délai dont le rappel <code>this.props</code> lu par <code>this.props</code> viole cette connexion.  Le <code>showMessage</code> showMessage <code>showMessage</code> pas «lié» à une opération de rendu particulière, par conséquent, il «perd» les propriétés correctes.  La lecture des données à partir de <code>this</code> rompt cette connexion. <br><br><h2>  <font color="#3AC1EF">Comment, au moyen de composants basés sur les classes, résoudre le problème?</font> </h2><br>  Imaginez qu'il n'y ait pas de composants fonctionnels dans React.  Comment alors résoudre ce problème? <br><br>  Nous avons besoin d'un mécanisme pour "restaurer" la connexion entre la méthode de <code>render</code> avec les propriétés correctes et le <code>showMessage</code> showMessage, qui lit les données des propriétés.  Ce mécanisme devrait être situé quelque part où l'essence des <code>props</code> avec les données correctes est perdue. <br><br>  Une façon de procéder consiste à lire <code>this.props</code> à l'avance dans le gestionnaire d'événements, puis à transmettre explicitement ce qui a été lu à la fonction de rappel utilisée dans <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Cette approche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionne</a> .  Mais les constructions supplémentaires utilisées ici, au fil du temps, entraîneront une augmentation du volume du code et le fait que la probabilité d'erreurs y augmentera.  Et si nous avons besoin de plus qu'une seule propriété?  Et si nous devons également travailler avec l'État?  Si la méthode <code>showMessage</code> une autre méthode et que cette méthode lit <code>this.props.something</code> ou <code>this.state.something</code> , nous rencontrerons à nouveau le même problème.  Et pour le résoudre, nous devons passer <code>this.props</code> et <code>this.state</code> comme arguments à toutes les méthodes appelées depuis <code>showMessage</code> . <br><br>  Si cela est vrai, cela détruira toutes les commodités offertes par l’utilisation des composants basés sur les classes.  Il est difficile de se rappeler que travailler avec des méthodes de cette manière est difficile, il est difficile d'automatiser, en conséquence, les développeurs conviennent souvent, au lieu d'utiliser des méthodes similaires, qu'il y a des erreurs dans leurs projets. <br><br>  De même, l'incorporation de code d' <code>alert</code> dans <code>handleClick</code> ne résout pas un problème plus global.  Nous devons structurer le code afin qu'il puisse être divisé en plusieurs méthodes, mais aussi pour pouvoir lire les propriétés et l'état qui correspondent à l'opération de rendu associée à un appel particulier.  Ce problème, d'ailleurs, ne s'applique même pas exclusivement à React.  Vous pouvez le lire dans n'importe quelle bibliothèque pour développer des interfaces utilisateur, ce qui place les données dans des objets mutables comme <code>this</code> . <br><br>  Peut-être que pour résoudre ce problème, vous pouvez lier des méthodes à <code>this</code> dans le constructeur? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Mais cela ne résout pas notre problème.  N'oubliez pas que c'est que nous lisons les données de <code>this.props</code> trop tard, et non dans la syntaxe utilisée!  Cependant, ce problème sera résolu si nous nous appuyons sur les fermetures JavaScript. <br><br>  Les développeurs essaient souvent d'éviter les fermetures, car il n'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas facile de</a> penser à des valeurs qui, au fil du temps, ne peuvent pas muter.  Mais les propriétés de React sont immuables!  (Ou, au minimum, cela est fortement recommandé).  Cela vous permet d'arrêter de percevoir les fermetures comme quelque chose à cause duquel le programmeur peut, comme on dit, «se tirer une balle dans le pied». <br><br>  Cela signifie que si vous «verrouillez» les propriétés ou l'état d'une opération de rendu particulière dans la fermeture, vous pouvez toujours compter sur eux pour ne pas changer. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br>  Comme vous pouvez le voir, nous avons ici «capturé» les propriétés lors de l'appel à la méthode de <code>render</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">Propriétés capturées par l'appel de rendu</font></i> <br><br>  Avec cette approche, tout code trouvé dans la méthode de <code>render</code> (y compris <code>showMessage</code> ) est garanti de voir les propriétés capturées lors d'un appel particulier à cette méthode.  En conséquence, React ne pourra plus nous empêcher de faire ce dont nous avons besoin. <br><br>  Dans la méthode de <code>render</code> , vous pouvez décrire autant de fonctions auxiliaires que vous le souhaitez et toutes pourront utiliser les propriétés et l'état «capturés».  C'est ainsi que les fermetures ont résolu notre problème. <br><br><h2>  <font color="#3AC1EF">Analyse de la solution du problème à l'aide de la fermeture</font> </h2><br>  Ce que nous venons d'arriver nous permet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">résoudre le problème</a> , mais un tel code semble étrange.  Pourquoi une classe est-elle nécessaire du tout si des fonctions sont déclarées à l'intérieur de la méthode de <code>render</code> , et non en tant que méthodes de classe? <br><br>  En fait, nous pouvons simplifier ce code en nous débarrassant du «shell» sous la forme d'une classe qui l'entoure: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Ici, comme dans l'exemple précédent, les propriétés sont capturées dans la fonction, puisque React leur les transmet en argument.  Contrairement à <code>this</code> , React ne <code>props</code> jamais <code>props</code> objet d' <code>props</code> . <br><br>  Cela devient un peu plus évident si les <code>props</code> détruits dans la déclaration de fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Lorsque le composant parent <code>ProfilePage</code> avec d'autres propriétés, React appellera à <code>ProfilePage</code> fonction <code>ProfilePage</code> .  Mais le gestionnaire d'événements qui a déjà été appelé appartient à l'appel précédent à cette fonction, cet appel utilise sa propre valeur <code>user</code> et son propre <code>showMessage</code> showMessage, qui lit cette valeur.  Tout cela reste intact. <br><br>  C'est pourquoi dans la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">originale</a> de notre exemple, lorsque vous travaillez avec un composant fonctionnel, la sélection d'un autre profil après avoir cliqué sur le bouton correspondant avant que le message ne s'affiche ne change rien.  Si un profil <code>Sophie</code> été sélectionné avant de cliquer sur le bouton, <code>'Followed Sophie'</code> s'affichera dans la fenêtre de message, quoi qu'il arrive. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">Utiliser un composant fonctionnel</font></i> <br><br>  Ce comportement est correct (vous pouvez également vous inscrire à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sunil en passant</a> ). <br><br>  Nous avons maintenant compris quelle est la grande différence entre les fonctions et les classes dans React.  Comme déjà mentionné, nous parlons du fait que les composants fonctionnels capturent des valeurs.  Parlons maintenant des crochets. <br><br><h2>  <font color="#3AC1EF">Crochets</font> </h2><br>  Lors de l'utilisation de hooks, le principe de "capture de valeurs" s'étend à l'état.  Prenons l'exemple suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez expérimenter avec lui <br><br>  Bien qu'il ne s'agisse pas d'un exemple exemplaire d'une interface d'application de messagerie, ce projet illustre la même idée: si un utilisateur envoie un message, le composant ne doit pas être confondu sur le message envoyé.  La constante de <code>message</code> de ce composant fonctionnel capture l'état qui "appartient" au composant qui rend le navigateur le gestionnaire de clics pour le bouton qu'il appelle.  Par conséquent, le <code>message</code> stocke ce qui était dans le champ de saisie au moment où vous cliquez sur le bouton <code>Send</code> . <br><br><h2>  <font color="#3AC1EF">Le problème de la capture des propriétés et des états par des composants fonctionnels</font> </h2><br>  Nous savons que les composants fonctionnels de React capturent par défaut les propriétés et l'état.  Mais que se passe-t-il si nous devons lire les dernières données des propriétés ou des états qui n'appartiennent pas à un appel de fonction particulier?  Et si nous voulons «les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lire du futur</a> »? <br><br>  Dans les composants basés sur les classes, cela pourrait être fait simplement en se référant à <code>this.props</code> ou <code>this.state</code> , car <code>this</code> s'agit d'une entité mutable.  Son changement est engagé dans React.  Les composants fonctionnels peuvent également fonctionner avec des valeurs mutables partagées par tous les composants.  Ces valeurs sont appelées <code>ref</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br>  Cependant, le programmeur doit gérer ces valeurs indépendamment. <br><br>  L'essence de <code>ref</code> joue le même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rôle</a> que les champs d'une instance d'une classe.  Il s'agit d'une «sortie d'urgence» dans un monde impératif mutable.  Vous connaissez peut-être le concept des références DOM, mais cette idée est beaucoup plus générale.  Il peut être comparé à une boîte dans laquelle un programmeur peut mettre quelque chose. <br><br>  Même à l'extérieur, une construction comme <code>this.something</code> ressemble à une image miroir de <code>something.current</code> construction actuelle.  Ils sont une représentation du même concept. <br><br>  Par défaut, React ne crée pas d'entités de <code>ref</code> dans les composants fonctionnels pour les valeurs de propriété ou d'état les plus récentes.  Dans de nombreux cas, vous n'en aurez pas besoin et leur création automatique serait une perte de temps.  Cependant, travailler avec eux, si nécessaire, peut être organisé de manière autonome: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br>  Si nous lisons le <code>message</code> dans <code>showMessage</code> , nous verrons alors le message qui se trouvait dans le champ au moment de cliquer sur le bouton <code>Send</code> .  Mais si vous lisez <code>latestMessage.current</code> , vous pouvez obtenir la dernière valeur - même si nous continuons à saisir du texte dans le champ après avoir cliqué sur le bouton <code>Send</code> . <br><br>  Vous pouvez comparer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceci</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ces</a> exemples afin d'évaluer indépendamment la différence.  La valeur de <code>ref</code> est un moyen «d'éviter» l'uniformité du rendu, dans certains cas, elle peut être très utile. <br><br>  En général, vous devez éviter de lire ou d'écrire des valeurs <code>ref</code> pendant le processus de rendu car ces valeurs sont mutables.  Nous nous efforçons de rendre le rendu prévisible.  Cependant, si nous devons obtenir la valeur la plus récente de quelque chose stocké dans des propriétés ou dans un état, la mise à jour manuelle de la valeur <code>ref</code> peut être une tâche fastidieuse.  Il peut être automatisé en utilisant l'effet: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> un exemple qui utilise ce code <br><br>  Nous attribuons une valeur à l'intérieur de l'effet, par conséquent, la valeur de <code>ref</code> ne changera qu'après la mise à jour du DOM.  Cela garantit que notre mutation ne perturbe pas des fonctionnalités comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Time Slicing et Suspense</a> , qui reposent sur la continuité des opérations de rendu. <br><br>  L'utilisation de la valeur <code>ref</code> de cette manière n'est pas souvent requise.  La capture de propriétés ou d'états semble généralement être un modèle bien meilleur de comportement standard du système.  Cependant, cela peut être pratique lorsque vous travaillez avec des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API impératives</a> , comme celles qui utilisent des intervalles ou des abonnements.  N'oubliez pas que vous pouvez travailler de cette façon avec n'importe quelle valeur - avec des propriétés, avec des variables stockées dans l'état, avec l'objet <code>props</code> entier <code>props</code> ou même avec une fonction. <br><br>  Ce modèle peut en outre être utile à des fins d'optimisation.  Par exemple, lorsque quelque chose comme <code>useCallback</code> change trop souvent.  Certes, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solution préférée est</a> souvent d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utiliser un réducteur</a> . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Dans cet article, nous avons examiné l'un des mauvais modèles d'utilisation des composants basés sur les classes et expliqué comment résoudre ce problème avec les fermetures.  Cependant, vous pouvez remarquer que lorsque vous essayez d'optimiser les hooks en spécifiant un tableau de dépendances, vous pouvez rencontrer des erreurs liées à des fermetures obsolètes.  Est-ce à dire que les défauts eux-mêmes sont un problème.  Je ne pense pas. <br><br>  Comme indiqué ci-dessus, les fermetures nous aident en fait à résoudre les petits problèmes difficiles à détecter.  De même, ils facilitent l'écriture de code qui fonctionne correctement en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parallèle</a> .  Cela est possible du fait que dans le composant, les propriétés et l'état corrects avec lesquels ce composant a été rendu sont «verrouillés». <br><br>  Dans tous les cas que j'ai vus jusqu'à présent, le problème des «fermetures obsolètes» s'est produit en raison de l'hypothèse erronée que «les fonctions ne changent pas» ou que «les propriétés restent toujours les mêmes».  J'espère qu'après avoir lu ce document, vous êtes convaincu que ce n'est pas le cas. <br><br>  Les fonctions «capturent» leurs propriétés et leur état - et il est donc également important de comprendre quelles fonctions sont en question.  Ce n'est pas une erreur, c'est une caractéristique des composants fonctionnels.  Les fonctions ne doivent pas être exclues du "tableau de dépendances" pour <code>useEffect</code> ou <code>useCalback</code> , par exemple.  (Un outil approprié pour résoudre le problème est généralement <code>useReducer</code> ou <code>useRef</code> . Nous en avons parlé ci-dessus, et bientôt nous préparerons du matériel qui sera consacré au choix de telle ou telle approche). <br><br>  Si la plupart du code de nos applications sera basé sur des composants fonctionnels, cela signifie que nous devons en savoir plus sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimisation du code</a> et quelles valeurs peuvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">changer au</a> fil du temps. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     : «  ,   ,    ,   ,    ,         ». <br><br>          .  ,        React    ,   .     ,    « »,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React —    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444348/">https://habr.com/ru/post/fr444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444338/index.html">Encapsulation dans Python 3</a></li>
<li><a href="../fr444340/index.html">Caractéristiques de l'utilisation du type de données Symbol en JavaScript</a></li>
<li><a href="../fr444342/index.html">Développement d'applications JavaScript simples et modernes à l'aide de Webpack et de technologies Web avancées</a></li>
<li><a href="../fr444344/index.html">10 étapes pour réussir un projet Python</a></li>
<li><a href="../fr444346/index.html">GraphQL et Golang</a></li>
<li><a href="../fr444350/index.html">Pour une raison quelconque, MVP (produit minimum viable) ne démarre pas</a></li>
<li><a href="../fr444352/index.html">Kontur.Kampus: nous vous invitons à un camp étudiant gratuit de développement industriel près de Saint-Pétersbourg</a></li>
<li><a href="../fr444356/index.html">Tutoriel React, partie 24: Leçon sur les seconds formulaires</a></li>
<li><a href="../fr444358/index.html">Enumerable: comment générer une valeur commerciale</a></li>
<li><a href="../fr444360/index.html">Injustice Google Play comme une bonne expérience de vie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>