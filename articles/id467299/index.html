<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ½ ğŸŒ´ ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ» Konsep: menyederhanakan implementasi kelas STD Utility âš”ï¸ ğŸ›µ ğŸ§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konsep yang muncul dalam C ++ 20 adalah topik yang panjang dan banyak dibahas. Terlepas dari kelebihan bahan yang terakumulasi selama bertahun-tahun (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konsep: menyederhanakan implementasi kelas STD Utility</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/467299/"><p><img src="https://habrastorage.org/webt/et/c4/ir/etc4ir2odcs1wv10o5jcu0yneng.jpeg"></p><br><p>  Konsep yang muncul dalam C ++ 20 adalah topik yang panjang dan banyak dibahas.  Terlepas dari kelebihan bahan yang terakumulasi selama bertahun-tahun (termasuk pidato para pakar kelas dunia), masih ada kebingungan di antara para programer terapan (yang tidak tertidur setiap hari dengan standar) apa konsep C ++ 20 dan apakah mereka kita perlu jika ada enable_if diperiksa selama bertahun-tahun.  Sebagian kesalahannya adalah bagaimana konsep berkembang lebih dari ~ 15 tahun (Konsep Lengkap + Peta Konsep -&gt; Konsep Lite), dan sebagian karena konsep tersebut ternyata tidak seperti alat serupa dalam bahasa lain (batas generik Java / C #, ciri-ciri Rust,. ..) </p><br><p>  Di bawah potongan video dan transkrip dari sebuah laporan oleh Andrey Davydov dari tim ReSharper C ++ dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Russia 2019</a> .  Andrey membuat tinjauan singkat tentang inovasi terkait konsep C ++ 20, setelah itu ia memeriksa implementasi beberapa kelas dan fungsi STL, membandingkan solusi C ++ 17 dan C ++ 20.  Selanjutnya ceritanya adalah atas namanya. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vYzjV0xSqJE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bicara tentang konsep.  Ini adalah topik yang agak rumit dan luas, jadi ketika mempersiapkan laporan, saya mengalami kesulitan.  Saya memutuskan untuk beralih ke pengalaman salah satu pembicara terbaik dari komunitas C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrei Alexandrescu</a> . </p><br><p>  Pada bulan November 2018, berbicara pada pembukaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rapat C ++</a> , Andrei bertanya kepada hadirin apa yang akan menjadi fitur besar selanjutnya dari C ++: </p><br><ul><li>  konsep </li><li>  metaclasses </li><li>  atau introspeksi? </li></ul><br><p>  Mari kita mulai dengan pertanyaan ini.  Apakah Anda pikir fitur besar berikutnya dalam C ++ akan menjadi konsep? </p><br><p>  Menurut Alexandrescu, konsep itu membosankan.  Ini adalah hal yang membosankan yang saya sarankan Anda lakukan.  Selain itu, saya masih tidak bisa berbicara tentang metaclasses, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Herb Sutter</a> , atau introspeksi, seperti Alexandrescu. </p><br><p>  Apa yang kita maksudkan ketika berbicara tentang konsep dalam C ++ 20?  Fitur ini telah dibahas setidaknya sejak tahun 2003, dan selama ini telah berhasil berkembang pesat.  Mari kita lihat fitur-fitur terkait konsep baru apa yang muncul di C ++ 20. </p><br><p> Entitas baru yang disebut "konsep" didefinisikan oleh kata kunci <code>concept</code> .  Ini adalah predikat pada parameter templat.  Itu terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept NoThrowDefaultConstructible = noexept(T{}); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> From, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> To&gt; concept Assignable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_assignable_v&lt;From, To&gt;</code> </pre> <br><p>  Saya tidak hanya menggunakan frasa "pada parameter templat", dan bukan "pada tipe", karena konsep dapat didefinisikan pada parameter templat non-standar.  Jika tidak ada yang bisa dilakukan sama sekali, Anda dapat mendefinisikan konsep untuk nomor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I&gt; concept Even = I % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Tetapi lebih masuk akal untuk mencampur parameter template yang tipikal dan atipikal.  Kami memanggil jenis kecil jika ukuran dan perataannya tidak melebihi batas yang ditentukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxSize, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxAlign&gt; concept Small = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &lt;= MaxSize &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T) &lt;= MaxAlign;</code> </pre> <br><p>  Mungkin, belum jelas mengapa kita perlu memagari entitas baru dalam bahasa, dan mengapa konsepnya bukan hanya variabel <code>constexpr bool</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  `concept`    ? #define concept constexpr bool</span></span></code> </pre> <br><h1 id="kak-ispolzuyutsya-koncepty">  Bagaimana konsep digunakan? </h1><br><p>  Untuk memahami, mari kita lihat bagaimana konsep digunakan. </p><br><p>  Pertama, seperti <code>constexpr bool</code> variabel <code>constexpr bool</code> , mereka dapat digunakan di mana pun Anda membutuhkan ekspresi boolean dalam waktu kompilasi.  Misalnya, di dalam <code>static_assert</code> atau di dalam <code>noexcept</code> <br>  spesifikasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// bool expression evaluated in compile-time static_assert(Assignable&lt;float, int&gt;); template&lt;typename T&gt; void test() noexcept(NothrowDefaultConstructible&lt;T&gt;) { T t; ... }</span></span></code> </pre> <br><p>  Kedua, konsep dapat digunakan alih-alih nama <code>typename</code> atau kata kunci <code>class</code> saat mendefinisikan parameter template.  Tentukan kelas <code>optional</code> sederhana yang hanya akan menyimpan sepasang flag boolean yang <code>initialized</code> dan nilai-nilai.  Tentu saja, <code>optional</code> semacam itu hanya berlaku untuk tipe sepele.  Oleh karena itu, kami menulis <code>Trivial</code> sini dan ketika kami mencoba untuk instantiate dari sesuatu yang non-trivial, misalnya, dari <code>std::string</code> , kami akan memiliki kesalahan kompilasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  type-parameter-key (class, typename) template&lt;Trivial T&gt; class simple_optional { T value; bool initialized = false; ... };</span></span></code> </pre> <br><p>  Konsep dapat diterapkan sebagian.  Sebagai contoh, kami mengimplementasikan kelas kami dengan optimasi buffer kecil.  Tentukan struktur <code>SB</code> (buffer kecil) dengan <code>Size</code> dan <code>Alignment</code> tetap, kami akan menyimpan serikat dari <code>SB</code> dan pointer pada heap.  Dan sekarang, jika tipe kecil masuk ke konstruktor, maka kita bisa memasukkannya ke dalam <code>SB</code> .  Untuk menentukan bahwa suatu jenis kecil, kami menulis bahwa itu memenuhi konsep <code>Small</code> .  Konsep <code>Small</code> mengambil 3 parameter template: kami mendefinisikan dua, dan kami mendapat fungsi dari satu parameter template: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; template&lt;Small&lt;SB::Size, SB::Alignment&gt; T&gt; any(T const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p>  Ada catatan yang lebih pendek.  Kami menulis nama parameter templat, mungkin dengan beberapa argumen, sebelum <code>auto</code> .  Contoh sebelumnya ditulis ulang dengan cara ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; any(Small&lt;SB::Size, SB::Alignment&gt; auto const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p>  Mungkin, di tempat mana pun kami menulis <code>auto</code> , sekarang Anda dapat menulis nama konsep di depannya. </p><br><p>  Tentukan fungsi <code>get_handle</code> , yang mengembalikan beberapa <code>handle</code> untuk objek. <br>  Kita mengasumsikan bahwa objek kecil itu sendiri adalah <code>handle</code> , dan untuk objek besar, sebuah penunjuk pada mereka adalah <code>handle</code> .  Karena kita memiliki dua cabang <code>if constexpr</code> menunjukkan ekspresi dari tipe yang berbeda, akan lebih mudah bagi kita untuk tidak menentukan tipe fungsi ini secara eksplisit, tetapi meminta kompiler untuk menampilkannya.  Tetapi jika kita hanya <code>auto</code> , kita akan kehilangan informasi bahwa nilai yang ditunjukkan kecil, itu tidak melebihi pointer: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; auto get_handle(T&amp; object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><p>  Dalam C ++ 20, dimungkinkan untuk menulis sebelumnya bahwa itu bukan hanya <code>auto</code> , tetapi <code>auto</code> terbatas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; LEPtr auto get_handle(T &amp;object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><h1 id="requires-expression">  Membutuhkan ekspresi </h1><br><p>  Membutuhkan ekspresi adalah seluruh keluarga ekspresi'ov, semuanya bertipe <code>bool</code> dan dihitung dalam waktu kompilasi.  Mereka digunakan untuk menguji pernyataan tentang ekspresi dan tipe.  Membutuhkan ekspresi sangat berguna untuk mendefinisikan konsep. </p><br><p>  Contoh yang <code>Constructible</code> .  Mereka yang ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> sudah melihatnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; concept Constructible = requires(Args... args) { T{args...} };</code> </pre> <br><p>  Dan contoh dengan <code>Comparable</code> .  Katakanlah tipe <code>T</code> adalah <code>Comparable</code> jika dua objek tipe <code>T</code> dapat dibandingkan dengan menggunakan operator "kurang" dan hasilnya dikonversi menjadi <code>bool</code> .  Panah ini dan tipe setelahnya berarti bahwa ekspresi tipe dikonversi menjadi <code>bool</code> , dan tidak sama dengan <code>bool</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Comparable = requires(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; a, T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; b) { {a &lt; b} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; };</code> </pre> <br><p>  Apa yang kami kaji sudah cukup untuk menunjukkan contoh penggunaan konsep secara penuh. </p><br><p>  Kami sudah memiliki konsep <code>Comparable</code> , mari kita mendefinisikan konsep untuk iterator.  Katakanlah <code>RandomAccessIterator</code> adalah <code>BidirectionalIterator</code> dan beberapa properti lainnya.  Dengan ini, kami mendefinisikan konsep <code>Sortable</code> .  <code>Range</code> disebut <code>Sortable</code> jika iterator <code>RandomAccess</code> dan elemen-elemennya dapat dibandingkan.  Dan sekarang kita dapat menulis fungsi <code>sort</code> yang menerima tidak hanya itu, tetapi <code>Sortable Range</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// concepts,    ++20 template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) {...}</span></span></code> </pre> <br><p>  Sekarang, jika kita mencoba memanggil fungsi ini dari sesuatu yang tidak memenuhi konsep <code>Sortable</code> , kita akan mendapatkan kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ramah SFINAE yang bagus</a> dari kompiler dengan pesan yang jelas.  Mari kita coba instantiate <code>std::list</code> 'atau vektor elemen yang tidak bisa dibandingkan: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++20,  struct X {}; void test() { vector&lt;int&gt; vi; sort(vi); // OK list &lt;int&gt; li; sort(li); // Fail, list&lt;int&gt;::iterator is not random access vector&lt; X &gt; vx; sort(vx); // Fail, X is not Comparable }</span></span></code> </pre> <br><p>  Pernahkah Anda melihat contoh serupa menggunakan konsep atau sesuatu yang sangat mirip?  Saya telah melihat ini beberapa kali.  Jujur, itu tidak meyakinkan saya sama sekali.  Apakah kita perlu memagari begitu banyak entitas baru dalam bahasa, jika kita bisa mendapatkan ini dalam C ++ 17? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++17 #define concept constexpr bool template&lt;typename T&gt; concept Comparable = is_convertible_v&lt; decltype(declval&lt;T const &amp;&gt;() &lt; declval&lt;T const &amp;&gt;()), bool &gt;; template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range, typename = enable_if_t&lt;Sortable&lt;Range&gt;&gt;&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p>  Saya memasukkan <code>concept</code> kata kunci <code>concept</code> makro, dan <code>Comparable</code> ditulis ulang dengan cara ini.  Ini menjadi sedikit lebih buruk, dan ini mengisyaratkan kepada kita bahwa menuntut ekspresi benar-benar bermanfaat dan nyaman.  Jadi kami mendefinisikan konsep <code>Sortable</code> dan menggunakan <code>enable_if</code> mengindikasikan bahwa fungsi <code>sort</code> menerima <code>Sortable Range</code> . </p><br><p>  Anda mungkin berpikir bahwa metode ini kehilangan banyak sesuai dengan pesan kesalahan kompilasi, tetapi, pada kenyataannya, ini adalah masalah kualitas implementasi kompiler.  Katakanlah bahwa Dentang membuat keributan tentang topik ini dan secara khusus melompat bahwa jika Anda mengganti <code>enable_if</code> Anda memiliki argumen pertama <br>  Jika <code>false</code> dihitung, maka mereka menyajikan kesalahan ini sehingga persyaratan seperti itu tidak terpenuhi. </p><br><p>  Contoh di atas tampaknya ditulis melalui konsep.  Saya punya hipotesis: contoh ini tidak dapat disimpulkan, karena tidak menggunakan fitur utama konsep - memerlukan klausa. </p><br><h1 id="requires-clause">  Membutuhkan klausa </h1><br><p>  Membutuhkan klausa adalah hal yang tergantung pada hampir semua deklarasi templat atau pada fungsi non-templat.  Secara sintaksis, ini seperti <code>requires</code> kata kunci, diikuti oleh beberapa ekspresi Boolean.  Ini diperlukan untuk memfilter kandidat templat spesialisasi atau kelebihan beban, yaitu, ia bekerja dengan cara yang sama seperti SFINAE, hanya dilakukan dengan benar, dan bukan dengan peretasan: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// requires-clause template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p>  Di mana dalam contoh kami yang diurutkan dapat kami gunakan membutuhkan klausa?  Alih-alih sintaks singkat untuk menerapkan konsep, kami menulis ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&gt; requires Sortable&lt;Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range &amp;)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Tampaknya kode semakin memburuk dan semakin besar.  Tapi sekarang kita bisa menyingkirkan konsep <code>Sortable</code> .  Dari sudut pandang saya, ini merupakan peningkatan, karena konsep <code>Sortable</code> tautologis: kami menyebut <code>Sortable</code> segala sesuatu yang dapat diteruskan ke fungsi <code>sort</code> .  Ini tidak memiliki arti fisik.  Kami menulis ulang kode dengan cara ini: </p><br><pre> <code class="plaintext hljs">//template&lt;typename R&gt; concept Sortable // = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range&gt; requires RandomAccessIterator&lt;Iterator&lt;Range&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;Range&gt;&gt;; void sort(Range &amp;) { ... }</code> </pre> <br><h1 id="itogovyy-spisok-concept-related-fich">  Daftar ringkasan fitur terkait konsep </h1><br><p>  Daftar inovasi terkait konsep di C ++ 20 terlihat seperti ini.  Item dalam daftar ini disortir dengan meningkatkan utilitas fitur dari sudut pandang subjektif saya: </p><br><ul><li>  <code>concept</code> entitas baru.  Sepertinya saya bahwa itu akan mungkin dilakukan tanpa esensi <code>concept</code> dengan menganugerahkan variabel <code>constexpr bool</code> dengan semantik tambahan. </li><li>  Sintaks khusus untuk menerapkan konsep.  Tentu saja, itu menyenangkan, tetapi ini hanya sintaksisnya.  Jika pemrogram C ++ takut sintaksis yang buruk, mereka akan mati karena ketakutan sejak lama. </li><li>  Membutuhkan ekspresi benar-benar hal yang keren, dan berguna tidak hanya untuk mendefinisikan konsep. </li><li>  Membutuhkan klausa adalah nilai konsep terbesar, memungkinkan Anda untuk melupakan SFINAE dan kengerian temporer C ++ lainnya yang legendaris. </li></ul><br><h1 id="podrobnee-o-requires-expression">  Lebih lanjut tentang membutuhkan ekspresi </h1><br><p>  Sebelum kita masuk ke diskusi tentang membutuhkan klausa, beberapa kata tentang memerlukan ekspresi. </p><br><p>  Pertama, mereka dapat digunakan tidak hanya untuk mendefinisikan konsep.  Sejak dahulu kala, kompiler Microsoft memiliki ekstensi <code>__if_exists</code> - <code>__if_not_exists</code> .  Ini memungkinkan waktu kompilasi untuk memverifikasi keberadaan nama dan, tergantung pada ini, mengaktifkan atau menonaktifkan kompilasi blok kode.  Dan di basis kode, yang saya gunakan beberapa tahun yang lalu, itu adalah sesuatu seperti ini.  Ada fungsi <code>f()</code> , ia mengambil titik dari tipe template dan mengambil ketinggian dari titik ini.  Ini bisa dipakai oleh titik tiga dimensi atau dua dimensi.  Untuk tiga dimensi, kami menganggap koordinat <code>z</code> sebagai tinggi, untuk dua dimensi, kami beralih ke sensor permukaan khusus.  Ini terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; __if_exists(Point::z) { h = pz; } __if_not_exists(Point::z) { h = sensor.get_height(p); } }</code> </pre> <br><p>  Di C ++ 20, kita dapat menulis ulang ini tanpa menggunakan ekstensi kompiler menggunakan kode standar.  Bagi saya sepertinya tidak menjadi lebih buruk: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requires { Point::z; })</span></span></span><span class="hljs-function"> h </span></span>= pz; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> h = sensor.get_height(p); }</code> </pre> <br><p>  Poin kedua adalah bahwa Anda harus waspada dengan sintaks yang membutuhkan ekspresi. <br>  Mereka cukup kuat, dan kekuatan ini dicapai dengan diperkenalkannya banyak konstruksi sintaksis baru.  Anda bisa bingung di dalamnya, setidaknya pada awalnya. </p><br><p>  Mari kita mendefinisikan konsep yang <code>Sizable</code> yang memeriksa bahwa wadah memiliki <code>size</code> metode konstan yang mengembalikan <code>size_t</code> .  Kami tentu berharap bahwa <code>vector&lt;int&gt;</code> cukup <code>Sizable</code> , namun <code>static_assert</code> ini <code>static_assert</code> .  Apakah Anda mengerti mengapa kami melakukan kesalahan?  Mengapa kode ini tidak dikompilasi? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { c.size() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// Fail</span></span></code> </pre> <br><p>  Biarkan saya menunjukkan kode yang mengkompilasi.  Kelas <code>X</code> seperti itu memuaskan konsep <code>Sizable</code> .  Sekarang Anda mengerti apa yang kita punya masalah? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-function"><span class="hljs-function">Inner* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;X&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>  Biarkan saya memperbaiki penyorotan kode.  Di sebelah kiri, kode ini berwarna sesuai keinginan saya.  Tetapi pada kenyataannya, itu harus dicat seperti di sebelah kanan: </p><br><p><img src="https://habrastorage.org/webt/mu/ht/l2/muhtl2zbr7nbutf7an8or2qjhse.jpeg"></p><br><p>  Lihat, warna <code>size_t</code> , berdiri setelah panah, telah berubah?  Saya ingin menjadi tipe, tetapi hanya bidang yang kami akses.  Segala sesuatu yang kita miliki memerlukan ekspresi adalah satu ekspresi besar, dan kami memeriksa kebenarannya.  Untuk tipe <code>X</code> , ya, ini adalah ekspresi yang valid; untuk <code>vector&lt;int&gt;</code> , tidak.  Untuk mencapai apa yang kita inginkan, kita perlu mengambil ekspresi dalam kurung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { {c.size()} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK struct X { struct Inner { int size_t; }; Inner* size() const; }; static_assert(Sizable&lt;X&gt;); // Fail</span></span></code> </pre> <br><p>  Tapi ini hanya contoh yang menyenangkan.  Secara umum, Anda hanya perlu berhati-hati. </p><br><h1 id="primery-ispolzovaniya-konceptov">  Contoh menggunakan konsep </h1><br><h2 id="realizaciya-klassa-pair">  Implementasi kelas berpasangan </h2><br><p>  Selanjutnya saya akan menunjukkan beberapa fragmen STL yang dapat diimplementasikan dalam C ++ 17, tetapi agak rumit. <br>  Dan kemudian kita akan melihat bagaimana dalam C ++ 20 kita dapat meningkatkan implementasi. </p><br><p>  Mari kita mulai dengan kelas <code>pair</code> . <br>  Ini adalah kelas yang sangat lama, masih dalam C ++ 98. <br>  Tidak mengandung logika yang rumit, jadi <br>  Saya ingin definisinya terlihat seperti ini. <br>  Dari sudut pandang saya, kira-kira harus diakhiri dengan ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; ... };</code> </pre> <br><p>  Tapi, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cppreference</a> , <code>pair</code> desainer hanya punya 8 buah. <br>  Dan jika Anda melihat implementasi nyata, misalnya, di Microsoft STL, maka akan ada sebanyak 15 konstruktor dari kelas <code>pair</code> .  Kami tidak akan melihat semua kekuatan ini dan membatasi diri pada konstruktor default. </p><br><p>  Tampaknya itu adalah sesuatu yang rumit?  Untuk memulainya, kami mengerti mengapa itu diperlukan.  Kami ingin jika salah satu argumen dari kelas <code>pair</code> adalah tipe sepele, katakan <code>int</code> , maka setelah membangun kelas <code>pair</code> itu diinisialisasi ke nol, dan tidak tetap tidak diinisialisasi.  Untuk melakukan ini, kami ingin menulis konstruktor yang memanggil inisialisasi nilai untuk bidang <code>f</code> (pertama) dan <code>s</code> (kedua). </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() : f() , s() {} };</code> </pre> <br><p>  Sayangnya, jika kami mencoba untuk instantiate <code>pair</code> dari sesuatu yang tidak memiliki konstruktor default, katakanlah, dari kelas <code></code> , kami segera mendapatkan kesalahan kompilasi.  Perilaku yang diinginkan adalah bahwa jika Anda mencoba membangun <code>pair</code> , defaultnya adalah kesalahan kompilasi, tetapi jika kami secara eksplisit melewatkan nilai <code>f</code> dan <code>s</code> , maka semuanya akan berfungsi: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, A&gt; a2; <span class="hljs-comment"><span class="hljs-comment">// must fail pair&lt;int, A&gt; a1; { 1, 2 }; // must be OK</span></span></code> </pre> <br><p>  Untuk melakukan ini, buat templat konstruktor default dan batasi pada SFINAE. <br>  Ide pertama yang muncul di pikiran adalah mari kita menulis sehingga konstruktor ini hanya diperbolehkan jika <code>f</code> dan <code>s</code> <code>is_default_constructable</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;F&gt;, <span class="hljs-comment"><span class="hljs-comment">// not dependent is_default_constructible&lt;S&gt; &gt;&gt;&gt; pair() : f(), s() {} };</span></span></code> </pre> <br><p>  Ini tidak akan berfungsi, karena argumen <code>enable_if_t</code> hanya bergantung pada parameter templat kelas.  Artinya, setelah substitusi kelas, mereka menjadi mandiri, mereka dapat segera dihitung.  Tetapi jika kita <code>false</code> , masing-masing, kita kembali mendapatkan kesalahan kompiler keras. </p><br><p>  Untuk mengatasinya, mari kita tambahkan lebih banyak parameter templat ke konstruktor ini dan buat ketentuan <code>enable_if_t</code> bergantung pada parameter templat ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} };</code> </pre> <br><p>  Situasinya sangat lucu.  Faktanya adalah bahwa parameter template <code>T</code> dan <code>U</code> tidak dapat diatur secara eksplisit oleh pengguna.  Dalam C + +, tidak ada sintaks untuk secara eksplisit mengatur parameter template dari konstruktor, mereka tidak dapat di-output oleh compiler, karena tidak ada tempat untuk menampilkannya.  Mereka hanya bisa datang dari nilai default.  Artinya, secara efektif kode ini tidak berbeda dengan kode pada contoh sebelumnya.  Namun, dari sudut pandang kompiler, itu valid, tetapi tidak dalam contoh sebelumnya. </p><br><p>  Kami memecahkan masalah pertama kami, tetapi kami dihadapkan dengan yang kedua, sedikit lebih halus.  Misalkan kita memiliki kelas <code>B</code> dengan konstruktor default eksplisit, dan kami ingin secara implisit membangun <code>pair&lt;int, B&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {};</code> </pre> <br><p>  Kita bisa melakukannya, tetapi, menurut standar, itu tidak akan berhasil.  Secara standar, suatu pasangan harus secara default secara implisit dibangun hanya jika kedua elemennya secara default secara default dibangun. </p><br><p>  Pertanyaan: apakah kita perlu menulis konstruktor dari pasangan eksplisit atau tidak?  Dalam C ++ 17, kami memiliki solusi Solomon: mari kita tulis ini dan itu. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> pair() : f(), s() {} };</code> </pre> <br><p>  Sekarang kami memiliki dua konstruktor default: </p><br><ul><li>  kami akan memotong salah satu dari mereka sesuai dengan SFINAE untuk kasus ketika unsur-unsur secara implisit standar dibangun; </li><li>  dan yang kedua untuk kasus sebaliknya. </li></ul><br><p>  Omong-omong, untuk mengimplementasikan tipe sifat <code>is_implicitly_default_constructible</code> di C ++ 17, saya tahu solusi seperti itu, tetapi saya tidak tahu solusinya tanpa SFINAE: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> is_implicity_default_constructible = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(test&lt;T&gt;({}, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  Jika kita sekarang mencoba membangun <code>pair &lt;int, B&gt;</code> secara implisit, maka kita mendapatkan kesalahan kompilasi, seperti yang kita inginkan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjuction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; ... pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; ... candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'conjunction_v&lt; is_default_constructible&lt;int&gt;, is_default_constructible&lt;B&gt;, is_implicity_default_constructible&lt;int&gt;, is_implicity_default_constructible&lt;B&gt; &gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, U=B]</code> </pre> <br><p>  Dalam kompiler yang berbeda, kesalahan ini akan memiliki berbagai tingkat kelayakan.  Sebagai contoh, kompiler Microsoft dalam kasus ini mengatakan: "Itu tidak mungkin untuk membangun pasangan <code>&lt;int, B&gt;</code> dari kurung keriting kosong."  GCC dan Clang akan menambahkan ini: "Kami mencoba konstruktor ini dan itu, tidak satu pun dari mereka muncul," dan mereka akan mengatakan alasan tentang masing-masing. </p><br><p>  Desainer apa yang kita miliki di sini?  Ada konstruktor yang dihasilkan oleh copy dan move compiler, ada beberapa yang ditulis oleh kami.  Dengan menyalin dan memindahkan, semuanya sederhana: mereka mengharapkan satu parameter, kami melewati nol.  Untuk konstruktor kami, alasannya adalah substitusinya floppy. </p><br><p>  GCC mengatakan: "Pergantian gagal, mencoba menemukan jenis <code>type</code> di dalam <code>enable_if&lt;false&gt;</code> - tidak dapat menemukan, maaf." </p><br><p>  Dentang menganggap situasi ini sebagai kasus khusus.  Karena itu, ia sangat keren menunjukkan kesalahan ini.  Jika kita <code>false</code> ketika mengevaluasi <code>enable_if</code> argumen pertama, dia menulis bahwa persyaratan spesifik tidak terpenuhi. </p><br><p>  Pada saat yang sama, kita sendiri merusak hidup kita dengan membuat kondisi yang rumit memungkinkan.  Kami melihat bahwa itu ternyata <code>false</code> , tetapi kami belum melihat mengapa. </p><br><p>  Ini dapat diatasi jika kita memecah <code>enable_if</code> menjadi empat dengan cara ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;U&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;U&gt;::value&gt;&gt; &gt; ...</code> </pre> <br><p>  Sekarang, ketika kami mencoba membangun pasangan secara implisit, kami mendapatkan pesan yang sangat bagus bahwa kandidat semacam itu tidak cocok, karena jenis sifat <code>is_implicitly_default_constructable</code> tidak puas: </p><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; <span class="hljs-comment"><span class="hljs-comment">// candidate template ignored: requirement 'is_implicity_default_constructible&lt;B&gt;::value' was not satisfied with...</span></span></code> </pre> <br><p>  Bahkan mungkin tampak sebentar: mengapa kita perlu konsep jika kita memiliki kompiler yang keren? <br>  Tapi kemudian kita ingat bahwa dua fungsi templat digunakan secara default untuk mengimplementasikan konstruktor, dan masing-masing templat memiliki enam parameter templat.  Untuk bahasa yang mengklaim dirinya kuat, ini adalah kegagalan. </p><br><p>  Bagaimana C ++ 20 akan membantu kami?  Pertama, singkirkan pola dengan menulis ulang ini dengan membutuhkan klausa.  Apa yang sebelumnya kita tulis di dalam <code>enable_if</code> , sekarang kita menulis di dalam argumen memerlukan klausa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;F&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;S&gt; : f(), s() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... }</span></span>;</code> </pre> <br><p>  Konsep <code>ImplicitlyDefaultConstructible</code> dapat diimplementasikan menggunakan ekspresi membutuhkan yang bagus, yang di dalamnya hampir hanya kurung dengan bentuk yang berbeda digunakan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept ImplicitlyDefaultConstructible = requires { [] (T) {} ({}); };</code> </pre> <br><p>   <code>T</code>  <code>ImplicitlyDefaultConstructible</code> ,  ,     <code>T</code>      .  ,   ,      SFINAE. </p><br><p>    C++20:   (conditional) <code>explicit</code> (    <code>noexcept</code> ).     <code>explicit</code>  .          ,     <code>explicit</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>(!ImplicityDefaultConstructible&lt;F&gt; || !ImplicityDefaultConstructible&lt;S&gt;) pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; : f(), s() {} };</code> </pre> <br><p>      ,   .      ,    <code>DefaultConstructible</code> ,   <code>explicit</code> ,       <code>explicit</code> . </p><br><h2 id="realizaciya-klassa-optional-v-c17">   Optional  C++17 </h2><br><p>       <code>Optional</code> .       ,     . </p><br><p>      .    ?   ,     C++    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Option&lt;T&gt; { None, Some(t) }</code> </pre> <br><p>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optional</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> final T value; Optional() {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = null; } Optional(T value) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } }</code> </pre> <br><p>       C++:   <code>null</code> ,    value-? </p><br><p>    C++ .    <code>initialized</code>  <code>storage</code> ,      ,   .         <code>T</code> ,     <code>optional</code>   <code>T</code>   ,  C++ memory model. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ...</code> </pre> <br><p>    ,   .  :    <code>optional</code> ,   <code>optional</code>  .     : </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-function"><span class="hljs-function">T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> move(get()); } optional() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : initialized(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} optional(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; value) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(value); } ~optional() : <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) get().~T(); } };</code> </pre><br><p>  <code>optional</code> '   .    <code>optional</code> ,   <code>optional</code>  ,   ,   <code>optional</code>      .     ,        copy  move . </p><br><p>   .   :     assignment .   ,   .      .  copy constructor.   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(other.initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(other.get()); } optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) {...} };</code> </pre> <br><p>  move assignment.    ,    : </p><br><ul><li>   <code>optional</code> ' ,    . </li><li>     ,   . </li><li>    ,   â€” ,   ,  . </li></ul><br><p>      <code>T</code>  : move constructor, move assignment  : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initilized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;other.storage) T(move(get())); get().~T(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;storage) T(move(get())); other.get().~T(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><p>         <code>noexcept</code> : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowAssignable&lt;T&gt; &amp;&amp; NothrowMoveConstructible&lt;T&gt; &amp;&amp; NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;other.storage) T(move(get())); get().~T(); } } ... }</code> </pre> <br><p>  <code>optional</code>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;); optional(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowMoveConstructible&lt;T&gt;); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); };</code> </pre> <br><p>        ,        <code>pair</code> : <br>      <code>Optional</code>  -,        (, deleted),   compilation error. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;unique_ptr&lt;int&gt;&gt;;</span></span> <span class="hljs-comment"><span class="hljs-comment">// compilation error</span></span></code> </pre> <br><p>    ,  <code>optional</code>  <code>unique_ptr</code>    , <br>  copy constructor  copy assignment   deleted.           ,    ,     SFINAE. <br>      copy  move   assignment ,       â€”     .   - ,     copy ,      . </p><br><p>   â€”  .        copy      : deleted operation , , operation: </p><br><ul><li> <code>deleted_copy_construct</code>    <code>delete</code> ,   â€” <code>default</code> ; </li><li> <code>copy_construct</code>   ,   <code>copy_construct</code>     . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deleted_copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { deleted_copy_construct(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; deleted_copy_construct(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { copy_construct(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(Base::construct(other))) { Base::construct(other); } copy_construct(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>   <code>select_copy_construct</code> ,     ,   <code>CopyConstrictuble</code>  ,    <code>copy_construct</code> ,  <code>deleted_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt; copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,    <code>optional</code> ,   <code>optional_base</code> , copy     <code>construct</code>   ,   <code>optional</code>   <br> <code>select_copy_construct&lt;T, optional_base&lt;T&gt;&gt;</code> .       copy : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((initialized = other.initialized)) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) t(other.get()); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_copy_construct&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p>      . , ,    <code>copy_construct</code>    ,  <code>move_construct</code>       <code>copy_construct</code> , <code>copy_assign</code> , ,  <code>move_construct</code> ,        , ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;MoveConstructible&lt;T&gt;, move_construct&lt;Base&gt; &gt; &gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;CopyAssignable&lt;T&gt; &amp;&amp; CopyConstructible&lt;T&gt;, copy_assign&lt;Base&gt; delete_copy_assign&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p> , <code>move_assign</code>  <code>copy_assign</code> , <code>optional_base</code>   ,    assignment   <code>construct</code>  <code>assign</code> ,  <code>optional</code>   <code>select_move_assign&lt;T, optional_base&lt;T&gt;&gt;</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class">&lt;T, ...&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowMoveConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p> ,      : <br> <code>optional&lt;unique_ptr&gt;</code>   <code>deleted_copy_construct</code> ,   <br> <code>move_construct</code>   .  ! </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>       :  <code>optional</code>   <code>TriviallyCopyable</code>    <code>TriviallyCopyable</code> . </p><br><p>   <code>TriviallyCopyable</code> ?  ,  <code>T</code>  <code>TriviallyCopyable</code> ,    <br>    <code>memcpy</code> .    ,          . </p><br><p>  ,            , ,  .    <code>resize</code>  <code>vector</code> <code>TriviallyCopyable</code> ,              <code>memcpy</code> ,       ,   .  ,  ,    . </p><br><p>      <code>TriviallyCopyable</code> , ,     <code>static_assert</code> ',    copy-move     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; {...}; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyable&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyDestructible &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;);</code> </pre> <br><p>      <code>static_assert</code> ' .  ,   ,      .   <code>optional</code> â€”  <code>aligned_storage</code> ,  ,  ,   ,  <code>TriviallyCopyable</code> . </p><br><p>    ,          .       ,     <code>TriviallyCopyable</code> . </p><br><p>  ,      .     <code>select_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p>  <code>CopyContructible</code>    <code>copy_construct</code> ,      <code>if</code>  compile-time:   <code>CopyContructible</code>  <code>TriviallyCopyContructible</code> ,     <code>Base</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, conditional_t&lt;TriviallyCopyConstructible&lt;T&gt;, Base, copy_construct&lt;Base&gt; &gt;, deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,     copy .        ,    <code>select_destruct</code>  .    <code>int</code>   ,  -     - ,    . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_destruct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;TriviallyDenstructible&lt;T&gt;, Base, destruct&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p>  ,     ,    .  , ,  : </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : destruct&lt;optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>  ,  C++17   <code>optional</code>      7;      :    <code>operation</code> , <code>deleted_operation</code>   <code>select_operation</code> ;   <code>construct</code>  <code>assign</code>   .  ,    . </p><br><p>     -   .      .        :   deleted. </p><br><p>  ,       <code>noexcept</code> . <br>  ,   ,   ,    <code>trivial</code> , <code>noexcept</code>         .   ,   ,    <code>trivial</code>  <code>noexcept</code> ,   <code>noexcept</code> ,    <code>deleted</code> .           .        ,     ,    . </p><br><p>          type trait,  ,        . , , copy :  <code>deleted</code>  ,  <code>nothrow</code>  ,    ? </p><br><p>   ,            - special member, ,    ,    ,     : </p><br><ul><li>   ,    <code>deleted</code> ,   <code>= delete</code>      <code>deleted_copy_construct</code> ; </li><li>      ,     <code>copy_construct</code> ,   c  noexcept ; </li><li> ,   ,     ,  . </li></ul><br><p>              . </p><br><h2 id="realizaciya-klassa-optional-v-c20">   optional  C++20 </h2><br><p>   C++20   <code>optional</code>   copy ? <br>   : </p><br><ul><li>   <code>T</code>  <code>CopyConstructible</code> ,     <code>deleted</code> ; </li><li>   <code>TriviallyCopyConstructible</code> ,   ; </li><li>        <code>noexcept</code> . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) requires(!CopyConstructible&lt;T&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// #1 optional(optional const &amp;) requires(TriviallyCopyConstructible&lt;T&gt;) = default; // #2 optional(optional const &amp;) noexcept(NothrowCopyConstructible&lt;T&gt;) {...} // #3 ... ~optional() requires(TriviallyDestructible&lt;T&gt;) = default; ~optional() noexcept(NothroeDestructible&lt;T&gt;) {...} };</span></span></code> </pre> <br><p>  ,   . -,     ,      <code>T</code>  requires clause      <code>false</code> .    <code>requires(false)</code> ,   ,      overload resolution.     ,        <code>requires(true)</code> ,             . <br>         ,    . </p><br><p>   requires clause    <code>= delete</code> : </p><br><ul><li>   <code>= delete</code>   overload resolution,     ,     ,     deleted . </li><li>   <code>requires(false)</code>     overload resolution. </li></ul><br><p>   ,     copy ,  ,    requires clause.       . </p><br><p>  ,      . !    C++    ,   ?  , , .        ,   ,    ,     .   ,   ,     ,      , ,   <code>optional</code> . </p><br><p> ,       ,  GCC   internal compiler error,  Clang    .   ,   .     ,  . </p><br><p>  ,   ,       <code>optional</code>  C++20.  ,   ,   C++17. </p><br><h1 id="alternativa-aligned_storage-i-aligned_union">  aligned_storage  aligned_union </h1><br><p>   :   <code>aligned_storage</code>         <code>reinterpret_cast</code> ,  <code>reinterpret_cast</code>    constexpr . ,  compile-time  <code>optional</code>   ,         compile-time.    STL   <code>aligned_storage</code>   <code>optional</code>    <code>aligned_union</code>   <code>variant</code> . ,  ,     STL  Boost    <code>optional</code>  <code>variant</code> .     <code>variant</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all_types_are_trivially_destructible, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> _Variant_storage = _Variant_storage_&lt; conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt;, _Types... &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;true, _First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;First&gt; _Head; _Variant_storage&lt;_Rest...&gt; _Tail; }; };</code> </pre> <br><p>      <code>variant</code> .    <code>_Variant_storage_</code> ,  , -, ,    <code>variant</code> ,  -,    .  ,    <code>trivially_destructible</code> ?     type alias,       .      <code>_Variant_storage_</code>  ,    <code>true</code>    <code>false</code> . ,   <code>true</code> ,  .      <code>trivially_destructible</code> ,     union     <code>Variant</code> '  . </p><br><p>  ,  ,   ,  ,    .     type alias  <code>_Variant_storage</code> .      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> = conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt; &gt; class _Variant_storage_;</code> </pre> <br><p>        .        ,   variadic template    . ,        ,            ,          <code>_Types</code> .   C++17  ,   . </p><br><p>  C++20        , <br>     ,       <br> requires clause.        C++20    requires clause: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; requires(TriviallyDestructible&lt;_First&gt; &amp;&amp; ... &amp;&amp; TriviallyDestuctible&lt;_Rest&gt;) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;_First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;_First&gt; _Head; _Variant_storage_&lt;_Rest...&gt; _Tail }; };</code> </pre> <br><p>    <code>_Variant_storage_</code> ,     <code>TriviallyDestructible</code> .  ,       requires clause   ,   ,       . </p><br><h1 id="ispolzovanie-requires-clause-dlya-template-type-alias">  requires clause  template type alias </h1><br><p> ,     requires clause   template type alias.      C++20  -  <code>enable_if</code> ,         : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> condition, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; requires condition <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span> = T;</code> </pre> <br><h1 id="kod-kotoryy-ne-podderzhit-ni-odin-kompilyator"> ,       </h1><br><p>  ,         .       : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Equivalent, but functionally not equivalent template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &lt; 239)&gt; f(); template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &gt; 239)&gt; f(); // Not equivalent template&lt;typename T&gt; requires(sizeof(T) &lt; 239) void f(); template&lt;typename T&gt; requires(sizeof(T) &gt; 239) void f();</span></span></code> </pre> <br><p>       ,     <code>enable_if</code>      .    ?     <code>f()</code> :   <code>enable_if</code> ,      ,  239, , ,  ,  239.       ,     : </p><br><ul><li>   ,      ,     template type alias',      Â«void f(); void f(); </li><li>   ,    SFINAE, ,      ,     . </li></ul><br><p> ,     <code>enable_if</code> ,      ,          <code>size &lt; 239</code> ,      <code>size &gt; 239</code> .      ,            .      ,      <code>f()</code>   .       requires clause.    â€”   ,      . </p><br><blockquote>        â€”  ,      .      C++ Russia 2019 Piter,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«:   core languageÂ»</a> .     , , :   reachable entity      visible,     ADL,   entities  internal linkage    .   ,    C++ Russia       (JetBrains)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Â«  ++20 â€”   ?Â»</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467299/">https://habr.com/ru/post/id467299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467281/index.html">Potret Ilmuwan Data di Rusia. Hanya fakta</a></li>
<li><a href="../id467283/index.html">Bagaimana menjelaskan kepada nenek Anda perbedaan antara SQL dan NoSQL</a></li>
<li><a href="../id467289/index.html">Mengembangkan OS seperti Unix yang monolitik - GDT & IDT (5)</a></li>
<li><a href="../id467291/index.html">iOS untuk kreativitas: menggambar</a></li>
<li><a href="../id467295/index.html">View Binding yang sudah lama dinanti di Android</a></li>
<li><a href="../id467301/index.html">Bagaimana AI bekerja di Hitman (2016)</a></li>
<li><a href="../id467303/index.html">Kisah programmer PSB termuda: hackathon menjadi pintu ke bank</a></li>
<li><a href="../id467305/index.html">Ketika kota pintar: pengalaman kota-kota besar</a></li>
<li><a href="../id467313/index.html">Replikasi Lintas Antara PostgreSQL dan MySQL</a></li>
<li><a href="../id467317/index.html">Bagaimana SoftBank menelan dunia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>