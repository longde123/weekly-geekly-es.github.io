<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎉 🈸 ⛽️ Unix-ähnliche Betriebssystementwicklung - Multitasking und Systemaufrufe (7) 🧖🏼 ⬅️ 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Artikel haben wir gelernt, wie man mit virtuellem Adressraum arbeitet. Heute werden wir Multitasking-Unterstützung hinzufügen. 

 Inhalt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unix-ähnliche Betriebssystementwicklung - Multitasking und Systemaufrufe (7)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468057/">  Im vorherigen Artikel haben wir gelernt, wie man mit virtuellem Adressraum arbeitet.  Heute werden wir Multitasking-Unterstützung hinzufügen. <br><a name="habracut"></a><br><h4>  Inhaltsverzeichnis </h4><br>  Build-System (make, gcc, gas).  Erster Start (Multiboot).  Starten Sie (qemu).  C-Bibliothek (strcpy, memcpy, strext). <br><br>  C-Bibliothek (sprintf, strcpy, strcmp, strtok, va_list ...).  Erstellen der Bibliothek im Kernelmodus und im Benutzeranwendungsmodus. <br><br>  Das Kernel-Systemprotokoll.  Videospeicher  Ausgabe an das Terminal (kprintf, kpanic, kassert). <br>  Dynamischer Speicher, Heap (kmalloc, kfree). <br><br>  Organisation der Speicher- und Interrupt-Behandlung (GDT, IDT, PIC, Syscall).  Ausnahmen <br>  Virtueller Speicher (Seitenverzeichnis und Seitentabelle). <br><br>  <b>Prozess.</b>  <b>Planer</b>  <b>Multitasking.</b>  <b>Systemaufrufe (kill, exit, ps).</b> <br>  Das Dateisystem des Kernels (initrd), elf und seiner Interna.  Systemaufrufe (exec). <br><br>  Zeichengerätetreiber.  Systemaufrufe (ioctl, fopen, fread, fwrite).  C-Bibliothek (fopen, fclose, fprintf, fscanf). <br><br>  Shell als komplettes Programm für den Kernel. <br><br>  Benutzerschutzmodus (Ring3).  Aufgabenstatussegment (tss). <br><br><h4>  Multitasking </h4><br>  Wie Sie sich erinnern, sollte jeder Prozess einen eigenen Adressraum haben. <br><br>  Dazu müssen Sie die vom Prozess verwendeten Seiten zählen. <br><br>  Daher müssen wir die Erinnerung an den Prozess beschreiben: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Process memory description */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_mem_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pages; <span class="hljs-comment"><span class="hljs-comment">/* task physical pages */</span></span> u_int pages_count; <span class="hljs-comment"><span class="hljs-comment">/* task physical pages count */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* page_dir; <span class="hljs-comment"><span class="hljs-comment">/* page directory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* page_table; <span class="hljs-comment"><span class="hljs-comment">/* page table */</span></span> };</code> </pre> <br>  Prozesse müssen irgendwie Informationen miteinander austauschen.  Dazu führen wir das Konzept einer Nachricht ein: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> {</span></span> u_short type; <span class="hljs-comment"><span class="hljs-comment">/* message type */</span></span> u_int len; <span class="hljs-comment"><span class="hljs-comment">/* data length */</span></span> u8 data[IPC_MSG_DATA_BUFF_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* message data */</span></span> };</code> </pre><br>  Danach müssen Sie den Prozess selbst als Element einer zyklischen Liste beschreiben. <br><br>  Die zyklische Liste hier ist praktisch, da Sie im Scheduler aus jeder Aufgabe die nächste auswählen müssen, bis die Liste leer ist. <br><br>  Auf diese Weise entfernen wir den entarteten Fall, was bedeutet, dass wir die Logik vereinfachen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Process descriptor */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* should be at first */</span></span> u_short tid; <span class="hljs-comment"><span class="hljs-comment">/* task id */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* task name */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* general purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* other purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* processor flags */</span></span> u_int time; <span class="hljs-comment"><span class="hljs-comment">/* time of task execution */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reschedule; <span class="hljs-comment"><span class="hljs-comment">/* whether task need to be rescheduled */</span></span> u_short status; <span class="hljs-comment"><span class="hljs-comment">/* task status */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> msg_count_in; <span class="hljs-comment"><span class="hljs-comment">/* count of incomming messages */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_buff</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TASK_MSG_BUFF_SIZE</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-comment"><span class="hljs-comment">/* task message buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* kstack; <span class="hljs-comment"><span class="hljs-comment">/* kernel stack top */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ustack; <span class="hljs-comment"><span class="hljs-comment">/* user stack top */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_mem_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_mem</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* task memory */</span></span> } attribute(packed);</code> </pre><br>  Wir werden jedem Prozess ein Kontingent zuweisen, die Anzahl der Timer-Unterbrechungen, nach denen der Prozess neu geplant wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_QUOTA 3</span></span></code> </pre><br>  Als nächstes müssen Sie eine Funktion schreiben, um einen neuen Prozess zu erstellen. <br><br>  Wir haben zwar keine Berechtigungsstufen, verwenden jedoch Kernel-Selektoren. <br><br>  Wir werden für die Zukunft 2 Stapel benötigen, einen für den Benutzermodus und einen für den Kernel. <br><br>  Wir setzen den Anfangsstatus als TASK_UNINTERRUPTABLE, damit die Aufgabe vor der vollständigen Initialisierung keine Zeit zum Abschließen hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Create new task */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_short tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* address, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">task_mem_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *task_mem)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* allocate memory */</span></span> entry = clist_insert_entry_after(&amp;task_list, task_list.head); task = (struct <span class="hljs-keyword"><span class="hljs-keyword">task_t</span></span>*)entry-&gt;data; task-&gt;kstack = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(TASK_KSTACK_SIZE); task-&gt;ustack = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(TASK_USTACK_SIZE); <span class="hljs-comment"><span class="hljs-comment">/* fill data */</span></span> task-&gt;tid = tid; task-&gt;name[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; task-&gt;status = TASK_UNINTERRUPTABLE; task-&gt;msg_count_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; task-&gt;time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;task-&gt;task_mem, task_mem, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">task_mem_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* set flags */</span></span> *(u32*)(&amp;task-&gt;flags) = asm_get_eflags() | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* set general purpose registers */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;task-&gt;gp_registers, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* set other purpose registers */</span></span> task-&gt;op_registers.cs = GDT_KCODE_SELECTOR; task-&gt;op_registers.ds = GDT_KDATA_SELECTOR; task-&gt;op_registers.ss = GDT_KSTACK_SELECTOR; task-&gt;op_registers.eip = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)address; task-&gt;op_registers.cr3 = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)task_mem-&gt;page_dir; task-&gt;op_registers.k_esp = (u32)task-&gt;kstack + TASK_KSTACK_SIZE; task-&gt;op_registers.u_esp = (u32)task-&gt;ustack + TASK_USTACK_SIZE; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_SCHED_TID_CREATE, tid, (u_int)address, task-&gt;kstack, task-&gt;ustack); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Der Prozess wird vom Scheduler gelöscht, wenn der Status des Prozesses TASK_KILLING lautet. <br>  Beim Löschen müssen nur die Stapel, Seiten für Daten- und Codeabschnitte freigegeben und das Verzeichnis der Prozessseiten zerstört werden. <br><br>  Im Allgemeinen können Sie für einen guten Benutzerstapel über den Speichermanager zuweisen, aber der Einfachheit halber das Debuggen, während wir es im Heap des Kernels implementieren, der sich immer in den Seitenverzeichnissen befindet. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Delete task by id */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">task_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* task)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_SCHED_TID_DELETE, (u_int)task-&gt;tid); assert(task != null); <span class="hljs-comment"><span class="hljs-comment">/* free stack memory */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(task-&gt;kstack); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(task-&gt;ustack); task-&gt;kstack = null; task-&gt;ustack = null; <span class="hljs-comment"><span class="hljs-comment">/* free user pages memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task-&gt;task_mem.pages_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mm_phys_free_pages(task-&gt;task_mem.pages, task-&gt;task_mem.pages_count); task-&gt;task_mem.pages = null; task-&gt;task_mem.pages_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* clear resources */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task-&gt;task_mem.page_dir != null) { mmu_destroy_user_page_directory(task-&gt;task_mem.page_dir, task-&gt;task_mem.page_table); } clist_delete_entry(&amp;task_list, (struct <span class="hljs-keyword"><span class="hljs-keyword">clist_head_t</span></span>*)task); }</code> </pre><br>  Jetzt müssen Sie den Scheduler selbst schreiben. <br><br>  Zuerst müssen wir verstehen, ob die aktuelle Aufgabe ausgeführt wird oder ob dies die erste Ausführung ist. <br>  Wenn die Aufgabe ausgeführt wird, müssen Sie überprüfen, ob das Kontingent erschöpft ist. <br>  Wenn ja, müssen Sie den Status speichern, indem Sie das Aktivierungs-Interrupt-Flag explizit angeben. <br>  Danach müssen Sie die nächste auszuführende Aufgabe im Status TASK_RUNNING finden. <br>  Als Nächstes müssen Sie die aktuelle Aufgabe abschließen, wenn sie sich im Status TASK_KILLING befindet. <br>  Danach bereiten wir den Stapelrahmen für die nächste Aufgabe vor und wechseln den Kontext. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Schedule task to run */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sched_schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ret_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reg_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_task</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* finish current task */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_task != null) { <span class="hljs-comment"><span class="hljs-comment">/* update running time */</span></span> current_task-&gt;time += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* check quota exceed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_task-&gt;time &lt; TASK_QUOTA &amp;&amp; !current_task-&gt;reschedule) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* continue task execution */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* reset quota */</span></span> current_task-&gt;time = <span class="hljs-number"><span class="hljs-number">0</span></span>; current_task-&gt;reschedule = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* save task state */</span></span> current_task-&gt;op_registers.eip = *ret_addr; current_task-&gt;op_registers.cs = *(u16*)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">4</span></span>); *(u32*)(&amp;current_task-&gt;flags) = *(u32*)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; current_task-&gt;op_registers.u_esp = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">12</span></span>; current_task-&gt;gp_registers.esp = current_task-&gt;op_registers.u_esp; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;current_task-&gt;gp_registers, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)reg_addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>)); } <span class="hljs-comment"><span class="hljs-comment">/* pick next task */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_task) { next_task = task_get_next_by_status(TASK_RUNNING, current_task); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { next_task = task_get_by_status(TASK_RUNNING); tss_set_kernel_stack(next_task-&gt;kstack); } assert(next_task != null); <span class="hljs-comment"><span class="hljs-comment">/* whether should kill current task */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_task &amp;&amp; current_task-&gt;status == TASK_KILLING) { <span class="hljs-comment"><span class="hljs-comment">/* kill current task */</span></span> task_delete(current_task); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* try to kill killing tasks */</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">task_t</span></span>* task; task = task_find_by_status(TASK_KILLING); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task) { task_delete(task); } } <span class="hljs-comment"><span class="hljs-comment">/* prepare context for the next task */</span></span> next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32*)(next_task-&gt;op_registers.u_esp) = (*(u16*)(&amp;next_task-&gt;flags)) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32*)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.cs; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32*)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.eip; next_task-&gt;gp_registers.esp = next_task-&gt;op_registers.u_esp; next_task-&gt;op_registers.u_esp -= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)next_task-&gt;op_registers.u_esp, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)&amp;next_task-&gt;gp_registers, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* update current task pointer */</span></span> current_task = next_task; <span class="hljs-comment"><span class="hljs-comment">/* run next task */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_SCHED_NEXT, next_task-&gt;tid, next_task-&gt;op_registers.u_esp, *ret_addr, next_task-&gt;op_registers.eip); asm_switch_ucontext(next_task-&gt;op_registers.u_esp, next_task-&gt;op_registers.cr3); }</code> </pre><br>  Es bleibt eine Taskkontextumschaltfunktion zu schreiben. <br><br>  Dazu müssen Sie ein neues Seitenverzeichnis herunterladen und alle allgemeinen Register einschließlich der Flags wiederherstellen. <br><br>  Sie müssen auch zum Stapel der nächsten Aufgabe wechseln. <br><br>  Als nächstes müssen Sie vom Interrupt zurückkehren, da wir hierfür einen speziellen Stapelrahmen gebildet haben. <br><br>  Für die Tatsache, dass wir dies später benötigen, um die Berechtigungsstufen zu wechseln. <br><br><pre> <code class="plaintext hljs">/* * Switch context (to kernel ring) * void asm_switch_kcontext(u32 esp, u32 cr3) */ asm_switch_kcontext: mov 4(%esp),%ebp # ebp = esp mov 8(%esp),%eax # eax = cr3 mov %cr0,%ebx # ebx = cr0 and $0x7FFFFFFF,%ebx # unset PG bit mov %ebx,%cr0 mov %eax,%cr3 or $0x80000001,%ebx # set PE &amp; PG bits mov %ebx,%cr0 mov %ebp,%esp popal sti iretl</code> </pre><br>  Wir implementieren den einfachsten Messaging-Mechanismus zwischen Prozessen. <br><br>  Wenn wir eine Nachricht an einen Prozess senden, muss sie aufgetaut werden, wenn sie eingefroren ist, weil sie auf Nachrichten wartet. <br><br>  Wenn wir jedoch eine Nachricht erhalten, müssen wir den Prozess einfrieren, wenn die Nachrichtenwarteschlange leer ist. <br><br>  Danach müssen Sie die Kontrolle an den Scheduler übertragen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Send message to task */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ksend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_short tid, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* get target task */</span></span> task = task_get_by_id(tid); <span class="hljs-comment"><span class="hljs-comment">/* put message to task buffer */</span></span> task_pack_message(task, msg); <span class="hljs-comment"><span class="hljs-comment">/* whether task has frozen */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task-&gt;status == TASK_INTERRUPTABLE) { <span class="hljs-comment"><span class="hljs-comment">/* defrost task */</span></span> task-&gt;status = TASK_RUNNING; } } <span class="hljs-comment"><span class="hljs-comment">/* * Api - Receive message to task * This function has blocking behaviour */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kreceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_short tid, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_before</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* before yield */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_after</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* after yield */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* get current task */</span></span> task_before = sched_get_current_task(); assert(tid == task_before-&gt;tid); assert(task_before-&gt;status == TASK_RUNNING); <span class="hljs-comment"><span class="hljs-comment">/* whether task has not incomming messages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task_before-&gt;msg_count_in == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* freeze task */</span></span> task_before-&gt;status = TASK_INTERRUPTABLE; } <span class="hljs-comment"><span class="hljs-comment">/* wait fot message */</span></span> sched_yield(); <span class="hljs-comment"><span class="hljs-comment">/* get current task */</span></span> task_after = sched_get_current_task(); assert(task_after == task_before); assert(tid == task_after-&gt;tid); assert(task_after-&gt;status == TASK_RUNNING); <span class="hljs-comment"><span class="hljs-comment">/* fetch message from buffer */</span></span> task_extract_message(task_after, msg); assert(msg != null); }</code> </pre><br>  Jetzt müssen Sie Systemaufrufe schreiben, um mit Prozessen aus Benutzeranwendungen arbeiten zu können. <br><br>  Dort werden wir Systemaufrufe auslösen, um Nachrichten zu senden und zu empfangen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Syscall handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ih_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_int* function)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> params_addr = ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)function + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(u_int)); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sched_get_current_task</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_SYSCALL, *function, current-&gt;tid); asm_lock(); <span class="hljs-comment"><span class="hljs-comment">/* handle syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*function) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SYSCALL_KSEND: { <span class="hljs-comment"><span class="hljs-comment">/* send message */</span></span> u_short tid = *(u_int*)params_addr; ksend(tid, *(struct <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span>**)(params_addr + <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SYSCALL_KRECEIVE: { <span class="hljs-comment"><span class="hljs-comment">/* receive message */</span></span> u_short tid = *(u_int*)params_addr; kreceive(tid, *(struct <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span>**)(params_addr + <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SYSCALL_KILL: { <span class="hljs-comment"><span class="hljs-comment">/* kill task */</span></span> u_short tid = *(u_int*)params_addr; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_find_by_id</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tid</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task != null) { assert(task-&gt;tid == tid); task-&gt;status = TASK_KILLING; task-&gt;reschedule = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; result = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SYSCALL_EXIT: { <span class="hljs-comment"><span class="hljs-comment">/* exit task */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errno = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)params_addr; u_int tid = current-&gt;tid; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_TASK_FINISHED, tid, errno); current-&gt;status = TASK_KILLING; sched_yield(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SYSCALL_TASK_LIST: { <span class="hljs-comment"><span class="hljs-comment">/* get tasks list */</span></span> result = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)task_get_task_list(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: unreachable(); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(MSG_SYSCALL_RET, *function); asm_unlock(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Um die Systemaufrufe aus unserer C-Bibliothek verwenden zu können, müssen wir eine Funktion schreiben, die einen Kernel-Interrupt verursacht.  Der Einfachheit halber werden wir keine speziellen Intel-Befehle verwenden, da wir keine Berechtigungsstufen haben.  Als Argument übergeben wir die Nummer der Systemfunktion und die Argumente, die sie benötigt. <br><br><pre> <code class="plaintext hljs">/* * Call kernel * void asm_syscall(unsigned int function, ...) */ asm_syscall: push %ebx push %ebp mov %esp,%ebp mov %ebp,%ebx add $8,%ebx # skip registers add $4,%ebx # skip return address push %ebx # &amp;function int $0x80 mov %ebp,%esp pop %ebp pop %ebx ret</code> </pre><br>  Dies reicht völlig aus, um das einfachste Multitasking ohne die Unterstützung von Schutzringen zu implementieren.  Öffnen Sie jetzt das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial</a> und schauen Sie sich alles in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">richtigen</a> Reihenfolge an! <br><br><h4>  Referenzen </h4><br>  Details und Erklärungen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial</a> . <br><br>  Der Quellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Git-Repository</a> (Sie benötigen den Lektion7-Zweig). <br><br><h4>  Referenzliste </h4><br>  1. James Molloy.  Rollen Sie Ihr eigenes UNIX-Klon-Betriebssystem. <br>  2. Zähne.  Assembler für DOS, Windows, Unix <br>  3. Kalaschnikow.  Assembler ist einfach! <br>  4. Tanenbaum.  Betriebssysteme.  Implementierung und Entwicklung. <br>  5. Robert Love.  Linux-Kernel  Beschreibung des Entwicklungsprozesses. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468057/">https://habr.com/ru/post/de468057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468043/index.html">So erstellen Sie ein UI-Kit, das zum Verkauf steht. Entwicklungsstadien eines kommerziellen Designsystems</a></li>
<li><a href="../de468047/index.html">Arbeiten mit Hierarchien in lsFusion</a></li>
<li><a href="../de468049/index.html">Verwenden von werf zum Ausrollen komplexer Helmdiagramme</a></li>
<li><a href="../de468051/index.html">VDS mit lizenziertem Windows Server für 100 Rubel: Mythos oder Realität?</a></li>
<li><a href="../de468053/index.html">Maschinelles Lernen für Ihre Wohnungssuche. Teil 1</a></li>
<li><a href="../de468059/index.html">Meine zweite Woche mit Haiku: viele versteckte Diamanten und angenehme Überraschungen sowie einige Probleme</a></li>
<li><a href="../de468061/index.html">Cron unter Linux: Verlauf, Verwendung und Gerät</a></li>
<li><a href="../de468063/index.html">Angulareact</a></li>
<li><a href="../de468065/index.html">Mentale Produktmanagementmodelle für alle</a></li>
<li><a href="../de468067/index.html">So funktioniert Alpha Compositing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>