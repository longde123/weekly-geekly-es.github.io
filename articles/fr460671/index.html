<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèâ üë®üèΩ‚Äçüè´ ‚§µÔ∏è Propri√©t√© et emprunt en D üó®Ô∏è üò© üöé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Presque tous les programmes non triviaux allouent et utilisent la m√©moire dynamique. Le faire correctement devient de plus en plus important car les p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propri√©t√© et emprunt en D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460671/"><img src="https://habrastorage.org/webt/gp/qe/oo/gpqeookkvehf2hdsowdegomcqai.png" align="right">  Presque tous les programmes non triviaux allouent et utilisent la m√©moire dynamique.  Le faire correctement devient de plus en plus important car les programmes deviennent plus complexes et les erreurs sont encore plus ch√®res. <br><br>  Les probl√®mes typiques sont: <br><br><ol><li>  fuites de m√©moire (pas de lib√©ration de m√©moire √©puis√©e) </li><li>  double lib√©ration (lib√©ration de la m√©moire plus d'une fois) </li><li>  utilisation apr√®s lib√©ration (utilisation d'un pointeur sur une m√©moire pr√©c√©demment lib√©r√©e) </li></ol><br>  La t√¢che consiste √† suivre les pointeurs responsables de la lib√©ration de la m√©moire (c'est-√†-dire ceux qui en sont propri√©taires) et √† distinguer les pointeurs qui pointent simplement vers un morceau de m√©moire, contr√¥lent o√π ils se trouvent et lesquels d'entre eux sont actifs (dans la port√©e). <br><a name="habracut"></a><br>  Les solutions typiques sont les suivantes: <br><br><ol><li>  Garbage Collection (GC) - GC poss√®de des blocs de m√©moire et les recherche p√©riodiquement des pointeurs vers ces blocs.  Si aucun pointeur n'est trouv√©, la m√©moire est lib√©r√©e.  Ce sch√©ma est fiable et est utilis√© dans des langages tels que Go et Java.  Mais GC a tendance √† utiliser beaucoup plus de m√©moire que n√©cessaire, a des pauses et ralentit le code en raison du reconditionnement (portes d'√©criture ins√©r√©es √† l'origine). </li><li>  Comptage de r√©f√©rences (RC) - Un objet RC poss√®de de la m√©moire et stocke un compteur de pointeurs pour lui-m√™me.  Lorsque ce compteur diminue √† z√©ro, la m√©moire est lib√©r√©e.  C'est √©galement un m√©canisme fiable et est accept√© dans des langages comme C ++ et ObjectiveC.  RC est efficace en m√©moire, ne n√©cessitant en outre que de l'espace sous le comptoir.  Les aspects n√©gatifs de RC sont la surcharge de maintenance du compteur, l'incorporation d'un gestionnaire d'exceptions pour assurer sa r√©duction et le blocage n√©cessaire pour les objets partag√©s entre les flux de programme.  Pour am√©liorer les performances, les programmeurs ont parfois tromp√© en se r√©f√©rant temporairement √† un objet RC contournant le compteur, ce qui cr√©e le risque de le faire incorrectement. </li><li>  Contr√¥le manuel - La gestion manuelle de la m√©moire est Sysalny malloc et gratuite.  Il est rapide et efficace en termes d‚Äôutilisation de la m√©moire, mais le langage n‚Äôaide pas √† tout faire correctement, s‚Äôappuyant enti√®rement sur l‚Äôexp√©rience et le z√®le du programmeur.  J'utilise malloc et gratuit depuis 35 ans, et avec l'aide d'une exp√©rience am√®re et sans fin, je fais rarement des erreurs.  Mais ce n'est pas de cette fa√ßon que la technologie de programmation peut s'appuyer, et notez que j'ai dit "rarement" et non "jamais". </li></ol><br>  Les solutions 2 et 3 √† un degr√© ou √† un autre reposent sur la confiance du programmeur pour tout faire correctement.  Les syst√®mes bas√©s sur la foi n'√©voluent pas bien et les erreurs de gestion de la m√©moire s'av√®rent tr√®s difficiles √† rev√©rifier (si mauvaises que certaines normes de codage interdisent l'utilisation de la m√©moire dynamique). <br><br>  Mais il existe √©galement une quatri√®me voie: propri√©t√© et emprunt, OB.  Il est efficace en m√©moire, aussi rapide que le fonctionnement manuel, et est soumis √† une nouvelle v√©rification automatique.  La m√©thode a r√©cemment √©t√© popularis√©e par le langage de programmation Rust.  Elle pr√©sente √©galement ses inconv√©nients, notamment la n√©cessit√© de repenser la planification des algorithmes et des structures de donn√©es. <br><br>  Vous pouvez traiter des aspects n√©gatifs et le reste de cet article est une description sch√©matique du fonctionnement du syst√®me OB et de la fa√ßon dont nous proposons de l'√©crire dans le langage D. J'ai d'abord consid√©r√© cela comme impossible, mais apr√®s y avoir r√©fl√©chi, j'ai trouv√© un moyen.  C'est similaire √† ce que nous avons fait avec la programmation fonctionnelle - avec l'immuabilit√© transitive et les fonctions "pures". <br><br><h3>  Possession </h3><br>  La d√©cision de qui d√©tient l'objet en m√©moire est ridiculement simple - il n'y a qu'un seul pointeur sur l'objet et c'est le propri√©taire.  Il est √©galement responsable de la lib√©ration de la m√©moire, apr√®s quoi celle-ci devient invalide.  En raison du fait que le pointeur vers l'objet en m√©moire est le propri√©taire, il n'y a pas d'autres pointeurs √† l'int√©rieur de cette structure de donn√©es, et donc la structure de donn√©es forme un arbre. <br><br>  La deuxi√®me cons√©quence est que les pointeurs utilisent la s√©mantique du d√©placement plut√¥t que de la copie: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); T* q = p; <span class="hljs-comment"><span class="hljs-comment">//  p   q,    g(p); // , p  </span></span></code> </pre> <br>  Il est interdit de supprimer un pointeur de l'int√©rieur d'une structure de donn√©es: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> T* p; } <span class="hljs-function"><span class="hljs-function">S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); T* q = sp; <span class="hljs-comment"><span class="hljs-comment">// ,      sp</span></span></code> </pre> <br>  Pourquoi ne pas simplement marquer sp comme invalide?  Le probl√®me est que cela n√©cessitera de d√©finir l'√©tiquette en runtime, mais devrait √™tre r√©solu au stade de la compilation, car il est simplement consid√©r√© comme une erreur de compilation. <br><br>  La sortie du propre pointeur hors de port√©e est √©galement une erreur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); } <span class="hljs-comment"><span class="hljs-comment">// ,   p?</span></span></code> </pre> <br>  Vous devez d√©placer la valeur du pointeur diff√©remment: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">//   g(),    g() }</span></span></code> </pre> <br>  Cela r√©sout les probl√®mes de fuite de m√©moire et d'utilisation apr√®s la lib√©ration (indice: pour plus de clart√©, remplacez f () par malloc () et g () par free ().) <br><br>  Tout cela peut √™tre v√©rifi√© au stade de la compilation √† l'aide de la technique d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse de flux de donn√©es (DFA)</a> , tout comme elle est utilis√©e pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">supprimer les sous-expressions courantes</a> . DFA peut d√©nouer tout enchev√™trement de rats des transitions de programme qui peuvent survenir. <br><br><h3>  Emprunter </h3><br>  Le r√©gime foncier d√©crit ci-dessus est fiable, mais trop restrictif. <br>  Consid√©rez: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-function">struct S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); s.car(); <span class="hljs-comment"><span class="hljs-comment">// s   car() s.bar(); // , s </span></span></code> </pre> <br>  Pour que cela fonctionne, s.car () doit avoir un moyen de r√©cup√©rer le pointeur √† la sortie. <br><br>  Voil√† comment fonctionne l'emprunt.  s.car () prend une copie de s pour la dur√©e de s.car ().  s n'est pas valide au moment de l'ex√©cution et redevient valide lorsque s.car () se ferme. <br><br>  En D, les fonctions membres <i>struct</i> obtiennent le pointeur <i>this</i> par r√©f√©rence, afin que nous puissions adapter l'emprunt avec une petite extension: obtenir l'argument par r√©f√©rence le prend. <br><br>  D prend √©galement en charge la port√©e des pointeurs, l'emprunt est donc naturel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">// g()  p g(p); //    p     g()</span></span></code> </pre> <br>  (Lorsque les fonctions re√ßoivent des arguments par r√©f√©rence ou que des pointeurs avec port√©e sont utilis√©s, il leur est interdit de s'√©tendre au-del√† des limites d'une fonction ou d'une port√©e. Cela correspond √† la s√©mantique de l'emprunt.) <br><br>  Emprunter de cette mani√®re garantit l'unicit√© d'un pointeur sur un objet en m√©moire √† un instant donn√©. <br><br>  L'emprunt peut √™tre √©tendu davantage en sachant que le syst√®me de propri√©t√© est √©galement fiable, m√™me si un objet est en outre indiqu√© par plusieurs pointeurs constants (mais un seul mutable).  Un pointeur constant ne peut pas changer la m√©moire ni la lib√©rer.  Cela signifie que plusieurs pointeurs constants peuvent √™tre emprunt√©s au propri√©taire mutable, mais il n'a pas le droit d'√™tre utilis√© tant que ces pointeurs constants sont vivants. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); <span class="hljs-comment"><span class="hljs-comment">// p   { scope const T* q = p; //    scope const T* r = p; //    g(p); // , p   q  r    } g(p); // ok</span></span></code> </pre> <br><h3>  Principes </h3><br>  Ce qui pr√©c√®de peut √™tre r√©duit √† la compr√©hension suivante qu'un objet en m√©moire se comporte comme s'il √©tait dans l'un des deux √©tats suivants: <br><br><ol><li>  il y a exactement un pointeur mutable </li><li>  un ou plusieurs pointeurs constants suppl√©mentaires </li></ol><br>  Un lecteur attentif remarquera quelque chose d'√©trange dans ce que j'ai √©crit: ¬´comme si¬ª.  √Ä quoi voulais-je faire allusion?  Que se passe-t-il?  Oui, il y en a un.  Les langages de programmation informatique sont pleins de ¬´comme si¬ª sous le capot, quelque chose comme l'argent dans votre compte bancaire n'est en fait pas l√† (je m'excuse si cela a √©t√© un choc brutal pour quelqu'un), et ce n'est pas diff√©rent de cela.  Continuez √† lire! <br><br>  Mais d'abord, un peu plus profond√©ment dans le sujet. <br><br><h3>  Int√©gration des techniques de propri√©t√© / emprunt dans D </h3><br>  Ces techniques ne sont-elles pas incompatibles avec la fa√ßon dont les gens √©crivent habituellement en D, et presque tous les programmes D existants ne se cassent-ils pas?  Et ce n'est pas si facile √† r√©parer, mais tellement que vous devez repenser tous les algorithmes √† partir de z√©ro? <br><br>  Oui en effet.  A moins que D n'ait une arme (presque) secr√®te: les attributs des fonctions.  Il s'av√®re que la s√©mantique de propri√©t√© / emprunt (OB) peut √™tre impl√©ment√©e s√©par√©ment pour chaque fonction apr√®s l'analyse s√©mantique habituelle.  Un lecteur attentif pourrait remarquer qu'aucune nouvelle syntaxe n'a √©t√© ajout√©e, seules des restrictions ont √©t√© impos√©es sur le code existant.  D a d√©j√† un historique d'utilisation des attributs de fonction pour changer leur s√©mantique, par exemple, l'attribut <i>pur</i> pour cr√©er des fonctions ¬´pures¬ª.  Pour activer la s√©mantique OB, l'attribut @ <i>live</i> est ajout√©. <br><br>  Cela signifie que l'OB peut √™tre ajout√© au code sur D progressivement, selon les besoins et les ressources gratuites.  Cela permet d'ajouter des OB, ce qui est essentiel, en soutenant constamment le projet dans un √©tat pleinement fonctionnel, test√© et pr√™t √† √™tre publi√©.  Il vous permet √©galement d'automatiser le processus de surveillance du pourcentage du projet qui a d√©j√† √©t√© transf√©r√© √† l'OB.  Cette technique est ajout√©e √† la liste des autres garanties du langage D concernant la fiabilit√© du travail avec la m√©moire (comme le contr√¥le de la non-distribution des pointeurs sur les variables temporaires de la pile). <br><br><h3>  Comme si </h3><br>  Certaines choses n√©cessaires ne peuvent pas √™tre r√©alis√©es avec le strict respect des OB, tels que les objets de comptage de r√©f√©rences.  Apr√®s tout, les objets RC sont con√ßus pour avoir de nombreux pointeurs vers eux.  √âtant donn√© que les objets RC sont s√ªrs lors de l'utilisation de la m√©moire (s'ils sont correctement mis en ≈ìuvre), ils peuvent √™tre utilis√©s avec des OB sans affecter n√©gativement la fiabilit√©.  Ils ne peuvent tout simplement pas √™tre cr√©√©s √† l'aide de la technique OB.  La solution est qu'il existe d'autres attributs de fonction dans D, comme @ <i>system</i> .  @ <i>system</i> sont des fonctionnalit√©s o√π de nombreux contr√¥les de fiabilit√© sont d√©sactiv√©s.  Naturellement, l'OB sera √©galement d√©sactiv√© dans le code avec @ <i>system</i> .  C'est l√† que la mise en ≈ìuvre de la technologie RC se cache du contr√¥le OB. <br><br>  Mais dans le code avec OB, RC, l'objet a l'air de suivre toutes les r√®gles, donc pas de probl√®me! <br><br>  Il faudra un certain nombre de types de biblioth√®ques similaires pour fonctionner correctement avec OB. <br><br><h3>  Conclusion </h3><br>  Cet article est un aper√ßu de base de la technologie OB.  Je travaille sur une sp√©cification beaucoup plus d√©taill√©e.  Il est possible que j'ai rat√© quelque chose et quelque part un trou sous la ligne de flottaison, mais jusqu'√† pr√©sent, tout semble bien.  Il s'agit d'un d√©veloppement tr√®s excitant pour D et j'ai h√¢te de le mettre en ≈ìuvre. <br><br>  Pour plus de discussions et commentaires de Walter, reportez-vous aux rubriques sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">/ r / programmation subreddit</a> et sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hacker News</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460671/">https://habr.com/ru/post/fr460671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460659/index.html">Utilisation de tuyaux pour pivoter</a></li>
<li><a href="../fr460661/index.html">Tout ce que vous devez savoir sur Node.js</a></li>
<li><a href="../fr460665/index.html">Projet de FAQ: Pourquoi les normes C ++ sont-elles publi√©es tous les trois ans?</a></li>
<li><a href="../fr460667/index.html">Automatisation des tests de services payants sur iOS</a></li>
<li><a href="../fr460669/index.html">Comment assurer la s√©curit√© du d√©veloppement, gagner du temps et des nerfs</a></li>
<li><a href="../fr460673/index.html">Exposez la magie de DiffUtil</a></li>
<li><a href="../fr460675/index.html">Extraction de donn√©es d'apprentissage automatique</a></li>
<li><a href="../fr460683/index.html">Projecteur d'√©v√©nements Laravel et concept de g√©n√©ration d'√©v√©nements</a></li>
<li><a href="../fr460685/index.html">Nous distribuons des fichiers √† partir de Google Drive en utilisant nginx</a></li>
<li><a href="../fr460687/index.html">A quoi ressemblent les canettes de l'int√©rieur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>