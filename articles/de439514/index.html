<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏼 🦆 👩🏽‍✈️ Tarantool-Replikation: Konfiguration und Verwendung 👨🏾‍🎤 🚇 📓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich betrete das Tarantool Core Team und beteilige mich an der Entwicklung eines Datenbankmoduls, der internen Kommunikation von Serverkomponenten und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool-Replikation: Konfiguration und Verwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/439514/"><img src="https://habrastorage.org/webt/ec/a3/bt/eca3bttl2uu6rg8sz7e9sj3o3us.jpeg"><br><br>  Ich betrete das Tarantool Core Team und beteilige mich an der Entwicklung eines Datenbankmoduls, der internen Kommunikation von Serverkomponenten und der Replikation.  Und heute werde ich Ihnen sagen, wie die Replikation funktioniert. <br><a name="habracut"></a><br><h2>  Informationen zur Replikation </h2><br>  Bei der Replikation werden Kopien von Daten von einem Geschäft in ein anderes erstellt.  Jede Kopie wird als Replikat bezeichnet.  Die Replikation kann verwendet werden, wenn Sie ein Backup erstellen, Hot Standby implementieren oder das System horizontal skalieren müssen.  Und dafür ist es notwendig, die gleichen Daten auf verschiedenen Knoten des Computernetzwerks des Clusters verwenden zu können. <br><br>  Wir klassifizieren die Replikation auf zwei Arten: <br><br><ul><li> <b>Richtung: Master-Master oder Master-Slave</b> .  Die Master-Slave-Replikation ist die einfachste Option.  Sie haben einen Knoten, auf dem Sie Daten ändern.  Sie übersetzen diese Änderungen auf die anderen Knoten, auf die sie angewendet werden.  Bei der Master-Master-Replikation werden Änderungen an mehreren Knoten gleichzeitig vorgenommen.  In diesem Fall ändert jeder Knoten seine Daten selbst und wendet die an anderen Knoten vorgenommenen Änderungen auf sich selbst an. </li><li>  <b>Betriebsart: asynchron oder synchron</b> .  Die synchrone Replikation bedeutet, dass keine Daten festgeschrieben werden und die Replikation dem Benutzer erst bestätigt wird, wenn die Änderungen über mindestens die Mindestanzahl von Clusterknoten übertragen werden.  Bei der asynchronen Replikation sind das Festschreiben einer Transaktion (Festschreiben) und die Interaktion mit einem Benutzer zwei unabhängige Prozesse.  Um Daten festzuschreiben, müssen sie nur in das lokale Protokoll fallen, und erst dann werden diese Änderungen auf irgendeine Weise an andere Knoten übertragen.  Offensichtlich hat die asynchrone Replikation aus diesem Grund eine Reihe von Nebenwirkungen. </li></ul><br><h2>  Wie funktioniert die Replikation in Tarantool? </h2><br>  Die Replikation in Tarantool bietet mehrere Funktionen: <br><br><ul><li>  Es besteht aus einfachen Bausteinen, mit denen Sie einen Cluster beliebiger Topologie erstellen können.  Jedes dieser grundlegenden Konfigurationselemente ist unidirektional, dh Sie haben immer Master und Slave.  Der Master führt einige Aktionen aus und generiert ein Protokoll der Vorgänge, das auf dem Replikat verwendet wird. </li><li>  Die Tarantool-Replikation ist asynchron.  Das heißt, das System bestätigt das Festschreiben an Sie, unabhängig davon, wie viele Replikate diese Transaktion gesehen hat, wie viel sie auf sich selbst angewendet wurde und ob sie überhaupt ausgeführt wurde. </li><li>  Eine weitere Eigenschaft der Replikation in Tarantool ist, dass sie zeilenbasiert ist.  Tarantool führt ein Operationsprotokoll (WAL).  Die Operation gelangt zeilenweise dorthin, dh wenn sich ein Tapla aus dem Leerzeichen ändert, wird diese Operation als eine Zeile in das Protokoll geschrieben.  Danach liest der Hintergrundprozess diese Zeile aus dem Protokoll und sendet sie an das Replikat.  Wie viele Replikate der Master hat, so viele Hintergrundprozesse.  Das heißt, jeder Replikationsprozess auf verschiedene Knoten des Clusters wird asynchron von anderen ausgeführt. </li><li>  Jeder Clusterknoten verfügt über eine eigene eindeutige Kennung, die beim Erstellen des Knotens generiert wird.  Darüber hinaus verfügt der Knoten über eine Kennung im Cluster (Mitgliedsnummer).  Dies ist eine numerische Konstante, die einem Replikat zugewiesen wird, wenn eine Verbindung zu einem Cluster besteht, und die während ihrer gesamten Lebensdauer im Cluster beim Replikat verbleibt. </li></ul><br>  Aufgrund der Asynchronität werden Daten an verzögerte Replikate geliefert.  Das heißt, Sie haben einige Änderungen vorgenommen, das System hat das Festschreiben bestätigt, die Operation wurde bereits auf den Master angewendet, aber auf Replikaten wird sie mit einer gewissen Verzögerung angewendet, die durch die Geschwindigkeit bestimmt wird, mit der der Hintergrundreplikationsprozess die Operation liest, an die Replik sendet und diese angewendet wird . <br><br>  Aus diesem Grund besteht die Möglichkeit, dass Daten nicht synchron sind.  Angenommen, wir haben mehrere Master, die miteinander verbundene Daten ändern.  Es kann sich herausstellen, dass die von Ihnen verwendeten Vorgänge nicht kommutativ sind und sich auf dieselben Daten beziehen. Dann haben zwei verschiedene Clustermitglieder unterschiedliche Versionen der Daten. <br><br>  <b>Wenn die Replikation in Tarantool ein unidirektionaler Master-Slave ist, wie wird dann Master-Master erstellt?</b>  Ganz einfach: Erstellen Sie einen anderen Replikationskanal, jedoch in die andere Richtung.  Sie müssen verstehen, dass die Master-Master-Replikation in Tarantool nur eine Kombination aus zwei voneinander unabhängigen Datenströmen ist. <br><br>  Nach dem gleichen Prinzip können wir den dritten Master verbinden und als Ergebnis ein vollständiges Mesh-Netzwerk aufbauen, in dem jedes Replikat ein Master und ein Slave für alle anderen Replikate ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/z5/b-/nxz5b-f9rzqtmhi7ga4fhq8pdq8.png" width="500"></div><br>  Beachten Sie, dass nicht nur die Vorgänge repliziert werden, die lokal auf diesem Master initiiert werden, sondern auch diejenigen, die er extern über Replikationsprotokolle empfangen hat.  In diesem Fall werden die auf Replikat Nr. 1 erstellten Änderungen zweimal auf Replikat Nr. 3 angewendet: direkt und über Replikat Nr. 2. Mit dieser Eigenschaft können komplexere Topologien ohne Verwendung eines vollständigen Netzes erstellt werden.  Sagen wir diesen. <br><br><img src="https://habrastorage.org/webt/k3/wy/r4/k3wyr4imeqfncmfar65mohmcj24.png"><br><br>  Allen drei Mastern, die zusammen den vollständigen Netzkern des Clusters bilden, ist ein individuelles Replikat zugeordnet.  Da das Proxying von Protokollen auf jedem der Master durchgeführt wird, enthalten alle drei "sauberen" Slaves alle Operationen, die auf einem der Clusterknoten ausgeführt wurden. <br><br>  Diese Konfiguration kann für eine Vielzahl von Aufgaben verwendet werden.  Sie können keine redundanten Verbindungen zwischen allen Knoten des Clusters erstellen. Wenn Replikate in der Nähe platziert werden, verfügen sie mit minimaler Verzögerung über eine exakte Kopie des Masters.  All dies geschieht mit dem grundlegenden Master-Slave-Replikationselement. <br><br><h2>  Beschriften von Cluster-Vorgängen </h2><br>  Es stellt sich die Frage: <b>Wenn Vorgänge zwischen allen Clustermitgliedern übertragen werden und mehrmals zu jedem Replikat gelangen, wie verstehen wir, welche Vorgänge ausgeführt werden müssen und welche nicht?</b>  Dies erfordert einen Filtermechanismus.  Jeder aus dem Protokoll gelesenen Operation werden zwei Attribute zugewiesen: <br><br><ul><li>  Die Kennung des Servers, auf dem dieser Vorgang initiiert wurde. </li><li>  Die Sequenznummer der Operation auf dem Server, lsn, der sein Initiator ist.  Jeder Server weist bei der Ausführung einer Operation jeder empfangenen Protokollzeile eine zunehmende Nummer zu: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ... Wenn wir also wissen, dass für einen Server mit einer bestimmten Kennung die Operation mit angewendet wurde lsn 10, dann sind Operationen mit lsn 9, 8, 7, 10, die über andere Replikationskanäle kamen, nicht erforderlich.  Stattdessen wenden wir Folgendes an: 11, 12 usw. </li></ul><br><h2>  Replikatstatus </h2><br>  <b>Und wie speichert Tarantool Informationen zu den bereits angewendeten Vorgängen?</b>  Dazu gibt es eine Vclock-Uhr - dies ist der Vektor des letzten lsn, der auf jeden Knoten im Cluster angewendet wird. <br><br> <code>[lsn <sub>1</sub> , lsn <sub>2</sub> , lsn <sub>n</sub> ]</code> <br> <br>  Dabei ist <code>lsn <sub>i</sub></code> die Nummer der letzten bekannten Operation vom Server mit der Kennung i. <br><br>  Vclock kann auch als bestimmte Momentaufnahme des gesamten Clusterstatus bezeichnet werden, der diesem Replikat bekannt ist.  Wenn wir die Server-ID der Operation kennen, die angekommen ist, isolieren wir die Komponente der lokalen Vclock, die wir benötigen, vergleichen die erhaltene lsn mit der lsn-Operation und entscheiden, ob diese Operation verwendet werden soll.  Infolgedessen werden von einem bestimmten Master initiierte Vorgänge nacheinander gesendet und angewendet.  Gleichzeitig können die auf verschiedenen Mastern erstellten Workflows aufgrund der asynchronen Replikation miteinander gemischt werden. <br><br><h2>  Clustererstellung </h2><br>  Angenommen, wir haben einen Cluster, der aus zwei Elementen besteht, Master und Slave, und wir möchten eine dritte Instanz damit verbinden.  Es hat eine eindeutige UUID, aber es gibt noch keine Cluster-ID.  Wenn Tarantool noch nicht initialisiert ist, möchte es dem Cluster beitreten. Es muss eine JOIN-Operation an einen der Master senden, der sie ausführen kann, dh es befindet sich im Lese- / Schreibmodus.  Als Antwort auf JOIN sendet der Master seinen lokalen Snapshot an das Verbindungsreplikat.  Das Replikat rollt es zu Hause, solange es noch keine Kennung hat.  Jetzt wird das Replikat mit einer leichten Verzögerung mit dem Cluster synchronisiert.  Danach weist der Master, auf dem JOIN ausgeführt wurde, diesem Replikat eine Kennung zu, die protokolliert und an das Replikat gesendet wird.  Wenn einem Replikat ein Bezeichner zugewiesen wird, wird er zu einem vollwertigen Knoten und kann danach die Protokollreplikation auf seiner Seite initiieren. <br><br>  Zeilen aus dem Journal werden ab dem Status dieses Replikats zum Zeitpunkt der Anforderung des Replikationsprotokolls vom Master gesendet, dh von der Uhr, die es während des JOIN-Prozesses empfangen hat, oder von der Stelle, an der das Replikat zuvor gestoppt wurde.  Wenn das Replikat aus irgendeinem Grund heruntergefallen ist, wird beim nächsten Herstellen einer Verbindung zum Cluster kein JOIN mehr ausgeführt, da bereits ein lokaler Snapshot vorhanden ist.  Sie fragt nur nach allen Operationen, die während ihrer Abwesenheit im Cluster stattgefunden haben. <br><br><h2>  Registrieren Sie ein Replikat in einem Cluster </h2><br>  Um den Status über die Struktur des Clusters zu speichern, wird ein spezieller Bereich verwendet - Cluster.  Es enthält die Server-IDs im Cluster, ihre Seriennummern und eindeutigen IDs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/0f/hr/af0fhra2ln0s2xcq-qsmeim2xtc.png" width="500"></div><br><br> <code>[1, 'c35b285c-c5b1-4bbe-83b1-b825eb594aa4'] <br> [2, '37b12cb7-d324-4d75-b428-cde92c18e708'] <br> [3, 'b72b1aa6-42a0-4d73-a611-900e44cdd465']</code> <br> <br>  Bezeichner müssen nicht in der richtigen Reihenfolge ausgeführt werden, da Knoten gelöscht und hinzugefügt werden können. <br><br>  Hier ist die erste Falle.  In der Regel werden Cluster nicht von einem Knoten erfasst: Sie führen eine bestimmte Anwendung aus und sie stellt den gesamten Cluster auf einmal bereit.  Die Replikation in Tarantool ist jedoch asynchron.  Was ist, wenn zwei Master gleichzeitig neue Knoten verbinden und ihnen identische Kennungen zuweisen?  Es wird einen Konflikt geben. <br><br>  Hier ist ein Beispiel für einen falschen und korrekten JOIN: <br><br><img src="https://habrastorage.org/webt/o2/9_/bc/o29_bcjs3dhyllneqlgaczljxys.png"><br><br>  Wir haben zwei Master und zwei Repliken, die eine Verbindung herstellen möchten.  Sie machen JOINs auf verschiedenen Meistern.  Angenommen, Replikate erhalten dieselben Bezeichner.  Dann fällt die Replikation zwischen den Mastern und denen, die es schaffen, ihre Protokolle zu replizieren, auseinander, der Cluster fällt auseinander. <br><br>  Um dies zu verhindern, müssen Sie Replikate jederzeit ausschließlich auf einem Master initiieren.  Zu diesem Zweck führte Tarantool ein solches Konzept als Initialisierungsleiter ein und implementierte einen Algorithmus zur Auswahl dieses Leiters.  Ein Replikat, das eine Verbindung zum Cluster herstellen möchte, stellt zunächst eine Verbindung zu allen Mastern her, die ihm aus der übertragenen Konfiguration bekannt sind.  Anschließend wählt das Replikat diejenigen aus, die bereits initiiert wurden (bei der Bereitstellung des Clusters können nicht alle Knoten das volle Geld verdienen).  Und aus ihnen werden die Master ausgewählt, die für die Aufnahme verfügbar sind.  In Tarantool gibt es schreibgeschützt und schreibgeschützt. Wir können uns nicht auf dem schreibgeschützten Knoten registrieren.  Danach wählen wir aus der Liste der gefilterten Knoten den Knoten mit der niedrigsten UUID aus. <br><br>  Wenn wir dieselbe Konfiguration und dieselbe Liste von Servern auf nicht initialisierten Instanzen verwenden, die eine Verbindung zum Cluster herstellen, wählen sie denselben Master aus, was bedeutet, dass JOIN höchstwahrscheinlich erfolgreich sein wird. <br><br>  Von hier leiten wir eine Regel ab: Wenn Replikate parallel mit einem Cluster verbunden werden, müssen alle diese Replikate dieselbe Replikationskonfiguration haben.  Wenn wir irgendwo etwas weglassen, besteht die Möglichkeit, dass Instanzen mit einer anderen Konfiguration auf verschiedenen Mastern initiiert werden und der Cluster nicht zusammengesetzt werden kann. <br><br>  Angenommen, wir haben uns geirrt oder der Administrator hat vergessen, die Konfiguration zu reparieren, oder Ansible ist kaputt gegangen, und der Cluster ist immer noch auseinandergefallen.  Was kann das bezeugen?  Erstens können steckbare Replikate ihre lokalen Snapshots nicht erstellen: Replikate werden nicht gestartet und melden Fehler.  Zweitens werden auf den Mastern in den Protokollen Fehler im Zusammenhang mit Konflikten im Space-Cluster angezeigt. <br><br>  Wie lösen wir diese Situation?  Es ist einfach: <br><br><ul><li>  Zunächst müssen wir die Konfiguration überprüfen, die wir für die Verbindungsreplikate festgelegt haben. Wenn wir sie nicht reparieren, ist alles andere nutzlos. </li><li>  Danach beseitigen wir die Konflikte im Cluster und machen ein Bild. </li></ul><br>  Jetzt können Sie versuchen, die Replikate erneut zu initialisieren. <br><br><h2>  Konfliktlösung </h2><br>  Also haben wir einen Cluster erstellt und eine Verbindung hergestellt.  Alle Knoten arbeiten im Abonnementmodus, dh sie erhalten die von verschiedenen Mastern generierten Änderungen.  Da die Replikation asynchron ist, sind Konflikte möglich.  Wenn Sie gleichzeitig Daten auf verschiedenen Mastern ändern, erhalten verschiedene Replikate unterschiedliche Kopien der Daten, da die Vorgänge in einer anderen Reihenfolge angewendet werden können. <br><br>  Hier ist ein Beispielcluster nach der Ausführung von JOIN: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-o/2j/k2/-o2jk2hjv2dqndshyqta_blcmo8.png" width="500"></div><br>  Wir haben drei Master-Slaves, zwischen denen Protokolle übertragen werden, die in verschiedene Richtungen übertragen werden und auf Slaves angewendet werden.  Nicht synchronisierte Daten bedeuten, dass jedes Replikat seinen eigenen Vclock-Änderungsverlauf hat, da Streams von verschiedenen Mastern miteinander gemischt werden können.  Dann kann die Reihenfolge der Operationen für Instanzen variieren.  Wenn unsere Operationen nicht kommutativ sind, wie z. B. die REPLACE-Operation, sind die Daten, die wir auf diesen Replikaten erhalten, unterschiedlich. <br><br>  Ein kleines Beispiel.  Angenommen, wir haben zwei Master mit vclock = {0,0}.  Und beide führen zwei Operationen aus, die als op1,1, op1,2, op2,1, op2,2 bezeichnet werden.  Dies ist die zweite Zeitscheibe, in der jeder der Master eine lokale Operation ausführte: <br><br><img src="https://habrastorage.org/webt/-y/z7/cy/-yz7cyhaozyxkdltf7pptl37oqa.png"><br><br>  Grün zeigt eine Änderung der entsprechenden vclock-Komponente an.  Zuerst ändern beide Master ihre Uhr, und dann führt der zweite Master eine weitere lokale Operation aus und erhöht die Uhr erneut.  Der erste Master empfängt die Replikationsoperation vom zweiten Master. Dies wird durch die rote Nummer 1 in vclock des ersten Clusterknotens angezeigt. <br><br><img src="https://habrastorage.org/webt/if/j8/8f/ifj88f4rat3litvsyedit09shw0.png"><br><br>  Dann empfängt der zweite Master die Operation von der ersten und die erste - die zweite Operation von der zweiten.  Und am Ende führt der erste Master seine letzte Operation aus und der zweite Master empfängt sie. <br><br><img src="https://habrastorage.org/webt/gh/3z/jo/gh3zjoicvoxqd772_pt1m92wfem.png"><br><br>  Vclock im Nullzeitquantum haben wir das gleiche - {0,0}.  In der letzten Zeit haben wir auch die gleiche Uhr {2,2}, es scheint, dass die Daten gleich sein sollten.  Die Reihenfolge der Operationen, die an jedem Master ausgeführt werden, ist jedoch unterschiedlich.  Und wenn dies eine REPLACE-Operation mit unterschiedlichen Werten für dieselben Schlüssel ist?  Dann erhalten wir trotz der gleichen Uhr am Ende unterschiedliche Versionen der Daten auf beiden Replikaten. <br><br>  Wir sind auch in der Lage, diese Situation zu lösen. <br><br><ul><li>  <b>Sharding-Datensätze</b> .  Erstens können wir Schreibvorgänge nicht für zufällig ausgewählte Replikate ausführen, sondern sie irgendwie zerlegen.  Sie haben nur die Schreiboperationen zwischen verschiedenen Mastern unterbrochen und schließlich ein Konsistenzsystem erhalten.  Beispielsweise haben sich die Schlüssel auf einem Master von 1 auf 10 und auf einem anderen von 11 auf 20 geändert. Die Knoten tauschen ihre Protokolle aus und erhalten genau dieselben Daten. <br><br>  Sharding impliziert, dass wir einen bestimmten Router haben.  Es muss überhaupt keine separate Entität sein, der Router kann Teil der Anwendung sein.  Es kann ein Shard sein, der Schreiboperationen auf sich selbst anwendet oder sie auf die eine oder andere Weise an einen anderen Master überträgt.  Es wird jedoch so übergeben, dass die Änderungen der zugehörigen Werte an einen bestimmten Master gehen: Ein Werteblock ging an einen Master, ein anderer Block an einen anderen Master.  In diesem Fall können Lesevorgänge an jeden Knoten im Cluster gesendet werden.  Und vergessen Sie nicht die asynchrone Replikation: Wenn Sie auf demselben Master aufgezeichnet haben, müssen Sie möglicherweise auch daraus lesen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/cq/wv/decqwvuzuaz-yn6t7fbyq2o2sv4.png" width="500"></div></li><li>  <b>Logische Reihenfolge der Operationen</b> .  Angenommen, Sie können gemäß den Bedingungen des Problems die Priorität der Operation irgendwie bestimmen.  Geben Sie beispielsweise einen Zeitstempel, eine Version oder ein anderes Etikett ein, mit dem wir verstehen können, welche Operation früher physisch stattgefunden hat.  Das heißt, wir sprechen von einer externen Bestellquelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h8/pt/zl/h8ptzlm1ieiugdnjr66ubi9pxwq.png" width="500"></div><br>  Tarantool verfügt über einen <code>before_replace</code> Trigger, der während der Replikation ausgeführt werden kann.  In diesem Fall sind wir nicht darauf beschränkt, Anfragen weiterzuleiten, sondern können sie senden, wohin wir wollen.  Bei der Replikation am Eingang des Datenstroms haben wir jedoch einen Auslöser.  Er liest die gesendete Leitung, vergleicht sie mit der bereits gespeicherten Leitung und entscheidet, welche der Leitungen eine höhere Priorität hat.  Das heißt, der Trigger ignoriert entweder die Replikationsanforderung oder wendet sie möglicherweise mit den erforderlichen Änderungen an.  Wir wenden diesen Ansatz bereits an, obwohl er auch seine Nachteile hat.  Zunächst benötigen Sie eine externe Taktquelle.  Angenommen, ein Betreiber in einem Mobiltelefonsalon nimmt Änderungen an einem Teilnehmer vor.  Für solche Vorgänge können Sie die Zeit auf dem Computer des Betreibers verwenden, da es unwahrscheinlich ist, dass mehrere Bediener gleichzeitig Änderungen an einem Teilnehmer vornehmen.  Operationen können auf unterschiedliche Weise erfolgen. Wenn jedoch jeder von ihnen eine bestimmte Version zugewiesen werden kann, bleiben beim Durchlaufen von Triggern nur die relevanten übrig. <br><br>  Der zweite Nachteil der Methode: Da der Trigger auf jedes Delta angewendet wird, das durch Replikation für jede Anforderung kam, entsteht eine zusätzliche Rechenlast.  Aber dann haben wir eine konsistente Kopie der Daten auf einer Cluster-Skala. </li></ul><br><h2>  Synchronisieren </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jr/1n/db/jr1ndb23coit6rz1qeblip_tpy0.png" width="500"></div><br>  Unsere Replikation ist asynchron, dh durch Festschreibungsausführung wissen Sie nicht, ob sich diese Daten bereits auf einem anderen Clusterknoten befinden.  Wenn Sie ein Commit für den Master vorgenommen haben, wurde es Ihnen bestätigt, und der Master hat aus irgendeinem Grund sofort aufgehört zu arbeiten. Dann können Sie nicht sicher sein, dass die Daten an einem anderen Ort gespeichert wurden.  Um dieses Problem zu lösen, verfügt das Tarantool-Replikationsprotokoll über eine ACK.  Jeder Master weiß, welche letzte ACK von jedem Slave kam. <br><br>  Was ist ein ACK?  Wenn der Slave das Delta empfängt, das mit dem Master lsn und seiner Kennung markiert ist, sendet er als Antwort ein spezielles ACK-Paket, in das er nach Anwendung dieser Operation seine lokale Uhr packt.  Mal sehen, wie das funktionieren kann. <br><br>  Wir haben einen Meister, der 4 Operationen in sich selbst durchgeführt hat.  Angenommen, der Slave-Slave hat irgendwann die ersten drei Zeilen empfangen und seine Uhr auf {3.0} erhöht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oy/iw/y1/oyiwy1eifo7_jfsb9ylvi1wkija.png" width="500"></div><br>  ACK ist noch nicht angekommen.  Nachdem der Slave diese drei Leitungen empfangen hat, sendet er das ACK-Paket, an das er zum Zeitpunkt des Sendens des Pakets seine Uhr angeschlossen hat.  Lassen Sie den Slave-Master eine weitere Leitung im selben Zeitfenster senden, dh die vclock des Slaves hat sich erhöht.  Auf dieser Grundlage weiß Master Nr. 1 mit Sicherheit, dass die ersten drei Operationen, die er ausgeführt hat, bereits auf diesen Slave angewendet wurden.  Diese Zustände werden für alle Slaves gespeichert, mit denen der Master arbeitet, sie sind völlig unabhängig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/rx/va/u1rxvazmmssfoizpfecbwf3ceas.png" width="500"></div><br>  Und am Ende antwortet der Slave mit einem vierten ACK-Paket.  Danach weiß der Master, dass der Slave mit ihm synchronisiert ist. <br><br>  Dieser Mechanismus kann im Anwendungscode verwendet werden.  Wenn Sie eine Operation festschreiben, bestätigen Sie den Benutzer nicht sofort, sondern rufen zuerst eine spezielle Funktion auf.  Es wartet darauf, dass der dem Master bekannte lsn-Slave zum Zeitpunkt des Abschlusses des Commits gleich dem lsn Ihres Masters ist.  Sie müssen also nicht auf die vollständige Synchronisierung warten, sondern nur auf den genannten Moment warten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1-/oe/93/1-oe930isjznmsurqj314c2-gue.png" width="500"></div><br>  Angenommen, unser erster Anruf hat drei Leitungen geändert, und der zweite Anruf hat eine geändert.  Nach dem ersten Aufruf möchten Sie sicherstellen, dass die Daten synchronisiert sind.  Der oben gezeigte Zustand bedeutet bereits, dass der erste Anruf auf mindestens einem Slave synchronisiert wurde. <br><br>  Wo genau Sie nach Informationen dazu suchen, werden wir im nächsten Abschnitt betrachten. <br><br><h2>  Überwachung </h2><br>  Wenn die Replikation synchron ist, ist die Überwachung sehr einfach: Wenn sie auseinanderfällt, werden Fehler an Ihre Vorgänge ausgegeben.  Und wenn die Replikation asynchron ist, wird die Situation verwirrend.  Der Meister antwortet Ihnen, dass alles in Ordnung ist, es funktioniert, akzeptiert, aufgeschrieben.  Gleichzeitig sind jedoch alle Replikate tot, die Daten sind nicht redundant, und wenn Sie den Master verlieren, verlieren Sie die Daten.  Daher möchte ich den Cluster wirklich überwachen und verstehen, was mit der asynchronen Replikation geschieht, wo sich die Replikate befinden und in welchem ​​Zustand sie sich befinden. <br><br>  Für die grundlegende Überwachung verfügt Tarantool über eine box.info-Entität.  Es lohnt sich, es in der Konsole aufzurufen, da Sie interessante Daten sehen werden. <br><br><pre> <code class="plaintext hljs">id: 1 uuid: c35b285c-c5b1-4bbe-83b1-b825eb594aa4 lsn : 5 vclock : {2: 1, 1: 5} replication : 1: id: 1 uuid : c35b285c -c5b1 -4 bbe -83b1 - b825eb594aa4 lsn : 5 2: id: 2 uuid : 37 b12cb7 -d324 -4 d75 -b428 - cde92c18e708 lsn : 1 upstream : status : follow idle : 0.30358312401222 peer : lag: 3.6001205444336 e -05 downstream : vclock : {2: 1, 1: 5}</code> </pre> <br>  Die wichtigste Metrik ist die ID- <code>id</code> .  In diesem Fall bedeutet 1, dass die lsn dieses Masters an der ersten Position in allen vclock gespeichert wird.  Eine sehr nützliche Sache.  Wenn Sie einen Konflikt mit JOIN haben, können Sie einen Master nur durch eindeutige Bezeichner von einem anderen unterscheiden.  Lokale Mengen umfassen auch solche Mengen wie lsn.  Dies ist die Nummer der letzten Zeile, die dieser Master ausgeführt und in sein Protokoll geschrieben hat.  In unserem Beispiel hat der erste Master fünf Operationen ausgeführt.  Vclock ist der Betriebszustand, von dem er weiß, dass er ihn auf sich selbst angewendet hat.  Und schließlich führte er für Master Nummer 2 eine seiner Replikationsoperationen durch. <br><br>  Nach den Anzeigen des lokalen Status können Sie sehen, was diese Instanz über den Status der Clusterreplikation weiß. Dazu gibt es einen <code>replication</code> .  Es listet alle der Instanz bekannten Clusterknoten auf, einschließlich sich selbst.  Der erste Knoten hat die Kennung 1, id entspricht der aktuellen Instanz.  Der zweite Knoten hat die Kennung 2, sein lsn 1 entspricht dem lsn, der in vclock geschrieben wird.  In diesem Fall betrachten wir die Master-Master-Replikation, wenn Master Nr. 1 sowohl der Master für den zweiten Knoten des Clusters als auch dessen Slave ist, dh ihm folgt. <br><br><ul><li>  Die Essenz von <code>upstream</code> .  Das <code>status follow</code> Attribut bedeutet, dass Master 1 auf Master 2 folgt. Leerlauf ist die Zeit, die seit der letzten Interaktion mit diesem Master lokal vergangen ist.  Wir senden keinen Stream kontinuierlich, der Master sendet nur dann ein Delta, wenn Änderungen daran auftreten.  Wenn wir eine Art ACK senden, kommunizieren wir auch.  Wenn der Leerlauf groß wird (Sekunden, Minuten, Stunden), stimmt offensichtlich etwas nicht. </li><li>  <code>lag</code> Attribut.  Wir haben über Lag gesprochen.  Zusätzlich zu lsn und der <code>server id</code> jede Operation im Protokoll mit einem Zeitstempel gekennzeichnet - der Ortszeit, während der diese Operation in vclock auf dem Master aufgezeichnet wurde, der sie ausgeführt hat.  Gleichzeitig vergleicht Slave seinen lokalen Zeitstempel mit dem Zeitstempel des Deltas, das er erhalten hat.  Der letzte aktuelle Zeitstempel, der für die letzte Zeile empfangen wurde, wird vom Slave bei der Überwachung angezeigt. </li><li>  <code>downstream</code> Attribut.  Es zeigt, was der Meister über seinen bestimmten Sklaven weiß.  Dies ist die Bestätigung, die der Sklave an ihn sendet.  Der oben dargestellte <code>downstream</code> bedeutet, dass sein Sklave, auch bekannt als Master auf Nummer 2, ihm das letzte Mal seine Uhr schickte, die 5.1 war.  Dieser Meister weiß, dass alle fünf seiner Linien, die er an seinem Platz vervollständigte, zu einem anderen Knoten gingen. </li></ul><br><h2>  XLOG-Verlust </h2><br>  Betrachten Sie die Situation mit dem Fall des Meisters. <br><br><pre> <code class="plaintext hljs">lsn : 0 id: 3 replication : 1: &lt;...&gt; upstream : status: disconnected peer : lag: 3.9100646972656 e -05 idle: 1602.836148153 message: connect, called on fd 13, aka [::1]:37960 2: &lt;...&gt; upstream : status : follow idle : 0.65611373598222 peer : lag: 1.9550323486328 e -05 3: &lt;...&gt; vclock : {2: 2, 1: 5}</code> </pre> <br>  Zunächst ändert sich der Status.  <code>Lag</code> ändert sich nicht, da die von uns angewendete Linie dieselbe bleibt und wir keine neuen erhalten haben.  Gleichzeitig wächst der <code>idle</code> , in diesem Fall sind es bereits 1602 Sekunden, so viel Zeit war der Meister tot.  Und wir sehen eine Fehlermeldung: Es besteht keine Netzwerkverbindung. <br><br>  Was tun in einer ähnlichen Situation?  Wir finden heraus, was mit unserem Master passiert ist, ziehen den Administrator an, starten den Server neu und heben den Knoten an.  Die wiederholte Replikation wird durchgeführt, und wenn der Master das System betritt, stellen wir eine Verbindung her, abonnieren dessen XLOG, holen sie für uns selbst und der Cluster stabilisiert sich. <br><br>  Aber es gibt ein kleines Problem.  Stellen Sie sich vor, wir hätten einen Sklaven, der aus irgendeinem Grund ausgeschaltet war und lange Zeit abwesend war.  Während dieser Zeit löschte der Meister, der es bediente, das XLOG.  Beispielsweise ist die Festplatte voll, der Garbage Collector hat Protokolle gesammelt.  Wie kann ein zurückkehrender Sklave weitermachen?  Auf keinen Fall.  Weil die Protokolle, die er anwenden muss, um mit dem Cluster synchronisiert zu werden, weg sind und es keinen Ort gibt, an dem sie abgerufen werden können.  In diesem Fall wird ein interessanter Fehler angezeigt: Der Status wird nicht mehr <code>disconnected</code> , sondern <code>stopped</code> .  Und eine bestimmte Nachricht: Es gibt keine Protokolldatei, die mit einer solchen lsn übereinstimmt. <br><br><pre> <code class="plaintext hljs">id: 3 replication : 1: &lt;...&gt; upstream : peer : status: stopped lag : 0.0001683235168457 idle : 9.4331328970147 message: 'Missing .xlog file between LSN 7 1: 5, 2: 2 and 8 1: 6, 2: 2' 2: &lt;...&gt; 3: &lt;...&gt; vclock : {2: 2, 1: 5}</code> </pre> <br>  In der Tat ist die Situation nicht immer tödlich.  Angenommen, wir haben mehr als zwei Master, und auf einigen von ihnen bleiben diese Protokolle erhalten.  Wir schütten sie allen Meistern gleichzeitig ein und lagern sie nicht nur auf einem.  Dann stellt sich heraus, dass diese Replik, die sich mit allen Mastern verbindet, die sie kennt, auf einigen von ihnen die Protokolle findet, die sie benötigt.  Sie wird alle diese Operationen zu Hause ausführen, ihre Uhr wird sich erhöhen und sie wird den aktuellen Status des Clusters erreichen.  Danach können Sie versuchen, die Verbindung wiederherzustellen. <br><br>  Wenn überhaupt keine Protokolle vorhanden sind, können wir das Replikat nicht fortsetzen.  Es bleibt nur eine Neuinitialisierung.  Denken Sie an die eindeutige Kennung. Sie können sie auf ein Blatt Papier oder in eine Datei schreiben.  Dann bereinigen wir das Replikat lokal: Löschen Sie seine Bilder, Protokolle und so weiter.  Verbinden Sie danach das Replikat erneut mit derselben UUID wie es. <br><br>     UUID   : <code>box.cfg{instance_uuid =  uuid}</code> . <br><br>   ,   .   UUID    space cluster,    .       ,    .    UUID,  master,     JOIN,     ,       UUID,   ,    . <br><br>   ,   UUID ,     space cluster      ,    .       .  ,  ,          . <br><br><h2>  </h2><br> ,  -           .   ,        .    ,   ,      . <br><br>  Tarantool   . <br><br> <code>replication_connect_quorum: 2 <br> replication_connect_timeout: 30 <br> replication_sync_lag: 0.1</code> <br> <br> ,   , ,            ,   ,  ,  master'     0,1 .    30 .     ,   .   0,1 .  ,      . <br><br><h2> Keep alive </h2><br>  ,      ip tables drop.  ,    -  30   30 ,    ,      .     ,   keep alive-. <br><br>  keep alive-  : <code>box.cfg.replication_timeout</code> . <br><br>      master'      ,    keep alive-, ,   .    4  master  slave   keep alive-   ,         .             master'. <br><br><h2>    </h2><br>  ,      .    6 ,      5 .     10 ,    9 .     . <br><br>   ,    ,     .       ,         master',   .  -          .   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pp/wv/qo/ppwvqoys4enyzstnxbfp0mtkug4.png" width="500"></div><br>     6 ,       3.     ,    .  ,     5 ,      3 . <br><br><h2>     </h2><br>   ,       : <br><br><ul><li>  . </li><li>  ,       space cluster,        .          . </li></ul><br>   ,    Telegram-,  .          ,     GitHub,   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439514/">https://habr.com/ru/post/de439514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439504/index.html">Benötigt Ihr Team einen Dateningenieur?</a></li>
<li><a href="../de439506/index.html">9 Alternativen zu einem schlechten Team (Designmuster)</a></li>
<li><a href="../de439508/index.html">Mitap über Open Source-Entwicklung in Moskau</a></li>
<li><a href="../de439510/index.html">Hoch belastetes verteiltes Steuerungssystem eines modernen Kernkraftwerks</a></li>
<li><a href="../de439512/index.html">Das Alter der Dinosaurier oder die gesetzlich geprüfte Rückversicherung?</a></li>
<li><a href="../de439516/index.html">00110001 00110100 00101110 00110000 00110010</a></li>
<li><a href="../de439518/index.html">GeekUniversity Aktualisiertes Webentwicklungs-Schulungsprogramm: Weitere Praktiken und Fälle für Delivery Clubs</a></li>
<li><a href="../de439520/index.html">Proof-of-Stake: Neues Geschäftsmodell im Jahr 2019?</a></li>
<li><a href="../de439522/index.html">DNS-Rebinding in 2k19 oder wie man wirklich schwitzt, indem man eine Pornoseite besucht</a></li>
<li><a href="../de439524/index.html">Fortnite ist die Zukunft, aber aus eher unerwarteten Gründen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>