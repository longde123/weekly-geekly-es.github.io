<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üïê üë©üèæ‚Äçü§ù‚Äçüë®üèª Experi√™ncia na cria√ß√£o de assemblies Linux para atualiza√ß√µes de placa √∫nica com suporte üèáüèæ üë©‚Äç‚öïÔ∏è üåì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 No momento, o mercado oferece uma ampla variedade de pagadores √∫nicos para todos os gostos, a um pre√ßo acess√≠vel. 

 Como regra, v√°rio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experi√™ncia na cria√ß√£o de assemblies Linux para atualiza√ß√µes de placa √∫nica com suporte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470519/"><img src="https://habrastorage.org/webt/uv/15/sj/uv15sjkhjdjizxf0g2acp_abzai.jpeg" alt="imagem"><br><br><h2>  1. Introdu√ß√£o </h2><br>  No momento, o mercado oferece uma ampla variedade de pagadores √∫nicos para todos os gostos, a um pre√ßo acess√≠vel. <br><br>  Como regra, v√°rios conjuntos de fabricantes s√£o projetados para avaliar a plataforma e s√£o o ponto de partida de um novo projeto; portanto, eles nem sempre s√£o adequados para tarefas espec√≠ficas.  Nas tarefas em que √© necess√°ria alta confiabilidade, o desenvolvedor enfrenta a quest√£o de como finalizar o kit de distribui√ß√£o e, em seguida, n√£o paga por isso com uma revis√£o completa da imagem e do sistema de atualiza√ß√£o. <br><a name="habracut"></a><br>  Na Internet, quase n√£o h√° informa√ß√µes sobre o que a vers√£o deve ser compilada e como implementar sua atualiza√ß√£o; portanto, o desenvolvedor √© for√ßado a criar uma ‚Äúbicicleta‚Äù ou usar seus pr√≥prios desenvolvimentos, que nem sempre s√£o 100% testados. <br><br>  Como participo do desenvolvimento de software para v√°rios dispositivos Linux (meu portf√≥lio pode ser google pela palavra develinux) e tamb√©m sou autor do projeto de 11 partes, regularmente tenho que lidar n√£o apenas com montagens de constru√ß√£o, mas tamb√©m com o desenvolvimento de mecanismos de atualiza√ß√£o via WEB ou USB flash. <br><br>  Neste artigo, quero compartilhar minha experi√™ncia e conhecimento em √°reas relevantes. <br><br><h2>  Requisitos de montagem </h2><br>  No processo de desenvolvimento de montagens e atualiza√ß√µes para v√°rios dispositivos, identifiquei v√°rios requisitos para mim: <br><br><ul><li>  o conjunto n√£o deve ser danificado quando a energia √© desligada repentinamente; </li><li>  a montagem deve carregar rapidamente; </li><li>  o gerenciador de inicializa√ß√£o deve funcionar perfeitamente; </li><li>  assembly deve suportar atualiza√ß√£o. </li></ul><br>  Tentarei explicar esses requisitos com mais detalhes abaixo e, depois disso, descreverei tr√™s abordagens na divis√£o de imagens em se√ß√µes e suas atualiza√ß√µes. <br><br><h2>  O conjunto n√£o deve ser danificado quando a energia for desligada repentinamente. </h2><br>  Quem precisa de um dispositivo que pare de funcionar ap√≥s uma d√©cima reinicializa√ß√£o?  Para ningu√©m!  Se voc√™ usar distribui√ß√µes prontas (e existem muito poucas para incorporar), sem um arquivo da caixa, todas elas s√£o muito pouco confi√°veis ‚Äã‚Äãnesse sentido.  Lembrei-me muito bem do projeto em que usei o ubuntu sob imx6, os sistemas de arquivos no cart√£o estavam danificados, √†s vezes desde a d√©cima reinicializa√ß√£o, √†s vezes a partir do quadrag√©simo, dependia das estrelas no c√©u.  O projeto salvou FS aufs.  O fato √© que o ubuntu n√£o foi projetado para somente leitura e deve sempre escrever algo.  Lembro-me de uma situa√ß√£o semelhante em outro projeto em que o yocto foi usado em um cart√£o SD.  Em geral, observe que os cart√µes SD s√£o o tipo de unidade mais feio que causa o travamento mais r√°pido e muito mais confi√°vel do que o emmc e o nand.  Se voc√™ usa um cart√£o SD, √© aconselh√°vel escrever o m√≠nimo poss√≠vel durante a opera√ß√£o, os algoritmos de transfer√™ncia em segundo plano para setores s√£o muito imprevis√≠veis, trabalhei com dezenas de diferentes cart√µes SD de marcas mundiais e n√£o encontrei um √∫nico cart√£o que eu pudesse recomendar. <br>  Mas os cart√µes SD t√™m v√°rias vantagens: s√£o acess√≠veis, baratos e convenientes em software de depura√ß√£o. <br><br>  Por que estou ... E eis a quest√£o - o FS raiz deve ser somente leitura, n√£o deve haver nenhuma entrada durante a opera√ß√£o.  Voc√™ provavelmente pensar√°: como?  Milh√µes de dispositivos Android sempre escrevem algo e n√£o falham.  √â verdade, mas tudo isso ocorre porque a maioria dos dispositivos Android, em primeiro lugar, tem uma bateria e, em segundo lugar, o FS raiz √© enquadrado como ramdisk e a parti√ß√£o do sistema √© somente leitura. <br><br>  Se o sistema for confi√°vel, todos os tipos de coisas com a instala√ß√£o de pacotes no FS raiz podem estragar muito.  Eu recomendo o squashfs como um sistema de arquivos.  Funciona r√°pido, n√£o pode escrever nada, economiza espa√ßo devido √† compress√£o ... <br><br>  Mas e quanto a salvar configura√ß√µes, baixar arquivos etc.  voc√™ pergunta? <br>  Mas, para isso, voc√™ precisa criar parti√ß√µes RW separadas.  Se voc√™ planeja escrever em NAND, recomendo uma op√ß√£o comprovada - UBIFS.  Se estiver na NOR, ent√£o jffs2.  Se eu escrever em outra unidade, recomendo ext4, btrfs, ReiserFS, n√£o posso apontar o melhor FS entre eles, porque  houve v√°rios problemas com todos. <br><br>  Nesse caso, sempre antes de montar parti√ß√µes rw, verifique se h√° erros nas parti√ß√µes usando utilit√°rios do tipo fsck. <br><br><h2>  O conjunto deve carregar rapidamente </h2><br>  As velocidades de download do dispositivo afetam a usabilidade geral.  Em algumas tarefas, o tempo de carregamento n√£o √© superior a 30 segundos; em alguns, 5 minutos s√£o permitidos.  Para mim, trabalhei at√© um minuto, quanto menos, melhor.  Aguarde o download por mais de um minuto por muito tempo, pode parecer que o dispositivo travou; portanto, se voc√™ puder reduzir o tempo, √© melhor us√°-lo. <br><br><h2>  O carregador de inicializa√ß√£o deve funcionar sem problemas </h2><br>  O carregador √© o que a montagem n√£o come√ßar√° sem.  Recentemente, observei com freq√º√™ncia como os fabricantes de placa √∫nica facilitam o desenvolvimento carregando uma demonstra√ß√£o de um cart√£o SD com uma descri√ß√£o de como registrar um carregador de inicializa√ß√£o ou uma imagem finalizada em um carregador de inicializa√ß√£o, que √© simplesmente preenchido com o comando dd.  Mas e se o cart√£o SD congelar?  O mesmo n√£o √© incomum.  Pessoalmente, na minha pr√°tica, as cartas ca√≠am frequentemente.  √â assim que voc√™ trabalha por uma taxa por v√°rias horas, escreve software, bam e isso √© tudo ... erros no kernel come√ßam a aparecer, o cart√£o caiu.  Mas e se esse for um dispositivo que funcione nos campos sem reiniciar?  A prop√≥sito, reiniciar incluindo watchdog nem sempre revive um cart√£o travado, o cart√£o n√£o tem um sinal de redefini√ß√£o, isso n√£o √© emmc, √© claro que isso √© mais uma quest√£o para o circuito da placa, se a placa tiver uma redefini√ß√£o do poder da placa, isso economizar√°, mas isso n√£o est√° em toda parte.  Em algumas placas, apenas distorcer a energia ou o cart√£o ajuda.  Com base na minha experi√™ncia, n√£o recomendo armazenar o carregador de inicializa√ß√£o na unidade com o conjunto principal se a grava√ß√£o for realizada na unidade durante a opera√ß√£o.  Se o sistema n√£o gravar nada na unidade com o gerenciador de inicializa√ß√£o, e isso raramente acontecer, por favor.  Na minha experi√™ncia, no modo somente leitura, o sistema de arquivos foi deformado apenas devido a erros de hardware, mas n√£o a erros de software. <br><br>  O carregador de inicializa√ß√£o deve ser armazenado em um local seguro, em uma unidade confi√°vel, por exemplo, em um chip NOR ou EEPROM separado.  Abaixo est√° um exemplo de m√≥dulo baseado no chip imx6ull, com SPI NOR para armazenar o gerenciador de inicializa√ß√£o. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/w0/ka/um/w0kaumujmmpo6mey_ubuk6oknm4.jpeg" alt="imagem" width="50%"></a> </div><br><h2>  A constru√ß√£o deve suportar a atualiza√ß√£o </h2><br>  Sem uma atualiza√ß√£o, lugar nenhum ... Participei de muitos projetos e nunca obtive o software perfeito para a entrega do trabalho.  Sempre √© detectado um erro ou √© necess√°ria uma melhoria funcional.  Voc√™ precisa entender que, enquanto as pessoas escrevem software, elas cometem erros, enquanto as pessoas usam o dispositivo, elas querem um pouco mais.  Em 90% dos casos, a falta de um sistema de atualiza√ß√£o bem pensado pode levar √† dor de cabe√ßa do fabricante e ao colapso de todo o projeto.  Por exemplo, um sistema de videovigil√¢ncia foi desenvolvido para transporte, o sistema foi instalado em toda a R√∫ssia e verifica-se que os profissionais de marketing subestimaram o mercado e n√£o forneceram streaming. Al√©m disso, foram encontrados v√°rios erros no firmware, al√©m de o consumidor come√ßar a olhar na dire√ß√£o dos concorrentes, porque eles h√° apenas algo que n√£o est√° no dispositivo adquirido ... Sim, sim, em um jardim estranho os morangos s√£o mais saborosos e o clima √© melhor (psicologia). <br>  O que fazer em tal situa√ß√£o?  Se a atualiza√ß√£o for suportada, existem muitas solu√ß√µes, erros podem ser corrigidos, transmiss√£o de fluxo pode ser melhorada e a funcionalidade pode ser personalizada para o consumidor, fornecer instru√ß√µes ao firmware do consumidor e isso √© tudo.  Mas se n√£o for suportado, o fabricante ter√° grandes aventuras com viagens de neg√≥cios de engenheiros de servi√ßo at√© a substitui√ß√£o de dispositivos. <br><br>  O sistema de atualiza√ß√£o no dispositivo deve ser pensado nos m√≠nimos detalhes e testado 100%.  Um erro nesta parte transformar√° o ferro em tijolo, portanto n√£o deve haver toler√¢ncias e exce√ß√µes. <br><br>  O processo de atualiza√ß√£o deve ser resistente ao desligamento da energia e, sob nenhuma circunst√¢ncia, deve estragar o dispositivo. <br><br><h2>  Uma vis√£o geral das abordagens de particionamento para atualiza√ß√µes futuras </h2><br>  Das muitas abordagens, posso recomendar tr√™s tipos que eu implementei pessoalmente.  Essas n√£o s√£o todas as abordagens; seu escopo est√° al√©m do escopo deste artigo.  Todos os tr√™s tipos t√™m falhas e est√£o longe do ideal, mas, como me parece, est√£o pr√≥ximos da m√©dia de ouro do senso comum. <br><br><h3>  Abordagem No. 1 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/j4/y0/1l/j4y01l02_tkwvnpe-gs1e2jabiy.jpeg" alt="imagem" width="50%"></a> </div><br>  A maneira mais f√°cil e acess√≠vel: <br>  Uma imagem √© colocada em uma unidade, por exemplo, um cart√£o SD, que √© exibido a partir do u-boot na unidade interna do dispositivo, por exemplo, flash NAND. <br>  No u-boot, voc√™ precisa preparar scripts para isso. <br>  Dos benef√≠cios - este √© o tipo mais f√°cil de atualiza√ß√£o, cujo desenvolvimento levar√° no m√°ximo 1 dia. <br>  As desvantagens dessa abordagem s√£o a falta de visualiza√ß√£o do processo e os recursos muito limitados do gerenciador de inicializa√ß√£o, ou seja,  n√£o h√° l√≥gica complicada com ferramentas padr√£o, a menos que voc√™ crie seu pr√≥prio comando u-boot (mas esse √© outro tipo de atualiza√ß√£o, C √© uma grande for√ßa).  Esse m√©todo n√£o se destina a atualiza√ß√µes via WEB - √© problem√°tico controlar a integridade da imagem do firmware; em alguns casos, o tamanho da montagem n√£o deve exceder o tamanho da RAM. <br>  Al√©m disso, em algumas tarefas √© necess√°rio salvar as configura√ß√µes durante a atualiza√ß√£o, e isso, com essa abordagem, n√£o √© f√°cil de implementar. <br><br><h3>  Abordagem No. 2 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ia/ox/vd/iaoxvdexq7u8_biakyniktekgmk.jpeg" alt="imagem" width="50%"></a> </div><br><br>  O m√©todo mais confi√°vel e protegido do considerado, mas o mais dif√≠cil.  Eu recomendo que esse m√©todo seja usado em desenvolvimentos especialmente respons√°veis, como  Ele protege as imagens quebradas e os danos f√≠sicos ao inversor principal, uma vez que o circuito usa um adicional. <br><br>  A abordagem usa uma compila√ß√£o m√≠nima (tamanho de ramdisk de 8 a 16 MB) e a principal.  O Ramdisk √© um arquivo compactado, portanto uma compila√ß√£o de 16 MB ser√° fisicamente v√°rias vezes menor. <br>  O objetivo de uma montagem m√≠nima √© avaliar a montagem principal e carreg√°-la. <br>  O Ramdisk √© hospedado com os scripts do kernel e do u-boot em uma imagem FIT. <br><br>  Por que a imagem FIT e o que ela fornece?  A imagem FIT √© um formato suportado pelo u-boot.  Garante a integridade de todos os componentes (kernel, dts, ramdisk, scripts).  A descompacta√ß√£o da imagem FIT √© realizada no u-boot e, se a soma de verifica√ß√£o n√£o convergir, o u-boot se recusar√° a carreg√°-lo.  Isso √© conveniente, ou seja,  n√£o h√° necessidade de cuidar do controle de integridade sozinho, n√£o h√° necessidade de gravar v√°rios arquivos separadamente ou inventar suas pr√≥prias imagens, tudo √© feito pela imagem FIT.  Geralmente, uma imagem FIT ocupa de 7 a 20 MB; ela deve ser gravada em uma unidade altamente confi√°vel, por exemplo, em qspi ou flash.  O conjunto principal pode ser armazenado em mem√≥ria mais barata e n√£o confi√°vel, por exemplo, flash NAND.  Como o trabalho principal ocorrer√° na montagem principal, √© precisamente isso que ser√° danificado primeiro.  Nesse caso, uma unidade separada com o m√≠nimo de rootfs ser√° resgatada. <br><br>  Processo de inicializa√ß√£o. <br><br>  O u-boot baixa um script que tenta usar as atualiza√ß√µes do FIT (FIT2) e, em seguida, o firmware de f√°brica do FIT (FIT1). <br><br>  Se o FIT2 n√£o estiver presente ou sua integridade for violada, o teste de ajuste falhar√° e o u-boot carregar√° o primeiro FIT (FIT1).  Se houver atualiza√ß√µes do FIT (FIT2) e n√£o estiver danificado, o seu ramdisk ser√° carregado para verificar as atualiza√ß√µes do rootfs (Rootfs2). <br><br>  Se o Rootfs2 estiver quebrado, os scripts excluir√£o as atualiza√ß√µes do FIT (FIT2); depois da reinicializa√ß√£o, a imagem de f√°brica que consiste em FIT (FIT1) e Rootfs1 ser√° baixada. <br><br>  Processo de atualiza√ß√£o. <br><br>  A imagem de atualiza√ß√£o cont√©m FIT, rootfs e v√°rias informa√ß√µes de montagem, incluindo somas de verifica√ß√£o de todos os seus componentes.  As informa√ß√µes de montagem s√£o usadas durante a atualiza√ß√£o para monitorar a integridade e a compatibilidade. <br><br>  Atualize o progresso nas etapas: <br><br><ul><li>  verifica√ß√£o da imagem quanto √† compatibilidade com hardware e software, </li><li>  verificar a integridade da imagem no arquivo de atualiza√ß√£o, </li><li>  copiar Rootfs2 do arquivo de atualiza√ß√£o para uma se√ß√£o preparada anteriormente, </li><li>  verificar a integridade da imagem copiada na se√ß√£o, </li><li>  copie o FIT2 para a se√ß√£o apropriada, </li><li>  reiniciar. </li></ul><br>  Se o processo falhar, a aus√™ncia ou dano do FIT2 n√£o arruinar√° o sistema, pois  O u-boot simplesmente se recusar√° a us√°-lo e carregar√° a imagem de f√°brica.  Portanto, durante a atualiza√ß√£o, a integridade do FIT2 n√£o √© verificada. <br><br>  Ap√≥s a atualiza√ß√£o, o novo assembly ser√° colocado na unidade principal na forma de FIT2 e Rootfs2. <br><br>  Este m√©todo √© resistente a danos mec√¢nicos no inversor e erros de FS. <br><br>  Em caso de mau funcionamento cr√≠tico, a imagem de f√°brica ser√° iniciada, onde o software de recupera√ß√£o funcionar√°, o que, por exemplo, pode verificar novamente a NAND, fazer o download do firmware da rede usando o protocolo SSH e depois grav√°-lo. <br><br>  Dei apenas um exemplo de recupera√ß√£o, h√° muitas op√ß√µes.  Nesta abordagem, o processo de recupera√ß√£o √© conduzido pelo Linux completo, que pode fazer tudo ... e n√£o o gerenciador de inicializa√ß√£o, como na primeira vers√£o. <br><br><h3>  Abordagem No. 3 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/wx/mz/o-/wxmzo-tpggd3a6goz48-us359_s.jpeg" alt="imagem" width="50%"></a> </div><br><br>  Esse tipo de atualiza√ß√£o √© usado em quase todos os projetos de 11 partes, pois funcionou muito bem. <br><br>  A atualiza√ß√£o √© adequada para qualquer tamanho de montagem, para qualquer tipo de unidade.  Diferente do tipo anterior, aqui o SPI NOR √© usado apenas para u-boot, portanto, possui um tamanho menor e um custo menor, 1 MB √© suficiente. <br><br>  Esse tipo de atualiza√ß√£o n√£o requer uma compila√ß√£o separada do ramdisk, o que significa que o tempo de programa√ß√£o √© economizado para seu desenvolvimento e suporte no futuro. <br><br>  O exemplo usa uma unidade de cart√£o SD, mas tamb√©m pode ser NAND usando UBIFS, sem diferen√ßa.  Nesta abordagem, n√£o h√° verifica√ß√£o do Rootfs RO antes do carregamento; se o conjunto estiver danificado, o sistema n√£o saber√° que foi danificado e o carregar√° em um c√≠rculo.  Aqui sup√µe-se que os dados na se√ß√£o RO n√£o possam ser alterados de forma alguma, essa abordagem elimina o mau funcionamento f√≠sico do inversor.  Se a unidade n√£o estiver fisicamente saud√°vel, o dispositivo dever√° ser transportado para um centro de servi√ßo, n√£o ser√° fornecida autocorre√ß√£o.  Este √© o pre√ßo que voc√™ deve pagar para aumentar a velocidade de desenvolvimento, o suporte mais barato e a base elementar mais barata, mas isso √© justificado.  Por que segurar contra algo que quase nunca acontece. <br><br>  A l√≥gica para baixar e atualizar √© a mesma da abordagem anterior. <br><br>  No caso de carregamento, o u-boot baixa primeiro as atualiza√ß√µes do FIT (FIT2); se ele n√£o existe ou a integridade √© violada, o u-boot carrega o primeiro FIT (FIT1), o conjunto que foi costurado na f√°brica √© iniciado e assim sucessivamente at√© que o sistema seja atualizado.  Quando o sistema √© atualizado, o FIT2 e o Rootfs2 aparecer√£o.  Nesse caso, quando o dispositivo inicializa, a atualiza√ß√£o do FIT (FIT2) inicia primeiro.  Nos scripts u-boot armazenados em cada FIT, deve ser escrito quais rootfs montar. <br><br><h2>  Parti√ß√£o compartilhada RW </h2><br>  Nos gr√°ficos, h√° um bloco de parti√ß√£o compartilhado em todos os lugares, este √© um grupo de se√ß√µes para grava√ß√£o.  Quaisquer entradas s√£o feitas apenas l√°.  Parti√ß√£o compartilhada √© mostrada como uma parti√ß√£o para maior clareza.  De fato, existem tr√™s deles: dois pequenos para configura√ß√µes que funcionam no espelho e um grande para todo o resto.  Al√©m disso, recomendo que voc√™ mantenha algumas das configura√ß√µes ao atualizar, o que √© conveniente, por exemplo, se voc√™ configurar a rede e atualizar, n√£o precisar√° reconfigurar as configura√ß√µes de rede. <br><br><h2>  Resumir </h2><br>  O artigo discute tr√™s tipos de montagens com suporte para atualiza√ß√µes, todas verificadas pessoalmente por mim; voc√™ pode us√°-las com seguran√ßa em projetos. <br><br>  No momento, uso apenas os dois √∫ltimos, pois s√£o mais adequados para os requisitos.  Para maior clareza, voc√™ pode ver exemplos de dispositivos nos quais esses tipos de atualiza√ß√µes s√£o usados ‚Äã‚Äã(detalhes no portf√≥lio de 11 partes): <br><br><ul><li>  Repetidor RS485 via 4G / WiFi / LAN, </li><li>  Placa de controle industrial do controlador da exposi√ß√£o 4K V-By-One, </li><li>  sistema integrado de controle clim√°tico do hangar, </li><li>  2DisplayPort-LVDS controlador de v√≠deo de exibi√ß√£o industrial, </li><li>  sistema de controle de linha </li><li>  Gateway de VPN. </li></ul><br>  Se meu artigo for √∫til e interessante, estou pronto para compartilhar ainda mais minha experi√™ncia e solu√ß√µes t√©cnicas comprovadas no campo do linux incorporado neste site. <br><br>  Obrigado a todos. <br>  Gorchakov Ilya <br>  telegrama: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">develinux</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470519/">https://habr.com/ru/post/pt470519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470501/index.html">M√¥nada "Reader" via ass√≠ncrono / aguardar em C #</a></li>
<li><a href="../pt470503/index.html">Usu√°rios e autoriza√ß√£o do Kubernetes RBAC</a></li>
<li><a href="../pt470511/index.html">TI na Arm√™nia: setores estrat√©gicos e esferas tecnol√≥gicas do pa√≠s</a></li>
<li><a href="../pt470513/index.html">Como encontrei uma casa inteligente dominada por uma botnet</a></li>
<li><a href="../pt470515/index.html">Um pequeno passo para o testador: os 10 principais relat√≥rios do Heisenbug 2019 Piter</a></li>
<li><a href="../pt470521/index.html">Lan√ßamento do 3CX V16 Update 3 e o novo aplicativo m√≥vel 3CX para Android</a></li>
<li><a href="../pt470529/index.html">Como traduzimos o projeto legado para o GraphQL</a></li>
<li><a href="../pt470531/index.html">O neurofisiologista discute o projeto Neuralink e fala sobre o trabalho do c√©rebro "nos dedos"</a></li>
<li><a href="../pt470535/index.html">Maneiras de criar gr√°ficos de barras usando Python</a></li>
<li><a href="../pt470537/index.html">Novo pacote de valida√ß√£o para o React no Mobx @ quantumart / mobx-form-validation-kit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>