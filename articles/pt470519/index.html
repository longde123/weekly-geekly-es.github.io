<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏽 🕐 👩🏾‍🤝‍👨🏻 Experiência na criação de assemblies Linux para atualizações de placa única com suporte 🏇🏾 👩‍⚕️ 🌓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdução 
 No momento, o mercado oferece uma ampla variedade de pagadores únicos para todos os gostos, a um preço acessível. 

 Como regra, vário...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experiência na criação de assemblies Linux para atualizações de placa única com suporte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470519/"><img src="https://habrastorage.org/webt/uv/15/sj/uv15sjkhjdjizxf0g2acp_abzai.jpeg" alt="imagem"><br><br><h2>  1. Introdução </h2><br>  No momento, o mercado oferece uma ampla variedade de pagadores únicos para todos os gostos, a um preço acessível. <br><br>  Como regra, vários conjuntos de fabricantes são projetados para avaliar a plataforma e são o ponto de partida de um novo projeto; portanto, eles nem sempre são adequados para tarefas específicas.  Nas tarefas em que é necessária alta confiabilidade, o desenvolvedor enfrenta a questão de como finalizar o kit de distribuição e, em seguida, não paga por isso com uma revisão completa da imagem e do sistema de atualização. <br><a name="habracut"></a><br>  Na Internet, quase não há informações sobre o que a versão deve ser compilada e como implementar sua atualização; portanto, o desenvolvedor é forçado a criar uma “bicicleta” ou usar seus próprios desenvolvimentos, que nem sempre são 100% testados. <br><br>  Como participo do desenvolvimento de software para vários dispositivos Linux (meu portfólio pode ser google pela palavra develinux) e também sou autor do projeto de 11 partes, regularmente tenho que lidar não apenas com montagens de construção, mas também com o desenvolvimento de mecanismos de atualização via WEB ou USB flash. <br><br>  Neste artigo, quero compartilhar minha experiência e conhecimento em áreas relevantes. <br><br><h2>  Requisitos de montagem </h2><br>  No processo de desenvolvimento de montagens e atualizações para vários dispositivos, identifiquei vários requisitos para mim: <br><br><ul><li>  o conjunto não deve ser danificado quando a energia é desligada repentinamente; </li><li>  a montagem deve carregar rapidamente; </li><li>  o gerenciador de inicialização deve funcionar perfeitamente; </li><li>  assembly deve suportar atualização. </li></ul><br>  Tentarei explicar esses requisitos com mais detalhes abaixo e, depois disso, descreverei três abordagens na divisão de imagens em seções e suas atualizações. <br><br><h2>  O conjunto não deve ser danificado quando a energia for desligada repentinamente. </h2><br>  Quem precisa de um dispositivo que pare de funcionar após uma décima reinicialização?  Para ninguém!  Se você usar distribuições prontas (e existem muito poucas para incorporar), sem um arquivo da caixa, todas elas são muito pouco confiáveis ​​nesse sentido.  Lembrei-me muito bem do projeto em que usei o ubuntu sob imx6, os sistemas de arquivos no cartão estavam danificados, às vezes desde a décima reinicialização, às vezes a partir do quadragésimo, dependia das estrelas no céu.  O projeto salvou FS aufs.  O fato é que o ubuntu não foi projetado para somente leitura e deve sempre escrever algo.  Lembro-me de uma situação semelhante em outro projeto em que o yocto foi usado em um cartão SD.  Em geral, observe que os cartões SD são o tipo de unidade mais feio que causa o travamento mais rápido e muito mais confiável do que o emmc e o nand.  Se você usa um cartão SD, é aconselhável escrever o mínimo possível durante a operação, os algoritmos de transferência em segundo plano para setores são muito imprevisíveis, trabalhei com dezenas de diferentes cartões SD de marcas mundiais e não encontrei um único cartão que eu pudesse recomendar. <br>  Mas os cartões SD têm várias vantagens: são acessíveis, baratos e convenientes em software de depuração. <br><br>  Por que estou ... E eis a questão - o FS raiz deve ser somente leitura, não deve haver nenhuma entrada durante a operação.  Você provavelmente pensará: como?  Milhões de dispositivos Android sempre escrevem algo e não falham.  É verdade, mas tudo isso ocorre porque a maioria dos dispositivos Android, em primeiro lugar, tem uma bateria e, em segundo lugar, o FS raiz é enquadrado como ramdisk e a partição do sistema é somente leitura. <br><br>  Se o sistema for confiável, todos os tipos de coisas com a instalação de pacotes no FS raiz podem estragar muito.  Eu recomendo o squashfs como um sistema de arquivos.  Funciona rápido, não pode escrever nada, economiza espaço devido à compressão ... <br><br>  Mas e quanto a salvar configurações, baixar arquivos etc.  você pergunta? <br>  Mas, para isso, você precisa criar partições RW separadas.  Se você planeja escrever em NAND, recomendo uma opção comprovada - UBIFS.  Se estiver na NOR, então jffs2.  Se eu escrever em outra unidade, recomendo ext4, btrfs, ReiserFS, não posso apontar o melhor FS entre eles, porque  houve vários problemas com todos. <br><br>  Nesse caso, sempre antes de montar partições rw, verifique se há erros nas partições usando utilitários do tipo fsck. <br><br><h2>  O conjunto deve carregar rapidamente </h2><br>  As velocidades de download do dispositivo afetam a usabilidade geral.  Em algumas tarefas, o tempo de carregamento não é superior a 30 segundos; em alguns, 5 minutos são permitidos.  Para mim, trabalhei até um minuto, quanto menos, melhor.  Aguarde o download por mais de um minuto por muito tempo, pode parecer que o dispositivo travou; portanto, se você puder reduzir o tempo, é melhor usá-lo. <br><br><h2>  O carregador de inicialização deve funcionar sem problemas </h2><br>  O carregador é o que a montagem não começará sem.  Recentemente, observei com freqüência como os fabricantes de placa única facilitam o desenvolvimento carregando uma demonstração de um cartão SD com uma descrição de como registrar um carregador de inicialização ou uma imagem finalizada em um carregador de inicialização, que é simplesmente preenchido com o comando dd.  Mas e se o cartão SD congelar?  O mesmo não é incomum.  Pessoalmente, na minha prática, as cartas caíam frequentemente.  É assim que você trabalha por uma taxa por várias horas, escreve software, bam e isso é tudo ... erros no kernel começam a aparecer, o cartão caiu.  Mas e se esse for um dispositivo que funcione nos campos sem reiniciar?  A propósito, reiniciar incluindo watchdog nem sempre revive um cartão travado, o cartão não tem um sinal de redefinição, isso não é emmc, é claro que isso é mais uma questão para o circuito da placa, se a placa tiver uma redefinição do poder da placa, isso economizará, mas isso não está em toda parte.  Em algumas placas, apenas distorcer a energia ou o cartão ajuda.  Com base na minha experiência, não recomendo armazenar o carregador de inicialização na unidade com o conjunto principal se a gravação for realizada na unidade durante a operação.  Se o sistema não gravar nada na unidade com o gerenciador de inicialização, e isso raramente acontecer, por favor.  Na minha experiência, no modo somente leitura, o sistema de arquivos foi deformado apenas devido a erros de hardware, mas não a erros de software. <br><br>  O carregador de inicialização deve ser armazenado em um local seguro, em uma unidade confiável, por exemplo, em um chip NOR ou EEPROM separado.  Abaixo está um exemplo de módulo baseado no chip imx6ull, com SPI NOR para armazenar o gerenciador de inicialização. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/w0/ka/um/w0kaumujmmpo6mey_ubuk6oknm4.jpeg" alt="imagem" width="50%"></a> </div><br><h2>  A construção deve suportar a atualização </h2><br>  Sem uma atualização, lugar nenhum ... Participei de muitos projetos e nunca obtive o software perfeito para a entrega do trabalho.  Sempre é detectado um erro ou é necessária uma melhoria funcional.  Você precisa entender que, enquanto as pessoas escrevem software, elas cometem erros, enquanto as pessoas usam o dispositivo, elas querem um pouco mais.  Em 90% dos casos, a falta de um sistema de atualização bem pensado pode levar à dor de cabeça do fabricante e ao colapso de todo o projeto.  Por exemplo, um sistema de videovigilância foi desenvolvido para transporte, o sistema foi instalado em toda a Rússia e verifica-se que os profissionais de marketing subestimaram o mercado e não forneceram streaming. Além disso, foram encontrados vários erros no firmware, além de o consumidor começar a olhar na direção dos concorrentes, porque eles há apenas algo que não está no dispositivo adquirido ... Sim, sim, em um jardim estranho os morangos são mais saborosos e o clima é melhor (psicologia). <br>  O que fazer em tal situação?  Se a atualização for suportada, existem muitas soluções, erros podem ser corrigidos, transmissão de fluxo pode ser melhorada e a funcionalidade pode ser personalizada para o consumidor, fornecer instruções ao firmware do consumidor e isso é tudo.  Mas se não for suportado, o fabricante terá grandes aventuras com viagens de negócios de engenheiros de serviço até a substituição de dispositivos. <br><br>  O sistema de atualização no dispositivo deve ser pensado nos mínimos detalhes e testado 100%.  Um erro nesta parte transformará o ferro em tijolo, portanto não deve haver tolerâncias e exceções. <br><br>  O processo de atualização deve ser resistente ao desligamento da energia e, sob nenhuma circunstância, deve estragar o dispositivo. <br><br><h2>  Uma visão geral das abordagens de particionamento para atualizações futuras </h2><br>  Das muitas abordagens, posso recomendar três tipos que eu implementei pessoalmente.  Essas não são todas as abordagens; seu escopo está além do escopo deste artigo.  Todos os três tipos têm falhas e estão longe do ideal, mas, como me parece, estão próximos da média de ouro do senso comum. <br><br><h3>  Abordagem No. 1 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/j4/y0/1l/j4y01l02_tkwvnpe-gs1e2jabiy.jpeg" alt="imagem" width="50%"></a> </div><br>  A maneira mais fácil e acessível: <br>  Uma imagem é colocada em uma unidade, por exemplo, um cartão SD, que é exibido a partir do u-boot na unidade interna do dispositivo, por exemplo, flash NAND. <br>  No u-boot, você precisa preparar scripts para isso. <br>  Dos benefícios - este é o tipo mais fácil de atualização, cujo desenvolvimento levará no máximo 1 dia. <br>  As desvantagens dessa abordagem são a falta de visualização do processo e os recursos muito limitados do gerenciador de inicialização, ou seja,  não há lógica complicada com ferramentas padrão, a menos que você crie seu próprio comando u-boot (mas esse é outro tipo de atualização, C é uma grande força).  Esse método não se destina a atualizações via WEB - é problemático controlar a integridade da imagem do firmware; em alguns casos, o tamanho da montagem não deve exceder o tamanho da RAM. <br>  Além disso, em algumas tarefas é necessário salvar as configurações durante a atualização, e isso, com essa abordagem, não é fácil de implementar. <br><br><h3>  Abordagem No. 2 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ia/ox/vd/iaoxvdexq7u8_biakyniktekgmk.jpeg" alt="imagem" width="50%"></a> </div><br><br>  O método mais confiável e protegido do considerado, mas o mais difícil.  Eu recomendo que esse método seja usado em desenvolvimentos especialmente responsáveis, como  Ele protege as imagens quebradas e os danos físicos ao inversor principal, uma vez que o circuito usa um adicional. <br><br>  A abordagem usa uma compilação mínima (tamanho de ramdisk de 8 a 16 MB) e a principal.  O Ramdisk é um arquivo compactado, portanto uma compilação de 16 MB será fisicamente várias vezes menor. <br>  O objetivo de uma montagem mínima é avaliar a montagem principal e carregá-la. <br>  O Ramdisk é hospedado com os scripts do kernel e do u-boot em uma imagem FIT. <br><br>  Por que a imagem FIT e o que ela fornece?  A imagem FIT é um formato suportado pelo u-boot.  Garante a integridade de todos os componentes (kernel, dts, ramdisk, scripts).  A descompactação da imagem FIT é realizada no u-boot e, se a soma de verificação não convergir, o u-boot se recusará a carregá-lo.  Isso é conveniente, ou seja,  não há necessidade de cuidar do controle de integridade sozinho, não há necessidade de gravar vários arquivos separadamente ou inventar suas próprias imagens, tudo é feito pela imagem FIT.  Geralmente, uma imagem FIT ocupa de 7 a 20 MB; ela deve ser gravada em uma unidade altamente confiável, por exemplo, em qspi ou flash.  O conjunto principal pode ser armazenado em memória mais barata e não confiável, por exemplo, flash NAND.  Como o trabalho principal ocorrerá na montagem principal, é precisamente isso que será danificado primeiro.  Nesse caso, uma unidade separada com o mínimo de rootfs será resgatada. <br><br>  Processo de inicialização. <br><br>  O u-boot baixa um script que tenta usar as atualizações do FIT (FIT2) e, em seguida, o firmware de fábrica do FIT (FIT1). <br><br>  Se o FIT2 não estiver presente ou sua integridade for violada, o teste de ajuste falhará e o u-boot carregará o primeiro FIT (FIT1).  Se houver atualizações do FIT (FIT2) e não estiver danificado, o seu ramdisk será carregado para verificar as atualizações do rootfs (Rootfs2). <br><br>  Se o Rootfs2 estiver quebrado, os scripts excluirão as atualizações do FIT (FIT2); depois da reinicialização, a imagem de fábrica que consiste em FIT (FIT1) e Rootfs1 será baixada. <br><br>  Processo de atualização. <br><br>  A imagem de atualização contém FIT, rootfs e várias informações de montagem, incluindo somas de verificação de todos os seus componentes.  As informações de montagem são usadas durante a atualização para monitorar a integridade e a compatibilidade. <br><br>  Atualize o progresso nas etapas: <br><br><ul><li>  verificação da imagem quanto à compatibilidade com hardware e software, </li><li>  verificar a integridade da imagem no arquivo de atualização, </li><li>  copiar Rootfs2 do arquivo de atualização para uma seção preparada anteriormente, </li><li>  verificar a integridade da imagem copiada na seção, </li><li>  copie o FIT2 para a seção apropriada, </li><li>  reiniciar. </li></ul><br>  Se o processo falhar, a ausência ou dano do FIT2 não arruinará o sistema, pois  O u-boot simplesmente se recusará a usá-lo e carregará a imagem de fábrica.  Portanto, durante a atualização, a integridade do FIT2 não é verificada. <br><br>  Após a atualização, o novo assembly será colocado na unidade principal na forma de FIT2 e Rootfs2. <br><br>  Este método é resistente a danos mecânicos no inversor e erros de FS. <br><br>  Em caso de mau funcionamento crítico, a imagem de fábrica será iniciada, onde o software de recuperação funcionará, o que, por exemplo, pode verificar novamente a NAND, fazer o download do firmware da rede usando o protocolo SSH e depois gravá-lo. <br><br>  Dei apenas um exemplo de recuperação, há muitas opções.  Nesta abordagem, o processo de recuperação é conduzido pelo Linux completo, que pode fazer tudo ... e não o gerenciador de inicialização, como na primeira versão. <br><br><h3>  Abordagem No. 3 </h3><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/wx/mz/o-/wxmzo-tpggd3a6goz48-us359_s.jpeg" alt="imagem" width="50%"></a> </div><br><br>  Esse tipo de atualização é usado em quase todos os projetos de 11 partes, pois funcionou muito bem. <br><br>  A atualização é adequada para qualquer tamanho de montagem, para qualquer tipo de unidade.  Diferente do tipo anterior, aqui o SPI NOR é usado apenas para u-boot, portanto, possui um tamanho menor e um custo menor, 1 MB é suficiente. <br><br>  Esse tipo de atualização não requer uma compilação separada do ramdisk, o que significa que o tempo de programação é economizado para seu desenvolvimento e suporte no futuro. <br><br>  O exemplo usa uma unidade de cartão SD, mas também pode ser NAND usando UBIFS, sem diferença.  Nesta abordagem, não há verificação do Rootfs RO antes do carregamento; se o conjunto estiver danificado, o sistema não saberá que foi danificado e o carregará em um círculo.  Aqui supõe-se que os dados na seção RO não possam ser alterados de forma alguma, essa abordagem elimina o mau funcionamento físico do inversor.  Se a unidade não estiver fisicamente saudável, o dispositivo deverá ser transportado para um centro de serviço, não será fornecida autocorreção.  Este é o preço que você deve pagar para aumentar a velocidade de desenvolvimento, o suporte mais barato e a base elementar mais barata, mas isso é justificado.  Por que segurar contra algo que quase nunca acontece. <br><br>  A lógica para baixar e atualizar é a mesma da abordagem anterior. <br><br>  No caso de carregamento, o u-boot baixa primeiro as atualizações do FIT (FIT2); se ele não existe ou a integridade é violada, o u-boot carrega o primeiro FIT (FIT1), o conjunto que foi costurado na fábrica é iniciado e assim sucessivamente até que o sistema seja atualizado.  Quando o sistema é atualizado, o FIT2 e o Rootfs2 aparecerão.  Nesse caso, quando o dispositivo inicializa, a atualização do FIT (FIT2) inicia primeiro.  Nos scripts u-boot armazenados em cada FIT, deve ser escrito quais rootfs montar. <br><br><h2>  Partição compartilhada RW </h2><br>  Nos gráficos, há um bloco de partição compartilhado em todos os lugares, este é um grupo de seções para gravação.  Quaisquer entradas são feitas apenas lá.  Partição compartilhada é mostrada como uma partição para maior clareza.  De fato, existem três deles: dois pequenos para configurações que funcionam no espelho e um grande para todo o resto.  Além disso, recomendo que você mantenha algumas das configurações ao atualizar, o que é conveniente, por exemplo, se você configurar a rede e atualizar, não precisará reconfigurar as configurações de rede. <br><br><h2>  Resumir </h2><br>  O artigo discute três tipos de montagens com suporte para atualizações, todas verificadas pessoalmente por mim; você pode usá-las com segurança em projetos. <br><br>  No momento, uso apenas os dois últimos, pois são mais adequados para os requisitos.  Para maior clareza, você pode ver exemplos de dispositivos nos quais esses tipos de atualizações são usados ​​(detalhes no portfólio de 11 partes): <br><br><ul><li>  Repetidor RS485 via 4G / WiFi / LAN, </li><li>  Placa de controle industrial do controlador da exposição 4K V-By-One, </li><li>  sistema integrado de controle climático do hangar, </li><li>  2DisplayPort-LVDS controlador de vídeo de exibição industrial, </li><li>  sistema de controle de linha </li><li>  Gateway de VPN. </li></ul><br>  Se meu artigo for útil e interessante, estou pronto para compartilhar ainda mais minha experiência e soluções técnicas comprovadas no campo do linux incorporado neste site. <br><br>  Obrigado a todos. <br>  Gorchakov Ilya <br>  telegrama: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">develinux</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470519/">https://habr.com/ru/post/pt470519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470501/index.html">Mônada "Reader" via assíncrono / aguardar em C #</a></li>
<li><a href="../pt470503/index.html">Usuários e autorização do Kubernetes RBAC</a></li>
<li><a href="../pt470511/index.html">TI na Armênia: setores estratégicos e esferas tecnológicas do país</a></li>
<li><a href="../pt470513/index.html">Como encontrei uma casa inteligente dominada por uma botnet</a></li>
<li><a href="../pt470515/index.html">Um pequeno passo para o testador: os 10 principais relatórios do Heisenbug 2019 Piter</a></li>
<li><a href="../pt470521/index.html">Lançamento do 3CX V16 Update 3 e o novo aplicativo móvel 3CX para Android</a></li>
<li><a href="../pt470529/index.html">Como traduzimos o projeto legado para o GraphQL</a></li>
<li><a href="../pt470531/index.html">O neurofisiologista discute o projeto Neuralink e fala sobre o trabalho do cérebro "nos dedos"</a></li>
<li><a href="../pt470535/index.html">Maneiras de criar gráficos de barras usando Python</a></li>
<li><a href="../pt470537/index.html">Novo pacote de validação para o React no Mobx @ quantumart / mobx-form-validation-kit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>