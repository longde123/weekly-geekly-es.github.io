<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® üë±üèø üßö Console de jeu DIY √† faire soi-m√™me üîß üë©üèæ‚Äçüîß üèπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est une introduction √† mon projet de consoles vid√©o de console "maison" faites √† partir de z√©ro. Je me suis inspir√© √† la fois des consoles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Console de jeu DIY √† faire soi-m√™me</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444006/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="image"></p><br><p>  Cet article est une introduction √† mon projet de consoles vid√©o de console "maison" faites √† partir de z√©ro.  Je me suis inspir√© √† la fois des consoles r√©tro et des √©chantillons modernes, mais j'ai ma propre architecture.  Mes amis me disaient constamment que je devais parler de mon projet, et ne pas tout faire exclusivement "pour moi", donc ici je publie ce post. </p><a name="habracut"></a><br><p>  <strong>Attention, ceci est une traduction</strong> </p><br><h1 id="kak-vsyo-nachalos">  Comment tout a commenc√© </h1><br><p>  Je m'appelle Sergio Vieira, j'ai grandi au Portugal dans les ann√©es 80 et 90, j'ai une longue nostalgie du jeu r√©tro, en particulier pour les consoles de troisi√®me et quatri√®me g√©n√©ration. </p><br><p>  Il y a quelques ann√©es, j'ai d√©cid√© de mieux comprendre l'√©lectronique et d'essayer de cr√©er mon propre pr√©fixe. </p><br><p>  De profession, je suis programmeur et je n'avais aucune exp√©rience en tant qu'ing√©nieur en √©lectronique, √† l'exception (et ne devrait pas √™tre consid√©r√©) des mises √† niveau ind√©pendantes de mon destkop. </p><br><p>  M√™me si je n'avais aucune exp√©rience, je me suis dit "pourquoi pas?", J'ai achet√© plusieurs livres, plusieurs kits √©lectroniques et j'ai commenc√© √† √©tudier en fonction de mes sentiments sur ce qu'il valait la peine d'√©tudier. </p><br><p>  Je voulais faire un pr√©fixe similaire √† ceux qui me rendent nostalgique, je voulais quelque chose entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NES</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Super Nintendo</a> , ou peut-√™tre entre le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sega Master System</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mega Drive</a> . </p><br><p>  Ces consoles avaient un CPU, une puce vid√©o d'origine (on ne les appelait pas alors GPU) et une puce audio, parfois int√©gr√©e, parfois externe. </p><br><p>  Les jeux √©taient distribu√©s sur des cartouches, qui √©taient en g√©n√©ral des extensions de fer, parfois juste des puces ROM, et parfois avec des composants suppl√©mentaires. </p><br><p>  Le plan initial √©tait de cr√©er un pr√©fixe avec les caract√©ristiques suivantes: </p><br><ul><li>  Sans √©mulation, les jeux et les programmes devraient fonctionner sur du vrai mat√©riel, pas n√©cessairement le m√™me √† cette √©poque, mais assez rapide pour la t√¢che, et rien de plus. </li><li>  Avec un vrai CPU r√©tro. </li><li>  Avec sortie TV analogique. </li><li>  Avec son </li><li>  Avec prise en charge double contr√¥leur </li><li>  Becks d√©filants et sprites d'animation </li><li>  Avec des fonctionnalit√©s pour prendre en charge les jeux de plate-forme comme Mario et bien s√ªr toutes sortes d'autres jeux. </li><li>  Avec le t√©l√©chargement de jeux et de programmes √† partir de cartes SD. </li></ul><br><p>  Pourquoi les cartes SD et non les cartouches, eh bien, fondamentalement, c'est tellement plus pratique que vous pouvez les copier depuis votre ordinateur.  Et les cartouches signifieraient, d'une part, plus de fer dans le d√©codeur, et d'autre part, de produire du fer pour chaque programme. </p><br><h1 id="proizvodstvo">  La production </h1><br><h2 id="video-signal">  Signal vid√©o </h2><br><p>  La premi√®re chose que j'ai faite a √©t√© de g√©n√©rer un signal vid√©o. </p><br><p>  Toute console de la p√©riode que j'ai prise comme √©chantillon avait diverses puces graphiques propri√©taires, ce qui signifie qu'elles avaient toutes des sp√©cifications diff√©rentes. <br>  Pour cette raison, je ne voulais pas utiliser une puce graphique pr√™te √† l'emploi, je voulais que ma console ait des sp√©cifications graphiques uniques.  Et comme je ne pouvais pas cr√©er ma propre puce graphique et √† ce moment-l√†, je ne pouvais toujours pas utiliser FPGA, j'ai d√©cid√© de me limiter √† la g√©n√©ration d'un signal graphique g√©n√©r√© par logiciel √† l'aide d'un microcontr√¥leur 8 bits, 20 m√©gahertz. </p><br><p>  Ce n'est pas trop, et juste une solution assez puissante pour les graphismes du niveau qui m'int√©ressait. </p><br><p>  Et donc, j'ai commenc√© √† utiliser le microcontr√¥leur Atmega644 √† une puret√© de 20 MHz pour g√©n√©rer un signal vid√©o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PAL</a> pour le t√©l√©viseur.  J'ai d√ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">battre</a> le protocole PAL car la puce elle-m√™me ne sait pas comment le faire. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="test imageVPU 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="imageVPU Test 2"></p><br><p>  Le microcontr√¥leur produit une couleur 8 bits (RGB332, 3 bits rouge, 3 bits vert et 2 bleu) et le DAC passif convertit le tout en RVB.  Heureusement au Portugal, presque tous les t√©l√©viseurs sont √©quip√©s d'un connecteur p√©ritel et ils prennent en charge l'entr√©e RVB. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  Le sous-syst√®me graphique correct </h2><br><p>  √âtant donn√© que le microcontr√¥leur est assez puissant et que j'ai d√©cid√© de l'utiliser exclusivement pour g√©n√©rer un signal vid√©o (je l'ai appel√© VPU - Video Processing Unit), j'ai d√©cid√© d'organiser un double tampon en m√™me temps. </p><br><p>  Il s'est av√©r√© que le deuxi√®me microcontr√¥leur (PPU, Picture Processing Unit, puce Atmega1284 √©galement √† 20 MHz) a g√©n√©r√© une image dans la puce RAM 1 (je l'ai appel√©e VRAM1), et le premier a envoy√© le contenu de la deuxi√®me puce (VRAM2) au t√©l√©viseur en m√™me temps. </p><br><p>  Apr√®s une trame et deux trames dans le syst√®me PAL, c'est 1/25 de seconde, la VPU commute les VRAM et elles sont permut√©es, la PPU g√©n√®re une image dans VRAM2 et la VPU d√©charge VRAM1 sur la sortie TV. </p><br><p>  La carte vid√©o s'est av√©r√©e tr√®s compliqu√©e parce que je devais utiliser du mat√©riel externe pour que les deux microcontr√¥leurs puissent utiliser les deux modules de m√©moire et acc√©l√©rer l'acc√®s √† la RAM, car elle a √©galement des bangs, donc j'ai d√ª ajouter 74 puces de la s√©rie comme compteurs, s√©lecteurs de ligne, √©metteurs-r√©cepteurs, etc. . </p><br><p>  Le firmware pour VPU et PPU s'est √©galement av√©r√© lourd car j'ai d√ª √©crire beaucoup de code pour obtenir la vitesse maximale des graphiques.  Au d√©but, tout √©tait √©crit en assembleur, puis une partie a √©t√© r√©√©crite en C. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  En cons√©quence, le PPU g√©n√®re une image de 224x192 pixels, qui est ensuite envoy√©e au t√©l√©viseur via VPU.  Vous pouvez trouver la r√©solution faible, mais en fait, c'est presque autant que les consoles de l'√©poque, en g√©n√©ral 256x224.  Une r√©solution l√©g√®rement inf√©rieure, mais m'a permis d'ajouter plus de fonctionnalit√©s que le syst√®me parvient √† calculer dans une seule image. </p><br><p>  Comme autrefois, PPU a sa propre m√©canique rigide que vous devez pouvoir utiliser.  Le support (support) est rendu √† partir de caract√®res 8x8 pixels, √©galement appel√©s tuiles.  Il s'av√®re que la taille de l'arri√®re-plan est de 28x24 carreaux. </p><br><p>  Pour que le support puisse d√©filer en douceur, pixel par pixel, je l'ai fait, il y a 4 √©crans virtuels, chacun de 28x24 carreaux qui vont en m√©moire s√©quentiellement et sont enroul√©s les uns sur les autres, dans l'image, c'est plus clair. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imageBackground"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imageContexte virtuel"></p><br><p>  En plus de l'arri√®re-plan, PPU peut rendre 64 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sprites</a> qui peuvent avoir une hauteur ou une largeur de 8 ou 16 pixels, c'est-√†-dire 1, 2 ou 4 tuiles et peuvent √©galement √™tre retourn√©s horizontalement et / ou verticalement. </p><br><p>  En haut du dos, vous pouvez √©galement restituer une superposition avec un tampon de 28x6 carreaux, ce qui √©tait destin√© au rendu des HUD, des scores afin de ne pas interf√©rer avec les sprites principaux et le d√©filement du dos. </p><br><p>  Une caract√©ristique ¬´avanc√©e¬ª est que l'arri√®re peut √™tre d√©fil√© non pas enti√®rement, mais chaque ligne s√©par√©ment, ce qui permet toutes sortes d'effets int√©ressants comme des √©crans divis√©s ou une quasi- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parallaxe</a> . </p><br><p>  Il existe √©galement une table d'attributs qui vous permet de d√©finir chaque tuile sur une valeur de 0 √† 3, puis vous pouvez sp√©cifier une page de tuiles ou incr√©menter leur valeur symbolique pour toutes les tuiles avec un attribut.  C'est pratique lorsqu'il y a des parties de la sauvegarde qui doivent √™tre chang√©es r√©guli√®rement et que le CPU n'a pas √† calculer chaque tuile individuellement, il suffit de dire quelque chose comme: "toutes les tuiles avec l'attribut 1, incr√©mentez la valeur num√©rique de votre personnage de 2", ces choses peuvent √™tre impl√©ment√©es par diff√©rentes techniques observez, par exemple, dans les tuiles blocs de Mario o√π le point d'interrogation est anim√© ou dans les jeux o√π il y a une cascade dans laquelle toutes les tuiles changent constamment cr√©ant l'effet de la chute d'eau. </p><br><h2 id="cpu">  CPU </h2><br><p>  Lorsque ma carte vid√©o a fonctionn√©, j'ai commenc√© √† travailler avec le processeur en tant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zilog 80</a> pour mon d√©codeur. </p><br><p>  L'une des raisons pour lesquelles le Z80 a √©t√© choisi, eh bien, outre le fait qu'il s'agit d'un CPU r√©tro cool, c'est sa capacit√© √† adresser deux espaces 16 bits, un pour la m√©moire et le second pour les ports d'E / S, non moins l√©gendaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6502</a> , par exemple, il ne peut pas , il ne peut traiter que l'espace de 16 bits, et vous devez le mapper en m√©moire ainsi que divers p√©riph√©riques externes, vid√©o, audio, joysticks, g√©n√©rateur de nombres al√©atoires mat√©riels, etc.  Il est plus pratique d'avoir deux espaces d'adressage, l'un enti√®rement remis √† 64 kilo-octets de code et de donn√©es en m√©moire et le second pour l'acc√®s aux p√©riph√©riques externes. </p><br><p>  Tout d'abord, j'ai connect√© le processeur √† l'EEPROM dans laquelle se trouvait mon programme de test et je l'ai √©galement connect√© via l'espace d'E / S au microcontr√¥leur que j'ai install√© pour pouvoir communiquer avec mon ordinateur via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RS232</a> et surveiller le fonctionnement du processeur et de tout le reste.  J'appelle ce microcontr√¥leur Atmega324 fonctionnant √† 20 MHz le microcontr√¥leur IO - une unit√© de microcontr√¥leur d'entr√©e / sortie, il est charg√© de contr√¥ler l'acc√®s aux contr√¥leurs de jeu (joysticks), un lecteur de carte SD, un clavier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PS / 2</a> et un communicateur via RS232. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="ImageCPU Board 1"></p><br><p>  Le processeur se connecte √† une puce de m√©moire de 128 kilo-octets, dont seulement 56 kilo-octets sont disponibles, c'est bien s√ªr un non-sens, mais je n'ai pu obtenir que des puces de 128 ou 32 kilo-octets.  Il s'est av√©r√© que la m√©moire se compose de 8 kilo-octets de ROM et de 56 kilo-octets de RAM. </p><br><p>  Apr√®s cela, j'ai mis √† jour le micrologiciel IO MCU √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette biblioth√®que</a> et j'ai pris en charge les lecteurs de carte SD. </p><br><p>  Maintenant, le processeur peut parcourir les r√©pertoires, voir ce qui s'y trouve, ouvrir et lire des fichiers.  Tout cela se fait en √©crivant et en lisant des adresses sp√©cifiques dans l'espace d'E / S. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  Connectez le CPU au PPU </h2><br><p>  La prochaine chose que j'ai faite est la connexion entre le CPU et le PPU.  Pour ce faire, j'ai appliqu√© une "solution simple" qui consistait √† acheter de la RAM double port, c'est une telle puce RAM qui peut √™tre connect√©e directement √† deux bus diff√©rents.  Cela lui permet de se d√©barrasser de puces suppl√©mentaires comme les s√©lecteurs de ligne et, de plus, permet un acc√®s presque simultan√© √† la m√©moire des deux puces.  Un autre PPU peut acc√©der directement au CPU sur chaque trame en activant ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interruptions non masquables</a> .  Il s'av√®re que le CPU re√ßoit une interruption sur chaque trame, ce qui est utile pour diverses t√¢ches de synchronisation et pour comprendre quand il est temps de faire une mise √† jour graphique. </p><br><p>  Chaque trame d'interaction du CPU, PPU et VPU se produit selon le sch√©ma suivant: </p><br><ol><li>  Le PPU copie les informations de la m√©moire PPU vers la m√©moire interne. </li><li>  Le PPU envoie un signal d'interruption au CPU. </li><li>  En m√™me temps: <br><ul><li>  Le CPU passe √† la fonction d'interruption et commence √† mettre √† jour la m√©moire PPU avec un nouvel √©tat graphique.  Le programme doit revenir de l'interruption au bloc suivant. </li><li>  PPU restitue une image bas√©e sur des informations pr√©c√©demment copi√©es sur l'un des VRAM. </li><li>  VPU envoie une image d'une autre VRAM √† la sortie TV. </li></ul></li></ol><br><p>  √Ä peu pr√®s √† la m√™me √©poque, j'ai commenc√© √† prendre en charge les contr√¥leurs de jeu, au d√©but, je voulais utiliser des contr√¥leurs Nintendo, mais leurs prises sont propri√©taires et g√©n√©ralement difficiles √† trouver, alors j'ai opt√© pour des contr√¥leurs √† 6 boutons compatibles avec Mega Drive / Genesis, ils ont des prises DB-9 standard qui sont partout. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  √âcrire le premier vrai jeu </h2><br><p>  A cette √©poque, j'avais d√©j√† un CPU capable de contr√¥ler PPU, de travailler avec des joysticks, de lire des cartes SD ... il √©tait temps d' <a href="">√©crire le premier jeu</a> , bien s√ªr en assembleur Z80, cela m'a pris plusieurs jours de temps libre. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  Ajouter des graphiques dynamiques </h2><br><p>  Tout √©tait super, j'avais ma propre console de jeu, mais cela ne me suffisait pas, car dans le jeu, je devais utiliser les graphiques cousus dans la m√©moire PPU et il √©tait impossible de dessiner des tuiles pour un jeu sp√©cifique et il √©tait possible de le changer uniquement en reflasher la ROM.  J'ai commenc√© √† r√©fl√©chir √† la fa√ßon d'ajouter plus de m√©moire pour que le CPU puisse y charger des caract√®res pour les tuiles, puis le PPU pourrait alors tout lire √† partir de l√† et comment le faire plus facilement car le pr√©fixe s'est d√©j√† r√©v√©l√© compliqu√© et volumineux. </p><br><p>  Et j'ai trouv√© ce qui suit: seul le PPU aura acc√®s √† cette nouvelle m√©moire, et le CPU y chargera des donn√©es via le PPU et pendant que ce processus de chargement est en cours, cette m√©moire ne peut pas √™tre utilis√©e pour le dessin, mais il sera possible de dessiner √† partir de la ROM √† ce moment. </p><br><p>  Apr√®s la fin du chargement, le CPU basculera la m√©moire ROM interne vers cette nouvelle m√©moire, que j'ai appel√©e RAM de caract√®res (CHR-RAM) et dans ce mode, le PPU commencera √† dessiner des graphiques dynamiques, ce n'est probablement pas la meilleure solution, mais cela fonctionne.  En cons√©quence, une nouvelle m√©moire a √©t√© install√©e √† 128 kilo-octets et peut stocker 1024 caract√®res de 8x8 pixels chacun pour l'arri√®re-plan et le m√™me nombre de caract√®res pour les sprites. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  Et enfin le son </h2><br><p>  Les mains atteignirent le son en dernier.  Au d√©but, je voulais un son comme celui de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Uzebox</a> , c'est-√†-dire que le microcontr√¥leur g√©n√®re 4 canaux de son PWM. </p><br><p>  Cependant, il s'est av√©r√© que je peux facilement obtenir les puces vintage et j'ai command√© plusieurs puces de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">synth√®se FM</a> YM3438, ces gars-l√† sont enti√®rement compatibles avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YM2612</a> utilis√© dans Mega Drive / Genesis.  En les installant, vous pouvez obtenir une musique de qualit√© Mega Drive et des effets sonores produits par le microcontr√¥leur. </p><br><p>  J'ai install√© un autre microcontr√¥leur et je l'ai appel√© SPU (Sound Processor Unit), il contr√¥le le YM3438 et peut g√©n√©rer des sons moi-m√™me.  Le CPU le contr√¥le via une m√©moire √† double port, cette fois, il ne fait que 2 kilo-octets. </p><br><p>  Comme dans l'unit√© graphique, l'unit√© sonore dispose de 128 kilo-octets de m√©moire pour stocker des √©chantillons PCM et des patchs sonores, le CPU charge les donn√©es dans cette m√©moire en acc√©dant au SPU.  Il s'est av√©r√© que le CPU dit au SPU d'ex√©cuter des commandes √† partir de cette m√©moire ou met √† jour les commandes du SPU √† chaque trame. </p><br><p>  Le CPU contr√¥le quatre canaux PWM via quatre tampons circulaires dans la m√©moire SPU.  Le SPU passe par ces tampons et ex√©cute les commandes qui leur sont √©crites.  Il existe √©galement un tel tampon pour la puce de synth√®se FM. </p><br><p>  Au total, comme dans le graphique, l'interaction entre le CPU et le SPU se d√©roule selon le sch√©ma: </p><br><ol><li>  Le SPU copie les donn√©es du SPU dans la m√©moire interne. </li><li>  SPU attend une interruption de PPU (c'est pour la synchronisation) </li><li>  En m√™me temps <br><ul><li>  Le CPU met √† jour les tampons de canaux PWM et les tampons de synth√©tiseur FM. </li><li>  Le SPU ex√©cute les commandes dans les tampons en fonction des donn√©es de la m√©moire interne. </li><li>  Parall√®lement √† tout cela, le SPU met √† jour les sons PWM √† une fr√©quence de 16 kilohertz. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  Ce qui est finalement sorti </h1><br><p>  Une fois tous les blocs pr√™ts, certains sont all√©s √† la planche √† pain. <br>  Pour le bloc CPU, j'ai pu d√©velopper et commander un PCB personnalis√©, je ne sais pas si cela en vaut la peine pour les autres modules, je pense que j'ai vraiment eu de la chance que mon PCB fonctionne imm√©diatement. </p><br><p>  Sur la maquette maintenant (jusqu'√† pr√©sent), il n'y a que du son. <br>  Voici √† quoi cela ressemble aujourd'hui: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  L'architecture </h2><br><p>  Le diagramme illustre les composants de chaque bloc et comment ils interagissent les uns avec les autres.  La seule chose qui n'est pas montr√©e est le signal du PPU au CPU sur chaque trame comme une interruption et le m√™me signal qui va au SPU. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="imageArchitecture"></p><br><ul><li>  CPU: Zilog Z80 √† 10 MHz </li><li>  CPU-ROM: 8 Ko EEPROM, contient le code du chargeur de d√©marrage </li><li>  CPU-RAM: 128 Ko de RAM (56 Ko disponibles), code et donn√©es pour les programmes / jeux </li><li>  IO MCU: Atmega324, est l'interface entre le CPU et RS232, le clavier PS / 2, les joysticks et le syst√®me de fichiers de la carte SD </li><li>  PPU-RAM: 4 kilo-octets de m√©moire √† double port, m√©moire interm√©diaire entre CPU et PPU </li><li>  CHR-RAM: 128 Ko de RAM, stocke les tuiles dynamiques pour le support (substrat) et les sprites (en caract√®res de 8x8 pixels). </li><li>  VRAM1, VRAM2: 128 Ko de RAM (43008 est vraiment disponible), ils sont utilis√©s pour le framebuffer, ils √©crivent PPU et lisent VPU d'eux. </li><li>  PPU (Picture Processing Unit): Atmega1284, dessine un cadre dans le framebuffer. </li><li>  VPU (Video Processing Unit): Atmega324, lit le framebuffer et g√©n√®re un signal RGB et PAL et une synchronisation. </li><li>  SPU-RAM: 2 Ko de RAM √† double port, sert d'interface entre le CPU et le SPU. </li><li>  SNDRAM: 128 Ko de RAM, stocke les patchs PWM, les √©chantillons PCM et les blocs d'instructions pour le synth√©tiseur FM. </li><li>  YM3438: YM3438, puce de synth√®se FM. </li><li>  SPU (Sound Processing Unit): Atmega644, g√©n√®re des sons en utilisant le principe de la modulation de largeur d'impulsion (PWM) et contr√¥le le YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Sp√©cifications finales </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  CPU 8 bits Zilog Z80 √† une fr√©quence de 10Mhz. </li><li>  ROM de 8 Ko pour le chargeur de d√©marrage. </li><li>  56 Ko de RAM. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Lecture des donn√©es du lecteur de carte SD FAT16 / FAT32. </li><li>  Lecture / √©criture sur le port RS232. </li><li>  2 contr√¥leurs de jeu compatibles MegaDrive / Genesis. </li><li>  Clavier PS2. </li></ul><br><p>  <strong>Vid√©o:</strong> </p><br><ul><li>  R√©solution 224x192 pixels. </li><li>  25 images par seconde (demi-FPS de PAL). </li><li>  256 couleurs (RGB332). </li><li>  Fond virtuel 2x2 (448x384 pixels), avec d√©filement bidirectionnel bas√© sur les pixels, bas√© sur quatre pages plein √©cran. </li><li>  64 sprites d'une largeur et hauteur de 8 ou 16 pixels avec possibilit√© de retournement vertical et horizontal. </li><li>  Le fond et les sprites sont constitu√©s de caract√®res de 8x8 pixels chacun. </li><li>  M√©moire vid√©o symbolique de 1024 caract√®res pour l'arri√®re-plan et 1024 pour les sprites. </li><li>  64 d√©filement horizontal ind√©pendant le long de lignes d√©finies </li><li>  8 d√©filement vertical ind√©pendant le long de lignes fixes </li><li>  Superposition de 224 x 48 pixels avec transparence des touches de couleur en option. </li><li>  Tableau d'attributs d'arri√®re-plan. </li><li>  RGB et PAL composite via le connecteur SCART. </li></ul><br><p>  <strong>Son:</strong> </p><br><ul><li>  PWM pour 8 bits et 4 canaux, avec formes d'onde int√©gr√©es: carr√©, sinus, scie, bruit, etc. </li><li>  √âchantillons 8 bits, 8 kHz dans l'un des canaux PWM. </li><li>  Puce de synth√®se FM YM3438 charg√©e d'instructions √† une fr√©quence de 50 hertz. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  D√©veloppement pour la console </h1><br><p>  Pour la console, un chargeur de d√©marrage a √©t√© √©crit.  Le chargeur de d√©marrage est plac√© dans la CPU ROM et peut prendre jusqu'√† 8 kilo-octets.  Il utilise les 256 premiers octets de RAM.  Le chargeur est la premi√®re chose que le CPU ex√©cute.  Il est n√©cessaire d'afficher les programmes situ√©s sur la carte SD. </p><br><p>  Ces programmes se trouvent dans des fichiers qui contiennent du code compil√© et peuvent √©galement contenir des graphiques et du son. </p><br><p>  Apr√®s avoir s√©lectionn√© un programme, il est charg√© dans la m√©moire CPU, la m√©moire CHR et la m√©moire SPU.  Apr√®s quoi le code du programme est ex√©cut√©.  La taille maximale du code charg√© dans la console est de 56 kilo-octets, √† l'exception des 256 premiers octets, et bien s√ªr, vous devez prendre en compte l'espace pour la pile et les donn√©es. <br>  Et ce chargeur de d√©marrage et d'autres programmes √©crits pour cette console ont √©t√© cr√©√©s de la m√™me mani√®re d√©crite ci-dessous. </p><br><h2 id="memoryio-mapping">  Mappage m√©moire / E / S </h2><br><p>  Ce qui est important lors du d√©veloppement de ce pr√©fixe est de prendre en compte la fa√ßon dont le CPU acc√®de aux diff√©rents blocs et d'allouer correctement l'espace adresse pour l'entr√©e d'entr√©e et l'espace adresse m√©moire. </p><br><p>  Le CPU acc√®de √† la m√©moire √† acc√®s al√©atoire du chargeur de d√©marrage via l'espace d'adressage de la m√©moire. </p><br><p>  Espace d'adressage m√©moire <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="Cartographie ImageMemory"></p><br><p>  Et vers PPU-RAM, SPU-RAM et IO MCU via l'espace d'adressage d'E / S. </p><br><p>  Espace d'adressage d'E / S <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="Cartographie imageIO"></p><br><p>  Comme vous pouvez le voir dans le tableau, les adresses de tous les p√©riph√©riques, IO MCU, PPU et SPU sont allou√©es √† l'int√©rieur de l'espace d'adressage d'E / S. </p><br><h2 id="upravlenie-ppu">  Gestion PPU </h2><br><p>  D'apr√®s les informations du tableau, on peut voir que pour le contr√¥le PPU, il est n√©cessaire d'√©crire dans la m√©moire PPU qui est disponible aux adresses 1000h-1FFFh dans l'espace adresse E / S. </p><br><p>  Allocation d'espace d'adressage PPU </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="Cartographie imagePPU"></p><br><p>  Le statut PPU peut prendre les valeurs suivantes: </p><br><ol><li>  Mode graphique int√©gr√© </li><li>  Mode graphique dynamique (CHR-RAM) </li><li>  Mode d'enregistrement dans la m√©moire CHR </li><li>  L'enregistrement est termin√©, en attendant la confirmation du mode de la CPU </li></ol><br><p>  Voici, par exemple, comment vous pouvez travailler avec les sprites: <br>  Le pr√©fixe peut dessiner 64 sprites √† la fois.      CPU    -   1004h-1143h (320 ),     5   (5 * 64 = 320): </p><br><ol><li>   ,     : Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  ,     (  ). </li><li>    (    ‚Äî ) </li><li>   X </li><li>   Y </li></ol><br><p> ,   ,    Active  1,    X  Y   ,  32/32       ,        . </p><br><p>         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, si nous devons afficher le sprite num√©ro 10, alors l'adresse sera 4145 (1004h + (5 x 9)), √©crivez la valeur 1 pour l'activation et les coordonn√©es, par exemple, x = 100 et y = 120, √©crivez la valeur 100 √† l'adresse 4148 et adresse 4149 valeur 120. </font></font></p><br><h2 id="ispolzuem-assembler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utiliser l'assembleur </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une des m√©thodes de programmation de la console est l'assembleur. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici un exemple de la fa√ßon de montrer un sprite et de l'animer afin qu'il se d√©place et repousse les bords de l'√©cran. </font></font></p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>Utilisation du langage C</em></strong> </p><br><p>  Vous pouvez √©galement utiliser le langage C, pour cela nous avons besoin du compilateur SDCC et de quelques utilitaires suppl√©mentaires. </p><br><p>  Le code C peut √™tre plus lent, mais l'√©crire est plus rapide et plus facile. </p><br><p>  Voici un exemple de code qui fait la m√™me chose que le code assembleur ci-dessus, il utilise une biblioth√®que qui permet d'appeler PPU: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Graphiques dynamiques </h2><br><p>  (Dans les graphiques personnalis√©s d'origine. Environ. Per.) </p><br><p>  Dans le pr√©fixe ROM, 1 page de tuiles pour le support et une autre page de sprites pr√™ts √† l'emploi sont cousues), par d√©faut, vous ne pouvez utiliser que ces graphiques fixes, mais vous pouvez passer en dynamique. </p><br><p>  Mon objectif √©tait tel que tous les graphiques n√©cessaires sous forme binaire soient imm√©diatement charg√©s dans la RAM CHR, et le code dans le chargeur de d√©marrage √† partir de la ROM peut le faire.  Pour ce faire, j'ai fait plusieurs photos de la bonne taille avec diff√©rents symboles utiles: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="Composants de tuiles imageSample"></p><br><p>  √âtant donn√© que la m√©moire graphique dynamique se compose de 4 pages avec 256 caract√®res de 8x8 pixels chacun et 4 pages des m√™mes caract√®res pour les sprites, j'ai converti les images au format PNG, supprim√© les doublons: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="Exemple de feuille de personnage"></p><br><p>  Et puis il a utilis√© un outil auto-√©crit pour tout traduire au format binaire RGB332 avec des blocs 8x8. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="ligne de commande imageGraphics"></p><br><p>  En cons√©quence, nous avons des fichiers avec des caract√®res, o√π tous les caract√®res vont s√©quentiellement les uns apr√®s les autres et chacun prend 64 octets. </p><br><h2 id="zvuk">  Son </h2><br><p>  √âchantillons Wave RAW convertis en √©chantillons PCM 8 bits 8 kilohertz. </p><br><p>  Les correctifs pour les effets sonores sur PWM et la musique sont √©crits avec des instructions sp√©ciales. </p><br><p>  Quant √† la puce de synth√®se FM Yamaha YM3438, j'ai trouv√© un programme appel√© DefleMask qui produit de la musique synchronis√©e PAL pour la puce Genesis YM2612, qui est compatible avec le YM3438. </p><br><p>  DefleMask exporte de la musique au format VGM et je la convertis avec un autre utilitaire propri√©taire en mon propre format binaire. </p><br><p>  Tous les fichiers binaires des trois types de sons sont combin√©s en un seul fichier binaire, que mon chargeur de d√©marrage peut lire et charger dans la m√©moire sonore de la RAM SDN. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="ligne de commande imageSound"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Lien vers le fichier final </h2><br><p>  Le code ex√©cutable binaire, les graphiques et le son sont combin√©s en un seul fichier PRG.  Le fichier PRG a un en-t√™te dans lequel tout est d√©crit s'il y a des donn√©es audio et graphiques, combien elles occupent et les donn√©es elles-m√™mes. </p><br><p>  Un tel fichier peut √™tre √©crit sur une carte SD, et le chargeur de d√©marrage de la console le consid√®re et t√©l√©charge tout aux endroits appropri√©s et lance le code ex√©cutable du programme. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="ligne de commande imagePRG"></p><br><h2 id="emulyator">  √âmulateur </h2><br><p>  J'ai √©crit un √©mulateur de ma console en C ++ en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wxWidgets</a> pour en faciliter le d√©veloppement. </p><br><p>  Le CPU est √©mul√© par la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libz80</a> . </p><br><p>  Des fonctionnalit√©s ont √©t√© ajout√©es √† l'√©mulateur pour le d√©bogage, je peux l'arr√™ter √† tout moment et faire le d√©bogage √©tape par √©tape de l'assembleur, il y a une correspondance avec le code source en C. si cette langue a √©t√© utilis√©e pour le jeu. </p><br><p>  Selon le graphique, je peux regarder dans la m√©moire vid√©o, dans les tables de symboles et dans la m√©moire CHR elle-m√™me. </p><br><p>  Voici un exemple de programme ex√©cut√© sur un √©mulateur avec des outils de d√©bogage activ√©s. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="D√©mo imageEmulator"></p><br><h1 id="demka-programmirovaniya">  D√©mo de programmation </h1><br><p>  Ces vid√©os ont √©t√© tourn√©es avec un appareil photo smartphone dirig√© vers l'√©cran CRT du t√©l√©viseur, je m'excuse pour la qualit√© d'image imparfaite. </p><br><p>  L'interpr√©teur BASIC programmable √† partir du clavier PS / 2, apr√®s le premier programme, je montre comment √©crire directement dans la m√©moire PPU via l'espace adresse E / S en activant et en d√©pla√ßant le sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Une d√©mo de graphiques, dans cette vid√©o, t√©l√©chargez 64 sprites 16x16 par programmation, sur fond d'un arri√®re-plan avec d√©filement dynamique et une superposition qui se d√©place en dessous et au-dessus des sprites: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La d√©mo de son montre les capacit√©s du son YM3438 et PWM, les donn√©es sonores de cette d√©mo et la musique FM et les sons PWM occupent ensemble presque tous les 128 kilo-octets disponibles de m√©moire sonore. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, presque exclusivement les fonctions d'arri√®re-plan, la musique sur le YM3438, les effets sonores sur les patchs PWM ont √©t√© utilis√©s pour les graphiques. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Ce projet est vraiment un r√™ve devenu r√©alit√©, j'y travaille depuis plusieurs ann√©es, avec des interruptions, en regardant mon temps libre, je n'ai jamais pens√© que j'irais aussi loin dans la cr√©ation de ma propre console vid√©o r√©tro de jeu.  Naturellement, ce n'est pas parfait, je ne suis certainement pas un expert en √©lectronique, il y avait √©videmment trop d'√©l√©ments dans le d√©codeur, et sans aucun doute on pourrait faire mieux et probablement certains lecteurs y pensent. </p><br><p>  Mais quand m√™me, en travaillant sur ce projet, j'ai beaucoup appris sur l'√©lectronique, les consoles de jeux et la conception d'ordinateurs, le langage d'assemblage et d'autres choses int√©ressantes, et surtout j'ai re√ßu une grande satisfaction en jouant √† des jeux que j'ai moi-m√™me √©crits sur du mat√©riel que j'ai d√©velopp√© et collect√©s. </p><br><p>  J'ai des plans pour faire des consoles / ordinateurs et plus encore.  En fait, je fais d√©j√† un nouveau d√©codeur, il est presque pr√™t, et c'est un d√©codeur r√©tro simplifi√© bas√© sur une carte FPGA et plusieurs composants suppl√©mentaires (en quantit√© beaucoup plus petite que dans ce projet, certainement), l'id√©e est d'√™tre beaucoup moins cher et plus r√©p√©table. </p><br><p>  Bien que j'aie beaucoup √©crit sur ce projet ici, sans aucun doute beaucoup plus peut √™tre discut√©, j'ai √† peine mentionn√© comment le moteur sonore fonctionne, comment le CPU interagit avec lui, et il y a beaucoup plus √† faire sur le syst√®me graphique et les autres entr√©es / sorties et l'ensemble de la console serait de dire. </p><br><p>  En regardant la r√©action des lecteurs, je peux √©crire plus d'articles en se concentrant sur les mises √† jour, les d√©tails sur les blocs de pr√©fixe individuels ou d'autres projets. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Projets, sites, cha√Ænes Youtube qui m'ont inspir√© et m'a aid√© avec des connaissances techniques: </h2><br><p>  Ces sites / canaux m'ont non seulement inspir√©, mais m'ont √©galement aid√© √† trouver des solutions aux probl√®mes complexes qui se sont pos√©s lors des travaux de ce projet. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Uzebox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ben ryves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Retroleum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Z80.info</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EEVBlog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©canique de jeu r√©tro</a> </li></ul><br><p>  Merci d'avoir lu jusqu'ici.  :) </p><br><p>  Si vous avez des questions ou des commentaires, veuillez √©crire dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaires ci-dessous</a> (article original en anglais sur Github. Approx. Per.) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444006/">https://habr.com/ru/post/fr444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443996/index.html">Annonce de TypeScript 3.4 RC</a></li>
<li><a href="../fr443998/index.html">Nouveau record du monde pour le calcul du nombre de pi: 31,4 billions de caract√®res</a></li>
<li><a href="../fr444000/index.html">Par o√π commencer lors de l'embauche de personnel pour la premi√®re fois</a></li>
<li><a href="../fr444002/index.html">Le premier assistant vocal ¬´non sexiste¬ª au monde pr√©sent√© au SXSW IT Festival</a></li>
<li><a href="../fr444004/index.html">CLRium # 5: All-All-All sur GC et plus. Pierre et Moscou</a></li>
<li><a href="../fr444010/index.html">Images de conteneur .NET Core d√©sormais publi√©es dans le registre de conteneurs Microsoft</a></li>
<li><a href="../fr444014/index.html">Microsoft ouvre une √©cole de commerce pour apprendre les strat√©gies, la culture et la responsabilit√© de l'IA</a></li>
<li><a href="../fr444016/index.html">Obtenez plus avec Microsoft Game Stack</a></li>
<li><a href="../fr444018/index.html">Comment un changement de configuration PostgreSQL am√©liore 50 fois les performances des requ√™tes lentes</a></li>
<li><a href="../fr444020/index.html">Karting en URSS: comment le hobby des pilotes am√©ricains est devenu un hobby de bricolage massif en Union sovi√©tique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>