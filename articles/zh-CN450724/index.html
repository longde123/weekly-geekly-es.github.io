<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔺 💧 🛠️ 为同志们介绍Python，而不再使用“ A vs. V语言” 语言B”等偏见 👩‍👩‍👧‍👦 👫 🧝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对于所有有似曾相识感觉的habrach居民：文章“ Python简介”提示我写这篇文章，并对此发表评论。 不幸的是，这种“介绍”技术的质量……让我们不要谈论悲伤的事情。 但是在评论中观察到争吵甚至更可悲，例如“ C ++比Python更快”，“ Rust甚至比C ++更快”，“不需要Python”等...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为同志们介绍Python，而不再使用“ A vs. V语言” 语言B”等偏见</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450724/"><p> 对于所有有似曾相识感觉的habrach居民：文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Python简介”</a>提示我写这篇文章，并对此发表评论。 不幸的是，这种“介绍”技术的质量……让我们不要谈论悲伤的事情。 但是在评论中观察到争吵甚至更可悲，例如“ C ++比Python更快”，“ Rust甚至比C ++更快”，“不需要Python”等类别。 他们不记得Ruby真是太神奇了！ </p><br><p> 正如Bjarn Stroustrup所说， </p><br><blockquote>  “只有两种类型的编程语言：人们一直在发誓的语言和没人使用的语言。” </blockquote><p> 欢迎来到每个想熟悉Python而又不因肮脏的诅咒而死的人！ </p><a name="habracut"></a><br><p>东高加索山脉的早晨有哭声。 两个年轻人坐在一块大石头上，积极地讨论着一些东西，积极地打手势。 一分钟后，他们开始互相推挤，然后抓钩并从一块巨石上掉进了一个荨麻灌木丛中。 显然，灌木丛在那里生长是有原因的-他立即安抚了争吵者，并为他们无法解决的纠纷停火了。 您可能猜到了，我是辩论者之一，另一个是我最好的朋友（您好，Quaker_t！），但是我们的闲聊主题是<strong>Visual</strong> Basicvs。  <strong>德尔福</strong> ！ </p><br><p> 你认识你自己吗？ 有时，我们会将自己喜欢的编程语言变成一种狂热分子，并准备将其捍卫到最后！ 但是随着时间的流逝，当争执的主题从“ A vs. B”发展为“我更愿意与A一起工作，但是如果有必要，我将学习如何与B，C，D，E <em>以及通常一起使用任何东西一起工作</em> 。” 只有当我们遇到新的编程语言时，旧的习惯和文化可能不会让我们走很长时间。 </p><br><p> 我想向您介绍Python，并帮助您将经验转移到一个新的方向。 像任何技术一样，它也有其优点和缺点。 像C ++，Rust，Ruby，JS以及其他所有人一样，Python是一种工具。 说明附在任何仪器上，您必须学习<em>正确</em>使用任何仪器。 </p><br><p>  “作者，没有头脑，您打算向我们介绍Python吗？” 让我们结识！ </p><br><p>  Python是一种动态的高级通用编程语言。  Python是具有丰富生态系统和传统的<strong>成熟</strong>编程语言。 尽管该语言于1991年发布，但它的现代外观在2000年代初开始成形。  Python是一种<strong>收费的</strong>语言，在其标准库中有很多解决方案。  Python是一种<strong>流行的</strong>编程语言：Dropbox，Reddit，Instagram，Disqus，YouTube，Netflix，该死，甚至Eve Online以及许多其他积极使用Python的语言。 </p><br><p> 如此受欢迎的原因是什么？ 经过您的许可，我将介绍我自己的版本。 </p><br><p>  Python是一种<strong>简单的</strong>编程语言。 动态输入。 垃圾收集器。 高阶函数。 用于处理字典，集合，元组和列表的简单语法（包括获取切片）。  Python非常适合初学者：它使从过程编程开始，缓慢地切换到OOP以及品尝函数式编程成为可能。 但是这种简单性就像冰山一角。 当您遇到Python的哲学<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Zen Of Python</a>时，值得深入研究。 深入探讨-您会发现自己掌握了一套清晰的代码设计规则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Python代码样式指南</a> 。 潜水时，程序员逐渐研究“ Python方式”或“ Pythonic”的概念。 在语言学习的这个惊人的阶段，您开始理解为什么用这种方式编写好的Python程序，而不是其他方式。 为什么语言朝着这个方向发展，而不是朝着另一个方向发展。  Python没有成功。 但是他成功地完成了我们工作中最重要的方面-可读性。  “为人而不是为汽车编写代码”-这是Python基础的基础。 </p><br><p> 好的Python代码看起来很漂亮。 并编写漂亮的代码-什么不是愉快的职业？ </p><br><p>  <strong>提示0：</strong> <em>在进一步阅读之前，请先看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zen Python</a>角落。</em>  <em>语言基于这些假设，如果您熟悉它们，我们的交流将更加愉快。</em> </p><br><h3 id="kakoy-umnik-dodumalsya-do-otstupov"> 哪个聪明的人想到了缩进？ </h3><br><p> 对于那些从未使用过Python的代码的人来说，首先感到震惊的是指令体的缩进： </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ins = input(<span class="hljs-string"><span class="hljs-string">'Please say something'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ins.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w == <span class="hljs-string"><span class="hljs-string">'hello'</span></span>: print(<span class="hljs-string"><span class="hljs-string">'world!'</span></span>)</code> </pre> <br><p> 我记得在圣彼得堡理工学院的宿舍里的晚上，我的邻居<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">VlK</a>眼睛<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">发亮</a> ，告诉我他发掘了Python中的一些新东西。  “压痕体？认真吗？”  -是我的反应。 确实，对于一个通过C，C ++和Java从Visual Basic（ <code>if ... end if</code> ）到C＃（大括号）的人来说，这种方法似乎有些奇怪。  “您是否使用缩进来格式化代码？” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">VlK</a>问。 我当然格式化了。 更准确地说，螺旋Studio Visual为我做到了。 她做得很好。 我从没考虑过格式和缩进-它们是自己出现在代码中的，似乎有些普通和熟悉。 但是没有什么可隐藏的-代码始终采用缩进格式。  “那么，如果说明主体在任何情况下都向右移动，那么为什么需要花括号？” </p><br><p> 那天晚上，我坐下了Python。 回顾过去，我可以肯定地说是什么有助于快速吸收新材料。 这是一个代码编辑器。 受同一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">VlK的</a>影响，在发生上述事件之前不久，我从Windows切换到Ubuntu和Emacs担任编辑器（在2007年，转而使用PyCharm，Atom，VS Code等）。  “好吧，现在Emacs将PR ...”-您说。 只是一点点：)传统上，Emacs中的<code>&lt;tab&gt;</code>键不添加标签，而是根据此模式的规则来对齐行。 按下<code>&lt;tab&gt;</code> -并将代码行移至下一个合适的位置： </p><br><p><img src="https://habrastorage.org/webt/p_/8g/jm/p_8gjmuqid2ffw7ixile3wkjz74.gif"></p><br><p> 这样，您就不必考虑代码是否正确对齐了。 </p><br><p>  <strong>提示1：</strong> <em>当您了解Python时，请使用负责缩进的编辑器。</em> </p><br><p> 您知道所有这些耻辱有什么副作用吗？ 程序员试图避免冗长的构造。 一旦函数的大小超出了屏幕的垂直边界，就很难区分给定代码块属于哪个设计。 而且投资越多，难度就越大。 结果，您尝试尽可能简洁地编写代码，以破坏函数，循环，条件转换等冗长的主体。 </p><br><h3 id="da-nu-vashu-dinamicheskuyu-tipizaciyu"> 哦，你的动态打字 </h3><br><p> 哦，这种讨论几乎一直存在，只要存在“编程”的概念！ 动态类型输入既不好也不好。 动态类型输入也是我们的工具。 在Python中，动态类型提供了极大的操作自由度。 在行动自由度更高的地方，更有可能枪杀自己。 </p><br><p> 值得说明的是，在Python中键入是<strong>严格的</strong> ，并且不能在字符串中添加数字： </p><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt;&gt; TypeError: unsupported operand type(s) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> +: <span class="hljs-string"><span class="hljs-string">'int'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'str'</span></span></code> </pre> <br><p> 当调用函数时，Python还会检查该函数的签名，如果调用签名不正确，则会抛出异常： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) &gt;&gt;&gt; TypeError: sum() takes <span class="hljs-number"><span class="hljs-number">2</span></span> positional arguments but <span class="hljs-number"><span class="hljs-number">3</span></span> were given</code> </pre> <br><p> 但是在加载脚本时，Python不会告诉您该函数需要一个数字，而不是传递给它的字符串。 而且您只能在运行时了解它： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'10'</span></span>) &gt;&gt;&gt; TypeError: can only concatenate str (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>) to str</code> </pre> <br><p> 程序员面临的挑战越来越<em>大</em> ， <em>尤其是在编写大型项目时</em> 。 现代Python通过注释引擎和类型库解决了这一难题，并且社区已经开发了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行静态类型检查的程序</a> 。 结果，程序员在执行程序之前了解了以下错误： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># main.py: def sum(x: int, y: int) -&gt; int: return x + y sum(10, '10') $ mypy main.py tmp.py:5: error: Argument 2 to "sum" has incompatible type "str"; expected "int"</span></span></code> </pre> <br><p> 尽管Python将注释存储在<code>__annotations__</code>属性中，但它并不重视注释。 唯一的条件是，注释在语言方面必须是有效值。 自从它们出现在3.0版中（距今已经十多年了！）以来，社区的努力开始使用注释对变量和参数进行类型化标记。 </p><br><div class="spoiler">  <b class="spoiler_title">再举一个例子，比较复杂。</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      , :   :) from typing import TypeVar, Iterable Num = TypeVar('Num', int, float) def sum(items: Iterable[Num]) -&gt; Num: accum = 0 for item in items: accum += item return accum sum([1, 2, 3]) &gt;&gt;&gt; 6</span></span></code> </pre> </div></div><br><p>  <strong>技巧2：</strong> <em>在实践中，大多数动态类型会在读取和调试代码时引起问题。</em>  <em>尤其是如果此代码编写时没有注释，并且您必须花费大量时间弄清楚变量的类型。</em>  <em>您不必指示和记录所有内容的类型，但是花在对公共接口和代码的最关键部分进行详细描述上的时间将得到一百倍的奖励！</em> </p><br><h3 id="krya-utinaya-tipizaciya">  ！ 鸭打字 </h3><br><p> 有时，Python爱好者装作很神秘，并谈论“鸭子打字”。 <br> 鸭子输入是鸭子测试在编程中的使用： </p><br><blockquote> 如果一个物体像鸭子一样嘎嘎叫，像鸭子一样飞翔，像鸭子一样走路，那么它很可能就是鸭子。 </blockquote><p> 考虑一个例子： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RpgCharacter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, weapon)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">battle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.weapon.attack()</code> </pre> <br><p> 这是经典的依赖注入。  <code>RpgCharacter</code>类在构造函数中接收<code>weapon</code>对象，随后在<code>weapon.attack()</code>方法中调用<code>weapon.attack()</code> 。 但是<code>RpgCharacter</code>并不依赖于该<code>weapon</code>的具体实现。 它可以是剑，BFG 9000或带有花盆的鲸鱼，随时可以降落在敌人的头上。 重要的是对象必须具有<code>attack()</code>方法，Python对其他所有内容都不感兴趣。 </p><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="400" src="https://habrastorage.org/webt/l8/ld/yz/l8ldyzcgtvlj3ifvbpnswr2k7ws.png"></a> </div><p></p><br><p> 严格来说，鸭的打字不是唯一的。 它以实现OOP的所有（熟悉的）动态语言存在。 </p><br><p> 这是如何在动态类型世界中仔细编程的另一个示例。 方法名称不正确？ 不确定地命名为变量？ 大约半年后，您的同事或您自己将很乐意提出这样的代码:) </p><br><div class="spoiler">  <b class="spoiler_title">如果使用条件Java会发生什么？</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sword</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } } public class RpgCharacter { IWeapon weapon; public RpgCharacter(IWeapon weapon) { this.weapon = weapon; } public void battle() { weapon.attack(); } }</span></span></code> </pre> <br><p> 并且会有一个经典的静态类型，在编译阶段进行类型检查。  <code>IWeapon</code>无法使用具有<code>IWeapon</code> <code>attack()</code>方法的对象，但未明确实现<code>IWeapon</code>接口。 </p></div></div><br><p>  <strong>提示3</strong> ： <em>如果愿意，可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用方法和属性</a>构建自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象类</a>来描述接口。</em>  <em>更好的是，花时间为您自己和您的代码用户彻底测试和编写文档。</em> </p><br><h3 id="procedurnyy-podhod-i-__specialnye_metody__"> 程序方法和__特殊方法__（） </h3><br><p>  Python是一种面向对象的语言，而<code>object</code>类是继承层次结构的根： </p><br><pre> <code class="python hljs">isinstance(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> isinstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p> 但是在Java和C＃中使用<code>obj.ToString()</code>地方，将在Python中调用<code>str(obj)</code> 。 例如，Python将使用<code>len(my_list)</code>代替<code>myList.length</code> 。 语言的创建者Guido van Rossum对此进行了如下解释： </p><br><blockquote> 当我读到<code>len(x)</code>的代码时，我知道请求的长度。 这立即告诉我结果将是一个整数，并且参数是某种容器。 相反，在读取<code>x.len()</code> ，我需要知道<code>x</code>是某种实现特定接口或从具有<code>len()</code>方法的类继承的容器。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[来源]</a> </blockquote><p> 然而，在函数内部，函数<code>len()</code> ， <code>str()</code>和其他一些函数将调用对象的<strong>某些</strong>方法： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, last_name)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.last_name = last_name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f"Honourable </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.last_name}</span></span></span><span class="hljs-string">"</span></span> u = User(<span class="hljs-string"><span class="hljs-string">'Alex'</span></span>, <span class="hljs-string"><span class="hljs-string">'Black'</span></span>) label = str(u) print(label) &gt;&gt;&gt; Honourable Alex Black</code> </pre> <br><p> 语言运算符，包括数学运算符和布尔运算符，以及<code>for ... in ...</code>循环运算符， <code>with</code>上下文运算符，索引运算符<code>[]</code>等，也使用特殊方法。 <br> 例如，迭代器协议包含两种方法： <code>__iter__()</code>和<code>__next__()</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  Iterable, IEnumerable, std::iterator  .. class InfinitePositiveIntegers: def __init__(self): self.counter = 0 def __iter__(self): """      .    iter(). """ return self def __next__(self): """  .    next(). """ self.counter += 1 return self.counter for i in InfinitePositiveIntegers(): print(i) &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; ... #  ,  Ctrl + C</span></span></code> </pre> <br><p> 好吧，让我们说一些特殊的方法。 但是为什么它们看起来如此扭曲？  Guido通过这样的事实来解释这一点，即他们具有惯用的名字而不会强调，程序员本身不会至少早晚重新定义它们。 即  <code>____()</code>是对傻瓜的一种保护。 正如时间所显示-保护是有效的:) </p><br><p>  <strong>提示4：</strong> <em>仔细研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内置函数</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特殊对象方法</a> 。</em>  <em>它们是语言不可或缺的一部分，没有它，就不可能完全说出来。</em> </p><br><h3 id="gde-inkapsulyaciya-gde-moy-private-gde-moya-skazochka"> 封装在哪里？ 我的私人在哪里？ 我的童话在哪里？ </h3><br><p>  Python没有类属性的访问修饰符。 物体的内部无障碍开放。 但是，有一个约定，将前缀<code>_</code>视为私有属性，例如： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    _os_handle = None def __init__(self, path: str): self._open(path) #    def _open(self, path): # os.open() - **    . #      open(). #   os.open()    . self._os_handle = os.open(path, os.O_RDWR | os.O_CREAT) #      def close(self): if self._os_handle is not None: os.close(self._os_handle) f = MyFile('/tmp/file.txt') print(f._os_handle) #    ""    ! f.close()</span></span></code> </pre> <br><p> 怎么了 </p><br><blockquote>  Python中没有什么私有的。 该类及其实例都不会向您隐藏内部的内容（这是由于可以进行最深入的内省）。  Python信任您。 他有点说：“伙计，如果您想在黑暗的角落闲逛-没问题。我相信这是有充分的理由的，我希望您不要破坏任何东西。 <br><br> 最后，我们都是成年人。 <br><br>  -Karl Fast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[来源]</a> 。 </blockquote><br><div class="spoiler">  <b class="spoiler_title">但是如何避免在继承过程中发生名称冲突？</b> <div class="spoiler_text"><p>  Python有一种特殊的机制来处理以双下划线开头但不以双下划线结尾的属性名称（ <code>__my_attr</code> ）！ 这样做是为了避免在继承期间发生名称冲突。 为了在体外调用类方法，Python添加了<code>___</code>前缀。 但是对于内部访问，没有任何变化： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.__x = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__x c = C() c.__x &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'C'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__x'</span></span> print(c.get_x()) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> print(c._C__x) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p> 让我们看一个实际的应用程序。 例如，对于要从本地文件系统读取文件的<code>File</code>类，我们要添加缓存功能。 为此，我们的同事设法编写了一个mixin类。 但是为了将方法和属性与<strong>潜在的</strong>冲突区<code>__</code>来，一位同事在名称中添加了<code>__</code>前缀： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path)</span></span></span><span class="hljs-function">:</span></span> self.path = path <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_from_local</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(self.path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMissError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Tepe,         #   __cache,   __from_cache(), # ,     ! self.__cache = {} def __from_cache(self): return self.__cache[self.path] def read_from_cache(self): try: return self.__from_cache() except KeyError as e: raise self.CacheMissError() from e def store_to_cache(self, data): self.__cache[self.path] = data class File(CachedMixin, LocalMixin, BaseFile): def __init__(self, path): CachedMixin.__init__(self) BaseFile.__init__(self, path) def read(self): try: return self.read_from_cache() except CachedMixin.CacheMissError: data = self.read_from_local() self.store_to_cache(data) return data</span></span></code> </pre> <br><p> 如果您有兴趣在CPython中查看此机制的实现，请在<a href="">Python / compile.c中</a> </p></div></div><br><p> 最后，由于语言中存在属性，因此以Java风格编写getter和setter毫无意义： <code>getX(), setX()</code> 。 例如，在最初编写的“ <code>Coordinates</code>类中， </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y c = Coordinates(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) print(cx, cy) &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p> 我需要控制对<code>x</code>属性的访问。 正确的方法是将其替换为<code>property</code> ，从而与外界保持合同。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> _x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._x @x.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> val &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>: self._x = val <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">'x should be greater than 10'</span></span>) c = Coordinates(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) cx = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; ValueError: x should be greater than <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  <strong>提示5：</strong> <em>与Python一样，私有字段和类方法的概念基于已建立的约定。</em>  <em>如果“一切都停止了工作”，请不要因库的作者而冒犯，因为您已经积极使用了它们类的私有字段。</em>  <em>最后，我们都是成年人：)</em> 。 </p><br><h3 id="nemnogo-ob-isklyucheniyah"> 关于异常的一点 </h3><br><p>  Python文化对异常有独特的处理方法。 除了通常的拦截和处理la C ++ / Java之外，您还将在上下文中遇到异常的使用 </p><br><blockquote>  “寻求宽恕比获得许可更容易-EAFP。” </blockquote><p> 解释一下- <code>if</code>在大多数情况下，执行将在此分支上进行，请不要写太多。 相反，将逻辑包装在<code>try..except</code> 。 </p><br><p> 示例：想象一个在条件数据库中创建用户的POST请求处理程序。 在函数的输入处是键值类型的字典（字典）： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Dict[str, str])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> <br><p> 我们没有通过检查“数据中是否包含<code>username</code>或<code>password</code> ”来污染代码。 我们希望他们很可能会在那里。 我们不要求“许可”使用这些字段，而是在下一个kulhacker发布缺少数据的表单时“道歉”。 </p><br><div class="spoiler">  <b class="spoiler_title">只是不要把它带到荒谬的地步！</b> <div class="spoiler_text"><p> 例如，您想检查数据中是否存在用户的姓氏，以及是否未将其设置为空值。  <code>if</code>这里更合适： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'last_name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>], last_name=data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> </div></div><br><p>  <strong>错误绝不能默默传递。</strong>  -不要忽略例外！ 现代Python <code>raise from</code>构造上有了惊人的<code>raise from</code>它使您可以维护异常链的上下文。 例如： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProductError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(<span class="hljs-string"><span class="hljs-string">'There has been a terrible product error'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / x <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> MyProductError() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> e</code> </pre> <br><p> 如果没有<code>raise from e</code>异常链将在<code>MyProductError</code>中断，并且我们无法找出导致此错误的确切原因。 通过<code>raise from X</code>引发，引发异常的原因（即<code>X</code> ）存储在<code>__cause__</code>属性中： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: calculate(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> MyProductError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(e.__cause__) &gt;&gt;&gt; division by zero</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">但是在迭代的情况下有一点细微差别：StopIteration</b> <div class="spoiler_text"><p> 对于迭代，抛出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StopIteration</a>异常是信号表明迭代器已完成的正式方法。 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositiveIntegers</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, limit)</span></span></span><span class="hljs-function">:</span></span> self.counter = <span class="hljs-number"><span class="hljs-number">0</span></span> self.limit = limit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__next__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.counter += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.counter == self.limit: <span class="hljs-comment"><span class="hljs-comment">#  hasNext()  moveNext(), #  ,   raise StopIteration() return self.counter for i in PositiveIntegers(5): print(i) &gt; 1 &gt; 2 &gt; 3 &gt; 4</span></span></code> </pre> </div></div><br><p>  <strong>提示6：</strong> <em>我们仅在特殊情况下为异常处理付费。</em>  <em>不要忽视他们！</em> </p><br><h3 id="there-should-be-one---and-preferably-only-one---obvious-way-to-do-it"> 以前的方法应该只有一种，最好只有一种。 </h3><br><p>  <code>switch</code>或模式匹配？  -使用<code>if</code>和字典。  <code>do-</code> ？  -为此，有一段<code>while</code> 。  <code>goto</code> ？ 我想你自己猜到了。 这同样适用于其他语言似乎理所当然的某些设计技术和模式。 最令人惊讶的是，对其实施没有技术限制，只是“我们没有这种方式”。 </p><br><p> 例如，在Python中，您通常不会看到“ Builder”模式。 相反，它使用了将名称参数传递并显式请求给函数的功能。 相反 </p><br><pre> <code class="python hljs">human = HumanBuilder.withName(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>).withLastName(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>).ofAge(<span class="hljs-number"><span class="hljs-number">20</span></span>).withHobbies([<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>]).build()</code> </pre> <br><p> 将是 </p><br><pre> <code class="python hljs">human = Human( name=<span class="hljs-string"><span class="hljs-string">"Alex"</span></span> last_name=<span class="hljs-string"><span class="hljs-string">"Black"</span></span> age=<span class="hljs-number"><span class="hljs-number">20</span></span> hobbies=[<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>] )</code> </pre> <br><p> 标准库不使用方法链来处理<em>集合</em> 。 我记得一位来自Kotlin的同事如何向我展示以下含义的代码（摘自Kotlin的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a> ）： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shortGreetings = people .filter { it.name.length &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> } .map { <span class="hljs-string"><span class="hljs-string">"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it.name}</span></span></span><span class="hljs-string">!"</span></span> }</code> </pre> <br><p> 在Python中， <code>map()</code> ， <code>filter()</code>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他许多</a>功能都是函数，而不是集合方法。 逐一重写此代码，我们得到： </p><br><pre> <code class="python hljs">short_greetings = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: <span class="hljs-string"><span class="hljs-string">f"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span>, filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>, people))</code> </pre> <br><p> 我认为它看起来很糟糕。 因此，对于诸如<code>.takewhile().filter().map().reduce()</code>之类的长束，最好使用所谓的  <em>包容</em> （理解）或良好的旧周期。 顺便说一下，以相应的列表理解的形式给出了关于Kotlin的相同示例。 在Python上看起来像这样： </p><br><pre> <code class="python hljs">short_greetings = [ <span class="hljs-string"><span class="hljs-string">f"Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> h <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> people <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">对于那些错过锁链的人</b> <div class="spoiler_text"><p> 有类似<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pipe</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">py_linq的</a>库！ </p></div></div><br><p> 在方法链比标准工具更有效的地方使用方法链。 例如，在Django Web框架中，链被用来构建数据库查询对象： </p><br><pre> <code class="python hljs">query = User.objects \ .filter(last_visited__gte=<span class="hljs-string"><span class="hljs-string">'2019-05-01'</span></span>) \ .order_by(<span class="hljs-string"><span class="hljs-string">'username'</span></span>) \ .values(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, <span class="hljs-string"><span class="hljs-string">'last_visited'</span></span>) \ [:<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre> <br><p>  <strong>提示7：</strong> <em>在您根据过去的经验做过非常熟悉但对Python不熟悉的事情之前，请问自己有经验的python专家会做出什么决定？</em> </p><br><h3 id="piton-medlennyy">  Python慢 </h3><br><p> 是的 </p><br><p> 是的，与静态类型和编译语言相比，执行速度更高。 </p><br><p> 但是您似乎想要详细的答案吗？ </p><br><p>  Python参考实现（CPython）远非其最有效的实现。 重要原因之一是开发人员希望不使其复杂化。 逻辑是可以理解的-不太深刻的代码意味着更少的错误，更好的机会进行更改，最终，更多的人想要阅读，理解和补充此代码。 </p><br><p> 杰克·范德普拉斯（Jake VanderPlas）在他的博客中分析<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>当添加两个包含整数值的变量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时，CPython</a>幕后的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">情况</a> ： </p><br><pre> <code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> c = a + b</code> </pre> <br><p> 即使我们不深入CPython的丛林，我们也可以说要存储变量<code>a</code> ， <code>b</code>和<code>c</code> ，解释器将不得不在堆上创建三个对象，其中将存储类型和（指针）值； 在加法操作期间重新确定类型和值，以调用诸如<code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code> ； 将结果写入<code>c</code> 。 <br> 与类似的C程序相比，这是非常低效的。 </p><br><p>  CPython的另一个麻烦是所谓的 全局解释器锁定（GIL）。 该机制本质上是一个由互斥锁括起来的布尔值，用于同步字节码的执行。  GIL简化了在多线程环境中运行的代码的开发：CPython无需考虑同步对变量或死锁的访问。 您必须为此付出代价，因为只有一个线程可以访问并在给定的时间<em>执行字节码</em> ： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/od/if/rwodifh_niof7jaf5bvmagg4ypy.gif"></div><br><p>  <strong>UPD：</strong>但这并不意味着Python上的程序可以在多线程环境中神奇地工作！  Python上的代码不会一一传输到字节码，并且不能保证版本之间字节码的兼容性！ 因此，您仍然必须同步代码中的线程。 幸运的是，这里的Python具有丰富的工具集，例如，允许您在多线程和多进程执行模型之间进行切换。 </p><br><div class="spoiler">  <b class="spoiler_title">如果您对正在采取哪些措施来根除GIL感到好奇</b> <div class="spoiler_text"><p>    Anthony Shaw " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Has the Python GIL been slain?</a> ". </p></div></div><br><p>    ? </p><br><ol><li>      .    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CFFI</a> )              .           API    (extensions)  C/C++.    ,      Rust, Go   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kotlin Native</a> ! </li><li>    , : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyPy</a> ,   JIT-.    ,     ,          ? </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cython</a> —      Python    C. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IronPython</a> — ,   .NET framework. </li></ul></li></ol><br><p> <strong> 8:</strong> <em>     ,              .      ,   IO (, ,  )   ,    ,      ,    ,     :)</em> </p><br><h3 id="osnovnye-instrumenty">   </h3><br><p>      ?      Linux  MacOS,   95%      .      ,      3.,       2.7.    Windows   .   :  Docker, Windows Subsystem for Linux, Cygwin, ,     . </p><br><p> <strong> 9:</strong> <em>     .  ,   —       -   .</em> </p><br><p>    "Hello world"   ? 太好了！      machine learning-    -    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python Package Index</a> (PyPI). </p><br><p>        (packages),    ..   (virtual environments).        ,      .     -    .   <code>pip</code>    .     <code>pip</code>      .      ,  <code>pipenv</code>  <code>poetry</code> —  npm, bundler, cargo  .. </p><br><p> <strong> 0xA:</strong> <em>      —  <code>pip</code>  <code>virtualenv</code> .   —  , ,  .  ,      —   <code>sys.path</code> —  ,        .</em> </p><br><h3 id="chto-zhe-dalshe">   ? </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ?       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> .     : </p><br><blockquote>      Dive into python... </blockquote><p> ,               .              , ,     :) </p><br><p> , ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450724/">https://habr.com/ru/post/zh-CN450724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450710/index.html">从合成视频（及类似视频）重建Midi</a></li>
<li><a href="../zh-CN450712/index.html">DotNext 2019 Piter上的DotNetRu</a></li>
<li><a href="../zh-CN450716/index.html">宣布Windows视觉技能（预览）</a></li>
<li><a href="../zh-CN450718/index.html">RxJS v6.5的新增功能</a></li>
<li><a href="../zh-CN450720/index.html">如何开发用户友好的应用程序</a></li>
<li><a href="../zh-CN450726/index.html">创建一个工具来快速有效地在Selenium上编写自动测试</a></li>
<li><a href="../zh-CN450728/index.html">NLog：规则和过滤器</a></li>
<li><a href="../zh-CN450730/index.html">ok.tech：前端聚会</a></li>
<li><a href="../zh-CN450732/index.html">我知道，这意味着我存在：计算机视觉深度学习的回顾（第1部分）</a></li>
<li><a href="../zh-CN450734/index.html">模糊测试是安全开发的重要一步</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>