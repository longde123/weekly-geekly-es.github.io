<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🀄️ 📎 💤 Memperkenalkan Aliran Udara untuk mengelola Spark Jobs di ivi: harapan dan tongkat penyangga 🛀🏽 ✖️ 💅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tugas menyebarkan model pembelajaran mesin dalam produksi selalu menyakitkan dan menderita, karena sangat tidak nyaman untuk keluar dari notebook jupy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan Aliran Udara untuk mengelola Spark Jobs di ivi: harapan dan tongkat penyangga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ivi/blog/456630/">  Tugas menyebarkan model pembelajaran mesin dalam produksi selalu menyakitkan dan menderita, karena sangat tidak nyaman untuk keluar dari notebook jupyter yang nyaman ke dunia pemantauan dan toleransi kesalahan. <br><br>  Kami sudah menulis tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iterasi pertama refactoring</a> sistem rekomendasi ivi bioskop online.  Selama setahun terakhir, kami hampir tidak menyelesaikan arsitektur aplikasi (dari global - hanya bergerak dari python usang 2.7 dan python 3.4 ke python 3.6 segar), tetapi kami menambahkan beberapa model ML baru dan segera mengalami masalah meluncurkan algoritma baru dalam produksi.  Dalam artikel tersebut, saya akan berbicara tentang pengalaman kami dalam mengimplementasikan alat manajemen aliran tugas seperti Apache Airflow: mengapa tim memiliki kebutuhan ini, apa yang tidak sesuai dengan solusi yang ada, kruk mana yang harus dipotong sepanjang jalan dan apa yang terjadi. <br><br>  → Versi video dari laporan dapat ditonton di YouTube (mulai pukul 03:00:00) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qc/bw/tt/qcbwttjzivyzuedihk88u6nwn5o.png"></div><br><a name="habracut"></a><br><br><h2>  <font color="#fd004c">Tim Hydra</font> </h2><br>  Saya akan memberi tahu Anda sedikit tentang proyek ini: ivi adalah beberapa puluh ribu unit konten, kami memiliki salah satu direktori hukum terbesar di RuNet.  Halaman utama dari versi web ivi adalah potongan yang dipersonalisasi dari katalog, yang dirancang untuk menyediakan pengguna dengan konten yang paling kaya, paling relevan berdasarkan umpan baliknya (pandangan, peringkat, dan sebagainya). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vj/-g/nh/vj-gnheaviq-z7tibuzawo-qdqs.png"></div><br>  Bagian online dari sistem rekomendasi adalah aplikasi backend Flask dengan beban hingga 600 RPS.  Offline, model ini dilatih pada lebih dari 250 juta tampilan konten per bulan.  Pipa persiapan data untuk pelatihan diimplementasikan pada Spark, yang berjalan di atas repositori Hive. <br><br>  Tim sekarang memiliki 7 pengembang yang terlibat dalam pembuatan model dan meluncurkannya ke dalam produksi - ini adalah tim yang agak besar yang membutuhkan alat yang mudah untuk mengelola aliran tugas. <br><br><h2>  <font color="#fd004c">Arsitektur Offline</font> </h2><br>  Di bawah ini Anda melihat diagram infrastruktur aliran data untuk sistem pemberi rekomendasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/10/nv/xs10nvc8r3mz9bd8osjrn6sqn3u.png"></div><br>  Dua penyimpanan data digambarkan di sini - Hive untuk umpan balik pengguna (tampilan, peringkat) dan Postgres untuk berbagai informasi bisnis (jenis monetisasi konten, dll.), Sementara transfer dari Postgres ke Hive disesuaikan.  Satu pak aplikasi Spark menghisap data dari Hive: dan melatih model kami pada data ini (ALS untuk rekomendasi pribadi, berbagai model kolaboratif kesamaan konten). <br><br>  Aplikasi Spark secara tradisional telah dikelola dari mesin virtual khusus, yang kami sebut hydra-updater menggunakan sekelompok skrip shell + cron.  Bundel ini dibuat di departemen operasi ivi pada jaman dahulu dan bekerja dengan sangat baik.  Shell-script adalah titik masuk tunggal untuk meluncurkan aplikasi-percikan - yaitu, setiap model baru mulai berputar di prod hanya setelah administrator menyelesaikan skrip ini. <br><br>  Beberapa artefak pelatihan model disimpan dalam HDFS untuk penyimpanan abadi (dan menunggu seseorang untuk mengunduhnya dari sana dan transfer ke server tempat bagian online berputar), dan beberapa ditulis langsung dari driver Spark ke penyimpanan cepat Redis, yang kami gunakan sebagai umum memori untuk beberapa lusin proses python dari bagian online. <br><br>  Arsitektur semacam itu telah mengakumulasi sejumlah kerugian dari waktu ke waktu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/x2/b0/rix2b0qjxi1qa0igp-bpl23bn04.png"></div><br>  Diagram menunjukkan bahwa aliran data memiliki struktur yang agak rumit dan rumit - tanpa alat yang sederhana dan jelas untuk mengelola barang ini, pengembangan dan operasi akan berubah menjadi horor, pembusukan, dan penderitaan. <br><br>  Selain mengelola aplikasi percikan, skrip admin melakukan banyak hal berguna: memulai kembali layanan dalam pertempuran, dump Redis, dan hal-hal sistem lainnya.  Jelas, selama periode operasi yang panjang, skrip telah ditumbuhi banyak fungsi, karena setiap model baru kita menghasilkan beberapa lusin baris di dalamnya.  Script mulai terlihat terlalu kelebihan dalam hal fungsionalitas, oleh karena itu, sebagai tim dari sistem yang merekomendasikan, kami ingin mengambil suatu bagian dari fungsi yang menyangkut peluncuran dan pengelolaan aplikasi Spark.  Untuk tujuan ini, kami memutuskan untuk menggunakan Airflow. <br><br><h2>  <font color="#fd004c">Kruk untuk Aliran Udara</font> </h2><br>  Selain menyelesaikan semua masalah ini, tentu saja, dalam perjalanan kami membuat yang baru untuk diri kami sendiri - menyebarkan Airflow untuk meluncurkan dan memantau aplikasi Spark ternyata sulit. <br><br>  Kesulitan utama adalah bahwa tidak ada yang akan merombak seluruh infrastruktur untuk kita, karena  sumber daya devops adalah hal yang langka.  Untuk alasan ini, kami tidak hanya harus mengimplementasikan Airflow, tetapi mengintegrasikannya ke dalam sistem yang ada, yang jauh lebih sulit dilihat dari awal. <br><br>  Saya ingin berbicara tentang rasa sakit yang kami temui selama proses implementasi, dan kruk yang harus kami tebas untuk mendapatkan Airflow. <br><br>  <b>Rasa sakit pertama dan utama</b> : bagaimana mengintegrasikan Airflow ke dalam skrip shell besar dari departemen operasi. <br><br>  Di sini solusinya adalah yang paling jelas - kami mulai memicu grafik langsung dari skrip shell menggunakan biner aliran udara dengan kunci trigger_dag.  Dengan pendekatan ini, kami tidak menggunakan penjadwal Airflow, dan pada kenyataannya aplikasi Spark diluncurkan dengan mahkota yang sama - ini secara agama tidak terlalu benar.  Tetapi kami mendapat integrasi yang mulus dengan solusi yang ada.  Beginilah awalnya dari skrip shell aplikasi Spark utama kami, yang secara historis disebut hydramatrices. <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$FUNCNAME</span></span></span><span class="hljs-string"> started"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> RETVAL=0 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> AIRFLOW_CONFIG=/opt/airflow/airflow.cfg AIRFLOW_API=api/dag_last_run/hydramatrices/all <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">"run /var/www/airflow/bin/airflow trigger_dag hydramatrices"</span></span> /var/www/airflow/bin/airflow trigger_dag hydramatrices 2&gt;&amp;1 | tee -a <span class="hljs-variable"><span class="hljs-variable">$LOGFILE</span></span></code> </pre> <br>  <b>Nyeri:</b> Skrip shell dari departemen operasi entah bagaimana harus menentukan status grafik Aliran Udara untuk mengontrol aliran eksekusi sendiri. <br><br>  Crutch: kami memperluas AirEST REST API dengan titik akhir untuk pemantauan DAG tepat di dalam skrip shell.  Sekarang setiap grafik memiliki tiga status: RUNNING, SUCCEED, FAILED. <br><br>  Faktanya, setelah memulai perhitungan di Airflow, kami cukup melakukan polling secara teratur pada grafik yang sedang berjalan: kami menerima permintaan GET untuk menentukan apakah DAG telah selesai atau belum.  Ketika titik akhir pemantauan merespons tentang keberhasilan eksekusi grafik, skrip shell terus menjalankan alirannya. <br>  Saya ingin mengatakan bahwa REST API Aliran Udara hanyalah hal yang berapi-api yang memungkinkan Anda mengkonfigurasi secara fleksibel saluran pipa Anda - misalnya, Anda dapat meneruskan parameter POST ke grafik. <br><br>  Ekstensi Airflow API hanyalah kelas Python yang terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> settings <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airflow.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DagBag, DagRun <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Blueprint, request, Response airflow_api_blueprint = Blueprint(<span class="hljs-string"><span class="hljs-string">'airflow_api'</span></span>, __name__, url_prefix=<span class="hljs-string"><span class="hljs-string">'/api'</span></span>) AIRFLOW_DAGS = <span class="hljs-string"><span class="hljs-string">'{}/dags'</span></span>.format( os.path.dirname(os.path.dirname(os.path.abspath(__file__))) ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiResponse</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    GET """</span></span> STATUS_OK = <span class="hljs-number"><span class="hljs-number">200</span></span> STATUS_NOT_FOUND = <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> @staticmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standard_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: int, payload: dict)</span></span></span><span class="hljs-function"> -&gt; Response:</span></span> json_data = json.dumps(payload) resp = Response(json_data, status=status, mimetype=<span class="hljs-string"><span class="hljs-string">'application/json'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, payload: dict)</span></span></span><span class="hljs-function"> -&gt; Response:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.standard_response(self.STATUS_OK, payload) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, status: int, message: str)</span></span></span><span class="hljs-function"> -&gt; Response:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.standard_response(status, {<span class="hljs-string"><span class="hljs-string">'error'</span></span>: message}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">not_found</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message: str = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Resource not found'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; Response:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.error(self.STATUS_NOT_FOUND, message)</code> </pre><br>  Kami menggunakan API dalam skrip shell - kami menyurvei titik akhir setiap 10 menit: <br><br><pre> <code class="bash hljs"> TRIGGER=$? [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TRIGGER</span></span></span><span class="hljs-string">"</span></span> -eq <span class="hljs-string"><span class="hljs-string">"0"</span></span> ] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">"trigger airflow DAG succeeded"</span></span> || { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">"trigger airflow DAG failed"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 1; } CMD=<span class="hljs-string"><span class="hljs-string">"curl -s http://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$HYDRA_SERVER</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$AIRFLOW_API</span></span></span><span class="hljs-string"> | jq .dag_last_run.state"</span></span> STATE=$(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> <span class="hljs-variable"><span class="hljs-variable">$CMD</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$STATE</span></span> == \<span class="hljs-string"><span class="hljs-string">"running\" ]; do log "</span></span>Generating matrices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> progress...<span class="hljs-string"><span class="hljs-string">" sleep 600 STATE=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(eval $CMD)</span></span></span><span class="hljs-string"> done [ </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STATE</span></span></span><span class="hljs-string"> == \"success\" ] &amp;&amp; RETVAL=0 || RETVAL=1 [ </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$RETVAL</span></span></span><span class="hljs-string"> -eq 0 ] &amp;&amp; log "</span></span><span class="hljs-variable"><span class="hljs-variable">$FUNCNAME</span></span> succeeded<span class="hljs-string"><span class="hljs-string">" || log "</span></span><span class="hljs-variable"><span class="hljs-variable">$FUNCNAME</span></span> failed<span class="hljs-string"><span class="hljs-string">" return </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$RETVAL</span></span></span></span></code> </pre><br>  <b>Nyeri</b> : jika Anda pernah menjalankan pekerjaan Spark menggunakan percikan-kirim dalam mode kluster, maka Anda tahu bahwa log di STDOUT adalah lembar tidak informasi dengan baris "SPARK APPLICATION_ID IS RUNNING".  Log aplikasi Spark itu sendiri dapat dilihat, misalnya, menggunakan perintah log benang.  Dalam skrip shell, masalah ini diselesaikan secara sederhana: terowongan SSH dibuka ke salah satu mesin cluster dan percikan-kirim dieksekusi dalam mode klien untuk mesin ini.  Dalam hal ini, STDOUT akan memiliki log yang dapat dibaca dan dimengerti.  Di Airflow, kami memutuskan untuk selalu menggunakan cluster-putuskan, dan nomor seperti itu tidak akan berfungsi. <br><br>  Crutch: setelah spark-submit bekerja, kami menarik log driver dari HDFS oleh application_id dan menampilkannya di antarmuka Airflow hanya melalui operator Python print ().  Satu-satunya negatif - di antarmuka Airflow, log muncul hanya setelah percikan-kirim telah berfungsi, Anda harus mengikuti realtime di tempat lain - misalnya, moncong web YARN. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_logs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: BaseConfig, app_id: str)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   :param config: :param app_id: """</span></span> hdfs = HDFSInteractor(config) logs_path = <span class="hljs-string"><span class="hljs-string">'/tmp/logs/{username}/logs/{app_id}'</span></span>.format(username=config.CURRENT_USERNAME, app_id=app_id) logs_files = hdfs.files_in_folder(logs_path) logs_files = [file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> logs_files <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> file[<span class="hljs-number"><span class="hljs-number">-4</span></span>:] != <span class="hljs-string"><span class="hljs-string">'.tmp'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> logs_files: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> hdfs.hdfs_client.read(os.path.join(logs_path, file), encoding=<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, delimiter=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> reader: print_line = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reader: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re.search(<span class="hljs-string"><span class="hljs-string">'stdout'</span></span>, line) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(line) &gt; <span class="hljs-number"><span class="hljs-number">30</span></span>: print_line = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re.search(<span class="hljs-string"><span class="hljs-string">'stderr'</span></span>, line): print_line = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> print_line: print(line)</code> </pre><br>  <b>Nyeri</b> : untuk penguji dan pengembang, alangkah baiknya memiliki bangku tes Airflow, tetapi kami menghemat sumber daya devops, jadi kami telah memikirkan tentang bagaimana menerapkan lingkungan pengujian untuk waktu yang lama. <br><br>  Crutch: kami mengemas Airflow dalam wadah buruh pelabuhan, dan Dockerfile meletakkannya di repositori dengan pekerjaan percikan.  Dengan demikian, setiap pengembang atau penguji dapat meningkatkan Aliran Udara mereka sendiri pada mesin lokal.  Karena kenyataan bahwa aplikasi berjalan dalam mode cluster, sumber daya lokal untuk buruh pelabuhan hampir tidak diperlukan. <br><br>  Instalasi lokal percikan disembunyikan di dalam wadah buruh pelabuhan dan seluruh konfigurasinya melalui variabel lingkungan - Anda tidak perlu lagi menghabiskan beberapa jam menyiapkan lingkungan.  Di bawah ini saya memberikan contoh dengan fragmen file buruh pelabuhan untuk sebuah wadah dengan Airflow, di mana Anda dapat melihat bagaimana Airflow dikonfigurasi menggunakan variabel lingkungan: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 ARG AIRFLOW_VERSION=1.9.0 ARG AIRFLOW_HOME ARG USERNAME=airflow ARG USER_ID ARG GROUP_ID ARG LOCALHOST ARG AIRFLOW_PORT ARG PIPENV_PATH ARG PROJECT_HYDRAMATRICES_DOCKER_PATH RUN apt-get update \ &amp;&amp; apt-get install -y \ python3.6 \ python3.6-dev \ &amp;&amp; update-alternatives --install /usr/bin/python3 python3.6 /usr/bin/python3.6 0 \ &amp;&amp; apt-get -y install python3-pip RUN mv /root/.pydistutils.cf /root/.pydistutils.cfg RUN pip3 install pandas==0.20.3 \ apache-airflow==<span class="hljs-variable"><span class="hljs-variable">$AIRFLOW_VERSION</span></span> \ psycopg2==2.7.5 \ ldap3==2.5.1 \ cryptography <span class="hljs-comment"><span class="hljs-comment">#   ,       ENV PROJECT_HYDRAMATRICES_DOCKER_PATH=${PROJECT_HYDRAMATRICES_DOCKER_PATH} ENV PIPENV_PATH=${PIPENV_PATH} ENV SPARK_HOME=/usr/lib/spark2 ENV HADOOP_CONF_DIR=$PROJECT_HYDRAMATRICES_DOCKER_PATH/etc/hadoop-conf-preprod ENV PYTHONPATH=${SPARK_HOME}/python/lib/py4j-0.10.4-src.zip:${SPARK_HOME}/python/lib/pyspark.zip:${SPARK_HOME}/python/lib ENV PIP_NO_BINARY=numpy ENV AIRFLOW_HOME=${AIRFLOW_HOME} ENV AIRFLOW_DAGS=${AIRFLOW_HOME}/dags ENV AIRFLOW_LOGS=${AIRFLOW_HOME}/logs ENV AIRFLOW_PLUGINS=${AIRFLOW_HOME}/plugins #      Airflow (log url) BASE_URL="http://${AIRFLOW_CURRENT_HOST}:${AIRFLOW_PORT}" ; #   Airflow ENV AIRFLOW__WEBSERVER__BASE_URL=${BASE_URL} ENV AIRFLOW__WEBSERVER__ENDPOINT_URL=${BASE_URL} ENV AIRFLOW__CORE__AIRFLOW_HOME=${AIRFLOW_HOME} ENV AIRFLOW__CORE__DAGS_FOLDER=${AIRFLOW_DAGS} ENV AIRFLOW__CORE__BASE_LOG_FOLDER=${AIRFLOW_LOGS} ENV AIRFLOW__CORE__PLUGINS_FOLDER=${AIRFLOW_PLUGINS} ENV AIRFLOW__SCHEDULER__CHILD_PROCESS_LOG_DIRECTORY=${AIRFLOW_LOGS}/scheduler</span></span></code> </pre><br>  Sebagai hasil dari penerapan Aliran Udara, kami mencapai hasil berikut: <br><br><ul><li>  Mengurangi siklus rilis: meluncurkan model baru (atau pipa persiapan data) sekarang turun untuk menulis grafik Airflow baru, grafik itu sendiri disimpan dalam repositori dan disebarkan dengan kode.  Proses ini sepenuhnya berada di tangan pengembang.  Admin senang, kami tidak lagi menarik mereka pada hal sepele. </li><li>  Log aplikasi Spark yang dulu langsung menuju neraka sekarang disimpan di Aiflow dengan antarmuka akses yang nyaman.  Anda dapat melihat log untuk hari apa pun tanpa memilih di direktori HDFS. </li><li>  Perhitungan yang gagal dapat dimulai kembali dengan satu tombol di antarmuka, itu sangat nyaman, bahkan Juni dapat menanganinya. </li><li>  Anda dapat menjalankan tugas percikan dari antarmuka tanpa harus mengalami pengaturan Spark pada mesin lokal.  Penguji senang - semua pengaturan agar spark-submit berfungsi dengan benar sudah dibuat di Dockerfile </li><li>  Aiflow roti standar - jadwal, memulai kembali pekerjaan yang jatuh, grafik yang indah (misalnya, waktu eksekusi aplikasi, statistik peluncuran yang berhasil dan tidak berhasil). </li></ul><br>  Ke mana harus pergi selanjutnya?  Sekarang kita memiliki sejumlah besar sumber data dan sink, yang jumlahnya akan bertambah.  Perubahan dalam kelas repositori hydramatrices dapat macet di pipa lain (atau bahkan di bagian online): <br><br><ul><li>  Clickhouse meluap → Sarang </li><li>  preprocessing data: Sarang → Sarang </li><li>  menggunakan model c2c: Hive → Redis </li><li>  persiapan direktori (seperti jenis monetisasi konten): Postgres → Redis </li><li>  persiapan model: FS Lokal → HDFS </li></ul><br>  Dalam situasi seperti itu, kita benar-benar memerlukan dukungan pengujian otomatis pipa dalam persiapan data.  Ini akan sangat mengurangi biaya pengujian perubahan dalam repositori, mempercepat peluncuran model-model baru dalam produksi dan secara dramatis meningkatkan tingkat endorfin pada penguji.  Tetapi tanpa Airflow, tidak mungkin untuk memasang dudukan untuk pengujian otomatis semacam ini! <br><br>  Saya menulis artikel ini untuk menceritakan pengalaman kami dalam mengimplementasikan Airflow, yang mungkin berguna bagi tim lain dalam situasi yang sama - Anda sudah memiliki sistem kerja yang besar, dan Anda ingin mencoba sesuatu yang baru, modis dan awet muda.  Tidak perlu takut dengan pembaruan pada sistem kerja, Anda perlu mencoba dan bereksperimen - eksperimen semacam itu biasanya membuka cakrawala baru untuk pengembangan lebih lanjut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456630/">https://habr.com/ru/post/id456630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456614/index.html">How A Plague Tale: Innocence Frame Render</a></li>
<li><a href="../id456616/index.html">3 juta rubel untuk mereka yang bisa kode</a></li>
<li><a href="../id456618/index.html">Larabeer Moscow - 21 Juni</a></li>
<li><a href="../id456622/index.html">Cara membuat OS bersertifikat berdasarkan perlindungan kelas I</a></li>
<li><a href="../id456624/index.html">Alat Python yang Berguna</a></li>
<li><a href="../id456632/index.html">Kami sedang membangun templat C ++ lantai empat di RESTinio. Kenapa dan bagaimana?</a></li>
<li><a href="../id456634/index.html">Resep Nginx: CAS (Layanan Otorisasi Pusat)</a></li>
<li><a href="../id456638/index.html">Membandingkan proyek yang sama di Rust, Haskell, C ++, Python, Scala, dan OCaml</a></li>
<li><a href="../id456640/index.html">Analisis kontes intelijen kompetitif di PHDays 9</a></li>
<li><a href="../id456642/index.html">Kelulusan pertama program Master Perusahaan JetBrains dan Universitas ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>