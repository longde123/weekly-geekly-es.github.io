<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 🐣 🐟 Einfach und in C ++. Userver Basics - Ein Framework zum Schreiben von asynchronen Microservices 🈯️ 👩🏻‍🤝‍👨🏽 🛃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yandex.Taxi hält an der Microservice-Architektur fest. Mit der Zunahme der Anzahl von Microservices haben wir festgestellt, dass Entwickler viel Zeit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfach und in C ++. Userver Basics - Ein Framework zum Schreiben von asynchronen Microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/474438/">  Yandex.Taxi hält an der Microservice-Architektur fest.  Mit der Zunahme der Anzahl von Microservices haben wir festgestellt, dass Entwickler viel Zeit mit Boilerplate und typischen Problemen verbringen, während Lösungen nicht immer optimal funktionieren. <br><br>  Wir haben uns entschlossen, ein eigenes Framework mit C ++ 17 und Coroutinen zu erstellen.  So sieht nun ein typischer Microservice-Code aus: <br><br><pre><code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response400(); } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); trx.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre> <br>  Und hier ist, warum es extrem effektiv und schnell ist - wir werden es unter dem Schnitt erkennen. <br><a name="habracut"></a><br><h2>  Userver - Asynchron </h2><br>  Unser Team besteht nicht nur aus erfahrenen C ++ - Entwicklern: Es gibt Auszubildende, Nachwuchsentwickler und sogar Leute, die nicht besonders an das Schreiben in C ++ gewöhnt sind.  Daher basiert das Benutzerdesign auf der Benutzerfreundlichkeit.  Aufgrund unseres Datenvolumens und unserer Datenlast können wir es uns jedoch auch nicht leisten, Eisenressourcen ineffizient zu verschwenden. <br><br>  Microservices zeichnen sich durch die Erwartung von Input / Output aus: Oft wird die Antwort eines Microservices aus mehreren Antworten anderer Microservices und Datenbanken gebildet.  Das Problem der effizienten E / A-Wartezeit wird durch asynchrone Methoden und Rückrufe gelöst: Bei asynchronen Vorgängen müssen keine Ausführungsthreads erstellt werden, und dementsprechend entsteht kein großer Overhead für das Umschalten von Flows. Nur der Code ist ziemlich schwer zu schreiben und zu warten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies, Response response) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; trx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; psql::Execute(trx, statement, request.id, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response, trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx)](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; res) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = res[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LogDebug()) { GetSomeInfoFromDb([id = request.id](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> info) { LOG_DEBUG() &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; info; }); } *response = Response400{}; } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar, [row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx), response]() { trx.Commit([row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), response]() { *response = Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }); }); }); }); }</code> </pre><br>  Und hier kommen Stackfull-Coroutinen zur Rettung.  Der Benutzer des Frameworks glaubt, den üblichen synchronen Code zu schreiben: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, queries::kGetRules, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  Unter der Haube tritt jedoch ungefähr Folgendes auf: <br><br><ol><li>  TCP-Pakete werden generiert und mit einer Anforderung an die Datenbank gesendet. </li><li>  Die Ausführung der Coroutine, in der die View :: Handle-Funktion derzeit ausgeführt wird, wird angehalten. </li><li>  Wir sagen zum Kernel des Betriebssystems: "Stellen Sie die angehaltene Coroutine in die Warteschlange der Aufgaben, die zur Ausführung bereit sind, sobald genügend TCP-Pakete aus der Datenbank kommen." </li><li>  Ohne auf den vorherigen Schritt zu warten, starten wir eine weitere Coroutine, die zur Ausführung bereit ist, aus der Warteschlange. </li></ol><br>  Mit anderen Worten, die Funktion aus dem ersten Beispiel arbeitet asynchron und kommt einem solchen Code mit C ++ 20 Coroutines nahe: <br><br><pre> <code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = co_await cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = co_await psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; <span class="hljs-function"><span class="hljs-function">co_await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeInfoFromDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; co_return Response400{<span class="hljs-string"><span class="hljs-string">"NOT_OK"</span></span>, <span class="hljs-string"><span class="hljs-string">"Please provide different ID"</span></span>}; } co_await psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); co_await trx.Commit(); co_return Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre><br>  Das ist nur, dass der Benutzer nicht über co_await und co_return nachdenken muss, alles funktioniert "von alleine". <br><br>  In unserem Framework ist das Wechseln zwischen Coroutinen schneller als das Aufrufen von std :: this_thread :: yield ().  Der gesamte Microservice kostet sehr wenig Threads. <br><br>  Im Moment enthält userver asynchrone Treiber: <br>  * für Betriebssystem-Sockets; <br>  * http und https (Client und Server); <br>  * PostgreSQL; <br>  * MongoDB; <br>  * Redis; <br>  * mit Dateien arbeiten; <br>  * Timer; <br>  * Grundelemente zum Synchronisieren und Starten neuer Coroutinen. <br><br>  Der obige asynchrone Ansatz zum Lösen von E / A-gebundenen Aufgaben sollte Go-Entwicklern vertraut sein.  Im Gegensatz zu Go erhalten wir jedoch keinen Overhead für Speicher und CPU vom Garbage Collector.  Entwickler können eine reichhaltigere Sprache mit verschiedenen Containern und Hochleistungsbibliotheken verwenden, ohne an mangelnder Konsistenz, RAII oder Vorlagen zu leiden. <br><br><h2>  Userver - Komponenten </h2><br>  Ein vollwertiges Framework besteht natürlich nicht nur aus Coroutinen.  Die Aufgaben der Entwickler in Taxi sind äußerst vielfältig und erfordern jeweils eigene Tools.  Daher hat userver alles, was Sie brauchen: <br>  * für die Protokollierung; <br>  * Caching; <br>  * mit verschiedenen Datenformaten arbeiten; <br>  * mit Konfigurationen arbeiten und Konfigurationen aktualisieren, ohne den Dienst neu zu starten; <br>  * verteilte Schlösser; <br>  * Testen; <br>  * Autorisierung und Authentifizierung; <br>  * Metriken erstellen und senden; <br>  * Schreiben von REST-Handlern; <br>  + Codegenerierung und Abhängigkeitsunterstützung (in einem separaten Teil des Frameworks). <br><br><h2>  Userver - Codegenerierung </h2><br>  Kehren wir zur ersten Zeile unseres Beispiels zurück und sehen, was sich hinter Antwort und Anfrage verbirgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request&amp;&amp; request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Dependencies&amp; dependencies)</span></span></span></span>;</code> </pre><br>  Mit userver können Sie jeden Microservice schreiben, aber für unsere Microservices ist es erforderlich, dass ihre APIs dokumentiert werden (beschrieben durch Swagger-Schemata). <br><br>  Für den Griff aus dem Beispiel könnte das Prahlerdiagramm beispielsweise folgendermaßen aussehen: <br><br><pre> <code class="json hljs">paths: /some/sample/{bar}: post: description: |     Habr. summary: | ,  -   . parameters: - in: query name: id type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: header name: foo type: string enum: - foo<span class="hljs-number"><span class="hljs-number">1</span></span> - foo<span class="hljs-number"><span class="hljs-number">2</span></span> required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: path name: bar type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> responses: '<span class="hljs-number"><span class="hljs-number">200</span></span>': description: OK schema: type: object additionalProperties: <span class="hljs-literal"><span class="hljs-literal">false</span></span> required: - baz properties: baz: type: string '<span class="hljs-number"><span class="hljs-number">400</span></span>': $ref: '#/responses/ResponseCommonError'</code> </pre><br>  Nun, da der Entwickler bereits ein Schema mit einer Beschreibung der Anfragen und Antworten hat, warum nicht diese Anfragen und Antworten darauf basierend generieren?  Gleichzeitig können im Schema auch Links zu protobuf / flatbuffer / ... -Dateien angegeben werden - die Codegenerierung aus der Anfrage selbst erhält alles, validiert die Eingabedaten gemäß dem Schema und zerlegt sie in die Felder der Antwortstruktur.  Der Benutzer muss nur Funktionen in der Handle-Methode schreiben, ohne von der Boilerplate mit Anforderungsanalyse und Serialisierung der Antwort abgelenkt zu werden. <br><br>  Gleichzeitig funktioniert die Codegenerierung für Servicekunden.  Sie können angeben, dass für Ihren Dienst ein Client erforderlich ist, der nach einem solchen Schema arbeitet, und eine Klasse für die Erstellung asynchroner Anforderungen bereitstellen: <br><br><pre> <code class="cpp hljs">Request req; req.id = id; req.foo = foo; req.bar = bar; dependencies.sample_client.SomeSampleBarPost(req);</code> </pre><br>  Dieser Ansatz hat ein weiteres Plus: Immer aktuelle Dokumentation.  Wenn ein Entwickler plötzlich versucht, Parameter zu verwenden, die nicht in der Dokumentation enthalten sind, wird ein Kompilierungsfehler angezeigt. <br><br><h2>  Userver - Protokollierung </h2><br>  Wir lieben es, Protokolle zu schreiben.  Wenn Sie nur die wichtigsten Informationen protokollieren, werden mehrere Terabyte Protokolle pro Stunde ausgeführt.  Daher ist es nicht verwunderlich, dass unsere Protokollierung ihre eigenen Tricks hat: <br>  * es ist asynchron (natürlich :-)); <br>  * Wir können das langsame std :: locale und std :: ostream umgehen. <br>  * Wir können die Protokollierungsstufe im laufenden Betrieb ändern (ohne den Dienst neu zu starten). <br>  * Wir führen keinen Benutzercode aus, wenn dieser nur für die Protokollierung benötigt wird. <br><br>  Während des normalen Betriebs des Mikrodienstes wird beispielsweise die Protokollierungsstufe auf INFO und der gesamte Ausdruck festgelegt <br><br><pre> <code class="cpp hljs"> LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb();</code> </pre><br>  wird nicht berechnet.  Das Aufrufen der ressourcenintensiven Funktion GetSomeInfoFromDb () erfolgt nicht. <br><br>  Wenn der Dienst plötzlich zu "täuschen" beginnt, kann der Entwickler dem funktionierenden Dienst immer mitteilen: "Im DEBUG-Modus anmelden".  In diesem Fall werden die Einträge "ist nicht in Ordnung" in den Protokollen angezeigt. Die Funktion GetSomeInfoFromDb () wird ausgeführt. <br><br><h2>  Anstelle von Summen </h2><br>  In einem Artikel ist es unmöglich, alle Funktionen und Tricks auf einmal zu beschreiben.  Deshalb haben wir mit einer kurzen Einführung begonnen.  Schreiben Sie in die Kommentare, über welche Dinge von userver Sie interessiert wären, und lesen Sie darüber. <br><br>  Jetzt überlegen wir, ob wir das Framework in Open Source veröffentlichen sollen.  Wenn wir dies mit Ja entscheiden, erfordert die Vorbereitung des Frameworks zum Öffnen der Quelle viel Aufwand. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474438/">https://habr.com/ru/post/de474438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474424/index.html">Blended Training - was ist das und wie funktioniert es?</a></li>
<li><a href="../de474426/index.html">Die Zeichentrickserie "Mathematical Circle"</a></li>
<li><a href="../de474430/index.html">DevOpsDays Moskau - eine Konferenz, die die Community für die Community veranstaltet</a></li>
<li><a href="../de474434/index.html">Eigener Telegramm-Bot zur Verfolgung der Verfügbarkeit seiner Server in Python und Docker</a></li>
<li><a href="../de474436/index.html">GitLab beendet aufgrund von Richtlinien die Einstellung von Ingenieuren aus Russland und China</a></li>
<li><a href="../de474440/index.html">Schwierigkeiten bei der Berechnung der Einnahmen aus Abonnements mit automatischer Verlängerung in iOS-Anwendungen</a></li>
<li><a href="../de474442/index.html">Irish Life Extension Story</a></li>
<li><a href="../de474444/index.html">5 weitere gewagte Trainingsprojekte für den Entwickler (Layer, Squoosh, Rechner, Website Crawler, Music Player)</a></li>
<li><a href="../de474448/index.html">Was das Gehirn eines Studenten in der Computerwelt kann</a></li>
<li><a href="../de474450/index.html">Verwenden Sie keine lächerlich kleinen TTL mehr für DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>