<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📢 🖖🏻 🐯 Flutter. Chaves! Para que eles servem? 🌟 🧖🏻 👩🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O parâmetro- key pode ser encontrado em quase todos os construtores de widgets, mas esse parâmetro raramente é usado no desenvolvimento. Keys mantêm o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flutter. Chaves! Para que eles servem?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> O parâmetro- <code>key</code> pode ser encontrado em quase todos os construtores de widgets, mas esse parâmetro raramente é usado no desenvolvimento.  <code>Keys</code> mantêm o estado ao mover widgets na árvore de widgets.  Na prática, isso significa que eles podem ser úteis para salvar o local de rolagem ou o estado do usuário quando a coleção for alterada. </p><br><p>  Este artigo foi adaptado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeo</a> a seguir.  Se você preferir ouvir / assistir, em vez de ler, o vídeo fornecerá o mesmo material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Informações secretas sobre <code>keys</code> </h2><br><p>  Na maioria das vezes ... você não precisa de <code>keys</code> .  Em geral, não há mal em adicioná-los, mas isso também não é necessário, pois eles simplesmente ocorrem como uma nova palavra-chave ou declaração de tipo nos dois lados de uma nova variável (estou falando de você, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Mas se você achar que está adicionando, removendo ou reorganizando widgets na coleção que contêm algum estado e são do mesmo tipo, preste atenção às <code>keys</code> ! </blockquote><p>  Para demonstrar por que você precisa de <code>keys</code> ao alterar uma coleção de widgets, escrevi um aplicativo extremamente simples com dois widgets coloridos que mudam de lugar quando um botão é clicado: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  Nesta versão do aplicativo, tenho dois widgets sem estado de cores aleatórias ( <code>StatelessWidget</code> ) no widget <code>Row</code> e PositionedTiles com o estado ( <code>StatefulWidget</code> ) para armazenar a ordem dos widgets de cores.  Quando clico no botão <code>FloatingActionButton</code> na parte inferior, os widgets de cores mudam corretamente de lugar na lista: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Mas se adicionarmos estado aos nossos widgets de cores (torná-los <code>StatefulWidget</code> ) e armazenar a cor neles, quando clicarmos no botão, parecerá que nada está acontecendo: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Como explicação: o código acima é incorreto, pois não mostra a troca de cores quando o usuário clica no botão.  Para corrigir esse erro, você precisa adicionar o parâmetro <code>key</code> aos widgets coloridos <code>StatefulWidget</code> e, em seguida, os widgets serão trocados conforme desejado: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Mas isso só é necessário se você tiver widgets com o estado na subárvore que você está alterando.  Se a subárvore inteira do widget em sua coleção não tiver estado, nenhuma chave será necessária. <br>  Lá vai você!  Em suma, tudo o que você precisa saber para usar as <code>keys</code> no <code>Flutter</code> .  Mas se você quiser se aprofundar um pouco no que está acontecendo ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Entendendo por que as <code>keys</code> às vezes <code>keys</code> necessárias </h2><br><p>  Você ainda está aqui, certo?  Bem, então chegue mais perto para descobrir a verdadeira natureza das árvores e widgets de elementos para se tornar um Mago Flutter!  Wahahaha!  Haha  Haha  Desculpe. </p><br><p>  Como você sabe, dentro de cada widget, o Flutter cria o elemento correspondente.  Assim como o Flutter cria uma árvore de widgets, ele também cria uma árvore de elementos (ElementTree).  O ElementTree é extremamente simples, contém apenas as informações de tipo de cada widget e um link para elementos filho.  Você pode pensar em ElementTree como o esqueleto do seu aplicativo Flutter.  Ele mostra a estrutura do seu aplicativo, mas todas as informações adicionais podem ser encontradas no link para o widget de origem. </p><br><p>  O widget de linha no exemplo acima contém um conjunto de slots ordenados para cada um de seus filhos.  Quando reordenamos os widgets de cores em Row, o Flutter percorre o ElementTree para verificar se a estrutura do esqueleto do aplicativo é a mesma. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  A validação começa com um RowElement e depois passa para os filhos.  O ElementTree verifica se o novo widget tem o mesmo tipo e <code>key</code> que o antigo e, se houver, o elemento atualiza seu link para o novo widget.  Na versão sem estado do código, os widgets não têm <code>key</code> , portanto o Flutter simplesmente verifica apenas o tipo.  (Se houver muita informação de cada vez, consulte o gráfico animado acima.) </p><br><p>  Abaixo ElementTree para widgets de estado parece um pouco diferente.  Existem widgets e elementos, como antes, mas também existem alguns objetos de estado para widgets, e as informações de cores são armazenadas neles, e não nos próprios widgets. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  No caso de widgets coloridos <code>StatefulWidget</code> sem <code>key</code> , quando altero a ordem de dois widgets, o Flutter percorre o ElementTree, verifica o tipo de RowWidget e atualiza o link.  Em seguida, o elemento do widget de cores verifica se o widget correspondente é do mesmo tipo e atualiza o link.  O mesmo acontece com o segundo widget.  Como o Flutter usa o ElementTree e seu estado correspondente para determinar o que realmente será exibido no seu dispositivo, do nosso ponto de vista, parece que os widgets não foram trocados! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  Na versão fixa do código em widgets coloridos com estado no construtor, defini a propriedade <code>key</code> .  Agora, se alterarmos os widgets em <code>Row</code> , por tipo eles corresponderão como antes, mas os valores- <code>key</code> do widget de cores e o elemento correspondente no ElementTree serão diferentes.  Isso faz com que o Flutter desative esses elementos dos widgets de cores e remova os links para eles no ElementTree, começando pelo primeiro, que não corresponde à <code>key</code> . </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Em seguida, o Flutter pesquisa os widgets no elemento <code>Row</code> no ElementTree com a <code>key</code> correspondente.  Se corresponder, ele adiciona um link ao elemento do widget.  Flutter faz para cada criança sem um link.  Agora o Flutter exibirá o que esperamos, os widgets de cores mudarão de lugar quando eu clicar no botão. </p><br><p>  Portanto, as <code>keys</code> são úteis se você alterar a ordem ou o número de widgets com o estado na coleção.  Neste exemplo, salvei a cor.  No entanto, muitas vezes a condição não é tão óbvia.  Reproduzindo uma animação, exibindo a entrada do usuário e percorrendo um local - tudo tem um estado. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  Quando devo usar <code>keys</code> ? </h2><br><p>  Resposta curta: se você precisar adicionar <code>keys</code> ao aplicativo, adicione-as na parte superior da subárvore do widget com o estado que deseja salvar. </p><br><p>  Um erro comum que vi é que as pessoas pensam que precisam definir <code>key</code> apenas para o primeiro widget com estado, mas há nuances.  Não acredita em mim?  Para mostrar em que problemas podemos estar, envolvi meus widgets de cores nos widgets <code>Padding</code> , deixando as teclas para os widgets de cores. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Agora, com o toque de um botão, os widgets ficam com cores completamente aleatórias! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  É assim que a árvore de widgets e o ElementTree se parecem com os widgets <code>Padding</code> adicionados: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Quando mudamos as posições dos widgets filhos, o algoritmo de correspondência entre elementos e widgets parece um nível na árvore de elementos.  No diagrama, os filhos das crianças são escurecidos para que nada desvie o interesse do primeiro nível.  Nesse nível, tudo corresponde corretamente. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  No segundo nível, o Flutter percebe que a <code>key</code> elemento de cor não corresponde à <code>key</code> widget; portanto, ele desativa esse elemento, descartando-o e removendo todos os links para ele.  <code>keys</code> que usamos neste exemplo são as <code>LocalKeys</code> .  Isso significa que, ao combinar um widget com elementos, o Flutter procura <code>keys</code> apenas em um determinado nível da árvore. </p><br><p>  Como ele não consegue encontrar o elemento do widget de cores nesse nível com a <code>key</code> correspondente, ele cria um novo e inicializa um novo estado, deixando o widget laranja nesse caso! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Se definirmos <code>keys</code> para os widgets <code>Padding</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  O Flutter percebe o problema e atualiza os links corretamente, como no exemplo anterior.  A ordem no universo é restaurada. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  Que tipo de <code>Key</code> devo usar? </h2><br><p>  As APIs do Flutter nos deram a opção de várias classes de <code>Key</code> .  O tipo de <code>key</code> você deve usar depende de qual é o recurso distintivo dos elementos que precisam de <code>keys</code> .  Veja as informações que você armazena nos respectivos widgets. </p><br><p>  Considere o seguinte aplicativo de tarefas [1], onde você pode alterar a ordem dos itens na lista de tarefas com base na prioridade e, quando terminar, pode excluí-los. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  Nesse caso, podemos esperar que o texto do parágrafo sobre a implementação seja permanente e exclusivo.  Nesse caso, esse provavelmente é um bom candidato para a <code>ValueKey</code> , onde o texto é "value". </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objectkey</strong> <br>  Como alternativa, você pode ter o aplicativo Catálogo de Endereços, que lista informações sobre cada usuário.  Nesse caso, cada widget filho armazena uma combinação mais complexa de dados.  Qualquer um dos campos individuais, por exemplo, nome ou data de nascimento, pode coincidir com outra entrada, mas a combinação é exclusiva.  Nesse caso, o <code>ObjectKey</code> provavelmente é o melhor ajuste. </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Se você tiver vários widgets na coleção com o mesmo valor ou se realmente quiser garantir que cada widget seja diferente de todos os outros, poderá usar o <code>UniqueKey</code> .  Usei o <code>UniqueKey</code> no aplicativo de exemplo para alternar cores, porque não tínhamos outros dados constantes que seriam armazenados em nossos widgets e não sabíamos qual a cor que o widget teria ao ser criado. </p><br><p>  No entanto, uma coisa que você <strong>não deseja</strong> usar como <code>key</code> é um número aleatório.  Sempre que um widget é criado, um novo número aleatório será gerado e você perderá a consistência entre os quadros.  Nesse cenário, você não pode usar <code>keys</code> ! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> são <code>keys</code> especializadas que contêm o estado atual da rolagem para que o aplicativo possa salvá-lo para uso posterior. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  Há duas opções para usar as <code>GlobalKeys</code> : elas permitem que os widgets alterem os pais em qualquer lugar do aplicativo sem perder o estado e podem ser usadas para acessar informações sobre outro widget em uma parte completamente diferente da árvore de widgets.  Como um exemplo do primeiro cenário, você pode imaginar que deseja mostrar o mesmo widget em duas telas diferentes, mas com o mesmo estado, para que os dados do widget sejam salvos, você usará o <code>GlobalKey</code> .  No segundo caso, pode surgir uma situação quando você precisa verificar a senha, mas não deseja compartilhar informações de status com outros widgets na árvore.  <code>GlobalKeys</code> também podem ser úteis para testes, usando a <code>key</code> para acessar um widget específico e solicitar informações sobre seu status. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  Freqüentemente (mas nem sempre!), As <code>GlobalKeys</code> pouco como variáveis ​​globais.  Geralmente, eles podem ser substituídos por <code>InheritedWidgets</code> ou algo como Redux, ou o modelo BLoC. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Breve conclusão </h2><br><p>  Em geral, use <code>Keys</code> se desejar manter o estado entre as subárvores do widget.  Isso geralmente acontece quando você altera a coleção de widgets do mesmo tipo.  Coloque a <code>key</code> na parte superior da subárvore do widget que você deseja salvar e selecione o tipo de <code>key</code> base nos dados armazenados no widget. </p><br><p>  Parabéns, você está agora no caminho de se tornar um Flutter Mage!  Oh, eu disse um mágico?  Eu quis dizer o mágico [2], como quem escreve o código fonte do aplicativo ... o que é quase tão bom.  quase. </p><br><p>  [1] Inspiração para escrever o código do aplicativo de tarefas pendentes recebido aqui <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] O autor usa a palavra <code>sorcerer</code> e depois adiciona uma carta extra a ele antes do <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446050/">https://habr.com/ru/post/pt446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446038/index.html">Um pequeno guia sobre a criação de oráculos, deuses dos carros e erros de segunda ordem</a></li>
<li><a href="../pt446040/index.html">Confissão Full Stack: Profissão, Religião, Sonhos</a></li>
<li><a href="../pt446042/index.html">DJI Mavic 2 Pro após seis meses de uso</a></li>
<li><a href="../pt446046/index.html">A expansão do universo é a maior falácia da história da ciência</a></li>
<li><a href="../pt446048/index.html">A união do Arduino e o processador clássico</a></li>
<li><a href="../pt446052/index.html">Criando a voz e o tom do seu produto</a></li>
<li><a href="../pt446054/index.html">Backup pronto: destruindo mitos do feriado</a></li>
<li><a href="../pt446056/index.html">Uma maneira simples de conversar com seu site</a></li>
<li><a href="../pt446058/index.html">Como criar SDN - Oito ferramentas de código aberto</a></li>
<li><a href="../pt446060/index.html">Síntese de altos sonhos moleculares</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>