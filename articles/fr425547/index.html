<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¶ ‚û°Ô∏è üë• Qt: dessin bas√© sur des graphiques vectoriels üïí üåÑ üì£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt fournit au programmeur des fonctionnalit√©s tr√®s riches, mais l'ensemble de widgets est limit√©. Si aucun des √©l√©ments disponibles ne convient, vous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: dessin bas√© sur des graphiques vectoriels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt fournit au programmeur des fonctionnalit√©s tr√®s riches, mais l'ensemble de widgets est limit√©.  Si aucun des √©l√©ments disponibles ne convient, vous devez dessiner quelque chose de votre choix.  La mani√®re la plus simple - d'utiliser des images pr√™tes √† l'emploi - pr√©sente de s√©rieux inconv√©nients: la n√©cessit√© de stocker des images dans un fichier ou des ressources, des probl√®mes d'√©volutivit√© et de portabilit√© des formats d'image.  Ce qui suit d√©crit l'utilisation des principes des graphiques vectoriels sans utiliser les images vectorielles r√©elles. </p><a name="habracut"></a><br><h2 id="preambula">  Pr√©ambule </h2><br><p>  Tout a commenc√© avec le fait qu'une fois qu'une indication de signes √† un bit √©tait n√©cessaire.  Certaines applications re√ßoivent des donn√©es sur un port, le package doit √™tre d√©mont√© et affich√© √† l'√©cran.  Ce serait bien en m√™me temps d'imiter le tableau de bord familier.  Pour afficher les donn√©es num√©riques, Qt propose ¬´pr√™te √† l'emploi¬ª la classe QLCDNumber, similaire aux indicateurs familiers √† sept segments, mais quelque chose n'est pas visible dans les lampes simples. </p><br><p>  L'utilisation de drapeaux (ce sont des cases √† cocher) et de commutateurs (ce sont des boutons radio) √† ces fins est mauvaise, et voici une liste de raisons: </p><br><ul><li>  C'est faux s√©mantiquement.  Boutons - ce sont des boutons qui sont destin√©s √† la saisie de l'utilisateur et non √† lui montrer quoi que ce soit. </li><li>  Cela implique la seconde: l'utilisateur s'efforce de pousser sur ces boutons.  Si, en m√™me temps, la mise √† jour des informations n'est pas particuli√®rement rapide, l'indication s'allongera et l'utilisateur signalera un programme d√©fectueux en riant m√©chamment. </li><li>  Si vous verrouillez le bouton pour appuyer sur (setEnabled (false)), il devient alors gris moche.  Je me souviens qu'√† Delphi, dans la r√©gion de la version 6, il y avait une telle feinte avec des oreilles: on pouvait mettre un drapeau sur le panneau et d√©sactiver la disponibilit√© du panneau, pas le drapeau, alors le drapeau n'√©tait ni gris ni actif.  Cette astuce ne fonctionne pas ici. </li><li>  Les boutons ont le focus d'entr√©e.  Par cons√©quent, s'il y a des √©l√©ments d'entr√©e dans la fen√™tre et que l'utilisateur les parcourt √† l'aide de la touche Tab, il devra parcourir les √©l√©ments de sortie, ce qui est g√™nant et laid. </li><li>  En fin de compte, ces boutons sont tout simplement esth√©tiques, surtout √† c√¥t√© du sept-segment. </li></ul><br><p>  Conclusion: vous devez dessiner vous-m√™me une ampoule. </p><br><h2 id="muki-vybora">  Farine de choix </h2><br><p>  J'ai d'abord cherch√© des solutions toutes faites.  En ce temps lointain, quand j'ai utilis√© Delphi, vous ne pouviez trouver qu'une quantit√© gigantesque de composants finis, √† la fois d'entreprises s√©rieuses et de fabricants amateurs.  Qt a beaucoup de mal avec √ßa.  QWT comporte certains √©l√©ments, mais pas cela.  Je n'ai pas du tout vu d'amateurisme.  Probablement, si vous creusez correctement sur Github, vous pouvez trouver quelque chose, mais je le ferai probablement plus rapidement moi-m√™me. </p><br><p>  La premi√®re chose qui s'est sugg√©r√©e par rapport √† celle faite maison √©tait d'utiliser deux fichiers d'images avec des images de la lumi√®re allum√©es et √©teintes.  Mauvais: </p><br><ul><li>  Il faut trouver de bonnes images (ou dessiner, mais je ne suis pas artiste); </li><li>  La question de principe est la suivante: attacher n'est pas bon, m√™me des images, m√™me couch√© sous vos pieds; </li><li>  Ils doivent √™tre stock√©s quelque part.  Les fichiers sont tr√®s mauvais: effac√©s accidentellement - et il n'y a pas de boutons.  Les ressources sont meilleures, mais je n'ai pas non plus l'impression de pouvoir m'en sortir; </li><li>  Aucune √©volutivit√©; </li><li>  La personnalisation (couleurs, par exemple) n'est obtenue qu'en ajoutant des fichiers.  Autrement dit, exigeant en ressources et rigide. </li></ul><br><p>  La deuxi√®me chose qui d√©coule de la premi√®re est d'utiliser des images vectorielles au lieu d'images.  De plus, Qt peut rendre SVG.  Ici, c'est d√©j√† un peu plus facile avec la recherche de l'image elle-m√™me: il y a beaucoup de le√ßons sur les graphiques vectoriels dans le r√©seau, vous pouvez trouver quelque chose de plus ou moins adapt√© et l'adapter √† vos besoins.  Mais la question reste de stockage et de personnalisation, et le rendu n'est pas gratuit pour les ressources.  Des sous, bien s√ªr, mais quand m√™me ... </p><br><p>  Et le troisi√®me d√©coule du second: vous pouvez utiliser les principes des graphiques vectoriels pour des images auto-dessin√©es!  Un fichier image vectorielle sous forme de texte indique quoi et comment dessiner.  Je peux sp√©cifier le m√™me code √† l'aide de didacticiels vectoriels.  Heureusement, l'objet QPainter dispose des outils n√©cessaires: un stylo, un pinceau, un d√©grad√© et des primitives de dessin, voire un remplissage de texture.  Oui, les outils sont loin de tout: il n'y a pas de masques, de modes de fusion, mais absolument aucun photor√©alisme n'est requis. </p><br><p>  J'ai cherch√© quelques exemples sur le net.  Il a suivi la premi√®re le√ßon qui a suivi: ¬´Nous dessinons un bouton dans l'√©diteur graphique d'Inkscape¬ª sur le site ¬´C'est facile √† dessiner¬ª.  Le bouton de cette le√ßon ressemble beaucoup plus √† une ampoule qu'√† un bouton, ce qui me convient parfaitement.  Je fais un brouillon: au lieu d'Inkscape, un projet dans Qt. </p><br><h2 id="proba-pera">  Test de plumes </h2><br><p>  Je cr√©e un nouveau projet.  Je choisis le nom du projet (car je veux faire quelque chose comme une LED RGB) et le chemin vers celui-ci.  Je choisis la classe de base QWidget et le nom RgbLed, je refuse de cr√©er un fichier formulaire.  Le projet par d√©faut apr√®s le lancement fait une fen√™tre vide, il est toujours sans int√©r√™t. </p><br><h3 id="podgotovka-k-risovaniyu">  Pr√©paration au dessin </h3><br><p>  Il y a un blanc.  Vous devez maintenant obtenir les membres priv√©s de la classe, qui d√©termineront la g√©om√©trie de l'image.  Un avantage essentiel des graphiques vectoriels est leur √©volutivit√©, donc il devrait y avoir un minimum de nombres constants, et ils ne fixent que les proportions.  Les dimensions seront recalcul√©es dans l'√©v√©nement resizeEvent (), qui devra √™tre red√©fini. </p><br><p>  Dans le didacticiel de dessin utilis√©, les dimensions sont sp√©cifi√©es en pixels au fur et √† mesure.  Je dois d√©terminer √† l'avance ce que j'utiliserai et comment recompter. </p><br><p>  Une image dessin√©e se compose des √©l√©ments suivants: </p><br><ul><li>  bague ext√©rieure (inclin√©e vers l'ext√©rieur, partie de la jante convexe) </li><li>  bague int√©rieure (inclin√©e vers l'int√©rieur) </li><li>  Bo√Ætier de lampe √† LED, "verre" </li><li>  ombre sur le bord du verre </li><li>  haut point culminant </li><li>  √©vasement en bas </li></ul><br><p>  Les cercles concentriques, c'est-√†-dire tout sauf l'√©blouissement, sont d√©termin√©s par la position du centre et du rayon.  L'√©blouissement est d√©termin√© par le centre, la largeur et la hauteur, et la position des X centres d'√©blouissement co√Øncide avec la position du centre X de l'image enti√®re. </p><br><p>  Pour calculer les √©l√©ments de la g√©om√©trie, vous devez d√©terminer laquelle est la plus grande - la largeur ou la hauteur, car l'ampoule est ronde et doit s'ins√©rer dans un carr√© avec un c√¥t√© √©gal √† la plus petite des deux dimensions.  J'ajoute donc les membres priv√©s correspondants au fichier d'en-t√™te. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Ensuite, je red√©finis la fonction prot√©g√©e qui est appel√©e lorsque le widget est redimensionn√©. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Ici, le c√¥t√© du carr√© dans lequel l'ampoule est inscrite est calcul√©, le centre de ce carr√©, le rayon de la jante occupant la zone maximale possible, la largeur de la jante, dont la partie ext√©rieure doit √™tre 1/10 du diam√®tre et le 1/14 int√©rieur.  Ensuite, la position de l'√©blouissement, qui sont situ√©s au milieu des rayons sup√©rieur et inf√©rieur, est calcul√©e, la largeur et la hauteur sont s√©lectionn√©es √† l'≈ìil nu. </p><br><p>  De plus, dans les champs prot√©g√©s, j'ajouterai imm√©diatement un ensemble de couleurs √† utiliser. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  Par les noms, il est √† peu pr√®s clair que ce sont les couleurs de l'ampoule, la partie claire de l'ombre, la partie sombre de l'ombre, les trois couleurs de l'ombre annulaire autour de l'ampoule et les couleurs des gradients d'√©blouissement. </p><br><p>  Les couleurs doivent √™tre initialis√©es, je vais donc compl√©ter la pi√®ce du designer. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  N'oubliez pas non plus d'ins√©rer dans le fichier d'en-t√™te les inclusions de classes qui seront n√©cessaires lors du dessin. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Ce code se compile avec succ√®s, mais rien n'a chang√© dans la fen√™tre du widget.  Il est temps de commencer √† dessiner. </p><br><h3 id="risovanie">  Dessin </h3><br><p>  J'entre dans une fonction ferm√©e </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  et red√©finir la fonction prot√©g√©e </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  L'√©v√©nement redessiner provoquera le dessin r√©el, auquel la couleur du "verre" est transmise comme param√®tre. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  Jusqu'√† pr√©sent.  Et nous commen√ßons √† remplir progressivement la fonction de dessin. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Tout d'abord, un objet d'artiste est cr√©√©, qui sera engag√© dans le dessin.  Ensuite, un crayon est cr√©√© qui est n√©cessaire pour qu'il n'y ait pas de crayon: dans cette image, le trait de contour n'est pas simplement n√©cessaire, mais pas du tout n√©cessaire. </p><br><p>  Ensuite, le premier cercle est trac√© approximativement conform√©ment √† la le√ßon sur les graphiques vectoriels: un grand cercle, rempli d'un d√©grad√© radial.  Le d√©grad√© a un point d'ancrage clair en haut, mais pas au bord m√™me, et un point sombre en bas, mais pas non plus au bord m√™me.  Un pinceau est cr√©√© sur la base du d√©grad√©, ce peintre au pinceau peint un cercle (c'est-√†-dire une ellipse inscrite dans un carr√©).  Il s'av√®re qu'un tel code </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  L'environnement met l'accent sur le param√®tre de couleur de la fonction drawLed car il n'est pas utilis√©.  Laissez-le tol√©rer, il n'est pas encore n√©cessaire, mais il en aura bient√¥t besoin.  Le projet lanc√© produit le r√©sultat suivant: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Ajoutez un autre lot de code. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Presque le m√™me cercle, mais de taille plus petite et √† l'envers.  Nous obtenons l'image suivante: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Enfin, vous avez besoin de la couleur du verre: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Ici, en utilisant la fonction plus sombre de la couleur transmise, la m√™me couleur est obtenue, mais plus sombre, pour organiser le d√©grad√©.  Coefficient 120 s√©lectionn√© √† l'≈ìil.  Voici le r√©sultat: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Ajoutez une ombre annulaire autour du verre.  Cela se fait dans la le√ßon sur les graphiques vectoriels, et cela devrait ajouter du volume et du r√©alisme: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Il y a un d√©grad√© en trois √©tapes, de sorte que l'ombre est plus √©paisse jusqu'au bord et p√¢lit vers le centre.  Il se pr√©sente comme ceci: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Ajoutez des surbrillances √† la fois.  La surbrillance sup√©rieure, contrairement √† la partie inf√©rieure (et √† tous les autres √©l√©ments), est un d√©grad√© lin√©aire.  L'artiste de moi est moyen, je prends ma parole pour l'auteur de la le√ßon.  Peut-√™tre y a-t-il une part de v√©rit√© √† cela, je ne vais pas exp√©rimenter avec diff√©rents types de d√©grad√©s. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  En fait, c'est tout, une ampoule pr√™te √† l'emploi, comme sur KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  La visibilit√© de l'√©blouissement et du renflement du verre est affect√©e par la couleur, ou plut√¥t par son obscurit√©.  Il peut √™tre judicieux d'ajouter un ajustement pour la luminosit√© de l'√©blouissement et le coefficient de variation dans la fonction plus sombre en fonction de l'obscurit√©, mais c'est du perfectionnisme, je pense. </p><br><p>  Voici un exemple d'utilisation dans une fen√™tre de programme. </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Choyer </h3><br><p>  Pour le plaisir, vous pouvez jouer avec des fleurs.  Par exemple, remplacer un √©v√©nement de clic de souris prot√©g√© </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  de cette fa√ßon: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  sans oublier d'ajouter des √©v√©nements de souris √† l'en-t√™te: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Maintenant, un clic de souris sur le composant changera la couleur de l'ampoule: rouge, vert, bleu, gris et une lumi√®re al√©atoire de la lampe. </p><br><h2 id="epilog">  √âpilogue </h2><br><p>  Quant au dessin, c‚Äôest tout.  Et le widget devrait ajouter des fonctionnalit√©s.  Dans mon cas, j'ai ajout√© un champ bool√©en ¬´use state¬ª, un autre champ bool√©en qui d√©finit l'√©tat On ou Off et les couleurs par d√©faut de ces √©tats, ainsi que des getters et setters ouverts pour tout cela. Ces champs sont utilis√©s dans la fonction paintEvent () pour s√©lectionner la couleur transmise √† drawLed () en tant que param√®tre. Par cons√©quent, vous pouvez d√©sactiver l'utilisation des √©tats et d√©finir l'ampoule sur n'importe quelle couleur, ou activer les √©tats et activer ou d√©sactiver l'ampoule en fonction des √©v√©nements. Il est particuli√®rement pratique de faire du s√©lecteur d'√©tat un emplacement ouvert et conjoint  que ce soit avec le signal qui doit √™tre surveill√©e. </p><br><p>  L'utilisation de mousePressEvent d√©montre qu'un widget peut √™tre cr√©√© non seulement un indicateur, mais aussi un bouton, ce qui le rend enfonc√©, rel√¢ch√©, pli√©, tordu, color√© et tout ce que vous voulez pour les √©v√©nements de pointage, de clic et de rel√¢chement. </p><br><p>  Mais ce n'est plus fondamental.  L'objectif √©tait de montrer o√π vous pouvez prendre des mod√®les lorsque vous dessinez vos propres widgets et comment ce dessin est facile √† impl√©menter sans utiliser d'images raster ou vectorielles, dans des ressources ou des fichiers. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425547/">https://habr.com/ru/post/fr425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425531/index.html">Refroidissement liquide des freins. Options de d√©veloppement du syst√®me</a></li>
<li><a href="../fr425533/index.html">Comment travailler dans le cloud: de la v√©rification de la fiabilit√© d'un datacenter √† la gestion d'une infrastructure virtuelle</a></li>
<li><a href="../fr425537/index.html">Comment combiner Java, Js et graphiques avec de l'art, ou l'histoire de la cr√©ation d'un th√©√¢tre interactif</a></li>
<li><a href="../fr425541/index.html">Comment contourner rapidement et sans puces inutiles l'immuabilit√© de l'adresse du capteur HTU21</a></li>
<li><a href="../fr425545/index.html">Vous devriez penser √† des heures de pratique.</a></li>
<li><a href="../fr425549/index.html">Les stocks de Supermicro se brisent au milieu d'une enqu√™te sur le d√©ploiement d'une puce d'espionnage chinoise</a></li>
<li><a href="../fr425551/index.html">Qui devrait recevoir de l'argent de la vente d'une ≈ìuvre d'art cr√©√©e par AI?</a></li>
<li><a href="../fr425553/index.html">Ce que le comte de Monte-Cristo peut nous dire sur la cybers√©curit√©</a></li>
<li><a href="../fr425555/index.html">Charles Nutter sur les langages dynamiques dans la JVM sur jug.msk.ru</a></li>
<li><a href="../fr425557/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 10: Ex√©cution symbolique, partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>