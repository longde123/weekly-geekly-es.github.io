<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧦 ➡️ 👥 Qt: dessin basé sur des graphiques vectoriels 🕒 🌄 📣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt fournit au programmeur des fonctionnalités très riches, mais l'ensemble de widgets est limité. Si aucun des éléments disponibles ne convient, vous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: dessin basé sur des graphiques vectoriels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt fournit au programmeur des fonctionnalités très riches, mais l'ensemble de widgets est limité.  Si aucun des éléments disponibles ne convient, vous devez dessiner quelque chose de votre choix.  La manière la plus simple - d'utiliser des images prêtes à l'emploi - présente de sérieux inconvénients: la nécessité de stocker des images dans un fichier ou des ressources, des problèmes d'évolutivité et de portabilité des formats d'image.  Ce qui suit décrit l'utilisation des principes des graphiques vectoriels sans utiliser les images vectorielles réelles. </p><a name="habracut"></a><br><h2 id="preambula">  Préambule </h2><br><p>  Tout a commencé avec le fait qu'une fois qu'une indication de signes à un bit était nécessaire.  Certaines applications reçoivent des données sur un port, le package doit être démonté et affiché à l'écran.  Ce serait bien en même temps d'imiter le tableau de bord familier.  Pour afficher les données numériques, Qt propose «prête à l'emploi» la classe QLCDNumber, similaire aux indicateurs familiers à sept segments, mais quelque chose n'est pas visible dans les lampes simples. </p><br><p>  L'utilisation de drapeaux (ce sont des cases à cocher) et de commutateurs (ce sont des boutons radio) à ces fins est mauvaise, et voici une liste de raisons: </p><br><ul><li>  C'est faux sémantiquement.  Boutons - ce sont des boutons qui sont destinés à la saisie de l'utilisateur et non à lui montrer quoi que ce soit. </li><li>  Cela implique la seconde: l'utilisateur s'efforce de pousser sur ces boutons.  Si, en même temps, la mise à jour des informations n'est pas particulièrement rapide, l'indication s'allongera et l'utilisateur signalera un programme défectueux en riant méchamment. </li><li>  Si vous verrouillez le bouton pour appuyer sur (setEnabled (false)), il devient alors gris moche.  Je me souviens qu'à Delphi, dans la région de la version 6, il y avait une telle feinte avec des oreilles: on pouvait mettre un drapeau sur le panneau et désactiver la disponibilité du panneau, pas le drapeau, alors le drapeau n'était ni gris ni actif.  Cette astuce ne fonctionne pas ici. </li><li>  Les boutons ont le focus d'entrée.  Par conséquent, s'il y a des éléments d'entrée dans la fenêtre et que l'utilisateur les parcourt à l'aide de la touche Tab, il devra parcourir les éléments de sortie, ce qui est gênant et laid. </li><li>  En fin de compte, ces boutons sont tout simplement esthétiques, surtout à côté du sept-segment. </li></ul><br><p>  Conclusion: vous devez dessiner vous-même une ampoule. </p><br><h2 id="muki-vybora">  Farine de choix </h2><br><p>  J'ai d'abord cherché des solutions toutes faites.  En ce temps lointain, quand j'ai utilisé Delphi, vous ne pouviez trouver qu'une quantité gigantesque de composants finis, à la fois d'entreprises sérieuses et de fabricants amateurs.  Qt a beaucoup de mal avec ça.  QWT comporte certains éléments, mais pas cela.  Je n'ai pas du tout vu d'amateurisme.  Probablement, si vous creusez correctement sur Github, vous pouvez trouver quelque chose, mais je le ferai probablement plus rapidement moi-même. </p><br><p>  La première chose qui s'est suggérée par rapport à celle faite maison était d'utiliser deux fichiers d'images avec des images de la lumière allumées et éteintes.  Mauvais: </p><br><ul><li>  Il faut trouver de bonnes images (ou dessiner, mais je ne suis pas artiste); </li><li>  La question de principe est la suivante: attacher n'est pas bon, même des images, même couché sous vos pieds; </li><li>  Ils doivent être stockés quelque part.  Les fichiers sont très mauvais: effacés accidentellement - et il n'y a pas de boutons.  Les ressources sont meilleures, mais je n'ai pas non plus l'impression de pouvoir m'en sortir; </li><li>  Aucune évolutivité; </li><li>  La personnalisation (couleurs, par exemple) n'est obtenue qu'en ajoutant des fichiers.  Autrement dit, exigeant en ressources et rigide. </li></ul><br><p>  La deuxième chose qui découle de la première est d'utiliser des images vectorielles au lieu d'images.  De plus, Qt peut rendre SVG.  Ici, c'est déjà un peu plus facile avec la recherche de l'image elle-même: il y a beaucoup de leçons sur les graphiques vectoriels dans le réseau, vous pouvez trouver quelque chose de plus ou moins adapté et l'adapter à vos besoins.  Mais la question reste de stockage et de personnalisation, et le rendu n'est pas gratuit pour les ressources.  Des sous, bien sûr, mais quand même ... </p><br><p>  Et le troisième découle du second: vous pouvez utiliser les principes des graphiques vectoriels pour des images auto-dessinées!  Un fichier image vectorielle sous forme de texte indique quoi et comment dessiner.  Je peux spécifier le même code à l'aide de didacticiels vectoriels.  Heureusement, l'objet QPainter dispose des outils nécessaires: un stylo, un pinceau, un dégradé et des primitives de dessin, voire un remplissage de texture.  Oui, les outils sont loin de tout: il n'y a pas de masques, de modes de fusion, mais absolument aucun photoréalisme n'est requis. </p><br><p>  J'ai cherché quelques exemples sur le net.  Il a suivi la première leçon qui a suivi: «Nous dessinons un bouton dans l'éditeur graphique d'Inkscape» sur le site «C'est facile à dessiner».  Le bouton de cette leçon ressemble beaucoup plus à une ampoule qu'à un bouton, ce qui me convient parfaitement.  Je fais un brouillon: au lieu d'Inkscape, un projet dans Qt. </p><br><h2 id="proba-pera">  Test de plumes </h2><br><p>  Je crée un nouveau projet.  Je choisis le nom du projet (car je veux faire quelque chose comme une LED RGB) et le chemin vers celui-ci.  Je choisis la classe de base QWidget et le nom RgbLed, je refuse de créer un fichier formulaire.  Le projet par défaut après le lancement fait une fenêtre vide, il est toujours sans intérêt. </p><br><h3 id="podgotovka-k-risovaniyu">  Préparation au dessin </h3><br><p>  Il y a un blanc.  Vous devez maintenant obtenir les membres privés de la classe, qui détermineront la géométrie de l'image.  Un avantage essentiel des graphiques vectoriels est leur évolutivité, donc il devrait y avoir un minimum de nombres constants, et ils ne fixent que les proportions.  Les dimensions seront recalculées dans l'événement resizeEvent (), qui devra être redéfini. </p><br><p>  Dans le didacticiel de dessin utilisé, les dimensions sont spécifiées en pixels au fur et à mesure.  Je dois déterminer à l'avance ce que j'utiliserai et comment recompter. </p><br><p>  Une image dessinée se compose des éléments suivants: </p><br><ul><li>  bague extérieure (inclinée vers l'extérieur, partie de la jante convexe) </li><li>  bague intérieure (inclinée vers l'intérieur) </li><li>  Boîtier de lampe à LED, "verre" </li><li>  ombre sur le bord du verre </li><li>  haut point culminant </li><li>  évasement en bas </li></ul><br><p>  Les cercles concentriques, c'est-à-dire tout sauf l'éblouissement, sont déterminés par la position du centre et du rayon.  L'éblouissement est déterminé par le centre, la largeur et la hauteur, et la position des X centres d'éblouissement coïncide avec la position du centre X de l'image entière. </p><br><p>  Pour calculer les éléments de la géométrie, vous devez déterminer laquelle est la plus grande - la largeur ou la hauteur, car l'ampoule est ronde et doit s'insérer dans un carré avec un côté égal à la plus petite des deux dimensions.  J'ajoute donc les membres privés correspondants au fichier d'en-tête. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Ensuite, je redéfinis la fonction protégée qui est appelée lorsque le widget est redimensionné. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Ici, le côté du carré dans lequel l'ampoule est inscrite est calculé, le centre de ce carré, le rayon de la jante occupant la zone maximale possible, la largeur de la jante, dont la partie extérieure doit être 1/10 du diamètre et le 1/14 intérieur.  Ensuite, la position de l'éblouissement, qui sont situés au milieu des rayons supérieur et inférieur, est calculée, la largeur et la hauteur sont sélectionnées à l'œil nu. </p><br><p>  De plus, dans les champs protégés, j'ajouterai immédiatement un ensemble de couleurs à utiliser. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  Par les noms, il est à peu près clair que ce sont les couleurs de l'ampoule, la partie claire de l'ombre, la partie sombre de l'ombre, les trois couleurs de l'ombre annulaire autour de l'ampoule et les couleurs des gradients d'éblouissement. </p><br><p>  Les couleurs doivent être initialisées, je vais donc compléter la pièce du designer. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  N'oubliez pas non plus d'insérer dans le fichier d'en-tête les inclusions de classes qui seront nécessaires lors du dessin. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Ce code se compile avec succès, mais rien n'a changé dans la fenêtre du widget.  Il est temps de commencer à dessiner. </p><br><h3 id="risovanie">  Dessin </h3><br><p>  J'entre dans une fonction fermée </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  et redéfinir la fonction protégée </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  L'événement redessiner provoquera le dessin réel, auquel la couleur du "verre" est transmise comme paramètre. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  Jusqu'à présent.  Et nous commençons à remplir progressivement la fonction de dessin. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Tout d'abord, un objet d'artiste est créé, qui sera engagé dans le dessin.  Ensuite, un crayon est créé qui est nécessaire pour qu'il n'y ait pas de crayon: dans cette image, le trait de contour n'est pas simplement nécessaire, mais pas du tout nécessaire. </p><br><p>  Ensuite, le premier cercle est tracé approximativement conformément à la leçon sur les graphiques vectoriels: un grand cercle, rempli d'un dégradé radial.  Le dégradé a un point d'ancrage clair en haut, mais pas au bord même, et un point sombre en bas, mais pas non plus au bord même.  Un pinceau est créé sur la base du dégradé, ce peintre au pinceau peint un cercle (c'est-à-dire une ellipse inscrite dans un carré).  Il s'avère qu'un tel code </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  L'environnement met l'accent sur le paramètre de couleur de la fonction drawLed car il n'est pas utilisé.  Laissez-le tolérer, il n'est pas encore nécessaire, mais il en aura bientôt besoin.  Le projet lancé produit le résultat suivant: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Ajoutez un autre lot de code. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Presque le même cercle, mais de taille plus petite et à l'envers.  Nous obtenons l'image suivante: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Enfin, vous avez besoin de la couleur du verre: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Ici, en utilisant la fonction plus sombre de la couleur transmise, la même couleur est obtenue, mais plus sombre, pour organiser le dégradé.  Coefficient 120 sélectionné à l'œil.  Voici le résultat: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Ajoutez une ombre annulaire autour du verre.  Cela se fait dans la leçon sur les graphiques vectoriels, et cela devrait ajouter du volume et du réalisme: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Il y a un dégradé en trois étapes, de sorte que l'ombre est plus épaisse jusqu'au bord et pâlit vers le centre.  Il se présente comme ceci: </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Ajoutez des surbrillances à la fois.  La surbrillance supérieure, contrairement à la partie inférieure (et à tous les autres éléments), est un dégradé linéaire.  L'artiste de moi est moyen, je prends ma parole pour l'auteur de la leçon.  Peut-être y a-t-il une part de vérité à cela, je ne vais pas expérimenter avec différents types de dégradés. </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  En fait, c'est tout, une ampoule prête à l'emploi, comme sur KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  La visibilité de l'éblouissement et du renflement du verre est affectée par la couleur, ou plutôt par son obscurité.  Il peut être judicieux d'ajouter un ajustement pour la luminosité de l'éblouissement et le coefficient de variation dans la fonction plus sombre en fonction de l'obscurité, mais c'est du perfectionnisme, je pense. </p><br><p>  Voici un exemple d'utilisation dans une fenêtre de programme. </p><br><div class="spoiler">  <b class="spoiler_title">dessin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Choyer </h3><br><p>  Pour le plaisir, vous pouvez jouer avec des fleurs.  Par exemple, remplacer un événement de clic de souris protégé </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  de cette façon: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  sans oublier d'ajouter des événements de souris à l'en-tête: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Maintenant, un clic de souris sur le composant changera la couleur de l'ampoule: rouge, vert, bleu, gris et une lumière aléatoire de la lampe. </p><br><h2 id="epilog">  Épilogue </h2><br><p>  Quant au dessin, c’est tout.  Et le widget devrait ajouter des fonctionnalités.  Dans mon cas, j'ai ajouté un champ booléen «use state», un autre champ booléen qui définit l'état On ou Off et les couleurs par défaut de ces états, ainsi que des getters et setters ouverts pour tout cela. Ces champs sont utilisés dans la fonction paintEvent () pour sélectionner la couleur transmise à drawLed () en tant que paramètre. Par conséquent, vous pouvez désactiver l'utilisation des états et définir l'ampoule sur n'importe quelle couleur, ou activer les états et activer ou désactiver l'ampoule en fonction des événements. Il est particulièrement pratique de faire du sélecteur d'état un emplacement ouvert et conjoint  que ce soit avec le signal qui doit être surveillée. </p><br><p>  L'utilisation de mousePressEvent démontre qu'un widget peut être créé non seulement un indicateur, mais aussi un bouton, ce qui le rend enfoncé, relâché, plié, tordu, coloré et tout ce que vous voulez pour les événements de pointage, de clic et de relâchement. </p><br><p>  Mais ce n'est plus fondamental.  L'objectif était de montrer où vous pouvez prendre des modèles lorsque vous dessinez vos propres widgets et comment ce dessin est facile à implémenter sans utiliser d'images raster ou vectorielles, dans des ressources ou des fichiers. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425547/">https://habr.com/ru/post/fr425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425531/index.html">Refroidissement liquide des freins. Options de développement du système</a></li>
<li><a href="../fr425533/index.html">Comment travailler dans le cloud: de la vérification de la fiabilité d'un datacenter à la gestion d'une infrastructure virtuelle</a></li>
<li><a href="../fr425537/index.html">Comment combiner Java, Js et graphiques avec de l'art, ou l'histoire de la création d'un théâtre interactif</a></li>
<li><a href="../fr425541/index.html">Comment contourner rapidement et sans puces inutiles l'immuabilité de l'adresse du capteur HTU21</a></li>
<li><a href="../fr425545/index.html">Vous devriez penser à des heures de pratique.</a></li>
<li><a href="../fr425549/index.html">Les stocks de Supermicro se brisent au milieu d'une enquête sur le déploiement d'une puce d'espionnage chinoise</a></li>
<li><a href="../fr425551/index.html">Qui devrait recevoir de l'argent de la vente d'une œuvre d'art créée par AI?</a></li>
<li><a href="../fr425553/index.html">Ce que le comte de Monte-Cristo peut nous dire sur la cybersécurité</a></li>
<li><a href="../fr425555/index.html">Charles Nutter sur les langages dynamiques dans la JVM sur jug.msk.ru</a></li>
<li><a href="../fr425557/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 10: Exécution symbolique, partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>