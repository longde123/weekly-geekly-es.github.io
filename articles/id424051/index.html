<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 🆚 🕵️ Manifesto Programmer Bersih atau Ringkasan Buku Kode Pendek Robert Martin 📩 🕵🏼 🔆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah sinopsis buku Clean Code Robert Martin dan pemahaman saya tentang bagaimana seharusnya Clean Code. Tidak ada bagian pengujian, TDD,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manifesto Programmer Bersih atau Ringkasan Buku Kode Pendek Robert Martin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424051/"><p>  Artikel ini adalah sinopsis buku Clean Code Robert Martin dan pemahaman saya tentang bagaimana seharusnya Clean Code.  Tidak ada bagian pengujian, TDD, arsitektur apa yang seharusnya, dll.  Di sini semuanya hanya tentang apa yang seharusnya menjadi Kode Bersih. </p><br><p><img src="https://habrastorage.org/webt/zt/bt/ue/ztbtueydh3jfvrdzeuh5_nkkca4.jpeg"></p><a name="habracut"></a><br><hr><br><p>  Ya, mungkin topik Kode Bersih sudah usang, namun demikian, tidak semua orang mengenalnya dan, apalagi, saya belum menemukan analog dari konten yang terkandung dalam artikel saya. </p><br><h3 id="obschee">  Jenderal </h3><br><p>  Tidak ada cara dan solusi yang benar.  Ada satu yang paling cocok untuk tugas tertentu. </p><br><p>  Saat memecahkan masalah, cobalah untuk mereproduksi secara absolut semua kasus yang dapat memengaruhi tugas ini dan mengimplementasikan tugas dengan memperhitungkan sepenuhnya semua kasus. </p><br><p>  Juga, ketika memecahkan masalah, cobalah untuk pergi dari yang sebaliknya.  Pahami hasil seperti apa yang ingin Anda dapatkan pada akhirnya dan buatlah berdasarkan algoritma ini tugas yang akan dilakukan. </p><br><p>  Sebelum mengirim tugas untuk dirilis, periksa apakah itu berfungsi dengan benar.  Apakah ada kesalahan di dalamnya.  Ini berlaku bahkan untuk komitmen yang dikirim ke cabang Anda.  Skenario paling ideal adalah skenario di mana tidak ada yang bisa menemukan kesalahan dalam fungsionalitas yang Anda kembangkan. </p><br><p>  Selalu pikirkan tentang bagaimana Anda dapat membuat kode Anda lebih sederhana, lebih bersih dan lebih mudah dibaca. </p><br><ul><li>  Kasing apa yang bisa dimiliki suatu tugas? </li><li>  Sudahkah saya mempertimbangkan semuanya? </li><li>  Apa yang bisa salah? </li><li>  Apa yang bisa digabungkan? </li><li>  Apakah ada fungsi serupa? </li><li>  Apa yang berlebihan di sini? </li><li>  Bagaimana cara membuatnya lebih mudah? </li><li>  Bagaimana membuatnya lebih mudah dibaca? </li><li>  Bagaimana membuatnya lebih jelas? </li></ul><br><h3 id="chistyy-kod">  Kode bersih </h3><br><p>  Bagaimana cara menulis kode yang bersih dan bagus?  Itu seperti menulis buku.  Pertama Anda membuat konsep dan kemudian menyisirnya ke keadaan di mana Anda akan senang membacanya.  Ingatlah selalu bahwa kode Anda harus menceritakan sebuah kisah sehingga pembaca dapat memahaminya. </p><br><p>  Entitas dipahami - antarmuka, kelas, metode, variabel, objek, dll. </p><br><ul><li>  Kode bersih sederhana, ekspresif, dan fokus pada tugas tertentu. </li><li>  Kode bersih mudah dibaca, seperti prosa.  Jika ini bukan masalahnya, maka ada baiknya refactoring. </li><li>  Kode bersih mudah dimodifikasi.  Seharusnya tidak terikat dengan tumpukan entitas.  Entitas apa pun dapat dengan mudah diubah. </li><li>  Kode bersih melewati ulasan jauh lebih baik.  Jika ulasan berjalan dengan banyak komentar, maka itu tidak bersih dan perlu di refactored. </li><li>  Kode bersih selalu terlihat seperti sudah dikerjakan untuk waktu yang sangat lama.  Apa pun cara Anda berusaha untuk meningkatkannya, Anda masih akan sampai pada kesimpulan bahwa kode ini adalah yang terbaik.  Karenanya, kode bersih dipikirkan hingga detail terkecil. </li><li>  Aturan Kepramukaan: Tinggalkan tempat parkir lebih bersih daripada sebelumnya.  Ini dengan mudah bergeser ke pemrograman.  Lihat kode kotornya?  Jadikan lebih bersih saat Anda memecahkan masalah Anda.  Anda tidak boleh terbawa oleh ini, dan jika kode kotor sangat kotor, maka Anda harus mengalokasikan tugas dan waktu terpisah untuk membersihkannya. </li><li>  Jangan takut untuk melakukan perubahan.  Jika Anda ingin membuatnya, maka Anda memiliki alasan untuk itu, yang berarti Anda akan membuat kodenya lebih baik dan bersih.  Selain itu, tes akan menunjukkan apakah ada kesalahan dalam kode Anda (asalkan ada sama sekali). </li><li>  Entitas apa pun harus bertanggung jawab atas satu fungsional dan hanya untuk itu.  Dan dia harus melakukannya dengan baik.  Tanggung jawab tunggal. </li><li>  Jika suatu entitas bertanggung jawab dengan segera untuk dua tindakan atau lebih, maka fungsinya harus dipisahkan. </li><li>  Kode harus dibaca dari atas ke bawah. </li><li>  Dalam arsitektur yang baik dan kompeten, membuat perubahan tanpa biaya dan upaya yang signifikan. </li><li>  Hapus kode mati.  Kode mati adalah kode yang tidak akan dipanggil dalam kondisi apa pun atau kode yang tidak digunakan di mana pun. </li></ul><br><h3 id="naimenovaniya-i-razdeleniya">  Nama dan divisi </h3><br><ul><li>  Gunakan nama yang jelas dan mudah diucapkan untuk entitas apa pun.  Mereka harus menjelaskan mengapa entitas ini ada, apa yang dilakukannya, dan bagaimana entitas itu digunakan. </li><li>  Jangan takut membuang waktu untuk memilih nama terbaik dan ramah.  Anda akan menang di masa depan dengan bekerja atau membaca kode ini. </li><li>  Jika nama entitas tidak sesuai dengan fungsinya atau nama tidak mengerti apa yang entitas lakukan, maka harus diganti namanya menjadi nama yang paling dimengerti.  Jika ini tidak mungkin, maka ada sesuatu yang salah dengan fungsionalnya dan perlu direaktor ulang. </li><li>  Entitas, yang memiliki nama "Dan", "Dengan" - melanggar Tanggung Jawab Tunggal.  Fungsionalitas entitas semacam itu layak dibagikan.  Namun aturan ini terkadang diabaikan. </li><li>  Teks-teks yang tidak dapat dipahami, garis-garis harus dimasukkan ke dalam variabel dan memberi mereka nama yang jelas. </li><li>  Nama metode harus berisi kata kerja yang menjelaskan apa yang dilakukan metode ini dan kata kunci yang digunakan metode ini.  Jika nama metode tidak memiliki kata kerja, maka entitas ini tidak boleh menjadi metode atau harus diberi nama yang benar. </li><li>  Nama yang sama harus dihindari untuk dua tujuan berbeda. </li><li>  Jika suatu entitas memiliki nama yang mirip dengan entitas lain, maka kemungkinan besar fungsinya sangat mirip dan mereka perlu digabungkan?  Jika tidak, nama mereka perlu diubah agar tidak mirip. </li><li>  Jika Anda secara mental mengubah nama entitas ketika Anda membaca kode sehingga Anda dapat lebih memahami fungsinya, maka ganti namanya menjadi nama mental ini. </li><li>  Pilih satu kata untuk satu konsep.  Akan sulit untuk memahami fungsionalitas saat Anda mengambil, mengambil, dan mendapatkan nama.  Lebih baik kemana-mana. </li><li>  Nama yang panjang dan mudah dimengerti lebih baik daripada yang pendek tapi tidak bisa dipahami. </li></ul><br><h3 id="funkcii">  Fungsi </h3><br><ul><li>  Fungsinya harus pendek dan padat. </li><li>  Fungsinya harus sangat pendek dan sangat kompak. </li><li>  Perkiraan maksimum 20 baris dan 150 karakter dalam satu baris, jika tidak cocok, maka Anda perlu memisahkan. </li><li>  Suatu fungsi harus melakukan hanya satu operasi. <br><ul><li>  Dia harus melakukannya dengan baik dan dia tidak boleh melakukan hal lain. </li><li>  Jika suatu fungsi hanya melakukan tindakan-tindakan yang berada pada level abstraksi yang sama, maka fungsi tersebut melakukan satu operasi. </li><li>  Untuk menentukan apakah suatu fungsi melakukan lebih dari satu operasi, cobalah mengekstrak fungsi lain darinya, yang tidak akan menjadi rumusan ulang implementasi yang sederhana. </li></ul></li><li>  Pernyataan bersyarat apa pun dengan pilihan panjang melalui sakelar, jika-lain harus dibelah atau digabungkan tanpa duplikasi, mungkin ke dalam kelas dengan implementasi, dan mentransfer pilihan implementasi ke kelas dasar, pabrik, atau orang lain. </li><li>  Jika, yang lain, sementara, dll.  harus mengandung panggilan ke satu fungsi.  Ini akan lebih mudah dibaca, lebih jelas dan lebih mudah. </li><li>  Jumlah ideal argumen input untuk fungsi = 0. Jika ada lebih dari tiga argumen input, maka ada baiknya mempertimbangkan cara terbaik untuk menghilangkannya, misalnya, membuat kelas untuk argumen ini. </li><li>  Semakin banyak input argumen, semakin sulit fungsi tersebut dipahami. </li><li>  Fungsi yang dilewati argumen argumen, di mana operasi fungsi tergantung, menunjukkan bahwa fungsi melakukan lebih dari satu operasi.  Fungsi seperti itu harus dibagi menjadi dua dan menyebutnya tingkat yang lebih tinggi. </li><li> Fungsi yang mengubah argumen input harus memberikan referensi ke objek yang diubah, dan tidak hanya memodifikasinya tanpa kembali. <code>String transform(String text)</code> </li><li>  Jika fungsi harus mengubah argumen input, maka biarkan itu mengubah keadaan objek pemiliknya. </li><li>  Jika argumen input fungsi tidak boleh berubah (dan digunakan lebih lanjut dalam kode), maka Anda harus menyalin nilai argumen dan bekerja dengan salinan di dalam fungsi. </li><li>  Alih-alih mengembalikan nol, lebih baik menggunakan objek kosong - <code>Collection.empty()</code> atau objek null - <code>EmptyObject()</code> . </li><li>  Usahakan selalu menggunakan fungsi non-statis.  Jika ini tidak memungkinkan, maka gunakan statis. </li><li>  Jika ada kode yang harus mengikuti satu demi satu, maka meneruskan hasil dari fungsi pertama ke yang kedua sehingga seseorang tidak mengubah urutan panggilan. </li><li>  Gunakan polimorfisme alih-alih jika / else atau beralih / case atau kapan. </li><li>  Hindari kondisi negatif. </li></ul><br><h3 id="kommentarii">  Komentar </h3><br><ul><li>  Jangan menggunakan komentar jika Anda bisa menggunakan fungsi atau variabel sebagai gantinya. </li><li>  Jangan mengomentari kode yang buruk - tulis ulang.  Tidak ada gunanya menjelaskan apa yang terjadi pada kode yang buruk, lebih baik membuatnya eksplisit dan mudah dimengerti. </li><li>  Komentar dapat digunakan untuk menyampaikan beberapa informasi, peringatan tentang konsekuensinya, tetapi tidak untuk menjelaskan cara kerja kode. </li><li>  Gunakan TODO dan FIXME dalam kasus di mana Anda perlu mencatat bahwa kode perlu ditingkatkan, tetapi sekarang tidak ada sumber daya untuk ini. </li><li>  Gunakan <code>//region REGIONNAME //endregion REGIONNAME</code> , dan jika Anda gunakan, maka pikirkan apakah mungkin untuk membagi wilayah menjadi entitas. </li><li>  Kode dokumen yang rumit tetapi bersih. </li><li>  Jangan tinggalkan kode komentar lama.  Anda dapat menemukannya di histori komit, jika perlu. </li><li>  Komentar harus singkat dan jelas.  Komentar informasi tidak boleh memiliki banyak informasi.  Semuanya harus singkat dan to the point. </li></ul><br><h3 id="formatirovanie-i-pravila">  Pemformatan dan aturan </h3><br><ul><li>  Ikuti kode gaya yang diadopsi pada proyek. </li><li>  Ikuti aturan yang diterima di tim. </li><li>  Tunduk pada format dan gaya kode, kode akan lebih mudah dibaca dan lebih baik.  Tidak sia-sia bahwa buku itu diberikan kepada editor sebelum menerbitkannya. </li><li>  Anda perlu memiliki alat otomatis yang akan memformat kode untuk Anda. </li><li>  File sumber harus seperti artikel surat kabar.  Ada tajuk, deskripsi singkat dalam bentuk parameter dan konten dalam bentuk fungsi.  Jika ini bukan masalahnya, maka Anda harus mengubah formatnya. </li><li>  Entitas yang terkait satu sama lain harus dekat, misalnya, dalam satu paket, sehingga lebih mudah untuk menavigasi kode. </li><li>  Variabel kelas (bidang) harus di bagian atas kelas. </li><li>  Variabel metode harus lebih dekat ke tempat penggunaannya. </li><li>  Fungsinya harus sesuai urutan panggilan.  Jika satu memanggil yang lain, maka fungsi panggilan harus di atas yang dipanggil.  Di sisi lain, fungsi pribadi level rendah mungkin ada di bagian bawah file dan tidak mengganggu pemahaman kode level tinggi.  Tapi saya lebih suka cara pertama. </li></ul><br><h3 id="obekty-i-struktury-dannyh">  Objek dan Struktur Data </h3><br><ul><li>  Anda harus bekerja dengan abstraksi sehingga implementasinya dapat dengan mudah diubah. </li><li>  Anda harus bekerja dengan abstraksi, karena klien yang menggunakan fungsionalitas tidak boleh tahu tentang detail implementasi, ia harus tahu implementasi mana yang digunakan dalam hal ini. </li><li>  Anda harus memberikan API tempat Anda bekerja dan menyembunyikan detail implementasi, struktur.  Jadi akan lebih mudah untuk bekerja dengan entitas seperti itu dan menambahkan tipe perilaku, fungsi, dan implementasi baru. </li><li>  DTO - Obyek Transfer Data.  Kelas yang hanya berisi data dan tanpa fungsi.  Ini diperlukan untuk mentransfer beberapa data.  Objek dari kelas ini harus tidak berubah. </li></ul><br><h3 id="klassy">  Kelas </h3><br><ul><li>  Kelas harus kompak. </li><li>  Kelas harus lebih padat. </li><li>  Nama kelas harus menjelaskan tanggung jawabnya.  Dari sini Anda dapat menghitung ukuran kelas. </li><li>  Fungsionalitas kelas harus dengan jelas sesuai dan sesuai dengan nama kelas. </li><li>  Membagi keterhubungan ke dalam kelas-kelas kecil.  Seharusnya tidak ada kohesi yang kaku dan berlimpah - ini mempersulit dukungan dan pengembangan proyek. </li><li>  Ingat Tanggung Jawab Tunggal.  Entitas harus memiliki satu dan hanya satu alasan untuk perubahan. </li><li>  Amati enkapsulasi.  Enkapsulasi yang lemah harus selalu menjadi pilihan terakhir. </li><li>  Biasanya kita mendeklarasikan variabel dan fungsi tambahan pribadi, tetapi kadang-kadang mereka perlu dinyatakan terlindungi dan dapat mengaksesnya dari tes. </li><li>  Jika sekelompok fungsi milik fungsional tertentu, maka kelompok fungsi ini dapat dan harus dialokasikan ke kelas yang terpisah dan menggunakan instance-nya. </li></ul><br><h3 id="obrabotka-oshibok">  Menangani kesalahan </h3><br><ul><li>  Gunakan Pengecualian alih-alih mengembalikan kode kesalahan. </li><li>  Penanganan kesalahan adalah satu operasi.  Jika ada <code>try</code> kata kunci dalam fungsi, maka setelah <code>catch/finally</code> blok seharusnya tidak ada hal lain dalam fungsi. </li><li>  Jika Anda memiliki enum yang mencantumkan kesalahan, maka lebih baik menyingkirkannya dan menggunakan pengecualian. </li><li>  Gunakan pengecualian yang tidak dicentang untuk secara eksplisit menunjukkan tempat di mana ada masalah.  Kesalahan semacam itu tidak perlu ditangkap, sebaliknya Anda perlu menulis kode agar kesalahan ini tidak pernah ada. </li><li>  Berikan informasi yang cukup bersama dengan melemparkan pengecualian sehingga nantinya pengguna kode Anda dapat memahami apa yang sebenarnya terjadi. </li><li>  Alih-alih pernyataan bersyarat dengan penanganan kesalahan, lebih baik untuk melemparkan pengecualian dan menanganinya. </li><li>  Jangan lulus nol di mana pun.  Cobalah untuk menghindari ini sebanyak mungkin. </li><li>  Penanganan kesalahan adalah tugas yang terpisah dan tidak berlaku untuk logika utama program. </li></ul><br><h3 id="granicy">  Perbatasan </h3><br><ul><li>  Kami selalu menggunakan beberapa perpustakaan yang paling sering memberi kami fungsi yang terlalu luas, terlalu kecil atau bertentangan dengan fungsionalitas yang diharapkan, yang membuat kode lebih berantakan dalam penggunaan akhirnya.  Anda dapat menghindari ini dengan hanya menerapkan pola seperti Dekorator, Adaptor, Fasad, atau lainnya. </li><li>  Ada situasi ketika Anda perlu bekerja dengan fungsionalitas yang sedang dikembangkan atau belum diadaptasi untuk digunakan dalam kode produksi.  Dalam hal ini, Anda harus membayangkan apa yang Anda harapkan dari perpustakaan / fungsi ini dan menulis antarmuka Anda atau membuat entitas yang dengannya Anda akan bekerja dalam proyek Anda seperti yang Anda butuhkan.  Ketika perpustakaan selesai dan menjadi stabil, Anda menyesuaikannya dengan struktur yang sudah jadi dan menggunakan fungsi yang sudah jadi. </li></ul><br><h3 id="posleslovie">  Kata penutup </h3><br><p>  Artikel ini hanya menyediakan pedoman untuk menulis Kode Bersih.  Tentu saja, mereka bisa diabaikan.  Anda hanya perlu memahami bahwa setiap keputusan Anda harus memiliki argumen yang mendukungnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424051/">https://habr.com/ru/post/id424051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424039/index.html">Kriptografi setelah pendaratan alien</a></li>
<li><a href="../id424041/index.html">Pengantar Singkat untuk Biologi Sel</a></li>
<li><a href="../id424043/index.html">Trik topi yang cerah. Ada tiga desa di Dobrovlyany di Ukraina. Dan ketiganya memiliki pembangkit listrik tenaga surya yang kuat</a></li>
<li><a href="../id424045/index.html">Beberapa trik terkadang diperlukan saat bekerja dengan git</a></li>
<li><a href="../id424049/index.html">Kami menyajikan buku "Harry Potter dan metode berpikir rasional" untuk Olimpiade</a></li>
<li><a href="../id424053/index.html">Seri MicroSD Yang Terbuat Dari Kanvas Yang Kosong</a></li>
<li><a href="../id424057/index.html">Integrasi Aplikasi Web dengan Kontrak Spring Cloud</a></li>
<li><a href="../id424059/index.html">Sorotan #GitLabLive pada 20 September 2018</a></li>
<li><a href="../id424061/index.html">Lima tahun kemudian, versi berikutnya dari DOSBox dirilis dengan angka 0,74-2</a></li>
<li><a href="../id424063/index.html">Bagaimana kami bunuh diri dalam satu klik, dengan menempatkan situs dan menagih pada geocluster, atau kami akan berbicara tentang redundansi lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>