<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔬 👨‍👧‍👧 👩🏾‍💻 Rust 1.30 Lanzamiento 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🈂️ 👨🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El equipo de desarrollo de Rust se complace en anunciar el lanzamiento de una nueva versión de Rust: 1.30.0. Rust es un lenguaje de programación del s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.30 Lanzamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428073/"><p>  El equipo de desarrollo de Rust se complace en anunciar el lanzamiento de una nueva versión de Rust: 1.30.0.  Rust es un lenguaje de programación del sistema destinado a la seguridad, la velocidad y la ejecución de código paralelo. </p><br><p> Si tiene una versión anterior de Rust instalada usando <code>rustup</code> , entonces para actualizar Rust a la versión 1.30.0 solo necesita hacer: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Si aún no ha instalado <code>rustup</code> , puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalarlo</a> desde la página correspondiente de nuestro sitio web.  <a href="">Las notas de lanzamiento detalladas para Rust 1.30.0</a> están disponibles en GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1300">  Lo que se incluye en la versión estable 1.30.0 </h2><br><p>  Rust 1.30 es un lanzamiento sobresaliente con una serie de innovaciones importantes.  Pero el lunes, se publicará en el blog oficial una solicitud para verificar la versión beta de Rust 1.31, que será el primer lanzamiento de "Rust 2018".  Encontrará más información sobre esto en nuestra publicación anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"What is Rust 2018"</a> . </p><br><h3 id="procedurnye-makrosy">  Macros procesales </h3><br><p>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust 1.15,</a> agregamos la capacidad de definir "macros de derivación personalizadas".  Por ejemplo, usando <code>serde_derive</code> , puede declarar: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Y convierta <code>Pet</code> a JSON y vuelva a estructurar utilizando <code>serde_json</code> .  Esto es posible gracias a la inferencia automática de los <code>Deserialize</code> <code>Serialize</code> y <code>Deserialize</code> utilizando macros de procedimiento en <code>serde_derive</code> . </p><br><p>  Rust 1.30 extiende la funcionalidad de las macros de procedimiento al agregar la capacidad de definir otros dos tipos de macros: "macros de procedimiento de atributos" y "macros de procedimiento funcionales". </p><a name="habracut"></a><br><p>  Las macros de atributos son similares a las macros de derivación para la salida automática, pero en lugar de generar código solo para el atributo <code>#[derive]</code> , permiten a los usuarios crear sus propios atributos nuevos.  Esto los hace más flexibles: las macros derivadas funcionan solo para estructuras y enumeraciones, pero los atributos se pueden aplicar a otros objetos, como las funciones.  Por ejemplo, las macros de atributos le permitirán hacer lo siguiente cuando use un marco web: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[route(GET, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>() {</code> </pre> <br><p>  Este atributo <code>#[route]</code> se definirá en el marco mismo como una macro de procedimiento.  Su firma se verá así: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_attribute]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Aquí tenemos dos parámetros de entrada de tipo <code>TokenStream</code> : el primero es para el contenido del atributo en sí, es decir, estos son los parámetros <code>GET, "/"</code> .  El segundo es el cuerpo del objeto al que se aplica el atributo.  En nuestro caso, este es <code>fn index() {}</code> y el resto del cuerpo de la función. </p><br><p>  Las macros funcionales definen macros cuyo uso se parece a una llamada de función.  Por ejemplo, la <code>sql!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Esta macro dentro de sí misma analizará las expresiones SQL y verificará su corrección sintáctica.  Una macro similar debe declararse de la siguiente manera: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sql</span></span></span></span>(input: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Esto es similar a la firma de la macro derivada: obtenemos los tokens que están dentro de los corchetes y devolvemos el código generado por ellos. </p><br><h3 id="makrosy-i-use">  Macros y <code>use</code> </h3><br><p>  Ahora puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">importar macros al alcance utilizando la palabra clave use</a> .  Por ejemplo, para usar la macro <code>serde-json</code> paquete <code>serde-json</code> , la entrada solía ser: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Y ahora tendrás que escribir: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Aquí, la macro se importa, así como otros elementos, por lo que no es necesario usar la anotación <code>macro_use</code> . </p><br><p>  Finalmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el paquete proc_macro se estabiliza</a> , lo que proporciona la API necesaria para escribir macros de procedimiento.  También mejoró significativamente la API de manejo de errores, y paquetes como <code>syn</code> y <code>quote</code> ya lo usan.  Por ejemplo, antes: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span> { ok: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, bad: std::thread::Thread, }</code> </pre> <br><p>  condujo a este error: </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> | ^^^^^^^^^ the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_IMPL_SERIALIZE_FOR_Demo</span></span></span></span>::_serde::Serialize` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `std::thread::Thread`</code> </pre> <br><p>  Ahora se emitirá: </p><br><pre> <code class="hljs cpp">error[E0277]: the trait bound `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread: serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | bad: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread, | ^^^ the trait `serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread`</code> </pre> <br><h2 id="uluchshenie-sistemy-moduley">  Mejorando el sistema de módulos </h2><br><p>  El sistema de módulos ha sido durante mucho tiempo un punto doloroso para los principiantes en Rust;  Algunas de sus reglas eran inconvenientes en la práctica.  Estos cambios son el primer paso que estamos tomando para simplificar el sistema de módulos. </p><br><p>  Además del cambio anterior para macros, hay dos nuevas mejoras para <code>use</code> .  En primer lugar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los paquetes externos ahora se agregan al preludio</a> , es decir: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  let json = ::serde_json::from_str("..."); //  let json = serde_json::from_str("...");</span></span></code> </pre> <br><p>  El problema es que el estilo antiguo no siempre fue necesario debido a las características del sistema de módulos Rust: </p><br><pre> <code class="hljs powershell">extern crate serde_json; fn main() { //   ;     ,  `serde_json` //     let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } mod foo { fn bar() { //   ;     `foo`,  `serde_json` //    let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } //   -        `use` use serde_json; fn baz() { //   -   `::serde_json`,   //  ,   let json = ::serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } }</code> </pre> <br><p>  Era molesto obtener código roto simplemente moviendo la función a un submódulo.  Ahora se comprobará la primera parte de la ruta y, si corresponde a una <code>extern crate</code> , se utilizará independientemente de la posición de la llamada en la jerarquía del módulo. </p><br><p>  Finalmente, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso comenzó a admitir la importación de elementos en el ámbito actual con rutas que comienzan en cajón</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } //  use ::foo::bar; //  use foo::bar; //  use crate::foo::bar;</span></span></code> </pre> <br><p>  La palabra clave <code>crate</code> al comienzo de la ruta indica que la ruta comenzará en la raíz del paquete.  Anteriormente, las rutas indicadas en la línea de importación de <code>use</code> siempre se especificaban en relación con la raíz del paquete, pero las rutas en el resto del código que se refieren directamente a los elementos se especificaban en relación con el módulo actual, lo que condujo a un comportamiento inconsistente de las rutas: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } mod baz { pub fn qux() { //  ::foo::bar(); //  ,    `use`: // foo::bar(); //  crate::foo::bar(); } }</span></span></code> </pre> <br><p>  Tan pronto como el nuevo estilo sea ampliamente utilizado, esperamos aclarar los caminos absolutos sin la necesidad de usar el feo prefijo <code>::</code> . </p><br><p>  Todos estos cambios juntos simplifican la comprensión de cómo se resuelven los caminos.  Donde sea que vea la ruta <code>a::b::c</code> , a excepción de la declaración de <code>use</code> , puede preguntar: </p><br><ul><li>  ¿Es un nombre de paquete?  Entonces necesitas buscar <code>b::c</code> dentro de él. </li><li>  ¿Es <code>a</code> <code>crate</code> palabras clave?  Luego debe buscar <code>b::c</code> desde la raíz del paquete actual. </li><li>  De lo contrario, debe buscar a <code>a::b::c</code> desde la posición actual en la jerarquía del módulo. </li></ul><br><p>  El comportamiento anterior de las rutas en <code>use</code> , siempre comenzando en la raíz del paquete, sigue siendo aplicable.  Pero con una transición única a un nuevo estilo, estas reglas se aplicarán a las rutas en todas partes de manera uniforme, y tendrá que preocuparse mucho menos por las importaciones al mover el código. </p><br><h2 id="syrye-identifikatory">  Identificadores sin formato </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ahora puede usar palabras clave como identificadores</a> usando la siguiente sintaxis nueva: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      `for` let r#for = true; //     `for` fn r#for() { // ... } //    r#for();</span></span></code> </pre> <br><p>  Hasta ahora, no hay muchos casos en que esto sea útil para usted.  Pero un día intentará usar el paquete para Rust 2015 en un proyecto para Rust 2018 o viceversa, entonces su conjunto de palabras clave será diferente.  Hablaremos más sobre esto en el próximo anuncio de Rust 2018. </p><br><h2 id="prilozheniya-bez-standartnoy-biblioteki">  Aplicaciones sin una biblioteca estándar. </h2><br><p>  De vuelta en Rust 1.6, anunciamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estabilización de "no_std" y libcore</a> para crear proyectos sin una biblioteca estándar.  Sin embargo, con una aclaración: era posible crear solo bibliotecas, pero no aplicaciones. </p><br><p>  En Rust 1.30, puede usar el atributo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>#[panic_handler]</code></a> para implementar de forma independiente el pánico.  Esto significa que ahora puede crear aplicaciones, no solo bibliotecas que no usan la biblioteca estándar. </p><br><h2 id="drugoe">  Otros </h2><br><p>  Una última cosa: en las macros, ahora puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asignar modificadores de alcance</a> , como <code>pub</code> , utilizando el calificador <code>vis</code> .  Además, los "atributos de herramienta", como <code>#[rustfmt::skip]</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ahora</a> están <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estabilizados</a> .  Verdadero para usar con <em>herramientas de análisis estático</em> , como <code>#[allow(clippy::something)]</code> , aún no son estables. </p><br><p>  Vea <a href="">las notas de la versión para más</a> detalles. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Estabilización de la biblioteca estándar. </h3><br><p>  Las <a href="">siguientes API</a> se han <a href="">estabilizado</a> en esta versión: </p><br><ul><li> <code>Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Ipv6Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Iterator::find_map</code> </li> </ul><br><p>  Además, la biblioteca estándar siempre ha tenido funciones para eliminar espacios en un lado de algún texto, como <code>trim_left</code> .  Sin embargo, para los lenguajes RTL, el significado de "derecha" e "izquierda" aquí lleva a confusión.  Por lo tanto, presentamos nuevos nombres para estas funciones: </p><br><ul><li>  <code>trim_left</code> -&gt; <code>trim_start</code> </li><li>  <code>trim_right</code> -&gt; <code>trim_end</code> </li><li>  <code>trim_left_matches</code> -&gt; <code>trim_start_matches</code> </li><li>  <code>trim_right_matches</code> -&gt; <code>trim_end_matches</code> </li></ul><br><p>  Planeamos declarar obsoletos los nombres antiguos (pero no eliminarlos, por supuesto) en Rust 1.33. </p><br><p>  Vea <a href="">las notas de la versión para más</a> detalles. </p><br><h3 id="uluchsheniya-v-cargo">  Mejoras de carga </h3><br><p>  ¡La mayor mejora de Cargo en este lanzamiento es que ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tenemos una barra de progreso!</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/84f/4ce/626/84f4ce6263525deded821b6007735dec.gif" alt="gif de demostración"></p><br><p>  Vea <a href="">las notas de la versión para más</a> detalles. </p><br><h2 id="razrabotchiki-1300">  Desarrolladores 1.30.0 </h2><br><p>  Muchas personas juntas crearon Rust 1.30.  No podríamos haber completado el trabajo sin cada uno de ustedes.  <a href="">Gracias</a> </p><br><p>  <em>De un traductor: Expreso un agradecimiento especial a los miembros de la comunidad Rustycrate y personalmente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Vitvakatu</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Virtuos86</a> por su ayuda con la traducción y revisión.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428073/">https://habr.com/ru/post/es428073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428061/index.html">Gestión de costes del proyecto con gestión del valor ganado</a></li>
<li><a href="../es428063/index.html">Los navegadores rechazan la compatibilidad con TLS 1.0 y 1.1</a></li>
<li><a href="../es428065/index.html">Menos no significa peor: skyrmions y paredes de dominio en ferromagnetos</a></li>
<li><a href="../es428067/index.html">AntiFuzzing: ¿Seguridad a través de la oscuridad?</a></li>
<li><a href="../es428069/index.html">Optimice el equilibrio de carga en la infraestructura de Veeam Backup & Replication</a></li>
<li><a href="../es428075/index.html">De todos modos, ¡no puedes hacerlo! - Uso de interfaces e inyección de dependencias para un diseño a largo plazo.</a></li>
<li><a href="../es428077/index.html">React.js: una guía para principiantes</a></li>
<li><a href="../es428079/index.html">Aplicación de principios SÓLIDOS para reaccionar al desarrollo de aplicaciones</a></li>
<li><a href="../es428081/index.html">Uso de RxJS en React Development para administrar el estado de la aplicación</a></li>
<li><a href="../es428083/index.html">Matriz de influencia de análisis web: el sistema estratégico de Avinash Koshik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>