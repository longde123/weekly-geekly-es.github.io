<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë® üà∫ üîÄ ¬´Et l'impossible est possible¬ª: nous transformons une bo√Æte noire en blanc gr√¢ce √† l'analyse binaire üê• ‚õ∏Ô∏è üßôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä l'heure actuelle, il existe deux approches principales pour la recherche de vuln√©rabilit√©s dans les applications: l'analyse statique et l'analyse dy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬´Et l'impossible est possible¬ª: nous transformons une bo√Æte noire en blanc gr√¢ce √† l'analyse binaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="image"></div><br>  √Ä l'heure actuelle, il existe deux approches principales pour la recherche de vuln√©rabilit√©s dans les applications: l'analyse statique et l'analyse dynamique.  Les deux approches ont leurs avantages et leurs inconv√©nients.  Le march√© arrive √† la conclusion que les deux approches doivent √™tre utilis√©es - elles r√©solvent des probl√®mes l√©g√®rement diff√©rents avec des r√©sultats diff√©rents.  Cependant, dans certains cas, l'utilisation de l'analyse statique est limit√©e - par exemple, lorsqu'il n'y a pas de code source.  Dans cet article, nous parlerons d'une technologie assez rare mais tr√®s utile qui vous permet de combiner les avantages des approches statiques et dynamiques - l'analyse statique du code ex√©cutable. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Allons de loin</b> <div class="spoiler_text"> Selon la soci√©t√© antivirus McAfee, les dommages mondiaux caus√©s par la cybercriminalit√© en 2017 s'√©levaient √† environ 600 milliards de dollars, soit 0,8% du PIB mondial.  Nous vivons √† l'√®re des technologies de l'information, dont les sp√©cificit√©s ont √©t√© l'int√©gration rapide du r√©seau mondial et des technologies Internet dans tous les domaines de l'activit√© humaine.  D√©sormais, les cybercrimes ne sortent plus de l'ordinaire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les statistiques</a> montrent une augmentation exponentielle de la cybercriminalit√©. <br><br>  La vuln√©rabilit√© des applications est devenue un probl√®me grave: selon le d√©partement am√©ricain de la S√©curit√© int√©rieure, plus de 90% des cyberattaques r√©ussies sont mises en ≈ìuvre en utilisant diverses vuln√©rabilit√©s dans les applications.  Les m√©thodes d'exploitation de vuln√©rabilit√© les plus connues sont: <br><br><ul><li>  Injection SQL </li><li>  d√©bordement de tampon </li><li>  script crossite </li><li>  Utilisation d'une configuration non s√©curis√©e. </li></ul><br></div></div><br>  L'analyse des logiciels (logiciels) pour la pr√©sence de capacit√©s non d√©clar√©es (NDV) et de vuln√©rabilit√©s est la principale technologie pour assurer la s√©curit√© des applications. <br>  En parlant de technologies classiques et bien √©tablies pour analyser les logiciels pour les vuln√©rabilit√©s et NDV (pour la conformit√© aux exigences de s√©curit√© de l'information), nous pouvons distinguer: <br><br><ul><li>  analyse de code statique (test de s√©curit√© d'application statique); </li><li>  analyse de code dynamique (Dynamic Application Security Testing). </li></ul><br>  Il existe IAST (analyse interactive), cependant, il est essentiellement dynamique (dans le processus d'analyse, un agent suppl√©mentaire observe ce qui se passe pendant l'ex√©cution de l'application).  RASP (Runtime Application Self-Defense), qui est √©galement parfois mentionn√© dans un certain nombre d'outils d'analyse, est plus probablement un outil de protection. <br><br>  L'analyse dynamique (m√©thode "Black Box") est une v√©rification de programme lors de son ex√©cution.  Les avantages suivants peuvent √™tre distingu√©s de cette approche. <br><br><ol><li>  Comme les vuln√©rabilit√©s se trouvent dans le programme ex√©cutable et que l'erreur est d√©tect√©e √† l'aide de son fonctionnement, la g√©n√©ration de faux positifs est inf√©rieure √† celle de l'analyse statique. </li><li>  Aucun code source n'est n√©cessaire pour effectuer l'analyse. </li></ol><br>  Mais il y a aussi des inconv√©nients. <br><br><ol><li>  Couverture incompl√®te du code, et il existe donc des risques de vuln√©rabilit√© manquante.  Par exemple, l'analyse dynamique ne peut pas trouver de vuln√©rabilit√©s associ√©es √† l'utilisation d'une cryptographie faible ou de signets comme "bombe temporaire". </li><li>  La n√©cessit√© d'ex√©cuter l'application, ce qui dans certains cas peut √™tre difficile.  Le lancement de l'application peut n√©cessiter une configuration complexe et la configuration de diverses int√©grations.  De plus, pour que les r√©sultats soient aussi pr√©cis que possible, il est n√©cessaire de reproduire ¬´l'environnement de combat¬ª, mais il est difficile de r√©aliser pleinement cela sans nuire au logiciel. </li></ol><br>  L'analyse statique (la m√©thode ¬´White Box¬ª) est un type de test de programme dans lequel le programme ne s'ex√©cute pas. <br><br>  Nous √©num√©rons les avantages. <br><br><ol><li>  Couverture compl√®te du code, ce qui conduit √† la recherche de plus de vuln√©rabilit√©s. </li><li>  Aucune d√©pendance √† l'environnement dans lequel le programme sera ex√©cut√©. </li><li>  La possibilit√© de mettre en ≈ìuvre des tests aux √©tapes initiales de l'√©criture de code pour un module ou un programme en l'absence de fichiers ex√©cutables.  Cela vous permet d'int√©grer d√©j√† de mani√®re flexible une solution similaire dans le SDLC (cycle de vie du d√©veloppement logiciel  cycle de vie du d√©veloppement logiciel) au d√©but du d√©veloppement. </li></ol><br>  Le seul inconv√©nient de la m√©thode est la pr√©sence de faux positifs: la n√©cessit√© d'√©valuer si l'analyseur indique une erreur r√©elle, ou est-il probable que ce faux positif. <br><br>  Comme nous pouvons le voir, les deux m√©thodes d'analyse pr√©sentent √† la fois des avantages et des inconv√©nients.  Cependant, est-il possible de quelque fa√ßon que ce soit d'utiliser les avantages de ces m√©thodes, tout en minimisant les inconv√©nients?  Oui, si vous appliquez l'analyse binaire - la recherche de vuln√©rabilit√©s dans les fichiers ex√©cutables par analyse statique. <br><br><h2>  Technologie d'analyse binaire ou d'analyse de fichiers ex√©cutables </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="image"></div><br>  L'analyse binaire permet une analyse statique sans code source, par exemple, dans le cas de prestataires tiers.  De plus, la couverture du code sera compl√®te, contrairement √† l'application de la m√©thode d'analyse dynamique.  √Ä l'aide de l'analyse binaire, vous pouvez v√©rifier les biblioth√®ques tierces utilis√©es dans le processus de d√©veloppement pour lesquelles il n'y a pas de code source.  De plus, √† l'aide de l'analyse binaire, vous pouvez effectuer un contr√¥le de contr√¥le de la version, en comparant les r√©sultats de l'analyse du code source du r√©f√©rentiel et du code ex√©cutable du serveur de combat. <br><br>  Au cours de l'analyse binaire, l'image binaire est transform√©e en une repr√©sentation interm√©diaire (repr√©sentation interne ou mod√®le de code) pour une analyse plus approfondie.  Apr√®s cela, des algorithmes d'analyse statique sont appliqu√©s √† la repr√©sentation interne.  En cons√©quence, le mod√®le actuel est compl√©t√© par les informations n√©cessaires √† la d√©tection suppl√©mentaire des vuln√©rabilit√©s et des NDV.  A l'√©tape suivante, l'application des r√®gles de recherche de vuln√©rabilit√©s et de NDV. <br><br>  Nous avons √©crit plus sur le sch√©ma d'analyse statique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article pr√©c√©dent</a> .  Contrairement √† l'analyse de code source, qui utilise des √©l√©ments de th√©orie de compilation (analyse lexicale et syntaxique) pour construire le mod√®le, l'analyse binaire utilise la th√©orie de la traduction inverse pour d√©sassembler, d√©compiler et d√©sobfusquer le mod√®le. <br><br><h2>  Un peu sur les termes </h2><br>  Nous parlons d'analyser les fichiers ex√©cutables qui n'ont pas d'informations de d√©bogage.  Avec les informations de d√©bogage, la t√¢che est grandement simplifi√©e, mais s'il existe des informations de d√©bogage, le code source l'est probablement et la t√¢che devient non pertinente. <br><br>  Dans cet article, nous appelons l'analyse de bytecode Java aussi l'analyse binaire, bien que ce ne soit pas tout √† fait correct.  Nous faisons cela pour simplifier le texte.  Bien s√ªr, la t√¢che d'analyser le bytecode JVM est plus simple que d'analyser le code binaire C / C ++ et Objective-C / Swift.  Mais le sch√©ma d'analyse g√©n√©ral est similaire dans le cas du bytecode et du code binaire.  Les principales difficult√©s d√©crites dans l'article concernent sp√©cifiquement l'analyse du code binaire. <br><br>  La d√©compilation est le processus de r√©cup√©ration du code source √† partir du code binaire.  Vous pouvez parler des √©l√©ments de la traduction inverse - d√©montage (obtention du code assembleur √† partir d'une image binaire), conversion de l'assembleur en code √† trois adresses ou autre repr√©sentation, restauration des constructions du niveau du code source. <br><br>  Obfuscation - transformations qui pr√©servent la fonctionnalit√© du code source, mais rendent difficile la d√©compilation et la compr√©hension de l'image binaire r√©sultante.  La d√©sobfuscation est la transformation inverse.  L'obfuscation peut √™tre appliqu√©e √† la fois au niveau du code source et au niveau du code binaire. <br><br><h2>  Comment regarder les r√©sultats? </h2><br>  Commen√ßons un peu par la fin, mais la question de visualiser les r√©sultats de l'analyse binaire est g√©n√©ralement pos√©e en premier. <br><br>  Il est important pour un sp√©cialiste analysant le code binaire de mapper les vuln√©rabilit√©s et NDV au code source.  Pour ce faire, au stade final, le processus de d√©sobfuscation (d√©m√™lage) est lanc√© si des conversions d√©routantes ont √©t√© appliqu√©es et le code binaire a √©t√© d√©compil√© vers la source.  Autrement dit, les vuln√©rabilit√©s peuvent √™tre d√©montr√©es sur du code d√©compil√©. <br><br>  Dans le processus de d√©compilation, m√™me si nous d√©compilons le bytecode JVM, certaines informations ne sont pas restaur√©es correctement, donc l'analyse elle-m√™me a lieu sur une repr√©sentation proche du code binaire.  En cons√©quence, la question se pose: comment, en trouvant des vuln√©rabilit√©s dans le code binaire, les localiser dans la source?  La solution au probl√®me du bytecode JVM a √©t√© d√©crite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans notre article sur la recherche de vuln√©rabilit√©s dans le bytecode Java</a> .  La solution pour le code binaire est similaire, c'est-√†-dire une question technique. <br><br>  R√©p√©tons la mise en garde importante - nous parlons d'analyse de code binaire sans informations de d√©bogage.  En pr√©sence d'informations de d√©bogage, la t√¢che est grandement simplifi√©e. <br><br>  La principale question qui nous est pos√©e √† propos de l'affichage des r√©sultats est de savoir si le code d√©compil√© est suffisant pour comprendre et localiser la vuln√©rabilit√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="image"></div><br>  Voici quelques r√©flexions √† ce sujet. <br><br><ol><li>  Si nous parlons du bytecode JVM, alors en g√©n√©ral la r√©ponse est ¬´oui¬ª - la qualit√© de d√©compilation pour le bytecode est excellente.  Presque toujours, vous pouvez d√©terminer quelle est la vuln√©rabilit√©. </li><li>  Ce qui peut interf√©rer avec la localisation qualitative de la vuln√©rabilit√© est une simple obfuscation telle que renommer des noms et des fonctions de classe.  Cependant, dans la pratique, il s'av√®re souvent qu'il est plus important de comprendre la vuln√©rabilit√© que de d√©terminer dans quel fichier elle se trouve.  La localisation est n√©cessaire lorsque quelqu'un peut corriger la vuln√©rabilit√©, mais dans ce cas, le d√©veloppeur comprendra √©galement o√π la vuln√©rabilit√© provient du code d√©compil√©. </li><li>  Quand on parle d'analyse de code binaire (par exemple, C ++), bien s√ªr, tout est beaucoup plus compliqu√©.  Il n'y a aucun outil qui r√©cup√®re compl√®tement le code C ++ al√©atoire.  Cependant, la particularit√© de notre cas est que nous n'avons pas besoin de compiler le code plus tard: nous avons besoin d'une qualit√© suffisante pour comprendre la vuln√©rabilit√©. </li><li>  Le plus souvent, vous pouvez obtenir une qualit√© de d√©compilation suffisante pour comprendre la vuln√©rabilit√© trouv√©e.  Pour ce faire, vous devez r√©soudre de nombreux probl√®mes complexes, mais vous pouvez les r√©soudre (nous en parlerons bri√®vement ci-dessous). </li><li>  Pour C / C ++, il est encore plus difficile de localiser la vuln√©rabilit√© - les noms des caract√®res sont perdus de plusieurs fa√ßons au cours du processus de compilation, vous ne pouvez pas les restaurer. </li><li>  La situation dans Objective-C est l√©g√®rement meilleure - il y a des noms de fonctions et il est plus facile de localiser la vuln√©rabilit√©. </li><li>  Les probl√®mes d'obscurcissement sont √† part.  Il existe un certain nombre de transformations complexes qui peuvent compliquer la d√©compilation et la cartographie des vuln√©rabilit√©s.  En pratique, il s'av√®re qu'un bon d√©compilateur peut g√©rer la plupart des conversions d√©routantes (rappelez-vous que nous avons besoin d'une qualit√© de code suffisante pour comprendre la vuln√©rabilit√©). </li></ol><br>  En conclusion - le plus souvent, il s'av√®re que la vuln√©rabilit√© est compr√©hensible et v√©rifiable. <br><br><h2>  Complexit√©s et d√©tails de l'analyse binaire </h2><br>  Ici, nous ne parlerons pas du bytecode: toutes les choses int√©ressantes √† ce sujet ont d√©j√† √©t√© dites ci-dessus.  La chose la plus int√©ressante est l'analyse du vrai code binaire.  Ici, nous parlerons de l'analyse de C / C ++, Objective-C et Swift comme exemple. <br><br>  Des difficult√©s importantes surviennent m√™me lors du d√©montage.  L'√©tape la plus importante est la division de l'image binaire en sous-programmes.  Ensuite, s√©lectionnez les instructions de l'assembleur dans les sous-programmes - une question technique.  Nous avons √©crit √† ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en</a> d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article de la revue ¬´Issues of Cybersecurity No. 1 (14) - 2016¬ª</a> , que nous d√©crirons ici bri√®vement. <br><br>  √Ä titre d'exemple, nous parlerons de l'architecture x86.  Les instructions qu'il contient n'ont pas de longueur fixe.  Dans les images binaires, il n'y a pas de division claire en sections de code et de donn√©es: les tables d'importation, les tables de fonctions virtuelles peuvent √™tre dans la section de code, les tables de transition peuvent √™tre dans les intervalles entre les blocs de fonction de base dans la section de code.  Par cons√©quent, vous devez pouvoir s√©parer le code des donn√©es et comprendre o√π les routines commencent et o√π se terminent les routines. <br><br>  Les plus courantes sont deux m√©thodes pour r√©soudre le probl√®me de la d√©termination des adresses de d√©part des sous-programmes.  Dans la premi√®re m√©thode, les adresses des sous-programmes sont d√©termin√©es par le prologue standard (pour l'architecture x86 c'est push ebp; mov ebp, esp).  Dans la deuxi√®me m√©thode, une section de code est parcourue r√©cursivement √† partir du point d'entr√©e avec reconnaissance des instructions d'appel de sous-programme.  Le contournement se fait en reconnaissant les instructions de branchement.  Des combinaisons des m√©thodes d√©crites sont √©galement utilis√©es lorsqu'un parcours r√©cursif est d√©marr√© √† partir des adresses de d√©but trouv√©es par le prologue. <br><br>  En pratique, il s'av√®re que de telles approches donnent un pourcentage assez faible de code reconnu, car toutes les fonctions n'ont pas un prologue standard, et il y a des appels et des transitions indirectes. <br><br>  Les algorithmes de base peuvent √™tre am√©lior√©s par les heuristiques suivantes. <br><br><ol><li>  Sur une large base d'images de test, trouvez une liste plus pr√©cise de prologues (nouveaux prologues ou variantes de prologs standard). </li><li>  Vous pouvez trouver automatiquement des tableaux de fonctions virtuelles, et √† partir d'eux pour r√©cup√©rer les adresses de d√©part des sous-programmes. </li><li>  Les adresses de d√©part des sous-programmes et d'autres constructions peuvent √™tre trouv√©es sur la base de sections de code binaire associ√©es au m√©canisme de gestion des exceptions. </li><li>  Vous pouvez v√©rifier les adresses de d√©part en recherchant ces adresses dans l'image et en reconnaissant les instructions d'appel. </li><li>  Pour rechercher des limites, vous pouvez effectuer une travers√©e r√©cursive du sous-programme avec reconnaissance des instructions √† partir de l'adresse de d√©but.  Il y a une difficult√© avec les transitions indirectes et les fonctions sans retour.  L'analyse de la table d'importation et la reconnaissance des constructions de commutateurs peuvent √™tre utiles. <br></li></ol><br>  Une autre chose importante qui doit √™tre faite lors de la traduction inverse, afin de rechercher normalement une vuln√©rabilit√© plus tard, est de reconna√Ætre les fonctions standard dans une image binaire.  Les fonctions standard peuvent √™tre li√©es statiquement √† l'image, ou m√™me √™tre int√©gr√©es.  L'algorithme de reconnaissance principal est une recherche par signature avec des variations; pour la solution, vous pouvez proposer l'algorithme Aho-Korasik adapt√©.  Pour collecter des signatures, vous devez pr√©-analyser les images de biblioth√®que collect√©es avec diff√©rentes conditions et les s√©lectionner comme octets immuables. <br><br><h2>  Et ensuite </h2><br>  Dans la section pr√©c√©dente, nous avons examin√© l'√©tape initiale de la traduction inverse d'une image binaire - le d√©montage.  La sc√®ne, en effet, est initiale, mais d√©terminante.  √Ä ce stade, vous pouvez perdre une partie du code, ce qui aura alors un effet spectaculaire sur les r√©sultats de l'analyse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="image"></div><br>  Ensuite, beaucoup de choses int√©ressantes se produisent.  Dites bri√®vement sur les t√¢ches principales.  Nous ne parlerons pas en d√©tail: soit le savoir-faire, sur lequel nous ne pouvons pas explicitement √©crire ici, soit des solutions techniques et d'ing√©nierie peu int√©ressantes sont dans les d√©tails. <br><br><ol><li>  Conversion du code d'assemblage en une repr√©sentation interm√©diaire sur laquelle l'analyse peut √™tre effectu√©e.  Vous pouvez utiliser diff√©rents bytecodes.  Pour les langages C, LLVM semble √™tre un bon choix.  LLVM est activement soutenu et d√©velopp√© par la communaut√©, l'infrastructure, notamment utile pour l'analyse statique, est actuellement impressionnante.  √Ä ce stade, il y a un grand nombre de d√©tails auxquels vous devez faire attention.  Par exemple, vous devez d√©tecter les variables qui sont adress√©es sur la pile afin de ne pas multiplier les entit√©s dans la vue r√©sultante.  Vous devez configurer l'affichage optimal des jeux d'instructions d'assembleur dans les instructions de bytecode. </li><li>  Restaurer des structures de haut niveau (par exemple, boucles, branches).  Plus il est possible de restaurer avec pr√©cision les constructions d'origine √† partir du code assembleur, meilleure est la qualit√© de l'analyse.  La restauration de telles constructions se fait √† l'aide d'√©l√©ments de th√©orie des graphes sur CFG (control flow graph) et quelques autres repr√©sentations graphiques du programme. </li><li>  R√©alisation d'algorithmes d'analyse statique.  Il y a des d√©tails.  En g√©n√©ral, peu importe que nous obtenions la repr√©sentation interne de la source ou du binaire - nous devons √©galement tous construire CFG, appliquer des algorithmes d'analyse de flux de donn√©es et d'autres algorithmes typiques de la statique.  Il existe certaines fonctionnalit√©s lors de l'analyse de la vue obtenue √† partir du binaire, mais elles sont plus techniques. </li></ol><br><h2>  Conclusions </h2><br>  Nous avons expliqu√© comment effectuer une analyse statique en l'absence de code source.  Selon l'exp√©rience de la communication avec les clients, il s'av√®re que la technologie est tr√®s demand√©e.  Cependant, la technologie est rare: le probl√®me de l'analyse binaire n'est pas anodin, sa solution n√©cessite des algorithmes complexes de haute technologie d'analyse statique et de traduction inverse. <br><br>  <i>Cet article a √©t√© √©crit en collaboration avec Anton Prokofiev, analyste Solar appScreener</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460949/">https://habr.com/ru/post/fr460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460939/index.html">Longrid sur l'histoire de l'exploitation mini√®re russe et l'attitude des r√©gulateurs √† son √©gard</a></li>
<li><a href="../fr460941/index.html">Compromis de courrier √©lectronique professionnel: aucune d√©fense contre les attaques</a></li>
<li><a href="../fr460943/index.html">Comment choisir des cl√©s prometteuses pour le r√©f√©rencement en fonction des pr√©visions de sc√©nario dans Google Data Studio (+ mod√®le)</a></li>
<li><a href="../fr460945/index.html">Exp√©rience de l'utilisation d'un canal de t√©l√©gramme pour accro√Ætre la reconnaissance et la croissance des revenus d'un studio de jeux</a></li>
<li><a href="../fr460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../fr460951/index.html">Cr√©er des fonds d'√©cran Android Live</a></li>
<li><a href="../fr460953/index.html">Les pointeurs sont complexes, ou qu'est-ce qui est stock√© dans un octet?</a></li>
<li><a href="../fr460955/index.html">Programme √©ducatif pour transmettre des param√®tres par valeur aux constructeurs et aux setters (C ++ moderne, exemples)</a></li>
<li><a href="../fr460959/index.html">La nouvelle technologie de Microsoft permet aux copies 3D d'une personne r√©elle de parler n'importe quelle langue</a></li>
<li><a href="../fr460961/index.html">Configuration de tests unitaires dans des projets mixtes Swift + Objective-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>