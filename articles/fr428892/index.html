<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª üèª ‚úäüèª Comment cr√©er un jeu AI: un guide pour les d√©butants ü•ë üïñ ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis tomb√© sur du mat√©riel int√©ressant sur l'intelligence artificielle dans les jeux. Avec une explication des choses de base sur l'IA √† l'aide d'e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment cr√©er un jeu AI: un guide pour les d√©butants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/428892/"><img src="https://habrastorage.org/webt/hp/x-/0n/hpx-0n-frdakrflfvlpdt-6hp1e.png"><br><br>  Je suis tomb√© sur du mat√©riel int√©ressant sur l'intelligence artificielle dans les jeux.  Avec une explication des choses de base sur l'IA √† l'aide d'exemples simples, et √† l'int√©rieur il y a de nombreux outils et m√©thodes utiles pour son d√©veloppement et sa conception pratiques.  Comment, o√π et quand les utiliser - est √©galement l√†. <br><br>  La plupart des exemples sont √©crits en pseudocode, donc aucune connaissance approfondie de la programmation n'est requise.  Sous la coupe de 35 feuilles de texte avec des images et des gifs, alors pr√©parez-vous. <br><br>  UPD  Je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suis d√©sol√©</a> , mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PatientZero a</a> d√©j√† fait la traduction de cet article sur Habr√©.  Vous pouvez lire sa version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais pour une raison quelconque, l'article m'a d√©pass√© (j'ai utilis√© la recherche, mais quelque chose s'est mal pass√©).  Et puisque j'√©cris un blog de d√©veloppement de jeux, j'ai d√©cid√© de laisser mon option de traduction aux abonn√©s (certains moments sont diff√©rents pour moi, certains sont intentionnellement manqu√©s sur les conseils des d√©veloppeurs). <br><a name="habracut"></a><br><h2>  Qu'est-ce que l'IA? </h2><br>  L'IA de jeu se concentre sur les actions qu'un objet doit effectuer en fonction des conditions dans lesquelles il se trouve.  Ceci est g√©n√©ralement appel√© la gestion des "agents intelligents", o√π l'agent est un personnage de jeu, un v√©hicule, un bot et parfois quelque chose de plus abstrait: tout un groupe d'entit√©s ou m√™me une civilisation.  Dans chaque cas, c'est une chose qui doit voir son environnement, prendre des d√©cisions sur sa base et agir en accord avec eux.  C'est ce qu'on appelle le cycle Sense / Think / Act: <br><br><ul><li>  Sens: l'agent trouve ou re√ßoit des informations sur des choses dans son environnement qui peuvent affecter son comportement (menaces √† proximit√©, objets √† collecter, lieux de recherche int√©ressants). </li><li>  Pensez: l'agent d√©cide de la fa√ßon de r√©agir (consid√®re s'il est s√©curitaire de collecter des objets ou s'il doit d'abord se battre / se cacher). </li><li>  Agir: l'agent effectue des actions pour mettre en ≈ìuvre la d√©cision pr√©c√©dente (commence √† se d√©placer vers l'adversaire ou l'objet). </li><li>  ... maintenant la situation a chang√© en raison des actions des personnages, donc le cycle se r√©p√®te avec de nouvelles donn√©es. </li></ul><br>  L'IA a tendance √† se concentrer sur la partie sensible de la boucle.  Par exemple, les voitures autonomes prennent des photos de la route, les combinent avec des donn√©es radar et lidar et interpr√®tent.  Habituellement, cela se fait par apprentissage automatique, qui traite les donn√©es entrantes et leur donne un sens, en extrayant des informations s√©mantiques comme "il y a une autre voiture √† 20 m√®tres devant vous".  Ce sont les soi-disant probl√®mes de classification. <br><br>  Les jeux n'ont pas besoin d'un syst√®me complexe pour extraire des informations, car la plupart des donn√©es en font d√©j√† partie int√©grante.  Il n'est pas n√©cessaire d'ex√©cuter des algorithmes de reconnaissance d'image pour d√©terminer s'il y a un ennemi √† venir - le jeu conna√Æt d√©j√† et transf√®re les informations directement dans le processus de prise de d√©cision.  Par cons√©quent, une partie du cycle des sens est souvent beaucoup plus simple que penser et agir. <br><br><h2>  Limitations de l'IA du jeu </h2><br>  L'IA a un certain nombre de restrictions √† respecter: <br><br><ul><li>  L'IA n'a pas besoin d'√™tre form√©e √† l'avance, comme s'il s'agissait d'un algorithme d'apprentissage automatique.  Il est inutile d'√©crire un r√©seau de neurones pendant le d√©veloppement pour regarder des dizaines de milliers de joueurs et apprendre la meilleure fa√ßon de jouer contre eux.  Pourquoi?  Parce que le jeu n'est pas sorti, mais il n'y a pas de joueurs. </li><li>  Le jeu devrait divertir et d√©fier, donc les agents ne devraient pas trouver la meilleure approche contre les gens. </li><li>  Les agents doivent √™tre r√©alistes pour que les joueurs aient l'impression de jouer contre de vraies personnes.  AlphaGo surpassait les humains, mais les mesures prises √©taient loin de la compr√©hension traditionnelle du jeu.  Si le jeu imite un adversaire humain, il ne devrait pas y avoir un tel sentiment.  L'algorithme doit √™tre modifi√© afin qu'il prenne des d√©cisions plausibles, pas id√©ales. </li><li>  L'IA devrait fonctionner en temps r√©el.  Cela signifie que l'algorithme ne peut pas monopoliser l'utilisation du processeur pendant longtemps pour la prise de d√©cision.  M√™me 10 millisecondes pour cela est trop long, car la plupart des jeux n'ont que 16 √† 33 millisecondes pour terminer tout le traitement et passer √† l'image suivante du graphique. </li><li>  Id√©alement, au moins une partie du syst√®me est pilot√©e par les donn√©es afin que les non-codeurs puissent apporter des modifications et des ajustements plus rapidement. </li></ul><br>  Consid√©rez les approches de l'IA qui couvrent tout le cycle Sense / Think / Act. <br><br><h3>  Prise de d√©cision de base </h3><br>  Commen√ßons par le jeu le plus simple - Pong.  Objectif: d√©placer la plate-forme (pagaie) de mani√®re √† ce que le ballon rebondisse dessus, plut√¥t que de passer devant.  C'est comme le tennis, dans lequel vous perdez si vous ne frappez pas la balle.  Ici, l'IA a une t√¢che relativement facile - d√©cider dans quelle direction d√©placer la plate-forme. <br><br><img src="https://habrastorage.org/webt/1l/6g/p8/1l6gp88aolep77ohq7dqwkw8oky.jpeg"><br><br><h3>  D√©clarations conditionnelles </h3><br>  Pour l'IA, Pong a la solution la plus √©vidente - essayez toujours de positionner la plate-forme sous le ballon. <br><br>  Un algorithme simple pour cela, √©crit en pseudocode: <br><br>  <i>chaque image / mise √† jour pendant le jeu:</i> <i><br></i>  <i>si le ballon est √† gauche de la raquette:</i> <i><br></i>  <i>d√©placer la palette vers la gauche</i> <i><br></i>  <i>sinon si le ballon est √† droite de la raquette:</i> <i><br></i>  <i>d√©placer la pagaie vers la droite</i> <br><br>  Si la plateforme se d√©place √† la vitesse du ballon, alors c'est l'algorithme parfait pour l'IA √† Pong.  Il n'est pas n√©cessaire de compliquer quoi que ce soit s'il n'y a pas tant de donn√©es et d'actions possibles pour l'agent. <br><br>  Cette approche est si simple que l'ensemble du cycle Sense / Think / Act est √† peine perceptible.  Mais il est: <br><br><ul><li>  La partie Sense est en deux instructions if.  Le jeu sait o√π se trouve la balle et o√π se trouve la plate-forme, donc l'IA se tourne vers elle pour cette information. </li><li>  La partie Think se d√©cline √©galement en deux d√©clarations if.  Ils incarnent deux solutions, qui dans ce cas s'excluent mutuellement.  Par cons√©quent, l'une des trois actions est s√©lectionn√©e: d√©placer la plate-forme vers la gauche, d√©placer vers la droite ou ne rien faire si elle est d√©j√† correctement positionn√©e. </li><li>  La partie Act se trouve dans les instructions Move Paddle Left et Move Paddle Right.  Selon la conception du jeu, ils peuvent d√©placer la plateforme instantan√©ment ou √† une certaine vitesse. </li></ul><br>  De telles approches sont appel√©es r√©actives - il existe un ensemble simple de r√®gles (dans ce cas, si des d√©clarations dans le code) qui r√©pondent √† l'√©tat actuel du monde et agissent. <br><br><h3>  Arbre de d√©cision </h3><br>  L'exemple Pong est en fait √©gal au concept formel de l'IA appel√© l'arbre de d√©cision.  L'algorithme le passe pour atteindre une ¬´feuille¬ª - une d√©cision sur l'action √† entreprendre. <br><br>  Faisons un sch√©ma de principe de l'arbre de d√©cision pour l'algorithme de notre plateforme: <br><br><img src="https://habrastorage.org/webt/yu/u8/nd/yuu8ndgkxfb0mj1qyfhht-vhrnw.png"><br><br>  Chaque partie de l'arbre est appel√©e un n≈ìud - l'IA utilise la th√©orie des graphes pour d√©crire ces structures.  Il existe deux types de n≈ìuds: <br><br><ul><li>  Noeuds de d√©cision: choisir entre deux alternatives bas√©es sur la v√©rification d'une certaine condition o√π chaque alternative est pr√©sent√©e comme un noeud s√©par√©. </li><li>  Noeuds finaux: action √† effectuer qui repr√©sente la d√©cision finale. </li></ul><br>  L'algorithme commence par le premier n≈ìud (la "racine" de l'arbre).  Il d√©cide soit du n≈ìud enfant vers lequel se rendre, soit effectue une action stock√©e dans le n≈ìud et se termine. <br><br>  Quel est l'avantage si l'arbre de d√©cision fait le m√™me travail que les instructions if de la section pr√©c√©dente?  Ici, il existe un syst√®me commun o√π chaque solution n'a qu'une seule condition et deux r√©sultats possibles.  Cela permet au d√©veloppeur de cr√©er une IA √† partir des donn√©es repr√©sentant les d√©cisions dans l'arborescence, en √©vitant son codage en dur.  Imaginez sous la forme d'un tableau: <br><br><img src="https://habrastorage.org/webt/dt/mx/zg/dtmxzgddk1mo585bhzy7-x_espw.png"><br><br>  C√¥t√© code, vous obtenez un syst√®me de lecture des cha√Ænes.  Cr√©ez un n≈ìud pour chacun d'eux, connectez la logique de d√©cision bas√©e sur la deuxi√®me colonne et les n≈ìuds enfants bas√©s sur les troisi√®me et quatri√®me colonnes.  Vous devez encore programmer les conditions et les actions, mais maintenant la structure du jeu sera plus compliqu√©e.  Vous y ajoutez des d√©cisions et des actions suppl√©mentaires, puis configurez l'int√©gralit√© de l'IA en modifiant simplement un fichier texte avec une d√©finition d'arbre.  Ensuite, transf√©rez le fichier au concepteur de jeu qui peut changer le comportement sans recompiler le jeu et changer le code. <br><br>  Les arbres de d√©cision sont tr√®s utiles lorsqu'ils sont construits automatiquement sur la base d'un grand nombre d'exemples (par exemple, en utilisant l'algorithme ID3).  Cela en fait un outil efficace et performant pour classer les situations en fonction des donn√©es re√ßues.  Cependant, nous allons au-del√† d'un simple syst√®me permettant aux agents de s√©lectionner des actions. <br><br><h3>  Sc√©narios </h3><br>  Nous avons d√©mont√© un syst√®me d'arbre de d√©cision qui utilisait des conditions et des actions pr√©-cr√©√©es.  Le concepteur d'IA peut organiser l'arborescence comme il le souhaite, mais il doit toujours compter sur l'encodeur qui a tout programm√©.  Et si nous pouvions donner au designer des outils pour cr√©er nos propres conditions ou actions? <br><br>  Pour emp√™cher le programmeur d'√©crire du code pour les conditions Is Ball Left Of Paddle et Is Ball Right Of Paddle, il peut cr√©er un syst√®me dans lequel le concepteur enregistrera les conditions de v√©rification de ces valeurs.  Ensuite, les donn√©es de l'arbre de d√©cision ressembleront √† ceci: <br><br><img src="https://habrastorage.org/webt/o9/nw/pe/o9nwpet07f-6xi7crzt5u34-orm.png"><br><br>  En substance, c'est la m√™me chose que dans le premier tableau, mais les solutions en elles-m√™mes ont leur propre code, un peu similaire √† la partie conditionnelle de l'instruction if.  C√¥t√© code, cela serait lu dans la deuxi√®me colonne pour les n≈ìuds de d√©cision, mais au lieu de rechercher une condition sp√©cifique √† remplir (Is Ball Left Of Paddle), il √©value l'expression conditionnelle et renvoie respectivement true ou false.  Cela se fait en utilisant le langage de script Lua ou Angelscript.  En les utilisant, le d√©veloppeur peut prendre des objets dans son jeu (balle et pagaie) et cr√©er des variables qui seront disponibles dans le script (ball.position).  De plus, le langage de script est plus simple que C ++.  Il ne n√©cessite pas d'√©tape de compilation compl√®te, il est donc id√©al pour un ajustement rapide de la logique du jeu et permet aux ¬´non-codeurs¬ª de cr√©er eux-m√™mes les fonctions n√©cessaires. <br><br>  Dans l'exemple ci-dessus, le langage de script est utilis√© uniquement pour √©valuer une expression conditionnelle, mais il peut √©galement √™tre utilis√© pour des actions.  Par exemple, les donn√©es Move Paddle Right peuvent devenir une instruction de script (ball.position.x + = 10).  Pour que l'action soit √©galement d√©finie dans le script, sans avoir besoin de programmer Move Paddle Right. <br><br>  Vous pouvez aller encore plus loin et √©crire un arbre de d√©cision complet dans un langage de script.  Ce sera un code sous la forme d'instructions conditionnelles cod√©es en dur, mais elles seront situ√©es dans des fichiers de script externes, c'est-√†-dire qu'elles peuvent √™tre modifi√©es sans recompiler l'int√©gralit√© du programme.  Souvent, vous pouvez modifier le fichier de script directement pendant le jeu pour tester rapidement diff√©rentes r√©actions de l'IA. <br><br><h3>  R√©ponse √† l'√©v√©nement </h3><br>  Les exemples ci-dessus sont parfaits pour Pong.  Ils ex√©cutent en continu le cycle Sense / Think / Act et agissent sur la base de l'√©tat le plus r√©cent du monde.  Mais dans les jeux plus complexes, vous devez r√©pondre aux √©v√©nements individuels et ne pas tout √©valuer √† la fois.  Pong est d√©j√† un exemple infructueux.  Choisissez-en un autre. <br><br>  Imaginez un tireur o√π les ennemis sont immobiles jusqu'√† ce qu'ils trouvent le joueur, apr√®s quoi ils agissent en fonction de leur "sp√©cialisation": quelqu'un courra pour "√©craser", quelqu'un attaquera de loin.  C'est toujours le syst√®me r√©actif de base - ¬´si le joueur est remarqu√©, alors faites quelque chose¬ª - mais il peut logiquement √™tre divis√© en l'√©v√©nement Player Seen (le joueur est remarqu√©) et la r√©action (s√©lectionnez la r√©ponse et ex√©cutez-la). <br><br>  Cela nous ram√®ne au cycle Sense / Think / Act.  Nous pouvons encoder la partie Sense, que chaque image v√©rifiera pour voir si l'IA du joueur est visible.  Sinon, rien ne se passe, mais s'il voit, alors l'√©v√©nement Joueur vu est d√©clench√©.  Le code aura une section s√©par√©e qui dit: "quand l'√©v√©nement Player Seen se produit, faites-le", o√π est la r√©ponse dont vous avez besoin pour vous r√©f√©rer aux parties Penser et Agir.  Ainsi, vous configurerez des r√©actions √† l'√©v√©nement Player Seen: ChargeAndAttack pour le personnage ¬´en pleine croissance¬ª et HideAndSnipe pour le tireur d'√©lite.  Ces relations peuvent √™tre cr√©√©es dans le fichier de donn√©es pour une modification rapide sans avoir √† recompiler.  Et ici, vous pouvez √©galement utiliser le langage de script. <br><br><h2>  Prendre des d√©cisions difficiles </h2><br>  Bien que les syst√®mes de r√©action simples soient tr√®s efficaces, il existe de nombreuses situations o√π ils ne sont pas suffisants.  Parfois, il est n√©cessaire de prendre diverses d√©cisions en fonction de ce que fait l'agent en ce moment, mais il est difficile d'imaginer cela comme une condition.  Parfois, il y a trop de conditions pour les repr√©senter efficacement dans un arbre de d√©cision ou un script.  Parfois, vous devez pr√©-√©valuer comment la situation va changer avant de d√©cider de la prochaine √©tape.  La r√©solution de ces probl√®mes n√©cessite des approches plus sophistiqu√©es. <br><br><h3>  Machine √† √©tats finis </h3><br>  La machine √† √©tats finis ou FSM (machine √† √©tats) est une fa√ßon de dire que notre agent est actuellement dans l'un des √©tats possibles et qu'il peut passer d'un √©tat √† l'autre.  Il existe un certain nombre de ces √©tats - d'o√π le nom.  Le meilleur exemple de vie est un feu de circulation.  √Ä diff√©rents endroits, diff√©rentes s√©quences de lumi√®res, mais le principe est le m√™me - chaque √©tat repr√©sente quelque chose (se tenir debout, partir, etc.).  Un feu de circulation n'est que dans un √©tat √† un moment donn√© et passe de l'un √† l'autre en fonction de r√®gles simples. <br><br>  Avec les PNJ dans les jeux, une histoire similaire.  Par exemple, prenez un garde avec les conditions suivantes: <br><br><ul><li>  Patrouille </li><li>  Attaquer </li><li>  Fuyant </li></ul><br>  Et de telles conditions pour changer son √©tat: <br><br><ul><li>  Si le garde voit l'ennemi, il attaque. </li><li>  Si le garde attaque, mais ne voit plus l'ennemi, il recommence √† patrouiller. </li><li>  Si le garde attaque, mais est gravement bless√©, il s'enfuit. </li></ul><br>  Vous pouvez √©galement √©crire des instructions if avec une variable d'√©tat de garde et diverses v√©rifications: y a-t-il un ennemi √† proximit√©, quel est le niveau de sant√© du PNJ, etc. Ajoutons quelques √©tats suppl√©mentaires: <br><br><ul><li>  Inaction (marche au ralenti) - entre les patrouilles. </li><li>  Recherche (recherche) - lorsque l'ennemi remarqu√© a disparu. </li><li>  Demandez de l'aide (Trouver de l'aide) - lorsque l'ennemi est vu, mais trop fort pour combattre seul avec lui. </li></ul><br>  Le choix pour chacun d'eux est limit√© - par exemple, un garde n'ira pas √† la recherche d'un ennemi cach√© s'il est en mauvaise sant√©. <br><br>  En fin de compte, l'√©norme liste de "si &lt;x et y, mais pas z&gt;, alors &lt;p&gt;" peut devenir trop lourde, nous devons donc formaliser une m√©thode qui nous permettra de garder √† l'esprit les √©tats et les transitions entre les √©tats.  Pour ce faire, nous prenons en compte tous les √©tats, et sous chaque √©tat, nous listons toutes les transitions vers d'autres √©tats, ainsi que les conditions n√©cessaires pour eux. <br><br><img src="https://habrastorage.org/webt/ut/25/j2/ut25j2aky0lx_ajk_rf2eeilgei.png"><br><br>  Cette table de transition d'√©tat est un moyen complet de repr√©senter FSM.  Dessinons un diagramme et obtenons un aper√ßu complet de la fa√ßon dont le comportement des PNJ change. <br><br><img src="https://habrastorage.org/webt/fg/7u/so/fg7uso5gla8wi4-fry0qne_bfvy.png"><br><br>  Le graphique refl√®te l'essence de la prise de d√©cision pour cet agent en fonction de la situation actuelle.  De plus, chaque fl√®che montre une transition entre les √©tats si la condition √† c√¥t√© d'elle est vraie. <br><br>  A chaque mise √† jour, on v√©rifie l'√©tat actuel de l'agent, on regarde la liste des transitions, et si les conditions de la transition sont remplies, il prend un nouvel √©tat.  Par exemple, chaque trame v√©rifie si le temporisateur de 10 secondes a expir√©, et si c'est le cas, le protecteur passe de la marche au ralenti √† la patrouille.  De la m√™me mani√®re, l'√©tat Attaque v√©rifie la sant√© de l'agent - s'il est faible, il passe √† l'√©tat Fuite. <br><br>  Il s'agit de g√©rer les transitions d'√©tats, mais qu'en est-il du comportement associ√© aux √©tats eux-m√™mes?  Concernant l'impl√©mentation du comportement r√©el pour un √©tat particulier, il existe g√©n√©ralement deux types de ¬´hooks¬ª dans lesquels nous attribuons des actions au FSM: <br><br><ul><li>  Actions que nous effectuons p√©riodiquement pour l'√©tat actuel. </li><li>  Les actions que nous entreprenons lors du passage d'un √©tat √† un autre. </li></ul><br>  Exemples pour le premier type.  √âtat de patrouille Chaque trame d√©placera l'agent le long de l'itin√©raire de patrouille.  √âtat d'attaque, chaque image tentera de lancer une attaque ou de passer dans un √©tat lorsque cela sera possible. <br><br>  Pour le deuxi√®me type, consid√©rez la transition ¬´si l'ennemi est visible et l'ennemi est trop fort, passez √† l'√©tat Finding Help.  L'agent doit choisir o√π aller pour obtenir de l'aide et enregistrer ces informations afin que l'√©tat de recherche d'aide sache o√π aller.  D√®s que de l'aide est trouv√©e, l'agent revient √† l'√©tat Attaquant.  √Ä ce stade, il voudra informer l'alli√© de la menace, afin que l'action NotifyFriendOfThreat puisse se produire. <br><br>  Et encore une fois, nous pouvons regarder ce syst√®me √† travers le prisme du cycle Sense / Think / Act.  Sense se traduit par des donn√©es utilis√©es par la logique de transition.  Pensez - transitions disponibles dans chaque √©tat.  Et l'acte est r√©alis√© par des actions effectu√©es p√©riodiquement au sein de l'√âtat ou lors de transitions entre √âtats. <br><br>  Parfois, l'interrogation continue des conditions de transition peut √™tre co√ªteuse.  Par exemple, si chaque agent effectue des calculs complexes sur chaque trame pour d√©terminer s'il voit des ennemis et comprendre s'il est possible de passer de l'√©tat de patrouille √† l'attaque, cela prendra beaucoup de temps au processeur. <br><br>  Des changements importants dans l'√©tat du monde peuvent √™tre consid√©r√©s comme des √©v√©nements qui seront trait√©s au fur et √† mesure qu'ils se produisent.  Au lieu que FSM v√©rifie la condition de transition ¬´mon agent peut-il voir le joueur?¬ª √Ä chaque trame, vous pouvez configurer un syst√®me distinct pour effectuer des v√©rifications moins souvent (par exemple, 5 fois par seconde).  Et le r√©sultat est de donner au joueur vu lorsque le ch√®que est r√©ussi. <br><br>  Ceci est transmis au FSM, qui doit maintenant entrer dans la condition re√ßue de l'√©v√©nement Joueur vu et r√©agir en cons√©quence.  Le comportement r√©sultant est le m√™me sauf pour un d√©lai presque imperceptible avant de r√©pondre.  Mais la performance est devenue meilleure √† la suite de la s√©paration d'une partie de Sense dans une partie distincte du programme. <br><br><h3>  Machine √† √©tats finis hi√©rarchique </h3><br>  Cependant, travailler avec de grands FSM n'est pas toujours pratique.  Si nous voulons √©tendre l'√©tat de l'attaque, en la rempla√ßant par MeleeAttacking (m√™l√©e) et RangedAttacking (√† distance) s√©par√©s, nous devrons changer les transitions de tous les autres √©tats qui m√®nent √† l'√©tat Attacking (actuel et futur). <br><br>  Vous avez s√ªrement remarqu√© que dans notre exemple, il y a beaucoup de transitions en double.  La plupart des transitions √† l'√©tat de ralenti sont identiques aux transitions √† l'√©tat de patrouille.  Ce serait bien de ne pas r√©p√©ter, surtout si nous ajoutons des √©tats plus similaires.  Il est logique de regrouper la marche au ralenti et les patrouilles sous l'√©tiquette commune de ¬´non-combat¬ª, o√π il n'y a qu'un seul ensemble commun de transitions pour combattre les √âtats.  Si nous pr√©sentons cette √©tiquette comme un √©tat, la marche au ralenti et la patrouille deviendront des sous-√©tats.  Un exemple d'utilisation d'une table de conversion distincte pour un nouveau sous-√©tat sans combat: <br><br>  <i>Les principales conditions:</i> <br><img src="https://habrastorage.org/webt/jk/6j/u6/jk6ju6k3dtxhbou06sqelhixykm.png"><br><br>  <i>Statut hors combat:</i> <br><img src="https://habrastorage.org/webt/b4/yn/ae/b4ynaedk42xhvikbzqjsbh9itgc.png"><br><br>  Et sous forme de graphique: <br><br><img src="https://habrastorage.org/webt/ni/li/dv/nilidvj4kqtrime1pgyzv11gh10.png"><br><br>  Il s'agit du m√™me syst√®me, mais avec un nouvel √©tat de non-combat, qui inclut la marche au ralenti et la patrouille.  Avec chaque √©tat contenant des FSM avec des sous-√©tats (et ces sous-√©tats, √† leur tour, contiennent leurs propres FSM - et ainsi de suite, autant que vous en avez besoin), nous obtenons une machine √† √©tats finis hi√©rarchique ou HFSM (machine √† √©tats hi√©rarchique).  Ayant regroup√© un √©tat non combattant, nous avons supprim√© un tas de transitions redondantes.  Nous pouvons faire de m√™me pour tous les nouveaux √âtats ayant des transitions communes.  Par exemple, si √† l'avenir nous √©tendons l'√©tat d'attaque aux √©tats de m√™l√©e et d'attaque de missiles, ce seront des sous-√©tats qui se croiseront en fonction de la distance √† l'ennemi et de la pr√©sence de munitions.  En cons√©quence, des mod√®les de comportement complexes et des sous-mod√®les de comportement peuvent √™tre repr√©sent√©s avec un minimum de transitions dupliqu√©es. <br><br><h3>   </h3><br>  HFSM      .   ,   ,            .        ,  .           .    ,    ,            . ,      25%,  ,      ,     ,    ‚Äî        .            25%  10%,     . <br><br>       ,    ¬´   ¬ª,     ,            .    . <br><br>     ,           :    ¬´¬ª ,     ,   ,  .     : <br><br><ul><li>       : Succeeded (  ), Failed (  )  Running (        ). </li><li>         .    Decorator,      .   Succeed,      . </li><li> ,  ,   Running    . </li></ul><br>             .  HFSM        : <br><br><img src="https://habrastorage.org/webt/1i/e5/4i/1ie54izd-h-ybfpwrb-yowau724.png"><br><br>           Idling/Patrolling   Attacking   .   ,    ,     Fleeing,   ,      ‚Äî Patrolling, Idling, Attacking   . <br><br><img src="https://habrastorage.org/webt/iw/je/uu/iwjeuuax51z5qxgmg5h4zcbm4tg.png"><br><br>    ‚Äî     ,            .     ,     ‚Äî         ,     ?   ,    ‚Äî  ,      Idling   10    ,      ,    ? <br><br>     . ,        .        ,        . <br><br><h3> Utility-based system </h3><br>       . ,          ,        .  ,         ,           . <br><br> Utility-based system (,   )     .  ,      ,      ,     .   ‚Äî   ,         . <br><br>         ,            .    FSM,   ,        ,  .  ,         ( ,    ).       ,      . <br><br>       ‚Äî ,  0 ( )  100 ( ).      ,     .      : <br><br><img src="https://habrastorage.org/webt/ty/an/id/tyanidrfvaoee_ekrdretfmyqhg.png"><br><br>     ‚Äî       .       .   ,    ,    ,   Fleeing,  FindingHelp    .   FindingHelp   .  ,       50,      .          . <br><br>         ,      .          . ,  Fleeing     ,    ,   Attacking   ,    . -   Fleeing    Attacking   ,   ,         .          ,        ,     FSM. <br><br>        .            .  The Sims,     ,     ‚Äî    ¬´¬ª,    .   ,        ,     EatFood     ,     ,   ,    EatFood  . <br><br>         ,  Utility-based system        ,      .             .  ,       Utility    ,  ,    . <br><br><h2>    </h2><br>       ,      ,  ,    .            ?    ,    ,     ,      ,     ?   . <br><br><h3>  </h3><br>     ,      ,    ,        .        ,   ,     . .   Sense/Think/Act,   ,   Think  ,   Act     .      ,      ,        .        ‚Äî ,     .  ,    ,          .   : <br><br> <i>desired_travel = destination_position ‚Äì agent_position</i> <br><br>  2D-.     (-2,-2),   -  -   (30, 20),     ,    ‚Äî (32, 22). ,      ‚Äî      5   ,            (4.12, 2.83).            8 . <br><br>      .       ,     ,       5 / (   ),   .      ,         . <br><br>      ‚Äî ,   ,   ,        .        .     steering behaviours,      : Seek (), Flee (), Arrival ()  . .    ,         ,           ,       . <br><br>      . Seek  Arrival ‚Äî       . Obstacle Avoidance ( )  Separation ()   ,       . Alignment ()  Cohesion ()     .    steering behaviours            . ,   Arrival, Separation  Obstacle Avoidance,        .          . <br><br>    ,      ‚Äî  ,      -  Arrival  Obstacle Avoidance.    ,  ,     .  :     ,          . <br><br>        ,    ,   -   . <br><br><h3>   </h3><br> Steering behaviours         (   ),       ‚Äî        .      pathfinding ( ),            . <br><br>   ‚Äî                .  -     ,           ,     .    .         ,          ( ,     ).  ,     Breadth-First Search  BFS (   ).         ( breadth, ¬´¬ª).      ,  ,      ‚Äî         ,       ,       . <br><br><img src="https://habrastorage.org/webt/ik/gg/_n/ikgg_n7oyigrgvo1av12jtsaga4.gif"><br><br>      ,     .     (, pathfinding) ‚Äî  ,   ,    . <br><br> ,        ,   steering behaviours,     ‚Äî   1   2,    2   3   .   ‚Äî     ,    ‚Äî         . -        . <br><br>   BFS    ‚Äî       ¬´¬ª ,   ¬´¬ª.        A* (A star).   ,     - (  ,       ),         ,      ,     .     ,     ‚Äî ¬´¬ª      (    )   ,        (    ). <br><br><img src="https://habrastorage.org/webt/3k/jb/al/3kjbal-iagj4ovxicix2swrbsxq.gif"><br><br>    ,        ,    ,    .    ,    BFS,        ‚Äî        . <br><br><h3>    </h3><br>  Mais la plupart des jeux ne sont pas dispos√©s sur la grille, et souvent cela ne peut se faire sans compromettre le r√©alisme.  Des compromis sont n√©cessaires.  Quelle taille doivent avoir les carr√©s?  Trop grand - et ils ne pourront pas imaginer correctement de petits couloirs ou virages, trop petits - il y aura trop de carr√©s √† rechercher, ce qui prendra finalement beaucoup de temps. <br><br>  La premi√®re chose √† comprendre est que la grille nous donne un graphe de n≈ìuds connect√©s.  Les algorithmes A * et BFS fonctionnent r√©ellement sur les graphiques et ne se soucient pas du tout de notre grille.  Nous pourrions placer les n≈ìuds n'importe o√π dans le monde du jeu: s'il y a une connexion entre deux n≈ìuds connect√©s, ainsi qu'entre les points de d√©but et de fin et au moins l'un des n≈ìuds, l'algorithme fonctionnera aussi bien qu'avant.  Ceci est souvent appel√© le syst√®me de points de cheminement, car chaque n≈ìud repr√©sente une position significative dans le monde, qui peut faire partie d'un nombre illimit√© de chemins hypoth√©tiques. <br><br><img src="https://habrastorage.org/webt/k7/ab/gq/k7abgqdwnx7efuqf8pqw0p6nbqm.png"><br>  <i>Exemple 1: un n≈ìud dans chaque carr√©.</i>  <i>La recherche commence au n≈ìud o√π se trouve l'agent et se termine au n≈ìud du carr√© souhait√©.</i> <br><br><img src="https://habrastorage.org/webt/m6/lx/5a/m6lx5a5wleqbvxthzcoajeat_us.png"><br>  <i>Exemple 2: un plus petit ensemble de n≈ìuds (waypoints).</i>  <i>La recherche commence au carr√© avec l'agent, passe par le nombre de n≈ìuds requis, puis continue vers la destination.</i> <br><br>  Il s'agit d'un syst√®me compl√®tement flexible et puissant.  Mais vous devez √™tre prudent lorsque vous d√©cidez o√π et comment placer le point de cheminement, sinon les agents peuvent tout simplement ne pas voir le point le plus proche et ne pourront pas d√©marrer le chemin.  Il serait plus facile de d√©finir automatiquement des points de cheminement en fonction de la g√©om√©trie du monde. <br><br>  Ensuite, un maillage de navigation ou un maillage de navigation appara√Æt.  Il s'agit g√©n√©ralement d'un maillage 2D de triangles qui recouvre la g√©om√©trie du monde - partout o√π l'agent est autoris√© √† marcher.  Chacun des triangles de la grille devient un n≈ìud dans le graphique et a jusqu'√† trois triangles adjacents qui deviennent des n≈ìuds adjacents dans le graphique. <br><br>  Cette image est un exemple du moteur Unity - il a analys√© la g√©om√©trie dans le monde et cr√©√© navmesh (bleu clair dans la capture d'√©cran).  Chaque polygone dans navmesh est une zone dans laquelle un agent peut se tenir ou se d√©placer d'un polygone √† un autre polygone.  Dans cet exemple, les polygones sont plus petits que les √©tages sur lesquels ils se trouvent - r√©alis√©s afin de prendre en compte les dimensions de l'agent, qui iront au-del√† de sa position nominale. <br><br><img src="https://habrastorage.org/webt/-y/ip/ic/-yipico3akqxyv8hhubbe0rzkgk.png"><br><br>  Nous pouvons rechercher l'itin√©raire √† travers cette grille, en utilisant √† nouveau l'algorithme A *.  Cela nous donnera un itin√©raire presque parfait dans le monde qui prend en compte toute la g√©om√©trie et ne n√©cessite pas de n≈ìuds et de waypoints suppl√©mentaires. <br><br>  Pathfinding est un sujet trop √©tendu sur lequel une section de l'article ne suffit pas.  Si vous souhaitez l'√©tudier plus en d√©tail, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site d'Amit Patel vous</a> y aidera. <br><br><h2>  Planification </h2><br>  Nous avons veill√© √† ce que, parfois, il ne suffit pas simplement de choisir une direction et de se d√©placer - nous devons choisir un itin√©raire et effectuer plusieurs virages pour arriver √† la destination souhait√©e.  Nous pouvons r√©sumer cette id√©e: atteindre l'objectif n'est pas seulement la prochaine √©tape, mais une s√©quence enti√®re, o√π parfois vous devez regarder en avant quelques √©tapes pour savoir quelle devrait √™tre la premi√®re.  C'est ce qu'on appelle la planification.  L'orientation peut √™tre consid√©r√©e comme l'un des nombreux ajouts de planification.  Du point de vue de notre cycle Sense / Think / Act, c'est l√† que la partie Think planifie plusieurs parties Act pour l'avenir. <br><br>  Prenons l'exemple du jeu de soci√©t√© Magic: The Gathering.  Nous allons d'abord avec un tel jeu de cartes en main: <br><br><ul><li>  Marais - donne 1 mana noir (carte de la Terre). </li><li>  For√™t - donne 1 mana vert (carte de la terre). </li><li>  Magicien fugitif - N√©cessite 1 mana bleu pour invoquer. </li><li>  Mystique elfique - N√©cessite 1 mana vert pour invoquer. </li></ul><br>  Nous ignorons les trois cartes restantes pour le rendre plus facile.  Selon les r√®gles, un joueur est autoris√© √† jouer 1 carte de terrain par tour, il peut ¬´engager¬ª cette carte pour en extraire du mana, puis utiliser des sorts (y compris des cr√©atures invoqu√©es) en fonction de la quantit√© de mana.  Dans cette situation, le joueur humain sait que vous devez jouer √† Forest, ¬´taper¬ª 1 mana vert, puis appeler Elvish Mystic.  Mais comment devinez-vous l'IA du jeu? <br><br><h3>  Planification simple </h3><br>  L'approche triviale consiste √† essayer chaque action √† tour de r√¥le jusqu'√† ce qu'il y en ait une appropri√©e.  En regardant les cartes, l'IA voit ce que Swamp peut jouer.  Et le joue.  Y a-t-il d'autres actions √† gauche ce tour-ci?  Il ne peut invoquer ni Elfique Mystique ni Fugitif Magicien, car leurs invocations n√©cessitent respectivement du mana vert et bleu, et Swamp ne donne que du mana noir.  Et il ne pourra pas jouer √† Forest, car il a d√©j√† jou√© √† Swamp.  Ainsi, l'IA du jeu a respect√© les r√®gles, mais l'a mal fait.  Cela peut √™tre am√©lior√©. <br><br>  La planification peut trouver une liste d'actions qui am√®nent le jeu √† son √©tat souhait√©.  Tout comme chaque carr√© sur le chemin avait des voisins (dans la recherche de chemin), chaque action du plan a aussi des voisins ou des successeurs.  Nous pouvons rechercher ces actions et les actions suivantes jusqu'√† ce que nous atteignions l'√©tat souhait√©. <br><br>  Dans notre exemple, le r√©sultat souhait√© est ¬´d'invoquer une cr√©ature, si possible¬ª.  Au d√©but du mouvement, nous ne voyons que deux actions possibles autoris√©es par les r√®gles du jeu: <br><br>  <i>1. Jouer √† Swamp (r√©sultat: Swamp dans le jeu)</i> <i><br></i>  <i>2. Jouer √† Forest (r√©sultat: Forest dans le jeu)</i> <br><br>  Chaque action entreprise peut conduire √† d'autres actions et en fermer d'autres, encore une fois, selon les r√®gles du jeu.  Imaginez que nous avons jou√© √† Swamp - cela supprimera Swamp √† l'√©tape suivante (nous l'avons d√©j√† jou√©), cela supprimera √©galement Forest (car selon les r√®gles, vous pouvez jouer une carte du terrain par tour).  Apr√®s cela, l'IA ajoute comme √©tape suivante - obtenir 1 mana noir, car il n'y a pas d'autres options.  S'il va plus loin et choisit Tap the Swamp, il recevra 1 unit√© de mana noir et ne pourra rien en faire. <br><br>  <i>1. Jouer √† Swamp (r√©sultat: Swamp dans le jeu)</i> <i><br></i>  <i>1.1 ¬´Tap¬ª Swamp (r√©sultat: Swamp ¬´tap¬ª, +1 unit√© de mana noir)</i> <i><br></i>  <i>Aucune action disponible - FIN</i> <i><br></i>  <i>2. Jouer √† Forest (r√©sultat: Forest dans le jeu)</i> <br><br>  La liste des actions √©tait courte, nous sommes dans une impasse.  R√©p√©tez le processus pour l'√©tape suivante.  Nous jouons √† Forest, ouvrons l'action "obtenir 1 mana vert", qui √† son tour ouvrira la troisi√®me action - l'appel d'Elvish Mystic. <br><br>  <i>1. Jouer √† Swamp (r√©sultat: Swamp dans le jeu)</i> <i><br></i>  <i>1.1 ¬´Tap¬ª Swamp (r√©sultat: Swamp ¬´tap¬ª, +1 unit√© de mana noir)</i> <i><br></i>  <i>Aucune action disponible - FIN</i> <i><br></i>  <i>2. Jouer √† Forest (r√©sultat: Forest dans le jeu)</i> <i><br></i>  <i>2.1 For√™t ¬´Tap¬ª (r√©sultat: ¬´Tap¬ª Forest, +1 unit√© de mana verte)</i> <i><br></i>  <i>2.1.1 Invocation d'un elfique mystique (r√©sultat: elfique mystique dans le jeu, -1 unit√© de mana vert)</i> <i><br></i>  <i>Aucune action disponible - FIN</i> <br><br>  Enfin, nous avons examin√© toutes les actions possibles et trouv√© un plan appelant la cr√©ature. <br><br>  Ceci est un exemple tr√®s simplifi√©.  Il est conseill√© de choisir le meilleur plan possible, et non celui qui r√©pond √† certains crit√®res.  En r√®gle g√©n√©rale, vous pouvez √©valuer les plans potentiels en fonction du r√©sultat final ou des avantages totaux de leur mise en ≈ìuvre.  Vous pouvez vous ajouter 1 point pour jouer une carte de la terre et 3 points pour d√©fier une cr√©ature.  Jouer √† Swamp serait un plan donnant 1 point.  Et pour jouer √† Forest ‚Üí Tap the Forest ‚Üí faites appel √† Elvish Mystic - il donnera imm√©diatement 4 points. <br><br>  C'est ainsi que la planification fonctionne dans Magic: The Gathering, mais selon la m√™me logique, cela s'applique dans d'autres situations.  Par exemple, d√©placez un pion pour faire de la place pour que l'√©v√™que se d√©place aux √©checs.  Ou couvrez-vous derri√®re un mur pour tirer en toute s√©curit√© sur XCOM comme √ßa.  En g√©n√©ral, vous obtenez le point. <br><br><h3>  Planification am√©lior√©e </h3><br>  Parfois, il y a trop d'actions potentielles pour consid√©rer toutes les options possibles.  Revenons √† l'exemple avec Magic: The Gathering: disons que dans le jeu et sur vos mains il y a plusieurs cartes de terrain et de cr√©atures - le nombre de combinaisons possibles de mouvements peut √™tre dans les dizaines.  Il existe plusieurs solutions au probl√®me. <br><br>  La premi√®re fa√ßon est le cha√Ænage arri√®re.  Au lieu de trier toutes les combinaisons, il est pr√©f√©rable de commencer par le r√©sultat final et d'essayer de trouver un itin√©raire direct.  Au lieu du chemin de la racine de l'arbre √† une feuille sp√©cifique, nous nous d√©pla√ßons dans la direction oppos√©e - de la feuille √† la racine.  Cette m√©thode est plus simple et plus rapide. <br><br>  Si l'adversaire a 1 unit√© de sant√©, vous pouvez trouver un plan pour "infliger 1 ou plusieurs unit√©s de d√©g√¢ts".  Pour y parvenir, un certain nombre de conditions doivent √™tre remplies: <br><br>  1. Les d√©g√¢ts peuvent √™tre caus√©s par un sort - ils devraient √™tre dans la main. <br>  2. Pour lancer un sort, vous avez besoin de mana. <br>  3. Pour obtenir du mana, vous devez jouer une carte de terrain. <br>  4. Pour jouer une carte de la terre - vous devez l'avoir en main. <br><br>  Une autre m√©thode consiste √† rechercher en priorit√©.  Au lieu de parcourir tous les chemins, nous choisissons le plus appropri√©.  Le plus souvent, cette m√©thode donne un plan optimal sans frais de recherche inutiles.  A * est la forme de la meilleure premi√®re recherche - en explorant les itin√©raires les plus prometteurs d√®s le d√©but, il peut d√©j√† trouver la meilleure fa√ßon sans avoir √† v√©rifier d'autres options. <br><br>  Monte Carlo Tree Search est une option int√©ressante et de plus en plus populaire pour la recherche du meilleur avant tout.  Au lieu de deviner quels plans sont meilleurs que d'autres lors du choix de chaque action suivante, l'algorithme s√©lectionne des successeurs al√©atoires √† chaque √©tape jusqu'√† la fin (lorsque le plan a conduit √† la victoire ou √† la d√©faite).  Ensuite, le r√©sultat final est utilis√© pour augmenter ou diminuer la pond√©ration des options pr√©c√©dentes.  R√©p√©tant ce processus plusieurs fois de suite, l'algorithme donne une bonne estimation de la prochaine √©tape qui est la meilleure, m√™me si la situation change (si l'adversaire prend des mesures pour emp√™cher le joueur). <br><br>  L'histoire de la planification dans les jeux ne se fera pas sans la planification d'actions orient√©es vers les objectifs ou GOAP (planification d'actions orient√©es vers les objectifs).  C'est une m√©thode largement utilis√©e et discut√©e, mais √† part quelques d√©tails distinctifs, c'est essentiellement la m√©thode de cha√Ænage vers l'arri√®re dont nous avons parl√© plus t√¥t.  Si la t√¢che √©tait de ¬´d√©truire le joueur¬ª, et que le joueur est √† couvert, le plan peut √™tre le suivant: d√©truire avec une grenade ‚Üí le r√©cup√©rer ‚Üí le laisser tomber. <br><br>  Il y a g√©n√©ralement plusieurs objectifs, chacun avec sa propre priorit√©.  Si l'objectif avec la priorit√© la plus √©lev√©e ne peut pas √™tre atteint (aucune combinaison d'actions ne cr√©e un plan pour ¬´d√©truire le joueur¬ª parce que le joueur n'est pas visible), l'IA retournera aux cibles avec une priorit√© inf√©rieure. <br><br><h2>  Formation et adaptation </h2><br>  Nous avons d√©j√† dit que l'IA de jeu n'utilise g√©n√©ralement pas le machine learning car elle n'est pas adapt√©e √† la gestion des agents en temps r√©el.  Mais cela ne signifie pas que vous ne pouvez rien emprunter dans cette r√©gion.  Nous voulons un tel adversaire dans un jeu de tir √† partir duquel nous pouvons apprendre quelque chose.  Par exemple, d√©couvrez les meilleures positions sur la carte.  Ou un adversaire dans un jeu de combat qui bloquerait les combos fr√©quemment utilis√©s par le joueur, motivant les autres √† utiliser.  L'apprentissage automatique dans de telles situations peut donc √™tre tr√®s utile. <br><br><h3>  Statistiques et probabilit√©s </h3><br>  Avant de passer √† des exemples complexes, nous allons estimer jusqu'o√π nous pouvons aller en prenant quelques mesures simples et en les utilisant pour prendre des d√©cisions.  Par exemple, une strat√©gie en temps r√©el - comment d√©terminer si un joueur peut lancer une attaque dans les premi√®res minutes d'une partie et quelle d√©fense se pr√©parer contre cela?  Nous pouvons √©tudier l'exp√©rience pass√©e du joueur pour comprendre quelle pourrait √™tre la r√©action future.  Pour commencer, nous ne disposons pas de telles donn√©es initiales, mais nous pouvons les collecter - chaque fois que l'IA joue contre une personne, il peut enregistrer l'heure de la premi√®re attaque.  Apr√®s plusieurs sessions, nous obtiendrons le temps moyen pendant lequel le joueur attaquera √† l'avenir. <br><br>  Les valeurs moyennes ont un probl√®me: si un joueur ¬´d√©cide¬ª 20 fois et joue lentement 20 fois, alors les valeurs n√©cessaires seront quelque part au milieu, et cela ne nous donnera rien d'utile.  Une solution consiste √† limiter l'entr√©e - vous pouvez consid√©rer les 20 derni√®res pi√®ces. <br><br>  Une approche similaire est utilis√©e pour √©valuer la probabilit√© de certaines actions, en supposant que les pr√©f√©rences pass√©es du joueur seront les m√™mes √† l'avenir.  Si un joueur nous attaque cinq fois avec une boule de feu, deux fois avec la foudre et une fois avec le corps √† corps, il est √©vident qu'il pr√©f√®re une boule de feu.  Nous extrapolons et voyons la probabilit√© d'utiliser diverses armes: boule de feu = 62,5%, foudre = 25% et m√™l√©e = 12,5%.  Notre IA de jeu doit se pr√©parer √† la protection contre les incendies. <br><br>  Une autre m√©thode int√©ressante consiste √† utiliser le Naive Bayes Classifier (classificateur bay√©sien na√Øf) pour √©tudier de grands volumes de donn√©es d'entr√©e et classer la situation afin que l'IA r√©ponde de la bonne mani√®re.  Les classificateurs bay√©siens sont surtout connus pour utiliser des filtres anti-spam de messagerie.  L√†, ils recherchent des mots, les comparent √† l'endroit o√π ces mots sont apparus plus t√¥t (dans le spam ou non) et tirent des conclusions sur les lettres entrantes.  Nous pouvons faire de m√™me, m√™me avec moins d'entr√©e.  Sur la base de toutes les informations utiles que l'IA voit (par exemple, quelles unit√©s ennemies sont cr√©√©es, ou quels sorts elles utilisent, ou quelles technologies elles ont explor√©es), et le r√©sultat final (guerre ou paix, "√©craser" ou d√©fendre, etc.) - nous s√©lectionnerons le comportement AI souhait√©. <br><br>  Toutes ces m√©thodes de formation sont suffisantes, mais il est conseill√© de les utiliser sur la base des donn√©es des tests.  L'IA apprendra √† s'adapter aux diff√©rentes strat√©gies utilis√©es par vos testeurs de jeu.  Une IA qui s'adapte √† un joueur apr√®s une sortie peut devenir trop pr√©visible, ou vice versa, trop complexe pour gagner. <br><br><h3>  Adaptation bas√©e sur la valeur </h3><br>  Compte tenu du contenu de notre monde du jeu et des r√®gles, nous pouvons changer l'ensemble de valeurs qui affectent la prise de d√©cision, et pas seulement utiliser les donn√©es d'entr√©e.  Nous faisons ceci: <br><br><ul><li>  Laissez l'IA collecter des donn√©es sur l'√©tat du monde et les √©v√©nements cl√©s pendant le jeu (comme indiqu√© ci-dessus). </li><li>  Modifions certaines valeurs importantes en fonction de ces donn√©es. </li><li>  Nous prenons nos d√©cisions en fonction du traitement ou de l'√©valuation de ces valeurs. </li></ul><br>  Par exemple, un agent dispose de plusieurs salles pour choisir un jeu de tir √† la premi√®re personne sur la carte.  Chaque chambre a sa propre valeur, ce qui d√©termine √† quel point il est souhaitable de visiter.  L'IA choisit au hasard la pi√®ce √† parcourir en fonction de la valeur de la valeur.  Ensuite, l'agent se souvient dans quelle pi√®ce il a √©t√© tu√© et r√©duit sa valeur (la probabilit√© qu'il y retourne).  De m√™me pour la situation inverse - si l'agent d√©truit de nombreux adversaires, la valeur de la salle augmente. <br><br><h3>  Mod√®le de Markov </h3><br>  Et si nous utilisons les donn√©es collect√©es pour les pr√©visions?  Si nous nous souvenons de chaque pi√®ce dans laquelle nous voyons le joueur pendant une certaine p√©riode de temps, nous pr√©dirons dans quelle pi√®ce le joueur peut entrer.  En suivant et en enregistrant le mouvement du joueur dans les pi√®ces (valeurs), nous pouvons les pr√©dire. <br><br>  Prenons trois pi√®ces: rouge, verte et bleue.  Ainsi que les observations que nous avons enregistr√©es en regardant une session de jeu: <br><br><img src="https://habrastorage.org/webt/cz/qm/-k/czqm-khdlmnybf2c4amu6v_yrc0.png"><br><br>  Le nombre d'observations pour chaque pi√®ce est presque √©gal - nous ne savons toujours pas o√π faire une bonne place pour une embuscade.  La collecte de statistiques est √©galement compliqu√©e par la r√©apparition de joueurs qui apparaissent uniform√©ment sur la carte.  Mais les donn√©es sur la pi√®ce voisine, qu'elles entrent apr√®s avoir apparu sur la carte, sont d√©j√† utiles. <br><br>  On peut voir que la salle verte convient aux joueurs - la plupart des gens rouges y vont, dont 50% restent l√† et plus loin.  La chambre bleue, au contraire, n'est pas populaire, elle n'est presque jamais visit√©e, et si elle l'est, elle ne s'attarde pas. <br><br>  Mais les donn√©es nous disent quelque chose de plus important - lorsque le joueur est dans la salle bleue, la prochaine pi√®ce dans laquelle nous le verrons le plus probablement sera rouge, pas verte.  Malgr√© le fait que la salle verte soit plus populaire que la rouge, la situation change si le joueur est en bleu.  L'√©tat suivant (c'est-√†-dire la pi√®ce dans laquelle le joueur ira) d√©pend de l'√©tat pr√©c√©dent (c'est-√†-dire la pi√®ce dans laquelle le joueur se trouve maintenant).  Gr√¢ce √† l'√©tude des d√©pendances, nous ferons des pr√©visions plus pr√©cises que si nous calculions simplement les observations ind√©pendamment les unes des autres. <br><br>  La pr√©diction d'un √©tat futur sur la base de donn√©es d'√©tat pass√©es s'appelle le mod√®le de Markov, et de tels exemples (avec des pi√®ces) sont appel√©s cha√Ænes de Markov.  √âtant donn√© que les mod√®les repr√©sentent la probabilit√© de changements entre les √©tats successifs, ils sont visuellement affich√©s sous forme de FSM avec une probabilit√© proche de chaque transition.  Auparavant, nous utilisions FSM pour repr√©senter l'√©tat comportemental dans lequel l'agent se trouvait, mais ce concept s'applique √† n'importe quel √©tat, qu'il soit li√© √† l'agent ou non.  Dans ce cas, les √©tats repr√©sentent la chambre occup√©e par l'agent: <br><br><img src="https://habrastorage.org/webt/xj/jn/zn/xjjnznthergzfs89ixqdghp7bjq.png"><br><br>  Il s'agit d'une version simple de la repr√©sentation de la probabilit√© relative de changements d'√©tats, ce qui donne √† l'IA l'occasion de pr√©dire l'√©tat suivant.  Vous pouvez pr√©voir quelques pas en avant. <br><br>  Si le joueur est dans la salle verte, il y a 50% de chances qu'il y reste lors de la prochaine observation.  Mais quelle est la probabilit√© qu'il soit toujours l√† m√™me apr√®s?  Il y a non seulement une chance que le joueur soit rest√© dans la salle verte apr√®s deux observations, mais aussi une chance qu'il soit parti et soit revenu.  Voici le nouveau tableau avec les nouvelles donn√©es: <br><br><img src="https://habrastorage.org/webt/te/wc/ya/tewcyajzsv_ys-9bro4mjdhtpte.png"><br><br>  Cela montre que la chance de voir un joueur dans la salle verte apr√®s deux observations sera de 51% - 21%, qu'il viendra de la salle rouge, 5% d'entre eux, que le joueur visitera la salle bleue entre eux, et 25%, que le joueur ne le fait pas quittera la salle verte. <br><br>  Un tableau n'est qu'un outil visuel - une proc√©dure ne n√©cessite qu'une multiplication des probabilit√©s √† chaque √©tape.  Cela signifie que vous pouvez regarder loin dans l'avenir avec un seul amendement: nous supposons que la chance d'entrer dans une pi√®ce d√©pend compl√®tement de la pi√®ce actuelle.  C'est ce qu'on appelle la propri√©t√© Markov - l'√©tat futur ne d√©pend que du pr√©sent.  Mais ce n'est pas tout √† fait exact.  Les joueurs peuvent prendre des d√©cisions en fonction d'autres facteurs: le niveau de sant√© ou la quantit√© de munitions.  Comme nous ne fixons pas ces valeurs, nos pr√©visions seront moins pr√©cises. <br><br><h3>  N-grammes </h3><br>         - ?  La m√™me chose!      ,     ,    -. <br><br>      ‚Äî    (, Kick, Punch  Block)         . ,    Kick, Kick, Punch,    SuperDeathFist,           ,    . <br><br><img src="https://habrastorage.org/webt/2m/ji/l4/2mjil4fdhjrro3em8vde-zcxhak.png"><br> (  ,     SuperDeathFist.) <br><br>    ,    Kick,    Kick,   ,     Punch.     - SuperDeathFist   ,   . <br><br>     N- (N-grams),  N ‚Äî   .      3- (),  :       .   5-        . <br><br>      N-.   N   ,     . , 2- ()   Kick, Kick  Kick, Punch,     Kick, Kick, Punch,       SuperDeathFist. <br><br>   ,          ,       .        Kick, Punch  Block,    10-,    60   . <br><br>       ‚Äî   ¬´ / ¬ª  ,         . 3-    N-      ,    (   N-)    ,    ‚Äî .         Kick  Kick   Kick  Punch.        , ,  ,       .     ,          ,  -  . <br><br><h2>  Conclusion </h2><br>            .    ,          . <br><br>           . ,  ,     .   ,     : <br><br><ul><li>   ,    ,      </li><li>   / (minimax  alpha-beta pruning) </li><li>   (,      ) </li><li>        </li><li>     ( ,        ) </li><li>   (   ) </li><li>   ( ,  anytime,  timeslicing) </li></ul><br> -  : <br><br> 1.  GameDev.net  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br> 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AiGameDev.com</a>             . <br> 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The GDC Vault</a>       GDC AI,     . <br> 4.        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI Game Programmers Guild</a> . <br> 5.  ,     ,    YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI and Games</a>        . <br><br>   : <br><br> 1.   Game AI Pro     , ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26xs%3D1%26isjs%3D1%26url%3Dhttps%253A%252F%252Famzn.to%252F2KGoB8n%26xguid%3Df8ad586e5984991508efff4754027dbd%26xuuid%3D305451ecead59d76ca830fded0aab276%26xsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26xcreo%3D0%26xed%3D0%26sref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26pref%3D">Game AI Pro: Collected Wisdom of Game AI Professionals</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26xs%3D1%26isjs%3D1%26url%3Dhttps%253A%252F%252Famzn.to%252F2KFKyoe%26xguid%3Df8ad586e5984991508efff4754027dbd%26xuuid%3D305451ecead59d76ca830fded0aab276%26xsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26xcreo%3D0%26xed%3D0%26sref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26pref%3D">Game AI Pro 2: Collected Wisdom of Game AI Professionals</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Game AI Pro 3: Collected Wisdom of Game AI Professionals</a> <br><br> 2.  AI Game Programming Wisdom ‚Äî   Game AI Pro.     ,      . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI Game Programming Wisdom 1</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI Game Programming Wisdom 2</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI Game Programming Wisdom 3</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AI Game Programming Wisdom 4</a> <br><br> 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Artificial Intelligence: A Modern Approach</a> ‚Äî              .       ‚Äî     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428892/">https://habr.com/ru/post/fr428892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428878/index.html">Pig Flight, ou optimisation des interpr√®tes Bytecode</a></li>
<li><a href="../fr428880/index.html">Nouvelles m√©thodes d'authentification - une menace pour la vie priv√©e?</a></li>
<li><a href="../fr428882/index.html">Mobile Yandex. Blitz: nous analysons les t√¢ches</a></li>
<li><a href="../fr428888/index.html">qml: puissance et simplicit√©</a></li>
<li><a href="../fr428890/index.html">Toute la v√©rit√© sur RTOS. Article # 18. Groupes d'indicateurs d'√©v√©nements: services d'assistance et structures de donn√©es</a></li>
<li><a href="../fr428894/index.html">TVA sur les achats nationaux</a></li>
<li><a href="../fr428896/index.html">R√©seaux de neurones de censure Hentai</a></li>
<li><a href="../fr428898/index.html">Aspects probl√©matiques de la programmation en C ++</a></li>
<li><a href="../fr428900/index.html">Des robots √† roues commencent √† livrer des marchandises aux r√©sidents des √âtats-Unis et de la Grande-Bretagne</a></li>
<li><a href="../fr428902/index.html">Balises sans fil NFC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>