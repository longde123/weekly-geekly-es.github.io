<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèø üçá üçØ Vergleich von Viper- und MVVM-Architekturen: So wenden Sie beide an ü§≥üèº üôÜ üéüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Derzeit sind VIPER und MVVM die beliebtesten Architekturl√∂sungen f√ºr die Entwicklung gro√üer Anwendungen, die die Teilnahme an der Entwicklung gro√üer T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vergleich von Viper- und MVVM-Architekturen: So wenden Sie beide an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440904/"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Derzeit sind VIPER und MVVM die beliebtesten Architekturl√∂sungen f√ºr die Entwicklung gro√üer Anwendungen, die die Teilnahme an der Entwicklung gro√üer Teams erfordern, die gut getestet, langfristig unterst√ºtzt und st√§ndig weiterentwickelt werden.  In diesem Artikel werden wir versuchen, sie auf ein kleines Testprojekt anzuwenden. Hierbei handelt es sich um eine Liste von Benutzerkontakten mit der M√∂glichkeit, einen neuen Kontakt hinzuzuf√ºgen.  Dieser Artikel hat mehr √úbung als Analytik und richtet sich in erster Linie an diejenigen, die theoretisch bereits mit diesen Architekturen vertraut sind und nun anhand spezifischer Beispiele verstehen m√∂chten, wie dies funktioniert.  Es gibt jedoch auch eine grundlegende Beschreibung der Architekturen und ihres Vergleichs. <br><a name="habracut"></a><br><br>  Dieser Artikel ist eine √úbersetzung von Rafael Sacchis Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûVergleichen von MVVM- und Viper-Architekturen: Verwendung der einen oder anderen Architektur‚Äú</a> .  Leider wurde irgendwann bei der Erstellung des Artikels "Ver√∂ffentlichung" anstelle von "√úbersetzung" eingerichtet, sodass Sie hier schreiben m√ºssen. <br><br>  Eine gut gestaltete Architektur ist unerl√§sslich, um die kontinuierliche Unterst√ºtzung Ihres Projekts sicherzustellen.  In diesem Artikel werden MVVM- und VIPER-Architekturen als Alternative zu herk√∂mmlichen MVC betrachtet. <br><br>  MVC ist ein bekanntes Konzept f√ºr alle, die seit geraumer Zeit in der Softwareentwicklung t√§tig sind.  Dieses Muster unterteilt das Projekt in drei Teile: Modell, das Entit√§ten darstellt;  Ansicht, eine Schnittstelle f√ºr die Benutzerinteraktion;  und Controller, der f√ºr die Sicherstellung der Interaktion zwischen Ansicht und Modell verantwortlich ist.  Dies ist die Architektur, die Apple uns zur Verwendung in unseren Anwendungen anbietet. <br><br>  Sie wissen jedoch wahrscheinlich, dass Projekte eine Menge komplexer Funktionen bieten: Unterst√ºtzung f√ºr Netzwerkanforderungen, Parsen, Zugriff auf Datenmodelle, Konvertieren von Daten f√ºr die Ausgabe, Reaktion auf Schnittstellenereignisse usw.  Als Ergebnis erhalten Sie riesige Controller, die die oben genannten Aufgaben l√∂sen, und eine Menge Code, der nicht wiederverwendet werden kann.  Mit anderen Worten, MVC kann ein Albtraum f√ºr einen Entwickler mit langfristiger Projektunterst√ºtzung sein.  Aber wie kann eine hohe Modularit√§t und Wiederverwendbarkeit in iOS-Projekten sichergestellt werden? <br><br>  Wir werden uns zwei sehr ber√ºhmte Alternativen zur MVC-Architektur ansehen: MVVM und VIPER.  Beide sind in der iOS-Community sehr bekannt und haben bewiesen, dass sie eine gro√üartige Alternative zu MVC sein k√∂nnen.  Wir werden √ºber ihre Struktur sprechen, eine Beispielanwendung schreiben und F√§lle betrachten, in denen es besser ist, die eine oder andere Architektur zu verwenden. <br><br>  <b>Beispiel</b> <br><br>  Wir werden eine Anwendung mit einer Tabelle von Benutzerkontakten schreiben.  Sie k√∂nnen den Code aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Repository verwenden</a> .  In den Starter-Ordnern ist das Grundger√ºst des Projekts enthalten, und in den endg√ºltigen Ordnern befindet sich eine vollst√§ndig abgeschlossene Anwendung. <br><br>  Die Anwendung verf√ºgt √ºber zwei Bildschirme: Auf dem ersten Bildschirm wird eine Liste der Kontakte in Form einer Tabelle angezeigt. Die Zelle enth√§lt den Vor- und Nachnamen des Kontakts sowie das Basisbild anstelle des Benutzerbilds. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  Der zweite Bildschirm ist der Bildschirm zum Hinzuf√ºgen eines neuen Kontakts mit den Eingabefeldern f√ºr Vor- und Nachnamen sowie den Schaltfl√§chen Fertig und Abbrechen. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  Wie es funktioniert: <br><br>  MVVM steht f√ºr <b>Model-View-ViewModel</b> .  Dieser Ansatz unterscheidet sich von MVC in der Logik der Verantwortlichkeitsverteilung zwischen Modulen. <br><br><ul><li>  <b>Modell</b> : Dieses Modul unterscheidet sich nicht von dem in MVC.  Er ist f√ºr die Erstellung von Datenmodellen verantwortlich und kann Gesch√§ftslogik enthalten.  Sie k√∂nnen beispielsweise auch Hilfsklassen erstellen, z. B. eine Manager-Klasse zum Verwalten von Objekten in Model und einen Netzwerk-Manager zum Verarbeiten von Netzwerkanforderungen und zum Parsen. </li><li>  <b>Ansicht</b> : Und hier beginnt sich alles zu √§ndern.  Das View-Modul in MVVM umfasst die Benutzeroberfl√§che (Unterklassen von UIView-, .xib- und .storyboard-Dateien), die Anzeigelogik (Animation, Rendering) und die Behandlung von Benutzerereignissen (Tastendruck usw.). View und Controller sind in MVC daf√ºr verantwortlich.  Dies bedeutet, dass Ihre Ansichten unver√§ndert bleiben, w√§hrend der ViewController einen kleinen Teil dessen enth√§lt, was in MVC enthalten war, und dementsprechend stark abnimmt. </li><li>  <b>ViewModel</b> : Dies ist jetzt der Ort, an dem sich der gr√∂√üte Teil des Codes befindet, den Sie zuvor in ViewController hatten.  Die ViewModel-Schicht fordert Daten vom Modell an (dies kann eine Anforderung an eine lokale Datenbank oder eine Netzwerkanforderung sein) und √ºbertr√§gt sie zur√ºck an die Ansicht, bereits in dem Format, in dem sie dort verwendet und angezeigt werden.  Dies ist jedoch ein bidirektionaler Mechanismus. Aktionen oder Daten, die vom Benutzer eingegeben werden, durchlaufen das ViewModel und aktualisieren das Modell.  Da das ViewModel alles anzeigt, was angezeigt wird, ist es n√ºtzlich, den Verkn√ºpfungsmechanismus zwischen den beiden Ebenen zu verwenden. </li></ul><br><br>  Im Vergleich zu MVC wechseln Sie von einer Architektur, die folgenderma√üen aussieht: <br><br><img src="https://habrastorage.org/webt/op/i7/gq/opi7gqlutejiwvehje5zoeey96k.jpeg"><br><br>  Zur n√§chsten Architekturvariante: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  In denen die Klassen und Unterklassen von UIView und UIViewController zum Implementieren der Ansicht verwendet werden. <br><br>  Nun zum Punkt.  Lassen Sie uns ein Beispiel unserer Anwendung unter Verwendung der MVVM-Architektur schreiben. <br><br>  <b>MVVM Kontakte App</b> <br><br>  <b>MODELL</b> <br><br>  Die folgende Klasse ist ein <b>Kontaktkontaktmodell</b> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  Die Kontaktklasse enth√§lt die Felder <i>firstName</i> , <i>lastName</i> sowie die berechnete Eigenschaft <i>fullName</i> . <br><br>  <b>ANSICHT</b> <br><br>  VIEW enth√§lt: Haupt-Storyboard mit bereits platzierten Ansichten;  ContactsViewController, der eine Liste der Kontakte in einer Tabelle anzeigt;  und AddContactViewController mit zwei Beschriftungen und Eingabefeldern, um den Vor- und Nachnamen des neuen Kontakts hinzuzuf√ºgen.  Beginnen wir mit dem <b>ContactsViewController</b> .  Der Code sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Selbst mit einem fl√ºchtigen Blick ist klar, dass diese Klasse zum gr√∂√üten Teil Schnittstellenaufgaben implementiert.  Es hat auch eine Navigation in der <i>prepareForSegue (: :)</i> -Methode - und genau dies ist der Moment, der sich in VIPER √§ndert, wenn eine Router-Ebene hinzugef√ºgt wird. <br><br>  Schauen wir uns die Klassenerweiterung genauer an, die das UITableViewDataSource-Protokoll implementiert.  Funktionen funktionieren nicht direkt mit dem Kontaktmodell des Kontaktbenutzers in der Modellebene. Stattdessen erhalten sie Daten (dargestellt durch die ContactViewModel-Struktur) in der Form, in der sie angezeigt werden, die bereits mit ViewModelController formatiert wurden. <br><br>  Das gleiche passiert in einer Schaltung, die unmittelbar nach dem Erstellen eines Kontakts beginnt.  Seine einzige Aufgabe ist es, der Tabelle eine Zeile hinzuzuf√ºgen und die Schnittstelle zu aktualisieren. <br><br>  Jetzt m√ºssen Sie eine Beziehung zwischen der Unterklasse von UITableViewCell und ViewModel herstellen.  Dies w√ºrde wie die Zellenklasse der <b>ContactsTableViewCell-</b> Tabelle aussehen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  Und so ist die <b>AddContactViewController-</b> Klasse: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  Auch hier wird haupts√§chlich mit der Benutzeroberfl√§che gearbeitet.  Beachten Sie, dass AddContactViewController die Funktionen zur Kontakterstellung in der Funktion <i>didClickOnDoneButton (:)</i> an ViewModelController <i>delegiert</i> . <br><br>  <b>MODELL ANZEIGEN</b> <br><br>  Es ist Zeit, √ºber die v√∂llig neue ViewModel-Ebene f√ºr uns zu sprechen.  Erstellen Sie zun√§chst eine <b>ContactViewModel-</b> Kontaktklasse, die die anzuzeigende Ansicht bereitstellt, und &lt;und&gt; Funktionen mit Parametern werden zum Sortieren von Kontakten definiert: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  <b>Der ContactViewModelController-</b> Code sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Hinweis:</u></i> MVVM gibt keine genaue Definition zum Erstellen eines ViewModel.  Wenn ich eine mehrschichtige Architektur erstellen m√∂chte, bevorzuge ich die Erstellung eines ViewModelControllers, der mit der Modellebene interagiert und f√ºr die Erstellung der ViewModel-Objekte verantwortlich ist. <br><br>  Die Hauptsache, die sehr leicht zu merken ist: Die ViewModel-Ebene sollte nicht an der Arbeit mit der Benutzeroberfl√§che beteiligt sein.  Um dies zu vermeiden, ist es besser, UIKit <b>niemals</b> mit ViewModel in eine Datei zu importieren. <br><br>  Die ContactViewModelController-Klasse fordert Kontakte vom lokalen Speicher an und versucht, die Modellebene nicht zu beeinflussen.  Es gibt die Daten in dem Format zur√ºck, in dem die Ansicht angezeigt werden muss, und benachrichtigt die Ansicht, wenn ein neuer Kontakt hinzugef√ºgt wird und sich die Daten √§ndern. <br><br>  Im wirklichen Leben w√§re dies eine Netzwerkanforderung und keine Anforderung an die lokale Datenbank, aber in keinem Fall sollte eine von ihnen Teil des ViewModel sein - sowohl die Netzwerkarbeit als auch die Arbeit mit der lokalen Datenbank sollten mit ihren eigenen Managern bereitgestellt werden ( Manager). <br><br>  Das ist alles √ºber MVVM.  Vielleicht erscheint Ihnen dieser Ansatz testbarer, unterst√ºtzter und verteilter als MVC.  Lassen Sie uns nun √ºber VIPER sprechen und sehen, wie es sich von MVVM unterscheidet. <br><br>  <b>VIPER</b> <br><br>  Wie es funktioniert: <br><br>  VIPER ist eine Clean Architecture-Implementierung f√ºr iOS-Projekte.  Die Struktur besteht aus: Ansicht, Interaktor, Pr√§sentator, Entit√§t und Router.  Dies ist wirklich eine sehr verteilte und modulare Architektur, die es Ihnen erm√∂glicht, Verantwortung zu teilen, die durch Unit-Tests sehr gut abgedeckt ist und Ihren Code wiederverwendbar macht. <br><br><ul><li>  <b>Ansicht</b> : Eine Schnittstellenebene, die normalerweise UIKit-Dateien (einschlie√ülich UIViewController) impliziert.  Es ist verst√§ndlich, dass in verteilten Systemen Unterklassen des UIViewController mit View verkn√ºpft sein sollten.  In VIPER sind die Dinge fast die gleichen wie in MVVM: View ist daf√ºr verantwortlich, anzuzeigen, was Presenter gibt, und vom Benutzer eingegebene Informationen oder Aktionen an Presenter zu √ºbertragen. </li><li>  <b>Interactor</b> : Enth√§lt die Gesch√§ftslogik, die f√ºr das Funktionieren der Anwendung erforderlich ist.  Interactor ist f√ºr das Abrufen von Daten aus dem Modell (Netzwerk- oder lokale Anforderungen) verantwortlich, und seine Implementierung h√§ngt in keiner Weise mit der Benutzeroberfl√§che zusammen.  Es ist wichtig zu beachten, dass Netzwerk- und lokale Manager nicht Teil von VIPER sind, sondern als separate Abh√§ngigkeiten behandelt werden. </li><li>  <b>Moderator</b> : Verantwortlich f√ºr die Formatierung der Daten, die in der Ansicht angezeigt werden sollen.  In MVVM in unserem Beispiel war ViewModelController daf√ºr verantwortlich.  Presenter empf√§ngt Daten von Interactor, erstellt eine Instanz von ViewModel (eine formatierte Klasse f√ºr die korrekte Anzeige) und √ºbergibt sie an View.  Er reagiert auch auf Benutzereingaben von Daten, fordert zus√§tzliche Daten aus der Datenbank an oder gibt sie an sie weiter. </li><li>  <b>Entit√§t</b> : √úbernimmt die Verantwortung f√ºr die Modellebene, die in anderen Architekturen verwendet wird.  Entit√§t ist ein einfaches Datenobjekt ohne Gesch√§ftslogik, das von einem Online-Traktor und verschiedenen Datenmanagern verwaltet wird. </li><li>  <b>Router</b> : Alle Anwendungsnavigationslogik.  Es scheint, dass dies nicht die wichtigste Ebene ist. Wenn Sie jedoch beispielsweise dieselbe Ansicht sowohl auf dem iPhone als auch in der Anwendung f√ºr das iPad wiederverwenden m√ºssen, kann sich nur √§ndern, wie Ihre Ansichten auf dem Bildschirm angezeigt werden.  Auf diese Weise k√∂nnen Sie keine weiteren Ebenen au√üer dem Router ber√ºhren, der jeweils daf√ºr verantwortlich ist. </li></ul><br><br>  Im Vergleich zu MVVM weist VIPER mehrere wesentliche Unterschiede in der Verteilung der Verantwortung auf: <br><br>  - Er hat einen Router, eine separate Ebene, die f√ºr die Navigation verantwortlich ist <br><br>  - Entit√§ten sind einfache Datenobjekte, die die Verantwortung f√ºr den Zugriff auf Daten vom Modell zum Interactor neu verteilen <br><br>  - Die Verantwortlichkeiten von ViewModelController werden zwischen Interactor und Presenter aufgeteilt <br><br>  Und jetzt wiederholen wir die gleiche Anwendung, aber bereits auf VIPER.  Zum besseren Verst√§ndnis erstellen wir jedoch nur einen Controller mit Kontakten.  Den Code f√ºr den Controller zum Hinzuf√ºgen eines neuen Kontakts im Projekt finden Sie √ºber den Link (VIPER Contacts Starter-Ordner in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Repository</a> ). <br><br>  <i><u>Hinweis</u></i> : Wenn Sie Ihr Projekt auf VIPER erstellen m√∂chten, sollten Sie nicht versuchen, alle Dateien manuell zu erstellen. Sie k√∂nnen beispielsweise einen der Codegeneratoren verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VIPER Gen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generamba (Rambler-Projekt)</a> . <br><br>  <b>VIPER Kontakte App</b> <br><br>  <b>ANSICHT</b> <br><br>  VIEW wird durch Elemente aus Main.storyboard und der ContactListView-Klasse dargestellt.  VIEW ist sehr passiv;  Seine einzige Aufgabe besteht darin, Schnittstellenereignisse an Presenter zu √ºbertragen und seinen Status nach Benachrichtigung durch Presenter zu aktualisieren.  So sieht der <b>ContactListView-</b> Code aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  View sendet die Ereignisse <i>viewDidLoad</i> und <i>didClickOnAddButton</i> an den Presenter.  Beim ersten Ereignis fordert der Pr√§sentator Daten von Interactor an, und beim zweiten Ereignis fordert der Pr√§sentator den Router auf, zum Hinzuf√ºgen eines neuen Kontakts zum Controller zu wechseln. <br><br>  ContactListViewProtocol-Protokollmethoden werden von Presenter entweder aufgerufen, wenn eine Kontaktliste angefordert wird oder wenn ein neuer Kontakt hinzugef√ºgt wird.  In beiden F√§llen enthalten die Daten in der Ansicht nur die Informationen, die f√ºr die Anzeige erforderlich sind. <br><br>  In der Ansicht befinden sich auch Methoden, die das UITableViewDataSource-Protokoll implementieren und die Tabelle mit den empfangenen Daten f√ºllen. <br><br>  <b>INTERAKTOR</b> <br><br>  Interactor in unserem Beispiel ist ganz einfach.  Er fordert lediglich Daten √ºber den lokalen Datenbankmanager an, und es spielt f√ºr ihn keine Rolle, was dieser Manager, CoreData, Realm oder eine andere L√∂sung verwendet.  Der Code in ContactListInteractor lautet wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  Nachdem Interactor die angeforderten Daten empfangen hat, benachrichtigt es Presenter.  Optional kann Interactor einen Fehler an Presenter senden, der den Fehler dann in eine Ansicht formatieren muss, die f√ºr die Anzeige in der Ansicht geeignet ist. <br><br>  <i>Hinweis</i> : Wie Sie vielleicht bemerkt haben, implementiert jede Schicht in VIPER ein Protokoll.  Infolgedessen h√§ngen Klassen von Abstraktionen und nicht von einer bestimmten Implementierung ab und erf√ºllen somit das Prinzip der Abh√§ngigkeitsinversion (eines der Prinzipien von SOLID). <br><br>  <b>PRESENTER</b> <br><br>  Das wichtigste Element der Architektur.  Die gesamte Kommunikation zwischen der Ansicht und den √ºbrigen Ebenen (Interactor und Router) erfolgt √ºber den Presenter.  <b>ContactListPresenter</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  Nach dem Laden von View wird Presenter benachrichtigt, der wiederum Daten √ºber Interactor anfordert.  Wenn der Benutzer auf die Schaltfl√§che Neuen Kontakt hinzuf√ºgen klickt, benachrichtigt View den Pr√§sentator, der eine Anforderung zum √ñffnen des Bildschirms Neuen Kontakt hinzuf√ºgen im Router sendet. <br><br>  Presenter formatiert die Daten auch und gibt sie nach Abfrage der Kontaktliste an die Ansicht zur√ºck.  Er ist auch f√ºr die Implementierung des AddModuleDelegate-Protokolls verantwortlich.  Dies bedeutet, dass Presenter eine Benachrichtigung erh√§lt, wenn ein neuer Kontakt hinzugef√ºgt wird. Bereiten Sie die Kontaktdaten f√ºr die Anzeige vor und √ºbertragen Sie sie an View. <br><br>  Wie Sie vielleicht bemerkt haben, hat Presenter jede Chance, ziemlich umst√§ndlich zu werden.  Wenn es eine solche M√∂glichkeit gibt, kann Presenter in zwei Teile unterteilt werden: Presenter, der nur Daten empf√§ngt, formatiert sie zur Anzeige und √ºbergibt sie an View;  und einen Ereignishandler, der auf Benutzeraktionen reagiert. <br><br>  <b>ENTIT√ÑT</b> <br><br>  Diese Ebene √§hnelt der Modellebene in MVVM.  In unserer Anwendung wird es durch die Kontaktklassen- und Operatordefinitionsfunktionen &lt;und&gt; dargestellt.  <b>Der Kontaktinhalt</b> sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel enth√§lt die Felder, die Presenter ausf√ºllt (Formate), die in der Ansicht angezeigt werden.  Die Contact-Klasse ist eine Unterklasse von NSManagedObject, die dieselben Felder wie im CoreData-Modell enth√§lt. <br><br>  <b>ROUTER</b> <br><br>  Und schlie√ülich die letzte, aber sicherlich nicht wichtige Schicht.  Alle Verantwortung f√ºr die Navigation liegt bei Presenter und WireFrame.  Presenter empf√§ngt ein Ereignis vom Benutzer und wei√ü, wann der √úbergang durchgef√ºhrt werden muss, und WireFrame wei√ü, wie und wo dieser √úbergang durchgef√ºhrt werden soll.  Damit Sie nicht verwirrt werden, wird in diesem Beispiel die Router-Ebene durch die ContactListWireFrame-Klasse dargestellt und im Text als WireFrame bezeichnet.  <b>ContactListWireFrame</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Da WireFrame f√ºr die Erstellung des Moduls verantwortlich ist, k√∂nnen Sie hier alle Abh√§ngigkeiten konfigurieren.  Wenn Sie einen anderen Controller √∂ffnen m√∂chten, empf√§ngt die Funktion, die den neuen Controller √∂ffnet, als Argument das Objekt, das ihn √∂ffnet, und erstellt mithilfe seines WireFrame einen neuen Controller.  Au√üerdem werden beim Erstellen eines neuen Controllers die erforderlichen Daten an diesen √ºbertragen, in diesem Fall nur der Delegat (Pr√§sentator des Controllers mit Kontakten), um den erstellten Kontakt zu empfangen. <br><br>  Die Router-Ebene bietet eine gute M√∂glichkeit, die Verwendung von √úberg√§ngen (√úberg√§ngen) in Storyboards zu vermeiden und die gesamte Code-Navigation zu organisieren.  Da Storyboards keine kompakte L√∂sung f√ºr die Daten√ºbertragung zwischen Controllern bieten, wird in unserer Navigationsimplementierung kein zus√§tzlicher Code hinzugef√ºgt.  Wir erhalten nur die beste Wiederverwendbarkeit. <br><br><br>  <b>Zusammenfassung</b> : <br><br>  Sie finden beide Projekte in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Repository</a> . <br><br>  Wie Sie sehen k√∂nnen, sind MVVM und VIPER zwar unterschiedlich, aber nicht eindeutig.  MVVM sagt uns, dass es neben Ansicht und Modell auch eine ViewModel-Ebene geben sollte.  Es wird jedoch nichts dar√ºber gesagt, wie diese Ebene erstellt werden soll oder wie die Daten angefordert werden - die Verantwortung f√ºr diese Ebene ist nicht klar definiert.  Es gibt viele M√∂glichkeiten, es zu implementieren, und Sie k√∂nnen jede davon verwenden. <br><br>  VIPER hingegen ist eine ziemlich einzigartige Architektur.  Es besteht aus vielen Schichten, von denen jede einen genau definierten Verantwortungsbereich hat und weniger als MVVM vom Entwickler beeinflusst wird. <br><br>  Wenn es um die Auswahl einer Architektur geht, gibt es normalerweise nicht die einzig richtige L√∂sung, aber ich werde trotzdem versuchen, ein paar Tipps zu geben.  Wenn Sie ein gro√ües und langwieriges Projekt mit klaren Anforderungen haben und ausreichend Gelegenheit zur Wiederverwendung von Komponenten haben m√∂chten, ist VIPER die beste L√∂sung.  Eine klarere Abgrenzung der Verantwortung erm√∂glicht es, Tests besser zu organisieren und die Wiederverwendung zu verbessern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440904/">https://habr.com/ru/post/de440904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440894/index.html">Sound f√ºr Pathfinder entwerfen: Kingmaker</a></li>
<li><a href="../de440896/index.html">Additive Technologien und 3D-Scannen im Maschinenbau: 7 Erfolgsgeschichten</a></li>
<li><a href="../de440898/index.html">Content Marketing, kontextbezogene Werbung, Verbesserung der Conversion: 6 n√ºtzliche Anleitungen zur Startup-Promotion</a></li>
<li><a href="../de440900/index.html">REST Leidenschaft f√ºr 200</a></li>
<li><a href="../de440902/index.html">Das halbe K√∂nigreich f√ºr KI: Wie viel Banken sparen an maschinellem Lernen, neuronalen Netzen und Chat-Bots?</a></li>
<li><a href="../de440906/index.html">Webinar "167-–§–ó. Wie Banken die Anforderungen der Zentralbank an Betrugsbek√§mpfungssysteme erf√ºllen k√∂nnen ‚Äú- 26. Februar 2019, 11:00 Uhr Moskauer Zeit</a></li>
<li><a href="../de440908/index.html">Alles servieren</a></li>
<li><a href="../de440910/index.html">Warum monopolisieren Banken Blockchain?</a></li>
<li><a href="../de440912/index.html">Solcher Schmerz, solcher Schmerz, Infrastruktur als Dienst 1: 0</a></li>
<li><a href="../de440914/index.html">Ich habe das Vertrauen in die Industrie verloren, bin ausgebrannt, aber der Kult des Werkzeugs hat mich gerettet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>