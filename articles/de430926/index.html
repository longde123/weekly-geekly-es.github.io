<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∑ üç© üîä Die Zeit ist fragmentiert; ein bisschen √ºber die √Ñhnlichkeit verteilter Systeme und ein schwaches Speichermodell üïñ üëæ üë£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle! 

 Heute m√∂chten wir noch einmal auf das Thema der gleichzeitigen und sequentiellen Ausf√ºhrung in verschiedenen Programmen, insbesonder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Zeit ist fragmentiert; ein bisschen √ºber die √Ñhnlichkeit verteilter Systeme und ein schwaches Speichermodell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/430926/">  Hallo an alle! <br><br>  Heute m√∂chten wir noch einmal auf das Thema der gleichzeitigen und sequentiellen Ausf√ºhrung in verschiedenen Programmen, insbesondere in verteilten Systemen, eingehen.  Bereits im September haben wir einen Artikel zu diesem Thema ver√∂ffentlicht: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchronizit√§t ist ein Mythos</a> ‚Äú. Jetzt ver√∂ffentlichen wir eine √úbersetzung einer ernsthafteren Studie, die Ihnen hoffentlich dabei helfen wird, verteilte Systeme besser zu navigieren. <br><a name="habracut"></a><br><blockquote>  In der Informatik gibt es nur ein wirkliches Problem: zuzugeben, dass Cache-Ung√ºltigkeitsfehler falsch benannt sind.  Dies sind nur Einheitenfehler im Zusammenhang mit der Zeitnutzung. </blockquote> - Unbekannter Autor <br><br>  Zeit ist eine seltsame Sache. <br><br>  Diese Zeit ist so seltsam, weil wir wirklich, wirklich glauben wollen, dass sie vollst√§ndig rationalisiert ist.  Es scheint uns, dass jedes Ereignis um 15.00 Uhr (wie wir sagen w√ºrden) vor jedem Ereignis um 16.00 Uhr stattfindet - ohne Ausnahmen, Argumente oder Kompromisse. <br><br>  Die Informatik kennt jedoch viele Beispiele, wenn es notwendig ist, diese Anforderung nicht so streng anzugehen.  Es manifestiert sich auf der Ebene von Prozessoren, Compilern und Netzwerkknoten.  Bei den Berechnungen befinden wir uns auf verschiedenen Ebenen des Stapels immer wieder in Situationen, in denen wir mit zwei Ereignissen konfrontiert sind und nicht wissen, in welcher Reihenfolge sie aufgetreten sind.  Die Zeit ist offensichtlich nicht total;  sie ist fragmentiert. <br><br>  Warum?  Tatsache ist, dass wir dies nicht wissen, da die Abstraktionsebene, √ºber die wir existieren, keine Antwort auf diese Frage liefert.  Unabh√§ngig davon, ob es sich um einen Zufall handelt oder nicht, geben unsere rechnerischen Abstraktionen keine Garantie f√ºr das Verfahren.  Durch die Freiheit, Ereignisse neu zu ordnen, k√∂nnen Sie h√§ufig viel produktivere und kosteng√ºnstigere Systeme erstellen. <br><br>  Der Prozessor kann ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherordnungsmodell haben</a> ;  Es spiegelt wider, welche Garantien der Prozessor Ihnen in der Phase der Montage keine Garantien geben m√∂chte - zum Beispiel, welche Anweisung fr√ºher und welche sp√§ter ausgef√ºhrt wurde.  Der Prozessor entscheidet genau, wie die Anweisungen √ºbermittelt werden sollen, und f√ºhrt sie nicht in der richtigen Reihenfolge aus - das hei√üt, er verwendet seine Chips effizienter als ich gedacht h√§tte. <br><br>  Eine Sprache kann ein <i>Speicheranpassungsmodell haben</i> (kurz ‚ÄûSpeichermodell‚Äú);  Es spiegelt wider, welche Garantien die Sprache beim Generieren einer Assembly nicht bietet, z. B. beim Verteilen von Anweisungen auf mehrere Threads.  Eine solche Neuordnung ist per Definition dem Hardwaremodell des Speichers inh√§rent und erkl√§rt weitgehend, warum ein solches "schwaches" Zeitkonzept in Compilern bereitgestellt wird.  Es ist im Rahmen eines solchen Speichermodells in der Sprache implementiert, die Sie programmieren, wenn Sie nicht blockierenden Code schreiben. <br><br>  Ein ber√ºhmtes Beispiel f√ºr ein auf Sprachebene implementiertes Speichermodell ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">starke und schwache Speichermodell</a> im C ++ 11-Standard.  Standardm√§√üig bietet C ++ atomare Operationen mit Synchronisation, kann jedoch auch das Speicherzugriffsmodell schw√§chen, um die Leistung zu verbessern.  Das auf diese Weise bereitgestellte Verhalten soll als Abstraktion √ºber die heute verwendeten Hauptprozessorarchitekturen (x86, POWER und ARM) dienen. <br><br>  Schlie√ülich kann ein verteiltes System ein eigenes Konsistenzmodell haben.  Es spiegelt wider, welche Garantien das System Ihnen in Bezug auf die Reihenfolge der Ereignisse auf Clients und Replikaten im globalen Computernetzwerk nicht geben wird.  Nachbestellungen, die in direktem Zusammenhang mit Kommunikationslatenz oder mangelnder Synchronisation stehen, erkl√§ren haupts√§chlich, warum Sie in einem verteilten System nicht auf das erw√§hnte schwache Zeitmodell verzichten k√∂nnen.  Dieses Konsistenzmodell programmieren Sie, wenn Sie eine verteilte Anwendung schreiben. <br><br>  In der Praxis gibt es einen riesigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zoo</a> von Konsistenzmodellen, die Sie beim Programmieren eines verteilten Systems verwenden k√∂nnen.  In all diesen Situationen beschreiben diese Modelle das (gew√ºnschte) Verhalten des Systems, das von au√üerhalb dieses Systems beobachtet wird.  Wenn ich - ein bestimmter Client oder ein bestimmter Stream - einen Wert schreibe und ihn dann sofort lese, ist dann garantiert, dass ich definitiv einen Datensatz sehe, der nicht √§lter als meiner ist?  Wenn die Zeit nicht fragmentiert w√§re, wenn wir immer eine klare Vorstellung davon h√§tten, in welcher Reihenfolge die Operationen in unserem System ablaufen - w√§re die Antwort auf diese Frage nat√ºrlich positiv.  Es w√§re seltsam, √ºberhaupt eine solche Frage zu stellen. <br><br>  Aber die Zeit ist fragmentarisch - daher ist es notwendig, eine solche Frage zu stellen. <br><br><h4>  Konsistenzmodelle - ich meine Speichermodelle </h4><br>  √úber solch eine fragmentierte Ordnung zu sprechen ist oft schwierig und immer unangenehm.  Wir m√∂chten von der Tatsache ausgehen, dass auf allen Ebenen des Stapels die Zeit immer absolut absolut ist - ob bei ACID-Transaktionen oder atomaren Operationen / Sperren.  Je strenger die Garantien, desto einfacher ist es nat√ºrlich, mit ihnen zu programmieren! <br><br>  Aber wir alle streben nach Geschwindigkeit.  Unabh√§ngig davon, ob es sich um verteilte Systeme handelt, bei denen die strikte Konsistenz f√ºr die Barrierefreiheit geopfert werden muss, oder um nicht blockierende Programmierung, bei der ein schwaches Speichermodell verwendet wird, um Synchronisationskosten zu vermeiden, ist es normalerweise f√ºr einen Programmierer, der mit einer beliebigen Ebene des Stapels arbeitet, ratsam, auf diese komplexen Argumente einzugehen . <br><br>  Die Konsistenz von Shared-Memory-Modellen und die Konsistenz von Distributed-Memory-Modellen sind beide <i>abstrakt</i> .  Sie beschreiben den mit dem System arbeitenden Programmierer, die Schnittstelle dieses Systems.  Sie erm√∂glichen es zu verstehen, welche Verhaltensweisen einem schwachen Speichermodell entsprechen, da die von uns als selbstverst√§ndlich vorausgesetzten allgemeinen Eigenschaften der Reihenfolge von Ereignissen im System nicht mehr darin wirken.  Es scheint, dass diese beiden Ged√§chtnismodelle √§hnlich sind, beide Gemeinschaften haben jedoch ihre eigenen Diskurse zur Diskussion entwickelt.  Die in ihnen verwendeten Werte unterscheiden sich, obwohl sie sich √ºberschneiden. <br><br>  Wir stellen uns bereits vor, wie verwirrt das sein kann.  Was tun? <br><br><h4>  Beschreibung der Zeit als Einheit, die zwei bis acht Arten von Teilordnungen impliziert </h4><br>  Sebastian Burkhardt versucht in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem Buch von 2014,</a> die vielen Optionen f√ºr Konsistenzmodelle ausf√ºhrlich zu beschreiben.  Mit dieser Eigenschaft werden zusammen mit anderen mathematischen Strukturen zwei Varianten der logischen Reihenfolge von Ereignissen verwendet: "Sichtbarkeit" und "Arbitrierung", die zuvor auch in anderen Arbeiten von Burkhardt et al. Erw√§hnt wurden, siehe zum Beispiel den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber Zeigen und Pr√ºfen replizierte Datentypen (2014). <br><br>  "Sichtbarkeit" ist eine Teilordnung, die einer m√∂glichen Konditionierung innewohnt.  Sie k√∂nnen verfolgen, welche Ereignisse (m√∂glicherweise in anderen Replikaten) f√ºr welche anderen Ereignisse sichtbar sind.  Es gibt keine anderen Anforderungen an die Sichtbarkeit als die Azyklizit√§t.  Ereignisse in einem Objekt k√∂nnen f√ºr Ereignisse in einem anderen Objekt sichtbar sein, und das Lesen oder Schreiben eines Ereignisses hat keinen Einfluss auf dessen Sichtbarkeit f√ºr andere Ereignisse. <br><br>  "Willk√ºr" ist eine allgemeine Reihenfolge, mit der Sie verfolgen k√∂nnen, wie ein verteiltes System, in dem eine Situation der Wahl auftritt, beurteilt, welches Ereignis fr√ºher und welches sp√§ter eintritt. <br><br>  Da verteilte Konsistenzmodelle Speichermodellen √§hnlich sind, stellt sich heraus, dass solche Ph√§nomene der Sichtbarkeit und Zuf√§lligkeit auch bei der Er√∂rterung von Speichermodellen n√ºtzlich sein k√∂nnen.  Insbesondere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Anhang zu seinem Artikel von 2014 zeigt</a> Burkhardt, "wie nahe" das schwache Speichermodell von C ++ 11 an der objektbasierten kausalen Konsistenz liegt, jedoch mit einigen interessanten Abweichungen.  Dies wird im Rest des Beitrags besprochen. <br><br>  Lassen Sie uns zun√§chst Sichtbarkeit und Zuf√§lligkeit unter Ber√ºcksichtigung von ‚ÄûLesen‚Äú und ‚ÄûReihenfolge der √Ñnderungen‚Äú ausarbeiten.  Beim ‚ÄûLesen‚Äú wird die Sichtbarkeit zwischen zwei beliebigen Objekten nur in Situationen ber√ºcksichtigt, in denen sowohl Lesen als auch Schreiben dasselbe Objekt ber√ºhren und beim Lesen nur ein Datensatz (oder mehrere) sichtbar sein kann. <br>  Dies entspricht einer Situation, in der ein Prozessor mit gemeinsam genutztem Speicher zu einem bestimmten Zeitpunkt Informationen in nur einer Speicherzelle f√ºr ein bestimmtes Objekt aufzeichnen kann, selbst wenn verschiedene Threads zu unterschiedlichen Zeitpunkten f√ºr Ursache und Wirkung darauf zugreifen k√∂nnen (andererseits in einem verteilten System die logische Ein Objekt kann sofort in vielen separaten Repliken aufgezeichnet werden. <br><br>  "√Ñnderungsreihenfolge" entspricht der gleichen Stufe bei der Konkretisierung von Willk√ºr, ist objektiv und erlaubt nur Aufzeichnungen.  Diese Spezialisierung basiert wiederum auf der Tatsache, dass bei einer schwachen Speicherspezifikation kategoriale Garantien nur auf der Ebene eines Objekts gegeben werden. <br><br>  Lassen Sie uns als n√§chstes die von Burkhardt et al. Formulierten Axiome der Konsistenz diskutieren und sehen, wie sie auf ein schwaches Speichermodell angewendet werden.  Bitte beachten Sie: Trotz des Wortes ‚ÄûAxiome‚Äú handelt es sich lediglich um Eigenschaften, die in verschiedenen Speichermodellen bereitgestellt werden k√∂nnen oder nicht.  Burkhardts Artikel konzentriert sich auf die Eigenschaften, die die objekt√ºbergreifende Kausalit√§t bestimmen. <br><br><h4>  Koh√§renz letztendlich </h4><br>  F√ºr ein bestimmtes Ereignis kann es nicht unbegrenzt viele Ereignisse geben, die es nicht sehen.  Das hei√üt, jedes Ereignis <i>ist letztendlich</i> f√ºr das System sichtbar. <br><br>  Das logische Erstellen solcher Bedingungen in einem System mit einem schwachen Speichermodell sollte etwas schwieriger sein: Es muss argumentiert werden, dass es f√ºr einen bestimmten <i>Datensatz</i> nicht unendlich viele Leseoperationen geben kann, die diesen Datensatz oder fr√ºhere Datens√§tze (in der √Ñnderungsreihenfolge) nicht lesen w√ºrden. <br><br>  In der C ++ 11-Spezifikation ist die Einhaltung dieses Axioms nicht garantiert, obwohl es in der Praxis schwierig ist, ein Gegenbeispiel zu finden. <br><br><h4>  √Ñtherische Konsistenz </h4><br>  Wenn Sie die ‚Äûpotenzielle Konditionalit√§t‚Äú auf der Ebene der Flows / Client-Vorg√§nge und in Bezug auf Sichtbarkeit / Lesbarkeit verfolgen, m√ºssen Sie verstehen, dass es keine R√ºckgabezeit gibt.  Aus diesem Grund ist es erforderlich, dass die Verschl√ºsse bei der Bestellung der zu lesenden Fl√ºsse azyklisch sind.  In der Regel besteht kein Zweifel daran, dass diese Eigenschaft in verteilten Systemen beobachtet wird. Diese Eigenschaft erm√∂glicht jedoch in einigen spekulativen Versionen keine Sichtbarkeit des Benutzers, wenn das System √ºber ein schwaches Speichermodell verf√ºgt. <br><br>  Burkhardt et al. Weisen darauf hin, dass dieses Axiom in der C ++ 11-Spezifikation ‚Äûnicht best√§tigt‚Äú ist und es unklar ist, ‚Äûnicht validiert‚Äú, ob <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Praxis</a> ‚Äûzufriedenstellende Zyklen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beobachtet</a> werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen</a> . <br><br><h4>  Axiome der Konditionalit√§t </h4><br>  Um genau anzugeben, worauf sich das Ph√§nomen der Konditionalit√§t unter einem schwachen Speichermodell bezieht, m√ºssen wir genau bestimmen, welche Ereignisse die Ergebnisse welcher anderen Ereignisse beeinflussen k√∂nnen.  Betrachten Sie zun√§chst unsere Standard-Axiome f√ºr Ursache und Wirkung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sitzungsgarantien</a> .  Dies sind vier miteinander verbundene Eigenschaften, die die Koh√§renzeigenschaften von Lese- und Schreiboperationen widerspiegeln, die in verschiedenen Streams auftreten. Dar√ºber hinaus sollten sie auf der Ebene jedes Objekts angegeben werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Burkhardt et al</a> ., <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abb. 23</a> ). <br><br><ul><li>  RYW (Lesen Sie Ihre Datens√§tze): Der Lesevorgang nach dem Schreibvorgang wird in derselben Zelle innerhalb desselben Streams / Replikats / derselben Sitzung ausgef√ºhrt. Er muss Daten lesen, die nicht weniger relevant sind als der Datensatz.  Die Variante dieser Eigenschaft f√ºr verteilte Systeme wird ausschlie√ülich in Bezug auf die Sichtbarkeit angegeben, w√§hrend die Variante f√ºr ein schwaches Speichermodell sowohl auf der Lesereihenfolge als auch auf der √Ñnderungsreihenfolge basieren sollte. </li><li>  MR (monolithische Messwerte): Nachfolgende Messwerte (innerhalb desselben Stroms, in derselben Zelle) sollten auch in Zukunft nicht weniger relevante Daten enthalten. </li><li>  WFR (zuerst lesen, dann schreiben): Wenn der Schreibvorgang dem Lesevorgang innerhalb des Streams in derselben Zelle folgt, sollte er in der Reihenfolge der √Ñnderungen sp√§ter als der Lesevorgang ausgef√ºhrt werden. </li><li>  MW (Monolithic Records): Sp√§tere Datens√§tze (innerhalb des Streams in derselben Zelle) sollten sp√§ter in der √Ñnderungsreihenfolge angezeigt werden. </li></ul><br>  Die Originalversionen von WFR und MW existieren aus Gr√ºnden der Zuf√§lligkeit und Sichtbarkeit in zwei Versionen.  Dies ist jedoch nur wichtig, wenn mit komplexeren Datenzellen als mit Registern f√ºr Ganzzahlen gearbeitet wird. <br><br>  Diese Eigenschaften spiegeln die Begriffe der Konditionalit√§t wider, die unserem gesunden Menschenverstand entsprechen.  Sie vermissen jedoch die interessantesten.  Insbesondere bei der Analyse in einem schwachen Speichermodell sind solche Ph√§nomene der Konditionalit√§t durch die Grenzen des Flusses / der Replik / der Sitzung und der spezifischen Zelle / des spezifischen Objekts, in die / der der Eintrag erfolgt, begrenzt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In einem Artikel von Burkhardt et al</a> .  in diesem Fall handelt es sich um "Objekt-durch-bedingte bedingte Sichtbarkeit" und "Objekt-durch-bedingte willk√ºrliche Willk√ºr", siehe auch Abb.  23. Diese Ph√§nomene schr√§nken das Verhalten des Systems nicht vollst√§ndig ein, wenn verschiedene Streams Informationen in verschiedene Zellen schreiben. <br><br>  Dann beschreiben die Axiome der objekt√ºbergreifenden Konditionierung die Wirkung von Ursache-Wirkungs-Beziehungen auf der Ebene verschiedener Objekte / Speicherzellen. <br><br><ul><li>  COCV (Objekt√ºbergreifende bedingte Sichtbarkeit): Der gleiche Fall wie bei RYW, jedoch ohne die Bedingung, dass der endg√ºltige Lesevorgang alle im selben Thread / Replikat / Sitzung durchgef√ºhrt werden muss.  Messwerte von einem Objekt, die objektiv sp√§ter als Datens√§tze in diesem Objekt sind, sollten Daten enthalten, die nicht weniger relevant sind als die w√§hrend der Aufzeichnung eingegebenen. </li></ul><br>  Die C ++ 11-Spezifikation spiegelt diese Eigenschaften wider.  Bitte beachten Sie: Sie sind so definiert, dass Einschr√§nkungen der Aufzeichnungssichtbarkeit und die Beliebigkeit der √Ñnderungsreihenfolge diese Definitionen nicht zu sehr beeinflussen. <br><br>  Dies gilt jedoch nicht f√ºr die letztere Eigenschaft. <br><br><ul><li>  COCA (Cross-Object Conditional Arbitrary): √Ñhnlich wie monolithische Datens√§tze, gilt jedoch f√ºr verschiedene Streams, √§hnlich wie COCV - es ist RYW f√ºr verschiedene Streams.  Da die √Ñnderungsreihenfolge jedoch nur Datens√§tze in einem Objekt betrifft, erm√∂glicht die Formulierung f√ºr ein schwaches Speichermodell dem System eine inkonsistente Verteilung von Aufzeichnungsereignissen in verschiedenen Objekten, und die Datens√§tze entsprechen m√∂glicherweise nicht den Messwerten oder der Reihenfolge innerhalb des Streams. </li></ul><br>  Insbesondere ist COCA in einem schwachen Speichermodell eine viel schw√§chere Eigenschaft.  Aus diesem Grund kann bei einem schwachen Speichermodell der folgende Code <code>{x ‚â° 0, y ‚â° 0}</code> . <br><br> <code>Thread A: y := 0; x := 1; return x <br> Thread B: x := 0; y := 1; return y</code> <br> <br>  Die Reihenfolge innerhalb jedes Streams kann mit der Reihenfolge der einzelnen Objekte und der √Ñnderungsreihenfolge nicht √ºbereinstimmen.  Bitte beachten Sie: Mit RYW gibt es kein <code>x := 0 ‚Üí x := 1</code> in der √Ñnderungsreihenfolge und f√ºr <code>y</code> dasselbe;  Daher sollte die √Ñnderungsreihenfolge <code>x := 1 ‚Üí x := 0</code> und <code>y := 1 ‚Üí y := 0</code> .  Somit bildet die √Ñnderungsreihenfolge offensichtlich einen Zyklus in der Reihenfolge der Fl√ºsse. <br>  Eine solche Schleife ist in COCA mit einem schwachen Speichermodell zul√§ssig.  Es ist nicht so, dass die Reihenfolge der Streams / Lesevorg√§nge der Reihenfolge der √Ñnderung widerspricht, sondern dass jeder Stream einen konsistenten Datensatzverlauf sieht.  Diese Geschichten stimmen nur dann mit den Geschichten anderer Fl√ºsse √ºberein, wenn wir den Umfang ihrer Anwendung objektiv einschr√§nken. <br><br><h4>  Was bedeutet das alles? </h4><br>  Die Zeit ist fragmentiert. <br><br>  Auch wenn es uns so scheint, als w√ºrde die Zeit ordentlich flie√üen, zeigt das Studium verteilter Systeme und eines schwachen Speichermodells deutlich, dass dies nicht der Fall ist.  Aus diesem Grund schr√§nkt in beiden Situationen unsere Standard√ºbersch√§tzung, nach der die Zeit insgesamt ist, die Leistung ein - was wir uns nicht leisten k√∂nnen. <br>  Wenn wir dann erkennen, dass die Zeit wirklich fragmentiert ist, finden wir viele kleine, aber wichtige Unterschiede zwischen den Sorten einer solchen Parteilichkeit.  Selbst die beiden oben genannten Felder, die auf den ersten Blick so √§hnlich erscheinen, erm√∂glichen es in vielen subtilen Nuancen zu unterscheiden, welche Arten von Ereignissen sich gegenseitig beeinflussen. <br><br>  Es ist notwendig, die technischen Details verschiedener Eigenschaften bereits genauer zu verstehen, nachdem jemand die Eigenschaften eines Feldes in der Sprache eines anderen ausdr√ºcken kann. <br><br>  Die Zeit ist fragmentiert.  Vielleicht m√ºssen wir uns nur daran gew√∂hnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430926/">https://habr.com/ru/post/de430926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430914/index.html">Analyse der Schwarzmarktpreise f√ºr personenbezogene Daten und Durchbruch</a></li>
<li><a href="../de430916/index.html">Kohlendioxiddetektor MT8057S. Nicht√ºberpr√ºfung unter Beteiligung eines Nichtemulators</a></li>
<li><a href="../de430918/index.html">√úber Flutter, kurz: Grundlagen</a></li>
<li><a href="../de430922/index.html">Berechnungsbeispiel f√ºr Schalttafel</a></li>
<li><a href="../de430924/index.html">Ada Programmierung</a></li>
<li><a href="../de430928/index.html">Nur zum "Smart Home": Wie man eine "intelligente" Hintergrundbeleuchtung macht</a></li>
<li><a href="../de430930/index.html">√úber 3D-Grafiken in einfachen Worten</a></li>
<li><a href="../de430932/index.html">Hacker haben einer russischen Bank mehr als 21 Millionen Rubel gestohlen</a></li>
<li><a href="../de430934/index.html">Asterisk Dialplan-Erweiterungsmaskengenerator</a></li>
<li><a href="../de430936/index.html">DEFCON 21. DNS-Konferenzen k√∂nnen gesundheitssch√§dlich sein. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>