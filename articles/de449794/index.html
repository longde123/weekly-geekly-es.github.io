<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📢 👨🏼‍🍳 👨‍🔧 Adaptive Antennenarrays: Wie funktioniert es? (Grundlagen) 👨🏽‍🎨 😃 🥚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. 

 In den letzten Jahren habe ich mich der Erforschung und Entwicklung verschiedener Algorithmen zur räumlichen Verarbeitung von Signalen i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Adaptive Antennenarrays: Wie funktioniert es? (Grundlagen)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449794/">  <i>Guten Tag.</i> <br><br>  <i>In den letzten Jahren habe ich mich der Erforschung und Entwicklung verschiedener Algorithmen zur räumlichen Verarbeitung von Signalen in adaptiven Antennenarrays gewidmet, und dies mache ich im Rahmen meiner gegenwärtigen Arbeit weiter.</i>  <i>Hier möchte ich das Wissen und die Chips teilen, die ich entdeckt habe.</i>  <i>Ich hoffe, dass es für Leute nützlich sein wird, die anfangen, diesen Bereich der Signalverarbeitung zu studieren oder nur interessiert sind.</i> <br><br><h2>  Was ist ein adaptives Antennenarray? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Antennenarray</a> ist ein Satz von Antennenelementen, die auf irgendeine Weise im Raum angeordnet sind.  Um die Struktur des adaptiven Antennenarrays zu vereinfachen, die wir betrachten werden, kann sie in der folgenden Form dargestellt werden: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/ew/z4/ruewz4gumbqixeta5slmr9am9z0.png" alt="imag"></div><br><a name="habracut"></a><br>  Adaptive Antennenarrays werden häufig als „Smart-Antennen“ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart-</a> Antennen) bezeichnet.  Das "intelligente" Antennenarray wird von der räumlichen Signalverarbeitungseinheit und den darin implementierten Algorithmen hergestellt.  Diese Algorithmen analysieren das empfangene Signal und bilden eine Reihe von Gewichten <math> </math> $ inline $ w_1 ... w_N $ inline $   die die Amplitude und Anfangsphase des Signals für jedes der Elemente bestimmen.  Die gegebene Amplitudenphasenverteilung bestimmt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Richtungsmuster des</a> gesamten Gitters als Ganzes.  Die Fähigkeit, das Strahlungsmuster der erforderlichen Form zu synthetisieren und während der Signalverarbeitung zu ändern, ist eines der Hauptmerkmale adaptiver Antennenarrays, mit denen eine Vielzahl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Problemen</a> gelöst werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> .  Aber das Wichtigste zuerst. <br><br><h2>  Wie entsteht das Strahlungsmuster? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Strahlungsmuster</a> charakterisiert die Leistung eines in eine bestimmte Richtung abgestrahlten Signals.  Der Einfachheit halber setzen wir die Gitterelemente isotrop, d.h.  Für jeden von ihnen hängt die Leistung des ausgesendeten Signals nicht von der Richtung ab.  Die Verstärkung oder Dämpfung der von der Anordnung in einer bestimmten Richtung abgestrahlten Leistung wird aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interferenz von</a> <abbr title="Elektromagnetische Wellen">elektromagnetischen Wellen erhalten,</abbr> die von verschiedenen Elementen der Antennenanordnung emittiert werden.  Ein stabiles Interferenzmuster für <abbr title="Elektromagnetische Wellen">EMW</abbr> ist nur möglich, wenn sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kohärent sind</a> , d.h.  Die Phasendifferenz der Signale sollte sich nicht mit der Zeit ändern.  Im Idealfall sollte jedes der Elemente des Antennenarrays ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">harmonisches Signal</a> mit derselben Trägerfrequenz aussenden <math> </math> $ inline $ f_ {0} $ inline $   .  In der Praxis ist es jedoch erforderlich, mit Schmalbandsignalen mit einem Spektrum endlicher Breite zu arbeiten <math> </math> $ inline $ \ Delta f &lt;&lt; f_ {0} $ inline $   . <br>  Lassen Sie alle <abbr title="Antennenarray">AR-</abbr> Elemente das gleiche Signal mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">komplexer Amplitude</a> aussenden <math> </math> $ inline $ x_n (t) = u (t) $ inline $   .  Dann kann am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entfernten</a> Empfänger das vom n-ten Element empfangene Signal in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">analytischen</a> Form dargestellt werden: <p><math> </math> $$ Anzeige $$ a_n (t) = u (t- \ tau_n) e ^ {i2 \ pi f_0 (t- \ tau_n)} $$ Anzeige $$ </p>  wo <math> </math> $ inline $ \ tau_n $ inline $   - Verzögerung der Signalausbreitung vom Antennenelement zum Empfangspunkt. <br>  Ein solches Signal ist <i>"quasi-harmonisch",</i> und um die Kohärenzbedingung zu erfüllen, ist es notwendig, dass die maximale Verzögerung bei der Ausbreitung <abbr title="Elektromagnetische Wellen">elektromagnetischer Wellen</abbr> zwischen zwei beliebigen Elementen viel geringer ist als die charakteristische Zeit der Signalhüllkurvenänderung <math> </math> $ inline $ T $ inline $   d.h. <math> </math> $ inline $ u (t- \ tau_n) ≈ u (t- \ tau_m) $ inline $   .  Somit kann die Bedingung für die Kohärenz eines Schmalbandsignals wie folgt geschrieben werden: <br><p><math> </math> $$ display $$ T≈ \ frac {1} {\ Delta f} &gt;&gt; \ frac {D_ {max}} {c} = max (\ tau_k- \ tau_m) $$ display $$ </p>  wo <math> </math> $ inline $ D_ {max} $ inline $   - der maximale Abstand zwischen den Elementen des <abbr title="Antennenarray">AR</abbr> und <math> </math> $ inline $ mit $ inline $   Ist die Lichtgeschwindigkeit. <br><br>  Beim Empfang eines Signals wird eine kohärente Summierung digital in der räumlichen Verarbeitungseinheit durchgeführt.  In diesem Fall wird der komplexe Wert des digitalen Signals am Ausgang dieses Blocks durch den Ausdruck bestimmt: <p><math> </math> $$ display $$ y = \ sum_ {n = 1} ^ Nw_n ^ * x_n $$ display $$ </p><a name="block_0"></a>  Es ist bequemer, den letzten Ausdruck in Form eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skalarprodukts von</a> N-dimensionalen komplexen Vektoren in Matrixform darzustellen: <p><math> </math> $$ display $$ y = (\ textbf {w}, \ textbf {x}) = \ textbf {w} ^ H \ textbf {x} $$ display $$ </p>  wobei <b>w</b> und <b>x</b> Spaltenvektoren sind und <math> </math> $ inline $ (.) ^ H $ inline $   - Operation der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hermitianischen Paarung</a> . <br><br>  <i>Die Vektordarstellung von Signalen ist eine der Grundlagen bei der Arbeit mit Antennenarrays, weil</i>  <i>vermeidet oft umständliche mathematische Berechnungen.</i>  <i>Darüber hinaus ermöglicht die Identifizierung eines zu einem bestimmten Zeitpunkt empfangenen Signals mit einem Vektor häufig die Abstraktion von einem realen physikalischen System und das Verständnis dessen, was unter dem Gesichtspunkt der Geometrie genau geschieht.</i> <br><a name="block_1"></a><br>  Um das Richtcharakteristikmuster des Antennenarrays zu berechnen, ist es notwendig, mental und konsistent einen Satz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ebener Wellen</a> aus allen möglichen Richtungen darauf zu "laufen".  In diesem Fall können die Werte der Elemente des Vektors <b>x</b> wie folgt dargestellt werden: <p><math> </math> $$ display $$ x_n = s_n = \ exp \ {- i (\ textbf {k} (\ phi, \ theta), \ textbf {r} _n) \} $$ display $$ </p>  wobei <b>k</b> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wellenvektor ist</a> <math> </math> $ inline $ \ phi $ inline $   und <math> </math> $ inline $ \ theta $ inline $   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Azimutwinkel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elevationswinkel,</a> der die Ankunftsrichtung einer ebenen Welle kennzeichnet, <math> </math> $ inline $ \ textbf {r} _n $ inline $   - Koordinate des Antennenelements, <math> </math> $ inline $ s_n $ inline $   - ein Element des Phasenvektors <b>s einer</b> ebenen Welle mit dem Wellenvektor <b>k</b> (in der englischen Literatur wird der Phasenvektor als Steuervektor bezeichnet).  Die Abhängigkeit des Quadrats von der Amplitude von <i>y</i> von <math> </math> $ inline $ \ phi $ inline $   und <math> </math> $ inline $ \ theta $ inline $   bestimmt das Richtungsmuster des Antennenarrays beim Empfang für einen gegebenen Vektor von Gewichtskoeffizienten <b>w</b> . <br><br><h2>  Merkmale des Antennenarrays </h2><br>  Es ist zweckmäßig, die allgemeinen Eigenschaften des Antennenarray-Strahlungsmusters auf einem linearen äquidistanten Antennenarray in einer horizontalen Ebene zu untersuchen (d. H. Das <abbr title="Strahlungsmuster">Strahlmuster</abbr> hängt nur vom Azimutwinkel ab <math> </math> $ inline $ \ phi $ inline $   )  Dies ist unter zwei Gesichtspunkten praktisch: analytische Berechnungen und visuelle Darstellung. <br><br>  Wir berechnen den DN für einen Einheitsgewichtsvektor ( <math> </math> $ inline $ w_n = 1, n = 1 ... N $ inline $   ) nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oben</a> beschriebenen Ansatz. <br><div class="spoiler">  <b class="spoiler_title">Mathe hier</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/he/7z/hjhe7zz-kkx9gggtleppdx1aswu.png"></div><br>  Die Projektion des Wellenvektors auf die vertikale Achse: <math> </math> $ inline $ k_v = - \ frac {2 \ pi} {\ lambda} \ sin \ phi $ inline $ <br>  Die vertikale Koordinate des Antennenelements mit dem Index n: <math> </math> $ inline $ r_ {nv} = (n-1) d $ inline $ <br>  Hier ist <i>d</i> die Periode des Antennenarrays (der Abstand zwischen benachbarten Elementen), <i>λ</i> ist die Wellenlänge.  Alle anderen Elemente des Vektors <b>r</b> sind gleich Null. <br>  Das vom Antennenarray empfangene Signal wird wie folgt aufgezeichnet: <p><math> </math> $$ display $$ y = \ sum_ {n = 1} ^ {N} 1 ⋅ \ exp \ {i2 \ pi n \ frac {d} {\ lambda} \ sin \ phi \} $$ display $$ </p>  Wir wenden die Formel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Summe eines geometrischen Verlaufs</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Darstellung trigonometrischer Funktionen durch komplexe Exponenten an</a> : <p><math> </math> $$ display $$ y = \ frac {1- \ exp \ {i2 \ pi N \ frac {d} {\ lambda} \ sin \ phi \}} {1- \ exp \ {i2 \ pi \ frac {d } {\ lambda} \ sin \ phi \}} = \ frac {\ sin (\ pi \ frac {Nd} {\ lambda} \ sin \ phi)} {\ sin (\ pi \ frac {d} {\ lambda } \ sin \ phi)} \ exp \ {i \ pi \ frac {d (N-1)} {\ lambda} \ sin \ phi \} $$ display $$ </p><br></div></div><br><a name="block_2"></a><br>  Als Ergebnis erhalten wir: <p><math> </math> $$ display $$ F (\ phi) = | y | ^ 2 = \ frac {\ sin ^ 2 (\ pi \ frac {Nd} {\ lambda} \ sin \ phi)} {\ sin ^ 2 (\ pi \ frac {d} {\ lambda} \ sin \ phi)} $$ display $$ </p><br><h3>  Strahlungsmusterfrequenz </h3><br>  Das resultierende Strahlungsmuster des Antennenarrays ist eine periodische Funktion des Sinus des Winkels.  Dies bedeutet, dass für bestimmte Werte des <i>d / λ-</i> Verhältnisses Beugungsmaxima (zusätzliche Maxima) vorliegen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/k7/rh/hbk7rh1yhltrpe9ye4q0bwvh5uu.png"></div>  <i>Nicht normalisiertes Antennenmuster für N = 5</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w1/m0/gf/w1m0gfdiay7xpditjpbktwokskw.png"></div>  <i>Normalisiertes Strahlungsmuster des Antennenarrays für N = 5 im Polarkoordinatensystem</i> <br><br>  Die Position der "Beuger" kann direkt aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formel</a> für NAM entnommen werden.  Wir werden jedoch versuchen zu verstehen, woher sie physikalisch und geometrisch kommen (im N-dimensionalen Raum). <br><br>  Die Elemente des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phasenvektors</a> sind komplexe Exponenten <math> </math> $ inline $ e ^ {i \ Psi n} $ inline $   deren Werte werden durch den Wert des verallgemeinerten Winkels bestimmt <math> </math> $ inline $ \ Psi = 2 \ pi \ frac {d} {\ lambda} \ sin \ phi $ inline $   .  Wenn es zwei verallgemeinerte Winkel gibt, die unterschiedlichen Ankunftsrichtungen einer ebenen Welle entsprechen, für die <math> </math> $ inline $ \ Psi_1 = \ Psi_2 + 2 \ pi m $ inline $   dann bedeutet dies zwei Dinge: <br><br><ul><li>  <b>Physikalisch:</b> ebene Wellenfronten, die aus diesen Richtungen kommen, induzieren identische Amplituden-Phasen-Verteilungen elektromagnetischer Wellen auf den Elementen des Antennenarrays. </li><li>  <b>Geometrisch:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phasenvektoren</a> für diese beiden Richtungen fallen zusammen. </li></ul><br>  <i>Die auf ähnliche Weise verbundenen Richtungen der Wellenankunft sind aus Sicht des Antennenarrays äquivalent und nicht voneinander unterscheidbar.</i> <br><br>  Wie kann man den Winkelbereich bestimmen, in dem immer nur ein Hauptmaximum der <abbr title="Strahlungsmuster">MD</abbr> liegt?  Wir werden dies aus folgenden Gründen in der Nähe des Null-Azimuts tun: Die Phasenverschiebung zwischen zwei benachbarten Elementen sollte im Intervall von liegen <math> </math> $ inline $ - \ pi $ inline $   vorher <math> </math> $ inline $ \ pi $ inline $   . <br><p><math> </math> $$ display $$ - \ pi &lt;2 \ pi \ frac {d} {\ lambda} \ sin \ phi &lt;\ pi $$ display $$ </p>  Wenn wir diese Ungleichung lösen, erhalten wir die Bedingung für den Bereich der Einzigartigkeit in einer Nachbarschaft von Null: <p><math> </math> $$ display $$ | \ sin \ phi | &lt;\ frac {\ lambda} {2d} $$ display $$ </p><br>  Es ist ersichtlich, dass die Größe des Bereichs der Eindeutigkeit im Winkel vom Verhältnis <i>d / λ</i> abhängt.  Wenn <i>d</i> = 0,5 <i>λ ist</i> , ist jede Ankunftsrichtung des Signals "individuell", und der Bereich der Eindeutigkeit deckt den gesamten Winkelbereich ab.  Wenn <i>d</i> = 2,0 <i>λ ist</i> , sind die Richtungen 0, ± 30, ± 90 äquivalent.  Beugungskeulen erscheinen auf dem Strahlungsmuster. <br><br>  <i>Typischerweise neigen Beugungskeulen dazu, unter Verwendung von Richtantennenelementen zu unterdrücken.</i>  <i>In diesem Fall ist das vollständige Strahlungsmuster des Antennenarrays das Produkt des <abbr title="Strahlungsmuster">Musters</abbr> eines Elements und des Arrays isotroper Elemente.</i>  <i>Die <abbr title="Strahlungsmuster">DN-</abbr> Parameter eines Elements werden normalerweise basierend auf der Bedingung des Eindeutigkeitsbereichs des Antennenarrays ausgewählt.</i> <br><br><h3>  Die Breite des Hauptlappens </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> technische Formel zum Schätzen der Breite der Hauptkeule des Antennensystems ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemein bekannt</a> : <math> </math> $ inline $ \ Delta \ phi ≈ \ frac {\ lambda} {D} $ inline $   Dabei ist D die charakteristische Größe der Antenne.  Die Formel wird für verschiedene Antennentypen verwendet, einschließlich SLR-Antennen.  Wir zeigen, dass es auch für Antennenarrays gilt. <br><br>  Wir bestimmen die Breite der Hauptkeule durch die ersten Nullen der <abbr title="Strahlungsmuster">MD</abbr> in der Nähe des Hauptmaximums.  Zähler des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausdrucks</a> für <math> </math> $ inline $ F (\ phi) $ inline $   verschwindet bei <math> </math> $ inline $ \ sin \ phi = m \ frac {\ lambda} {dN} $ inline $   .  Die ersten Nullen entsprechen m = ± 1.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorausgesetzt</a> <math> </math> $ inline $ \ frac {\ lambda} {dN} &lt;&lt; 1 $ inline $   wir bekommen <math> </math> $ inline $ \ Delta \ phi = 2 \ frac {\ lambda} {dN} $ inline $   . <br><br>  Typischerweise wird die Richtstrahlbreite <abbr title="Antennenarray">AR</abbr> durch den halben Leistungspegel (-3 dB) bestimmt.  Verwenden Sie in diesem Fall den Ausdruck: <p><math> </math> $$ display $$ \ Delta \ phi≈0.88 \ frac {\ lambda} {dN} $$ display $$ </p><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4a/oz/aj/4aozajnoydkkmoj6izygdirnh-q.png"></div><br></div></div><br>  Die Breite der Hauptkeule kann gesteuert werden, indem unterschiedliche Werte der Amplituden für die Gewichtskoeffizienten des Antennenarrays eingestellt werden.  Betrachten Sie drei Verteilungen: <br><br><ul><li>  Gleichmäßige Amplitudenverteilung (Gewichte 1): <math> </math> $ inline $ w_n = 1 $ inline $   . </li><li>  Amplitudenwerte, die an die Gitterkanten fallen (Gewichte 2): <math> </math> $ inline $ w_n = 0,5 + 0,3 \ cos (2 \ pi \ frac {n-1} {N} - \ pi \ frac {N-1} {N}) $ inline $ </li><li>  Amplitudenwerte, die bis zu den Rändern des Gitters ansteigen (Gewichte 3): <math> </math> $ inline $ w_n = 0,5-0,3 \ cos (2 \ pi \ frac {n-1} {N} - \ pi \ frac {N-1} {N}) $ inline $ </li></ul><br>  Die Abbildung zeigt die resultierenden normalisierten Strahlungsmuster auf einer logarithmischen Skala: <div style="text-align:center;"><img src="https://habrastorage.org/webt/b-/j3/9w/b-j39w3o1qv9cbfvm8e2znx4vry.png"></div><br>  <i>Die folgenden Tendenzen können aus der Figur beobachtet werden: Die Verteilung der Amplituden der Gewichtskoeffizienten, die zu den Rändern des Gitters hin abnimmt, führt zu einer Verbreiterung des Hauptlappens des MD, jedoch zu einer Abnahme des Niveaus der Nebenkeulen.</i>  <i>Die zu den Rändern der Antennenanordnung hin zunehmenden Amplituden führen im Gegensatz dazu zu einer Verengung der Hauptkeule und einer Erhöhung des Niveaus der Seiten.</i>  Es ist zweckmäßig, hier Grenzfälle zu berücksichtigen: <br><br><ol><li>  Die Amplituden der Gewichtungskoeffizienten aller Elemente mit Ausnahme der extremen sind gleich Null.  Gewichte für extreme Elemente sind gleich Einheit.  In diesem Fall wird das Gitter äquivalent zu einem Zwei-Elemente-AR mit einer Periode von <i>D = (N-1) d</i> .  Es ist nicht schwierig, die Breite des Hauptblatts gemäß der obigen Formel abzuschätzen.  In diesem Fall verwandeln sich die Seitenteile in Beugungsmaxima und richten sich nach dem Hauptmaximum aus. </li><li>  Das Gewicht des zentralen Elements ist gleich Eins und der Rest gleich Null.  In diesem Fall haben wir im Wesentlichen eine Antenne mit einem isotropen Strahlungsmuster. </li></ol><br><h3>  Die Richtung des Hauptmaximums </h3><br>  Wir haben uns also angesehen, wie Sie die Breite der Hauptkeule des <abbr title="Antennenmuster">AP AR</abbr> anpassen können.  Nun wollen wir sehen, wie man die Richtung steuert.  Rufen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vektorausdruck</a> für das empfangene Signal auf.  Angenommen, wir möchten, dass das maximale Strahlungsmuster in eine bestimmte Richtung zeigt <math> </math> $ inline $ \ phi_0 $ inline $   .  Dies bedeutet, dass die maximale Leistung aus dieser Richtung entnommen werden sollte.  Der Phasenvektor entspricht dieser Richtung <math> </math> $ inline $ \ textbf {s} (\ phi_0) $ inline $   im <i>N-</i> dimensionalen Vektorraum, und die Empfangsleistung ist definiert als das Quadrat des Skalarprodukts dieses Phasenvektors durch den Vektor der Gewichtskoeffizienten <b>w</b> .  Das Skalarprodukt zweier Vektoren ist maximal, wenn sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kollinear sind</a> , d.h. <math> </math> $ inline $ \ textbf {w} = \ beta \ textbf {s} (\ phi_0) $ inline $   wobei <i>β</i> ein normalisierender Faktor ist.  Wenn wir also einen Gewichtsvektor wählen, der dem Phasenvektor für die gewünschte Richtung entspricht, drehen wir das maximale Strahlungsmuster. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/7n/dd/oe7nddqigily-krmim4cwzf0yty.png"></div><br>  Betrachten Sie die folgenden Gewichte als Beispiel: <math> </math> $ inline $ \ textbf {w} = \ textbf {s} (10 °) $ inline $ <br><p><math> </math> $$ display $$ w_n = \ exp \ {i2 \ pi \ frac {d} {\ lambda} (n-1) \ sin (10 \ pi / 180) \} $$ display $$ </p>  Als Ergebnis erhalten wir ein Strahlungsmuster mit dem Hauptmaximum in Richtung 10 °. <br><br>  Jetzt wenden wir die gleichen Gewichte an, jedoch nicht für den Signalempfang, sondern für die Übertragung.  Hierbei ist zu berücksichtigen, dass bei der Übertragung eines Signals die Richtung des Wellenvektors umgekehrt wird.  Dies bedeutet, dass sich die Elemente des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phasenvektors</a> zum Empfangen und Senden im Exponenten im Vorzeichen unterscheiden, d.h.  durch komplexe Konjugation miteinander verbunden.  Als Ergebnis erhalten wir das Maximum des Strahlungsmusters in Richtung von -10 °, das nicht mit dem Maximum des Empfangssignals bei gleichen Gewichtskoeffizienten übereinstimmt. Um die Situation zu korrigieren, ist es notwendig, eine komplexe Konjugation auch auf die Gewichtskoeffizienten anzuwenden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/zr/uc/lzzrucsvxlhxx2qlglvzyantxfo.png"></div><br>  <i>Das beschriebene Merkmal der Bildung der <abbr title="Strahlungsmuster">Strahlen</abbr> zum Empfangen und Senden sollte bei der Arbeit mit Antennenarrays immer berücksichtigt werden.</i> <br><br><h2>  Spielen wir mit dem Strahlungsmuster </h2><br><h3>  Nur wenige Höhen </h3><br>  Wir stellen das Problem, zwei Hauptmaxima des Strahlungsmusters in der Richtung zu bilden: -5 ° und 10 °.  Dazu wählen wir die gewichtete Summe der Phasenvektoren für die entsprechenden Richtungen als Gewichtsvektor. <p><math> </math> $$ display $$ \ textbf {w} = \ beta \ textbf {s} (10 °) + (1- \ beta) \ textbf {s} (- 5 °) $$ display $$ </p><img src="https://habrastorage.org/webt/kg/bw/7e/kgbw7e976btha_5dtc2whecdslq.png">  Durch Einstellen des Koeffizienten <i>β</i> kann das Verhältnis zwischen den Hauptkeulen eingestellt werden.  Auch hier ist es bequem zu sehen, was im Vektorraum passiert.  Wenn <i>β</i> größer als 0,5 ist, liegt der Gewichtsvektor näher an <b>s</b> (10 °), andernfalls an <b>s</b> (-5 °).  Je näher der Gewichtsvektor an einem der Zeiger liegt, desto größer ist das entsprechende Skalarprodukt und damit die Größe des entsprechenden Maximums der <abbr title="Strahlungsmuster">ND</abbr> . <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/md/qs/rbmdqsh5l5uskrwtm_himwic95y.png"></div><br>  Es ist jedoch zu bedenken, dass beide Hauptblütenblätter eine endliche Breite haben. Wenn wir in zwei nahe Richtungen stimmen möchten, verschmelzen diese Blütenblätter zu einer, die auf eine mittlere Richtung ausgerichtet ist. <br><br><h3>  Ein Maximum und Null </h3><br>  Versuchen wir nun, das maximale Strahlungsmuster an die Richtung anzupassen <math> </math> $ inline $ \ phi_1 = 10 ° $ inline $   und gleichzeitig das aus der Richtung kommende Signal unterdrücken <math> </math> $ inline $ \ phi_2 = -5 ° $ inline $   .  Dazu muss für den entsprechenden Winkel die Null gesetzt werden.  Sie können dies wie folgt tun: <p><math> </math> $$ display $$ \ textbf {w} = \ textbf {s} _1- \ frac {\ textbf {s} _2 ^ H \ textbf {s} _1} {N} \ textbf {s} _2 $$ display $$ </p><br>  wo <math> </math> $ inline $ \ textbf {s} _1 = \ textbf {s} (10 °) $ inline $   und <math> </math> $ inline $ \ textbf {s} _2 = \ textbf {s} (- 5 °) $ inline $   . <br><img src="https://habrastorage.org/webt/2o/n5/-g/2on5-gvr1ispkx7sprj73nbhgmg.png"><br>  Die geometrische Bedeutung der Wahl des Gewichtsvektors ist wie folgt.  Wir wollen, dass dieser Vektor <b>w</b> eine maximale Projektion hat <math> </math> $ inline $ \ textbf {s} _1 $ inline $   und war orthogonal zum Vektor <math> </math> $ inline $ \ textbf {s} _2 $ inline $   .  Vektor <math> </math> $ inline $ \ textbf {s} _1 $ inline $   kann als zwei Begriffe dargestellt werden: kollinearer Vektor <math> </math> $ inline $ \ textbf {s} _2 $ inline $   und orthogonaler Vektor <math> </math> $ inline $ \ textbf {s} _2 $ inline $   .  Um die Problemstellung zu erfüllen, muss die zweite Komponente als Vektor der Gewichtskoeffizienten <b>w gewählt werden</b> .  Die kollineare Komponente kann durch Entwerfen eines Vektors berechnet werden <math> </math> $ inline $ \ textbf {s} _1 $ inline $   zum normalisierten Vektor <math> </math> $ inline $ \ frac {\ textbf {s} _2} {\ sqrt {N}} $ inline $   mit einem skalaren Produkt. <p><math> </math> $$ display $$ \ textbf {s} _ {1 ||} = \ frac {\ textbf {s} _2} {\ sqrt {N}} \ frac {\ textbf {s} _2 ^ H \ textbf {s} _1} {\ sqrt {N}} $$ display $$ </p>  Dementsprechend wird vom anfänglichen Phasenvektor subtrahiert <math> </math> $ inline $ \ textbf {s} _1 $ inline $   Mit seiner kollinearen Komponente erhalten wir den gewünschten Gewichtsvektor. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nn/sc/15/nnsc15djywky_jsaprbpbel6f48.png"></div><br><h3>  Einige zusätzliche Hinweise </h3><br><ol><li>  Überall oben habe ich die Frage der Normalisierung des Gewichtsvektors weggelassen, d.h.  seine Länge.  Die Normalisierung des Gewichtsvektors beeinflusst also nicht die Eigenschaften des Antennenarray-Strahlungsmusters: die Richtung der Hauptmaxime, die Breite der Hauptkeule usw.  Es kann auch gezeigt werden, dass diese Normalisierung das <abbr title="Signal-Rausch-Verhältnis">SNR</abbr> am Ausgang des räumlichen Verarbeitungsblocks nicht beeinflusst.  In dieser Hinsicht akzeptiere ich, wenn räumliche Signalverarbeitungsalgorithmen betrachtet werden, normalerweise eine Einheitsnormalisierung des Gewichtsvektors, d.h. <math> </math> $ inline $ \ textbf {w} ^ H \ textbf {w} = 1 $ inline $ </li><li>  Die Möglichkeiten zur Bildung des Antennenarraybodens werden durch die Anzahl der Elemente N bestimmt. Je mehr Elemente, desto breiter die Möglichkeiten.  Je mehr Freiheitsgrade bei der Implementierung der räumlichen Gewichtsverarbeitung vorhanden sind, desto mehr Optionen zum "Verdrehen" des Gewichtsvektors im N-dimensionalen Raum. </li><li>  Beim Empfang des Antennenstrahlmusters <abbr title="Strahlungsmuster">existiert das</abbr> Antennenarray physikalisch nicht, und all dies existiert nur in der "Vorstellung" der Recheneinheit, die das Signal verarbeitet.  Dies bedeutet, dass es gleichzeitig möglich ist, mehrere <abbr title="Strahlungsmuster">MDs</abbr> zu synthetisieren und unabhängig voneinander Signale zu verarbeiten, die aus verschiedenen Richtungen ankommen.  Bei der Übertragung ist alles etwas komplizierter, es ist aber auch möglich, mehrere <abbr title="Strahlungsmuster">MDs</abbr> zur Übertragung verschiedener Datenströme zu synthetisieren.  Diese Technologie in Kommunikationssystemen heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIMO</a> . </li><li>  Mit dem bereitgestellten Matlab-Code können Sie selbst mit <abbr title="Strahlungsmuster">NAM</abbr> spielen <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">% antenna array settings N = 10; % number of elements d = 0.5; % period of antenna array wLength = 1; % wavelength mode = 'receiver'; % receiver or transmitter % weights of antenna array w = ones(N,1); % w = 0.5 + 0.3*cos(2*pi*((0:N-1)-0.5*(N-1))/N).'; % w = 0.5 - 0.3*cos(2*pi*((0:N-1)-0.5*(N-1))/N).'; % w = exp(2i*pi*d/wLength*sin(10/180*pi)*(0:N-1)).'; % b = 0.5; w = b*exp(2i*pi*d/wLength*sin(+10/180*pi)*(0:N-1)).' + (1-b)*exp(2i*pi*d/wLength*sin(-5/180*pi)*(0:N-1)).'; % b = 0.5; w = b*exp(2i*pi*d/wLength*sin(+3/180*pi)*(0:N-1)).' + (1-b)*exp(2i*pi*d/wLength*sin(-3/180*pi)*(0:N-1)).'; % s1 = exp(2i*pi*d/wLength*sin(10/180*pi)*(0:N-1)).'; % s2 = exp(2i*pi*d/wLength*sin(-5/180*pi)*(0:N-1)).'; % w = s1 - (1/N)*s2*s2'*s1; % w = s1; % normalize weights w = w./sqrt(sum(abs(w).^2)); % set of angle values to calculate pattern angGrid_deg = (-90:0.5:90); % convert degree to radian angGrid = angGrid_deg * pi / 180; % calculate set of steerage vectors for angle grid switch (mode) case 'receiver' s = exp(2i*pi*d/wLength*bsxfun(@times,(0:N-1)',sin(angGrid))); case 'transmitter' s = exp(-2i*pi*d/wLength*bsxfun(@times,(0:N-1)',sin(angGrid))); end % calculate pattern y = (abs(w'*s)).^2; %linear scale plot(angGrid_deg,y/max(y)); grid on; xlim([-90 90]); % log scale % plot(angGrid_deg,10*log10(y/max(y))); % grid on; % xlim([-90 90]);</span></span></code> </pre> <br></div></div></li></ol><br><a name="block_3"></a><br><h2>  Welche Aufgaben können mit Hilfe eines adaptiven Antennenarrays gelöst werden? </h2><br><div class="spoiler">  <b class="spoiler_title">Optimaler Empfang unbekannter Signale</b> <div class="spoiler_text">  Wenn die Ankunftsrichtung des Signals unbekannt ist (und wenn der Kommunikationskanal mehrwegig ist, gibt es im Allgemeinen mehrere Richtungen), ist es durch Analysieren des vom Antennenarray empfangenen Signals möglich, den optimalen Gewichtsvektor <b>w</b> so zu bilden, dass das <abbr title="Signal-Rausch-Verhältnis">SNR</abbr> am Ausgang der räumlichen Verarbeitungseinheit maximal ist. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Optimaler Signalempfang gegen Störungen</b> <div class="spoiler_text">  Die Aufgabe hier ist wie folgt: Die räumlichen Parameter des erwarteten Nutzsignals sind bekannt, es gibt jedoch Störquellen in der äußeren Umgebung.  Es ist notwendig, das <abbr title="Signal / (Rauschen + Interferenz) Verhältnis">SINR</abbr> am Ausgang des AR zu maximieren, um die Auswirkung von Interferenzen auf den Signalempfang zu minimieren. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Optimale Signalübertragung an den Benutzer</b> <div class="spoiler_text">  Dieses Problem wird in Mobilkommunikationssystemen (4G, 5G) sowie in Wi-Fi gelöst.  Die Bedeutung ist einfach: Mit Hilfe spezieller Pilotsignale im Rückkopplungskanal des Benutzers werden die räumlichen Eigenschaften des Kommunikationskanals geschätzt und der für die Übertragung optimale Vektor der Gewichtungskoeffizienten auf seiner Basis ausgewählt. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Räumliche Multiplexing-Datenströme</b> <div class="spoiler_text">  Adaptive Antennenarrays ermöglichen die gleichzeitige Übertragung von Daten an mehrere Benutzer mit derselben Frequenz, wobei für jeden von ihnen ein individuelles <abbr title="Strahlungsmuster">Muster</abbr> gebildet wurde.  Diese Technologie heißt MU-MIMO und wird derzeit (und anderswo) aktiv in Kommunikationssysteme eingeführt.  Die Möglichkeit des räumlichen Multiplexens ist beispielsweise im 4G LTE-Mobilkommunikationsstandard, IEEE802.11ay Wi-Fi-Standard, 5G-Mobilkommunikationsstandards vorgesehen. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Virtuelle Antennenarrays für Radargeräte</b> <div class="spoiler_text">  Digitale Antennenarrays ermöglichen die Verwendung mehrerer sendender Antennenelemente, um ein virtuelles Antennenarray mit wesentlich größeren Größen für die Signalverarbeitung zu bilden.  Ein virtuelles Gitter hat alle Eigenschaften eines realen Gitters, benötigt jedoch für seine Implementierung weniger Hardware. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bewertung der Parameter von Strahlungsquellen</b> <div class="spoiler_text">  Adaptive Antennenarrays ermöglichen es, das Problem der Schätzung der Anzahl, Leistung und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winkelkoordinaten</a> von Funkemissionsquellen zu lösen und eine statistische Beziehung zwischen Signalen verschiedener Quellen herzustellen.  Der Hauptvorteil von adaptiven Antennenarrays in dieser Angelegenheit ist die Fähigkeit, nahegelegene Strahlungsquellen aufzulösen.  Quellen, deren Winkelabstand zwischen ihnen kleiner ist als die Breite der Hauptkeule des Antennenarray-Strahlungsmusters ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rayleigh-Auflösungsgrenze</a> ).  Dies ist hauptsächlich aufgrund der Vektordarstellung des Signals, des bekannten Signalmodells sowie der Apparatur der linearen Mathematik möglich. <br></div></div><br><br>  <i>Vielen Dank für Ihre Aufmerksamkeit</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449794/">https://habr.com/ru/post/de449794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449778/index.html">Fototour: Was wird im Labor für Quantenmaterialien der ITMO-Universität gemacht?</a></li>
<li><a href="../de449782/index.html">Künstliche Intelligenz nimmt den Müll des Ozeans auf: Bereinigen Sie die Strände der Welt mithilfe von Daten</a></li>
<li><a href="../de449784/index.html">In welchen Fällen lohnt es sich, Django zu verwenden (und in welchen Fällen ist es nicht notwendig)</a></li>
<li><a href="../de449788/index.html">Brave Browser stellt eine belohnungsbasierte Werbeplattform vor</a></li>
<li><a href="../de449790/index.html">Produktentwicklung Visual Aid: Design</a></li>
<li><a href="../de449796/index.html">Über ein Mädchen</a></li>
<li><a href="../de449798/index.html">Turmverteidigung in Einheit schaffen, Teil 1</a></li>
<li><a href="../de449802/index.html">Karriereprogrammierer. Teil 1. Das erste Programm</a></li>
<li><a href="../de449804/index.html">Überblick über die Anti-Aging-Therapie für Biohacker</a></li>
<li><a href="../de449806/index.html">Karriereprogrammierer. Teil 2. Schule oder Selbstbildung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>