<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌹 🤾🏿 🤟🏿 AI, tentu saja praktis. Pembelajaran mendalam untuk menghasilkan musik 🏝️ 🤺 👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel terakhir dari serangkaian artikel pelatihan untuk pengembang di bidang kecerdasan buatan. Ini membahas langkah-langkah untuk membua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI, tentu saja praktis. Pembelajaran mendalam untuk menghasilkan musik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/423727/"><img src="https://habrastorage.org/webt/zy/do/u4/zydou4yx-zh_x9qzbumtrbdhwy4.jpeg"><br><br>  Ini adalah artikel terakhir dari serangkaian artikel pelatihan untuk pengembang di bidang kecerdasan buatan.  Ini membahas langkah-langkah untuk membuat model pembelajaran yang mendalam untuk generasi musik, memilih model yang tepat dan preprocessing data, dan menjelaskan prosedur untuk pengaturan, pelatihan, pengujian dan modifikasi BachBot. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Generasi Musik - Berpikir Tentang Suatu Tugas</font> </h2><br>  Langkah pertama dalam memecahkan banyak masalah menggunakan kecerdasan buatan (AI) adalah untuk mengurangi masalah menjadi masalah dasar yang dapat diselesaikan dengan cara AI.  Salah satu masalah tersebut adalah prediksi urutan, yang digunakan dalam terjemahan bahasa alami dan aplikasi pemrosesan.  Tugas kita menghasilkan musik dapat direduksi menjadi masalah memprediksi urutan, dan prediksi akan dilakukan untuk urutan catatan musik. <br><br><h2>  <font color="#0071c5">Pemilihan model</font> </h2><br>  Ada beberapa jenis jaringan saraf yang dapat dianggap sebagai model: jaringan saraf distribusi langsung, jaringan saraf berulang, dan jaringan saraf memori jangka panjang. <br><br>  Neuron adalah elemen abstrak dasar yang bergabung membentuk jaringan saraf.  Pada dasarnya, neuron adalah fungsi yang menerima data pada input dan output hasilnya. <br><br><img src="https://habrastorage.org/webt/56/pq/hs/56pqhseblx5mqec0apoegck7vd4.png"><br>  <i>Neuron</i> <br><br>  Lapisan neuron yang menerima data yang sama pada input dan output yang terhubung dapat dikombinasikan untuk membangun <i>jaringan saraf dengan propagasi langsung</i> .  Jaringan saraf tersebut menunjukkan hasil yang tinggi karena komposisi fungsi aktivasi nonlinier ketika melewatkan data melalui beberapa lapisan (yang disebut deep learning). <br><br><img src="https://habrastorage.org/webt/e8/ps/1v/e8ps1vchys7uap5mjucmyip5ob8.png"><br>  <i>Jaringan saraf distribusi langsung</i> <br><br>  Jaringan saraf distribusi langsung menunjukkan hasil yang baik dalam berbagai aplikasi.  Namun, jaringan saraf semacam itu memiliki satu kelemahan yang tidak memungkinkannya digunakan dalam tugas yang berkaitan dengan komposisi musik (prediksi urutan): ia memiliki dimensi data input yang tetap, dan komposisi musik dapat memiliki panjang yang berbeda.  Selain itu, <i>jaringan saraf distribusi langsung tidak mempertimbangkan input dari langkah waktu sebelumnya, yang membuatnya tidak terlalu berguna untuk memecahkan masalah prediksi urutan!</i>  Model yang disebut <i>jaringan saraf berulang</i> lebih cocok untuk tugas ini. <br><br>  Jaringan saraf rekursif menyelesaikan kedua masalah ini dengan memperkenalkan tautan antara simpul tersembunyi: dalam hal ini, pada langkah waktu berikutnya, simpul dapat menerima informasi tentang data pada langkah waktu sebelumnya. <br><br><img src="https://habrastorage.org/webt/xc/jv/dr/xcjvdrzlx66olpyziwbtfywxukq.png"><br>  <i>Representasi terperinci dari jaringan saraf berulang</i> <br><br>  Seperti yang Anda lihat pada gambar, setiap neuron sekarang menerima input dari kedua lapisan saraf sebelumnya dan waktu sebelumnya. <br><br>  Jaringan saraf rekursif yang berurusan dengan sekuens input besar menghadapi apa yang disebut <i>masalah gradien menghilang</i> : ini berarti bahwa pengaruh dari langkah waktu sebelumnya dengan cepat menghilang.  Masalah ini adalah karakteristik tugas komposisi musik, karena ada ketergantungan jangka panjang yang penting dalam karya musik yang harus diperhitungkan. <br><br>  Untuk mengatasi masalah gradien yang hilang, modifikasi jaringan berulang, yang disebut <i>jaringan saraf dengan memori jangka pendek (atau jaringan saraf LSTM), dapat digunakan</i> .  Masalah ini diselesaikan dengan memperkenalkan sel-sel memori, yang dipantau dengan cermat oleh tiga jenis "gerbang".  Klik tautan berikut untuk informasi lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi umum tentang jaringan saraf LSTM</a> . <br><br>  Dengan demikian, BachBot menggunakan model yang didasarkan pada jaringan saraf LSTM. <br><br><h2>  <font color="#0071c5">Pretreatment</font> </h2><br>  Musik adalah bentuk seni yang sangat kompleks dan mencakup berbagai dimensi: nada, irama, tempo, nuansa dinamis, artikulasi dan banyak lagi.  Untuk menyederhanakan musik untuk keperluan proyek ini <i>, hanya nada dan durasi suara yang dipertimbangkan</i> .  Selain itu, semua paduan suara <i>dialihkan</i> ke kunci dalam C mayor atau A minor, dan durasi nada <i>dihitung dalam waktu</i> (dibulatkan) ke kelipatan terdekat dari nada keenam belas.  Tindakan ini diambil untuk mengurangi kompleksitas komposisi dan meningkatkan kinerja jaringan, sementara konten dasar musik tetap tidak berubah.  Operasi untuk menormalkan nada dan durasi nada dilakukan menggunakan perpustakaan music21. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standardize_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(score)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Converts into the key of C major or A minor. Adapted from https://gist.github.com/aldous-rey/68c6c43450517aa47474 """</span></span> <span class="hljs-comment"><span class="hljs-comment"># conversion tables: eg Ab -&gt; C is up 4 semitones, D -&gt; A is down 5 semitones majors = dict([("A-", 4),("A", 3),("B-", 2),("B", 1),("C", 0),("C#",-1), ("D-", -1),("D", -2),("E-", -3),("E", -4),("F", -5),("F#",6), ("G-", 6), ("G", 5)]) minors = dict([("A-", 1),("A", 0),("B-", -1),("B", -2),("C", -3),("C#",-4), ("D-", -4),("D", -5),("E-", 6),("E", 5),("F", 4),("F#",3), ("G-",3),("G", 2)]) # transpose score key = score.analyze('key') if key.mode == "major": halfSteps = majors[key.tonic.name] elif key.mode == "minor": halfSteps = minors[key.tonic.name] tScore = score.transpose(halfSteps) # transpose key signature for ks in tScore.flat.getKeySignatures(): ks.transpose(halfSteps, inPlace=True) return tScore</span></span></code> </pre> <br>  <i>Kode yang digunakan untuk membakukan karakter kunci dalam karya yang dikumpulkan, kunci dalam C mayor atau A minor digunakan dalam output</i> <br><br>  Kuantisasi waktu untuk kelipatan terdekat dari catatan keenambelas dilakukan menggunakan fungsi <i>Stream.quantize ()</i> dari perpustakaan <i>music21</i> .  Berikut ini adalah perbandingan statistik yang terkait dengan kumpulan data sebelum dan sesudah pemrosesan pendahuluan: <br><br><img src="https://habrastorage.org/webt/kr/wh/5n/krwh5n0d1dubkwn0urbjmp7ovzs.png"><br>  <i>Menggunakan setiap kelas catatan sebelum (kiri) dan setelah preprocessing (kanan).</i>  <i>Kelas catatan adalah catatan terlepas dari oktafnya.</i> <br><br><img src="https://habrastorage.org/webt/mz/rq/i0/mzrqi0fynco56dhr9kdk-nsfjrs.png"><br>  <i>Lokasi catatan sebelum (kiri) dan setelah preprocessing (kanan)</i> <br><br>  Seperti yang Anda lihat pada gambar di atas, transposisi kunci asli paduan suara ke kunci C mayor atau C minor (A minor) secara signifikan memengaruhi kelas nada yang digunakan dalam karya yang dikumpulkan.  Secara khusus, jumlah kemunculan untuk catatan dalam kunci di kunci utama (C mayor) dan A minor (A minor) (C, D, E, F, G, A, B) meningkat.  Anda juga dapat mengamati puncak kecil untuk catatan F # dan G # karena keberadaannya dalam urutan melodi A minor (A, B, C, D, E, F # dan G #).  <i>Di sisi lain, kuantisasi waktu memiliki efek yang jauh lebih kecil.</i>  Ini dapat dijelaskan dengan resolusi tinggi kuantisasi (mirip dengan pembulatan ke banyak digit signifikan). <br><br><h2>  <font color="#0071c5">Coding</font> </h2><br>  Setelah data telah diproses sebelumnya, perlu untuk menyandikan paduan suara ke dalam format yang dapat dengan mudah diproses menggunakan jaringan saraf berulang.  Format yang diperlukan adalah <i>urutan token</i> .  Untuk proyek BachBot, pengkodean dipilih pada tingkat catatan (setiap token mewakili catatan) alih-alih tingkat akor (setiap token mewakili akor).  Solusi ini mengurangi ukuran kamus dari 128 <sup>4</sup> kemungkinan akor menjadi 128 kemungkinan nada, yang memungkinkan untuk meningkatkan efisiensi kerja. <br><br>  Skema pengkodean asli untuk komposisi musik diciptakan untuk proyek BachBot.  Paduan suara dibagi menjadi langkah-langkah waktu yang sesuai dengan nada keenambelas.  Langkah-langkah ini disebut bingkai.  Setiap bingkai berisi urutan tupel yang mewakili nilai nada catatan dalam format antarmuka alat musik digital (MIDI) dan tanda pengikat catatan ini ke catatan sebelumnya dengan tinggi yang sama (catatan, tanda pengikatan).  Catatan dalam bingkai diberi nomor sesuai urutan ketinggian (sopran → alt → tenor → bass).  Setiap bingkai juga dapat memiliki bingkai yang menandai akhir kalimat;  Fermata diwakili oleh simbol titik (.) Di atas catatan.  Simbol <i>MULAI</i> dan <i>AKHIR</i> ditambahkan ke awal dan akhir setiap nyanyian.  Simbol-simbol ini menyebabkan inisialisasi model dan memungkinkan pengguna untuk menentukan kapan komposisi berakhir. <br><br> <code>START <br> (59, True) <br> (56, True) <br> (52, True) <br> (47, True) <br> ||| <br> (59, True) <br> (56, True) <br> (52, True) <br> (47, True) <br> ||| <br> (.) <br> (57, False) <br> (52, False) <br> (48, False) <br> (45, False) <br> ||| <br> (.) <br> (57, True) <br> (52, True) <br> (48, True) <br> (45, True) <br> ||| <br> END</code> <br>  <i>Contoh pengkodean dua akord.</i>  <i>Setiap akord berlangsung dalam ketukan kedelapan dalam ukuran, akor kedua disertai oleh pertanian.</i>  <i>Urutan "|||"</i>  <i>menandai akhir bingkai</i> <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode_score</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(score, keep_fermatas=True, parts_to_mask=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Encodes a music21 score into a List of chords, where each chord is represented with a (Fermata :: Bool, List[(Note :: Integer, Tie :: Bool)]). If `keep_fermatas` is True, all `has_fermata`s will be False. All tokens from parts in `parts_to_mask` will have output tokens `BLANK_MASK_TXT`. Time is discretized such that each crotchet occupies `FRAMES_PER_CROTCHET` frames. """</span></span> encoded_score = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chord <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (score .quantize((FRAMES_PER_CROTCHET,)) .chordify(addPartIdAsGroup=bool(parts_to_mask)) .flat .notesAndRests): <span class="hljs-comment"><span class="hljs-comment"># aggregate parts, remove markup # expand chord/rest st constant timestep between frames if chord.isRest: encoded_score.extend((int(chord.quarterLength * FRAMES_PER_CROTCHET)) * [[]]) else: has_fermata = (keep_fermatas) and any(map(lambda e: e.isClassOrSubclass(('Fermata',)), chord.expressions)) encoded_chord = [] # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> sorts Soprano, Bass, Alto, Tenor without breaking ties # c = chord.sortAscending() # sorted_notes = [c[-1], c[0]] + c[1:-1] # for note in sorted_notes: for note in chord: if parts_to_mask and note.pitch.groups[0] in parts_to_mask: encoded_chord.append(BLANK_MASK_TXT) else: has_tie = note.tie is not None and note.tie.type != 'start' encoded_chord.append((note.pitch.midi, has_tie)) encoded_score.append((has_fermata, encoded_chord)) # repeat pitches to expand chord into multiple frames # all repeated frames when expanding a chord should be tied encoded_score.extend((int(chord.quarterLength * FRAMES_PER_CROTCHET) - 1) * [ (has_fermata, map(lambda note: BLANK_MASK_TXT if note == BLANK_MASK_TXT else (note[0], True), encoded_chord)) ]) return encoded_score</span></span></code> </pre> <br>  <i>Kode yang digunakan untuk menyandikan nada musik21 menggunakan skema penyandian khusus</i> <br><br><h2>  <font color="#0071c5">Tugas model</font> </h2><br>  Pada bagian sebelumnya, penjelasan diberikan menunjukkan bahwa tugas komposisi otomatis dapat dikurangi menjadi tugas memprediksi urutan.  Secara khusus, suatu model dapat memprediksi nada berikutnya yang paling mungkin berdasarkan catatan sebelumnya.  Untuk mengatasi jenis masalah ini, jaringan saraf dengan memori jangka pendek (LSTM) paling cocok.  Secara formal, model harus memprediksi P (x <sub>t + 1</sub> | x <sub>t</sub> , h <sub>t-1</sub> ), distribusi probabilitas untuk catatan selanjutnya yang mungkin (x <sub>t + 1</sub> ) berdasarkan token saat ini (x <sub>t</sub> ) dan keadaan tersembunyi sebelumnya (h <sub>t-1</sub> ) .  Menariknya, operasi yang sama dilakukan oleh model bahasa berdasarkan jaringan saraf berulang. <br><br>  Dalam mode komposisi, model diinisialisasi dengan token <i>START</i> , setelah itu memilih token berikutnya yang paling mungkin untuk diikuti.  Setelah itu, model melanjutkan untuk memilih token berikutnya yang paling mungkin menggunakan note sebelumnya dan status tersembunyi sebelumnya sampai token END dihasilkan.  Sistem ini mengandung elemen suhu yang menambahkan beberapa tingkat keacakan untuk mencegah BachBot menyusun bagian yang sama berulang kali. <br><br><h3>  <font color="#0071c5">Fungsi kerugian</font> </h3><br>  Saat melatih model untuk prediksi, biasanya ada beberapa fungsi yang perlu diminimalkan (disebut fungsi rugi).  Fungsi ini menjelaskan perbedaan antara prediksi model dan properti ground truth.  BachBot meminimalkan hilangnya cross-entropy antara distribusi yang diprediksi (x <sub>t + 1</sub> ) dan distribusi aktual dari fungsi tujuan.  Menggunakan cross entropy sebagai fungsi kerugian adalah titik awal yang baik untuk berbagai tugas, tetapi dalam beberapa kasus Anda dapat menggunakan fungsi kerugian Anda sendiri.  Pendekatan lain yang dapat diterima adalah mencoba menggunakan berbagai fungsi kerugian dan menerapkan model yang meminimalkan kerugian aktual selama verifikasi. <br><br><h3>  <font color="#0071c5">Pelatihan / pengujian</font> </h3><br>  Dalam pelatihan jaringan saraf rekursif, BachBot menggunakan token koreksi dengan nilai x <sub>t + 1</sub> alih-alih menerapkan prediksi model.  Proses ini, yang dikenal sebagai pembelajaran wajib, digunakan untuk memastikan konvergensi, karena prediksi model secara alami akan menghasilkan hasil yang buruk pada awal pelatihan.  Sebaliknya, selama validasi dan komposisi, prediksi model x <sub>t + 1</sub> harus digunakan kembali sebagai input ke prediksi berikutnya. <br><br><h3>  <font color="#0071c5">Pertimbangan lainnya</font> </h3><br>  Untuk meningkatkan efisiensi dalam model ini, metode praktis berikut digunakan yang umum untuk jaringan saraf LSTM: pemotongan gradien yang dinormalisasi, metode eliminasi, normalisasi paket, dan metode propagasi balik kesalahan terputus waktu (BPTT) yang terpotong. <br><br>  <i>Metode pemotongan gradien yang dinormalisasi</i> menghilangkan masalah pertumbuhan yang tidak terkendali dari nilai gradien (kebalikan dari masalah gradien hilang, yang diselesaikan dengan menggunakan arsitektur sel memori LSTM).  Dengan menggunakan teknik ini, nilai gradien yang melebihi ambang tertentu dipotong atau diskalakan. <br><br>  <i>Metode eksklusi</i> adalah teknik di mana beberapa neuron yang <i>dipilih secara acak</i> terputus (dikecualikan) selama pelatihan jaringan.  Ini menghindari overfitting dan meningkatkan kualitas generalisasi.  Masalah overfitting muncul ketika model menjadi dioptimalkan untuk set data pelatihan dan pada tingkat yang lebih rendah berlaku untuk sampel di luar set ini.  Metode eksklusi sering memperburuk kehilangan selama pelatihan, tetapi memperbaikinya pada tahap verifikasi (lebih lanjut tentang ini di bawah). <br><br>  Perhitungan gradien dalam jaringan saraf berulang untuk urutan 1000 elemen adalah setara dengan biaya untuk maju dan mundur melewati dalam jaringan saraf propagasi langsung 1000 lapisan.  <i>Metode terputus galat balik terpotong</i> (BPTT) dari waktu ke waktu digunakan untuk mengurangi biaya memperbarui parameter selama pelatihan.  Ini berarti bahwa kesalahan hanya diperbanyak selama jumlah langkah waktu yang tetap dihitung kembali dari saat ini.  Harap dicatat bahwa ketergantungan pembelajaran jangka panjang masih dimungkinkan dengan metode BPTT, karena status laten telah terungkap pada banyak langkah waktu sebelumnya. <br><br><h3>  <font color="#0071c5">Parameter</font> </h3><br>  Berikut ini adalah daftar parameter yang relevan untuk model jaringan saraf berulang / jaringan saraf dengan memori jangka pendek: <br><ul><li>  <i>Jumlah lapisan</i> .  Meningkatkan parameter ini dapat meningkatkan efisiensi model, tetapi akan membutuhkan waktu lebih lama untuk melatihnya.  Selain itu, terlalu banyak lapisan dapat menyebabkan overfitting. </li><li>  <i>Dimensi keadaan laten</i> .  Meningkatkan parameter ini dapat meningkatkan kompleksitas model, namun hal ini dapat menyebabkan overfitting. </li><li>  <i>Dimensi perbandingan vektor</i> </li><li>  <i>Panjang urutan</i> / jumlah frame sebelum memotong propagasi kembali kesalahan dari waktu ke waktu. </li><li>  <i>Kemungkinan eksklusi neuron</i> .  Probabilitas yang dengannya neuron akan dikeluarkan dari jaringan selama setiap siklus pembaruan. </li></ul><br>  Metodologi untuk memilih set parameter optimal akan dibahas nanti dalam artikel ini. <br><br><h2>  <font color="#0071c5">Implementasi, pelatihan dan pengujian</font> </h2><br><h3>  <font color="#0071c5">Pemilihan platform</font> </h3><br>  Saat ini, ada banyak platform yang memungkinkan Anda untuk menerapkan model pembelajaran mesin dalam berbagai bahasa pemrograman (termasuk bahkan JavaScript!).  Platform populer termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scikit-learn</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TensorFlow,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Torch</a> . <br><br>  Perpustakaan Torch dipilih sebagai platform untuk proyek BachBot.  Pada awalnya, perpustakaan TensorFlow dicoba, tetapi pada waktu itu menggunakan jaringan saraf berulang yang luas, yang menyebabkan meluapnya RAM GPU.  Torch adalah platform komputasi ilmiah yang didukung oleh bahasa pemrograman cepat LuaJIT *.  Platform Torch berisi perpustakaan yang sangat baik untuk bekerja dengan jaringan saraf dan optimisasi. <br><br><h3>  <font color="#0071c5">Implementasi dan pelatihan model</font> </h3><br>  Implementasinya, tentu saja, akan bervariasi tergantung pada bahasa dan platform yang Anda pilih.  Untuk mempelajari bagaimana BachBot mengimplementasikan jaringan saraf dengan memori jangka panjang dan pendek menggunakan Torch, periksa skrip yang digunakan untuk melatih dan mengatur parameter BachBot.  Skrip ini tersedia di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Feynman Lyang GitHub.</a> <br><br>  Titik awal yang baik untuk menavigasi repositori adalah <a href="">skrip 1-train.zsh</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dengannya</a> , Anda dapat menemukan path ke file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bachbot.py</a> . <br><br>  Lebih tepatnya, skrip utama untuk mengatur parameter model adalah file <a href="">LSTM.lua</a> .  Script untuk melatih model adalah file <a href="">train.lua</a> . <br><br><h3>  <font color="#0071c5">Optimalisasi Hyperparameter</font> </h3><br>  Untuk mencari nilai optimal dari hiperparameter, metode pencarian kisi digunakan menggunakan kisi parameter berikut. <br><br><img src="https://habrastorage.org/webt/91/7p/_3/917p_3g7mtewimqlykgaskxn8y0.png"><br>  <i>Kisi parameter yang digunakan oleh BachBot dalam pencarian kisi</i> <br><br>  Pencarian kisi adalah pencarian lengkap dari semua kemungkinan kombinasi parameter.  Metode lain yang disarankan untuk mengoptimalkan hiperparameter adalah pencarian acak dan optimasi Bayesian. <br><br>  Himpunan parameter optimal yang terdeteksi sebagai hasil pencarian kisi adalah sebagai berikut: jumlah lapisan = 3, dimensi keadaan tersembunyi = 256, dimensi perbandingan vektor = 32, panjang urutan = 128, probabilitas eliminasi neuron = 0,3. <br><br>  Model ini mencapai kerugian lintas-entropi 0,324 selama pelatihan dan 0,477 pada tahap verifikasi.  Grafik kurva belajar menunjukkan bahwa proses belajar menyatu setelah 30 iterasi (≈28,5 menit saat menggunakan GPU tunggal). <br><br>  Grafik kehilangan selama pelatihan dan selama fase verifikasi juga dapat menggambarkan efek dari masing-masing hyperparameter.  Yang menarik bagi kami adalah kemungkinan menghilangkan neuron: <br><br><img src="https://habrastorage.org/webt/ad/zd/_s/adzd_s3hxek23oyz8dqg_d1pkys.png"><br>  <i>Kurva Belajar untuk Berbagai Pengaturan Metode Pengecualian</i> <br><br>  Dapat dilihat pada gambar bahwa metode eliminasi benar-benar menghindari terjadinya overfitting.  Meskipun dengan kemungkinan pengecualian 0,0, kerugian selama pelatihan minimal, pada tahap verifikasi, kerugian memiliki nilai maksimum.  Nilai probabilitas yang besar menyebabkan peningkatan kerugian selama pelatihan dan penurunan kerugian pada tahap verifikasi.  Nilai minimum kerugian selama fase verifikasi saat bekerja dengan BachBot diperbaiki dengan probabilitas pengecualian 0,3. <br><br><h3>  <font color="#0071c5">Metode penilaian alternatif (opsional)</font> </h3><br>  Untuk beberapa model - terutama untuk aplikasi kreatif seperti menggubah musik - kehilangan mungkin bukan ukuran yang tepat untuk keberhasilan sistem.  Sebaliknya, persepsi manusia yang subyektif mungkin menjadi kriteria terbaik. <br><br>  Tujuan proyek BachBot adalah untuk secara otomatis membuat musik yang tidak dapat dibedakan dari komposisi Bach sendiri.  Untuk menilai keberhasilan hasil, survei pengguna di Internet dilakukan.  Survei ini diberikan dalam bentuk kompetisi di mana pengguna diminta untuk menentukan karya mana yang termasuk dalam proyek BachBot, dan mana untuk Bach. <br><br>  Hasil survei menunjukkan bahwa peserta survei (759 orang dengan berbagai tingkat pelatihan) mampu membedakan secara akurat antara dua sampel hanya dalam 59 persen kasus.  Ini hanya 9 persen lebih tinggi daripada hasil tebakan acak!  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">survei BachBot</a> sendiri! <br><br><h2>  <font color="#0071c5">Menyesuaikan model dengan harmonisasi</font> </h2><br>  Sekarang BachBot dapat menghitung P (x <sub>t + 1</sub> | x <sub>t</sub> , h <sub>t-1</sub> ), distribusi probabilitas untuk catatan berikutnya yang mungkin didasarkan pada catatan saat ini dan keadaan tersembunyi sebelumnya.  Model prediksi sekuensial ini selanjutnya dapat diadaptasi untuk menyelaraskan melodi.  Model adaptasi seperti itu diperlukan untuk menyelaraskan melodi, yang dimodulasi dengan bantuan emosi, sebagai bagian dari proyek musikal dengan tampilan slide. <br><br>  Ketika bekerja dengan harmonisasi model, melodi yang telah ditentukan disediakan (biasanya ini adalah bagian sopran), dan setelah itu model harus menyusun musik untuk sisa potongan.  Untuk menyelesaikan tugas ini, pencarian "terbaik-pertama" serakah digunakan dengan batasan bahwa nada melodi diperbaiki.  Algoritma serakah melibatkan keputusan yang optimal dari sudut pandang lokal.  Jadi, di bawah ini adalah strategi sederhana yang digunakan untuk harmonisasi: <br><blockquote>  Asumsikan bahwa <sub>xt</sub> adalah token dalam harmonisasi yang diusulkan.  Pada langkah waktu t, jika nada tersebut sesuai dengan melodi, maka <sub>xt</sub> sama dengan nada yang diberikan.  Jika tidak, <sub>xt</sub> sama dengan not selanjutnya yang <i>paling mungkin</i> sesuai dengan prediksi model.  Kode untuk adaptasi model ini dapat ditemukan di situs web Feynman Lyang GitHub: <a href="">HarmModel.lua</a> , <a href="">harmonize.lua</a> . </blockquote><br>  Berikut ini adalah contoh harmonisasi Twinkle pengantar tidur, Twinkle, Little Star dengan BachBot, menggunakan strategi di atas. <br><br><img src="https://habrastorage.org/webt/wl/mu/kf/wlmukfjpuyeswxwfr15lmkgfvrw.jpeg"><br>  <i>Harmonisasi lagu pengantar tidur Twinkle, Twinkle, Little Star dengan BachBot (di bagian soprano).</i>  <i>Bagian viola, tenor dan bass juga diisi dengan BachBot</i> <br><br>  Dalam contoh ini, melodi Twinkle pengantar tidur, Twinkle, Little Star diberikan di bagian soprano.  Setelah itu, bagian viola, tenor dan bass diisi menggunakan BachBot menggunakan strategi harmonisasi.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah bunyinya</a> . <br><br>  Terlepas dari kenyataan bahwa BachBot telah menunjukkan kinerja yang baik dalam melakukan tugas ini, ada beberapa batasan yang terkait dengan model ini.  Lebih tepatnya, algoritma <i>tidak melihat</i> ke <i>depan</i> ke dalam melodi dan hanya menggunakan not saat ini dari melodi dan konteks masa lalu untuk menghasilkan not berikutnya.  Ketika menyelaraskan melodi oleh orang-orang, mereka dapat mencakup keseluruhan melodi, yang menyederhanakan derivasi harmonisasi yang sesuai.  Fakta bahwa model ini tidak mampu melakukan hal ini dapat menimbulkan <i>kejutan</i> karena pembatasan penggunaan informasi selanjutnya yang menyebabkan kesalahan.  Untuk mengatasi masalah ini, apa yang disebut <i>pencarian balok</i> dapat digunakan. <br><br>  Saat menggunakan pencarian balok, berbagai garis gerakan diperiksa.  Misalnya, alih-alih menggunakan hanya satu, catatan yang paling mungkin, yang saat ini sedang dilakukan, empat atau lima catatan yang paling mungkin dapat dipertimbangkan, setelah itu algoritma melanjutkan pekerjaannya dengan masing-masing catatan ini.  Meneliti berbagai opsi dapat membantu model <i>pulih dari kesalahan</i> .  Pencarian balok biasanya digunakan dalam aplikasi pemrosesan bahasa alami untuk membuat kalimat. <br><br>  Melodi yang dimodulasi dengan bantuan emosi kini dapat dilewatkan melalui model harmonisasi untuk menyempurnakannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423727/">https://habr.com/ru/post/id423727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423713/index.html">"Made in Russia" - Bahasa pemrograman WBASIC untuk mengembangkan aplikasi web sisi-server</a></li>
<li><a href="../id423719/index.html">Dari Erlang / Elixir ke Jawa dan sebaliknya. Petualangan selama 20 menit</a></li>
<li><a href="../id423721/index.html">“Anda adalah seorang ibu jelek ** ker”: algoritma pendeteksian bahasa yang tidak bersahabat dan solusi</a></li>
<li><a href="../id423723/index.html">(Non) proyek komersial: Redis mengubah lisensi tetapi tetap open source</a></li>
<li><a href="../id423725/index.html">Proses desain dalam sistem ISP. Bagaimana cara memperkenalkan ideologi, membangun departemen, dan tetap hidup</a></li>
<li><a href="../id423729/index.html">5 juta akun terdaftar di ProtonMail crypto-mail</a></li>
<li><a href="../id423731/index.html">Komputasi karakter dengan Python. Bagian 1 Dasar-dasarnya</a></li>
<li><a href="../id423733/index.html">Dampak GDPR pada operator data pribadi Rusia</a></li>
<li><a href="../id423735/index.html">Konferensi Internet of Things akan menyelenggarakan Pertempuran Startups. Kami mengundang peserta</a></li>
<li><a href="../id423737/index.html">Optimalisasi kerja dengan data pasar untuk pertukaran cryptocurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>