<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≠ üë©üèº‚Äçüî¨ üâê Algoritmos de procesamiento de cadenas inteligentes en ClickHouse üç© üèüÔ∏è üßñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ClickHouse encuentra constantemente tareas de procesamiento de cadenas. Por ejemplo, buscar, calcular las propiedades de cadenas UTF-8, o algo m√°s ex√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de procesamiento de cadenas inteligentes en ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  ClickHouse encuentra constantemente tareas de procesamiento de cadenas.  Por ejemplo, buscar, calcular las propiedades de cadenas UTF-8, o algo m√°s ex√≥tico, ya sea una b√∫squeda que distingue entre may√∫sculas y min√∫sculas o una b√∫squeda de datos comprimidos. </p><br><p>  Todo comenz√≥ con el hecho de que la gerente de desarrollo de ClickHouse, Lesha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">o6CuFl2Q,</a> vino a nosotros a la Facultad de Ciencias de la Computaci√≥n de la Escuela Superior de Econom√≠a y ofreci√≥ una gran cantidad de temas para trabajos y diplomas.  Cuando vi "Algoritmos de procesamiento de cadenas inteligentes en ClickHouse" (yo, una persona que est√° interesada en varios algoritmos, incluidos los experimentales), inmediatamente establec√≠ planes sobre c√≥mo hacer el mejor diploma.  Mi alegr√≠a y expresi√≥n se pueden describir de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  ClickHouse pens√≥ cuidadosamente en la organizaci√≥n del almacenamiento de datos en la memoria, en columnas.  Al final de cada columna hay un relleno de 15 bytes para la lectura segura de un registro de 16 bytes.  Por ejemplo, ColumnString almacena cadenas terminadas nulas junto con compensaciones.  Es muy conveniente trabajar con tales matrices. </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p>  Tambi√©n hay ColumnFixedString, ColumnConst y LowCardinality, pero hoy no hablaremos de ellos con tanto detalle.  El punto principal en este punto es que el dise√±o para la lectura segura de colas es simplemente hermoso, y la localidad de los datos tambi√©n juega un papel en el procesamiento. </p><br><h2 id="poisk-po-podstrokam">  B√∫squeda de subcadenas </h2><br><p>  Lo m√°s probable es que conozca muchos algoritmos diferentes para encontrar una subcadena en una cadena.  Hablaremos sobre los que se usan en ClickHouse.  Primero presentamos un par de definiciones: </p><br><ol><li>  pajar - la l√≠nea en la que estamos buscando;  t√≠picamente la longitud se denota por <em>n</em> . </li><li>  aguja - la cadena o expresi√≥n regular que estamos buscando;  la longitud se denotar√° por <em>m</em> . </li></ol><br><p>  Despu√©s de estudiar una gran cantidad de algoritmos, puedo decir que hay 2 (m√°ximo 3) tipos de algoritmos de b√∫squeda de subcadenas.  El primero es la creaci√≥n en una forma u otra de estructuras de sufijo.  El segundo tipo son los algoritmos basados ‚Äã‚Äãen la comparaci√≥n de memoria.  Tambi√©n est√° el algoritmo Rabin-Karp, que utiliza hashes, pero es bastante √∫nico en su tipo.  El algoritmo m√°s r√°pido no existe, todo depende del tama√±o del alfabeto, la longitud de la aguja, el pajar y la frecuencia de ocurrencia. </p><br><p>  Lea sobre diferentes algoritmos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Y aqu√≠ est√°n los algoritmos m√°s populares: </p><br><ol><li>  Knut - Morris - Pratt, </li><li>  Boyer - Moore, </li><li>  Boyer - Moore - Horspool, </li><li>  Rabin - Carpa, </li><li>  Doble cara (usado en glibc llamado "memmem"), </li><li>  BNDM </li></ol><br><p>  La lista contin√∫a.  En ClickHouse, honestamente lo intentamos todo, pero al final nos decidimos por una versi√≥n m√°s extraordinaria. </p><br><h4 id="algoritm-volnickogo">  Algoritmo de Volnitsky </h4><br><p>  El algoritmo fue publicado en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog del</a> programador Leonid Volnitsky a finales de 2010.  Es algo que recuerda al algoritmo Boyer-Moore-Horspool, solo una versi√≥n mejorada. </p><br><p>  Si <em>m &lt;4</em> , entonces se usa el algoritmo de b√∫squeda est√°ndar.  Guarde todas las agujas de bigrams (2 bytes consecutivos) desde el final en una tabla hash con direccionamiento abierto de tama√±o <em>| Sigma |</em>  <em><sup>2</sup></em> elementos (en la pr√°ctica, estos son 2 <sup>16</sup> elementos), donde las compensaciones de este bigram ser√°n los valores, y el bigram en s√≠ mismo ser√° el hash y el √≠ndice al mismo tiempo.  La posici√≥n inicial estar√° en la posici√≥n <em>m - 2</em> desde el comienzo del pajar.  Seguimos al pajar con un paso de <em>m - 1</em> , mira el siguiente bigram desde esta posici√≥n en el pajar y considera todos los valores del bigram en la tabla hash.  Luego compararemos dos piezas de memoria con el algoritmo de comparaci√≥n habitual.  La cola que queda ser√° procesada por el mismo algoritmo. </p><br><p>  El paso <em>m - 1 se</em> elige de tal manera que si se produce una aguja en un pajar, definitivamente consideraremos el bigram de esta entrada, asegurando as√≠ que devolvamos la posici√≥n de la entrada en el pajar.  La primera aparici√≥n est√° garantizada por el hecho de que agregamos √≠ndices desde el final a la tabla hash por bigram.  Esto significa que cuando vamos de izquierda a derecha, primero consideraremos los bigrams desde el final de la l√≠nea (quiz√°s inicialmente considerando bigrams completamente innecesarios), luego m√°s cerca del comienzo. </p><br><p> Considera un ejemplo.  Deje que el pajar de la cuerda sea <code>abacabaac</code> y la aguja igual a <code>aaca</code> .  La tabla hash ser√° <code>{aa : 0, ac : 1, ca : 2}</code> . </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Vemos el bigram <code>ac</code> .  En aguja es, sustituimos en igualdad: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  No coincidi√≥  Despu√©s de <code>ac</code> no hay entradas en la tabla hash, pasamos al paso 3: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  No hay bigrams <code>ba</code> en la tabla hash, adelante: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Hay un bigram <code>ca</code> en aguja, miramos el desplazamiento y encontramos la entrada: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  El algoritmo tiene muchas ventajas.  En primer lugar, no necesita asignar memoria en el mont√≥n, y 64 KB en la pila no son algo trascendental ahora.  En segundo lugar, 2 <sup>16</sup> es un n√∫mero excelente para tomar un m√≥dulo para el procesador;  estas son solo instrucciones movzwl (o, como bromeamos, "movsvl") y la familia. </p><br><p>  En promedio, este algoritmo demostr√≥ ser el mejor.  Tomamos los datos de Yandex.Metrica, las solicitudes son casi reales.  Una velocidad de transmisi√≥n, m√°s es mejor, KMP: algoritmo Knut - Morris - Pratt, BM: Boyer - Moore, BMH: Boyer - Moore - Horspool. </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p>  Para no ser infundado, el algoritmo puede funcionar en tiempo cuadr√°tico: </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p>  Se utiliza en la funci√≥n de <code>position(Column, ConstNeedle)</code> y tambi√©n act√∫a como una optimizaci√≥n para b√∫squedas de expresiones regulares. </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam">  B√∫squeda de expresiones regulares </h2><br><p>  Le diremos c√≥mo ClickHouse optimiza las b√∫squedas de expresiones regulares.  Muchas expresiones regulares contienen una subcadena dentro, que debe estar dentro de un pajar.  Para no construir una m√°quina de estados finitos y verificarla, aislaremos tales subcadenas. </p><br><p>  Hacer esto es bastante simple: cualquier par√©ntesis de apertura aumenta el nivel de anidaci√≥n, cualquier par√©ntesis de cierre disminuye;  Tambi√©n hay caracteres espec√≠ficos para las expresiones regulares (por ejemplo, '.', '*', '?', '\ w', etc.).  Necesitamos obtener todas las subcadenas en el nivel 0. Considere un ejemplo: <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p>  Lo dividimos en esas subcadenas que deben estar en el pajar de la expresi√≥n regular, despu√©s de lo cual seleccionamos la longitud m√°xima, buscamos candidatos en √©l y luego verificamos con el motor de expresi√≥n regular RE2 habitual.  Hay una expresi√≥n regular en la imagen de arriba, es procesada por el motor RE2 habitual a 736 MB / s, Hyperscan (aproximadamente un poco m√°s tarde) maneja a 1.6 GB / s, y manejamos 1.69 GB / s por n√∫cleo, junto con la descompresi√≥n LZ4.  En general, dicha optimizaci√≥n est√° en la superficie y acelera en gran medida la b√∫squeda de expresiones regulares, pero a menudo no se implementa en herramientas, lo que me sorprende mucho. </p><br><p>  La palabra clave LIKE tambi√©n se optimiza utilizando este algoritmo, solo despu√©s de LIKE puede aparecer una expresi√≥n regular muy simplificada en %%%%%% (subcadena arbitraria) y <code>_</code> (car√°cter arbitrario). </p><br><p>  Desafortunadamente, no todas las expresiones regulares est√°n sujetas a tales optimizaciones, por ejemplo, desde <code>yandex|google</code> es imposible extraer expl√≠citamente las subcadenas que deben ocurrir en el pajar.  Por lo tanto, se nos ocurri√≥ una soluci√≥n completamente diferente. </p><br><h2 id="poisk-po-mnogim-podstrokam">  Busca muchas subcadenas </h2><br><p>  El problema es que hay muchas agujas, y quiero entender si al menos una de ellas est√° incluida en el pajar.  Existen m√©todos bastante cl√°sicos para tal b√∫squeda, por ejemplo, el algoritmo Aho-Korasik.  Pero no fue demasiado r√°pido para nuestra tarea.  Hablaremos de esto un poco m√°s tarde. </p><br><p><del>  Lesha </del>  ClickHouse adora las soluciones no est√°ndar, por lo que decidimos probar algo diferente y, tal vez, crear un nuevo algoritmo de b√∫squeda.  Y lo hicieron. </p><br><p>  Observamos el algoritmo Volnitsky y lo modificamos para que comenzara a buscar muchas subcadenas a la vez.  Para hacer esto, solo necesita agregar los bigrams de todas las filas y almacenar adem√°s un √≠ndice de fila en la tabla hash.  El paso se seleccionar√° de al menos todas las longitudes de aguja menos 1 para garantizar nuevamente la propiedad de que si ocurre, veremos su bigram.  La tabla hash crecer√° a 128 KB (las l√≠neas m√°s largas que 255 son procesadas por el algoritmo est√°ndar, consideraremos no m√°s de 256 agujas).  Soy muy vago, as√≠ que aqu√≠ hay un ejemplo de la presentaci√≥n (le√≠da de izquierda a derecha de arriba a abajo): </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p>  Comenzamos a ver c√≥mo se comporta tal algoritmo en comparaci√≥n con otros (las filas se toman de datos reales).  Y para un peque√±o n√∫mero de l√≠neas, hace todo (se indica la velocidad junto con la descarga, aproximadamente 2.5 GB / s). </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p>  Entonces se hizo interesante.  Por ejemplo, con una gran cantidad de bigrams similares, perdemos ante algunos competidores.  Es comprensible: comenzamos a comparar muchos recuerdos y a degradarnos. </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p>  No puede acelerar mucho si la longitud m√≠nima de la aguja es lo suficientemente grande.  Obviamente, tenemos m√°s oportunidades para omitir piezas enteras de pajar sin pagar nada por ello. </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p>  El punto de inflexi√≥n comienza en alg√∫n lugar de las l√≠neas 13-15.  Alrededor del 97% de las solicitudes que vi en el cl√∫ster eran menos de 15 filas: </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p>  Bueno, una imagen muy aterradora: 41 l√≠neas, muchas bigrams repetidas: </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p>  Como resultado, en ClickHouse (19.5) implementamos las siguientes funciones a trav√©s de este algoritmo: </p><br><p>  - <code>multiSearchAny(h, [n_1, ..., n_k])</code> - 1, si al menos una de las agujas est√° en el pajar. <br>  - <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> : la posici√≥n de entrada m√°s a la izquierda en el pajar (de uno) o 0 si no se encuentra. <br>  - <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> : el √≠ndice de la aguja m√°s a la izquierda, que se encontr√≥ en el pajar;  0 si no se encuentra. <br>  - <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> : todas las primeras posiciones de todas las agujas devuelven una matriz. </p><br><p>  Los sufijos son -UTF8 (no normalizamos), -CaseInsensitive (agregue 4 bigrams con may√∫sculas y min√∫sculas diferentes), -CaseInsensitiveUTF8 (existe la condici√≥n de que las letras may√∫sculas y min√∫sculas deben tener el mismo n√∫mero de bytes).  Vea la implementaci√≥n <a href="">aqu√≠</a> . </p><br><p>  Despu√©s de eso, nos preguntamos si podr√≠amos hacer algo similar con muchas expresiones regulares.  Y encontraron una soluci√≥n que ya estaba estropeada en los puntos de referencia. </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam">  Buscar por muchas expresiones regulares </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hyperscan</a> es una biblioteca de Intel que busca de inmediato muchas expresiones regulares.  Utiliza la heur√≠stica para aislar las subpalabras de las expresiones regulares sobre las que escribimos, y muchos SIMD para buscar el aut√≥mata Glushkov (el algoritmo parece llamarse Teddy). </p><br><p>  En general, todo est√° en las mejores tradiciones de sacar el m√°ximo provecho de la b√∫squeda de expresiones regulares.  La biblioteca realmente hace lo que se declara en sus funciones. </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p>  Afortunadamente, en mi mes de desarrollo en ClickHouse, pude superar el desarrollo de 12 a√±os en una clase de consultas decente y estoy muy satisfecho con esto. </p><br><p>  En Yandex, la biblioteca Hyperscan tambi√©n se usa en antispam.  A juzgar por las revisiones, procesa con calma miles de expresiones regulares y las busca r√°pidamente. </p><br><p>  La biblioteca tiene varias desventajas.  El primero es la cantidad indocumentada de memoria consumida y una caracter√≠stica extra√±a de que el pajar debe tener menos de 2 <sup>32</sup> bytes.  El segundo: no puede devolver las primeras posiciones de forma gratuita, los √≠ndices de aguja m√°s a la izquierda, etc. Y el tercer signo negativo: hay algunos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores</a> de la nada.  Por lo tanto, en ClickHouse, implementamos las siguientes funciones usando Hyperscan: </p><br><p>  - <code>multiMatchAny(h, [n_1, ..., n_k])</code> - 1, si al menos una de las agujas tiene pajar. <br>  - <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> : cualquier √≠ndice de la aguja que <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> pajar. </p><br><p>  Estamos interesados, pero ¬øc√≥mo puede buscar no exactamente, sino aproximadamente?  Y se le ocurrieron varias soluciones. </p><br><h2 id="priblizhyonnyy-poisk">  B√∫squeda aproximada </h2><br><p>  El est√°ndar en la b√∫squeda aproximada es la distancia de Levenshtein: el n√∫mero m√≠nimo de caracteres que se pueden reemplazar, agregar y eliminar para obtener una cadena b de longitud n de una cadena a de longitud m.  Desafortunadamente, el ingenuo algoritmo de programaci√≥n din√°mica funciona para <em>O (mn)</em> ;  las mejores mentes de ShAD pueden hacerlo en <em>O (mn / log max (n, m))</em> ;  es f√°cil pensar en <em>O ((n + m) ‚ãÖ alfa)</em> , donde <em>alfa</em> es la respuesta;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la ciencia</a> puede hacerlo para <em>O ((alpha - | n - m |) min (m, n, alpha) + m + n)</em> (el algoritmo es simple, leer al menos en el ShAD) o, si es un poco m√°s claro, para <em>O (alpha ^ 2 + m + n)</em> .  Todav√≠a hay un punto negativo: lo m√°s probable es que sea imposible deshacerse del tiempo cuadr√°tico en el peor de los casos polinomialmente. Peter Indik escribi√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> muy poderoso sobre esto. </p><br><p>  Hay un ejercicio: imagine que por reemplazar un personaje en la distancia de Levenshtein paga una multa, no dos, sino dos;  luego, encuentre un algoritmo para <em>O ((n + m) log (n + m))</em> . </p><br><p>  Todav√≠a no funciona, demasiado largo y costoso.  Pero con la ayuda de tal distancia, hicimos la detecci√≥n de errores tipogr√°ficos en las consultas. </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p>  Adem√°s de la distancia de Levenshtein, hay una distancia de Hamming.  Con √©l tambi√©n, todo es bastante malo, pero un poco mejor que con la distancia de Levenshtein.  No tiene en cuenta la eliminaci√≥n de caracteres, pero considera solo para dos l√≠neas de la misma longitud el n√∫mero de caracteres en los que difieren.  Por lo tanto, si usamos la distancia para cadenas de longitud m &lt;n, entonces solo en la b√∫squeda de las subcadenas m√°s cercanas. </p><br><p>  C√≥mo calcular dicha matriz de discrepancias (una matriz d de n - m + 1 elementos, donde d [i] es el n√∫mero de caracteres diferentes en el i-√©simo desde el comienzo de la superposici√≥n) para <em>O (| Sigma | (n + m) log (n + m) )</em> ?  Primero, haz <em>| Sigma |</em>  M√°scaras de bits que indican si este s√≠mbolo es igual al considerado.  A continuaci√≥n, calculamos la respuesta para cada una de las m√°scaras Sigma y sumamos: obtenemos la respuesta original. </p><br><p>  Considera un ejemplo.  <code>abba</code> , subcadena <code>ba</code> , alfabeto binario.  Obtenemos 2 m√°scaras <code>1001, 01</code> y <code>0110, 10</code> . </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p>  Obtenemos la matriz [0, 1, 2], esta es casi la respuesta correcta.  Pero tenga en cuenta que para cada letra, el n√∫mero de coincidencias es solo el producto escalar de una aguja binaria fija y todas las subcadenas de pajar.  Y para esto, por supuesto, ¬°hay una r√°pida transformaci√≥n de Fourier! </p><br><p>  Para aquellos que no saben: la FFT puede multiplicar dos polinomios de grados <em>m &lt;n</em> en un tiempo <em>O (n log n)</em> , siempre que el trabajo con los coeficientes se realice por unidad de tiempo.  Las convoluciones son muy similares a los productos escalares.  Es suficiente duplicar los coeficientes del primer polinomio, y expandir y complementar el segundo con el n√∫mero requerido de ceros, luego obtenemos todos los productos escalares de una cadena binaria y todas las subcadenas de la otra en <em>O (n log n)</em> , ¬°alg√∫n tipo de magia!  Pero cr√©eme, esto es absolutamente real, y a veces la gente lo hace. </p><br><p>  Pero no en ClickHouse.  Para nosotros, trabajando con | Sigma |  = 30 ya es grande, y el FFT no es el algoritmo pr√°ctico m√°s agradable para el procesador o, como dicen en la gente com√∫n, "la constante es grande". </p><br><p>  Por lo tanto, decidimos mirar otras m√©tricas.  Llegamos a la bioinform√°tica, donde las personas usan la distancia de n gramos.  De hecho, tomamos todos los n-gramos de pajar y aguja, consideremos 2 multisets con estos n-gramos.  Luego tomamos la diferencia sim√©trica y la dividimos por la suma de las cardinalidades de dos conjuntos m√∫ltiples con n-gramos.  Obtenemos un n√∫mero del 0 al 1: cuanto m√°s cerca de 0, m√°s se parecen las l√≠neas.  Considere un ejemplo donde <em>n = 4</em> : </p><br><pre> <code class="plaintext hljs">abcda ‚Üí {abcd, bcda}; Size = 2 bcdab ‚Üí {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p>  Como resultado, hicimos una distancia de 4 gramos y atascamos un mont√≥n de ideas de SSE all√≠, y tambi√©n debilitamos ligeramente la implementaci√≥n a hash crc32 de doble byte. </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p>  Echa un vistazo a la <a href="">implementaci√≥n</a> .  Precauci√≥n: c√≥digo muy convincente y optimizado para compiladores. </p><br><p>  Le aconsejo especialmente que preste atenci√≥n al <a href="">truco sucio</a> para emitir min√∫sculas para los puntos de c√≥digo ASCII y ruso. </p><br><p>  - <code>ngramDistance(haystack, needle)</code> : devuelve un n√∫mero de 0 a 1;  cuanto m√°s cerca de 0, m√°s l√≠neas son similares entre s√≠. <br>  - -UTF8, -CaseInsensitive, -CaseInsensitiveUTF8 (truco sucio para rusos y ASCII). </p><br><p>  Hyperscan tampoco se detiene; tiene la funcionalidad de b√∫squeda aproximada: puede buscar l√≠neas que parecen expresiones regulares por la distancia constante de Levenshtein.  Se crea <em>un</em> aut√≥mata <em>distancia + 1</em> , que se interconecta eliminando, reemplazando o insertando un car√°cter, que significa "bien", despu√©s de lo cual se aplica el algoritmo habitual para verificar si un aut√≥mata acepta una l√≠nea en particular.  En ClickHouse, los implementamos con los siguientes nombres: </p><br><p>  - <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> - similar a multiMatchAny, solo con distancia. <br>  - <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> - similar a multiMatchAnyIndex, solo con distancia. </p><br><p>  Con el aumento de la <em>distancia, la</em> velocidad comienza a degradarse mucho, pero a√∫n se mantiene en un nivel bastante decente. </p><br><p>  Finalice la b√∫squeda y comience a procesar cadenas UTF-8.  Tambi√©n hubo muchas cosas interesantes. </p><br><h2 id="obrabotka-utf-8-strok">  Procesamiento de l√≠nea UTF-8 </h2><br><p>  Admito que fue dif√≠cil romper el techo de implementaciones ingenuas en cadenas codificadas UTF-8.  Fue especialmente dif√≠cil atornillar SIMD.  Compartir√© algunas ideas sobre c√≥mo hacer esto. </p><br><p>  Recuerde c√≥mo se ve una secuencia UTF-8 v√°lida: </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p>  Intentemos calcular la longitud del punto de c√≥digo por el primer byte.  Aqu√≠ es donde comienza la magia de bits.  Nuevamente escribimos algunas propiedades: </p><br><p>  - Comenzando en 0xC <em>y en 0xD</em> tienen 2 bytes <br>  - 0xC2 = 11 <u>0</u> 00010 <br>  - 0xDF = 11 <u>0</u> 11111 <br>  - 0xE0 = 111 <u>0</u> 0000 <br>  - 0xF4 = 1111 <u>0</u> 100, no hay nada m√°s que 0xF4, pero si hubiera 0xF8, habr√≠a una historia diferente <br>  - Responda 7 menos la posici√≥n del primer cero desde el final, si no es un car√°cter ASCII </p><br><p>  Calculamos la longitud: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p>  Afortunadamente, tenemos en stock instrucciones que pueden calcular el n√∫mero de bits cero, comenzando por los m√°s significativos. </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p>  Calcular bitScanReverse: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p>  Intentemos calcular la longitud de una cadena UTF-8 por puntos de c√≥digo a trav√©s de SIMD.  Para hacer esto, mire cada byte como un n√∫mero con signo y observe las siguientes propiedades: </p><br><p>  - 0xBF = -65 <br>  - 0x80 = -128 <br>  - 0xC2 = -62 <br>  - 0x7F = 127 <br>  - todos los primeros bytes est√°n en [0xC2, 0x7F] <br>  - todos los primeros bytes est√°n en [0x80, 0xBF] </p><br><p>  El algoritmo es bastante simple.  Compare cada byte con -65 y, si es mayor que este n√∫mero, agregue uno.  Si queremos usar SIMD, entonces esta es la carga habitual de 16 bytes del flujo de entrada.  Luego hay una comparaci√≥n de bytes, que en el caso de un resultado positivo dar√° el byte 0xFF, y en el caso de un negativo - 0x00.  Luego, la instrucci√≥n <code>pmovmskb</code> , que recopilar√° los bits altos de cada byte del registro.  Luego, el n√∫mero de guiones bajos aumenta, usamos el intr√≠nseco para la instrucci√≥n <code>popcnt</code> SSE4.  El esquema de este algoritmo puede ilustrarse con un ejemplo: </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p>  Resulta que, junto con la descompresi√≥n, el procesamiento por n√∫cleo ser√° de aproximadamente 1,5 GB / s. </p><br><p>  Las funciones se llaman: </p><br><p>  - <code>lengthUTF8(string)</code> : devuelve la longitud de una cadena UTF-8 codificada correctamente, se considera que algo no es v√°lido, no se produce una excepci√≥n. </p><br><p>  Fuimos m√°s all√° porque quer√≠amos a√∫n m√°s funciones con el procesamiento de cadenas UTF-8.  Por ejemplo, verificar la validez y convertir a una expresi√≥n UTF-8 v√°lida. </p><br><p>  Para verificar la validez, tom√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/cyb70289/utf8/</a> , adaptado para ClickHouse (en realidad solo cambi√© el procesamiento de las colas) y obtuve una velocidad de 1.22 GB / s en comparaci√≥n con 900 MB / s para el algoritmo ingenuo .  No describir√© el algoritmo en s√≠, es bastante complicado para la percepci√≥n. </p><br><p>  - <code>isValidUTF8(string)</code> : devuelve 1 si la cadena est√° codificada correctamente con UTF-8; de lo contrario, 0. <br>  - <code>toValidUTF8(string)</code> : reemplaza los caracteres UTF-8 no v√°lidos con el car√°cter   (U + FFFD).  Todos los caracteres inv√°lidos consecutivos colapsan en un car√°cter de reemplazo.  No hay ciencia espacial. </p><br><p>  En general, en las l√≠neas UTF-8, debido al esquema est√°tico no tan agradable, siempre es dif√≠cil encontrar algo que est√© bien optimizado. </p><br><h2 id="chto-dalshe">  Que sigue </h2><br><p>  D√©jame recordarte que esta fue mi tesis.  Por supuesto, la defend√≠ por 10/10.  Ya fuimos con ella a Highload ++ Siberia (aunque me pareci√≥ que no le interesaba a nadie).  Mira la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n</a> .  Me gust√≥ que la parte pr√°ctica de la tesis result√≥ en una gran cantidad de investigaciones interesantes.  Y aqu√≠ est√° el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diploma en</a> s√≠.  Tiene muchos errores tipogr√°ficos, porque nadie lo ley√≥.  :) </p><br><p>  Como parte de la preparaci√≥n del diploma, hice un mont√≥n de otros trabajos similares (los enlaces conducen a solicitudes de grupo): </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funci√≥n optimizada de concat 2 veces</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hizo el formato de Python m√°s simple para solicitudes</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acelerado LZ4 en un 4%</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hice un gran trabajo en SIMD para ARM y PPC64LE</a> ; <br>  - Y aconsej√≥ a un par de estudiantes del FCS con diplomas en ClickHouse. </p><br><p>  Al final, result√≥ que, en mi experiencia, <del>  cada mes Lesha intentaba cantarme </del>  ClickHouse es el sistema m√°s agradable para escribir c√≥digo de alto rendimiento, donde hay documentaci√≥n, comentarios, excelente soporte para desarrolladores y desarrolladores.  ClickHouse es impresionante, de verdad.  ¬øCansado de cambiar los formatos JSON?  Venga a Lesha y solicite una tarea de cualquier nivel: √©l se la proporcionar√° y durante el fin de semana obtendr√° un gran placer escribiendo c√≥digo. </p><br><p>  Pero con todos los logros de ClickHouse y su dise√±o, probablemente no se trata de ellos.  No principalmente en ellos. </p><br><p>  Pas√© 4 a√±os de estudios de pregrado en el FCS, en junio me gradu√© del HSE con honores, trabaj√© durante un a√±o y medio en un equipo incre√≠ble en Yandex, despu√©s de haber bombeado bien.  Sin experiencia total todo este tiempo <del>  y hierro </del>  Nada de lo escrito en la publicaci√≥n hubiera funcionado.  FCN es muy bueno, si le quitas el m√°ximo.  Gracias a Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ivan_puzyrevskiy</a> , Ignat Kolesnichenko, Gleb Evstropov, Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">maxim_babenko</a> por reunirse en mi divertida aventura en FCN.  Y tambi√©n gracias a todos los profesores que me ense√±aron algo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466183/">https://habr.com/ru/post/466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466165/index.html">C√≥mo la inteligencia artificial ayuda a gestionar proyectos</a></li>
<li><a href="../466169/index.html">Oferta especial para estudiantes que trabajan de JetBrains</a></li>
<li><a href="../466171/index.html">Cinco razones para ir a JUG.EKB</a></li>
<li><a href="../466179/index.html">fform: React & JSONSchema - m√°xima flexibilidad</a></li>
<li><a href="../466181/index.html">Python desde C (C API)</a></li>
<li><a href="../466187/index.html">Editor de l√≥gica visual para Unity3d. Parte 2</a></li>
<li><a href="../466191/index.html">Lo principal de la batalla por la neutralidad de la red en los Estados Unidos es la cronolog√≠a de los eventos y el estado actual de las cosas.</a></li>
<li><a href="../466193/index.html">Alimentaci√≥n autom√°tica de MailChimp personalizada desde RSS</a></li>
<li><a href="../466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>