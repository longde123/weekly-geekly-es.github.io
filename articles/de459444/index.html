<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí® ‚òòÔ∏è üë©üèª‚Äçüåæ J√ºngste √Ñnderungen im Linux IO-Stack aus DBA-Sicht üë∞üèΩ üßöüèΩ üë®‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Hauptprobleme beim Arbeiten mit der Datenbank h√§ngen mit den Funktionen des Ger√§ts des Betriebssystems zusammen, auf dem die Datenbank arbeitet. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>J√ºngste √Ñnderungen im Linux IO-Stack aus DBA-Sicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/459444/">  Die Hauptprobleme beim Arbeiten mit der Datenbank h√§ngen mit den Funktionen des Ger√§ts des Betriebssystems zusammen, auf dem die Datenbank arbeitet.  Linux ist jetzt das Hauptbetriebssystem f√ºr Datenbanken.  Solaris, Microsoft und sogar HPUX werden immer noch im Unternehmen verwendet, aber sie werden niemals den ersten Platz einnehmen, selbst wenn sie kombiniert werden.  Linux gewinnt zuversichtlich an Boden, da es immer mehr Open-Source-Datenbanken gibt.  Daher geht es bei der Datenbankinteraktion mit dem Betriebssystem offensichtlich um Linux-Datenbanken.  Dies √ºberlagert das ewige DB-Problem - die E / A-Leistung.  Es ist gut, dass Linux in den letzten Jahren den E / A-Stack grundlegend √ºberarbeitet hat und Hoffnung auf Aufkl√§rung besteht. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0o7uNUOS-Ho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ilya Kosmodemyansky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Hydrobiont</a> ) arbeitet f√ºr Data Egret, ein Unternehmen, das PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">konsultiert</a> und unterst√ºtzt, und wei√ü viel √ºber die Interaktion zwischen Betriebssystem und Datenbanken.  In einem Bericht √ºber HighLoad ++ sprach Ilya am Beispiel von PostgreSQL √ºber die Interaktion von E / A und Datenbanken, zeigte aber auch, wie andere Datenbanken mit E / A funktionieren.  Ich habe mir den Linux IO-Stack angesehen, welche neuen und guten Dinge darin erschienen sind und warum nicht alles so ist, wie es vor ein paar Jahren war.  Als n√ºtzliche Erinnerung - eine Checkliste mit PostgreSQL- und Linux-Einstellungen f√ºr maximale Leistung des E / A-Subsystems in den neuen Kerneln. <br><a name="habracut"></a><br>  <i>Das Berichtsvideo enth√§lt viel Englisch, von dem wir die meisten im Artikel √ºbersetzt haben.</i> <br><br><h2>  Warum √ºber IO sprechen? </h2><br>  <strong>Schnelle E / A ist f√ºr Datenbankadministratoren das Wichtigste</strong> .  Jeder wei√ü, was sich bei der Arbeit mit der CPU √§ndern l√§sst, dass der Speicher erweitert werden kann, aber E / A kann alles ruinieren.  Wenn es mit Festplatten und zu viel E / A schlecht ist, st√∂hnt die Datenbank.  IO wird zu einem Engpass. <br><br><blockquote>  Damit alles gut funktioniert, m√ºssen Sie alles konfigurieren. </blockquote><br>  Nicht nur die Datenbank oder nur die Hardware - das war's.  Sogar das Oracle auf hoher Ebene, das an einigen Stellen selbst ein Betriebssystem ist, muss konfiguriert werden.  Wir lesen die Anweisungen im "Installationshandbuch" von Oracle: √Ñndern Sie solche Kernel-Parameter, √§ndern Sie andere - es gibt viele Einstellungen.  Zus√§tzlich zu der Tatsache, dass in Unbreakable Kernel vieles bereits standardm√§√üig mit Oracle Linux verbunden ist. <br><br>  F√ºr PostgreSQL und MySQL sind noch weitere √Ñnderungen erforderlich.  Dies liegt daran, dass diese Technologien auf Betriebssystemmechanismen beruhen.  Ein DBA, der mit PostgreSQL, MySQL oder modernem NoSQL funktioniert, muss ein Linux-Betriebsingenieur sein und verschiedene Betriebssysteme verr√ºckt machen. <br><br>  Jeder, der sich mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kerneleinstellungen</a> befassen m√∂chte, wendet sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LWN</a> .  Die Ressource ist genial, minimalistisch, enth√§lt viele n√ºtzliche Informationen, wurde jedoch <strong>von Kernel-Entwicklern f√ºr Kernel-Entwickler geschrieben</strong> .  Was schreiben Kernel-Entwickler gut?  Der Kern, nicht der Artikel, wie man es benutzt.  Deshalb werde ich versuchen, Ihnen alles f√ºr die Entwickler zu erkl√§ren und sie den Kernel schreiben zu lassen. <br><br>  Alles wird oft dadurch kompliziert, dass die Entwicklung des Linux-Kernels und die Verarbeitung seines Stacks anfangs hinterherhinken und in den letzten Jahren sehr schnell gegangen sind.  Weder Eisen noch Entwickler mit Artikeln hinter sich k√∂nnen mithalten. <br><br><h2>  Typische Datenbank </h2><br>  Beginnen wir mit den Beispielen f√ºr PostgreSQL - hier ist I / O gepuffert.  Es verf√ºgt √ºber einen gemeinsam genutzten Speicher, der aus Sicht des Betriebssystems im <strong>Benutzerbereich</strong> zugewiesen wird, und √ºber denselben Cache im Kernel-Cache im <strong>Kernel-Bereich</strong> . <br><br><img src="https://habrastorage.org/webt/jd/dh/d2/jddhd25l97pocaqtqqf6ccygcxi.jpeg"><br><br>  <strong>Die Hauptaufgabe einer modernen Datenbank</strong> : <br><br><ul><li>  Nehmen Sie Seiten von der Festplatte im Speicher auf. </li><li>  Wenn eine √Ñnderung auftritt, markieren Sie die Seiten als verschmutzt. </li><li>  in das Write-Ahead-Protokoll schreiben; </li><li>  Synchronisieren Sie dann den Speicher so, dass er mit der Festplatte √ºbereinstimmt. </li></ul><br>  In einer PostgreSQL-Situation ist dies ein st√§ndiger Roundtrip: vom gemeinsam genutzten Speicher, den PostgreSQL im Page Cache-Kernel steuert, und dann √ºber den gesamten Linux-Stack auf die Festplatte.  Wenn Sie eine Datenbank in einem Dateisystem verwenden, funktioniert dieser Algorithmus mit jedem UNIX-√§hnlichen System und mit jeder Datenbank.  Unterschiede sind, aber unbedeutend. <br><br>  Die Verwendung von Oracle ASM ist anders - Oracle selbst interagiert mit der Festplatte.  Das Prinzip ist jedoch dasselbe: Mit Direct IO oder mit Page Cache besteht die Aufgabe jedoch <strong>darin, Seiten so schnell wie m√∂glich durch den gesamten E / A-Stapel zu zeichnen</strong> , unabh√§ngig davon, um was es sich handelt.  Und in jeder Phase k√∂nnen Probleme auftreten. <br><br><h3>  Zwei Probleme von IO </h3><br>  W√§hrend alles <strong>schreibgesch√ºtzt ist</strong> , gibt es keine Probleme.  Sie lesen und wenn gen√ºgend Speicher vorhanden ist, werden alle zu lesenden Daten im RAM abgelegt.  Die Tatsache, dass im Fall von PostgreSQL im <strong>Puffer-Cache</strong> dieselbe ist, macht uns keine gro√üen Sorgen. <br><br><img src="https://habrastorage.org/webt/mh/0j/sm/mh0jsmmdrh5bosmamuaiko9l-jw.jpeg"><br><br>  <strong>Das erste Problem mit E / A ist die Cache-Synchronisation.</strong>  Tritt auf, wenn eine Aufzeichnung erforderlich ist.  In diesem Fall m√ºssen Sie viel mehr Speicher hin und her fahren. <br><br><img src="https://habrastorage.org/webt/tq/mw/u7/tqmwu7fy-wlwqjx6nxec6jfcyrk.jpeg"><br><br>  Dementsprechend m√ºssen Sie PostgreSQL oder MySQL so konfigurieren, dass alles vom gemeinsam genutzten Speicher auf die Festplatte gelangt.  Im Fall von PostgreSQL m√ºssen Sie den Hintergrundbetrug schmutziger Seiten unter Linux noch optimieren, um alles auf die Festplatte zu senden. <br><br>  <strong>Das zweite h√§ufige Problem ist ein Schreibfehler beim Write-Ahead-Protokoll</strong> .  Es wird angezeigt, wenn die Last so stark ist, dass sogar ein nacheinander aufgezeichnetes Protokoll auf der Festplatte liegt.  In dieser Situation muss es auch schnell aufgezeichnet werden. <br><br>  Die Situation unterscheidet sich nicht wesentlich von der <strong>Cache-Synchronisation</strong> .  In PostgreSQL arbeiten wir mit einer gro√üen Anzahl gemeinsam genutzter Puffer. Die Datenbank verf√ºgt √ºber Mechanismen f√ºr eine effiziente Write-Ahead-Protokollaufzeichnung und ist bis zum Limit optimiert.  Das einzige, was getan werden kann, um das Protokoll selbst effizienter zu gestalten, ist das √Ñndern der Linux-Einstellungen. <br><br><h2>  Die Hauptprobleme bei der Arbeit mit der Datenbank </h2><br>  <strong>Das gemeinsam genutzte Speichersegment kann sehr gro√ü sein</strong> .  Ich habe 2012 auf Konferenzen dar√ºber gesprochen.  Dann sagte ich, dass der Speicher im Preis gefallen ist, auch wenn es Server mit 32 GB RAM gibt.  Im Jahr 2019 sind m√∂glicherweise bereits mehr Laptops vorhanden, immer h√§ufiger auf den Servern 128, 256 usw. <br><br>  <strong>Wirklich viel Ged√§chtnis</strong> .  Banale Aufnahmen erfordern Zeit und Ressourcen, und die <strong>Technologien, die wir daf√ºr verwenden, sind konservativ</strong> .  Datenbanken sind alt, sie wurden lange entwickelt und entwickeln sich langsam weiter.  Die Mechanismen in den Datenbanken stimmen mit der neuesten Technologie nicht genau √ºberein. <br><br>  <strong>Das Synchronisieren von Seiten im Speicher mit der Festplatte f√ºhrt zu gro√üen E / A-Vorg√§ngen</strong> .  Wenn wir Caches synchronisieren, entsteht ein gro√üer Strom von E / A und ein weiteres Problem - <strong>wir k√∂nnen etwas nicht verdrehen und den Effekt betrachten.</strong>  In einem wissenschaftlichen Experiment √§ndern Forscher einen Parameter - erhalten Sie den Effekt, den zweiten - erhalten Sie den Effekt, den dritten.  Wir werden es nicht schaffen.  Wir verdrehen einige Parameter in PostgreSQL, konfigurieren Checkpoints - wir haben den Effekt nicht gesehen.  Konfigurieren Sie dann erneut den gesamten Stapel, um zumindest einige Ergebnisse zu erhalten.  Twist One-Parameter funktioniert nicht - wir m√ºssen alles auf einmal konfigurieren. <br><br>  Die meisten PostgreSQL-E / A generieren eine Seitensynchronisation: Pr√ºfpunkte und andere Synchronisationsmechanismen.  Wenn Sie mit PostgreSQL gearbeitet haben, haben Sie m√∂glicherweise Checkpoints-Spitzen gesehen, wenn regelm√§√üig eine ‚ÄûS√§ge‚Äú in den Diagrammen angezeigt wird.  Fr√ºher waren viele mit diesem Problem konfrontiert, aber jetzt gibt es Handb√ºcher zur Behebung. Es ist einfacher geworden. <br><br>  SSDs retten heute die Situation erheblich.  Bei PostgreSQL ruht etwas selten direkt auf dem Wertedatensatz.  Alles h√§ngt von der Synchronisation ab: Wenn ein Pr√ºfpunkt auftritt, wird fsync aufgerufen und es gibt eine Art ‚ÄûSchlagen‚Äú eines Pr√ºfpunkts auf einen anderen.  Zu viel IO.  Ein Checkpoint ist noch nicht beendet, hat noch nicht alle Fsyncs abgeschlossen, hat aber bereits einen weiteren Checkpoint verdient und es hat begonnen! <br><br>  PostgreSQL hat eine einzigartige Funktion - <strong>Autovacuum</strong> .  Dies ist eine lange Geschichte von Kr√ºcken f√ºr die Datenbankarchitektur.  Wenn das Autovakuum ausf√§llt, wird es normalerweise so eingerichtet, dass es aggressiv funktioniert und den Rest nicht beeintr√§chtigt: Es gibt viele Autovakuumarbeiter, die h√§ufig ein wenig stolpern und Tabellen schnell verarbeiten.  Andernfalls treten Probleme mit DDL und Sperren auf. <br><br><blockquote>  Aber wenn Autovacuum aggressiv ist, beginnt es auf IO zu kauen. </blockquote><br>  Wenn Checkpoints mit Autovakuum √ºberlagert werden, werden die Festplatten die meiste Zeit zu fast 100% recycelt, und dies ist die Ursache der Probleme. <br><br>  Seltsamerweise gibt es ein <strong>Cache-Nachf√ºllproblem</strong> .  Sie ist normalerweise weniger bekannt f√ºr DBA.  Ein typisches Beispiel: Die Datenbank wurde gestartet und f√ºr einige Zeit verlangsamt sich alles traurig.  Kaufen Sie daher auch bei viel RAM gute Festplatten, damit der Stapel den Cache erw√§rmt. <br><br>  All dies beeintr√§chtigt die Leistung erheblich.  Probleme beginnen nicht unmittelbar nach dem Neustart der Datenbank, sondern sp√§ter.  Beispielsweise wurde der Pr√ºfpunkt √ºbergeben, und viele Seiten sind in der gesamten Datenbank verschmutzt.  Sie werden auf die Festplatte kopiert, da Sie sie synchronisieren m√ºssen.  Dann fordern die Anforderungen eine neue Version der Seiten von der Festplatte an, und die Datenbank h√§ngt ab.  Die Grafiken zeigen, wie das Nachf√ºllen des Caches nach jedem Pr√ºfpunkt einen bestimmten Prozentsatz zur Last beitr√§gt. <br><br>  Das Unangenehmste an der Eingabe / Ausgabe der Datenbank ist <strong>Worker IO.</strong>  Wenn jeder von Ihnen angeforderte Mitarbeiter mit der Generierung seiner E / A beginnt.  In Oracle ist es einfacher, aber in PostgreSQL ist es ein Problem. <br><br>  Es gibt viele Gr√ºnde f√ºr Probleme mit <strong>Worker IO</strong> : Es ist nicht gen√ºgend Cache vorhanden, um neue Seiten von der Festplatte zu "posten".  Es kommt beispielsweise vor, dass alle Puffer gemeinsam genutzt werden, dass sie alle verschmutzt sind und dass noch keine Checkpoints vorhanden sind.  Damit der Worker die einfachste Auswahl durchf√ºhren kann, m√ºssen Sie den Cache von irgendwoher nehmen.  Dazu m√ºssen Sie zun√§chst alles auf der Festplatte speichern.  Sie haben keinen speziellen Checkpointer-Prozess, und der Worker startet fsync, um ihn freizugeben und mit etwas Neuem zu f√ºllen. <br><br>  Dies wirft ein noch gr√∂√üeres Problem auf: Der Arbeiter ist nicht spezialisiert, und der gesamte Prozess ist √ºberhaupt nicht optimiert.  Es ist m√∂glich, irgendwo auf Linux-Ebene zu optimieren, aber in PostgreSQL ist dies eine Notfallma√ünahme. <br><br><h2>  Haupt-E / A-Problem f√ºr DB </h2><br>  <strong>Welches Problem l√∂sen wir, wenn wir etwas einrichten?</strong>  Wir m√∂chten den Transport schmutziger Seiten zwischen Festplatte und Speicher maximieren. <br><br>  Es kommt jedoch h√§ufig vor, dass diese Dinge die Festplatte nicht direkt ber√ºhren.  Ein typischer Fall - Sie sehen einen sehr gro√üen Lastdurchschnitt.  Warum so?  Weil jemand auf die Festplatte wartet und auch alle anderen Prozesse warten.  Es scheint, dass es keine explizite Disc-Nutzung der Discs gibt, nur etwas hat die Disc dort blockiert, und das Problem liegt sowieso in der Ein- / Ausgabe. <br><br><blockquote>  Datenbank-E / A-Probleme betreffen nicht immer nur Festplatten. </blockquote><br>  An diesem Problem ist alles beteiligt: ‚Äã‚ÄãFestplatten, Speicher, CPU, E / A-Scheduler, Dateisysteme und Datenbankeinstellungen.  Lassen Sie uns nun den Stapel durchgehen und sehen, was damit zu tun ist und welche guten Dinge in Linux erfunden wurden, damit alles besser funktioniert. <br><br><h3>  Festplatten </h3><br>  Viele Jahre lang waren die Festplatten furchtbar langsam und niemand war an der Latenz oder Optimierung der √úbergangsphasen beteiligt.  Die Optimierung von fsyncs ergab keinen Sinn.  Die Scheibe drehte sich, die K√∂pfe bewegten sich wie eine Schallplatte dar√ºber, und fsyncs war so lang, dass keine Probleme auftraten. <br><br><h3>  Die Erinnerung </h3><br>  Es ist sinnlos, sich Top-Abfragen anzusehen, ohne die Datenbank zu optimieren.  Sie konfigurieren eine ausreichende Menge an gemeinsam genutztem Speicher usw. und haben eine neue Top-Abfrage - Sie m√ºssen sie erneut konfigurieren.  Hier ist die gleiche Geschichte.  Aus dieser Berechnung wurde der gesamte Linux-Stack erstellt. <br><br><h3>  Bandbreite und Latenz </h3><br>  <strong>Die Maximierung der E / A-Leistung durch Maximierung des Durchsatzes ist bis zu einem gewissen Punkt einfach.</strong>  In PostgreSQL wurde ein zus√§tzlicher PageWriter-Prozess erfunden, der den Checkpoint entlud.  Die Arbeit ist parallel geworden, aber es gibt noch Grundlagen f√ºr die Hinzuf√ºgung von Parallelit√§t.  Und die Latenz zu minimieren, ist die Aufgabe der letzten Meile, f√ºr die Supertechnologien ben√∂tigt werden. <br><br>  Diese Supertechnologien sind SSDs.  Als sie erschienen, sank die Latenz stark.  In allen anderen Phasen des Stacks traten jedoch Probleme auf: sowohl von Seiten der Datenbankhersteller als auch von Seiten der Linux-Hersteller.  Probleme m√ºssen angegangen werden. <br><br>  Bei der Datenbankentwicklung ging es um die Maximierung des Durchsatzes, ebenso wie bei der Entwicklung des Linux-Kernels.  Viele Methoden zur Optimierung der E / A-√Ñra von sich drehenden Festplatten sind f√ºr SSDs nicht so gut. <br><br>  Zwischendurch mussten wir f√ºr die aktuelle Linux-Infrastruktur sichern, jedoch mit neuen Festplatten.  Wir haben Leistungstests des Herstellers mit einer gro√üen Anzahl verschiedener IOPS gesehen, und die Datenbank wurde nicht besser, da es in der Datenbank nicht nur und nicht so sehr um IOPS geht.  Es kommt oft vor, dass wir 50.000 IOPS pro Sekunde √ºberspringen k√∂nnen, was gut ist.  Aber wenn wir die Latenz nicht kennen, ihre Verteilung nicht kennen, k√∂nnen wir nichts √ºber die Leistung sagen.  Irgendwann beginnt die Datenbank mit dem Checkpoint und die Latenz steigt dramatisch an. <br><br>  Nach wie vor war dies ein gro√ües Leistungsproblem bei Virtuala-Datenbanken.  Virtuelle E / A zeichnen sich durch ungleichm√§√üige Latenz aus, was nat√ºrlich auch Probleme mit sich bringt. <br><br><h2>  IO-Stack.  Wie es vorher war </h2><br><img src="https://habrastorage.org/webt/yl/3v/oz/yl3vozgbt2ltrkqo8lbey-wzdfo.jpeg"><br><br>  Es gibt User Space - diesen Speicher, der von der Datenbank selbst verwaltet wird.  In einer DB so konfiguriert, dass alles so funktioniert, wie es sollte.  Dies kann in einem separaten Bericht erfolgen und nicht einmal in einem.  Dann geht alles unweigerlich durch den Seiten-Cache oder √ºber die Direct IO-Schnittstelle in die <strong>Block Input / Output-Schicht</strong> . <br><br>  Stellen Sie sich eine Dateisystemschnittstelle vor.  Die Seiten, die sich im Puffer-Cache befanden, wie sie urspr√ºnglich in der Datenbank waren, dh Bl√∂cke, werden durch diese entfernt.  Die Block-E / A-Schicht behandelt Folgendes.  Es gibt eine C-Struktur, die einen Block im Kernel beschreibt.  Die Struktur nimmt diese Bl√∂cke und sammelt daraus Vektoren (Arrays) von Eingabe- oder Ausgabeanforderungen.  Unterhalb der BIO-Schicht befindet sich die Anforderungsschicht.  Vektoren werden auf dieser Schicht gesammelt und gehen weiter. <br><br>  Diese beiden Schichten in Linux wurden lange Zeit f√ºr eine effiziente Aufzeichnung auf Magnetplatten gesch√§rft.  Es war unm√∂glich, auf einen √úbergang zu verzichten.  Es gibt Bl√∂cke, die bequem √ºber die Datenbank verwaltet werden k√∂nnen.  Es ist notwendig, diese Bl√∂cke zu Vektoren zusammenzusetzen, die bequem auf die Platte geschrieben werden, so dass sie irgendwo in der N√§he liegen.  Damit dies effektiv funktioniert, haben sie Elevators oder Schedulers IO entwickelt. <br><br><h2>  Aufz√ºge </h2><br>  Aufz√ºge waren haupts√§chlich an der Kombination und Sortierung von Vektoren beteiligt.  Alles, damit der Block-SD-Treiber - der Quasidisk-Treiber - die Aufzeichnungsbl√∂cke in der f√ºr ihn passenden Reihenfolge eintreffen.  Der Treiber √ºbersetzte von Bl√∂cken in seine Sektoren und schrieb auf die Festplatte. <br><br>  Das Problem war, dass es notwendig war, mehrere √úberg√§nge durchzuf√ºhren und bei jeder ihre eigene Logik des optimalen Prozesses zu implementieren. <br><br><h3>  Aufz√ºge: bis Kernel 2.6 </h3><br>  <strong>Vor Kernel 2.6 gab es Linus Elevator</strong> - den primitivsten IO-Scheduler, der von Ihnen geschrieben wurde.  Lange Zeit galt er als absolut unersch√ºtterlich und gut, bis sie etwas Neues entwickelten. <br><br>  Linus Elevator hatte viele Probleme.  <strong>Er kombinierte und sortierte</strong> <strong>, um effizienter aufzunehmen</strong> .  Bei rotierenden mechanischen Scheiben f√ºhrte dies zur Entstehung von " <strong>Hunger"</strong> : Eine Situation, in der die Aufzeichnungseffizienz von der Drehung der Scheibe abh√§ngt.  Wenn Sie pl√∂tzlich gleichzeitig effektiv lesen m√ºssen, es aber bereits falsch eingestellt wurde, wird es von einer solchen Festplatte schlecht gelesen. <br><br>  Allm√§hlich wurde klar, dass dies ein ineffizienter Weg ist.  Aus diesem Grund wurde ab Kernel 2.6 ein ganzer Zoo von Schedulern angezeigt, der f√ºr verschiedene Aufgaben vorgesehen war. <br><br><h3>  Aufz√ºge: zwischen 2,6 und 3 </h3><br>  Viele Leute verwechseln diese Scheduler mit Betriebssystem-Schedulern, weil sie √§hnliche Namen haben.  <strong>CFQ - V√∂llig faires Queuing</strong> ist nicht dasselbe wie OS-Scheduler.  Nur die Namen sind √§hnlich.  Es wurde als universeller Scheduler gepr√§gt. <br><br>  <strong>Was ist ein universeller Scheduler?</strong>  Denken Sie, Sie haben eine durchschnittliche Belastung oder im Gegenteil eine einzigartige?  Datenbanken sind sehr vielseitig einsetzbar.  Die universelle Last kann man sich als normalen Laptop vorstellen.  Dort passiert alles: Wir h√∂ren Musik, spielen, tippen Text.  Daf√ºr wurden nur universelle Scheduler geschrieben. <br><br>  <strong>Die Hauptaufgabe des universellen Schedulers:</strong> Erstellen Sie unter Linux f√ºr jedes virtuelle Terminal und jeden virtuellen Prozess eine Anforderungswarteschlange.  Wenn wir Musik in einem Audio-Player h√∂ren m√∂chten, nimmt IO f√ºr den Player eine Warteschlange ein.  Wenn wir etwas mit dem Befehl cp sichern m√∂chten, ist etwas anderes beteiligt. <br><br>  Bei Datenbanken tritt ein Problem auf.  In der Regel ist eine Datenbank ein Prozess, der gestartet wurde, und w√§hrend des Betriebs entstanden parallele Prozesse, die immer in derselben E / A-Warteschlange enden.  Der Grund ist, dass dies dieselbe Anwendung ist, derselbe √ºbergeordnete Prozess.  F√ºr sehr kleine Lasten war eine solche Planung geeignet, f√ºr den Rest war sie nicht sinnvoll.  Es war einfacher auszuschalten und wenn m√∂glich nicht zu benutzen. <br><br>  Allm√§hlich erschien der <strong>Terminplaner</strong> - er funktioniert schlauer, aber im Grunde ist es Zusammenf√ºhren und Sortieren f√ºr sich drehende Datentr√§ger.  Angesichts des Entwurfs eines bestimmten Platten-Subsystems sammeln wir Blockvektoren, um sie optimal zu schreiben.  Er hatte weniger Probleme mit dem <strong>Hunger</strong> , aber sie waren da. <br><br>  Daher erschien n√§her am dritten Linux-Kernel <strong>noop</strong> oder <strong>none</strong> , was mit der Verbreitung von SSDs viel besser funktionierte.  Einschlie√ülich Scheduler Noop deaktivieren wir die Scheduling-Funktion: Es gibt keine Sortierungen, Zusammenf√ºhrungen und √§hnliche Dinge, die CFQ und Deadline durchgef√ºhrt haben. <br><br>  Dies funktioniert besser mit SSDs, da SSDs von Natur aus parallel sind: Sie haben Speicherzellen.  Je mehr dieser Elemente auf einer PCIe-Karte gespeichert werden m√ºssen, desto effizienter funktioniert sie. <br><br>  Scheduler aus einigen seiner jenseitigen, aus Sicht der SSD, √úberlegungen, sammelt einige Vektoren und sendet sie irgendwohin.  Alles endet mit einem Trichter.  Also t√∂ten wir die Parallelit√§t von SSD, wir nutzen sie nicht in vollem Umfang.  Daher funktionierte ein einfaches Herunterfahren, wenn die Vektoren zuf√§llig ohne Sortierung ablaufen, hinsichtlich der Leistung besser.  Aus diesem Grund wird angenommen, dass zuf√§lliges Lesen und zuf√§lliges Schreiben auf SSDs besser sind. <br><br><h3>  Aufz√ºge: ab 3.13 </h3><br>  Beginnend mit Kernel 3.13 erschien <strong>blk-mq</strong> .  Etwas fr√ºher gab es einen Prototyp, aber in 3.13 erschien zuerst eine funktionierende Version. <br><br>  <strong>Blk-mq begann</strong> als Scheduler, aber es ist schwierig, es als Scheduler zu bezeichnen - es steht architektonisch allein.  Dies ist ein Ersatz f√ºr die Anforderungsschicht im Kernel.  Langsam f√ºhrte die Entwicklung von blk-mq zu einer umfassenden √úberarbeitung des gesamten Linux-E / A-Stacks. <br><br>  Die Idee ist folgende: Lassen Sie uns die native F√§higkeit von SSDs nutzen, um eine effiziente Parallelit√§t f√ºr E / A zu erreichen.  Abh√§ngig davon, wie viele parallele E / A-Streams Sie verwenden k√∂nnen, gibt es ehrliche Warteschlangen, √ºber die wir einfach so schreiben, wie es auf der SSD ist.   CPU     . <br><br>    <strong>blk-mq</strong>    .     .   ,  4  ,  <strong>blk-mq</strong>   ‚Äî  5-10%,   . <br><br><blockquote> blk-mq ‚Äî ,      SSD. </blockquote><br>    <strong>blk-mq</strong>    <strong>NVMe</strong> driver Linux.      Linux,     Microsoft.     <strong>blk-mq</strong>  NVMe driver ‚Äî      Linux,      . <br><br>       ,   .     -     PCIe SSD.      ,    . <br><br><blockquote>  blk-mq  NVMe ,  .       . </blockquote><br>    ,  ,   .  NVMe ,     ,     . <br><br><h3>    elevators </h3><br><img src="https://habrastorage.org/webt/ya/82/ou/ya82oun8cusxylg0bsuz5y0e1la.jpeg"><br><br>  :  CPU,   ,   -   . <br><br>   Elevators  -.   CPU   . - , ,    ,       , IO      . <br><br><h3>    elevators </h3><br> blk-mq ‚Äî    .  CPU,  NUMA-   /   .     ,  ,  ,    .   SD ,    , . <br><br><img src="https://habrastorage.org/webt/zf/12/7n/zf127n1eqhli2qioregzrsiftp8.jpeg"><br><br>   .  -    RAID-   ,     RAID.   SSD ‚Äî   .    SD-   ,  blq-mq. <br><br><h2>    blk-mq </h2><br>      . <br><br><img src="https://habrastorage.org/webt/me/ma/3e/mema3e595wllaoub6thn61q8kvu.jpeg"><br><br>    . ,   . /    ,  ,   Block IO-.     <strong>blk-mq</strong> ,    ,   scheduler. <br><br>   3.13      ,       .    schedulers  <strong>blk-mq</strong> ,      .     Linux    schedulers IO ‚Äî  Kyber  BFQ.         <strong>blk-mq</strong> . <br><br> <strong>BFQ</strong> <strong>‚Äî Budget Fair Queueing ‚Äî </strong> <strong></strong> <strong></strong> <strong>FQ</strong> .   ,     . BFQ ‚Äî  scheduler   .         IO.     IO,  / .       ,   .     ‚Äî  .   BFQ,   ,    . <br><br> <strong>Kyber ‚Äî  </strong> .   BFQ,   .  Kyber  scheduler   .    ‚Äî   CPU  . Kyber    . <br><br>      ‚Äî <strong>blk-mq    SD-</strong> .      ,    ,  ,    IO-.  blk-mq  NVMe driver      .     . <br><br>        ‚Äî   latency,      .   SSD,    ‚Äî     .      -, ,    NVMe-,   blk-mq    ,    .    . <br><br><h2>   Linux IO </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> / Linux. <br><br><img src="https://habrastorage.org/webt/ak/05/qb/ak05qbritsgbiaeybq3dmz2mpyi.png"><br><br>   ,    ,   ,  Elevators,   . <br><br>   ,           ,    . <br><br><h2>  NVM Express </h2><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVM Express oder NVMe ist eine Spezifikation, eine Reihe von Standards, mit denen Sie SSDs besser nutzen k√∂nnen. </font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Spezifikation ist unter Linux gut gestellt. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux ist eine der treibenden Kr√§fte des Standards. </font></font></font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt in Produktion ist die dritte Version. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Treiber dieser Version kann der Spezifikation folgen 20 GB / s pro SSD-Block und NVMe der falschen Version, die noch nicht verf√ºgbar ist, </font></font></font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zu 32 GB / s</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geh√∂rt </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der SD-Treiber wird weder √ºber Schnittstellen noch √ºber Steuern, um eine Rechte Bandbreite geh√∂rt.</font></font></font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Spezifikation ist Zugang schneller als alles, war ein Krieg. </font></font></font></font></blockquote><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'de', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><br>  Sobald die Datenbanken f√ºr rotierende Datentr√§ger geschrieben und an diesen ausgerichtet wurden, haben sie beispielsweise Indizes in Form eines B-Baums.  Es stellt sich die Frage: <strong>Sind die Datenbanken f√ºr NVMe bereit</strong> ?  K√∂nnen Datenbanken eine solche Last kauen? <br><br>  Noch nicht, aber sie passen sich an.  Die PostgreSQL-Mailingliste hatte k√ºrzlich einige <code>pwrite()</code> und √§hnliche Dinge.  PostgreSQL- und MySQL-Entwickler interagieren mit Kernel-Entwicklern.  Nat√ºrlich m√∂chte ich mehr Interaktion. <br><br><h2>  J√ºngste Entwicklungen </h2><br>  In den letzten anderthalb Jahren hat NVMe <strong>IO-Polling</strong> hinzugef√ºgt. <br><br>  Anfangs gab es sich drehende Scheiben mit hoher Latenz.  Dann kamen die SSDs, die viel schneller sind.  Aber es gab einen Stau: fsync geht weiter, die Aufnahme beginnt und auf einer sehr niedrigen Ebene - tief im Treiber wird eine Anfrage direkt an die Hardware gesendet - schreiben Sie sie auf. <br><br>  Der Mechanismus war einfach - sie haben ihn gesendet und wir warten, bis der Interrupt verarbeitet ist.  Das Warten auf die Interrupt-Verarbeitung ist im Vergleich zum Schreiben auf eine sich drehende Festplatte kein Problem.  Das Warten dauerte so lange, dass der Interrupt funktionierte, sobald die Aufnahme beendet war. <br><br>  Da die SSD sehr schnell schreibt, ist zwangsweise ein Mechanismus zum Abfragen der Hardware √ºber die Aufzeichnung erschienen.  In den ersten Versionen erreichte die Erh√∂hung der E / A-Geschwindigkeit 50%, da wir nicht auf eine Unterbrechung warten, sondern das St√ºck Eisen aktiv nach dem Datensatz fragen.  <strong>Dieser Mechanismus wird als E / A-Abfrage bezeichnet</strong> . <br><br>  Es wurde in neueren Versionen eingef√ºhrt.  In Version 4.12 erschienen <strong>IO-Scheduler</strong> , die speziell f√ºr die Arbeit mit <strong>blk-mq</strong> und NVMe gesch√§rft wurden und √ºber die ich <strong>Kyber und BFQ</strong> sagte.  Sie sind bereits offiziell im Kernel, sie k√∂nnen verwendet werden. <br><br>  In einer verwendbaren Form gibt es jetzt das sogenannte <strong>IO-Tagging</strong> .  Meist werden Hersteller von Clouds und virtuellen Maschinen zu dieser Entwicklung beitragen.  Grob gesagt k√∂nnen Eingaben aus einer bestimmten Anwendung angegangen werden und ihr Vorrang einger√§umt werden.  Die Datenbanken sind daf√ºr noch nicht bereit, bleiben aber dran.  Ich denke, es wird bald Mainstream sein. <br><br><h2>  Direkte E / A-Notizen </h2><br>  <strong>PostgreSQL unterst√ºtzt Direct IO nicht und es gibt eine Reihe von Problemen, die es schwierig machen, den Support zu aktivieren</strong> .  Dies wird jetzt nur f√ºr den Wert unterst√ºtzt und nur, wenn die Replikation nicht aktiviert ist.  Es ist erforderlich <strong>, viel</strong> betriebssystemspezifischen <strong>Code zu schreiben</strong> , und im Moment verzichtet jeder darauf. <br><br>  Trotz der Tatsache, dass Linux stark auf die Idee von Direct IO und dessen Implementierung schw√∂rt, gehen alle Datenbanken dorthin.  In Oracle und MySQL wird Direct IO h√§ufig verwendet.  PostgreSQL ist die einzige Datenbank, die Direct IO nicht toleriert. <br><br><h2>  Checkliste </h2><br>  So sch√ºtzen Sie sich in PostgreSQL vor fsync-√úberraschungen: <br><br><ul><li>  Richten Sie Checkpoints so ein, dass sie weniger h√§ufig und gr√∂√üer sind. </li><li>  Richten Sie den Hintergrundschreiber ein, um den Checkpoint zu unterst√ºtzen. </li><li>  Ziehen Sie am Autovakuum, damit keine unn√∂tigen st√∂renden E / A auftreten. </li></ul><br><blockquote>  Der Tradition nach warten wir im November auf professionelle Entwickler hoch geladener Dienste in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skolkovo</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> .  Es bleibt noch ein Monat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> einen Bericht zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beantragen</a> , aber wir haben bereits die ersten Berichte f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programm</a> akzeptiert.  Melden Sie sich f√ºr unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter an</a> und erfahren Sie aus erster Hand mehr √ºber neue Themen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459444/">https://habr.com/ru/post/de459444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459430/index.html">Mobile Anwendung mit automatischer Formularerstellung: unser Fall</a></li>
<li><a href="../de459432/index.html">RD-180: K√∂nnen die USA Raketentriebwerke herstellen?</a></li>
<li><a href="../de459434/index.html">React Hook Router Eine moderne Alternative zum React Router</a></li>
<li><a href="../de459438/index.html">Daten sind noch wichtiger</a></li>
<li><a href="../de459442/index.html">5 Open-Source-Sicherheitsereignismanagementsysteme</a></li>
<li><a href="../de459446/index.html">F√ºnf be√§ngstigende Trends des modernen Designs</a></li>
<li><a href="../de459450/index.html">Durch die Sicherheitsl√ºcke in der Zoom-Telekonferenzsoftware kann jede Website Benutzer √ºber eine Webcam ausspionieren</a></li>
<li><a href="../de459452/index.html">Agro-Roboter mit KI lernten, nur gereiften Salat aus dem Garten sorgf√§ltig zu sammeln</a></li>
<li><a href="../de459454/index.html">Wie war der erste Hackathon bei The Standoff?</a></li>
<li><a href="../de459456/index.html">Dagaz: Episoden (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>