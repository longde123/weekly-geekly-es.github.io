<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💨 ☘️ 👩🏻‍🌾 Jüngste Änderungen im Linux IO-Stack aus DBA-Sicht 👰🏽 🧚🏽 👨‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Hauptprobleme beim Arbeiten mit der Datenbank hängen mit den Funktionen des Geräts des Betriebssystems zusammen, auf dem die Datenbank arbeitet. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jüngste Änderungen im Linux IO-Stack aus DBA-Sicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/459444/">  Die Hauptprobleme beim Arbeiten mit der Datenbank hängen mit den Funktionen des Geräts des Betriebssystems zusammen, auf dem die Datenbank arbeitet.  Linux ist jetzt das Hauptbetriebssystem für Datenbanken.  Solaris, Microsoft und sogar HPUX werden immer noch im Unternehmen verwendet, aber sie werden niemals den ersten Platz einnehmen, selbst wenn sie kombiniert werden.  Linux gewinnt zuversichtlich an Boden, da es immer mehr Open-Source-Datenbanken gibt.  Daher geht es bei der Datenbankinteraktion mit dem Betriebssystem offensichtlich um Linux-Datenbanken.  Dies überlagert das ewige DB-Problem - die E / A-Leistung.  Es ist gut, dass Linux in den letzten Jahren den E / A-Stack grundlegend überarbeitet hat und Hoffnung auf Aufklärung besteht. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0o7uNUOS-Ho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ilya Kosmodemyansky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Hydrobiont</a> ) arbeitet für Data Egret, ein Unternehmen, das PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">konsultiert</a> und unterstützt, und weiß viel über die Interaktion zwischen Betriebssystem und Datenbanken.  In einem Bericht über HighLoad ++ sprach Ilya am Beispiel von PostgreSQL über die Interaktion von E / A und Datenbanken, zeigte aber auch, wie andere Datenbanken mit E / A funktionieren.  Ich habe mir den Linux IO-Stack angesehen, welche neuen und guten Dinge darin erschienen sind und warum nicht alles so ist, wie es vor ein paar Jahren war.  Als nützliche Erinnerung - eine Checkliste mit PostgreSQL- und Linux-Einstellungen für maximale Leistung des E / A-Subsystems in den neuen Kerneln. <br><a name="habracut"></a><br>  <i>Das Berichtsvideo enthält viel Englisch, von dem wir die meisten im Artikel übersetzt haben.</i> <br><br><h2>  Warum über IO sprechen? </h2><br>  <strong>Schnelle E / A ist für Datenbankadministratoren das Wichtigste</strong> .  Jeder weiß, was sich bei der Arbeit mit der CPU ändern lässt, dass der Speicher erweitert werden kann, aber E / A kann alles ruinieren.  Wenn es mit Festplatten und zu viel E / A schlecht ist, stöhnt die Datenbank.  IO wird zu einem Engpass. <br><br><blockquote>  Damit alles gut funktioniert, müssen Sie alles konfigurieren. </blockquote><br>  Nicht nur die Datenbank oder nur die Hardware - das war's.  Sogar das Oracle auf hoher Ebene, das an einigen Stellen selbst ein Betriebssystem ist, muss konfiguriert werden.  Wir lesen die Anweisungen im "Installationshandbuch" von Oracle: Ändern Sie solche Kernel-Parameter, ändern Sie andere - es gibt viele Einstellungen.  Zusätzlich zu der Tatsache, dass in Unbreakable Kernel vieles bereits standardmäßig mit Oracle Linux verbunden ist. <br><br>  Für PostgreSQL und MySQL sind noch weitere Änderungen erforderlich.  Dies liegt daran, dass diese Technologien auf Betriebssystemmechanismen beruhen.  Ein DBA, der mit PostgreSQL, MySQL oder modernem NoSQL funktioniert, muss ein Linux-Betriebsingenieur sein und verschiedene Betriebssysteme verrückt machen. <br><br>  Jeder, der sich mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kerneleinstellungen</a> befassen möchte, wendet sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LWN</a> .  Die Ressource ist genial, minimalistisch, enthält viele nützliche Informationen, wurde jedoch <strong>von Kernel-Entwicklern für Kernel-Entwickler geschrieben</strong> .  Was schreiben Kernel-Entwickler gut?  Der Kern, nicht der Artikel, wie man es benutzt.  Deshalb werde ich versuchen, Ihnen alles für die Entwickler zu erklären und sie den Kernel schreiben zu lassen. <br><br>  Alles wird oft dadurch kompliziert, dass die Entwicklung des Linux-Kernels und die Verarbeitung seines Stacks anfangs hinterherhinken und in den letzten Jahren sehr schnell gegangen sind.  Weder Eisen noch Entwickler mit Artikeln hinter sich können mithalten. <br><br><h2>  Typische Datenbank </h2><br>  Beginnen wir mit den Beispielen für PostgreSQL - hier ist I / O gepuffert.  Es verfügt über einen gemeinsam genutzten Speicher, der aus Sicht des Betriebssystems im <strong>Benutzerbereich</strong> zugewiesen wird, und über denselben Cache im Kernel-Cache im <strong>Kernel-Bereich</strong> . <br><br><img src="https://habrastorage.org/webt/jd/dh/d2/jddhd25l97pocaqtqqf6ccygcxi.jpeg"><br><br>  <strong>Die Hauptaufgabe einer modernen Datenbank</strong> : <br><br><ul><li>  Nehmen Sie Seiten von der Festplatte im Speicher auf. </li><li>  Wenn eine Änderung auftritt, markieren Sie die Seiten als verschmutzt. </li><li>  in das Write-Ahead-Protokoll schreiben; </li><li>  Synchronisieren Sie dann den Speicher so, dass er mit der Festplatte übereinstimmt. </li></ul><br>  In einer PostgreSQL-Situation ist dies ein ständiger Roundtrip: vom gemeinsam genutzten Speicher, den PostgreSQL im Page Cache-Kernel steuert, und dann über den gesamten Linux-Stack auf die Festplatte.  Wenn Sie eine Datenbank in einem Dateisystem verwenden, funktioniert dieser Algorithmus mit jedem UNIX-ähnlichen System und mit jeder Datenbank.  Unterschiede sind, aber unbedeutend. <br><br>  Die Verwendung von Oracle ASM ist anders - Oracle selbst interagiert mit der Festplatte.  Das Prinzip ist jedoch dasselbe: Mit Direct IO oder mit Page Cache besteht die Aufgabe jedoch <strong>darin, Seiten so schnell wie möglich durch den gesamten E / A-Stapel zu zeichnen</strong> , unabhängig davon, um was es sich handelt.  Und in jeder Phase können Probleme auftreten. <br><br><h3>  Zwei Probleme von IO </h3><br>  Während alles <strong>schreibgeschützt ist</strong> , gibt es keine Probleme.  Sie lesen und wenn genügend Speicher vorhanden ist, werden alle zu lesenden Daten im RAM abgelegt.  Die Tatsache, dass im Fall von PostgreSQL im <strong>Puffer-Cache</strong> dieselbe ist, macht uns keine großen Sorgen. <br><br><img src="https://habrastorage.org/webt/mh/0j/sm/mh0jsmmdrh5bosmamuaiko9l-jw.jpeg"><br><br>  <strong>Das erste Problem mit E / A ist die Cache-Synchronisation.</strong>  Tritt auf, wenn eine Aufzeichnung erforderlich ist.  In diesem Fall müssen Sie viel mehr Speicher hin und her fahren. <br><br><img src="https://habrastorage.org/webt/tq/mw/u7/tqmwu7fy-wlwqjx6nxec6jfcyrk.jpeg"><br><br>  Dementsprechend müssen Sie PostgreSQL oder MySQL so konfigurieren, dass alles vom gemeinsam genutzten Speicher auf die Festplatte gelangt.  Im Fall von PostgreSQL müssen Sie den Hintergrundbetrug schmutziger Seiten unter Linux noch optimieren, um alles auf die Festplatte zu senden. <br><br>  <strong>Das zweite häufige Problem ist ein Schreibfehler beim Write-Ahead-Protokoll</strong> .  Es wird angezeigt, wenn die Last so stark ist, dass sogar ein nacheinander aufgezeichnetes Protokoll auf der Festplatte liegt.  In dieser Situation muss es auch schnell aufgezeichnet werden. <br><br>  Die Situation unterscheidet sich nicht wesentlich von der <strong>Cache-Synchronisation</strong> .  In PostgreSQL arbeiten wir mit einer großen Anzahl gemeinsam genutzter Puffer. Die Datenbank verfügt über Mechanismen für eine effiziente Write-Ahead-Protokollaufzeichnung und ist bis zum Limit optimiert.  Das einzige, was getan werden kann, um das Protokoll selbst effizienter zu gestalten, ist das Ändern der Linux-Einstellungen. <br><br><h2>  Die Hauptprobleme bei der Arbeit mit der Datenbank </h2><br>  <strong>Das gemeinsam genutzte Speichersegment kann sehr groß sein</strong> .  Ich habe 2012 auf Konferenzen darüber gesprochen.  Dann sagte ich, dass der Speicher im Preis gefallen ist, auch wenn es Server mit 32 GB RAM gibt.  Im Jahr 2019 sind möglicherweise bereits mehr Laptops vorhanden, immer häufiger auf den Servern 128, 256 usw. <br><br>  <strong>Wirklich viel Gedächtnis</strong> .  Banale Aufnahmen erfordern Zeit und Ressourcen, und die <strong>Technologien, die wir dafür verwenden, sind konservativ</strong> .  Datenbanken sind alt, sie wurden lange entwickelt und entwickeln sich langsam weiter.  Die Mechanismen in den Datenbanken stimmen mit der neuesten Technologie nicht genau überein. <br><br>  <strong>Das Synchronisieren von Seiten im Speicher mit der Festplatte führt zu großen E / A-Vorgängen</strong> .  Wenn wir Caches synchronisieren, entsteht ein großer Strom von E / A und ein weiteres Problem - <strong>wir können etwas nicht verdrehen und den Effekt betrachten.</strong>  In einem wissenschaftlichen Experiment ändern Forscher einen Parameter - erhalten Sie den Effekt, den zweiten - erhalten Sie den Effekt, den dritten.  Wir werden es nicht schaffen.  Wir verdrehen einige Parameter in PostgreSQL, konfigurieren Checkpoints - wir haben den Effekt nicht gesehen.  Konfigurieren Sie dann erneut den gesamten Stapel, um zumindest einige Ergebnisse zu erhalten.  Twist One-Parameter funktioniert nicht - wir müssen alles auf einmal konfigurieren. <br><br>  Die meisten PostgreSQL-E / A generieren eine Seitensynchronisation: Prüfpunkte und andere Synchronisationsmechanismen.  Wenn Sie mit PostgreSQL gearbeitet haben, haben Sie möglicherweise Checkpoints-Spitzen gesehen, wenn regelmäßig eine „Säge“ in den Diagrammen angezeigt wird.  Früher waren viele mit diesem Problem konfrontiert, aber jetzt gibt es Handbücher zur Behebung. Es ist einfacher geworden. <br><br>  SSDs retten heute die Situation erheblich.  Bei PostgreSQL ruht etwas selten direkt auf dem Wertedatensatz.  Alles hängt von der Synchronisation ab: Wenn ein Prüfpunkt auftritt, wird fsync aufgerufen und es gibt eine Art „Schlagen“ eines Prüfpunkts auf einen anderen.  Zu viel IO.  Ein Checkpoint ist noch nicht beendet, hat noch nicht alle Fsyncs abgeschlossen, hat aber bereits einen weiteren Checkpoint verdient und es hat begonnen! <br><br>  PostgreSQL hat eine einzigartige Funktion - <strong>Autovacuum</strong> .  Dies ist eine lange Geschichte von Krücken für die Datenbankarchitektur.  Wenn das Autovakuum ausfällt, wird es normalerweise so eingerichtet, dass es aggressiv funktioniert und den Rest nicht beeinträchtigt: Es gibt viele Autovakuumarbeiter, die häufig ein wenig stolpern und Tabellen schnell verarbeiten.  Andernfalls treten Probleme mit DDL und Sperren auf. <br><br><blockquote>  Aber wenn Autovacuum aggressiv ist, beginnt es auf IO zu kauen. </blockquote><br>  Wenn Checkpoints mit Autovakuum überlagert werden, werden die Festplatten die meiste Zeit zu fast 100% recycelt, und dies ist die Ursache der Probleme. <br><br>  Seltsamerweise gibt es ein <strong>Cache-Nachfüllproblem</strong> .  Sie ist normalerweise weniger bekannt für DBA.  Ein typisches Beispiel: Die Datenbank wurde gestartet und für einige Zeit verlangsamt sich alles traurig.  Kaufen Sie daher auch bei viel RAM gute Festplatten, damit der Stapel den Cache erwärmt. <br><br>  All dies beeinträchtigt die Leistung erheblich.  Probleme beginnen nicht unmittelbar nach dem Neustart der Datenbank, sondern später.  Beispielsweise wurde der Prüfpunkt übergeben, und viele Seiten sind in der gesamten Datenbank verschmutzt.  Sie werden auf die Festplatte kopiert, da Sie sie synchronisieren müssen.  Dann fordern die Anforderungen eine neue Version der Seiten von der Festplatte an, und die Datenbank hängt ab.  Die Grafiken zeigen, wie das Nachfüllen des Caches nach jedem Prüfpunkt einen bestimmten Prozentsatz zur Last beiträgt. <br><br>  Das Unangenehmste an der Eingabe / Ausgabe der Datenbank ist <strong>Worker IO.</strong>  Wenn jeder von Ihnen angeforderte Mitarbeiter mit der Generierung seiner E / A beginnt.  In Oracle ist es einfacher, aber in PostgreSQL ist es ein Problem. <br><br>  Es gibt viele Gründe für Probleme mit <strong>Worker IO</strong> : Es ist nicht genügend Cache vorhanden, um neue Seiten von der Festplatte zu "posten".  Es kommt beispielsweise vor, dass alle Puffer gemeinsam genutzt werden, dass sie alle verschmutzt sind und dass noch keine Checkpoints vorhanden sind.  Damit der Worker die einfachste Auswahl durchführen kann, müssen Sie den Cache von irgendwoher nehmen.  Dazu müssen Sie zunächst alles auf der Festplatte speichern.  Sie haben keinen speziellen Checkpointer-Prozess, und der Worker startet fsync, um ihn freizugeben und mit etwas Neuem zu füllen. <br><br>  Dies wirft ein noch größeres Problem auf: Der Arbeiter ist nicht spezialisiert, und der gesamte Prozess ist überhaupt nicht optimiert.  Es ist möglich, irgendwo auf Linux-Ebene zu optimieren, aber in PostgreSQL ist dies eine Notfallmaßnahme. <br><br><h2>  Haupt-E / A-Problem für DB </h2><br>  <strong>Welches Problem lösen wir, wenn wir etwas einrichten?</strong>  Wir möchten den Transport schmutziger Seiten zwischen Festplatte und Speicher maximieren. <br><br>  Es kommt jedoch häufig vor, dass diese Dinge die Festplatte nicht direkt berühren.  Ein typischer Fall - Sie sehen einen sehr großen Lastdurchschnitt.  Warum so?  Weil jemand auf die Festplatte wartet und auch alle anderen Prozesse warten.  Es scheint, dass es keine explizite Disc-Nutzung der Discs gibt, nur etwas hat die Disc dort blockiert, und das Problem liegt sowieso in der Ein- / Ausgabe. <br><br><blockquote>  Datenbank-E / A-Probleme betreffen nicht immer nur Festplatten. </blockquote><br>  An diesem Problem ist alles beteiligt: ​​Festplatten, Speicher, CPU, E / A-Scheduler, Dateisysteme und Datenbankeinstellungen.  Lassen Sie uns nun den Stapel durchgehen und sehen, was damit zu tun ist und welche guten Dinge in Linux erfunden wurden, damit alles besser funktioniert. <br><br><h3>  Festplatten </h3><br>  Viele Jahre lang waren die Festplatten furchtbar langsam und niemand war an der Latenz oder Optimierung der Übergangsphasen beteiligt.  Die Optimierung von fsyncs ergab keinen Sinn.  Die Scheibe drehte sich, die Köpfe bewegten sich wie eine Schallplatte darüber, und fsyncs war so lang, dass keine Probleme auftraten. <br><br><h3>  Die Erinnerung </h3><br>  Es ist sinnlos, sich Top-Abfragen anzusehen, ohne die Datenbank zu optimieren.  Sie konfigurieren eine ausreichende Menge an gemeinsam genutztem Speicher usw. und haben eine neue Top-Abfrage - Sie müssen sie erneut konfigurieren.  Hier ist die gleiche Geschichte.  Aus dieser Berechnung wurde der gesamte Linux-Stack erstellt. <br><br><h3>  Bandbreite und Latenz </h3><br>  <strong>Die Maximierung der E / A-Leistung durch Maximierung des Durchsatzes ist bis zu einem gewissen Punkt einfach.</strong>  In PostgreSQL wurde ein zusätzlicher PageWriter-Prozess erfunden, der den Checkpoint entlud.  Die Arbeit ist parallel geworden, aber es gibt noch Grundlagen für die Hinzufügung von Parallelität.  Und die Latenz zu minimieren, ist die Aufgabe der letzten Meile, für die Supertechnologien benötigt werden. <br><br>  Diese Supertechnologien sind SSDs.  Als sie erschienen, sank die Latenz stark.  In allen anderen Phasen des Stacks traten jedoch Probleme auf: sowohl von Seiten der Datenbankhersteller als auch von Seiten der Linux-Hersteller.  Probleme müssen angegangen werden. <br><br>  Bei der Datenbankentwicklung ging es um die Maximierung des Durchsatzes, ebenso wie bei der Entwicklung des Linux-Kernels.  Viele Methoden zur Optimierung der E / A-Ära von sich drehenden Festplatten sind für SSDs nicht so gut. <br><br>  Zwischendurch mussten wir für die aktuelle Linux-Infrastruktur sichern, jedoch mit neuen Festplatten.  Wir haben Leistungstests des Herstellers mit einer großen Anzahl verschiedener IOPS gesehen, und die Datenbank wurde nicht besser, da es in der Datenbank nicht nur und nicht so sehr um IOPS geht.  Es kommt oft vor, dass wir 50.000 IOPS pro Sekunde überspringen können, was gut ist.  Aber wenn wir die Latenz nicht kennen, ihre Verteilung nicht kennen, können wir nichts über die Leistung sagen.  Irgendwann beginnt die Datenbank mit dem Checkpoint und die Latenz steigt dramatisch an. <br><br>  Nach wie vor war dies ein großes Leistungsproblem bei Virtuala-Datenbanken.  Virtuelle E / A zeichnen sich durch ungleichmäßige Latenz aus, was natürlich auch Probleme mit sich bringt. <br><br><h2>  IO-Stack.  Wie es vorher war </h2><br><img src="https://habrastorage.org/webt/yl/3v/oz/yl3vozgbt2ltrkqo8lbey-wzdfo.jpeg"><br><br>  Es gibt User Space - diesen Speicher, der von der Datenbank selbst verwaltet wird.  In einer DB so konfiguriert, dass alles so funktioniert, wie es sollte.  Dies kann in einem separaten Bericht erfolgen und nicht einmal in einem.  Dann geht alles unweigerlich durch den Seiten-Cache oder über die Direct IO-Schnittstelle in die <strong>Block Input / Output-Schicht</strong> . <br><br>  Stellen Sie sich eine Dateisystemschnittstelle vor.  Die Seiten, die sich im Puffer-Cache befanden, wie sie ursprünglich in der Datenbank waren, dh Blöcke, werden durch diese entfernt.  Die Block-E / A-Schicht behandelt Folgendes.  Es gibt eine C-Struktur, die einen Block im Kernel beschreibt.  Die Struktur nimmt diese Blöcke und sammelt daraus Vektoren (Arrays) von Eingabe- oder Ausgabeanforderungen.  Unterhalb der BIO-Schicht befindet sich die Anforderungsschicht.  Vektoren werden auf dieser Schicht gesammelt und gehen weiter. <br><br>  Diese beiden Schichten in Linux wurden lange Zeit für eine effiziente Aufzeichnung auf Magnetplatten geschärft.  Es war unmöglich, auf einen Übergang zu verzichten.  Es gibt Blöcke, die bequem über die Datenbank verwaltet werden können.  Es ist notwendig, diese Blöcke zu Vektoren zusammenzusetzen, die bequem auf die Platte geschrieben werden, so dass sie irgendwo in der Nähe liegen.  Damit dies effektiv funktioniert, haben sie Elevators oder Schedulers IO entwickelt. <br><br><h2>  Aufzüge </h2><br>  Aufzüge waren hauptsächlich an der Kombination und Sortierung von Vektoren beteiligt.  Alles, damit der Block-SD-Treiber - der Quasidisk-Treiber - die Aufzeichnungsblöcke in der für ihn passenden Reihenfolge eintreffen.  Der Treiber übersetzte von Blöcken in seine Sektoren und schrieb auf die Festplatte. <br><br>  Das Problem war, dass es notwendig war, mehrere Übergänge durchzuführen und bei jeder ihre eigene Logik des optimalen Prozesses zu implementieren. <br><br><h3>  Aufzüge: bis Kernel 2.6 </h3><br>  <strong>Vor Kernel 2.6 gab es Linus Elevator</strong> - den primitivsten IO-Scheduler, der von Ihnen geschrieben wurde.  Lange Zeit galt er als absolut unerschütterlich und gut, bis sie etwas Neues entwickelten. <br><br>  Linus Elevator hatte viele Probleme.  <strong>Er kombinierte und sortierte</strong> <strong>, um effizienter aufzunehmen</strong> .  Bei rotierenden mechanischen Scheiben führte dies zur Entstehung von " <strong>Hunger"</strong> : Eine Situation, in der die Aufzeichnungseffizienz von der Drehung der Scheibe abhängt.  Wenn Sie plötzlich gleichzeitig effektiv lesen müssen, es aber bereits falsch eingestellt wurde, wird es von einer solchen Festplatte schlecht gelesen. <br><br>  Allmählich wurde klar, dass dies ein ineffizienter Weg ist.  Aus diesem Grund wurde ab Kernel 2.6 ein ganzer Zoo von Schedulern angezeigt, der für verschiedene Aufgaben vorgesehen war. <br><br><h3>  Aufzüge: zwischen 2,6 und 3 </h3><br>  Viele Leute verwechseln diese Scheduler mit Betriebssystem-Schedulern, weil sie ähnliche Namen haben.  <strong>CFQ - Völlig faires Queuing</strong> ist nicht dasselbe wie OS-Scheduler.  Nur die Namen sind ähnlich.  Es wurde als universeller Scheduler geprägt. <br><br>  <strong>Was ist ein universeller Scheduler?</strong>  Denken Sie, Sie haben eine durchschnittliche Belastung oder im Gegenteil eine einzigartige?  Datenbanken sind sehr vielseitig einsetzbar.  Die universelle Last kann man sich als normalen Laptop vorstellen.  Dort passiert alles: Wir hören Musik, spielen, tippen Text.  Dafür wurden nur universelle Scheduler geschrieben. <br><br>  <strong>Die Hauptaufgabe des universellen Schedulers:</strong> Erstellen Sie unter Linux für jedes virtuelle Terminal und jeden virtuellen Prozess eine Anforderungswarteschlange.  Wenn wir Musik in einem Audio-Player hören möchten, nimmt IO für den Player eine Warteschlange ein.  Wenn wir etwas mit dem Befehl cp sichern möchten, ist etwas anderes beteiligt. <br><br>  Bei Datenbanken tritt ein Problem auf.  In der Regel ist eine Datenbank ein Prozess, der gestartet wurde, und während des Betriebs entstanden parallele Prozesse, die immer in derselben E / A-Warteschlange enden.  Der Grund ist, dass dies dieselbe Anwendung ist, derselbe übergeordnete Prozess.  Für sehr kleine Lasten war eine solche Planung geeignet, für den Rest war sie nicht sinnvoll.  Es war einfacher auszuschalten und wenn möglich nicht zu benutzen. <br><br>  Allmählich erschien der <strong>Terminplaner</strong> - er funktioniert schlauer, aber im Grunde ist es Zusammenführen und Sortieren für sich drehende Datenträger.  Angesichts des Entwurfs eines bestimmten Platten-Subsystems sammeln wir Blockvektoren, um sie optimal zu schreiben.  Er hatte weniger Probleme mit dem <strong>Hunger</strong> , aber sie waren da. <br><br>  Daher erschien näher am dritten Linux-Kernel <strong>noop</strong> oder <strong>none</strong> , was mit der Verbreitung von SSDs viel besser funktionierte.  Einschließlich Scheduler Noop deaktivieren wir die Scheduling-Funktion: Es gibt keine Sortierungen, Zusammenführungen und ähnliche Dinge, die CFQ und Deadline durchgeführt haben. <br><br>  Dies funktioniert besser mit SSDs, da SSDs von Natur aus parallel sind: Sie haben Speicherzellen.  Je mehr dieser Elemente auf einer PCIe-Karte gespeichert werden müssen, desto effizienter funktioniert sie. <br><br>  Scheduler aus einigen seiner jenseitigen, aus Sicht der SSD, Überlegungen, sammelt einige Vektoren und sendet sie irgendwohin.  Alles endet mit einem Trichter.  Also töten wir die Parallelität von SSD, wir nutzen sie nicht in vollem Umfang.  Daher funktionierte ein einfaches Herunterfahren, wenn die Vektoren zufällig ohne Sortierung ablaufen, hinsichtlich der Leistung besser.  Aus diesem Grund wird angenommen, dass zufälliges Lesen und zufälliges Schreiben auf SSDs besser sind. <br><br><h3>  Aufzüge: ab 3.13 </h3><br>  Beginnend mit Kernel 3.13 erschien <strong>blk-mq</strong> .  Etwas früher gab es einen Prototyp, aber in 3.13 erschien zuerst eine funktionierende Version. <br><br>  <strong>Blk-mq begann</strong> als Scheduler, aber es ist schwierig, es als Scheduler zu bezeichnen - es steht architektonisch allein.  Dies ist ein Ersatz für die Anforderungsschicht im Kernel.  Langsam führte die Entwicklung von blk-mq zu einer umfassenden Überarbeitung des gesamten Linux-E / A-Stacks. <br><br>  Die Idee ist folgende: Lassen Sie uns die native Fähigkeit von SSDs nutzen, um eine effiziente Parallelität für E / A zu erreichen.  Abhängig davon, wie viele parallele E / A-Streams Sie verwenden können, gibt es ehrliche Warteschlangen, über die wir einfach so schreiben, wie es auf der SSD ist.   CPU     . <br><br>    <strong>blk-mq</strong>    .     .   ,  4  ,  <strong>blk-mq</strong>   —  5-10%,   . <br><br><blockquote> blk-mq — ,      SSD. </blockquote><br>    <strong>blk-mq</strong>    <strong>NVMe</strong> driver Linux.      Linux,     Microsoft.     <strong>blk-mq</strong>  NVMe driver —      Linux,      . <br><br>       ,   .     -     PCIe SSD.      ,    . <br><br><blockquote>  blk-mq  NVMe ,  .       . </blockquote><br>    ,  ,   .  NVMe ,     ,     . <br><br><h3>    elevators </h3><br><img src="https://habrastorage.org/webt/ya/82/ou/ya82oun8cusxylg0bsuz5y0e1la.jpeg"><br><br>  :  CPU,   ,   -   . <br><br>   Elevators  -.   CPU   . - , ,    ,       , IO      . <br><br><h3>    elevators </h3><br> blk-mq —    .  CPU,  NUMA-   /   .     ,  ,  ,    .   SD ,    , . <br><br><img src="https://habrastorage.org/webt/zf/12/7n/zf127n1eqhli2qioregzrsiftp8.jpeg"><br><br>   .  -    RAID-   ,     RAID.   SSD —   .    SD-   ,  blq-mq. <br><br><h2>    blk-mq </h2><br>      . <br><br><img src="https://habrastorage.org/webt/me/ma/3e/mema3e595wllaoub6thn61q8kvu.jpeg"><br><br>    . ,   . /    ,  ,   Block IO-.     <strong>blk-mq</strong> ,    ,   scheduler. <br><br>   3.13      ,       .    schedulers  <strong>blk-mq</strong> ,      .     Linux    schedulers IO —  Kyber  BFQ.         <strong>blk-mq</strong> . <br><br> <strong>BFQ</strong> <strong>— Budget Fair Queueing — </strong> <strong></strong> <strong></strong> <strong>FQ</strong> .   ,     . BFQ —  scheduler   .         IO.     IO,  / .       ,   .     —  .   BFQ,   ,    . <br><br> <strong>Kyber —  </strong> .   BFQ,   .  Kyber  scheduler   .    —   CPU  . Kyber    . <br><br>      — <strong>blk-mq    SD-</strong> .      ,    ,  ,    IO-.  blk-mq  NVMe driver      .     . <br><br>        —   latency,      .   SSD,    —     .      -, ,    NVMe-,   blk-mq    ,    .    . <br><br><h2>   Linux IO </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> / Linux. <br><br><img src="https://habrastorage.org/webt/ak/05/qb/ak05qbritsgbiaeybq3dmz2mpyi.png"><br><br>   ,    ,   ,  Elevators,   . <br><br>   ,           ,    . <br><br><h2>  NVM Express </h2><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVM Express oder NVMe ist eine Spezifikation, eine Reihe von Standards, mit denen Sie SSDs besser nutzen können. </font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Spezifikation ist unter Linux gut gestellt. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux ist eine der treibenden Kräfte des Standards. </font></font></font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt in Produktion ist die dritte Version. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Treiber dieser Version kann der Spezifikation folgen 20 GB / s pro SSD-Block und NVMe der falschen Version, die noch nicht verfügbar ist, </font></font></font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zu 32 GB / s</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehört </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der SD-Treiber wird weder über Schnittstellen noch über Steuern, um eine Rechte Bandbreite gehört.</font></font></font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Spezifikation ist Zugang schneller als alles, war ein Krieg. </font></font></font></font></blockquote><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'de', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><br>  Sobald die Datenbanken für rotierende Datenträger geschrieben und an diesen ausgerichtet wurden, haben sie beispielsweise Indizes in Form eines B-Baums.  Es stellt sich die Frage: <strong>Sind die Datenbanken für NVMe bereit</strong> ?  Können Datenbanken eine solche Last kauen? <br><br>  Noch nicht, aber sie passen sich an.  Die PostgreSQL-Mailingliste hatte kürzlich einige <code>pwrite()</code> und ähnliche Dinge.  PostgreSQL- und MySQL-Entwickler interagieren mit Kernel-Entwicklern.  Natürlich möchte ich mehr Interaktion. <br><br><h2>  Jüngste Entwicklungen </h2><br>  In den letzten anderthalb Jahren hat NVMe <strong>IO-Polling</strong> hinzugefügt. <br><br>  Anfangs gab es sich drehende Scheiben mit hoher Latenz.  Dann kamen die SSDs, die viel schneller sind.  Aber es gab einen Stau: fsync geht weiter, die Aufnahme beginnt und auf einer sehr niedrigen Ebene - tief im Treiber wird eine Anfrage direkt an die Hardware gesendet - schreiben Sie sie auf. <br><br>  Der Mechanismus war einfach - sie haben ihn gesendet und wir warten, bis der Interrupt verarbeitet ist.  Das Warten auf die Interrupt-Verarbeitung ist im Vergleich zum Schreiben auf eine sich drehende Festplatte kein Problem.  Das Warten dauerte so lange, dass der Interrupt funktionierte, sobald die Aufnahme beendet war. <br><br>  Da die SSD sehr schnell schreibt, ist zwangsweise ein Mechanismus zum Abfragen der Hardware über die Aufzeichnung erschienen.  In den ersten Versionen erreichte die Erhöhung der E / A-Geschwindigkeit 50%, da wir nicht auf eine Unterbrechung warten, sondern das Stück Eisen aktiv nach dem Datensatz fragen.  <strong>Dieser Mechanismus wird als E / A-Abfrage bezeichnet</strong> . <br><br>  Es wurde in neueren Versionen eingeführt.  In Version 4.12 erschienen <strong>IO-Scheduler</strong> , die speziell für die Arbeit mit <strong>blk-mq</strong> und NVMe geschärft wurden und über die ich <strong>Kyber und BFQ</strong> sagte.  Sie sind bereits offiziell im Kernel, sie können verwendet werden. <br><br>  In einer verwendbaren Form gibt es jetzt das sogenannte <strong>IO-Tagging</strong> .  Meist werden Hersteller von Clouds und virtuellen Maschinen zu dieser Entwicklung beitragen.  Grob gesagt können Eingaben aus einer bestimmten Anwendung angegangen werden und ihr Vorrang eingeräumt werden.  Die Datenbanken sind dafür noch nicht bereit, bleiben aber dran.  Ich denke, es wird bald Mainstream sein. <br><br><h2>  Direkte E / A-Notizen </h2><br>  <strong>PostgreSQL unterstützt Direct IO nicht und es gibt eine Reihe von Problemen, die es schwierig machen, den Support zu aktivieren</strong> .  Dies wird jetzt nur für den Wert unterstützt und nur, wenn die Replikation nicht aktiviert ist.  Es ist erforderlich <strong>, viel</strong> betriebssystemspezifischen <strong>Code zu schreiben</strong> , und im Moment verzichtet jeder darauf. <br><br>  Trotz der Tatsache, dass Linux stark auf die Idee von Direct IO und dessen Implementierung schwört, gehen alle Datenbanken dorthin.  In Oracle und MySQL wird Direct IO häufig verwendet.  PostgreSQL ist die einzige Datenbank, die Direct IO nicht toleriert. <br><br><h2>  Checkliste </h2><br>  So schützen Sie sich in PostgreSQL vor fsync-Überraschungen: <br><br><ul><li>  Richten Sie Checkpoints so ein, dass sie weniger häufig und größer sind. </li><li>  Richten Sie den Hintergrundschreiber ein, um den Checkpoint zu unterstützen. </li><li>  Ziehen Sie am Autovakuum, damit keine unnötigen störenden E / A auftreten. </li></ul><br><blockquote>  Der Tradition nach warten wir im November auf professionelle Entwickler hoch geladener Dienste in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skolkovo</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> .  Es bleibt noch ein Monat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> einen Bericht zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beantragen</a> , aber wir haben bereits die ersten Berichte für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programm</a> akzeptiert.  Melden Sie sich für unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter an</a> und erfahren Sie aus erster Hand mehr über neue Themen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459444/">https://habr.com/ru/post/de459444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459430/index.html">Mobile Anwendung mit automatischer Formularerstellung: unser Fall</a></li>
<li><a href="../de459432/index.html">RD-180: Können die USA Raketentriebwerke herstellen?</a></li>
<li><a href="../de459434/index.html">React Hook Router Eine moderne Alternative zum React Router</a></li>
<li><a href="../de459438/index.html">Daten sind noch wichtiger</a></li>
<li><a href="../de459442/index.html">5 Open-Source-Sicherheitsereignismanagementsysteme</a></li>
<li><a href="../de459446/index.html">Fünf beängstigende Trends des modernen Designs</a></li>
<li><a href="../de459450/index.html">Durch die Sicherheitslücke in der Zoom-Telekonferenzsoftware kann jede Website Benutzer über eine Webcam ausspionieren</a></li>
<li><a href="../de459452/index.html">Agro-Roboter mit KI lernten, nur gereiften Salat aus dem Garten sorgfältig zu sammeln</a></li>
<li><a href="../de459454/index.html">Wie war der erste Hackathon bei The Standoff?</a></li>
<li><a href="../de459456/index.html">Dagaz: Episoden (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>