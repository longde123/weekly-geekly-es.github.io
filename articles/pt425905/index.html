<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèΩ üëπ üí™üèª Como escrever c√≥digo assembler com instru√ß√µes sobrepostas (outra t√©cnica para ofuscar bytecode) ‚ÜóÔ∏è ü§í üêñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apresentamos a sua aten√ß√£o a t√©cnica de cria√ß√£o de programas assembler com instru√ß√µes sobrepostas - para proteger o bytecode compilado da desmontagem....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever c√≥digo assembler com instru√ß√µes sobrepostas (outra t√©cnica para ofuscar bytecode)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425905/"><p>  Apresentamos a sua aten√ß√£o a t√©cnica de cria√ß√£o de programas assembler com instru√ß√µes sobrepostas - para proteger o bytecode compilado da desmontagem.  Essa t√©cnica √© capaz de suportar an√°lises de bytecode est√°ticas e din√¢micas.  A id√©ia √© selecionar um fluxo de bytes que, quando desmontado de dois deslocamentos diferentes, resulte em duas cadeias de instru√ß√µes diferentes, ou seja, em duas maneiras diferentes de executar o programa.  Para fazer isso, seguimos as instru√ß√µes do assembler multibyte e ocultamos o c√≥digo protegido nas partes vari√°veis ‚Äã‚Äãdo bytecode dessas instru√ß√µes.  Para enganar o desmontador, colocando-o em uma trilha falsa (de acordo com uma cadeia de instru√ß√µes ocultas) e para proteger de seus olhos uma cadeia oculta de instru√ß√µes. </p><br><p><img src="https://habrastorage.org/webt/iu/f0/nj/iuf0njjfado7wk-bt05rlxz5l2w.png"></p><a name="habracut"></a><br><h2 id="tri-neobhodimyh-usloviya-dlya-sozdaniya-effektivnogo-perekrytiya">  Tr√™s pr√©-requisitos para criar uma "sobreposi√ß√£o" eficaz </h2><br><p>  Para enganar o desmontador, o c√≥digo sobreposto deve atender √†s tr√™s condi√ß√µes a seguir: 1) As instru√ß√µes da cadeia de m√°scara e da cadeia oculta devem sempre se cruzar, isto √©,  n√£o devem estar alinhados um com o outro (o primeiro e o √∫ltimo bytes n√£o devem coincidir).  Caso contr√°rio, parte do c√≥digo oculto ser√° vis√≠vel na cadeia de mascaramento.  2) Ambas as correntes devem consistir em instru√ß√µes de montagem plaus√≠veis.  Caso contr√°rio, o mascaramento j√° ser√° detectado no est√°gio da an√°lise est√°tica (ap√≥s encontrar um c√≥digo inadequado para execu√ß√£o, o desmontador corrigir√° o ponteiro do comando e exp√µe o mascaramento).  3) Todas as instru√ß√µes de ambas as cadeias devem ser n√£o apenas plaus√≠veis, mas tamb√©m executadas corretamente (para impedir que isso aconte√ßa, o programa travou ao tentar execut√°-las).  Caso contr√°rio, durante a an√°lise din√¢mica, as falhas atrair√£o a aten√ß√£o do reverso e a m√°scara ser√° revelada. </p><br><h2 id="opisanie-tehniki-perekrytiya-assemblernyh-instrukciy">  Descri√ß√£o da t√©cnica de instru√ß√µes de montagem "sobrepostas" </h2><br><p>  Para tornar o processo de cria√ß√£o de c√≥digo sobreposto o mais flex√≠vel poss√≠vel, √© necess√°rio selecionar apenas essas instru√ß√µes multibyte, para as quais o maior n√∫mero poss√≠vel de bytes possa assumir qualquer valor.  Essas instru√ß√µes multibyte constituir√£o uma cadeia de instru√ß√µes de mascaramento. </p><br><p>  Em busca do objetivo de criar c√≥digo sobreposto que satisfa√ßa as tr√™s condi√ß√µes acima, consideramos cada instru√ß√£o de m√°scara como uma sequ√™ncia de bytes no formato: XX YY ZZ. </p><br><p>  Aqui XX √© o prefixo da instru√ß√£o (c√≥digo de instru√ß√£o e outros bytes est√°ticos - que n√£o podem ser alterados). </p><br><p>  AA s√£o bytes que podem ser alterados arbitrariamente (como regra, esses bytes armazenam o valor num√©rico direto passado para a instru√ß√£o; ou o endere√ßo do operando armazenado na mem√≥ria).  Deve haver o m√°ximo de bytes YY poss√≠vel, para que mais instru√ß√µes ocultas se ajustem a eles. </p><br><p>  ZZ - tamb√©m s√£o bytes que podem ser alterados arbitrariamente, com a √∫nica diferen√ßa de que a combina√ß√£o de bytes ZZ com os pr√≥ximos bytes XX (ZZ XX) deve formar uma instru√ß√£o v√°lida que satisfa√ßa as tr√™s condi√ß√µes formuladas no in√≠cio do artigo.  Idealmente, o ZZ deve ocupar apenas um byte, de modo que em YY (essa √© essencialmente a parte mais importante - nosso c√≥digo oculto √© colocado aqui), deve haver o maior n√∫mero poss√≠vel de bytes.  A √∫ltima instru√ß√£o oculta deve terminar em ZZ, - criando um ponto de converg√™ncia para as duas cadeias de execu√ß√£o. </p><br><h2 id="skleivayuschie-instrukcii">  Instru√ß√µes de colagem </h2><br><p>  A combina√ß√£o ZZ XX - chamaremos a instru√ß√£o de colagem.  Uma instru√ß√£o de colagem √© necess√°ria, em primeiro lugar, para unir instru√ß√µes ocultas localizadas em instru√ß√µes de m√°scara adjacentes e, em segundo lugar, para atender √† primeira condi√ß√£o necess√°ria declarada no in√≠cio do artigo: as instru√ß√µes de ambas as cadeias sempre devem se cruzar (portanto, a instru√ß√£o de colagem sempre localizado na interse√ß√£o de duas instru√ß√µes de m√°scara). </p><br><p>  A instru√ß√£o de colar √© executada em uma cadeia oculta de comandos e, portanto, deve ser selecionada de maneira a impor o m√≠nimo de restri√ß√µes poss√≠vel ao c√≥digo oculto.  Suponha que, quando executado, os registradores de uso geral e o registro EFLAGS sejam alterados, o c√≥digo oculto n√£o poder√° usar efetivamente os registradores correspondentes e os comandos condicionais (por exemplo, se a instru√ß√£o de colagem for precedida pelo operador de compara√ß√£o e a pr√≥pria instru√ß√£o de colagem alterar o valor do registro EFLAGS, a transi√ß√£o condicional, que segue as instru√ß√µes de colagem n√£o funcionar√° corretamente). </p><br><p>  A descri√ß√£o acima da t√©cnica de sobreposi√ß√£o √© ilustrada na figura a seguir.  Se a execu√ß√£o come√ßar com os bytes iniciais (XX), uma cadeia de instru√ß√µes de mascaramento ser√° ativada.  E se a partir dos bytes YY, uma cadeia de instru√ß√µes oculta √© ativada. </p><br><p><img src="https://habrastorage.org/webt/a8/yq/f-/a8yqf-uukfw3fgzvlkqmmjjxiao.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-maskiruyuschih-instrukciy">  Instru√ß√µes de montagem adequadas para a fun√ß√£o de "instru√ß√µes de mascaramento" </h2><br><p>  A mais longa das instru√ß√µes, que √† primeira vista nos conv√©m, √© uma vers√£o de 10 bytes do MOV, onde o deslocamento especificado pelo registro e pelo endere√ßo de 32 bits √© transferido como o primeiro operando e o n√∫mero de 32 bits como o segundo operando.  Esta instru√ß√£o cont√©m o m√°ximo de bytes que podem ser alterados arbitrariamente (at√© 8 partes). </p><br><p><img src="https://habrastorage.org/webt/0k/8b/ph/0k8bphb01jec2f1t7dy1bupi_c0.png"></p><br><p>  No entanto, embora essa instru√ß√£o pare√ßa plaus√≠vel (teoricamente, pode ser executada corretamente), ainda n√£o nos conv√©m, porque seu primeiro operando, como regra, apontar√° para um endere√ßo inacess√≠vel e, portanto, ao tentar executar esse MOV, o programa entrar√° em colapso.  T.O.  esse MOV de 10 bytes n√£o atende √† terceira condi√ß√£o necess√°ria: todas as instru√ß√µes de ambas as cadeias devem ser executadas corretamente. </p><br><p>  Portanto, escolheremos para o papel de instru√ß√µes de mascaramento apenas os candidatos que n√£o apresentem risco de colapso do programa.  Essa condi√ß√£o reduz significativamente o intervalo de instru√ß√µes adequadas para a cria√ß√£o de c√≥digos sobrepostos, mas ainda existem as adequadas.  Abaixo est√£o quatro deles.  Cada uma dessas quatro instru√ß√µes cont√©m cinco bytes, que podem ser alterados arbitrariamente, sem o risco de uma falha no programa. </p><br><ul><li>  <strong>LEA.</strong>  Esta instru√ß√£o calcula o endere√ßo de mem√≥ria especificado pela express√£o no segundo operando e armazena o resultado no primeiro operando.  Como podemos nos referir √† mem√≥ria sem acesso real a ela (e, consequentemente, sem o risco de uma falha no programa), os √∫ltimos cinco bytes desta instru√ß√£o podem assumir valores arbitr√°rios. </li></ul><br><p><img src="https://habrastorage.org/webt/nt/j4/qt/ntj4qtax25h_ztuizjq-aokjpbu.png"></p><br><ul><li>  <strong>CMOVcc.</strong>  Esta instru√ß√£o executa a opera√ß√£o MOV se a condi√ß√£o "cc" for atendida.  Para que esta instru√ß√£o atenda ao terceiro requisito, a condi√ß√£o deve ser selecionada para que, em qualquer circunst√¢ncia, tenha o valor FALSE.  Caso contr√°rio, esta instru√ß√£o pode tentar acessar um endere√ßo de mem√≥ria inacess√≠vel, e assim por diante.  derrubar o programa. </li></ul><br><p><img src="https://habrastorage.org/webt/np/me/fn/npmefnc43igcj9aqvw9omgyofae.png"></p><br><ul><li>  <strong>SETcc</strong>  Ele opera com o mesmo princ√≠pio que o CMOVcc: define o byte como um se a condi√ß√£o "cc" for atendida.  Esta instru√ß√£o tem o mesmo problema que o CMOVcc: acessar um endere√ßo inv√°lido causar√° uma falha no programa.  Portanto, a escolha da condi√ß√£o "cc" deve ser abordada com muito cuidado. </li></ul><br><p><img src="https://habrastorage.org/webt/sn/yc/xt/snycxte6lqjzorjwdqcvsppfdri.png"></p><br><ul><li>  <strong>NOP.</strong>  Os NOPs podem ter comprimentos diferentes (de 2 a 15 bytes), dependendo de quais operandos s√£o indicados neles.  Nesse caso, n√£o haver√° risco de travamento do programa (devido ao acesso a um endere√ßo de mem√≥ria inv√°lido).  Como a √∫nica coisa que os NOPs fazem √© aumentar o contador de instru√ß√µes (eles n√£o executam nenhuma opera√ß√£o nos operandos).  Portanto, os bytes NOP nos quais os operandos s√£o especificados podem assumir um valor arbitr√°rio.  Para nossos prop√≥sitos, um NOP de 9 bytes √© mais adequado. </li></ul><br><p><img src="https://habrastorage.org/webt/_i/sh/8k/_ish8ks2qosezlkfzpgzx43jk2k.png"></p><br><p>  Para refer√™ncia, aqui est√£o algumas outras op√ß√µes de NOP. </p><br><p><img src="https://habrastorage.org/webt/0k/iq/n7/0kiqn7dtu1yzrrmawbtw8yfwep0.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-skleivayuschih-instrukciy">  Instru√ß√µes de montagem adequadas para o papel de "instru√ß√µes de colagem" </h2><br><p>  A lista de instru√ß√µes adequadas para o papel de uma instru√ß√£o de colagem √© exclusiva para cada instru√ß√£o de m√°scara espec√≠fica.  Abaixo est√° uma lista (gerada pelo algoritmo mostrado na figura a seguir) usando NOP de 9 bytes como exemplo. </p><br><p><img src="https://habrastorage.org/webt/zh/9o/ja/zh9ojaw9sezcyr9milmugd3pihm.png"></p><br><p>  Para formar esta lista, levamos em conta apenas as op√ß√µes nas quais o ZZ ocupa 1 byte (caso contr√°rio, haver√° pouco espa√ßo para o c√≥digo oculto).  Aqui est√° uma lista de instru√ß√µes adesivas adequadas para um NOP de 9 bytes. </p><br><p><img src="https://habrastorage.org/webt/wm/kv/uj/wmkvujcabiyqgy-ysdg1750mp7k.png"></p><br><p>  Entre esta lista de instru√ß√µes, n√£o h√° uma que estaria livre de efeitos colaterais.  Cada um deles altera o EFLAGS, ou os registros de uso geral, ou ambos de uma vez.  Esta lista √© dividida em 4 categorias, de acordo com o efeito colateral da instru√ß√£o. </p><br><p>  <strong>A primeira categoria</strong> inclui instru√ß√µes que alteram o registro EFLAGS, mas n√£o alteram os registros de uso geral.  As instru√ß√µes desta categoria podem ser usadas quando n√£o houver saltos condicionais ou quaisquer instru√ß√µes na cadeia de instru√ß√µes ocultas com base na avalia√ß√£o de informa√ß√µes do registro EFLAGS.  Nesse caso, neste caso (para um NOP de 9 bytes), existem apenas duas instru√ß√µes: TEST e CMP. </p><br><p><img src="https://habrastorage.org/webt/vx/6k/nz/vx6knzdkeafykou6rrga4kjtjrc.png"></p><br><p>  A seguir, √© apresentado um exemplo simples de c√≥digo oculto que usa TEST como uma instru√ß√£o de colagem.  Este exemplo faz uma chamada ao sistema de sa√≠da, que retorna um valor de 1 para qualquer vers√£o do Linux.Para formar corretamente a instru√ß√£o TEST para nossas necessidades, precisamos definir o √∫ltimo byte do primeiro NOP como 0xA9.  Este byte, quando associado aos quatro primeiros bytes do pr√≥ximo NOP (66 0F 1F 84), se transformar√° em uma instru√ß√£o TEST EAX, 0x841F0F66.  As duas figuras a seguir mostram o c√≥digo do montador correspondente (para cadeia de m√°scara e cadeia oculta).  A cadeia oculta √© ativada quando o controle √© transferido para o quarto byte do primeiro NOP. </p><br><p><img src="https://habrastorage.org/webt/sv/ok/v9/svokv9pvujkp3sz1mzgcpfumlx4.png"></p><br><p><img src="https://habrastorage.org/webt/ky/bd/-b/kybd-bm02hdj6lka_rnkemfrnj8.png"></p><br><p>  <strong>A segunda categoria</strong> inclui instru√ß√µes que alteram os valores dos registros gerais ou da mem√≥ria dispon√≠vel (pilha, por exemplo), mas n√£o alteram o registro EFLAGS.  Ao executar uma instru√ß√£o PUSH ou qualquer variante MOV, onde um valor imediato √© especificado como o segundo operando, o registro EFLAGS permanece inalterado.  T.O.  as instru√ß√µes de colagem da segunda categoria podem at√© ser colocadas entre a instru√ß√£o de compara√ß√£o (TEST, por exemplo) e a instru√ß√£o que avalia o registro EFLAGS.  No entanto, as instru√ß√µes nesta categoria limitam o uso do registro que aparece nas instru√ß√µes de colagem correspondentes.  Por exemplo, se MOV EBP, 0x841F0F66 for usado como uma instru√ß√£o de colagem, as possibilidades de uso do registro EBP (do restante do c√≥digo oculto) ser√£o significativamente limitadas. </p><br><p>  <strong>A terceira categoria</strong> inclui instru√ß√µes que alteram o registro EFLAGS e os registros de uso geral (ou mem√≥ria).  Essas instru√ß√µes n√£o t√™m vantagens √≥bvias sobre as instru√ß√µes das duas primeiras categorias.  No entanto, eles tamb√©m podem ser utilizados, uma vez que n√£o contradizem as tr√™s condi√ß√µes formuladas no in√≠cio do artigo.  A quarta categoria inclui instru√ß√µes, cuja implementa√ß√£o n√£o garante que o programa n√£o falhe - existe o risco de acesso ilegal √† mem√≥ria.  √â extremamente indesej√°vel us√°-los, porque  eles n√£o satisfazem a terceira condi√ß√£o. </p><br><h2 id="assemblernye-instrukcii-kotorye-mozhno-ispolzovat-v-skrytoy-cepochke">  Instru√ß√µes do assembler que podem ser usadas em uma cadeia oculta </h2><br><p>  No nosso caso (quando os NOPs de 9 bytes s√£o usados ‚Äã‚Äãcomo instru√ß√µes de mascaramento), o comprimento de cada instru√ß√£o da cadeia oculta n√£o deve exceder quatro bytes (essa restri√ß√£o n√£o se aplica a instru√ß√µes fixas que ocupam 5 bytes).  No entanto, essa n√£o √© uma limita√ß√£o muito cr√≠tica, porque a maioria das instru√ß√µes com mais de quatro bytes pode ser decomposta em v√°rias instru√ß√µes mais curtas.  A seguir, √© apresentado um exemplo de um MOV de 5 bytes muito grande para caber em uma cadeia oculta. </p><br><p><img src="https://habrastorage.org/webt/oo/97/yx/oo97yx0fsovio-agsdn-spiejre.png"></p><br><p>  No entanto, esse MOV de cinco bytes pode ser decomposto em tr√™s instru√ß√µes, cujo comprimento n√£o excede quatro bytes. </p><br><p><img src="https://habrastorage.org/webt/yx/zd/oc/yxzdocctpxhzvy13td7fpkqnwi0.png"></p><br><h2 id="usilenie-maskirovki-putyom-rasseivaniya-maskiruyuschih-nopov-po-vsey-programme">  Aprimorando o mascaramento dispersando os NOPs de mascaramento ao longo do programa </h2><br><p>  Um grande n√∫mero de NOPs consecutivos parece, do ponto de vista inverso, muito suspeito.  Concentrando seu interesse nesses NOPs suspeitos, um reversor experiente pode chegar ao fundo do c√≥digo oculto neles.  Para evitar essa exposi√ß√£o, os NOPs mascarados podem ser espalhados por todo o programa. </p><br><p>  A cadeia correta de execu√ß√£o do c√≥digo oculto nesse caso pode ser suportada por instru√ß√µes de byte duplo de salto incondicional.  Nesse caso, os dois √∫ltimos bytes de cada NOP ocupar√£o um JMP de 2 bytes. </p><br><p>  Esse truque permite dividir uma longa sequ√™ncia de NOPs em v√°rias curtas (ou at√© usar um NOP cada).  No √∫ltimo NOP de uma sequ√™ncia t√£o curta, apenas 3 bytes da carga √∫til podem ser alocados (o 4¬∫ byte ser√° obtido pela instru√ß√£o de salto incondicional).  T.O.  aqui h√° uma restri√ß√£o adicional no tamanho das instru√ß√µes v√°lidas.  No entanto, como mencionado acima, instru√ß√µes longas podem ser dispostas em uma cadeia de instru√ß√µes mais curtas.  Abaixo est√° um exemplo do mesmo MOV de 5 bytes, que j√° estabelecemos para caber no limite de 4 bytes.  No entanto, agora decompomos esse MOV de forma a caber no limite de 3 bytes. </p><br><p><img src="https://habrastorage.org/webt/lr/6g/bz/lr6gbzoo5qnjgocu3zzkoblxqsc.png"></p><br><p>  Tendo decomposto todas as instru√ß√µes longas em instru√ß√µes mais curtas, de acordo com o mesmo princ√≠pio, podemos, para mascarar mais, geralmente usar apenas NOPs espalhados por todo o programa.  As instru√ß√µes JMP de dois bytes podem avan√ßar e retroceder 127 bytes, o que significa que dois NOPs consecutivos (consecutivos, em termos de uma cadeia de instru√ß√µes ocultas) devem estar dentro de 127 bytes. </p><br><p>  Esse truque tem outra vantagem significativa (al√©m do mascaramento aprimorado): com sua ajuda, voc√™ pode colocar c√≥digo oculto nos NOPs existentes do arquivo bin√°rio compilado (ou seja, inserir uma carga √∫til no bin√°rio ap√≥s compil√°-lo).  Nesse caso, n√£o √© necess√°rio que esses NOPs √≥rf√£os tenham 9 bytes.  Por exemplo, se houver v√°rios NOPs de byte √∫nico em uma linha no bin√°rio, eles poder√£o ser convertidos em NOPs de v√°rios bytes, sem interromper a funcionalidade do programa.  Abaixo est√° um exemplo de uma t√©cnica para dispersar NOPs (esse c√≥digo √© funcionalmente equivalente ao exemplo discutido acima). </p><br><p><img src="https://habrastorage.org/webt/t6/cj/fn/t6cjfn6ctjsqubp6setuf324nui.png"></p><br><p>  Esse c√≥digo oculto, oculto no NOP espalhado por todo o programa, j√° √© muito mais dif√≠cil de detectar. </p><br><p>  Um leitor atento deve ter notado que o primeiro NOP n√£o tem √∫ltimo byte.  No entanto, n√£o h√° nada com que se preocupar.  Como esse byte n√£o reclamado √© precedido por um salto incondicional.  T.O.  o controle nunca ser√° transferido para ele.  Ent√£o, est√° tudo em ordem. </p><br><p>  Aqui est√° uma t√©cnica para criar c√≥digo sobreposto.  Use na sa√∫de.  Esconda seu c√≥digo precioso de olhares indiscretos.  Mas adote outras instru√ß√µes, n√£o um NOP de 9 bytes.  Porque os inversores provavelmente tamb√©m ler√£o este artigo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425905/">https://habr.com/ru/post/pt425905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425893/index.html">‚ÄúO Flutter est√° come√ßando a atrair a comunidade, mas ainda n√£o os clientes‚Äù: Entrevista com Paulina Szklarska</a></li>
<li><a href="../pt425897/index.html">Recursos do uso da biblioteca RxJs em um sistema banc√°rio online</a></li>
<li><a href="../pt425899/index.html">Formigueiro ou fortaleza? Estou construindo uma casa pelo pre√ßo de um apartamento. 1 parte</a></li>
<li><a href="../pt425901/index.html">Esta√ß√£o meteorol√≥gica no Arduino de A a Z. Parte 1</a></li>
<li><a href="../pt425903/index.html">O feriado chega at√© n√≥s: o SCRF dobrou a banda ISM de 868 MHz</a></li>
<li><a href="../pt425907/index.html">Estamos desenvolvendo um projeto de aprendizado de m√°quina em Python. Parte 2</a></li>
<li><a href="../pt425911/index.html">Transferir o CRM da nuvem para a vers√£o em caixa</a></li>
<li><a href="../pt425915/index.html">Como as comunica√ß√µes transfronteiri√ßas podem substituir os sem√°foros e diminuir o caminho para o trabalho</a></li>
<li><a href="../pt425917/index.html">Lutador da justi√ßa impede Waymo de patentear a tecnologia chave do lidar</a></li>
<li><a href="../pt425919/index.html">Mapas hexagonais no Unity: salvamento e carregamento, texturas, dist√¢ncias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>