<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ üòè üå≠ White-Box-Test üë©‚Äçüé§ üëø üè∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung hochwertiger Programme setzt voraus, dass das Programm und seine Teile getestet werden. Beim klassischen Testen von Einheiten wird ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>White-Box-Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  Die Entwicklung hochwertiger Programme setzt voraus, dass das Programm und seine Teile getestet werden.  Beim klassischen Testen von Einheiten wird ein gro√ües Programm in kleine Bl√∂cke aufgeteilt, die zum Testen geeignet sind.  Oder wenn die Entwicklung von Tests parallel zur Entwicklung von Code erfolgt oder Tests vor dem Programm entwickelt werden (TDD - Test Driven Development), wird das Programm zun√§chst in kleinen Bl√∂cken entwickelt, die f√ºr die Anforderungen der Tests geeignet sind. </p><br><p>  Eine der Varianten von Unit-Tests kann als eigenschaftsbasiertes Testen betrachtet werden (dieser Ansatz ist beispielsweise in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScalaCheck implementiert</a> ).  Dieser Ansatz basiert auf der Suche nach universellen Eigenschaften, die f√ºr alle Eingabedaten g√ºltig sein sollten.  Beispielsweise sollte eine <em>Serialisierung gefolgt von einer Deserialisierung dasselbe Objekt erzeugen</em> .  Durch <em>erneutes Sortieren sollte die Reihenfolge der Elemente in der Liste nicht ge√§ndert werden</em> .  Um solche universellen Eigenschaften zu √ºberpr√ºfen, unterst√ºtzen die obigen Bibliotheken einen Mechanismus zum Generieren von zuf√§lligen Eingabedaten.  Dieser Ansatz eignet sich besonders gut f√ºr Programme, die auf mathematischen Gesetzen basieren und als universelle Eigenschaften f√ºr eine breite Klasse von Programmen dienen.  Es gibt sogar eine Bibliothek mit vorgefertigten mathematischen Eigenschaften - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Disziplin</a> -, mit der Sie die Leistung dieser Eigenschaften in neuen Programmen √ºberpr√ºfen k√∂nnen (ein gutes Beispiel f√ºr die Wiederverwendung von Tests). </p><br><p>  Manchmal stellt sich heraus, dass es notwendig ist, ein komplexes Programm zu testen, ohne es in unabh√§ngig √ºberpr√ºfbare Teile zerlegen zu k√∂nnen.  In diesem Fall ist das Testprogramm <del>  schwarz </del>  White Box (wei√ü - weil wir die M√∂glichkeit haben, die interne Struktur des Programms zu studieren). </p><br><p>  Im Rahmen des Schnitts werden verschiedene Ans√§tze zum Testen komplexer Programme mit einer Eingabe mit unterschiedlichem Komplexit√§tsgrad (Beteiligung) und unterschiedlichem Abdeckungsgrad beschrieben. </p><a name="habracut"></a><br><p>  * <em>In diesem Artikel gehen wir davon aus, dass das zu testende Programm als reine Funktion ohne internen Zustand dargestellt werden kann.</em>  <em>(Einige der folgenden √úberlegungen k√∂nnen angewendet werden, wenn der interne Zustand vorliegt, es ist jedoch m√∂glich, diesen Zustand auf einen festen Wert zur√ºckzusetzen.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Pr√ºfstand </h3><br><p> Da nur eine Funktion getestet wird, deren aufrufender Code immer der gleiche ist, m√ºssen wir zun√§chst keine separaten Komponententests erstellen.  Alle diese Tests w√§ren gleich, genau auf die Eingabe und die Pr√ºfungen.  Es reicht v√∂llig aus, die Quelldaten ( <code>input</code> ) in einer Schleife zu √ºbertragen und die Ergebnisse ( <code>expectedOutput</code> ) zu √ºberpr√ºfen.  Um einen Problemsatz von Testdaten im Falle einer Fehlererkennung zu identifizieren, m√ºssen alle Testdaten gekennzeichnet werden.  Somit kann ein Satz von Testdaten als Dreifach dargestellt werden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Das Ergebnis eines Laufs kann als <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Wir pr√§sentieren das Ergebnis des Starts mit <code>Try</code> , m√∂gliche Ausnahmen abzufangen.) </p><br><p>  Um die Ausf√ºhrung aller Testdaten durch das zu testende Programm zu vereinfachen, k√∂nnen Sie eine Hilfsfunktion verwenden, die das Programm f√ºr jeden Eingabewert aufruft: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Diese Hilfsfunktion gibt die problematischen Daten und Ergebnisse zur√ºck, die sich von den erwarteten unterscheiden. </p><br><p>  Der Einfachheit halber k√∂nnen Sie die Testergebnisse formatieren. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  und zeigen Sie einen Bericht nur bei Fehlern an: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Eingabevorbereitung </h3><br><p>  Im einfachsten Fall k√∂nnen Sie manuell Testdaten erstellen, um das Programm zu testen, es direkt in den Testcode zu schreiben und wie oben gezeigt zu verwenden.  Es stellt sich oft heraus, dass interessante F√§lle von Testdaten viel gemeinsam haben und mit geringf√ºgigen √Ñnderungen als grundlegende Instanz dargestellt werden k√∂nnen. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Bei der Arbeit mit verschachtelten unver√§nderlichen Datenstrukturen sind Objektive eine gro√üe Hilfe, beispielsweise aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monocle-</a> Bibliothek: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Mit Objektiven k√∂nnen Sie tief verschachtelte Teile von Datenstrukturen elegant ‚Äûmodifizieren‚Äú: Jedes Objektiv ist ein Getter und Setter f√ºr eine Eigenschaft.  Objektive k√∂nnen kombiniert werden, um Objektive herzustellen, die sich auf die n√§chste Ebene "konzentrieren". </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Verwenden von DSL zum Pr√§sentieren von √Ñnderungen </h3><br><p>  Als n√§chstes betrachten wir die Bildung von Testdaten, indem wir √Ñnderungen an einem anf√§nglichen Eingabeobjekt vornehmen.  Normalerweise m√ºssen wir einige √Ñnderungen vornehmen, um das ben√∂tigte Testobjekt zu erhalten.  Gleichzeitig ist es sehr n√ºtzlich, eine Liste der √Ñnderungen in die Textbeschreibung von TestCase aufzunehmen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Dann wissen wir immer, f√ºr welche Testdaten der Test durchgef√ºhrt wird. </p><br><p>  Damit die Textliste der √Ñnderungen nicht von den tats√§chlichen √Ñnderungen abweicht, m√ºssen Sie dem Prinzip "einer einzigen Version der Wahrheit" folgen.  (Wenn dieselbe Information an mehreren Stellen ben√∂tigt / verwendet wird, sollte es eine einzige prim√§re Quelle f√ºr eindeutige Informationen geben, und Informationen sollten automatisch mit den erforderlichen Transformationen an alle anderen Verwendungsstellen verteilt werden. Wenn dieses Prinzip verletzt wird und ein manuelles Kopieren von Informationen unvermeidlich ist . Diskrepanz Versionsinformationen an verschiedenen Punkten in anderen Worten in der Beschreibung der Testdaten, k√∂nnen wir ein und Testdaten sehen -. ein weiteres Beispiel, das Kopieren einer √Ñnderung <code>field2 = "456"</code> und in der Einstellung <code>field3 = "789"</code> wir Mauger  Vergessen versehentlich die Beschreibung zu korrigieren. Als Ergebnis wird die Beschreibung nur zwei √Ñnderungen von drei reflektieren.) </p><br><p>  In unserem Fall sind die √Ñnderungen selbst die Hauptinformationsquelle bzw. der Quellcode des Programms, das die √Ñnderungen vornimmt.  Wir m√∂chten daraus einen Text ableiten, der die √Ñnderungen beschreibt.  Nebenbei k√∂nnen Sie als erste Option die Verwendung eines Makros vorschlagen, das den Quellcode der √Ñnderungen erfasst, und den Quellcode als Dokumentation verwenden.  Dies ist anscheinend eine gute und relativ unkomplizierte Methode, um tats√§chliche √Ñnderungen zu dokumentieren, und kann in einigen F√§llen durchaus angewendet werden.  Wenn wir die √Ñnderungen im Klartext darstellen, verlieren wir leider die F√§higkeit, sinnvolle Transformationen der √Ñnderungsliste vorzunehmen.  Erkennen und beseitigen Sie beispielsweise doppelte oder √ºberlappende √Ñnderungen und erstellen Sie eine Liste der √Ñnderungen auf eine f√ºr den Endbenutzer bequeme Weise. </p><br><p>  Um √Ñnderungen verarbeiten zu k√∂nnen, m√ºssen Sie √ºber ein strukturiertes Modell verf√ºgen.  Das Modell sollte aussagekr√§ftig genug sein, um alle √Ñnderungen zu beschreiben, die uns interessieren.  Teil dieses Modells ist beispielsweise die Adressierung von Objektfeldern, Konstanten und Zuweisungsoperationen. </p><br><p>  Das √Ñnderungsmodell sollte die L√∂sung der folgenden Aufgaben erm√∂glichen: </p><br><ol><li>  Spawn-√Ñnderungsmodellinstanzen.  (Das hei√üt, tats√§chlich wird eine bestimmte Liste von √Ñnderungen erstellt.) </li><li>  Bildung einer Textbeschreibung der √Ñnderungen. </li><li>  Anwenden von √Ñnderungen auf Dom√§nenobjekte. </li><li>  Durchf√ºhren von Optimierungstransformationen f√ºr das Modell. </li></ol><br><p>  Wenn eine universelle Programmiersprache verwendet wird, um √Ñnderungen vorzunehmen, kann es schwierig sein, diese √Ñnderungen im Modell darzustellen.  Der Quellcode des Programms kann komplexe Konstruktionen verwenden, die vom Modell nicht unterst√ºtzt werden.  Ein solches Programm kann sekund√§re Muster wie Linsen oder die <code>copy</code> verwenden, um die Felder eines Objekts zu √§ndern, bei denen es sich um Abstraktionen niedrigerer Ebene relativ zur Ebene des √Ñnderungsmodells handelt.  Infolgedessen kann eine zus√§tzliche Analyse solcher Muster erforderlich sein, um Instanzen von √Ñnderungen auszugeben.  Daher ist eine gute Option mit einem Makro zun√§chst nicht sehr praktisch. </p><br><p>  Eine andere M√∂glichkeit, Instanzen des √Ñnderungsmodells zu erstellen, kann eine spezielle Sprache (DSL) sein, die √Ñnderungsmodellobjekte mithilfe einer Reihe von Erweiterungsmethoden und Hilfsoperatoren erstellt.  In den einfachsten F√§llen k√∂nnen Instanzen des √Ñnderungsmodells direkt √ºber die Konstruktoren erstellt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Sprachdetails √§ndern</b> <div class="spoiler_text"><p>  Die √Ñnderungssprache ist eine ziemlich komplexe Konstruktion, die mehrere Komponenten enth√§lt, die wiederum nicht trivial sind. </p><br><ol><li>  Datenstrukturmodell. </li><li>  Modell √§ndern. </li><li>  Tats√§chlich eingebettetes (?) DSL - Hilfskonstruktionen, Erweiterungsmethoden zur bequemen Konstruktion von √Ñnderungen. </li><li>  Ein Interpret von √Ñnderungen, mit dem Sie ein Objekt tats√§chlich "√§ndern" k√∂nnen (tats√§chlich k√∂nnen Sie nat√ºrlich eine ge√§nderte Kopie erstellen). </li></ol><br><p>  Hier ist ein Beispiel f√ºr ein Programm, das mit DSL geschrieben wurde: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Mit den Erweiterungsmethoden <code>\</code> und <code>:=</code> , <code>PropertyAccess</code> werden <code>SetProperty</code> Objekte aus den zuvor erstellten <code>target</code> , <code>field1</code> , <code>subobject</code> und <code>field2</code> .  Aufgrund (gef√§hrlicher) impliziter Konvertierungen wird die Zeichenfolge "123" in einen <code>LiftedString</code> gepackt (Sie k√∂nnen auf implizite Konvertierungen verzichten und die entsprechende Methode explizit aufrufen: <code>lift("123")</code> ). </p><br><p>  Eine typisierte Ontologie kann als Datenmodell verwendet werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/229035/</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/222553/</a> ).  (Kurz <code>val field1: Property[Target, String]</code> werden deklariert, die die Eigenschaften eines beliebigen <code>val field1: Property[Target, String]</code> : <code>val field1: Property[Target, String]</code> .) In diesem Fall k√∂nnen die tats√§chlichen Daten beispielsweise in Form von JSON gespeichert werden.  Die Bequemlichkeit einer typisierten Ontologie liegt in unserem Fall in der Tatsache, dass das √Ñnderungsmodell normalerweise mit einzelnen Eigenschaften von Objekten arbeitet und die Ontologie lediglich ein geeignetes Werkzeug zum Adressieren von Eigenschaften bietet. </p><br><p>  Um die √Ñnderungen darzustellen, ben√∂tigen Sie eine Reihe von Klassen mit demselben Plan wie die <code>SetProperty</code> genannte <code>SetProperty</code> Klasse: </p><br><ul><li>  <code>Modify</code> - Anwendung der Funktion, </li><li>  <code>Changes</code> - mehrere √Ñnderungen nacheinander anwenden </li><li>  <code>ForEach</code> - √Ñnderungen auf jedes Element in der Sammlung anwenden, </li><li>  usw. </li></ul><br><p>  Der Interpreter zum √Ñndern der Sprache ist ein regul√§rer Evaluator f√ºr rekursive Ausdr√ºcke, der auf PatternMatching basiert.  So etwas wie: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Um die Eigenschaften von Objekten direkt bearbeiten zu k√∂nnen, m√ºssen Sie f√ºr jede im √Ñnderungsmodell verwendete Eigenschaft Getter und Setter angeben.  Dies kann erreicht werden, indem die Karte zwischen den ontologischen Eigenschaften und den entsprechenden Linsen ausgef√ºllt wird. </p></div></div><br><p>  Dieser Ansatz als Ganzes funktioniert und erm√∂glicht es Ihnen, die √Ñnderungen einmal zu beschreiben, aber nach und nach m√ºssen immer komplexere √Ñnderungen dargestellt werden, und das Modell der √Ñnderungen w√§chst etwas.  Wenn Sie beispielsweise eine Eigenschaft mithilfe des Werts einer anderen Eigenschaft desselben Objekts √§ndern m√ºssen (z. B. <code>field1 = field2 + 1</code> ), m√ºssen Sie Variablen auf DSL-Ebene unterst√ºtzen.  Wenn das √Ñndern einer Eigenschaft nicht trivial ist, ist auf DSL-Ebene die Unterst√ºtzung von arithmetischen Ausdr√ºcken und Funktionen erforderlich. </p><br><h3 id="testirovanie-vetvey">  Branchentests </h3><br><p>  Der Testcode kann linear sein, und dann reicht im Gro√üen und Ganzen ein Satz von Testdaten aus, um zu verstehen, ob er funktioniert.  Wenn es einen Zweig gibt ( <code>if-then-else</code> ), m√ºssen Sie das wei√üe Feld mindestens zweimal mit unterschiedlichen Eingabedaten ausf√ºhren, damit beide Zweige ausgef√ºhrt werden.  Die Anzahl der S√§tze von Eingabedaten, die ausreichen, um alle Zweige abzudecken, entspricht anscheinend numerisch der zyklomatischen Komplexit√§t des Codes mit Zweigen. </p><br><p>  Wie bilde ich alle S√§tze von Eingabedaten?  Da es sich um eine wei√üe Box handelt, k√∂nnen wir die Verzweigungsbedingungen isolieren und das Eingabeobjekt zweimal √§ndern, sodass in einem Fall eine Verzweigung ausgef√ºhrt wird, in dem anderen Fall eine andere.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Unter solchen Bedingungen k√∂nnen wir zwei Testf√§lle bilden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Falls eines der Testszenarien nicht erstellt werden kann, k√∂nnen wir davon ausgehen, dass toter Code erkannt wurde und die Bedingung zusammen mit dem entsprechenden Zweig sicher entfernt werden kann.)</em> </p><br><p>  Wenn unabh√§ngige Eigenschaften eines Objekts in mehreren Zweigen √ºberpr√ºft werden, ist es recht einfach, einen vollst√§ndigen Satz modifizierter Testobjekte zu bilden, der alle m√∂glichen Kombinationen vollst√§ndig abdeckt. </p><br><div class="spoiler">  <b class="spoiler_title">DSL, um alle Kombinationen von √Ñnderungen zu bilden</b> <div class="spoiler_text"><p>  Lassen Sie uns den Mechanismus genauer betrachten, mit dem alle m√∂glichen √Ñnderungslisten erstellt werden k√∂nnen, die eine vollst√§ndige Abdeckung aller Zweige erm√∂glichen.  Um die Liste der √Ñnderungen w√§hrend des Testens verwenden zu k√∂nnen, m√ºssen wir alle √Ñnderungen in einem Objekt zusammenfassen, das wir an die Eingabe des getesteten Codes senden, dh Unterst√ºtzung f√ºr die Komposition ist erforderlich.  Dazu k√∂nnen Sie entweder das obige DSL verwenden, um √Ñnderungen zu modellieren, und dann reicht eine einfache Liste von √Ñnderungen aus, oder Sie k√∂nnen eine √Ñnderung als √Ñnderungsfunktion <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  dann wird die Kette von √Ñnderungen einfach eine Zusammensetzung von Funktionen sein: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  oder f√ºr eine Liste von √Ñnderungen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Um alle √Ñnderungen, die allen m√∂glichen Zweigen entsprechen, kompakt aufzuzeichnen, k√∂nnen Sie das DSL der folgenden Abstraktionsebene verwenden, das die Struktur der getesteten White Box simuliert: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Hier enth√§lt die Testsammlung aggregierte √Ñnderungen, die allen m√∂glichen Kombinationen von Zweigen entsprechen.  Ein Parameter vom Typ <code>String</code> enth√§lt alle Namen der Bedingungen und alle Beschreibungen der √Ñnderungen, aus denen die aggregierte √Ñnderungsfunktion gebildet wird.  Und das zweite Element eines Paares vom Typ <code>T =&gt; T</code> ist nur die aggregierte Funktion von √Ñnderungen, die sich aus der Zusammensetzung einzelner √Ñnderungen ergeben. </p><br><p>  Um die ge√§nderten Objekte abzurufen, m√ºssen Sie alle aggregierten √Ñnderungsfunktionen auf das Basisobjekt anwenden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Als Ergebnis erhalten wir eine Sammlung von Paaren, und die Zeile beschreibt die angewendeten √Ñnderungen, und das zweite Element des Paares ist das Objekt, in dem alle diese √Ñnderungen kombiniert werden. </p><br><p>  Basierend auf der Struktur des Modells des getesteten Codes in Form eines Baums stellen die √Ñnderungslisten den Pfad von der Wurzel zu den Bl√§ttern dieses Baums dar.  Somit wird ein wesentlicher Teil der √Ñnderungen dupliziert.  Sie k√∂nnen diese Duplizierung mithilfe der DSL-Option entfernen, bei der die √Ñnderungen direkt auf das Basisobjekt angewendet werden, wenn Sie sich entlang der Zweige bewegen.  In diesem Fall werden weniger unn√∂tige Berechnungen durchgef√ºhrt. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Automatische Generierung von Testdaten </h3><br><p>  Da es sich um eine wei√üe Box handelt, k√∂nnen wir alle Zweige sehen.  Auf diese Weise k√∂nnen Sie ein Logikmodell erstellen, das in einer wei√üen Box enthalten ist, und das Modell zum Generieren von Testdaten verwenden.  Wenn der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testcode</a> in Scala geschrieben ist, k√∂nnen Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scalameta</a> zum Lesen des Codes verwenden und anschlie√üend in ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logikmodell</a> konvertieren.  Wie in der zuvor diskutierten Ausgabe der Modellierung der Logik von Ver√§nderungen ist es auch hier schwierig f√ºr uns, alle M√∂glichkeiten einer universellen Sprache zu modellieren.  Ferner nehmen wir an, dass der getestete Code unter Verwendung einer begrenzten Teilmenge der Sprache oder in einer anderen Sprache oder DSL implementiert wird, die anf√§nglich begrenzt ist.  Dadurch k√∂nnen wir uns auf die Aspekte der Sprache konzentrieren, die f√ºr uns von Interesse sind. </p><br><p>  Betrachten Sie ein Beispiel f√ºr Code, der einen einzelnen Zweig enth√§lt: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Die Bedingung teilt die Menge der <code>field1</code> Werte in zwei √Ñquivalenzklassen auf: <code>== "123"</code> und <code>!= "123"</code> .  Daher wird der gesamte Satz von Eingabedaten in Bezug auf diese Bedingung auch in zwei √Ñquivalenzklassen unterteilt - <code>ClassCondition1IsTrue</code> und <code>ClassCondition1IsFalse</code> .  Unter dem Gesichtspunkt der Vollst√§ndigkeit der Berichterstattung reicht es aus, mindestens ein Beispiel aus diesen beiden Klassen zu nehmen, um beide Zweige <code>A</code> und <code>B</code> abzudecken <code>B</code>  F√ºr die erste Klasse k√∂nnen wir ein Beispiel in gewisser Weise auf einzigartige Weise <code>field1</code> : Nehmen Sie ein zuf√§lliges Objekt, aber √§ndern Sie <code>field1</code> in <code>"123"</code> .  Dar√ºber hinaus wird das Objekt sicherlich in der √Ñquivalenzklasse <code>ClassCondition1IsTrue</code> und die Berechnungen werden entlang Zweig <code>A</code>  Es gibt weitere Beispiele f√ºr die zweite Klasse.  Eine M√∂glichkeit, ein Beispiel f√ºr die zweite Klasse zu generieren, besteht darin, beliebige Eingabeobjekte zu generieren und diese mit <code>field1 == "123"</code> verwerfen.  Eine andere M√∂glichkeit: <code>field1</code> ein zuf√§lliges Objekt zu nehmen, aber <code>field1</code> in <code>"123" + "*"</code> √§ndern (zur √Ñnderung k√∂nnen Sie jede √Ñnderung in der Steuerzeile verwenden, um sicherzustellen, dass die neue Zeile nicht der Steuerzeile entspricht). </p><br><p>  <a href=""><code>  Arbitrary</code> und <code>Gen</code> aus der ScalaCheck-Bibliothek</a> eignen sich gut als Zufallsdatengeneratoren. </p><br><p>  Im Wesentlichen <strong>rufen</strong> wir <strong>die</strong> in der <code>if</code> verwendete boolesche Funktion auf.  Das hei√üt, wir finden alle Werte des Eingabeobjekts, f√ºr das diese Boolesche Funktion <code>true</code> - <code>ClassCondition1IsTrue</code> , und alle Werte des Eingabeobjekts, f√ºr das <code>false</code> - <code>ClassCondition1IsFalse</code> akzeptiert <code>ClassCondition1IsFalse</code> . </p><br><p>  In √§hnlicher Weise ist es m√∂glich, Daten zu generieren, die f√ºr die Einschr√§nkungen geeignet sind, die von einfachen bedingten Operatoren mit Konstanten generiert werden (mehr / weniger als eine in einer Menge enthaltene Konstante beginnt mit einer Konstanten).  Solche Bedingungen sind leicht umzukehren.  Selbst wenn einfache Funktionen im Testcode aufgerufen werden, k√∂nnen wir ihren Aufruf durch ihre Definition (Inline) ersetzen und dennoch bedingte Ausdr√ºcke invertieren. </p><br><h4 id="trudno-obratimye-funkcii">  Harte reversible Funktionen </h4><br><p>  Die Situation ist anders, wenn die Bedingung eine Funktion verwendet, die schwer umzukehren ist.  Wenn beispielsweise eine Hash-Funktion verwendet wird, scheint es nicht m√∂glich zu sein, automatisch ein Beispiel mit dem gew√ºnschten Wert des Hash-Codes zu generieren. </p><br><p>  In diesem Fall k√∂nnen Sie dem Eingabeobjekt, das das Ergebnis der Funktionsberechnung darstellt, einen zus√§tzlichen Parameter hinzuf√ºgen, den Funktionsaufruf durch einen Aufruf dieses Parameters ersetzen und diesen Parameter trotz Verletzung der Funktionsverbindung aktualisieren: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Ein zus√§tzlicher Parameter erm√∂glicht die Codeausf√ºhrung innerhalb des Zweigs, kann jedoch offensichtlich zu tats√§chlich falschen Ergebnissen f√ºhren.  Das hei√üt, das Testprogramm liefert Ergebnisse, die in der Realit√§t niemals beobachtet werden k√∂nnen.  Die √úberpr√ºfung eines Teils des Codes, auf den wir sonst nicht zugreifen k√∂nnen, ist dennoch n√ºtzlich und kann als eine Form des Komponententests angesehen werden.  Schlie√ülich wird auch w√§hrend des Komponententests eine Unterfunktion mit Argumenten aufgerufen, die m√∂glicherweise nie im Programm verwendet werden. </p><br><p>  Mit solchen Manipulationen ersetzen wir das Testobjekt.  In gewissem Sinne enth√§lt das neu erstellte Programm jedoch die Logik des alten Programms.  Wenn wir als Werte der neuen k√ºnstlichen Parameter die Ergebnisse der Berechnung der Funktionen verwenden, die wir durch die Parameter ersetzt haben, liefert das Programm dieselben Ergebnisse.  Anscheinend k√∂nnte das Testen des modifizierten Programms immer noch von Interesse sein.  Sie m√ºssen sich nur merken, unter welchen Bedingungen sich das ge√§nderte Programm genauso verh√§lt wie das urspr√ºngliche. </p><br><h4 id="zavisimye-usloviya">  Abh√§ngige Bedingungen </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   ‚Äî <code>x &lt;= 1</code> .         ,           ‚Äî <code>(-‚àû, 0]</code> , <code>(0, 1]</code> , <code>(1, +‚àû)</code> , ‚Äî      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       ‚Äî <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         ‚Äî <code>true</code>  <code>false</code> .       .           .  Zum Beispiel </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Danksagung </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422283/">https://habr.com/ru/post/de422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422269/index.html">Das Buch "Internes Ger√§t Windows. 7. Aufl</a></li>
<li><a href="../de422273/index.html">In einer intelligenten Stadt gibt es keine dummen Stra√üen. Was ist RWIS und wie werden die Kosten f√ºr Stra√üenarbeiten gesenkt?</a></li>
<li><a href="../de422275/index.html">Ein Google-Mitarbeiter konnte das T√ºr√∂ffnungssystem im B√ºro des Unternehmens aufgrund einer Software-Sicherheitsl√ºcke steuern</a></li>
<li><a href="../de422277/index.html">Architektur und Programmierung RCA Studio II</a></li>
<li><a href="../de422281/index.html">A7 Data Server: Datenverwaltung online</a></li>
<li><a href="../de422285/index.html">Warum Online-Shopping genug Loyalit√§t von 1% der Kunden hat</a></li>
<li><a href="../de422291/index.html">Kleine Black Box (Visualisierung aller Geld- und Weltm√§rkte)</a></li>
<li><a href="../de422293/index.html">Abrufen der Alarmliste von OSS √ºber die AlarmIRP-Schnittstelle</a></li>
<li><a href="../de422297/index.html">Die erste Erfahrung oder wie man versucht, eine Legende von Code und Magie zu werden</a></li>
<li><a href="../de422299/index.html">TsNIImash: SpaceX setzt angeblich sowjetische Entwicklungen um. Warum Ilon Mask so viele Feinde hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>