<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎮 😏 🌭 White-Box-Test 👩‍🎤 👿 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung hochwertiger Programme setzt voraus, dass das Programm und seine Teile getestet werden. Beim klassischen Testen von Einheiten wird ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>White-Box-Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  Die Entwicklung hochwertiger Programme setzt voraus, dass das Programm und seine Teile getestet werden.  Beim klassischen Testen von Einheiten wird ein großes Programm in kleine Blöcke aufgeteilt, die zum Testen geeignet sind.  Oder wenn die Entwicklung von Tests parallel zur Entwicklung von Code erfolgt oder Tests vor dem Programm entwickelt werden (TDD - Test Driven Development), wird das Programm zunächst in kleinen Blöcken entwickelt, die für die Anforderungen der Tests geeignet sind. </p><br><p>  Eine der Varianten von Unit-Tests kann als eigenschaftsbasiertes Testen betrachtet werden (dieser Ansatz ist beispielsweise in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScalaCheck implementiert</a> ).  Dieser Ansatz basiert auf der Suche nach universellen Eigenschaften, die für alle Eingabedaten gültig sein sollten.  Beispielsweise sollte eine <em>Serialisierung gefolgt von einer Deserialisierung dasselbe Objekt erzeugen</em> .  Durch <em>erneutes Sortieren sollte die Reihenfolge der Elemente in der Liste nicht geändert werden</em> .  Um solche universellen Eigenschaften zu überprüfen, unterstützen die obigen Bibliotheken einen Mechanismus zum Generieren von zufälligen Eingabedaten.  Dieser Ansatz eignet sich besonders gut für Programme, die auf mathematischen Gesetzen basieren und als universelle Eigenschaften für eine breite Klasse von Programmen dienen.  Es gibt sogar eine Bibliothek mit vorgefertigten mathematischen Eigenschaften - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Disziplin</a> -, mit der Sie die Leistung dieser Eigenschaften in neuen Programmen überprüfen können (ein gutes Beispiel für die Wiederverwendung von Tests). </p><br><p>  Manchmal stellt sich heraus, dass es notwendig ist, ein komplexes Programm zu testen, ohne es in unabhängig überprüfbare Teile zerlegen zu können.  In diesem Fall ist das Testprogramm <del>  schwarz </del>  White Box (weiß - weil wir die Möglichkeit haben, die interne Struktur des Programms zu studieren). </p><br><p>  Im Rahmen des Schnitts werden verschiedene Ansätze zum Testen komplexer Programme mit einer Eingabe mit unterschiedlichem Komplexitätsgrad (Beteiligung) und unterschiedlichem Abdeckungsgrad beschrieben. </p><a name="habracut"></a><br><p>  * <em>In diesem Artikel gehen wir davon aus, dass das zu testende Programm als reine Funktion ohne internen Zustand dargestellt werden kann.</em>  <em>(Einige der folgenden Überlegungen können angewendet werden, wenn der interne Zustand vorliegt, es ist jedoch möglich, diesen Zustand auf einen festen Wert zurückzusetzen.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Prüfstand </h3><br><p> Da nur eine Funktion getestet wird, deren aufrufender Code immer der gleiche ist, müssen wir zunächst keine separaten Komponententests erstellen.  Alle diese Tests wären gleich, genau auf die Eingabe und die Prüfungen.  Es reicht völlig aus, die Quelldaten ( <code>input</code> ) in einer Schleife zu übertragen und die Ergebnisse ( <code>expectedOutput</code> ) zu überprüfen.  Um einen Problemsatz von Testdaten im Falle einer Fehlererkennung zu identifizieren, müssen alle Testdaten gekennzeichnet werden.  Somit kann ein Satz von Testdaten als Dreifach dargestellt werden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Das Ergebnis eines Laufs kann als <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Wir präsentieren das Ergebnis des Starts mit <code>Try</code> , mögliche Ausnahmen abzufangen.) </p><br><p>  Um die Ausführung aller Testdaten durch das zu testende Programm zu vereinfachen, können Sie eine Hilfsfunktion verwenden, die das Programm für jeden Eingabewert aufruft: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Diese Hilfsfunktion gibt die problematischen Daten und Ergebnisse zurück, die sich von den erwarteten unterscheiden. </p><br><p>  Der Einfachheit halber können Sie die Testergebnisse formatieren. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  und zeigen Sie einen Bericht nur bei Fehlern an: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Eingabevorbereitung </h3><br><p>  Im einfachsten Fall können Sie manuell Testdaten erstellen, um das Programm zu testen, es direkt in den Testcode zu schreiben und wie oben gezeigt zu verwenden.  Es stellt sich oft heraus, dass interessante Fälle von Testdaten viel gemeinsam haben und mit geringfügigen Änderungen als grundlegende Instanz dargestellt werden können. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Bei der Arbeit mit verschachtelten unveränderlichen Datenstrukturen sind Objektive eine große Hilfe, beispielsweise aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monocle-</a> Bibliothek: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Mit Objektiven können Sie tief verschachtelte Teile von Datenstrukturen elegant „modifizieren“: Jedes Objektiv ist ein Getter und Setter für eine Eigenschaft.  Objektive können kombiniert werden, um Objektive herzustellen, die sich auf die nächste Ebene "konzentrieren". </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Verwenden von DSL zum Präsentieren von Änderungen </h3><br><p>  Als nächstes betrachten wir die Bildung von Testdaten, indem wir Änderungen an einem anfänglichen Eingabeobjekt vornehmen.  Normalerweise müssen wir einige Änderungen vornehmen, um das benötigte Testobjekt zu erhalten.  Gleichzeitig ist es sehr nützlich, eine Liste der Änderungen in die Textbeschreibung von TestCase aufzunehmen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Dann wissen wir immer, für welche Testdaten der Test durchgeführt wird. </p><br><p>  Damit die Textliste der Änderungen nicht von den tatsächlichen Änderungen abweicht, müssen Sie dem Prinzip "einer einzigen Version der Wahrheit" folgen.  (Wenn dieselbe Information an mehreren Stellen benötigt / verwendet wird, sollte es eine einzige primäre Quelle für eindeutige Informationen geben, und Informationen sollten automatisch mit den erforderlichen Transformationen an alle anderen Verwendungsstellen verteilt werden. Wenn dieses Prinzip verletzt wird und ein manuelles Kopieren von Informationen unvermeidlich ist . Diskrepanz Versionsinformationen an verschiedenen Punkten in anderen Worten in der Beschreibung der Testdaten, können wir ein und Testdaten sehen -. ein weiteres Beispiel, das Kopieren einer Änderung <code>field2 = "456"</code> und in der Einstellung <code>field3 = "789"</code> wir Mauger  Vergessen versehentlich die Beschreibung zu korrigieren. Als Ergebnis wird die Beschreibung nur zwei Änderungen von drei reflektieren.) </p><br><p>  In unserem Fall sind die Änderungen selbst die Hauptinformationsquelle bzw. der Quellcode des Programms, das die Änderungen vornimmt.  Wir möchten daraus einen Text ableiten, der die Änderungen beschreibt.  Nebenbei können Sie als erste Option die Verwendung eines Makros vorschlagen, das den Quellcode der Änderungen erfasst, und den Quellcode als Dokumentation verwenden.  Dies ist anscheinend eine gute und relativ unkomplizierte Methode, um tatsächliche Änderungen zu dokumentieren, und kann in einigen Fällen durchaus angewendet werden.  Wenn wir die Änderungen im Klartext darstellen, verlieren wir leider die Fähigkeit, sinnvolle Transformationen der Änderungsliste vorzunehmen.  Erkennen und beseitigen Sie beispielsweise doppelte oder überlappende Änderungen und erstellen Sie eine Liste der Änderungen auf eine für den Endbenutzer bequeme Weise. </p><br><p>  Um Änderungen verarbeiten zu können, müssen Sie über ein strukturiertes Modell verfügen.  Das Modell sollte aussagekräftig genug sein, um alle Änderungen zu beschreiben, die uns interessieren.  Teil dieses Modells ist beispielsweise die Adressierung von Objektfeldern, Konstanten und Zuweisungsoperationen. </p><br><p>  Das Änderungsmodell sollte die Lösung der folgenden Aufgaben ermöglichen: </p><br><ol><li>  Spawn-Änderungsmodellinstanzen.  (Das heißt, tatsächlich wird eine bestimmte Liste von Änderungen erstellt.) </li><li>  Bildung einer Textbeschreibung der Änderungen. </li><li>  Anwenden von Änderungen auf Domänenobjekte. </li><li>  Durchführen von Optimierungstransformationen für das Modell. </li></ol><br><p>  Wenn eine universelle Programmiersprache verwendet wird, um Änderungen vorzunehmen, kann es schwierig sein, diese Änderungen im Modell darzustellen.  Der Quellcode des Programms kann komplexe Konstruktionen verwenden, die vom Modell nicht unterstützt werden.  Ein solches Programm kann sekundäre Muster wie Linsen oder die <code>copy</code> verwenden, um die Felder eines Objekts zu ändern, bei denen es sich um Abstraktionen niedrigerer Ebene relativ zur Ebene des Änderungsmodells handelt.  Infolgedessen kann eine zusätzliche Analyse solcher Muster erforderlich sein, um Instanzen von Änderungen auszugeben.  Daher ist eine gute Option mit einem Makro zunächst nicht sehr praktisch. </p><br><p>  Eine andere Möglichkeit, Instanzen des Änderungsmodells zu erstellen, kann eine spezielle Sprache (DSL) sein, die Änderungsmodellobjekte mithilfe einer Reihe von Erweiterungsmethoden und Hilfsoperatoren erstellt.  In den einfachsten Fällen können Instanzen des Änderungsmodells direkt über die Konstruktoren erstellt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Sprachdetails ändern</b> <div class="spoiler_text"><p>  Die Änderungssprache ist eine ziemlich komplexe Konstruktion, die mehrere Komponenten enthält, die wiederum nicht trivial sind. </p><br><ol><li>  Datenstrukturmodell. </li><li>  Modell ändern. </li><li>  Tatsächlich eingebettetes (?) DSL - Hilfskonstruktionen, Erweiterungsmethoden zur bequemen Konstruktion von Änderungen. </li><li>  Ein Interpret von Änderungen, mit dem Sie ein Objekt tatsächlich "ändern" können (tatsächlich können Sie natürlich eine geänderte Kopie erstellen). </li></ol><br><p>  Hier ist ein Beispiel für ein Programm, das mit DSL geschrieben wurde: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Mit den Erweiterungsmethoden <code>\</code> und <code>:=</code> , <code>PropertyAccess</code> werden <code>SetProperty</code> Objekte aus den zuvor erstellten <code>target</code> , <code>field1</code> , <code>subobject</code> und <code>field2</code> .  Aufgrund (gefährlicher) impliziter Konvertierungen wird die Zeichenfolge "123" in einen <code>LiftedString</code> gepackt (Sie können auf implizite Konvertierungen verzichten und die entsprechende Methode explizit aufrufen: <code>lift("123")</code> ). </p><br><p>  Eine typisierte Ontologie kann als Datenmodell verwendet werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/229035/</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/222553/</a> ).  (Kurz <code>val field1: Property[Target, String]</code> werden deklariert, die die Eigenschaften eines beliebigen <code>val field1: Property[Target, String]</code> : <code>val field1: Property[Target, String]</code> .) In diesem Fall können die tatsächlichen Daten beispielsweise in Form von JSON gespeichert werden.  Die Bequemlichkeit einer typisierten Ontologie liegt in unserem Fall in der Tatsache, dass das Änderungsmodell normalerweise mit einzelnen Eigenschaften von Objekten arbeitet und die Ontologie lediglich ein geeignetes Werkzeug zum Adressieren von Eigenschaften bietet. </p><br><p>  Um die Änderungen darzustellen, benötigen Sie eine Reihe von Klassen mit demselben Plan wie die <code>SetProperty</code> genannte <code>SetProperty</code> Klasse: </p><br><ul><li>  <code>Modify</code> - Anwendung der Funktion, </li><li>  <code>Changes</code> - mehrere Änderungen nacheinander anwenden </li><li>  <code>ForEach</code> - Änderungen auf jedes Element in der Sammlung anwenden, </li><li>  usw. </li></ul><br><p>  Der Interpreter zum Ändern der Sprache ist ein regulärer Evaluator für rekursive Ausdrücke, der auf PatternMatching basiert.  So etwas wie: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Um die Eigenschaften von Objekten direkt bearbeiten zu können, müssen Sie für jede im Änderungsmodell verwendete Eigenschaft Getter und Setter angeben.  Dies kann erreicht werden, indem die Karte zwischen den ontologischen Eigenschaften und den entsprechenden Linsen ausgefüllt wird. </p></div></div><br><p>  Dieser Ansatz als Ganzes funktioniert und ermöglicht es Ihnen, die Änderungen einmal zu beschreiben, aber nach und nach müssen immer komplexere Änderungen dargestellt werden, und das Modell der Änderungen wächst etwas.  Wenn Sie beispielsweise eine Eigenschaft mithilfe des Werts einer anderen Eigenschaft desselben Objekts ändern müssen (z. B. <code>field1 = field2 + 1</code> ), müssen Sie Variablen auf DSL-Ebene unterstützen.  Wenn das Ändern einer Eigenschaft nicht trivial ist, ist auf DSL-Ebene die Unterstützung von arithmetischen Ausdrücken und Funktionen erforderlich. </p><br><h3 id="testirovanie-vetvey">  Branchentests </h3><br><p>  Der Testcode kann linear sein, und dann reicht im Großen und Ganzen ein Satz von Testdaten aus, um zu verstehen, ob er funktioniert.  Wenn es einen Zweig gibt ( <code>if-then-else</code> ), müssen Sie das weiße Feld mindestens zweimal mit unterschiedlichen Eingabedaten ausführen, damit beide Zweige ausgeführt werden.  Die Anzahl der Sätze von Eingabedaten, die ausreichen, um alle Zweige abzudecken, entspricht anscheinend numerisch der zyklomatischen Komplexität des Codes mit Zweigen. </p><br><p>  Wie bilde ich alle Sätze von Eingabedaten?  Da es sich um eine weiße Box handelt, können wir die Verzweigungsbedingungen isolieren und das Eingabeobjekt zweimal ändern, sodass in einem Fall eine Verzweigung ausgeführt wird, in dem anderen Fall eine andere.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Unter solchen Bedingungen können wir zwei Testfälle bilden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Falls eines der Testszenarien nicht erstellt werden kann, können wir davon ausgehen, dass toter Code erkannt wurde und die Bedingung zusammen mit dem entsprechenden Zweig sicher entfernt werden kann.)</em> </p><br><p>  Wenn unabhängige Eigenschaften eines Objekts in mehreren Zweigen überprüft werden, ist es recht einfach, einen vollständigen Satz modifizierter Testobjekte zu bilden, der alle möglichen Kombinationen vollständig abdeckt. </p><br><div class="spoiler">  <b class="spoiler_title">DSL, um alle Kombinationen von Änderungen zu bilden</b> <div class="spoiler_text"><p>  Lassen Sie uns den Mechanismus genauer betrachten, mit dem alle möglichen Änderungslisten erstellt werden können, die eine vollständige Abdeckung aller Zweige ermöglichen.  Um die Liste der Änderungen während des Testens verwenden zu können, müssen wir alle Änderungen in einem Objekt zusammenfassen, das wir an die Eingabe des getesteten Codes senden, dh Unterstützung für die Komposition ist erforderlich.  Dazu können Sie entweder das obige DSL verwenden, um Änderungen zu modellieren, und dann reicht eine einfache Liste von Änderungen aus, oder Sie können eine Änderung als Änderungsfunktion <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  dann wird die Kette von Änderungen einfach eine Zusammensetzung von Funktionen sein: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  oder für eine Liste von Änderungen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Um alle Änderungen, die allen möglichen Zweigen entsprechen, kompakt aufzuzeichnen, können Sie das DSL der folgenden Abstraktionsebene verwenden, das die Struktur der getesteten White Box simuliert: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Hier enthält die Testsammlung aggregierte Änderungen, die allen möglichen Kombinationen von Zweigen entsprechen.  Ein Parameter vom Typ <code>String</code> enthält alle Namen der Bedingungen und alle Beschreibungen der Änderungen, aus denen die aggregierte Änderungsfunktion gebildet wird.  Und das zweite Element eines Paares vom Typ <code>T =&gt; T</code> ist nur die aggregierte Funktion von Änderungen, die sich aus der Zusammensetzung einzelner Änderungen ergeben. </p><br><p>  Um die geänderten Objekte abzurufen, müssen Sie alle aggregierten Änderungsfunktionen auf das Basisobjekt anwenden: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Als Ergebnis erhalten wir eine Sammlung von Paaren, und die Zeile beschreibt die angewendeten Änderungen, und das zweite Element des Paares ist das Objekt, in dem alle diese Änderungen kombiniert werden. </p><br><p>  Basierend auf der Struktur des Modells des getesteten Codes in Form eines Baums stellen die Änderungslisten den Pfad von der Wurzel zu den Blättern dieses Baums dar.  Somit wird ein wesentlicher Teil der Änderungen dupliziert.  Sie können diese Duplizierung mithilfe der DSL-Option entfernen, bei der die Änderungen direkt auf das Basisobjekt angewendet werden, wenn Sie sich entlang der Zweige bewegen.  In diesem Fall werden weniger unnötige Berechnungen durchgeführt. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Automatische Generierung von Testdaten </h3><br><p>  Da es sich um eine weiße Box handelt, können wir alle Zweige sehen.  Auf diese Weise können Sie ein Logikmodell erstellen, das in einer weißen Box enthalten ist, und das Modell zum Generieren von Testdaten verwenden.  Wenn der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testcode</a> in Scala geschrieben ist, können Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scalameta</a> zum Lesen des Codes verwenden und anschließend in ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logikmodell</a> konvertieren.  Wie in der zuvor diskutierten Ausgabe der Modellierung der Logik von Veränderungen ist es auch hier schwierig für uns, alle Möglichkeiten einer universellen Sprache zu modellieren.  Ferner nehmen wir an, dass der getestete Code unter Verwendung einer begrenzten Teilmenge der Sprache oder in einer anderen Sprache oder DSL implementiert wird, die anfänglich begrenzt ist.  Dadurch können wir uns auf die Aspekte der Sprache konzentrieren, die für uns von Interesse sind. </p><br><p>  Betrachten Sie ein Beispiel für Code, der einen einzelnen Zweig enthält: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Die Bedingung teilt die Menge der <code>field1</code> Werte in zwei Äquivalenzklassen auf: <code>== "123"</code> und <code>!= "123"</code> .  Daher wird der gesamte Satz von Eingabedaten in Bezug auf diese Bedingung auch in zwei Äquivalenzklassen unterteilt - <code>ClassCondition1IsTrue</code> und <code>ClassCondition1IsFalse</code> .  Unter dem Gesichtspunkt der Vollständigkeit der Berichterstattung reicht es aus, mindestens ein Beispiel aus diesen beiden Klassen zu nehmen, um beide Zweige <code>A</code> und <code>B</code> abzudecken <code>B</code>  Für die erste Klasse können wir ein Beispiel in gewisser Weise auf einzigartige Weise <code>field1</code> : Nehmen Sie ein zufälliges Objekt, aber ändern Sie <code>field1</code> in <code>"123"</code> .  Darüber hinaus wird das Objekt sicherlich in der Äquivalenzklasse <code>ClassCondition1IsTrue</code> und die Berechnungen werden entlang Zweig <code>A</code>  Es gibt weitere Beispiele für die zweite Klasse.  Eine Möglichkeit, ein Beispiel für die zweite Klasse zu generieren, besteht darin, beliebige Eingabeobjekte zu generieren und diese mit <code>field1 == "123"</code> verwerfen.  Eine andere Möglichkeit: <code>field1</code> ein zufälliges Objekt zu nehmen, aber <code>field1</code> in <code>"123" + "*"</code> ändern (zur Änderung können Sie jede Änderung in der Steuerzeile verwenden, um sicherzustellen, dass die neue Zeile nicht der Steuerzeile entspricht). </p><br><p>  <a href=""><code>  Arbitrary</code> und <code>Gen</code> aus der ScalaCheck-Bibliothek</a> eignen sich gut als Zufallsdatengeneratoren. </p><br><p>  Im Wesentlichen <strong>rufen</strong> wir <strong>die</strong> in der <code>if</code> verwendete boolesche Funktion auf.  Das heißt, wir finden alle Werte des Eingabeobjekts, für das diese Boolesche Funktion <code>true</code> - <code>ClassCondition1IsTrue</code> , und alle Werte des Eingabeobjekts, für das <code>false</code> - <code>ClassCondition1IsFalse</code> akzeptiert <code>ClassCondition1IsFalse</code> . </p><br><p>  In ähnlicher Weise ist es möglich, Daten zu generieren, die für die Einschränkungen geeignet sind, die von einfachen bedingten Operatoren mit Konstanten generiert werden (mehr / weniger als eine in einer Menge enthaltene Konstante beginnt mit einer Konstanten).  Solche Bedingungen sind leicht umzukehren.  Selbst wenn einfache Funktionen im Testcode aufgerufen werden, können wir ihren Aufruf durch ihre Definition (Inline) ersetzen und dennoch bedingte Ausdrücke invertieren. </p><br><h4 id="trudno-obratimye-funkcii">  Harte reversible Funktionen </h4><br><p>  Die Situation ist anders, wenn die Bedingung eine Funktion verwendet, die schwer umzukehren ist.  Wenn beispielsweise eine Hash-Funktion verwendet wird, scheint es nicht möglich zu sein, automatisch ein Beispiel mit dem gewünschten Wert des Hash-Codes zu generieren. </p><br><p>  In diesem Fall können Sie dem Eingabeobjekt, das das Ergebnis der Funktionsberechnung darstellt, einen zusätzlichen Parameter hinzufügen, den Funktionsaufruf durch einen Aufruf dieses Parameters ersetzen und diesen Parameter trotz Verletzung der Funktionsverbindung aktualisieren: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Ein zusätzlicher Parameter ermöglicht die Codeausführung innerhalb des Zweigs, kann jedoch offensichtlich zu tatsächlich falschen Ergebnissen führen.  Das heißt, das Testprogramm liefert Ergebnisse, die in der Realität niemals beobachtet werden können.  Die Überprüfung eines Teils des Codes, auf den wir sonst nicht zugreifen können, ist dennoch nützlich und kann als eine Form des Komponententests angesehen werden.  Schließlich wird auch während des Komponententests eine Unterfunktion mit Argumenten aufgerufen, die möglicherweise nie im Programm verwendet werden. </p><br><p>  Mit solchen Manipulationen ersetzen wir das Testobjekt.  In gewissem Sinne enthält das neu erstellte Programm jedoch die Logik des alten Programms.  Wenn wir als Werte der neuen künstlichen Parameter die Ergebnisse der Berechnung der Funktionen verwenden, die wir durch die Parameter ersetzt haben, liefert das Programm dieselben Ergebnisse.  Anscheinend könnte das Testen des modifizierten Programms immer noch von Interesse sein.  Sie müssen sich nur merken, unter welchen Bedingungen sich das geänderte Programm genauso verhält wie das ursprüngliche. </p><br><h4 id="zavisimye-usloviya">  Abhängige Bedingungen </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           .  Zum Beispiel </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Danksagung </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422283/">https://habr.com/ru/post/de422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422269/index.html">Das Buch "Internes Gerät Windows. 7. Aufl</a></li>
<li><a href="../de422273/index.html">In einer intelligenten Stadt gibt es keine dummen Straßen. Was ist RWIS und wie werden die Kosten für Straßenarbeiten gesenkt?</a></li>
<li><a href="../de422275/index.html">Ein Google-Mitarbeiter konnte das Türöffnungssystem im Büro des Unternehmens aufgrund einer Software-Sicherheitslücke steuern</a></li>
<li><a href="../de422277/index.html">Architektur und Programmierung RCA Studio II</a></li>
<li><a href="../de422281/index.html">A7 Data Server: Datenverwaltung online</a></li>
<li><a href="../de422285/index.html">Warum Online-Shopping genug Loyalität von 1% der Kunden hat</a></li>
<li><a href="../de422291/index.html">Kleine Black Box (Visualisierung aller Geld- und Weltmärkte)</a></li>
<li><a href="../de422293/index.html">Abrufen der Alarmliste von OSS über die AlarmIRP-Schnittstelle</a></li>
<li><a href="../de422297/index.html">Die erste Erfahrung oder wie man versucht, eine Legende von Code und Magie zu werden</a></li>
<li><a href="../de422299/index.html">TsNIImash: SpaceX setzt angeblich sowjetische Entwicklungen um. Warum Ilon Mask so viele Feinde hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>