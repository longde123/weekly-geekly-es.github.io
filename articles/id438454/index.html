<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèª üëâüèæ üëåüèø OpenSceneGraph: Levels of detail (LOD) dan pemuatan latar belakang objek üèñÔ∏è ‚õ∫Ô∏è üòë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Salah satu tugas paling menarik yang diselesaikan dengan grafis tiga dimensi adalah penciptaan "dunia besar" - adegan panjang yang beris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Levels of detail (LOD) dan pemuatan latar belakang objek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438454/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Salah satu tugas paling menarik yang diselesaikan dengan grafis tiga dimensi adalah penciptaan "dunia besar" - adegan panjang yang berisi sejumlah besar objek dengan kemungkinan pergerakan tanpa batas di panggung.  Solusi untuk masalah ini terletak pada keterbatasan yang dapat dipahami yang melekat pada perangkat keras komputer. <br><br>  <i>Contoh khas: "dunia besar" saat memvisualisasikan kereta api pada mesin OSG.</i>  <i>Yang hilang hanyalah para penghuni dunia yang melahap dunia di belakang kereta ...</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YEaYugmhO2Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dalam hal ini, perlu muncul untuk mengelola sumber daya aplikasi, yang bermuara pada solusi yang jelas: memuat hanya sumber daya tersebut (model, tekstur, dan sebagainya) yang diperlukan untuk membentuk sebuah adegan pada waktu saat ini dengan posisi pengamat saat ini;  pengurangan level detail objek jarak jauh;  membongkar objek tidak lagi diperlukan dari memori sistem.  Untuk sebagian besar, mesin grafis dan permainan menyediakan seperangkat alat tertentu untuk memecahkan masalah seperti itu.  Hari ini kita melihat yang mana yang tersedia di OpenSceneGraph. <br><a name="habracut"></a><br><h1>  1. Menggunakan Levels of Detail (LOD) </h1><br>  Teknik menggunakan level detail memungkinkan Anda untuk menampilkan objek yang sama secara lebih kurang detail, tergantung pada jarak dari objek tersebut ke pengamat.  Penggunaan teknik ini didasarkan pada pertimbangan sederhana bahwa detail kecil dari model tiga dimensi tidak dapat dibedakan dari jarak yang jauh, yang berarti tidak perlu menggambarnya.  Di satu sisi, teknik ini memungkinkan Anda untuk mengurangi jumlah total geometri primitif yang ditampilkan dalam buffer bingkai, dan di sisi lain, tidak kehilangan rentang tampilan objek pemandangan, yang sangat berguna saat membuat dunia terbuka besar. <br><br>  OSG menyediakan alat untuk menerapkan teknik ini melalui kelas osg :: LOD, yang diwarisi dari osg :: Group yang sama.  Kelas ini memungkinkan Anda untuk mewakili objek yang sama dalam beberapa level detail.  Setiap tingkat detail dicirikan oleh jarak minimum dan maksimum ke pengamat, di mana pengamatan objek dihidupkan dalam tingkat detail ini. <br><br>  osg :: LOD memungkinkan Anda menentukan kisaran ini segera ketika mendefinisikan simpul anak, atau lebih baru, menggunakan metode setRange () <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; lodNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; lodNode-&gt;addChild(node2, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>, FLT_MAX); lodNode-&gt;addChild(node1); . . . lodNode-&gt;setRange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>);</code> </pre> <br>  Kami terus menyiksa Cessna dan mengilustrasikan teknik yang dijelaskan dengan sebuah contoh <br><br><div class="spoiler">  <b class="spoiler_title">Sebagai contoh</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/LOD&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgUtil/Simplifier&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; modelL2 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osgUtil::Simplifier simplifer; simplifer.setSampleRatio(0.5f); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(0.1f); modelL1-&gt;accept(simplifer); osg::ref_ptr&lt;osg::LOD&gt; root = new osg::LOD; root-&gt;addChild(modelL1.get(), 200.0f, FLT_MAX); root-&gt;addChild(modelL2.get(), 50.0f, 200.0f); root-&gt;addChild(modelL3.get(), 0.0f, 50.0f); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pertama, muat model <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Sekarang Anda perlu membuat beberapa model (kami akan membatasi diri untuk dua contoh), dengan tingkat detail yang lebih rendah.  Untuk melakukan ini, salin simpul yang dimuat dua kali, menggunakan teknik yang disebut salinan kelas "dalam", untuk simpul yang diimplementasikan oleh metode klon () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL));</code> </pre><br>  Sekarang kita mengurangi geometri model ini menggunakan kelas osgUtil :: Simplifer.  Tingkat penyederhanaan model ditentukan oleh metode setSampleRatio () dari kelas ini - semakin kecil parameter yang dilewati, semakin sedikit detail model setelah menerapkan prosedur reduksi. <br><br><pre> <code class="cpp hljs">osgUtil::Simplifier simplifer; simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>); modelL1-&gt;accept(simplifer);</code> </pre><br>  Ketika kami memiliki model tingkat detail yang berbeda, kami dapat mengisi daya ke simpul akar, dibuat sebagai penunjuk pintar ke osg :: LOD.  Untuk setiap level detail, atur jarak tampilan level ini <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; root-&gt;addChild(modelL1.get(), <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX); root-&gt;addChild(modelL2.get(), <span class="hljs-number"><span class="hljs-number">50.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>); root-&gt;addChild(modelL3.get(), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">50.0f</span></span>);</code> </pre><br>  Dengan FLT_MAX berarti dalam beberapa cara jarak "tak terbatas" ke pengamat.  Setelah memulai pemirsa, kami mendapatkan gambar berikut <br><br>  Tingkat Detail 3 <br><br><img src="https://habrastorage.org/webt/ww/d7/bq/wwd7bqrlttw9sgedue6m5xoxjgu.png"><br><br>  Tingkat Detail 2 <br><br><img src="https://habrastorage.org/webt/us/ku/h0/uskuh0x_zfchoklahjzoqjeq--c.png"><br><br>  Tingkat Detail 1 <br><br><img src="https://habrastorage.org/webt/lh/gi/ca/lhgica7l6z4dnl9w8yekiodyxn0.png"><br><br>  Dapat dilihat bahwa ketika kamera dipindahkan dari objek, detail geometri yang ditampilkan berkurang.  Dengan menggunakan teknik ini, Anda dapat mencapai realisme adegan yang tinggi dengan konsumsi sumber daya yang rendah. <br><br><h1>  2. Teknik pemuatan latar belakang untuk node adegan </h1><br>  Mesin OSG menyediakan kelas osg :: ProxyNode dan osg :: PagedLOD, yang dirancang untuk menyeimbangkan beban saat merender adegan.  Kedua kelas mewarisi dari osg :: Grup. <br><br>  Node osg :: Jenis ProxyNode mengurangi waktu peluncuran aplikasi sebelum rendering, jika adegan memiliki sejumlah besar model yang dimuat dan ditampilkan dari disk.  Ini berfungsi sebagai antarmuka ke file eksternal, memungkinkan pemuatan model yang ditangguhkan.  Untuk menambahkan node anak, gunakan metode setFileName () (bukan addChild) untuk mengatur nama file model pada disk dan memuatnya secara dinamis. <br><br>  Node osg :: PagedNode mewarisi metode osg :: LOD dan memuat dan membongkar level detail sedemikian rupa untuk menghindari kelebihan pipa OpenGL dan memastikan rendering adegan yang lancar. <br><br><h1>  3. Pemuatan dinamis (runtime) dari model </h1><br>  Mari kita lihat bagaimana proses memuat model menggunakan osg :: ProxyNode terjadi. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Proxynode</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ProxyNode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ProxyNode&gt; root = new osg::ProxyNode; root-&gt;setFileName(0, "../data/cow.osg"); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Proses pengunduhan di sini sedikit berbeda <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::ProxyNode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::ProxyNode; root-&gt;setFileName(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"../data/cow.osg"</span></span>);</code> </pre><br>  Alih-alih secara eksplisit memuat model sapi, kami menunjukkan simpul akar nama file tempat model dan indeks simpul anak berada, di mana model ini harus ditempatkan setelah dimuat.  Saat menjalankan program, kami mendapatkan hasil ini <br><br><img src="https://habrastorage.org/webt/4u/z_/yb/4uz_ybvtau_okn8gtbsyvesuqo8.png"><br><br>  Dapat dilihat bahwa sudut pandang tidak dipilih dengan cara terbaik - kamera bersandar langsung di sisi cermin sapi.  Ini terjadi karena model dimuat setelah memulai render dan menginisialisasi kamera, ketika node 0 belum terlihat.  Penampil tidak bisa menghitung parameter kamera yang diperlukan.  Namun, model telah dimuat dan kita dapat mengonfigurasi mode tampilan dengan memanipulasi mouse <br><br><img src="https://habrastorage.org/webt/kj/qp/hm/kjqphmpi5-thkedfpuqflwfywoa.png"><br><br>  Apa yang terjadi pada contoh di atas?  osg :: ProxyNode dan osg :: PagedLOD berfungsi dalam hal ini sebagai wadah.  Manajer data internal OSG akan mengirim permintaan dan memuat data ke dalam grafik adegan saat diperlukan untuk file model dan tingkat detail. <br><br>  Mekanisme ini bekerja di beberapa aliran latar belakang dan mengontrol pemuatan data statis yang terletak di file pada disk dan data dinamis yang dihasilkan dan ditambahkan selama eksekusi program. <br><br>  Mesin secara otomatis memproses node yang tidak ditampilkan di viewport saat ini dan menghapusnya dari grafik adegan ketika render kelebihan beban.  Namun, perilaku ini tidak mempengaruhi osg :: node ProxyNode. <br><br>  Seperti simpul proksi, kelas osg :: PagedLOD juga memiliki metode setFileName () untuk menentukan lintasan ke model yang dimuat, namun, Anda harus menetapkan rentang visibilitas untuk itu, seperti untuk simpul osg :: LOD.  Asalkan kita memiliki file cessna.osg dan model level-L1 yang rendah-poli, kita dapat mengatur paged node sebagai berikut <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; pagedLOD-&gt;addChild(modelL1, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX ); pagedLOD-&gt;setFileName( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span> ); pagedLOD-&gt;setRange( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span> );</code> </pre><br>  Anda perlu memahami bahwa simpul modelL1 tidak dapat diturunkan dari memori, karena ini adalah simpul non-proxy anak normal. <br><br>  Saat merender, perbedaan antara osg :: LOD dan osg :: PagedLOD tidak terlihat saat menggunakan hanya satu tingkat detail model.  Ide yang menarik adalah mengatur sekelompok besar model Cessna menggunakan kelas osg :: MatrixTransform.  Untuk ini, Anda dapat menggunakan misalnya fungsi seperti itu <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLODNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3&amp; pos )</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; ‚Ä¶ osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;setMatrix( osg::Matrix::translate(pos) ); mt-&gt;addChild( pagedLOD.get() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mt.release(); }</code> </pre><br>  Contoh program yang mengimplementasikan pemuatan latar belakang 10.000 pesawat <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PagedLOD&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLODNode(const std::string &amp;filepath, const osg::Vec3 &amp;pos) { osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = new osg::PagedLOD; pagedLOD-&gt;setFileName(0, filepath); pagedLOD-&gt;setRange(0, 0.0f, FLT_MAX); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;setMatrix(osg::Matrix::translate(pos)); mt-&gt;addChild(pagedLOD.get()); return mt.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; float dist = 50.0f; int N = 100; for (int i = 0; i &lt; N; ++i) { float x = i * dist; for (int j = 0; j &lt; N; ++j) { float y = j * dist; osg::Vec3 pos(x, y, 0.0f); osg::ref_ptr&lt;osg::Node&gt; node = createLODNode("../data/cessna.osg", pos); root-&gt;addChild(node.get()); } } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Diasumsikan bahwa pesawat akan ditempatkan di pesawat dengan interval 50 unit koordinat.  Saat memuat, kita akan melihat bahwa hanya cessna yang masuk ke dalam bingkai yang dimuat.  Pesawat-pesawat yang menghilang dari bingkai menghilang dari pohon adegan. <br><br><img src="https://habrastorage.org/webt/zx/cc/j4/zxccj4cjwh5a0ejfpl6mjudq8zi.png"><br><br><h1>  Kesimpulan </h1><br>  Pelajaran ini dalam seri OpenSceneGraph akan menjadi yang terakhir dalam format How To.  Dalam dua belas artikel, adalah mungkin untuk memenuhi prinsip-prinsip dasar bekerja dan menggunakan OpenSceneGraph dalam praktiknya.  Saya sangat berharap bahwa mesin ini menjadi lebih jelas bagi pengembang yang berbahasa Rusia. <br><br>  Ini tidak berarti bahwa saya menutup topik OpenSceneGraph pada sumber daya, sebaliknya, direncanakan untuk mencurahkan artikel masa depan untuk teknik yang lebih maju dan metode menggunakan OSG dalam pengembangan aplikasi grafis.  Tetapi untuk ini, Anda perlu mengumpulkan materi yang bagus dan memproses banyak sumber berbahasa Inggris, dan ini membutuhkan waktu. <br><br>  Tapi saya tidak mengucapkan selamat tinggal, terima kasih atas perhatian Anda dan sampai jumpa lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438454/">https://habr.com/ru/post/id438454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438438/index.html">Makanan untuk Bitrix Parrots. Kami menguji kinerja, pilih besi</a></li>
<li><a href="../id438442/index.html">Meneruskan permintaan dari Apache ke Payara Server 5 di Ubuntu</a></li>
<li><a href="../id438446/index.html">Benchmark sebagai dasar untuk memutuskan perubahan kode</a></li>
<li><a href="../id438448/index.html">Apa yang PC Speaker mampu lakukan</a></li>
<li><a href="../id438450/index.html">Mengapa templat kebijakan privasi tidak cocok untuk Anda?</a></li>
<li><a href="../id438456/index.html">Menyiapkan Sistem Masuk Tunggal di Zimbra Collaboration Suite</a></li>
<li><a href="../id438458/index.html">Konferensi DUMP 2019 akan diadakan pada 19 April. Kami mengundang Anda untuk berbicara di bagian Frontend, Backend, dan Science.</a></li>
<li><a href="../id438460/index.html">Serialisasi Tingkat Basis Data</a></li>
<li><a href="../id438462/index.html">Cara cepat untuk menambahkan pemberitahuan ke aplikasi Android</a></li>
<li><a href="../id438464/index.html">SciPy, algoritma grafik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>