<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❇️ 🏈 👩🏽‍💻 没有一个ORM 👩‍⚕️ 💡 ✉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="没有一个ORM 


 大家好！ 我负责Ostrovok.ru酒店预订服务的合作伙伴发展部。 在本文中，我想谈谈我们如何在一个项目上使用Django ORM 。 


 实际上，我在欺骗，这个名字应该是“  不可以  ORM single“。如果您想知道为什么我写这个，以及： 


- 您在堆栈上有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有一个ORM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/447706/"><h1 id="ne-ormom-edinym"> 没有一个ORM </h1><br><p> 大家好！ 我负责<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ostrovok.ru</a>酒店预订服务的合作伙伴发展部。 在本文中，我想谈谈我们如何在一个项目上使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Django ORM</a> 。 </p><br><p> 实际上，我在欺骗，这个名字应该是“ <del> 不可以 </del>  ORM single“。如果您想知道为什么我写这个，以及： </p><br><ul><li>您在堆栈上有Django，并且想要从ORM中挤出最大的<code>Model.objects.all()</code> ，而不仅仅是<code>Model.objects.all()</code> ， </li><li> 您想将部分业务逻辑转移到数据库级别， </li><li> 还是您想找出为什么B2B.Ostrovok.ru的开发人员最经常的借口是<em>“从历史</em>上讲<em>”</em> ， </li></ul><br><p>  ...欢迎猫。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="光盘"></p><a name="habracut"></a><br><p>  2014年，我们推出了B2B.Ostrovok.ru-在线预订服务，为旅游市场的专业人员（旅行代理商，运营商和公司客户）提供酒店，中转，汽车和其他旅行服务。 </p><br><p> 在B2B中，我们已经设计并成功使用了基于<code>MetaOrder</code> -meta order- <code>MetaOrder</code>的抽象订单模型。 </p><br><p> 元订单是一个抽象实体，无论它属于哪种类型的订单，都可以使用它：酒店（ <code>Hotel</code> ），附加服务（ <code>Upsell</code> ）或汽车（ <code>Car</code> ）。 将来可能会出现其他类型。 </p><br><p> 并非总是如此。 当B2B服务启动时，只能通过它预订酒店，所有业务逻辑都将重点放在这些酒店上。 例如，创建了许多字段来显示销售金额和预订退款金额的汇率。 随着时间的推移，我们意识到在给定元顺序的情况下如何最好地存储和重用此数据。 但是整个代码无法重写，并且部分遗产继承到了新架构中。 实际上，这导致了使用几种类型的订单进行计算的困难。 怎么做-从<em>历史上看</em> ... </p><br><p> 我的目标是在我们的示例中展示Django ORM的功能。 </p><br><h2 id="predystoriya"> 背景知识 </h2><br><p> 为了计划费用，我们的B2B客户确实缺乏有关现在/明天/以后需要支付多少，订单上是否有债务以及​​债务规模以及在限制范围内可以支出的数量等方面的信息。 我们决定以仪表板的形式显示此信息-这样的简单插座，带有清晰的图表。 </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="破折号1"><br>  <em>（所有值均为测试值，不适用于特定合作伙伴）</em> </p><br><p> 乍一看，一切都很简单-我们过滤了合作伙伴的所有订单，进行了汇总并显示。 </p><br><h2 id="varianty-resheniya"> 解决方案选项 </h2><br><p> 关于我们如何进行计算的一些解释。 我们是一家国际公司，来自不同国家/地区的合作伙伴以不同的货币进行经营-购买和转售预订。 此外，他们必须以所选货币（通常是本地货币）接收财务报表。 存储所有货币汇率的所有可能数据是愚蠢且不切实际的，因此您需要选择一种参考货币，例如卢布。 因此，您只能将所有货币的汇率存储到卢布。 因此，当合作伙伴想要接收摘要时，我们将按照销售时设定的汇率转换金额。 </p><br><h3 id="v-lob">  “在额头上” </h3><br><p> 实际上，这是<code>Model.objects.all()</code>并且条件循环： </p><br><div class="spoiler">  <b class="spoiler_title">带条件的Model.objects.all（）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p> 该查询将返回一个可能包含数百个预订的生成器。 将针对这些预订中的每个预订向数据库发出请求，因此该周期将持续很长时间。 </p><br><p> 您可以通过添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>prefetch_related</code></a>方法来加快速度： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p> 然后，对数据库的请求将略微减少（ <code>GenericForeignKey</code> ），但是最后，我们将停止它们的数目，因为对数据库的请求仍将在循环的每次迭代中进行。 </p><br><p> 可以（并且应该）缓存<code>output</code>方法，但是第一个调用仍然满足一分钟的顺序，这是完全不可接受的。 </p><br><p> 这是此方法的结果： </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="Timing_before"></p><br><p> 平均响应时间为4秒，峰值达到21秒。 相当长的时间。 </p><br><p> 我们没有为所有合作伙伴推出仪表板，因此我们对此没有太多要求，但足以理解这种方法是否有效。 </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>右下角的数字是查询数：最小值，最大值，平均值，总数。</em> </p><br><h3 id="s-umom"> 明智地 </h3><br><p> 前额原型可以很好地理解任务的复杂性，但使用起来并非最佳。 我们认为，向数据库中进行几个复杂的查询比许多简单的查询要快得多，所需资源也更少。 </p><br><h4 id="plan-zaprosa"> 申请方案 </h4><br><p> 查询计划的广泛笔触可以这样描述： </p><br><ul><li> 根据初始条件收集订单， </li><li> 通过<code>annotate</code>准备要计算的字段， </li><li> 计算字段值 </li><li> 按数量和数量<code>aggregate</code> </li></ul><br><h4 id="nachalnye-usloviya"> 初始条件 </h4><br><p> 访问该网站的合作伙伴只能在其合同上看到信息。 </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p> 如果我们不想显示新的订单/预订类型，我们只需要过滤支持的订单/预订： </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p> 订单状态很重要（有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Q</code></a>更多信息）： </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p> 例如，我们还经常使用预先准备好的请求，以排除所有无法付款的订单。 有很多业务逻辑，在本文的框架中对我们来说不是很有趣，但是从本质上讲，这些只是附加的过滤器。 返回准备好的查询的方法可能如下所示： </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p> 如您所见，这是一个类方法，该方法还将返回<code>QuerySet</code> 。 </p><br><p> 我们还将准备一些变量，用于条件构造和存储计算结果： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate"> 现场准备（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>annotate</code></a> ） </h4><br><p> 由于必须根据订单类型来引用字段，因此我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Coalesce</code></a> 。 因此，我们可以将任意数量的新型订单抽象到一个字段中。 </p><br><p> 这是<code>annotate</code>块的第一部分： </p><br><div class="spoiler">  <b class="spoiler_title">第一次注释</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code>在这里大放异彩，因为酒店订单具有几个特殊属性，在所有其他情况下（其他服务和汽车），这些属性对我们而言并不重要。 这就是<code>Value(ZERO)</code>和汇率<code>Value(ONE)</code>的显示方式。  <code>ZERO</code>和<code>ONE</code>均为常数形式的<code>Decimal('0')</code>和<code>Decimal(1)</code> 。 这是一种业余方法，但是在我们的项目中，这种方法是可以接受的。 </p><br><p> 您可能会有一个问题，为什么不将某些字段按元顺序放在一个级别上？ 例如， <code>payment_pending</code> ，到处都是。 的确，随着时间的流逝，我们将此类字段转换为元顺序，但是现在代码运行良好，因此此类任务不再是我们的优先事项。 </p><br><h4 id="esche-odna-podgotovka-i-raschety"> 另一个准备和计算 </h4><br><p> 现在，我们需要使用上一个<code>annotate</code>块中收到的金额进行一些计算。 请注意，这里您不再需要受定单类型的约束（一个例外除外）。 </p><br><div class="spoiler">  <b class="spoiler_title">第二注解</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p> 该区块最有趣的部分是<code>_reporting_currency_rate</code>字段，即出售时相对于参考货币的汇率。 有关酒店订单的所有货币对参考货币的汇率数据存储在<code>currency_data</code> 。 这只是JSON。 我们为什么要保留这个？  <em>历史上就是这种情况</em> 。 </p><br><p> 在这里看来，为什么不使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>F</code></a>替代合同货币的价值呢？ 也就是说，如果您可以这样做，那将很酷： </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p> 但是<code>f-strings</code>不支持<code>f-strings</code> <code>F</code> 尽管Django ORM已经可以访问嵌套的json字段，这一事实非常令人愉快<code>F('currency_data__USD')</code> 。 </p><br><p> 最后一个<code>annotate</code>块是<code>_payable_in_cur</code>计算，它将对所有订单进行汇总。 此值必须以合同货币表示。 </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  <code>annotate</code>方法的独特之处在于，它生成了很多不与请求直接相关的<code>SELECT something AS something_else</code>构造的<code>SELECT something AS something_else</code> 。 可以通过卸载SQL <code>query.__str__()</code>来看到。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a> Django ORM为<code>base_query_annotated</code>生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> SQL代码的<code>base_query_annotated</code> 。 您必须经常阅读它，以了解可以在哪里优化查询。 </p><br><h4 id="zaklyuchitelnye-podschety"> 最终计算 </h4><br><p> 将有一个小包装来封装<code>aggregate</code> ，以便将来如果合作伙伴需要其他指标，可以轻松添加。 </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p> 还有一件事-这是根据业务状况进行的最后过滤，例如，我们需要所有需要尽快支付的订单。 </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="破折号4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka"> 调试与验证 </h4><br><p> 验证所创建请求的正确性的一种非常方便的方法是将其与更易读的计算版本进行比较。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p> 您知道“额头”方法吗？ </p><br><h3 id="finalnyy-kod"> 最终代码 </h3><br><p> 结果，我们得到如下内容： </p><br><div class="spoiler">  <b class="spoiler_title">最终代码</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p> 现在是这样的： </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="Timing_after"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody"> 结论 </h2><br><p> 重写并优化逻辑之后，我们设法相当快地处理会员指标，并大大减少了对数据库的查询数量。 事实证明该解决方案很好，我们将在项目的其他部分重用此逻辑。  ORM是我们的一切。 </p><br><p> 发表评论，提出问题-我们将尽力回答！ 谢谢你 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447706/">https://habr.com/ru/post/zh-CN447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447696/index.html">为什么城市反对第一家非现金商店Amazon Go</a></li>
<li><a href="../zh-CN447698/index.html">红霍格沃茨：没有文凭的院士</a></li>
<li><a href="../zh-CN447700/index.html">情绪上的灵活性是个人成长的关键。</a></li>
<li><a href="../zh-CN447702/index.html">理想的数学圈不存在</a></li>
<li><a href="../zh-CN447704/index.html">爬Elbrus-侦察战。 技术部分1.寄存器，堆栈和其他技术细节</a></li>
<li><a href="../zh-CN447708/index.html">Yandex将首批以Ilya Segalovich命名的科学家授予年轻的科学家和主管</a></li>
<li><a href="../zh-CN447712/index.html">嗨，SaaS | Russian SaaS 2018-结果</a></li>
<li><a href="../zh-CN447714/index.html">论ARMA过程理论在工程实践中的应用</a></li>
<li><a href="../zh-CN447716/index.html">团结：在一口气中画出许多健康条</a></li>
<li><a href="../zh-CN447718/index.html">一切都会按计划进行</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>