<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤˜ ğŸ‘¨ğŸ½â€ğŸš€ ğŸ§–ğŸ¿ Prediksi fisika sisi klien dalam Unity ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ ğŸ» ğŸ™„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 Saya membuat demo yang menunjukkan bagaimana menerapkan prediksi sisi klien dari gerakan fisik pemain di Unity - GitHub . 

 Pendahuluan 
 Pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prediksi fisika sisi klien dalam Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="gambar"></div><br><h3>  TL; DR </h3><br>  Saya membuat demo yang menunjukkan bagaimana menerapkan prediksi sisi klien dari gerakan fisik pemain di Unity - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h3>  Pendahuluan </h3><br>  Pada awal 2012, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> tentang cara menerapkan peramalan di sisi klien dari gerakan fisik pemain di Unity.  Berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Physics.Simulate (),</a> solusi canggung yang saya jelaskan tidak lagi diperlukan.  Posting lama masih salah satu yang paling populer di blog saya, tetapi untuk Unity modern informasi ini sudah salah.  Karena itu, saya merilis versi 2018. <br><br><h3>  Apa yang ada di sisi klien? </h3><br>  Dalam permainan multipemain yang kompetitif, menyontek harus dihindari sedapat mungkin.  Biasanya ini berarti bahwa model jaringan dengan server otoriter digunakan: klien mengirim informasi yang dimasukkan ke server, dan server mengubah informasi ini menjadi gerakan pemain, dan kemudian mengirimkan potret status pemain ke klien.  Dalam hal ini, ada penundaan antara menekan tombol dan menampilkan hasilnya, yang tidak dapat diterima untuk setiap game yang aktif.  Prediksi di sisi klien adalah teknik yang sangat populer yang menyembunyikan penundaan, memprediksi apa yang akan terjadi dan segera menunjukkannya kepada pemain.  Ketika klien menerima hasil dari server, ia membandingkannya dengan apa yang diprediksi klien, dan jika mereka berbeda, maka ramalan itu salah dan perlu diperbaiki. <br><a name="habracut"></a><br>  Snapshots yang diterima dari server selalu berasal dari masa lalu sehubungan dengan keadaan klien yang diprediksi (misalnya, jika mentransfer data dari klien ke server dan kembali membutuhkan 150 ms, maka setiap snapshot akan ditunda setidaknya 150 ms).  Sebagai akibatnya, ketika klien perlu memperbaiki ramalan yang salah, ia harus memutar kembali ke titik ini di masa lalu, dan kemudian mereproduksi semua informasi yang dimasukkan dalam celah untuk kembali ke tempatnya.  Jika gerakan pemain dalam permainan didasarkan pada fisika, maka Physics.Simulate () diperlukan untuk mensimulasikan beberapa siklus dalam satu frame.  Jika hanya Pengontrol Karakter (atau pemain kapsul, dll.) Yang digunakan saat menggerakkan pemain, maka Anda dapat melakukannya tanpa Fisika. Rangsang () - dan saya berasumsi bahwa kinerjanya akan lebih baik. <br><br>  Saya akan menggunakan Unity untuk membuat ulang demo jaringan yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Zen Fisika Jaringan dari</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Glenn Fiedler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,"</a> yang telah lama saya nikmati.  Pemain memiliki kubus fisik di mana ia dapat mengerahkan kekuatan, mendorongnya dalam adegan.  Demo ini mensimulasikan berbagai kondisi jaringan, termasuk penundaan dan kehilangan paket. <br><br><h3>  Mulai bekerja </h3><br>  Hal pertama yang harus dilakukan adalah mematikan simulasi fisika otomatis.  Meskipun Physics.Simulate () memungkinkan kita memberi tahu sistem fisik kapan harus memulai simulasi, secara default ia melakukan simulasi secara otomatis berdasarkan delta waktu proyek yang tetap.  Oleh karena itu, kita akan menonaktifkannya di <strong>Edit-&gt; Pengaturan Proyek-&gt; Fisika</strong> , hapus centang pada kotak " <strong>Simulasi Otomatis</strong> ". <br><br>  Untuk memulai, kami akan membuat implementasi pengguna tunggal yang sederhana.  Input diambil sampelnya (w, a, s, d untuk bergerak dan ruang untuk melompat), dan semuanya bermuara pada kekuatan sederhana yang diterapkan pada Rigidbody menggunakan AddForce (). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Pemain bergerak saat jaringan tidak digunakan</i> <br><br><h3>  Mengirim input ke server </h3><br>  Sekarang kita perlu mengirim input ke server, yang juga akan mengeksekusi kode gerak ini, membuat snapshot keadaan kubus dan mengirimkannya kembali ke klien. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Tidak ada yang istimewa di sini sejauh ini, satu-satunya hal yang ingin saya perhatikan adalah menambahkan variabel tick_number.  Hal ini diperlukan agar ketika server mengirim snapshot dari keadaan kubus kembali ke klien, kita dapat mengetahui kebijaksanaan klien yang sesuai dengan keadaan ini, sehingga kita dapat membandingkan keadaan ini dengan klien yang diprediksi (yang akan kita tambahkan sedikit kemudian). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Semuanya sederhana - server menunggu pesan input, ketika menerimanya, ini mensimulasikan siklus jam.  Kemudian dia mengambil snapshot dari keadaan kubus yang dihasilkan dan mengirimkannya kembali ke klien.  Anda mungkin memperhatikan bahwa tick_number dalam pesan status lebih besar daripada tick_number dalam pesan input.  Ini dilakukan karena secara pribadi secara intuitif lebih nyaman bagi saya untuk memikirkan "keadaan pemain dalam kebijaksanaan 100" sebagai "keadaan pemain pada <strong>awal</strong> kebijaksanaan 100".  Oleh karena itu, keadaan pemain dalam ukuran 100 dalam kombinasi dengan input pemain dalam ukuran 100 menciptakan keadaan baru bagi pemain dalam ukuran 101. <br><br><h1>  Status <sub>n</sub> + Input <sub>n</sub> = Status <sub>n + 1</sub> </h1><br>  Saya tidak mengatakan bahwa Anda harus mengambilnya dengan cara yang sama, yang utama adalah keteguhan pendekatan. <br><br>  Harus juga dikatakan bahwa saya tidak <em>mengirim</em> pesan-pesan ini melalui soket nyata, tetapi meniru dengan menulisnya ke antrian, mensimulasikan penundaan dan kehilangan paket.  Adegan ini berisi dua kubus fisik - satu untuk klien, yang lain untuk server.  Saat memperbarui kubus klien, saya menonaktifkan GameObject dari kubus server, dan sebaliknya. <br><br>  Namun, saya tidak mensimulasikan bouncing jaringan dan pengiriman paket dalam urutan yang salah, itulah sebabnya saya membuat asumsi bahwa setiap pesan input yang diterima lebih baru daripada yang sebelumnya.  Peniruan ini diperlukan untuk menjalankan "klien" dan "server" dengan sangat sederhana dalam satu contoh Unity, sehingga kami dapat menggabungkan server dan kubus klien dalam satu adegan. <br><br>  Anda juga dapat memperhatikan bahwa jika pesan input dibuang dan tidak mencapai server, maka server mensimulasikan lebih sedikit siklus clock daripada klien, dan karenanya akan menciptakan keadaan yang berbeda.  Ini benar, tetapi bahkan jika kami mensimulasikan kelalaian ini, inputnya masih bisa salah, yang juga akan menyebabkan keadaan yang berbeda.  Kami akan menangani masalah ini nanti. <br><br>  Juga harus ditambahkan bahwa dalam contoh ini hanya ada satu klien, yang menyederhanakan pekerjaan.  Jika kami memiliki beberapa klien, maka kami akan memerlukan a) saat memanggil Fisika. Mensimulasi () untuk memverifikasi bahwa hanya satu kubus pemain yang diaktifkan di server, atau b) jika server menerima input dari beberapa kubus, simulasikan semuanya bersama-sama. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Tunda 75 ms (150 ms pulang pergi)</i> <i><br></i>  <i>0% paket hilang</i> <i><br></i>  <i>Kubus kuning - pemain server</i> <i><br></i>  <i>Kubus biru - foto terakhir yang diterima oleh klien</i> <br><br>  Semuanya terlihat baik sejauh ini, tetapi saya sedikit selektif dengan apa yang saya rekam di video untuk menyembunyikan masalah yang agak serius. <br><br><h3>  Kegagalan Penentuan </h3><br>  Lihatlah sekarang ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Aduh ...</i> <br><br>  Video ini direkam tanpa kehilangan paket, namun simulasi masih bervariasi dengan input yang sama persis.  Saya tidak begitu mengerti mengapa ini terjadi - PhysX harus cukup deterministik, jadi saya merasa mengejutkan bahwa simulasi sering kali berbeda.  Ini mungkin karena fakta bahwa saya terus-menerus mengaktifkan dan menonaktifkan kubus GameObject, yaitu, ada kemungkinan bahwa masalahnya akan berkurang ketika menggunakan dua contoh Unity yang berbeda.  Ini bisa menjadi bug, jika Anda melihatnya di kode di GitHub, maka beri tahu saya. <br><br>  Namun demikian, perkiraan yang salah adalah fakta penting dalam memperkirakan di sisi klien, jadi mari kita hadapi mereka. <br><br><h3>  Bisakah saya mundur? </h3><br>  Prosesnya cukup sederhana - ketika klien memprediksi pergerakan, dia menyimpan buffer status (posisi dan rotasi) dan input.  Setelah menerima pesan status dari server, ia membandingkan keadaan yang diterima dengan keadaan yang diprediksi dari buffer.  Jika mereka berbeda dengan nilai yang terlalu besar, maka kami mendefinisikan kembali keadaan kubus klien di masa lalu, dan kemudian mensimulasikan lagi semua langkah menengah. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Input dan status data yang disangga disimpan dalam buffer melingkar yang sangat sederhana, di mana pengidentifikasi ukuran digunakan sebagai indeks.  Dan saya memilih nilai 64 Hz untuk frekuensi clock fisika, yaitu, buffer 1024 elemen memberi kita ruang selama 16 detik, dan ini jauh lebih dari yang kita butuhkan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Koreksi aktif!</i> <br><br><h3>  Transfer Input Redundan </h3><br>  Pesan input biasanya sangat kecil - tombol yang ditekan dapat digabungkan menjadi bidang bit yang hanya membutuhkan beberapa byte.  Masih ada nomor pengukur dalam pesan kami, yang menempati 4 byte, tetapi kita dapat dengan mudah mengompresnya menggunakan nilai 8-bit dengan carry (mungkin interval 0-255 akan terlalu kecil, kita bisa aman dan meningkatkannya menjadi 9 atau 10 bit).  Bagaimanapun, pesan-pesan ini cukup kecil, dan ini berarti bahwa kami dapat mengirim banyak data input di setiap pesan (jika data input sebelumnya hilang).  Seberapa jauh ke belakang kita harus kembali?  Nah, klien tahu nomor ukuran pesan status terakhir yang ia terima dari server, jadi tidak masuk akal untuk kembali lebih jauh dari ukuran ini.  Kita juga perlu memberlakukan batasan pada jumlah data input redundan yang dikirim oleh klien.  Saya tidak melakukan ini dalam demo saya, tetapi harus diimplementasikan dalam kode yang sudah selesai. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Ini adalah perubahan sederhana, klien hanya menulis nomor ukuran pesan status yang terakhir diterima. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  Pesan input yang dikirim oleh klien sekarang berisi daftar data input, bukan hanya satu item.  Bagian dengan nomor pengukur mendapat nilai baru - sekarang ini adalah nomor pengukur input pertama dalam daftar ini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Ketika server menerima pesan input, ia mengetahui jumlah pengukuran input pertama dan jumlah data input dalam pesan.  Oleh karena itu, dapat menghitung ukuran input terakhir dalam pesan.  Jika ukuran terakhir ini lebih besar dari atau sama dengan nomor ukuran server, maka ia tahu bahwa pesan tersebut mengandung setidaknya satu input yang belum dilihat server.  Jika demikian, maka ini mensimulasikan semua data input baru. <br><br>  Anda mungkin telah memperhatikan bahwa <em>jika</em> kami membatasi jumlah input data yang berlebihan dalam pesan input, maka dengan sejumlah besar pesan input yang hilang, kami akan memiliki celah simulasi antara server dan klien.  Artinya, server dapat mensimulasikan ukuran 100, mengirim pesan status untuk mulai mengukur 101, dan kemudian menerima pesan input mulai dari ukuran 105. Dalam kode di atas, server akan pergi ke 105, itu tidak akan mencoba mensimulasikan langkah-langkah antara berdasarkan pada data input terbaru yang diketahui.  Apakah Anda membutuhkannya tergantung pada keputusan Anda dan seperti apa permainannya.  Secara pribadi, saya tidak akan memaksa server untuk berspekulasi dan memindahkan pemain pada peta karena kondisi jaringan yang buruk.  Saya percaya bahwa lebih baik membiarkan pemain di tempatnya sampai koneksi pulih. <br><br>  Dalam demo "Zen dari Fisika Jaringan" ada fungsi untuk mengirim "gerakan penting" oleh klien, yaitu, ia mengirim data input yang berlebihan hanya jika berbeda dari input yang dikirimkan sebelumnya.  Ini bisa disebut kompresi input delta, dan dengan itu Anda dapat mengurangi ukuran pesan input.  Namun sejauh ini saya belum melakukannya, karena dalam demo ini tidak ada optimasi pemuatan jaringan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Sebelum mengirim data input yang berlebihan: ketika 25% paket hilang, gerakan kubus lambat dan berkedut, itu terus dibuang kembali.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Setelah mengirim data input yang berlebihan: dengan kehilangan 25% dari paket, masih ada koreksi berkedut, tetapi kubus bergerak dengan kecepatan yang dapat diterima.</i> <br><br><h3>  Frekuensi Snapshot Variabel </h3><br>  Dalam demo ini, frekuensi server mengirim foto ke klien bervariasi.  Dengan frekuensi yang berkurang, klien akan membutuhkan lebih banyak waktu untuk menerima koreksi dari server.  Oleh karena itu, ketika klien keliru dalam ramalan, maka sebelum menerima pesan status dia mungkin menyimpang lebih banyak, yang akan mengarah pada koreksi yang lebih nyata.  Dengan snapshot frekuensi tinggi, packet loss jauh kurang penting, sehingga klien tidak perlu menunggu lama untuk menerima snapshot berikutnya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frekuensi snapshot 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frekuensi snapshot 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frekuensi snapshot 2 Hz</i> <br><br>  Jelas, semakin tinggi frekuensi foto, semakin baik, jadi Anda harus mengirimnya sesering mungkin.  Tetapi itu juga tergantung pada jumlah traffic tambahan, biayanya, ketersediaan dedicated server, biaya komputasi server, dan sebagainya. <br><br><h3>  Koreksi perataan </h3><br>  Kami membuat ramalan yang salah dan mendapatkan koreksi tersentak lebih sering dari yang kita inginkan.  Tanpa akses yang tepat ke integrasi Unity / PhysX, saya hampir tidak bisa men-debug ramalan yang keliru ini.  Saya telah mengatakan ini sebelumnya, tetapi saya ulangi sekali lagi - jika Anda menemukan sesuatu yang berhubungan dengan fisika, yang salah saya, maka beri tahu saya tentang itu. <br><br>  Saya menghindari solusi untuk masalah ini dengan mengolesi retakan dengan smoothing lama yang baik!  Ketika koreksi terjadi, klien cukup menghaluskan posisi dan rotasi pemain ke arah kondisi yang benar untuk beberapa frame.  Kubus fisik itu sendiri dikoreksi secara instan (tidak terlihat), tetapi kami memiliki kubus kedua untuk tampilan saja, yang memungkinkan perataan. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Ketika perkiraan yang salah terjadi, klien melacak perbedaan posisi / rotasi setelah koreksi.  Jika jarak total koreksi posisi lebih dari 2 meter, maka kubus hanya bergerak dalam sentakan - smoothing masih akan terlihat buruk, jadi biarkan setidaknya kembali ke keadaan yang benar secepat mungkin. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  Dalam setiap frame, klien melakukan lerp / slerp menuju posisi / rotasi yang benar sebesar 10%, ini adalah pendekatan hukum-kekuatan standar untuk pergerakan rata-rata.  Itu tergantung pada frame rate, tetapi untuk keperluan demo kami ini sudah cukup. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Penundaan 250 ms</i> <i><br></i>  <i>Kehilangan 10% paket</i> <i><br></i>  <i>Tanpa smoothing, koreksi sangat terlihat</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Penundaan 250 ms</i> <i><br></i>  <i>Kehilangan 10% paket</i> <i><br></i>  <i>Dengan smoothing, koreksi jauh lebih sulit untuk diperhatikan.</i> <br><br>  Hasil akhirnya bekerja dengan sangat baik, saya ingin membuat versi yang benar-benar mengirim paket, daripada meniru mereka.  Tetapi setidaknya ini adalah bukti konsep untuk sistem perkiraan sisi klien dengan objek fisik nyata di Unity tanpa perlu plug-in fisik dan sejenisnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432190/">https://habr.com/ru/post/id432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432180/index.html">Cara memompa karir Anda melalui GitHub</a></li>
<li><a href="../id432182/index.html">Kami mengambil surat tanpa sms dan registrasi</a></li>
<li><a href="../id432184/index.html">Identitas Masalah Di Antara Penguji</a></li>
<li><a href="../id432186/index.html">Menggunakan STP untuk membuat saluran p2p</a></li>
<li><a href="../id432188/index.html">Peretas APT28 menyerang kotak email ratusan pegawai kementerian Ceko</a></li>
<li><a href="../id432192/index.html">4 tanda bahwa Anda belum siap untuk mengimplementasikan solusi manajemen proyek</a></li>
<li><a href="../id432196/index.html">Tentang komposisi fungsi dalam JavaScript</a></li>
<li><a href="../id432198/index.html">Delivery Manager - Peran Baru di Dunia Agile</a></li>
<li><a href="../id432200/index.html">Bagaimana Ivan menyelidiki konversi tegakan</a></li>
<li><a href="../id432202/index.html">Menghasilkan jenis karakter dengan cepat (atau gila dengan Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>