<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 ♟️ 👩🏻‍💼 Inovasi literal objek dalam JavaScript ES6 🚇 🎅🏼 📌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahan, terjemahan yang kami sajikan untuk perhatian Anda, dikhususkan untuk mempelajari fitur literal objek dalam JavaScript, khususnya, inovasi yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inovasi literal objek dalam JavaScript ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414377/">  Bahan, terjemahan yang kami sajikan untuk perhatian Anda, dikhususkan untuk mempelajari fitur literal objek dalam JavaScript, khususnya, inovasi yang muncul dalam versi terbaru dari standar ECMAScript. <br><br>  JavaScript memiliki kemampuan yang kuat dan nyaman untuk membuat objek menggunakan literal objek.  Standar ES2015 (ES6) menyederhanakan bekerja dengan objek ketika membuat aplikasi untuk browser modern (kecuali IE) dan untuk platform Node.js. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/z0/iq/f2/z0iqf21z0nrwpezfudp6vjkmfvc.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Dasar-dasarnya</font> </h2><br>  Membuat objek dalam beberapa bahasa dapat menjadi sumber daya yang intensif, yang kami maksudkan adalah waktu kerja programmer dan sumber daya komputasi sistem.  Secara khusus, kita berbicara tentang fakta bahwa sebelum Anda membuat objek, Anda harus menggambarkan kelas (katakanlah, menggunakan kata kunci <code>class</code> ).  Dalam JavaScript, objek dapat dibuat dengan sangat cepat dan sederhana, tanpa perlu langkah awal.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs lua">// ES5 var myObject = { prop1: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, prop2: <span class="hljs-string"><span class="hljs-string">'world'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(this.prop1 + <span class="hljs-string"><span class="hljs-string">' '</span></span> + this.prop2); } }; myObject.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>(); // hello world</code> </pre> <br>  Dalam pemrograman, objek "sekali pakai" sering digunakan.  Mereka menyimpan pengaturan dan data lainnya, mereka digunakan sebagai parameter fungsi, sebagai nilai yang dikembalikan oleh fungsi, dan dalam situasi lain.  Literal objek JavaScript dalam kasus seperti itu ternyata sangat berguna, dan ES6 memperluas kemampuannya. <br><br><h2>  <font color="#3AC1EF">Inisialisasi objek dari variabel</font> </h2><br>  Properti objek sering dibuat dari variabel dengan menugaskan mereka nama yang sama yang sudah ditugaskan ke variabel-variabel ini.  Sebagai contoh: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES5 var a = 1, b = 2, c = 3; obj = {   a: a,   b: b,   c: c }; // obj.a = 1, obj.b = 2, obj.c = 3</span></span></code> </pre> <br>  Di ES6, Anda tidak perlu lagi mengulang nama variabel: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES6 const a = 1, b = 2, c = 3; obj = {   a,   b,   c }; // obj.a = 1, obj.b = 2, obj.c = 3</span></span></code> </pre> <br>  Teknik ini mungkin berguna untuk objek yang dikembalikan saat menggunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Revealing Module</a> , yang memungkinkan Anda membuat ruang nama untuk berbagai fragmen kode untuk menghindari konflik nama.  Sebagai contoh: <br><br><pre> <code class="hljs lua">// ES6 const lib = (() =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span>  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   sum,   mult }; }()); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Anda mungkin telah melihat bagaimana teknik ini digunakan dalam modul ES6: <br><br><pre> <code class="hljs powershell">// lib.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span>  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } export { sum, mult };</code> </pre> <br><h2>  <font color="#3AC1EF">Sintaks singkatan untuk mendeklarasikan metode objek</font> </h2><br>  Saat mendeklarasikan metode objek di ES5, Anda harus menggunakan kata kunci <code>function</code> : <br><br><pre> <code class="hljs lua">// ES5 var lib = { sum:  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }, mult: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } }; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Sekarang, di ES6, Anda tidak bisa lagi melakukan ini.  Cara singkat untuk mendeklarasikan metode diperbolehkan di sini: <br><br><pre> <code class="hljs pgsql">// ES6 const lib = { sum(a, b)  { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }, mult(a, b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } }; console.log( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  // <span class="hljs-number"><span class="hljs-number">5</span></span> console.log( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); // <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Perlu dicatat bahwa fungsi panah ES6 ( <code>=&gt;</code> ) tidak dapat digunakan di sini, karena metode harus memiliki nama.  Namun, fungsi panah dapat digunakan jika Anda secara eksplisit menetapkan nama untuk metode (seperti pada ES5).  Sebagai contoh: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ES6 const lib = { sum:  <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> =&gt;</span></span> a + b, mult: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> =&gt;</span></span> a * b }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( lib.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) );  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( lib.mult(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Kunci dinamis</font> </h2><br>  Di ES5, Anda tidak bisa menggunakan variabel sebagai nama kunci, meskipun kunci yang namanya diberikan ke variabel bisa ditambahkan setelah membuat objek.  Sebagai contoh: <br><br><pre> <code class="hljs powershell">// ES5 var key1 = <span class="hljs-string"><span class="hljs-string">'one'</span></span>, obj = {   two: <span class="hljs-number"><span class="hljs-number">2</span></span>,   three: <span class="hljs-number"><span class="hljs-number">3</span></span> }; obj[<span class="hljs-type"><span class="hljs-type">key1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; // obj.one = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj.two = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj.three = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Di ES6, kunci dapat ditetapkan secara dinamis dengan menempatkan ekspresi nama dalam tanda kurung ( <code>[]</code> ).  Sebagai contoh: <br><br><pre> <code class="hljs powershell">// ES6 const key1 = <span class="hljs-string"><span class="hljs-string">'one'</span></span>, obj = {   [<span class="hljs-type"><span class="hljs-type">key1</span></span>]: <span class="hljs-number"><span class="hljs-number">1</span></span>,   two: <span class="hljs-number"><span class="hljs-number">2</span></span>,   three: <span class="hljs-number"><span class="hljs-number">3</span></span> }; // obj.one = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj.two = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj.three = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Untuk membuat kunci, Anda dapat menggunakan ekspresi apa pun: <br><br><pre> <code class="hljs powershell">// ES6 const i = <span class="hljs-number"><span class="hljs-number">1</span></span>, obj = {   [<span class="hljs-string"><span class="hljs-string">'i'</span></span> + <span class="hljs-type"><span class="hljs-type">i</span></span>]: i }; console.log(obj.i1); // <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Kunci dinamis dapat digunakan untuk metode dan properti: <br><br><pre> <code class="hljs powershell">// ES6 const i = <span class="hljs-number"><span class="hljs-number">2</span></span>, obj = {   [<span class="hljs-string"><span class="hljs-string">'mult'</span></span> + <span class="hljs-type"><span class="hljs-type">i</span></span>]: x =&gt; x * i }; console.log( obj.mult2(<span class="hljs-number"><span class="hljs-number">5</span></span>) ); // <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Pertanyaan lain adalah apakah membuat properti dan metode dengan nama yang dihasilkan secara dinamis.  Keterbacaan kode yang menggunakan teknik ini dapat terdegradasi.  Mungkin jika Anda dihadapkan pada situasi di mana nama dinamis tampak sesuai, akan lebih baik untuk berpikir tentang menggunakan fungsi pabrik atau kelas untuk membuat objek. <br><br><h2>  <font color="#3AC1EF">Restrukturisasi</font> </h2><br>  Destrukturisasi adalah ekstraksi properti objek dan penugasannya ke variabel.  Seringkali selama pengembangan aplikasi, Anda perlu mengekstraksi nilai properti objek dan menulisnya ke variabel.  Di ES5, Anda harus menggambarkan ini sebagai berikut, menggunakan perintah akses properti: <br><br><pre> <code class="hljs pgsql">// ES5 var myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; var one   = myObject.one, // <span class="hljs-string"><span class="hljs-string">'a'</span></span> two   = myObject.two, // <span class="hljs-string"><span class="hljs-string">'b'</span></span> three = myObject.three; // <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  ES6 mendukung perusakan.  Anda bisa membuat variabel dengan nama yang sama yang menanggung properti objek yang sesuai dan melakukan hal berikut: <br><br><pre> <code class="hljs julia">// ES6 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { one, two, three } = myObject; // one = <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two = <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three = <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  Variabel yang mendapatkan nilai properti objek sebenarnya dapat memiliki nama apa pun, tetapi jika mereka berbeda dari nama properti, Anda harus menggunakan <code>{ propertyName: newVariable }</code> : <br><br><pre> <code class="hljs julia">// ES6 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = { one:   <span class="hljs-string"><span class="hljs-string">'a'</span></span>, two:   <span class="hljs-string"><span class="hljs-string">'b'</span></span>, three: <span class="hljs-string"><span class="hljs-string">'c'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { one: first, two: second, three: third } = myObject; // first = <span class="hljs-string"><span class="hljs-string">'a'</span></span>, second = <span class="hljs-string"><span class="hljs-string">'b'</span></span>, third = <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  Objek dengan struktur kompleks, di mana array dan objek lainnya tertanam, juga dapat digunakan dalam operasi penugasan destruktif: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ES6 const meta = { title: 'Enhanced Object Literals', pageinfo: {   url: 'https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/www.sitepoint.com/</span></span><span class="hljs-string"><span class="hljs-string">',   description: '</span></span>How to use object literals <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ES2015 (ES6).<span class="hljs-string"><span class="hljs-string">',   keywords: '</span></span>javascript, object, literal<span class="hljs-string"><span class="hljs-string">' } }; const { title   : doc, pageinfo: { keywords: topic } } = meta; /* doc   = '</span></span>Enhanced Object Literals<span class="hljs-string"><span class="hljs-string">' topic = '</span></span>javascript, object, literal<span class="hljs-string"><span class="hljs-string">' */</span></span></code> </pre> <br>  Pada awalnya, semua ini mungkin tampak rumit, namun, tidak begitu sulit untuk mengetahuinya, hal utama adalah mengingat yang berikut: <br><br><ul><li>  Sisi kanan ekspresi adalah sumber data - larik atau objek yang menyimpan data yang akan diambil. </li><li>  Sisi kiri ekspresi adalah tujuan dari tugas destruktif - struktur yang menggambarkan variabel yang akan diberi nilai yang diekstraksi dari array atau objek. </li></ul><br>  Saat menggunakan perusakan, Anda mungkin menemui beberapa kesulitan.  Jadi, sebuah ekspresi tidak dapat dimulai dengan penjepit keriting, karena kemudian akan terlihat seperti blok kode.  Sebagai contoh: <br><br><pre> <code class="hljs swift">{ a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> } = myObject; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Desain ini biasanya diterima oleh sistem ketika mendeklarasikan variabel: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">{ a, b, c }</span></span> = myObject; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Jika variabel sudah dideklarasikan, Anda harus menyertakan ekspresi dalam tanda kurung: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>; ({ a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> } = myObject); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Akibatnya, ketika berhadapan dengan penghancuran, Anda harus berhati-hati tentang kode dan tidak mencampur variabel yang dideklarasikan dan tidak dideklarasikan. <br><br>  Destrukturisasi adalah teknik yang berguna dalam banyak situasi. <br><br><h2>  <font color="#3AC1EF">Parameter Fungsi Default</font> </h2><br>  Jika suatu fungsi membutuhkan daftar argumen yang panjang, biasanya lebih mudah memberikannya objek tunggal dengan parameter.  Sebagai contoh: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">prettyPrint</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Enhanced Object Literals'</span></span>, publisher: {   name: <span class="hljs-string"><span class="hljs-string">'SitePoint'</span></span>,   url: <span class="hljs-string"><span class="hljs-string">'https://www.sitepoint.com/'</span></span> } } );</code> </pre> <br>  Dalam ES5, perlu mem-parsing objek dengan parameter untuk, jika objek ini tidak memiliki apa yang mereka butuhkan, tetapkan nilai default ke parameter yang sesuai: <br><br><pre> <code class="hljs powershell">// ES5,     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> || {}; var   pubTitle = param.title || <span class="hljs-string"><span class="hljs-string">'No title'</span></span>,   pubName = (param.publisher &amp;&amp; param.publisher.name) || <span class="hljs-string"><span class="hljs-string">'No publisher'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pubTitle + <span class="hljs-string"><span class="hljs-string">', '</span></span> + pubName; }</code> </pre> <br>  Dalam ES6, parameter apa pun dapat ditetapkan nilai default: <br><br><pre> <code class="hljs powershell">// ES6 -     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param = {})</span></span></span></span> { ... }</code> </pre> <br>  Kemudian Anda bisa menggunakan destrrukturisasi untuk mengekstraksi nilai dari objek, dan, jika perlu, untuk menetapkan nilai default: <br><br><pre> <code class="hljs powershell">// ES6     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( {   title: pubTitle = 'No title',   publisher: { name: pubName = 'No publisher' } } = {} )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `${pubTitle}, <span class="hljs-variable"><span class="hljs-variable">$</span></span>{pubName}`; }</code> </pre> <br>  Perlu dicatat bahwa kode seperti itu mungkin lebih sulit dibaca daripada yang lebih tradisional, meskipun ini adalah masalah preferensi pribadi programmer. <br><br><h2>  <font color="#3AC1EF">Parsing objek dikembalikan oleh fungsi</font> </h2><br>  Fungsi dapat mengembalikan hanya satu nilai, tetapi nilai ini bisa menjadi objek dengan ratusan properti atau metode.  Di ES5, Anda harus terlebih dahulu mendapatkan objek yang dikembalikan, dan setelah itu Anda bisa mengekstrak nilai dari itu: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES5 var obj = getObject(), one = obj.one, two = obj.two, three = obj.three;</span></span></code> </pre> <br>  Restrukturisasi menyederhanakan proses ini.  Sekarang semua ini dapat dilakukan tanpa harus menyimpan objek dalam variabel yang terpisah dan kemudian menguraikannya: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ES6 const { one, two, three } = getObject();</span></span></code> </pre> <br>  Anda mungkin telah melihat sesuatu yang serupa di Node.js.  Misalnya, jika Anda hanya memerlukan metode <code>writeFile()</code> dan <code>writeFile()</code> pada modul <code>fs</code> , Anda bisa mendapatkan tautan ke sana seperti ini: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ES6 Node.js const { readFile, writeFile } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); readFile(<span class="hljs-string"><span class="hljs-string">'file.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err || data); }); writeFile(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'new content'</span></span>, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err || <span class="hljs-string"><span class="hljs-string">'file written'</span></span>); });</code> </pre> <br><h2>  <font color="#3AC1EF">Sintaks parameter yang tersisa dan operator ekstensi ES2018 (ES9)</font> </h2><br>  = Dalam ES2015, sintaks dari parameter yang tersisa dan operator ekstensi (keduanya terlihat seperti tiga titik, <code>…</code> ) digunakan hanya ketika bekerja dengan array.  Dalam ES2018, fungsionalitas serupa dapat digunakan untuk bekerja dengan objek: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = <span class="hljs-comment"><span class="hljs-comment">{ a: 1, b: 2, c: 3 }</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">{ a, ...x }</span></span> = myObject; <span class="hljs-comment"><span class="hljs-comment">// a = 1 // x = { b: 2, c: 3 }</span></span></code> </pre> <br>  Pendekatan serupa dapat digunakan untuk mentransfer nilai-nilai tertentu ke suatu fungsi: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ a, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...x</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// a = 1 // x = { b: 2, c: 3 } } restParam({ a: 1, b: 2, c: 3 });</span></span></code> </pre> <br>  Harap perhatikan bahwa dalam situasi seperti itu, Anda hanya dapat menggunakan satu ekspresi dengan tiga titik di akhir daftar.  Selain itu, untuk objek yang bersarang di objek lain, ini tidak berfungsi. <br><br>  Operator ekstensi dapat digunakan di dalam objek: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = <span class="hljs-comment"><span class="hljs-comment">{ a: 1, b: 2, c: 3 }</span></span>, obj2 = <span class="hljs-comment"><span class="hljs-comment">{ ...obj1, z: 26 }</span></span>; <span class="hljs-comment"><span class="hljs-comment">// obj2 is { a: 1, b: 2, c: 3, z: 26 }</span></span></code> </pre> <br>  Operator ekstensi dapat digunakan untuk mengkloning objek ( <code>obj2 = { ...obj1 };</code> ), tetapi di sini harus diingat bahwa dengan pendekatan ini, salinan objek yang dangkal dilakukan.  Jika properti objek adalah objek lain, klon objek akan merujuk ke objek bersarang yang sama. <br><br>  Sintaks parameter yang tersisa dan operator ekstensi belum didukung secara luas.  Saat ini, mereka dapat digunakan di browser Chrome dan Firefox tanpa upaya tambahan, dan ketika mengembangkan untuk platform Node.js versi 8.6 dan lebih tinggi. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Literal objek selalu menjadi fitur JavaScript yang berguna.  Inovasi yang muncul dalam JavaScript sejak standar ES2015 tidak membawa perubahan mendasar, tetapi mereka menghemat waktu programmer dan membantu menulis kode yang lebih bersih dan ringkas. <br><br>  <b>Pembaca yang budiman!</b>  Apa metode membuat objek JS yang paling sering Anda gunakan? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414377/">https://habr.com/ru/post/id414377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414367/index.html">Berderap dalam tiga tahun: apa yang menarik untuk dibaca kembali di blog HashFlare</a></li>
<li><a href="../id414369/index.html">Print Server Windows yang toleran</a></li>
<li><a href="../id414371/index.html">Kelas sekolah dan sketsa kecil rekayasa sosial</a></li>
<li><a href="../id414373/index.html">Desain async / menunggu JavaScript: kekuatan, jebakan, dan pola penggunaan</a></li>
<li><a href="../id414375/index.html">Perintah untuk bekerja dengan konsol JavaScript di browser dan meningkatkan produktivitas programmer</a></li>
<li><a href="../id414379/index.html">"Mereka yang bersedia bertukar kebebasan untuk keamanan tidak layak dengan kebebasan atau keamanan" (sumber asli)</a></li>
<li><a href="../id414381/index.html">Airwheel R8 E-bike: under-rider atau re-bike</a></li>
<li><a href="../id414383/index.html">Kabel bawah laut serat optik juga dapat berfungsi sebagai seismograf</a></li>
<li><a href="../id414385/index.html">10 UX / UI Tips: Bagaimana Label Pakaian dan Aplikasi Kencan Mengajari Kita Mendesain Lebih Baik</a></li>
<li><a href="../id414387/index.html">Sam Altman, President, Y Combinator: Produktivitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>