<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö® üë∑üèª ‚ôìÔ∏è Testes autom√°ticos de interface do usu√°rio: como fazer isso n√£o vale a pena üë∏üèæ üòÄ üôÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, Habr. Meu nome √© Vitaliy Kotov, trabalho no departamento de testes do Badoo. Escrevo muitos testes autom√°ticos de interface do usu√°rio, mas traba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes autom√°ticos de interface do usu√°rio: como fazer isso n√£o vale a pena</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Ol√°, Habr.  Meu nome √© Vitaliy Kotov, trabalho no departamento de testes do Badoo.  Escrevo muitos testes autom√°ticos de interface do usu√°rio, mas trabalho ainda mais com aqueles que fazem isso h√° pouco tempo e ainda n√£o conseguiram pisar em todos os ancinhos. <br><br>  Ent√£o, depois de adicionar minha pr√≥pria experi√™ncia e observa√ß√µes de outros caras, decidi preparar para voc√™ uma cole√ß√£o de "como escrever testes n√£o vale a pena".  Apoiei cada exemplo com uma descri√ß√£o detalhada, exemplos de c√≥digo e capturas de tela. <br><br>  O artigo ser√° interessante para autores iniciantes de testes de interface do usu√°rio, mas os veteranos deste t√≥pico provavelmente aprender√£o algo novo, ou apenas sorrir√£o, lembrando-se "da juventude".  :) <br><br>  Vamos l√°! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Conte√∫do </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Localizadores sem atributos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verifique se h√° itens ausentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verifique se h√° um item</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dados aleat√≥rios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atomicidade dos ensaios (parte 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atomicidade dos ensaios (parte 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erro ao clicar em um item existente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texto de erro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> </li></ul><a name="locators"></a><br><h2>  Localizadores sem atributos </h2><br>  Vamos come√ßar com um exemplo simples.  Como estamos falando de testes de interface do usu√°rio, os localizadores desempenham um papel importante neles.  Um localizador √© uma linha composta de acordo com uma certa regra e descreve um ou mais elementos XML (em particular HTML). <br><br>  Existem v√°rios tipos de localizadores.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localizadores css</a> s√£o usados ‚Äã‚Äãpara folhas de estilos em cascata.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os localizadores XPath</a> s√£o usados ‚Äã‚Äãpara trabalhar com documentos XML.  E assim por diante <br><br>  Uma lista completa dos tipos de localizadores usados ‚Äã‚Äãpelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selenium</a> pode ser encontrada em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seleniumhq.github.io</a> . <br><br>  Nos testes de interface do usu√°rio, os localizadores s√£o usados ‚Äã‚Äãpara descrever os elementos com os quais o driver deve interagir. <br><br>  Em quase qualquer inspetor de navegador, √© poss√≠vel selecionar o elemento de interesse para n√≥s e copiar seu XPath.  Parece algo como isto: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Acontece que esse localizador: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Parece que n√£o h√° nada de errado com esse localizador.  Afinal, podemos salv√°-lo em alguma constante ou campo da classe, que por seu nome transmitir√° a ess√™ncia do elemento: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  E envolva o texto de erro correspondente, caso o elemento n√£o seja encontrado: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(‚ÄúCannot find Create Account button.‚Äù) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Essa abordagem tem uma vantagem: n√£o h√° necessidade de aprender XPath. <br><br>  No entanto, existem v√°rias desvantagens.  Em primeiro lugar, ao alterar o layout, n√£o h√° garantia de que o elemento em um localizador permane√ßa o mesmo.  √â poss√≠vel que outro ocupe o seu lugar, o que levar√° a circunst√¢ncias imprevistas.  Em segundo lugar, a tarefa dos autotestes √© procurar bugs e n√£o monitorar as altera√ß√µes no layout.  Portanto, a adi√ß√£o de algum inv√≥lucro ou de outros elementos mais altos na √°rvore n√£o deve afetar nossos testes.  Caso contr√°rio, levaremos muito tempo para atualizar os localizadores. <br><br>  Conclus√£o: voc√™ deve criar localizadores que descrevam corretamente o elemento e sejam resistentes a altera√ß√µes de layouts fora da parte testada de nossa aplica√ß√£o.  Por exemplo, voc√™ pode ligar a um ou mais atributos de um elemento: <br><br> <code>//a[@rel=‚ÄùcreateAccount‚Äù] <br></code> <br>  Um localizador desse tipo √© mais f√°cil de perceber no c√≥digo e ser√° interrompido apenas se "rel" desaparecer. <br><br>  Outra vantagem desse localizador √© a capacidade de procurar no reposit√≥rio de modelos com o atributo especificado.  Mas o que procurar se o localizador se parecer no exemplo original?  :) <br><br>  Se inicialmente no aplicativo os elementos n√£o tiverem nenhum atributo ou forem definidos automaticamente (por exemplo, devido √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ofusca√ß√£o de</a> classes), vale a pena discutir com os desenvolvedores.  Eles n√£o devem estar menos interessados ‚Äã‚Äãem automatizar os testes de produtos e certamente o encontrar√£o e oferecer√£o uma solu√ß√£o. <br><a name="no_element"></a><br><h2>  Verifique se h√° itens ausentes </h2><br>  Cada usu√°rio do Badoo tem seu pr√≥prio perfil.  Ele cont√©m informa√ß√µes sobre o usu√°rio: (nome, idade, fotos) e informa√ß√µes sobre com quem o usu√°rio deseja conversar.  Al√©m disso, √© poss√≠vel indicar seus interesses. <br><br>  Suponha que j√° tivemos um bug (embora, √© claro, n√£o seja assim :)).  O usu√°rio em seu perfil escolheu interesses.  N√£o encontrando um interesse adequado na lista, ele decidiu clicar em "Mais" para atualizar a lista. <br><br>  Comportamento esperado: interesses antigos devem desaparecer, novos devem aparecer.  Mas, em vez disso, um "Erro inesperado" apareceu: <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Verificou-se que havia um problema no lado do servidor, a resposta n√£o era a mesma e o cliente processou esse problema mostrando uma notifica√ß√£o. <br><br>  Nossa tarefa √© escrever um autoteste que verifique esse caso. <br><br>  Escrevemos aproximadamente o seguinte script: <br><br><ul><li>  Abrir perfil </li><li>  Abrir lista de interesses </li><li>  Clique no bot√£o "Mais" </li><li>  Verifique se o erro n√£o apareceu (por exemplo, n√£o h√° elemento div.error) </li></ul><br>  N√≥s executamos esse teste.  No entanto, acontece o seguinte: ap√≥s alguns dias / meses / anos, o bug reaparece, embora o teste n√£o capte nada.  Porque <br><br>  Tudo √© bem simples: durante a aprova√ß√£o bem-sucedida do teste, o localizador do elemento pelo qual procuramos o texto do erro foi alterado.  Houve uma refatora√ß√£o dos modelos e, em vez da classe "error", obtivemos a classe "error_new". <br><br>  Durante a refatora√ß√£o, o teste continuou a funcionar como esperado.  O elemento div.error n√£o apareceu; n√£o havia motivo para a queda.  Mas agora o elemento ‚Äúdiv.error‚Äù n√£o existe mais - portanto, o teste nunca falha, n√£o importa o que aconte√ßa no aplicativo. <br><br>  Conclus√£o: √© melhor testar a operacionalidade da interface com verifica√ß√µes positivas.  Em nosso exemplo, devemos esperar que a lista de interesses tenha mudado. <br><br>  H√° situa√ß√µes em que um teste negativo n√£o pode ser substitu√≠do por um teste positivo.  Por exemplo, ao interagir com algum elemento, nada acontece em uma situa√ß√£o "boa" e um erro aparece em uma situa√ß√£o "ruim".  Nesse caso, voc√™ deve criar uma maneira de simular um cen√°rio "ruim" e tamb√©m escrever um autoteste nele.  Assim, verificamos que o elemento de erro aparece no caso negativo e, assim, monitoramos a relev√¢ncia do localizador. <br><a name="element_exists"></a><br><h2>  Verifique se h√° um item </h2><br>  Como garantir que a intera√ß√£o do teste com a interface tenha √™xito e que tudo funcione?  Isso √© visto com mais frequ√™ncia nas altera√ß√µes que ocorreram nessa interface. <br><br>  Considere um exemplo.  Voc√™ precisa garantir que, ao enviar uma mensagem, ela apare√ßa no chat: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  O script √© mais ou menos assim: <br><br><ul><li>  Abrir perfil de usu√°rio </li><li>  Abra o bate-papo com ele </li><li>  Escreva uma mensagem </li><li>  Enviar </li><li>  Aguarde a mensagem aparecer. </li></ul><br>  Descrevemos esse cen√°rio em nosso teste.  Suponha que uma mensagem de bate-papo corresponda a um localizador: <br><br> <code>p.message_text <br></code> <br>  √â assim que verificamos se o elemento aparece: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Se a nossa espera funcionar, tudo est√° em ordem: as mensagens de bate-papo s√£o desenhadas. <br><br>  Como voc√™ deve ter adivinhado, depois de um tempo, o envio de mensagens de bate-papo √© interrompido, mas nosso teste continua a funcionar sem interrup√ß√µes.  Vamos acertar. <br><br>  Acontece que um dia antes de um novo elemento aparecer no bate-papo: algum texto que solicita ao usu√°rio que destaque a mensagem se de repente passar despercebida: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  E, o mais engra√ßado, tamb√©m cai sob o nosso localizador.  Somente ele possui uma classe adicional que o distingue das mensagens enviadas: <br><br> <code>p.message_text.highlight <br></code> <br>  Nosso teste n√£o foi interrompido quando esse bloco apareceu, mas a verifica√ß√£o "aguardar a exibi√ß√£o da mensagem" deixou de ser relevante.  O elemento que foi um indicador de um evento bem-sucedido agora est√° sempre l√°. <br><br>  Conclus√£o: se a l√≥gica do teste √© baseada na verifica√ß√£o da apar√™ncia de algum elemento, √© necess√°rio verificar se esse elemento n√£o existe antes de nossa intera√ß√£o com a interface do usu√°rio. <br><br><ul><li>  Abrir perfil de usu√°rio </li><li>  Abra o bate-papo com ele </li><li>  <b>Verifique se n√£o h√° mensagens enviadas</b> </li><li>  Escreva uma mensagem </li><li>  Enviar </li><li>  Aguarde a mensagem aparecer. </li></ul><br><a name="random_data"></a><h2>  Dados aleat√≥rios </h2><br>  Frequentemente, os testes de interface do usu√°rio funcionam com formul√°rios nos quais eles inserem dados.  Por exemplo, temos um formul√°rio de registro: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Os dados para esses testes podem ser armazenados em configura√ß√µes ou codificados em um teste.  Mas √†s vezes o pensamento vem √† mente: por que n√£o randomizar os dados?  Isso √© bom, vamos cobrir mais casos! <br><br>  Meu conselho: n√£o.  E agora vou lhe dizer o porqu√™. <br><br>  Suponha que nosso teste esteja registrado no Badoo.  Decidimos que escolheremos o sexo do usu√°rio aleatoriamente.  No momento da reda√ß√£o do teste, o fluxo de registro para a menina e o menino n√£o √© diferente, portanto, nosso teste √© aprovado com √™xito. <br><br>  Agora imagine que depois de um tempo o fluxo de registro se torne diferente.  Por exemplo, damos b√¥nus √† menina imediatamente ap√≥s o registro, sobre os quais a notificamos com uma cobertura especial. <br><br>  No teste, n√£o h√° l√≥gica para fechar a sobreposi√ß√£o, mas, por sua vez, interfere em quaisquer outras a√ß√µes prescritas no teste.  Temos um teste que cai em 50% dos casos.  Qualquer ferramenta de automa√ß√£o confirmar√° que os testes de interface do usu√°rio n√£o s√£o inerentemente est√°veis ‚Äã‚Äãpor natureza.  E isso √© normal, √© preciso conviver com ele, constantemente enfrentando a l√≥gica redundante "para todas as ocasi√µes" (que estraga visivelmente a legibilidade do c√≥digo e complica seu suporte) e essa instabilidade em si. <br><br>  Da pr√≥xima vez, quando o teste cair, talvez n√£o tenhamos tempo para lidar com isso.  N√≥s apenas o reiniciamos e vemos que j√° passou.  Decidimos que, em nossa aplica√ß√£o, tudo funciona como deveria e a coisa √© um teste inst√°vel.  E acalme-se. <br><br>  Agora vamos seguir em frente.  E se essa sobreposi√ß√£o quebrar?  O teste continuar√° a ser aprovado em 50% dos casos, o que atrasa significativamente a localiza√ß√£o do problema. <br><br>  E √© bom quando, devido √† randomiza√ß√£o dos dados, criamos uma situa√ß√£o "50 por 50".  Mas isso acontece de maneira diferente.  Por exemplo, antes de se registrar, uma senha era considerada aceit√°vel com pelo menos tr√™s caracteres.  N√≥s escrevemos um c√≥digo que vem com uma senha aleat√≥ria n√£o inferior a tr√™s caracteres (√†s vezes tr√™s caracteres e √†s vezes mais).  E ent√£o a regra muda - e a senha j√° deve conter pelo menos quatro caracteres.  Qual √© a probabilidade de uma queda neste caso?  E, se o nosso teste detectar um erro real, com que rapidez descobriremos? <br><br>  √â especialmente dif√≠cil trabalhar com testes nos quais muitos dados aleat√≥rios s√£o inseridos: nome, sexo, senha e assim por diante ... Nesse caso, tamb√©m existem muitas combina√ß√µes diferentes e, se ocorrer um erro em alguma delas, geralmente √© dif√≠cil perceber. <br><br>  Conclus√£o  Como escrevi acima, randomizar dados √© ruim.  √â melhor cobrir mais casos √†s custas dos provedores de dados, sem esquecer as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classes de equival√™ncia</a> , √© claro.  Passar nos testes levar√° mais tempo, mas voc√™ pode combat√™-lo.  Mas teremos certeza de que, se houver um problema, ele ser√° detectado. <br><a name="atom_tests_1"></a><br><h2>  Atomicidade dos ensaios (parte 1) </h2><br>  Vejamos o exemplo a seguir.  Estamos escrevendo um teste que verifica o contador de usu√°rios no rodap√©. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  O cen√°rio √© simples: <br><br><ul><li>  Abrir aplica√ß√£o </li><li>  Localizar contador de rodap√© </li><li>  Verifique se est√° vis√≠vel </li></ul><br>  Chamamos esse teste de testFooterCounter e o executamos.  Ent√£o, √© necess√°rio verificar se o contador n√£o mostra zero.  Adicionamos esse teste a um teste existente, por que n√£o? <br><br>  Por√©m, torna-se necess√°rio verificar se no rodap√© existe um link para a descri√ß√£o do projeto (o link "Quem Somos").  Escrever um novo teste ou adicionar a um existente?  No caso de um novo teste, teremos que aumentar novamente o aplicativo, preparar o usu√°rio (se verificarmos o rodap√© na p√°gina autorizada), efetuar login - em geral, gastar um tempo precioso.  Em tal situa√ß√£o, renomear o teste para testFooterCounterAndLinks parece uma boa id√©ia. <br><br>  Por um lado, essa abordagem tem vantagens: economizando tempo, armazenando todas as verifica√ß√µes de alguma parte de nosso aplicativo (neste caso, rodap√©) em um √∫nico local. <br><br>  Mas h√° um sinal de menos.  Se o teste falhar no primeiro teste, n√£o verificaremos o restante do componente.  Suponha que um teste trava em algum ramo, n√£o por instabilidade, mas por um erro.  O que fazer  Retornar uma tarefa que descreve apenas esse problema?  Em seguida, corremos o risco de obter uma tarefa com uma corre√ß√£o apenas desse bug, executamos um teste e descobrimos que o componente tamb√©m est√° quebrado, em outro local.  E pode haver muitas dessas itera√ß√µes.  Chutar um ticket para frente e para tr√°s neste caso levar√° muito tempo e ser√° ineficaz. <br><br>  Conclus√£o: se poss√≠vel, atomize as verifica√ß√µes.  Nesse caso, mesmo tendo um problema em um caso, verificaremos todos os outros.  E, se voc√™ precisar devolver o ticket, podemos descrever imediatamente todas as √°reas problem√°ticas. <br><a name="atom_tests_2"></a><br><h2>  Atomicidade dos ensaios (parte 2) </h2><br>  Considere outro exemplo.  Estamos escrevendo um teste de bate-papo que verifica a seguinte l√≥gica.  Se os usu√°rios tiverem simpatia m√∫tua, o seguinte promoblock aparecer√° no bate-papo: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  O cen√°rio √© o seguinte: <br><br><ul><li>  Votar pelo usu√°rio A para o usu√°rio B </li><li>  Votar pelo usu√°rio B para o usu√°rio A </li><li>  Usu√°rio A bate-papo aberto com o usu√°rio B </li><li>  Confirme se a unidade est√° no lugar </li></ul><br>  Por algum tempo, o teste funciona com √™xito, mas acontece o seguinte ... N√£o, desta vez o teste n√£o perde nenhum bug.  :) <br><br>  Depois de algum tempo, descobrimos que h√° outro erro n√£o relacionado ao nosso teste: se voc√™ abrir um bate-papo, feche-o imediatamente e abra-o novamente, o bloqueio desaparecer√°.  N√£o √© o caso mais √≥bvio, e no teste, √© claro, n√£o o previmos.  Mas decidimos que precisamos cobri-lo tamb√©m. <br><br>  Surge a mesma pergunta: escreva outro teste ou insira um teste em um j√° existente?  Escrever um novo parece inapropriado, porque 99% das vezes ele faz o mesmo que o existente.  E decidimos adicionar o teste ao teste que j√° est√° l√°: <br><br><ul><li>  Votar pelo usu√°rio A para o usu√°rio B </li><li>  Votar pelo usu√°rio B para o usu√°rio A </li><li>  Usu√°rio A bate-papo aberto com o usu√°rio B </li><li>  Confirme se a unidade est√° no lugar </li><li>  <b>Fechar bate-papo</b> </li><li>  <b>Chat aberto</b> </li><li>  Confirme se a unidade est√° no lugar </li></ul><br>  Um problema pode surgir quando, por exemplo, refatoramos um teste ap√≥s um longo per√≠odo de tempo.  Por exemplo, um novo design acontecer√° em um projeto - e voc√™ ter√° que reescrever muitos testes. <br><br>  Vamos abrir o teste e tentar lembrar o que ele verifica.  Por exemplo, um teste √© chamado testPromoAfterMutualAttraction.  Entendemos por que a abertura e o encerramento do bate-papo est√£o escritos no final?  Provavelmente n√£o.  Especialmente se este teste n√£o foi escrito por n√≥s.  Vamos deixar esta pe√ßa?  Talvez sim, mas se houver algum problema com ele, √© prov√°vel que simplesmente o excluamos.  E a verifica√ß√£o ser√° perdida simplesmente porque seu significado n√£o ser√° √≥bvio. <br><br>  Eu vejo duas solu√ß√µes aqui.  Primeiro: ainda fa√ßa o segundo teste e chame-o de testCheckBlockPresentAfterOpenAndCloseChat.  Com esse nome, ficar√° claro que n√£o estamos apenas realizando um determinado conjunto de a√ß√µes, mas realizando uma verifica√ß√£o muito consciente, porque houve uma experi√™ncia negativa.  A segunda solu√ß√£o √© escrever um coment√°rio detalhado no c√≥digo sobre por que estamos fazendo esse teste neste teste espec√≠fico.  Tamb√©m √© aconselh√°vel indicar o n√∫mero do bug no coment√°rio. <br><a name="click_error"></a><br><h2>  Erro ao clicar em um item existente </h2><br>  O exemplo a seguir me jogou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">bbidox</a> , pelo qual ele √© uma grande vantagem no karma! <br><br>  H√° uma situa√ß√£o muito interessante quando o c√≥digo de teste j√° se torna ... uma estrutura.  Suponha que tenhamos um m√©todo como este: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  Em algum momento, algo estranho come√ßa a acontecer com esse m√©todo: o teste falha quando voc√™ tenta clicar em um bot√£o.  Abrimos a captura de tela feita no momento em que o teste falhou e vemos que h√° um bot√£o na captura de tela e o m√©todo waitForButtonToAppear funcionou com √™xito.  Pergunta: o que h√° de errado com o clique? <br><br>  A parte mais dif√≠cil nessa situa√ß√£o √© que o teste √†s vezes pode ser bem-sucedido.  :) <br><br>  Vamos acertar.  Suponha que o bot√£o considerado no exemplo esteja localizado em uma sobreposi√ß√£o: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Esta √© uma sobreposi√ß√£o especial atrav√©s da qual um usu√°rio em nosso site pode preencher informa√ß√µes sobre si mesmo.  Quando voc√™ clica no bot√£o de sobreposi√ß√£o destacado, o pr√≥ximo bloco aparece para preencher. <br><br>  Por divers√£o, vamos adicionar uma classe OLOLO extra para este bot√£o: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Depois disso, clicamos neste bot√£o.  Visualmente, nada mudou, mas o pr√≥prio bot√£o permaneceu no lugar: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  O que aconteceu?  De fato, quando JS redesenhou o bloco para n√≥s, ele redesenhou o bot√£o tamb√©m.  Ainda est√° dispon√≠vel no mesmo localizador, mas este √© outro bot√£o.  Isso √© evidenciado pela falta da classe OLOLO que adicionamos. <br><br>  No c√≥digo acima, armazenamos o elemento na vari√°vel $ element.  Se um elemento for regenerado durante esse per√≠odo, ele poder√° n√£o estar vis√≠vel visualmente, mas voc√™ n√£o poder√° mais clicar nele - o m√©todo click () falhar√°. <br><br>  Existem v√°rias solu√ß√µes: <br><br><ul><li>  Quebrar clique no bloco try e no elemento catch reconstruir </li><li>  Adicione um bot√£o a um atributo para sinalizar que ele foi alterado </li></ul><br><a name="error_message"></a><h2>  Texto de erro </h2><br>  Finalmente, um ponto simples, mas n√£o menos importante. <br><br>  Este exemplo se aplica n√£o apenas aos testes da interface do usu√°rio, mas tamb√©m ocorre com muita frequ√™ncia neles.  Geralmente, quando voc√™ escreve um teste, est√° no contexto do que est√° acontecendo: descreve a verifica√ß√£o ap√≥s a verifica√ß√£o e entende seu significado.  E voc√™ escreve textos de erro no mesmo contexto: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  O que pode ser incompreens√≠vel neste c√≥digo?  O teste espera a apar√™ncia de um bot√£o e, se n√£o estiver l√°, cai naturalmente. <br><br>  Agora imagine que o autor do teste est√° de licen√ßa m√©dica e seu colega est√° cuidando dos testes.  E ent√£o ele descarta o teste testQuestionsOnProfile e escreve esta mensagem: "N√£o √© poss√≠vel encontrar o bot√£o".  Um colega precisa entender o que est√° acontecendo o mais r√°pido poss√≠vel, porque o lan√ßamento est√° chegando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  O que ele ter√° que fazer? <br><br>  N√£o faz sentido abrir a p√°gina na qual o teste caiu e verificar o localizador "a.link" - n√£o h√° elemento.  Portanto, voc√™ deve estudar cuidadosamente o teste e descobrir o que ele verifica. <br><br>  Seria muito mais simples com um texto de erro mais detalhado: "N√£o √© poss√≠vel encontrar o bot√£o enviar na sobreposi√ß√£o de perguntas".  Com esse erro, voc√™ pode abrir imediatamente a sobreposi√ß√£o e ver para onde foi o bot√£o. <br><br>  Sa√≠da dois.  Em primeiro lugar, vale a pena passar o texto do erro para qualquer m√©todo da sua estrutura de teste e √© um par√¢metro necess√°rio para que n√£o haja tenta√ß√£o de esquec√™-lo.  Em segundo lugar, o texto do erro deve ser detalhado.  Isso nem sempre significa que deve ser longo, basta esclarecer o que deu errado no teste. <br><br>  Como entender que o texto do erro est√° bem escrito?  Muito simples  Imagine que seu aplicativo quebrou e voc√™ precisa ir at√© os desenvolvedores e explicar o que e onde quebrou.  Se voc√™ contar apenas o que est√° escrito no texto do erro, eles entender√£o? <br><a name="summary"></a><br><h2>  Sum√°rio </h2><br>  Escrever um script de teste geralmente √© uma atividade interessante.  Ao mesmo tempo, buscamos muitos objetivos.  Nossos testes devem: <br><br><ul><li>  cobrir o maior n√∫mero poss√≠vel de casos </li><li>  trabalhe o mais r√°pido poss√≠vel </li><li>  ser entendido </li><li>  apenas expanda </li><li>  f√°cil de manter </li><li>  pedir pizza </li><li>  e assim por diante ... </li></ul><br>  √â especialmente interessante trabalhar com testes em um projeto em constante evolu√ß√£o e mudan√ßa, onde eles precisam ser atualizados constantemente: adicione algo e corte algo.  √â por isso que vale a pena pensar sobre alguns pontos com anteced√™ncia e nem sempre se apressar nas decis√µes.  :) <br><br>  Espero que minhas dicas o ajudem a evitar alguns problemas e a torn√°-lo mais atencioso nos estudos de caso.  Se o p√∫blico gostar do artigo, tentarei coletar alguns exemplos mais chatos.  Enquanto isso - tchau! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419419/">https://habr.com/ru/post/pt419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419409/index.html">Novas NUCs da Intel baseadas em processadores Coffee Lake</a></li>
<li><a href="../pt419411/index.html">Sobre o fogo em um arranha-c√©u. Cinema e realidade</a></li>
<li><a href="../pt419413/index.html">Cinzel - (n√£o exatamente) uma nova abordagem para o desenvolvimento da l√≥gica digital</a></li>
<li><a href="../pt419415/index.html">Mattermost e Powershell - grande pot√™ncia ou pequena automa√ß√£o em casa</a></li>
<li><a href="../pt419417/index.html">GDPR: mapeamento de dados ou como os clientes encontram laptops h√° muito esquecidos</a></li>
<li><a href="../pt419423/index.html">Nos √© prometido um v√≠deo em tempo real, sem frisos e contra√ß√µes musculares</a></li>
<li><a href="../pt419425/index.html">Semana de Seguran√ßa 29. Hacking Reddit, uma carteira para roteadores de criptomoeda e MikroTik</a></li>
<li><a href="../pt419427/index.html">Epson convida todos para o piquenique para geeks 2018</a></li>
<li><a href="../pt419429/index.html">Tenho 57 anos e sou scrum master</a></li>
<li><a href="../pt419435/index.html">Seguran√ßa NIST Bluetooth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>