<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèø üë©üèª‚Äçü§ù‚Äçüë®üèΩ üôÜüèª Vorbereitungen f√ºr das Kombinieren üë®üèΩ‚Äçüîß üõÄüèø ü•ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor anderthalb Jahren habe ich RxSwift gelobt . Ich brauchte eine Weile, um es herauszufinden, aber als das passierte, gab es kein Zur√ºck mehr. Jetzt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorbereitungen f√ºr das Kombinieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470117/"><img src="https://habrastorage.org/webt/km/8-/uo/km8-uov-j3m2rfjjsxscoyeh9bc.jpeg"><br><br>  Vor anderthalb Jahren habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxSwift gelobt</a> .  Ich brauchte eine Weile, um es herauszufinden, aber als das passierte, gab es kein Zur√ºck mehr.  Jetzt hatte ich den besten Hammer der Welt und verdammt noch mal, wenn nicht alles um mich herum wie ein Nagel aussah. <br><br>  Apple stellte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Combine</a> Framework auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWDC</a> Summer Conference vor.  Auf den ersten Blick sieht es nach einer etwas besseren Version von RxSwift aus.  Bevor ich erkl√§ren kann, was mir daran gef√§llt und was nicht, m√ºssen wir verstehen, welches Problem Combine l√∂sen soll. <br><a name="habracut"></a><br><h2>  Reaktive Programmierung?  Na und? </h2><br>  Die ReactiveX-Community - zu der auch die RxSwift-Community geh√∂rt - erkl√§rt ihre Essenz wie folgt: <br><br><blockquote>  API f√ºr asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  Und auch: <br><br><blockquote>  ReactiveX ist eine Kombination der besten Ideen aus den Entwurfsmustern Observer und Iterator sowie der funktionalen Programmierung. </blockquote><br>  Nun ... okay. <br><br>  Und was bedeutet das <i>wirklich</i> ? <br><br><h2>  Die Grundlagen </h2><br>  Um die Essenz der reaktiven Programmierung wirklich zu verstehen, finde ich es n√ºtzlich zu verstehen, wie wir dazu gekommen sind.  In diesem Artikel werde ich beschreiben, wie Sie vorhandene Typen in jeder modernen OOP-Sprache betrachten, verdrehen und dann zur reaktiven Programmierung gelangen k√∂nnen. <br><br>  In diesem Artikel werden wir uns schnell mit dem Dschungel befassen, was f√ºr das Verst√§ndnis der reaktiven Programmierung nicht <i>unbedingt</i> erforderlich ist. <br><br>  Ich halte dies jedoch f√ºr eine merkw√ºrdige akademische √úbung, insbesondere im Hinblick darauf, wie stark typisierte Sprachen uns zu neuen Entdeckungen f√ºhren k√∂nnen. <br><br>  Warten Sie also auf meine n√§chsten Beitr√§ge, wenn Sie an neuen Details interessiert sind. <br><br><h2>  Aufz√§hlbar </h2><br>  Die mir bekannte ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktive Programmierung</a> ‚Äú stammt aus der Sprache, in der ich einmal geschrieben habe - C #.  Die Pr√§misse selbst ist ganz einfach: <br><br>  <i>Was ist, wenn sie Ihnen die Werte selbst senden, anstatt Werte aus der Aufz√§hlung zu extrahieren?</i> <br><br>  Diese Idee, "dr√ºcken statt ziehen", wurde am besten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Brian Beckman und Eric Meyer beschrieben.  Die ersten 36 Minuten ... Ich habe nichts verstanden, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ab der 36. Minute</a> wird es <i>wirklich</i> interessant. <br><br>  Kurz gesagt, lassen Sie uns die Idee einer linearen Gruppe von Objekten in Swift sowie eines Objekts, das √ºber diese lineare Gruppe iterieren kann, neu formulieren.  Sie k√∂nnen dies tun, indem Sie diese gef√§lschten Swift-Protokolle definieren: <br><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ;     //    Array. protocol Enumerable { associatedtype Enum: Enumerator associatedtype Element where Self.Element == Self.Enum.Element func getEnumerator() -&gt; Self.Enum } // ,       . protocol Enumerator: Disposable { associatedtype Element func moveNext() throws -&gt; Bool var current: Element { get } } //          // Enumerator,         .   . protocol Disposable { func dispose() }</span></span></code> </pre> <br><h2>  Doppel </h2><br>  Lassen Sie uns alles umdrehen und <i>Doppel</i> machen.  Wir senden Daten dorthin, woher sie stammen.  Und holen Sie sich die Daten von dort, wo sie abgereist sind.  Es klingt absurd, aber ertrage es ein wenig. <br><br><h3>  Doppelte Aufz√§hlung </h3><br>  Beginnen wir mit Enumerable: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerable { associatedtype Element where Self.Element == Self.Enum.Element associatedtype Enum: Enumerator func getEnumerator() -&gt; Self.Enum } protocol DualOfEnumerable { //  Enumerator : // getEnumerator() -&gt; Self.Enum //    : // getEnumerator(Void) -&gt; Enumerator // //  , : // : Void; : Enumerator // getEnumerator(Void) ‚Üí Enumerator // //     Void   Enumerator. //   -      Enumerator,   Void. // :  Enumerator; : Void func subscribe(DualOfEnumerator) }</span></span></code> </pre> <br>  Da <code>getEnumerator()</code> <code>Void</code> nahm und <code>Enumerator</code> gab, akzeptieren wir jetzt den [double] <code>Enumerator</code> und geben <code>Void</code> . <br><br>  Ich wei√ü, dass das seltsam ist.  Geh nicht weg. <br><br><h3>  Doppelter Enumerator </h3><br>  Und was ist dann <code>DualOfEnumerator</code> ? <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerator: Disposable { associatedtype Element // : Void; : Bool, Error func moveNext() throws -&gt; Bool // : Void; : Element var current: Element { get } } protocol DualOfEnumerator { // : Bool, Error; : Void //   Error    func enumeratorIsDone(Bool) // : Element, : Void var nextElement: Element { set } }</span></span></code> </pre> <br>  Hier gibt es mehrere Probleme: <br><br><ul><li>  In Swift gibt es kein Konzept f√ºr eine Nur-Set-Eigenschaft. <br></li><li>  Was ist mit <code>throws</code> in <code>Enumerator.moveNext()</code> passiert? <br></li><li>  Was passiert mit <code>Disposable</code> ? <br></li></ul><br>  Um das Problem mit der Eigenschaft set-only zu beheben, k√∂nnen wir es als das behandeln, was es wirklich ist - eine Funktion.  Lassen Sie uns unseren <code>DualOfEnumerator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool; : Void, Error //   Error    func enumeratorIsDone(Bool) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Um das Problem mit <code>throws</code> zu l√∂sen, trennen wir den Fehler, der in <code>moveNext()</code> und arbeiten damit als separate <code>error()</code> -Funktion: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool, Error; : Void func enumeratorIsDone(Bool) func error(Error) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Wir k√∂nnen noch etwas anderes tun: Sehen Sie sich die Signatur des Abschlusses der Iteration an: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool)</span></span></span></span></code> </pre> <br>  Wahrscheinlich wird im Laufe der Zeit etwas √Ñhnliches passieren: <br><br><pre> <code class="swift hljs">enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     enumeratorIsDone(true)</span></span></code> </pre> <br>  Lassen Sie uns nun die Dinge vereinfachen und <code>enumeratorIsDone</code> nur aufrufen, wenn ... alles wirklich fertig ist.  Anhand dieser Idee vereinfachen wir den Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h3>  Pass auf uns auf </h3><br>  Was ist mit <code>Disposable</code> ?  Was soll man damit machen?  Da <code>Disposable</code> Teil <i>des</i> <code>Enumerator</code> <i>Typs ist</i> , sollte <i>der</i> <code>Enumerator</code> , wenn wir ihn <i>doppelt erhalten</i> , wahrscheinlich √ºberhaupt nicht im <code>Enumerator</code> .  Stattdessen sollte es Teil von <code>DualOfEnumerable</code> .  Aber wo genau? <br><br>  <code>DualOfEnumerator</code> hier ein: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span></code> </pre> <br>  Wenn wir <code>DualOfEnumerator</code> akzeptieren, sollte <code>Disposable</code> dann nicht <i>zur√ºckgegeben werden</i> ? <br><br>  Hier ist, was f√ºr ein Double du hast: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Nennen wir es eine Rose, aber nicht </h2><br>  Also, noch einmal, hier ist was wir haben: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  Lassen Sie uns jetzt ein wenig mit den Namen spielen. <br><br>  Beginnen wir mit <code>DualOfEnumerator</code> .  Wir werden bessere Namen f√ºr die Funktionen finden, um genauer zu beschreiben, was passiert: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  So viel besser und verst√§ndlicher. <br><br>  Was ist mit Typnamen?  Sie sind einfach schrecklich.  Lassen Sie uns sie ein wenig √§ndern. <br><br><ul><li>  <code>DualOfEnumerator</code> - etwas, das folgt, was mit einer linearen Gruppe von Objekten passiert.  Wir k√∂nnen sagen, dass er eine lineare Gruppe <i>beobachtet</i> . <br></li><li>  <code>DualOfEnumerable</code> ist Gegenstand der Beobachtung.  Was wir sehen.  Daher kann es als <i>beobachtbar bezeichnet werden</i> . <br></li></ul><br>  Nehmen Sie nun die letzten √Ñnderungen vor und erhalten Sie Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observer)</span></span></span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Wow </h2><br>  Wir haben gerade zwei grundlegende Objekte in RxSwift erstellt.  Sie k√∂nnen ihre realen Versionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Beachten Sie, dass im Fall von Observer die drei <code>on()</code> -Funktionen zu einer <code>on(Event)</code> kombiniert werden, wobei <code>Event</code> eine Aufz√§hlung ist, die bestimmt, was das Ereignis ist - Abschluss, n√§chster Wert oder Fehler. <br><br>  Diese beiden Typen liegen RxSwift und der reaktiven Programmierung zugrunde. <br><br><h2>  √úber gef√§lschte Protokolle </h2><br>  Die beiden oben erw√§hnten "gef√§lschten" Protokolle sind eigentlich √ºberhaupt nicht gef√§lscht.  Dies sind Analoga bestehender Typen in Swift: <br><br><ul><li>  Aufz√§hlbar ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequenz</a> <br></li><li>  Enumerator ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iteratorsequenz</a> <br></li></ul><br><h2>  Na und? </h2><br>  Wor√ºber sollten Sie sich also Sorgen machen? <br><br>  So viel in der modernen Entwicklung - <i>insbesondere in der</i> Anwendungsentwicklung - ist mit Asynchronit√§t verbunden.  Der Benutzer klickte pl√∂tzlich auf eine Schaltfl√§che.  Der Benutzer hat pl√∂tzlich eine Registerkarte im UISegmentControl ausgew√§hlt.  Der Benutzer hat pl√∂tzlich eine Registerkarte in der UITabBar ausgew√§hlt.  Der Web-Socket gab uns pl√∂tzlich neue Informationen.  Dieser Download endete pl√∂tzlich - und schlie√ülich -.  Diese Hintergrundaufgabe endete abrupt.  Diese Liste geht weiter und weiter. <br><br>  In der modernen CocoaTouch-Welt gibt es viele M√∂glichkeiten, mit solchen Ereignissen umzugehen: <br><br><ul><li>  Benachrichtigungen <br></li><li>  R√ºckrufe <br></li><li>  Schl√ºsselwertbeobachtung (KVO), <br></li><li>  Ziel- / Aktionsmechanismus. <br></li></ul><br>  Stellen <i>Sie sich vor, alles</i> k√∂nnte sich in einer einzigen Schnittstelle widerspiegeln.  Welches mit <i>jeder</i> Art von asynchronen Daten oder Ereignissen innerhalb der gesamten Anwendung arbeiten k√∂nnte. <br><br>  Stellen Sie sich nun vor, es g√§be eine ganze <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Funktionen</a> , mit denen Sie diese <i>Streams</i> √§ndern, von einem Typ in einen anderen konvertieren, Informationen aus Elementen extrahieren oder sie sogar mit anderen Streams kombinieren k√∂nnen. <br><br>  Pl√∂tzlich liegt in unseren H√§nden ein neues <i>universelles</i> Werkzeugset. <br>  Und so kehrten wir zum Anfang zur√ºck: <br><br><blockquote>  API f√ºr asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  Dies macht RxSwift zu einem so leistungsstarken Tool.  Wie kombinieren. <br><br><h2>  Was weiter? </h2><br>  Wenn Sie mehr √ºber RxSwift <i>in der Praxis</i> lesen m√∂chten, empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine f√ºnf Artikel aus dem Jahr 2016</a> .  Sie beschreiben die Erstellung einer einfachen CocoaTouch-Anwendung, gefolgt von einer schrittweisen Konvertierung in RxSwift. <br><br>  In einem der folgenden Artikel werde ich erkl√§ren, warum viele der in meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelserie f√ºr Anf√§nger</a> beschriebenen Techniken in Combine nicht anwendbar sind, und ich vergleiche Combine mit RxSwift. <br><br><h1>  Kombinieren: Was ist der Sinn? </h1><br>  Die Diskussion von Combine beinhaltet auch eine Diskussion der Hauptunterschiede zwischen ihm und RxSwift.  F√ºr mich gibt es drei davon: <br><br><ul><li>  die M√∂glichkeit der Verwendung nicht reaktiver Klassen, <br></li><li>  Fehlerbehandlung <br></li><li>  Gegendruck. <br></li></ul><br>  Ich werde jedem Artikel einen eigenen Artikel widmen.  Ich werde mit dem ersten beginnen. <br><br><h2>  Eigenschaften von RxCocoa </h2><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem fr√ºheren Beitrag habe</a> ich gesagt, dass RxSwift mehr als ... RxSwift ist.  Es bietet zahlreiche M√∂glichkeiten f√ºr die Verwendung von Steuerelementen von UIKit im Typ-aber-nicht-ganz-Teilprojekt von RxCocoa.  Dar√ºber hinaus ging <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxSwiftCommunity</a> noch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt</a> weiter und implementierte viele Bindungen f√ºr noch abgelegenere Nebenstra√üen von UIKit sowie einige andere CocoaTouch-Klassen, die RxSwift und RxCocoa noch nicht abdecken. <br><br>  Daher ist es sehr einfach, einen <code>Observable</code> Stream zu erhalten, indem Sie beispielsweise auf UIButton klicken.  Ich werde dieses Beispiel noch einmal geben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Leichtgewichtler. <br><br><h2>  Lassen Sie uns (endlich) noch √ºber Kombinieren sprechen </h2><br>  Combine ist RxSwift sehr √§hnlich.  Wie die Dokumentation sagt: <br><br><blockquote>  Das Combine-Framework bietet eine deklarative Swift-API f√ºr die Verarbeitung von Werten im Zeitverlauf. </blockquote><br>  Klingt vertraut: Erinnern Sie sich an die Beschreibung von ReactiveX (dem √ºbergeordneten Projekt f√ºr RxSwift): <br><br><blockquote>  API f√ºr asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  In beiden F√§llen wird dasselbe gesagt.  Es ist nur so, dass in der Beschreibung von ReactiveX bestimmte Begriffe verwendet werden.  Es kann wie folgt umformuliert werden: <br><br><blockquote>  Eine API f√ºr die asynchrone Programmierung mit Werten √ºber die Zeit. </blockquote><br>  Fast das gleiche wie bei mir. <br><br><h2>  Gleich wie zuvor </h2><br>  Als ich mit der Analyse der API begann, wurde sofort klar, dass die meisten Typen, die ich von RxSwift kenne, √§hnliche Optionen in Combine haben: <br><br><ul><li>  Beobachtbar ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verlag</a> <br></li><li>  Beobachter ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abonnent</a> <br></li><li>  Einweg ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stornierbar</a> .  Dies ist ein Triumph des Marketings.  Sie k√∂nnen sich nicht vorstellen, wie viele √ºberraschte Blicke ich von unvoreingenommeneren Entwicklern erhalten habe, als ich anfing, Disposable in RxSwift zu beschreiben. <br></li><li>  SchedulerType ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler</a> <br></li></ul><br>  So weit so gut.  Ich mag Cancellable wieder viel mehr als Disposable.  Ein gro√üartiger Ersatz, nicht nur in Bezug auf Marketing, sondern auch in Bezug auf eine genaue Beschreibung des Wesens des Objekts. <br><br>  Mehr ist noch besser! <br><br><ul><li>  RxCocoas Treiber -&gt; Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BindableObject</a> von SwiftUI <br></li></ul><br>  Dies ist nicht sofort klar, aber geistig dienen sie einem Zweck, und keiner von ihnen kann zu Fehlern f√ºhren. <br><br><ul><li>  Single ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zukunft</a> <br></li><li>  SubjectType ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subject</a> <br></li><li>  PublishSubject ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PassthroughSubject</a> <br></li></ul><br><h2>  "Pause f√ºr Kacke" </h2><br>  Alles √§ndert sich, sobald Sie sich mit RxCocoa besch√§ftigen.  Erinnern Sie sich an das obige Beispiel, in dem wir einen Observable-Stream erhalten wollten, der Klicks auf UIButton darstellt?  Da ist er: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Kombinieren erfordert ... viel mehr Arbeit, um dasselbe zu tun. <br><br>  <b>Combine bietet keine Funktionen zum Binden an UIKit-Objekte.</b> <br><br>  Das ist ... nur ein unwirklicher Mist. <br><br>  Hier ist eine √ºbliche Methode, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIControl.Event</a> mithilfe von Combine von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIControl abzurufen</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlPublisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIControl</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> = (control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = <span class="hljs-type"><span class="hljs-type">PassthroughSubject</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Output</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">convenience</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: control, events: [event]) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, events: [<span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events { control.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(controlAction), <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: event) } } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">controlAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIControl, forEvent event: UIControl.Event)</span></span></span></span> { subject.send(<span class="hljs-type"><span class="hljs-type">ControlEvent</span></span>(control: sender, event: event)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { subject.receive(subscriber: subscriber) } }</code> </pre> <br>  Hier ... <i>viel</i> mehr Arbeit.  Zumindest sieht der Anruf so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>(control: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button, event: .touchUpInside) .sink { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }</code> </pre> <br>  Zum Vergleich: RxCocoa bietet einen angenehmen, leckeren Kakao in Form von Bindungen an UIKit-Objekte: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) })</code> </pre> <br>  An sich sind diese Herausforderungen letztendlich wirklich sehr √§hnlich.  Das einzig Frustrierende ist, dass ich <code>ControlPublisher</code> selbst schreiben musste, um an diesen Punkt zu gelangen.  Dar√ºber hinaus sind RxSwift und RxCocoa sehr gut getestet und werden in Projekten viel mehr als in meinen verwendet. <br><br>  Zum Vergleich erschien mein <code>ControlPublisher</code> nur ... jetzt.  Nur aufgrund der Anzahl der Clients (Null) und der Nutzungszeit in der realen Welt (fast Null im Vergleich zu RxCocoa) kann mein Code als unendlich gef√§hrlicher angesehen werden. <br><br>  Schade. <br><br><h2>  Gemeinschaftshilfe? </h2><br>  Ehrlich gesagt hindert nichts die Community daran, ein eigenes Open-Source-Programm ‚ÄûCombineCocoa‚Äú zu erstellen, das die RxCocoa-L√ºcke genau wie die RxSwiftCommunity f√ºllen w√ºrde. <br><br>  Ich halte dies jedoch f√ºr einen gro√üen Nachteil von Combine.  Ich m√∂chte nicht den gesamten RxCocoa neu schreiben, sondern nur Bindungen an UIKit-Objekte erhalten. <br><br>  Wenn ich mich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftUI</a> entscheide, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Problem des Mangels an Bindungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wahrscheinlich</a> dadurch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigt</a> .  Sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine kleine Anwendung</a> enth√§lt eine <i>Menge</i> UI-Code.  Das alles rauszuwerfen, nur um in den Kombinationszug zu springen, w√§re zumindest dumm oder sogar gef√§hrlich. <br><br>  √úbrigens beschreibt der Artikel in der Dokumentation zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Empfangen und Behandeln von Ereignissen mit Kombinieren</i></a> kurz, wie Ereignisse in Kombinieren empfangen und verarbeitet werden.  Die Einf√ºhrung ist gut. Sie zeigt, wie Sie einen Wert aus einem Textfeld extrahieren und in einem benutzerdefinierten Modellobjekt speichern.  Die Dokumentation zeigt auch die Verwendung von Operatoren, um einige erweiterte √Ñnderungen an dem betreffenden Stream vorzunehmen. <br><br><h2>  Beispiel </h2><br>  Fahren wir mit dem Ende der Dokumentation fort, wo das Codebeispiel lautet: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { ($<span class="hljs-number"><span class="hljs-number">0</span></span>.object <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSTextField</span></span>).stringValue } ) .assign(to: \<span class="hljs-type"><span class="hljs-type">MyViewModel</span></span>.filterString, on: myViewModel)</code> </pre> <br>  Ich habe ... viele Probleme damit. <br><br><h2>  Benachrichtigen Sie, dass es mir nicht gef√§llt </h2><br>  Die ersten beiden Zeilen werfen mir die meisten Fragen auf: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NotificationCenter</a> ist so etwas wie ein Anwendungsbus (oder sogar ein Systembus), in den viele Daten werfen oder vorbeifliegende Informationen abfangen k√∂nnen.  Diese L√∂sung geh√∂rt zur Kategorie "Alles f√ºr alle", wie von den Erstellern beabsichtigt.  Und es gibt wirklich viele Situationen, in denen Sie m√∂glicherweise herausfinden m√ºssen, ob die Tastatur nur ein- oder ausgeblendet wurde.  NotificationCenter ist eine gro√üartige M√∂glichkeit, diese Nachricht im gesamten System zu verteilen. <br><br>  Aber f√ºr mich ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NotificationCenter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code mit einer Drossel</a> .  Es gibt Zeiten (wie das Erhalten einer Benachrichtigung √ºber die Tastatur), in denen NotificationCenter tats√§chlich die <i>bestm√∂gliche</i> L√∂sung f√ºr das Problem ist.  Aber zu oft ist NotificationCenter f√ºr mich die <i>bequemste</i> L√∂sung.  Es ist wirklich sehr praktisch, etwas in NotificationCenter abzulegen und es an einer anderen Stelle in der Anwendung abzurufen. <br><br>  Dar√ºber hinaus ist das NotificationCenter vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typ "Zeichenfolge", dh</a> Sie k√∂nnen leicht den Fehler machen, welche Benachrichtigung Sie ver√∂ffentlichen oder anh√∂ren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten</a> .  Swift tut alles, um die Situation zu verbessern, aber immer noch liegt derselbe NSString unter der Haube. <br><br><h2>  √úber KVO </h2><br>  Auf der Apple-Plattform gibt es seit langem eine beliebte M√∂glichkeit, Benachrichtigungen √ºber √Ñnderungen in verschiedenen Teilen des Codes zu erhalten: Key-Value-Observation (KVO).  Apple beschreibt es so: <br><br><blockquote>  Dies ist ein Mechanismus, mit dem Objekte Benachrichtigungen √ºber √Ñnderungen an den angegebenen Eigenschaften anderer Objekte erhalten k√∂nnen. </blockquote><br>  Dank eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gui Rambo-Tweets</a> bemerkte ich, dass Apple Combine KVO-Bindungen hinzuf√ºgte.  Dies k√∂nnte bedeuten, dass ich die vielen Entt√§uschungen √ºber das Fehlen eines RxCocoa-Analogons in Combine loswerden k√∂nnte.  Wenn ich KVO verwenden kann, wird dies wahrscheinlich sozusagen die Notwendigkeit von CombineCocoa beseitigen. <br><br>  Ich habe versucht, ein Beispiel f√ºr die Verwendung von KVO zu finden, um einen Wert von einem <code>UITextField</code> und an die Konsole auszugeben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textField.publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \<span class="hljs-type"><span class="hljs-type">UITextField</span></span>.text) .sink(receiveCompletion: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) }, receiveValue: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Text field is currently \"\($0)\""</span></span>) })</code> </pre> <br>  Sieht gut aus, mach weiter? <br><br>  Nicht so schnell, Freunde. <br><br>  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unangenehme Wahrheit</a> vergessen: <br><br>  UIKit ist im Gro√üen und Ganzen nicht mit KVO kompatibel. <br><br>  Und ohne KVO-Unterst√ºtzung wird meine Idee nicht funktionieren.  Meine √úberpr√ºfungen haben dies best√§tigt: Der Code gibt nichts an die Konsole aus, wenn ich Text in das Feld eingebe. <br><br>  Meine Hoffnungen, die Notwendigkeit von UIKit-Bindungen loszuwerden, waren wundersch√∂n, aber nicht lange. <br><br><h2>  Reinigung </h2><br>  Ein weiteres Kombinationsproblem besteht darin, dass noch v√∂llig unklar ist, wo und wie Ressourcen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stornierbaren</a> Objekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freigegeben</a> werden sollen.  <i>Es scheint,</i> dass wir sie in Instanzvariablen speichern sollten.  Aber ich erinnere mich nicht, dass in der offiziellen Dokumentation etwas √ºber die Reinigung gesagt wurde. <br><br>  RxSwift hat eine schrecklich benannte, aber unglaublich praktische <a href="">DisposeBag</a> .  Es ist nicht weniger einfach, CancelBag in Combine zu erstellen, aber ich bin mir nicht ganz sicher, ob es in diesem Fall die beste L√∂sung ist. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Artikel werden</a> wir √ºber die Fehlerbehandlung in RxSwift und Combine sprechen, √ºber die Vor- und Nachteile beider Ans√§tze. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470117/">https://habr.com/ru/post/de470117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470101/index.html">Regelm√§√üige Avalonia</a></li>
<li><a href="../de470105/index.html">oktech Data Sense # 3: Empfehlungssysteme</a></li>
<li><a href="../de470107/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, September 2019</a></li>
<li><a href="../de470109/index.html">@ Pythonetc September 2019</a></li>
<li><a href="../de470113/index.html">Wie die In-Memory-Technologie Business Intelligence ver√§ndert hat</a></li>
<li><a href="../de470121/index.html">Firmenprogrammierschulen oder Einstieg in die IT</a></li>
<li><a href="../de470123/index.html">Yandex.Geldfinanzfalle</a></li>
<li><a href="../de470125/index.html">Beurteilen Sie den Code eines anderen nicht streng</a></li>
<li><a href="../de470127/index.html">Komponist mit langem Kurzzeitged√§chtnis</a></li>
<li><a href="../de470129/index.html">Deklarative Speicherverwaltung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>