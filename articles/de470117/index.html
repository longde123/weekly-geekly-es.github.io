<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏿 👩🏻‍🤝‍👨🏽 🙆🏻 Vorbereitungen für das Kombinieren 👨🏽‍🔧 🛀🏿 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor anderthalb Jahren habe ich RxSwift gelobt . Ich brauchte eine Weile, um es herauszufinden, aber als das passierte, gab es kein Zurück mehr. Jetzt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorbereitungen für das Kombinieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470117/"><img src="https://habrastorage.org/webt/km/8-/uo/km8-uov-j3m2rfjjsxscoyeh9bc.jpeg"><br><br>  Vor anderthalb Jahren habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxSwift gelobt</a> .  Ich brauchte eine Weile, um es herauszufinden, aber als das passierte, gab es kein Zurück mehr.  Jetzt hatte ich den besten Hammer der Welt und verdammt noch mal, wenn nicht alles um mich herum wie ein Nagel aussah. <br><br>  Apple stellte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Combine</a> Framework auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWDC</a> Summer Conference vor.  Auf den ersten Blick sieht es nach einer etwas besseren Version von RxSwift aus.  Bevor ich erklären kann, was mir daran gefällt und was nicht, müssen wir verstehen, welches Problem Combine lösen soll. <br><a name="habracut"></a><br><h2>  Reaktive Programmierung?  Na und? </h2><br>  Die ReactiveX-Community - zu der auch die RxSwift-Community gehört - erklärt ihre Essenz wie folgt: <br><br><blockquote>  API für asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  Und auch: <br><br><blockquote>  ReactiveX ist eine Kombination der besten Ideen aus den Entwurfsmustern Observer und Iterator sowie der funktionalen Programmierung. </blockquote><br>  Nun ... okay. <br><br>  Und was bedeutet das <i>wirklich</i> ? <br><br><h2>  Die Grundlagen </h2><br>  Um die Essenz der reaktiven Programmierung wirklich zu verstehen, finde ich es nützlich zu verstehen, wie wir dazu gekommen sind.  In diesem Artikel werde ich beschreiben, wie Sie vorhandene Typen in jeder modernen OOP-Sprache betrachten, verdrehen und dann zur reaktiven Programmierung gelangen können. <br><br>  In diesem Artikel werden wir uns schnell mit dem Dschungel befassen, was für das Verständnis der reaktiven Programmierung nicht <i>unbedingt</i> erforderlich ist. <br><br>  Ich halte dies jedoch für eine merkwürdige akademische Übung, insbesondere im Hinblick darauf, wie stark typisierte Sprachen uns zu neuen Entdeckungen führen können. <br><br>  Warten Sie also auf meine nächsten Beiträge, wenn Sie an neuen Details interessiert sind. <br><br><h2>  Aufzählbar </h2><br>  Die mir bekannte „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktive Programmierung</a> “ stammt aus der Sprache, in der ich einmal geschrieben habe - C #.  Die Prämisse selbst ist ganz einfach: <br><br>  <i>Was ist, wenn sie Ihnen die Werte selbst senden, anstatt Werte aus der Aufzählung zu extrahieren?</i> <br><br>  Diese Idee, "drücken statt ziehen", wurde am besten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Brian Beckman und Eric Meyer beschrieben.  Die ersten 36 Minuten ... Ich habe nichts verstanden, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ab der 36. Minute</a> wird es <i>wirklich</i> interessant. <br><br>  Kurz gesagt, lassen Sie uns die Idee einer linearen Gruppe von Objekten in Swift sowie eines Objekts, das über diese lineare Gruppe iterieren kann, neu formulieren.  Sie können dies tun, indem Sie diese gefälschten Swift-Protokolle definieren: <br><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ;     //    Array. protocol Enumerable { associatedtype Enum: Enumerator associatedtype Element where Self.Element == Self.Enum.Element func getEnumerator() -&gt; Self.Enum } // ,       . protocol Enumerator: Disposable { associatedtype Element func moveNext() throws -&gt; Bool var current: Element { get } } //          // Enumerator,         .   . protocol Disposable { func dispose() }</span></span></code> </pre> <br><h2>  Doppel </h2><br>  Lassen Sie uns alles umdrehen und <i>Doppel</i> machen.  Wir senden Daten dorthin, woher sie stammen.  Und holen Sie sich die Daten von dort, wo sie abgereist sind.  Es klingt absurd, aber ertrage es ein wenig. <br><br><h3>  Doppelte Aufzählung </h3><br>  Beginnen wir mit Enumerable: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerable { associatedtype Element where Self.Element == Self.Enum.Element associatedtype Enum: Enumerator func getEnumerator() -&gt; Self.Enum } protocol DualOfEnumerable { //  Enumerator : // getEnumerator() -&gt; Self.Enum //    : // getEnumerator(Void) -&gt; Enumerator // //  , : // : Void; : Enumerator // getEnumerator(Void) → Enumerator // //     Void   Enumerator. //   -      Enumerator,   Void. // :  Enumerator; : Void func subscribe(DualOfEnumerator) }</span></span></code> </pre> <br>  Da <code>getEnumerator()</code> <code>Void</code> nahm und <code>Enumerator</code> gab, akzeptieren wir jetzt den [double] <code>Enumerator</code> und geben <code>Void</code> . <br><br>  Ich weiß, dass das seltsam ist.  Geh nicht weg. <br><br><h3>  Doppelter Enumerator </h3><br>  Und was ist dann <code>DualOfEnumerator</code> ? <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  . protocol Enumerator: Disposable { associatedtype Element // : Void; : Bool, Error func moveNext() throws -&gt; Bool // : Void; : Element var current: Element { get } } protocol DualOfEnumerator { // : Bool, Error; : Void //   Error    func enumeratorIsDone(Bool) // : Element, : Void var nextElement: Element { set } }</span></span></code> </pre> <br>  Hier gibt es mehrere Probleme: <br><br><ul><li>  In Swift gibt es kein Konzept für eine Nur-Set-Eigenschaft. <br></li><li>  Was ist mit <code>throws</code> in <code>Enumerator.moveNext()</code> passiert? <br></li><li>  Was passiert mit <code>Disposable</code> ? <br></li></ul><br>  Um das Problem mit der Eigenschaft set-only zu beheben, können wir es als das behandeln, was es wirklich ist - eine Funktion.  Lassen Sie uns unseren <code>DualOfEnumerator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool; : Void, Error //   Error    func enumeratorIsDone(Bool) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Um das Problem mit <code>throws</code> zu lösen, trennen wir den Fehler, der in <code>moveNext()</code> und arbeiten damit als separate <code>error()</code> -Funktion: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// : Bool, Error; : Void func enumeratorIsDone(Bool) func error(Error) // : Element, : Void func next(Element) }</span></span></code> </pre> <br>  Wir können noch etwas anderes tun: Sehen Sie sich die Signatur des Abschlusses der Iteration an: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool)</span></span></span></span></code> </pre> <br>  Wahrscheinlich wird im Laufe der Zeit etwas Ähnliches passieren: <br><br><pre> <code class="swift hljs">enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) enumeratorIsDone(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     enumeratorIsDone(true)</span></span></code> </pre> <br>  Lassen Sie uns nun die Dinge vereinfachen und <code>enumeratorIsDone</code> nur aufrufen, wenn ... alles wirklich fertig ist.  Anhand dieser Idee vereinfachen wir den Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h3>  Pass auf uns auf </h3><br>  Was ist mit <code>Disposable</code> ?  Was soll man damit machen?  Da <code>Disposable</code> Teil <i>des</i> <code>Enumerator</code> <i>Typs ist</i> , sollte <i>der</i> <code>Enumerator</code> , wenn wir ihn <i>doppelt erhalten</i> , wahrscheinlich überhaupt nicht im <code>Enumerator</code> .  Stattdessen sollte es Teil von <code>DualOfEnumerable</code> .  Aber wo genau? <br><br>  <code>DualOfEnumerator</code> hier ein: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span></code> </pre> <br>  Wenn wir <code>DualOfEnumerator</code> akzeptieren, sollte <code>Disposable</code> dann nicht <i>zurückgegeben werden</i> ? <br><br>  Hier ist, was für ein Double du hast: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Nennen wir es eine Rose, aber nicht </h2><br>  Also, noch einmal, hier ist was wir haben: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DualOfEnumerator)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumeratorIsDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  Lassen Sie uns jetzt ein wenig mit den Namen spielen. <br><br>  Beginnen wir mit <code>DualOfEnumerator</code> .  Wir werden bessere Namen für die Funktionen finden, um genauer zu beschreiben, was passiert: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DualOfEnumerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre> <br>  So viel besser und verständlicher. <br><br>  Was ist mit Typnamen?  Sie sind einfach schrecklich.  Lassen Sie uns sie ein wenig ändern. <br><br><ul><li>  <code>DualOfEnumerator</code> - etwas, das folgt, was mit einer linearen Gruppe von Objekten passiert.  Wir können sagen, dass er eine lineare Gruppe <i>beobachtet</i> . <br></li><li>  <code>DualOfEnumerable</code> ist Gegenstand der Beobachtung.  Was wir sehen.  Daher kann es als <i>beobachtbar bezeichnet werden</i> . <br></li></ul><br>  Nehmen Sie nun die letzten Änderungen vor und erhalten Sie Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observer)</span></span></span></span> → <span class="hljs-type"><span class="hljs-type">Disposable</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Error)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Element)</span></span></span></span> }</code> </pre><br><h2>  Wow </h2><br>  Wir haben gerade zwei grundlegende Objekte in RxSwift erstellt.  Sie können ihre realen Versionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Beachten Sie, dass im Fall von Observer die drei <code>on()</code> -Funktionen zu einer <code>on(Event)</code> kombiniert werden, wobei <code>Event</code> eine Aufzählung ist, die bestimmt, was das Ereignis ist - Abschluss, nächster Wert oder Fehler. <br><br>  Diese beiden Typen liegen RxSwift und der reaktiven Programmierung zugrunde. <br><br><h2>  Über gefälschte Protokolle </h2><br>  Die beiden oben erwähnten "gefälschten" Protokolle sind eigentlich überhaupt nicht gefälscht.  Dies sind Analoga bestehender Typen in Swift: <br><br><ul><li>  Aufzählbar ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequenz</a> <br></li><li>  Enumerator ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iteratorsequenz</a> <br></li></ul><br><h2>  Na und? </h2><br>  Worüber sollten Sie sich also Sorgen machen? <br><br>  So viel in der modernen Entwicklung - <i>insbesondere in der</i> Anwendungsentwicklung - ist mit Asynchronität verbunden.  Der Benutzer klickte plötzlich auf eine Schaltfläche.  Der Benutzer hat plötzlich eine Registerkarte im UISegmentControl ausgewählt.  Der Benutzer hat plötzlich eine Registerkarte in der UITabBar ausgewählt.  Der Web-Socket gab uns plötzlich neue Informationen.  Dieser Download endete plötzlich - und schließlich -.  Diese Hintergrundaufgabe endete abrupt.  Diese Liste geht weiter und weiter. <br><br>  In der modernen CocoaTouch-Welt gibt es viele Möglichkeiten, mit solchen Ereignissen umzugehen: <br><br><ul><li>  Benachrichtigungen <br></li><li>  Rückrufe <br></li><li>  Schlüsselwertbeobachtung (KVO), <br></li><li>  Ziel- / Aktionsmechanismus. <br></li></ul><br>  Stellen <i>Sie sich vor, alles</i> könnte sich in einer einzigen Schnittstelle widerspiegeln.  Welches mit <i>jeder</i> Art von asynchronen Daten oder Ereignissen innerhalb der gesamten Anwendung arbeiten könnte. <br><br>  Stellen Sie sich nun vor, es gäbe eine ganze <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Funktionen</a> , mit denen Sie diese <i>Streams</i> ändern, von einem Typ in einen anderen konvertieren, Informationen aus Elementen extrahieren oder sie sogar mit anderen Streams kombinieren können. <br><br>  Plötzlich liegt in unseren Händen ein neues <i>universelles</i> Werkzeugset. <br>  Und so kehrten wir zum Anfang zurück: <br><br><blockquote>  API für asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  Dies macht RxSwift zu einem so leistungsstarken Tool.  Wie kombinieren. <br><br><h2>  Was weiter? </h2><br>  Wenn Sie mehr über RxSwift <i>in der Praxis</i> lesen möchten, empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine fünf Artikel aus dem Jahr 2016</a> .  Sie beschreiben die Erstellung einer einfachen CocoaTouch-Anwendung, gefolgt von einer schrittweisen Konvertierung in RxSwift. <br><br>  In einem der folgenden Artikel werde ich erklären, warum viele der in meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelserie für Anfänger</a> beschriebenen Techniken in Combine nicht anwendbar sind, und ich vergleiche Combine mit RxSwift. <br><br><h1>  Kombinieren: Was ist der Sinn? </h1><br>  Die Diskussion von Combine beinhaltet auch eine Diskussion der Hauptunterschiede zwischen ihm und RxSwift.  Für mich gibt es drei davon: <br><br><ul><li>  die Möglichkeit der Verwendung nicht reaktiver Klassen, <br></li><li>  Fehlerbehandlung <br></li><li>  Gegendruck. <br></li></ul><br>  Ich werde jedem Artikel einen eigenen Artikel widmen.  Ich werde mit dem ersten beginnen. <br><br><h2>  Eigenschaften von RxCocoa </h2><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem früheren Beitrag habe</a> ich gesagt, dass RxSwift mehr als ... RxSwift ist.  Es bietet zahlreiche Möglichkeiten für die Verwendung von Steuerelementen von UIKit im Typ-aber-nicht-ganz-Teilprojekt von RxCocoa.  Darüber hinaus ging <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxSwiftCommunity</a> noch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt</a> weiter und implementierte viele Bindungen für noch abgelegenere Nebenstraßen von UIKit sowie einige andere CocoaTouch-Klassen, die RxSwift und RxCocoa noch nicht abdecken. <br><br>  Daher ist es sehr einfach, einen <code>Observable</code> Stream zu erhalten, indem Sie beispielsweise auf UIButton klicken.  Ich werde dieses Beispiel noch einmal geben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Leichtgewichtler. <br><br><h2>  Lassen Sie uns (endlich) noch über Kombinieren sprechen </h2><br>  Combine ist RxSwift sehr ähnlich.  Wie die Dokumentation sagt: <br><br><blockquote>  Das Combine-Framework bietet eine deklarative Swift-API für die Verarbeitung von Werten im Zeitverlauf. </blockquote><br>  Klingt vertraut: Erinnern Sie sich an die Beschreibung von ReactiveX (dem übergeordneten Projekt für RxSwift): <br><br><blockquote>  API für asynchrone Programmierung mit beobachtbaren Threads. </blockquote><br>  In beiden Fällen wird dasselbe gesagt.  Es ist nur so, dass in der Beschreibung von ReactiveX bestimmte Begriffe verwendet werden.  Es kann wie folgt umformuliert werden: <br><br><blockquote>  Eine API für die asynchrone Programmierung mit Werten über die Zeit. </blockquote><br>  Fast das gleiche wie bei mir. <br><br><h2>  Gleich wie zuvor </h2><br>  Als ich mit der Analyse der API begann, wurde sofort klar, dass die meisten Typen, die ich von RxSwift kenne, ähnliche Optionen in Combine haben: <br><br><ul><li>  Beobachtbar → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verlag</a> <br></li><li>  Beobachter → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abonnent</a> <br></li><li>  Einweg → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stornierbar</a> .  Dies ist ein Triumph des Marketings.  Sie können sich nicht vorstellen, wie viele überraschte Blicke ich von unvoreingenommeneren Entwicklern erhalten habe, als ich anfing, Disposable in RxSwift zu beschreiben. <br></li><li>  SchedulerType → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler</a> <br></li></ul><br>  So weit so gut.  Ich mag Cancellable wieder viel mehr als Disposable.  Ein großartiger Ersatz, nicht nur in Bezug auf Marketing, sondern auch in Bezug auf eine genaue Beschreibung des Wesens des Objekts. <br><br>  Mehr ist noch besser! <br><br><ul><li>  RxCocoas Treiber -&gt; Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BindableObject</a> von SwiftUI <br></li></ul><br>  Dies ist nicht sofort klar, aber geistig dienen sie einem Zweck, und keiner von ihnen kann zu Fehlern führen. <br><br><ul><li>  Single → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zukunft</a> <br></li><li>  SubjectType → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subject</a> <br></li><li>  PublishSubject → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PassthroughSubject</a> <br></li></ul><br><h2>  "Pause für Kacke" </h2><br>  Alles ändert sich, sobald Sie sich mit RxCocoa beschäftigen.  Erinnern Sie sich an das obige Beispiel, in dem wir einen Observable-Stream erhalten wollten, der Klicks auf UIButton darstellt?  Da ist er: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disposeBag = <span class="hljs-type"><span class="hljs-type">DisposeBag</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-type"><span class="hljs-type">UIButton</span></span>() button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }) .disposed(by: disposeBag)</code> </pre> <br>  Kombinieren erfordert ... viel mehr Arbeit, um dasselbe zu tun. <br><br>  <b>Combine bietet keine Funktionen zum Binden an UIKit-Objekte.</b> <br><br>  Das ist ... nur ein unwirklicher Mist. <br><br>  Hier ist eine übliche Methode, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIControl.Event</a> mithilfe von Combine von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIControl abzurufen</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlPublisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIControl</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> = (control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span> = <span class="hljs-type"><span class="hljs-type">ControlEvent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span> = <span class="hljs-type"><span class="hljs-type">Never</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subject = <span class="hljs-type"><span class="hljs-type">PassthroughSubject</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Output</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">convenience</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, event: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: control, events: [event]) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(control: <span class="hljs-type"><span class="hljs-type">UIControl</span></span>, events: [<span class="hljs-type"><span class="hljs-type">UIControl</span></span>.<span class="hljs-type"><span class="hljs-type">Event</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events { control.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(controlAction), <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: event) } } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">controlAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIControl, forEvent event: UIControl.Event)</span></span></span></span> { subject.send(<span class="hljs-type"><span class="hljs-type">ControlEvent</span></span>(control: sender, event: event)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">&lt;S&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber: S)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span> : <span class="hljs-type"><span class="hljs-type">Subscriber</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>, <span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span> == <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span> { subject.receive(subscriber: subscriber) } }</code> </pre> <br>  Hier ... <i>viel</i> mehr Arbeit.  Zumindest sieht der Anruf so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ControlPublisher</span></span>(control: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button, event: .touchUpInside) .sink { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) }</code> </pre> <br>  Zum Vergleich: RxCocoa bietet einen angenehmen, leckeren Kakao in Form von Bindungen an UIKit-Objekte: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.button.rx.tap .subscribe(onNext: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap!"</span></span>) })</code> </pre> <br>  An sich sind diese Herausforderungen letztendlich wirklich sehr ähnlich.  Das einzig Frustrierende ist, dass ich <code>ControlPublisher</code> selbst schreiben musste, um an diesen Punkt zu gelangen.  Darüber hinaus sind RxSwift und RxCocoa sehr gut getestet und werden in Projekten viel mehr als in meinen verwendet. <br><br>  Zum Vergleich erschien mein <code>ControlPublisher</code> nur ... jetzt.  Nur aufgrund der Anzahl der Clients (Null) und der Nutzungszeit in der realen Welt (fast Null im Vergleich zu RxCocoa) kann mein Code als unendlich gefährlicher angesehen werden. <br><br>  Schade. <br><br><h2>  Gemeinschaftshilfe? </h2><br>  Ehrlich gesagt hindert nichts die Community daran, ein eigenes Open-Source-Programm „CombineCocoa“ zu erstellen, das die RxCocoa-Lücke genau wie die RxSwiftCommunity füllen würde. <br><br>  Ich halte dies jedoch für einen großen Nachteil von Combine.  Ich möchte nicht den gesamten RxCocoa neu schreiben, sondern nur Bindungen an UIKit-Objekte erhalten. <br><br>  Wenn ich mich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftUI</a> entscheide, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Problem des Mangels an Bindungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wahrscheinlich</a> dadurch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beseitigt</a> .  Sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine kleine Anwendung</a> enthält eine <i>Menge</i> UI-Code.  Das alles rauszuwerfen, nur um in den Kombinationszug zu springen, wäre zumindest dumm oder sogar gefährlich. <br><br>  Übrigens beschreibt der Artikel in der Dokumentation zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Empfangen und Behandeln von Ereignissen mit Kombinieren</i></a> kurz, wie Ereignisse in Kombinieren empfangen und verarbeitet werden.  Die Einführung ist gut. Sie zeigt, wie Sie einen Wert aus einem Textfeld extrahieren und in einem benutzerdefinierten Modellobjekt speichern.  Die Dokumentation zeigt auch die Verwendung von Operatoren, um einige erweiterte Änderungen an dem betreffenden Stream vorzunehmen. <br><br><h2>  Beispiel </h2><br>  Fahren wir mit dem Ende der Dokumentation fort, wo das Codebeispiel lautet: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { ($<span class="hljs-number"><span class="hljs-number">0</span></span>.object <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSTextField</span></span>).stringValue } ) .assign(to: \<span class="hljs-type"><span class="hljs-type">MyViewModel</span></span>.filterString, on: myViewModel)</code> </pre> <br>  Ich habe ... viele Probleme damit. <br><br><h2>  Benachrichtigen Sie, dass es mir nicht gefällt </h2><br>  Die ersten beiden Zeilen werfen mir die meisten Fragen auf: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> .publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">NSControl</span></span>.textDidChangeNotification, object: filterField)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NotificationCenter</a> ist so etwas wie ein Anwendungsbus (oder sogar ein Systembus), in den viele Daten werfen oder vorbeifliegende Informationen abfangen können.  Diese Lösung gehört zur Kategorie "Alles für alle", wie von den Erstellern beabsichtigt.  Und es gibt wirklich viele Situationen, in denen Sie möglicherweise herausfinden müssen, ob die Tastatur nur ein- oder ausgeblendet wurde.  NotificationCenter ist eine großartige Möglichkeit, diese Nachricht im gesamten System zu verteilen. <br><br>  Aber für mich ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NotificationCenter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code mit einer Drossel</a> .  Es gibt Zeiten (wie das Erhalten einer Benachrichtigung über die Tastatur), in denen NotificationCenter tatsächlich die <i>bestmögliche</i> Lösung für das Problem ist.  Aber zu oft ist NotificationCenter für mich die <i>bequemste</i> Lösung.  Es ist wirklich sehr praktisch, etwas in NotificationCenter abzulegen und es an einer anderen Stelle in der Anwendung abzurufen. <br><br>  Darüber hinaus ist das NotificationCenter vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typ "Zeichenfolge", dh</a> Sie können leicht den Fehler machen, welche Benachrichtigung Sie veröffentlichen oder anhören <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möchten</a> .  Swift tut alles, um die Situation zu verbessern, aber immer noch liegt derselbe NSString unter der Haube. <br><br><h2>  Über KVO </h2><br>  Auf der Apple-Plattform gibt es seit langem eine beliebte Möglichkeit, Benachrichtigungen über Änderungen in verschiedenen Teilen des Codes zu erhalten: Key-Value-Observation (KVO).  Apple beschreibt es so: <br><br><blockquote>  Dies ist ein Mechanismus, mit dem Objekte Benachrichtigungen über Änderungen an den angegebenen Eigenschaften anderer Objekte erhalten können. </blockquote><br>  Dank eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gui Rambo-Tweets</a> bemerkte ich, dass Apple Combine KVO-Bindungen hinzufügte.  Dies könnte bedeuten, dass ich die vielen Enttäuschungen über das Fehlen eines RxCocoa-Analogons in Combine loswerden könnte.  Wenn ich KVO verwenden kann, wird dies wahrscheinlich sozusagen die Notwendigkeit von CombineCocoa beseitigen. <br><br>  Ich habe versucht, ein Beispiel für die Verwendung von KVO zu finden, um einen Wert von einem <code>UITextField</code> und an die Konsole auszugeben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sub = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textField.publisher(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \<span class="hljs-type"><span class="hljs-type">UITextField</span></span>.text) .sink(receiveCompletion: { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) }, receiveValue: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Text field is currently \"\($0)\""</span></span>) })</code> </pre> <br>  Sieht gut aus, mach weiter? <br><br>  Nicht so schnell, Freunde. <br><br>  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unangenehme Wahrheit</a> vergessen: <br><br>  UIKit ist im Großen und Ganzen nicht mit KVO kompatibel. <br><br>  Und ohne KVO-Unterstützung wird meine Idee nicht funktionieren.  Meine Überprüfungen haben dies bestätigt: Der Code gibt nichts an die Konsole aus, wenn ich Text in das Feld eingebe. <br><br>  Meine Hoffnungen, die Notwendigkeit von UIKit-Bindungen loszuwerden, waren wunderschön, aber nicht lange. <br><br><h2>  Reinigung </h2><br>  Ein weiteres Kombinationsproblem besteht darin, dass noch völlig unklar ist, wo und wie Ressourcen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stornierbaren</a> Objekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freigegeben</a> werden sollen.  <i>Es scheint,</i> dass wir sie in Instanzvariablen speichern sollten.  Aber ich erinnere mich nicht, dass in der offiziellen Dokumentation etwas über die Reinigung gesagt wurde. <br><br>  RxSwift hat eine schrecklich benannte, aber unglaublich praktische <a href="">DisposeBag</a> .  Es ist nicht weniger einfach, CancelBag in Combine zu erstellen, aber ich bin mir nicht ganz sicher, ob es in diesem Fall die beste Lösung ist. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nächsten Artikel werden</a> wir über die Fehlerbehandlung in RxSwift und Combine sprechen, über die Vor- und Nachteile beider Ansätze. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470117/">https://habr.com/ru/post/de470117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470101/index.html">Regelmäßige Avalonia</a></li>
<li><a href="../de470105/index.html">oktech Data Sense # 3: Empfehlungssysteme</a></li>
<li><a href="../de470107/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, September 2019</a></li>
<li><a href="../de470109/index.html">@ Pythonetc September 2019</a></li>
<li><a href="../de470113/index.html">Wie die In-Memory-Technologie Business Intelligence verändert hat</a></li>
<li><a href="../de470121/index.html">Firmenprogrammierschulen oder Einstieg in die IT</a></li>
<li><a href="../de470123/index.html">Yandex.Geldfinanzfalle</a></li>
<li><a href="../de470125/index.html">Beurteilen Sie den Code eines anderen nicht streng</a></li>
<li><a href="../de470127/index.html">Komponist mit langem Kurzzeitgedächtnis</a></li>
<li><a href="../de470129/index.html">Deklarative Speicherverwaltung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>