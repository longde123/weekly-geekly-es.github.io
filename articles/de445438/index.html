<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏼 ✅ 📐 Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten 👰🏽 📷 🕴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwann musste ich mich dringend mit Webkomponenten vertraut machen und einen Weg finden, sie bequem zu entwickeln. Ich habe vor, eine Reihe von Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  Irgendwann musste ich mich dringend mit Webkomponenten vertraut machen und einen Weg finden, sie bequem zu entwickeln.  Ich habe vor, eine Reihe von Artikeln zu schreiben, die dies tun würden <br>  Organisieren Sie irgendwie das Wissen über Webkomponenten, lit-element und geben Sie anderen eine kurze Einführung in diese Technologie. <a name="habracut"></a>  Ich bin kein Experte für diese Technologie und nehme gerne Feedback entgegen. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lit-element</a> ist ein Wrapper (Basisvorlage) für native Webkomponenten.  Es implementiert viele bequeme Methoden, die nicht in der Spezifikation enthalten sind.  Aufgrund seiner Nähe zur nativen Implementierung zeigt lit-element in verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmarks</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich</a> zu anderen Ansätzen (Stand 02.06.2019) sehr gute Ergebnisse. </p><br><p>  Boni, die ich durch die Verwendung von lit-element als Basisklasse von Webkomponenten sehe: </p><br><ol><li>  Diese Technologie implementiert bereits die zweite Version und wurde „krank mit Kinderkrankheiten“, die den gerade erschienenen Instrumenten eigen sind. </li><li>  Die Montage kann sowohl mit Polymer als auch mit Webpack, Typoskript, Rollup usw. durchgeführt werden. Auf diese Weise können Sie lit-element problemlos in jedes moderne Projekt einbetten. </li><li>  Das beleuchtete Element verfügt über ein sehr praktisches System zum Arbeiten mit Eigenschaften, um Werte einzugeben, zu initiieren und zu konvertieren. </li><li>  lit-element implementiert fast die gleiche Logik wie die Reaktion, d.h.  Es bietet das Minimum - eine einzige Vorlage zum Erstellen von Komponenten und deren Rendering - und schränkt den Entwickler bei der Auswahl eines Ökosystems und zusätzlicher Bibliotheken nicht ein. </li></ol><br><p>  Erstellen Sie eine einfache Webkomponente für lit-element.  Wenden wir uns der Dokumentation zu.  Wir brauchen folgendes: </p><br><ol><li>  Fügen Sie unserer Baugruppe das npm-Paket mit lit-element hinzu <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Erstellen Sie unsere Komponente. </li></ol><br><p>  Zum Beispiel müssen wir eine Webkomponente erstellen, die im <code>my-component</code> Tag initialisiert ist.  Erstellen Sie dazu die js-Datei <code>my-component.js</code> und definieren Sie deren Grundvorlage: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Zuerst importieren wir unsere Basisvorlage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Zweitens erstellen Sie die Webkomponente selbst mit <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  Und das Letzte ist, die Webkomponente im Browser zu registrieren </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Als Ergebnis erhalten wir Folgendes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Wenn Sie die Notwendigkeit ausschließen, <code>my-component.js</code> mit HTML zu verbinden, dann ist es das.  Die einfachste Komponente ist fertig. </p><br><p>  Ich schlage vor, das Rad nicht neu zu erfinden und die fertige Montage des Rollups mit beleuchteten Elementen vorzunehmen.  Befolgen Sie die Anweisungen: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Nachdem alle Befehle ausgeführt wurden, gehen wir zur Seite im Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Wenn wir uns HTML ansehen, werden wir sehen, dass sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-loader.js</a> vor dem schließenden Tag befindet.  Dies ist ein Satz von Polyfüllungen für Webkomponenten, und für den browserübergreifenden Betrieb der Webkomponente ist es wünschenswert, dass diese Polyfüllung vorhanden ist.  Schauen wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tabelle der Browser an</a> , die alle Standards für die Arbeit mit Webkomponenten implementieren. Dort heißt es, dass EDGE die Standards immer noch nicht vollständig implementiert (ich schweige über IE11, das noch unterstützt werden muss). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  2 Optionen für diese Polyfüllung implementiert: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-bundle.js</a> - Diese Version enthält alle möglichen Optionen für die Polyfüllung. Sie werden alle initiiert, aber jede Polyfüllung funktioniert nur auf der Grundlage der erkannten Zeichen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-loader.js</a> ist ein minimaler Bootloader, der basierend auf den erkannten Symptomen die erforderlichen Polyfills lädt </li></ol><br><p>  Ich bitte Sie auch, auf eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfüllung</a> zu achten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">custom-elements-es5-adapter.js</a> .  Gemäß der Spezifikation können nur native ESE-Klassen zu ES6-Klassen hinzugefügt werden.  Für eine optimale Leistung sollte ES6-Code nur an Browser übergeben werden, die ihn unterstützen, und ES5 an alle anderen.  Dies ist nicht immer möglich. Aus Gründen der besseren Cross-Browser-Kompatibilität wird empfohlen, den gesamten ES6-Code in ES5 zu konvertieren.  In diesem Fall können die Webkomponenten von ES5 jedoch nicht in Browsern verwendet werden.  Um dieses Problem zu lösen, gibt es custom-elements-es5-adapter.js. </p><br><p>  Öffnen <code>./src/my-element.js</code> Datei <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Die lit-html-Vorlagen-Engine kann eine Zeichenfolge unterschiedlich verarbeiten.  Ich werde Ihnen mehrere Optionen geben: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Tipps zur Optimierung der Funktion render (): </p><br><ul><li>  darf den Zustand eines Elements nicht ändern, </li><li>  sollte keine Nebenwirkungen haben, </li><li>  sollte nur von den Eigenschaften des Elements abhängen, </li><li>  sollte das gleiche Ergebnis zurückgeben, wenn die gleichen Werte übertragen werden. </li></ul><br><p>  Aktualisieren Sie das DOM nicht außerhalb der Funktion render (). </p><br><p>  Lit-html ist für das Rendern des lit-Elements verantwortlich. Dies ist eine deklarative Methode, um zu beschreiben, wie die Webkomponente angezeigt werden soll.  lit-html garantiert schnelle Aktualisierungen, indem nur die Teile des DOM geändert werden, die geändert werden müssen. </p><br><p>  Fast der gesamte Code befand sich in einem einfachen Beispiel, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekorator</a> <code>@property</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> für die Eigenschaft <code>@property</code> hinzugefügt.  Dieser Dekorateur gibt an, dass wir in unserem <code>my-element</code> ein Attribut namens <code>myprop</code> erwarten.  Wenn kein solches Attribut festgelegt ist, wird der Zeichenfolgenwert standardmäßig auf <code>stuff</code> . </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  lit-element bietet zwei Möglichkeiten, mit <code>property</code> zu arbeiten: </p><br><ol><li>  Durch den Dekorateur. </li><li>  Über einen statischen Getter <code>properties</code> . </li></ol><br><p>  Die erste Option ermöglicht es, jede Eigenschaft separat anzugeben: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  Die zweite besteht darin, alles an einer Stelle anzugeben. In diesem Fall muss die Eigenschaft, wenn sie einen Standardwert hat, in die Klassenkonstruktormethode geschrieben werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  Die API für die Arbeit mit Eigenschaften in lit-element ist ziemlich umfangreich: </p><br><ul><li>  <b>Attribut</b> : Gibt an, ob eine Eigenschaft zu einem beobachtbaren Attribut werden kann.  Wenn <code>false</code> , wird das Attribut von der Beobachtung ausgeschlossen, und es wird kein Getter dafür erstellt.  Wenn <code>true</code> oder ein <code>attribute</code> fehlt, entspricht die im Getter im LowerCamelCase-Format angegebene Eigenschaft dem Attribut im Zeichenfolgenformat.  Wenn eine Zeichenfolge angegeben wird, z. B. <code>my-prop</code> , entspricht sie in den Attributen demselben Namen. </li><li>  <b>Konverter</b> : Enthält eine Beschreibung, wie ein Wert von / in ein Attribut / eine Eigenschaft konvertiert wird.  Der Wert kann eine Funktion sein, mit der der Wert serialisiert und deserialisiert werden kann, oder er kann ein Objekt mit den Schlüsseln <code>fromAttribute</code> und <code>toAttribute</code> . Diese Schlüssel enthalten separate Funktionen zum Konvertieren der Werte.  Standardmäßig enthält die Eigenschaft eine Konvertierung in die Basistypen <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> und <code>Array</code> .  Die Konvertierungsregeln sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> aufgelistet. </li><li>  <b>Typ</b> : Gibt einen der Basistypen an, die diese Eigenschaft enthalten wird.  Es wird als „Hinweis“ für den Konverter verwendet, welchen Typ die Eigenschaft enthalten soll. </li><li>  <b>Reflect</b> : Gibt an, ob das Attribut der Eigenschaft ( <code>true</code> ) zugeordnet und gemäß den Regeln von <code>type</code> und <code>converter</code> geändert werden soll. </li><li>  <b>hasChanged</b> : Jede Eigenschaft verfügt über eine Funktion, die bestimmt, ob zwischen dem alten und dem neuen Wert geändert wird, und einen <code>Boolean</code> Wert zurückgibt.  Wenn <code>true</code> , wird das Element aktualisiert. </li><li>  <b>noAccessor</b> : Diese Eigenschaft akzeptiert einen <code>Boolean</code> <b>Wert</b> und ist standardmäßig <code>false</code> .  Es verbietet die Erzeugung von Gettern und Setzern für jede Eigenschaft, um von der Klasse aus auf sie zuzugreifen.  Dadurch wird die Konvertierung nicht abgebrochen. </li></ul><br><p>  Lassen Sie uns ein hypothetisches Beispiel machen: Wir schreiben eine Webkomponente, die einen Parameter enthält, der eine Zeichenfolge enthält. Dieses Wort sollte auf dem Bildschirm gezeichnet werden, in dem jeder Buchstabe größer als der vorherige ist. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  Am Ende bekommen wir: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  Wenn auf die Schaltfläche geklickt wurde, wurde die Eigenschaft geändert, wodurch die Prüfung zuerst ausgelöst und dann zum erneuten Zeichnen gesendet wurde. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  und mit <code>reflect</code> wir auch HTML-Änderungen sehen </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Wenn Sie dieses Attribut mit Code außerhalb dieser Webkomponente ändern, wird auch die Webkomponente neu gezeichnet. </p><br><p>  Betrachten Sie nun das Styling der Komponente.  Wir haben zwei Möglichkeiten, lit-element zu stylen: </p><br><ol><li>  Styling durch Hinzufügen eines Style-Tags zur Rendermethode <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Über statische Getter- <code>styles</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  Als Ergebnis erhalten wir, dass ein Tag mit Stilen nicht erstellt, sondern gemäß der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> in das <code>Shadow DOM</code> Elements geschrieben wird ( <code>&gt;= Chrome 73</code> ).  Dies verbessert die Leistung bei einer großen Anzahl von Elementen, weil  Wenn er eine neue Komponente registriert, weiß er bereits, welche Eigenschaften seine Stile bestimmen. Sie müssen nicht jedes Mal registriert und nachgezählt werden. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  Wenn diese Spezifikation nicht unterstützt wird, wird in der Komponente ein reguläres <code>style</code> Tag erstellt. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Vergessen Sie außerdem nicht, dass wir auf diese Weise auch trennen können, welche Stile auf der Seite hinzugefügt und berechnet werden.  Zum Beispiel, um Medienabfragen nicht in CSS, sondern in JS zu verwenden und beispielsweise nur den gewünschten Stil zu implementieren (dies ist wild, muss es aber sein): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Dementsprechend wird dies angezeigt, wenn sich der Benutzer an einem Gerät mit einer Bildschirmbreite von mehr als 400 Pixel angemeldet hat. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  Dies ist der Fall, wenn der Benutzer die Site von einem Gerät mit einer Breite von weniger als 400 Pixel aus besucht hat. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Meine Meinung: Es gibt praktisch keinen angemessenen Fall, in dem ein Benutzer während der Arbeit an einem mobilen Gerät plötzlich einem vollwertigen Monitor mit einer Bildschirmbreite von 1920 Pixel gegenübersteht.  Hinzu kommt das verzögerte Laden von Komponenten.  Als Ergebnis erhalten wir eine sehr optimierte Front mit schnellem Komponenten-Rendering.  Das einzige Problem ist die Schwierigkeit bei der Unterstützung. </p><br><p>  Jetzt schlage ich vor, mich mit den Lebenszyklusmethoden von lit-element vertraut zu machen: </p><br><ul><li>  <b>render ()</b> : Implementiert eine Beschreibung des DOM-Elements mit <code>lit-html</code> .  Im Idealfall ist die <code>render</code> eine reine Funktion, die nur die aktuellen Eigenschaften des Elements verwendet.  Die <code>render()</code> -Methode wird von der <code>update()</code> -Funktion aufgerufen. </li><li>  <b>shouldUpdate (definedProperties)</b> : Wird implementiert, wenn die Aktualisierung und das Rendern gesteuert werden müssen, wenn Eigenschaften geändert wurden oder <code>requestUpdate()</code> aufgerufen wurde.  Das Argument für die Funktion " <code>changedProperties</code> ist eine <code>Map</code> mit Schlüsseln für die geänderten Eigenschaften.  Standardmäßig gibt diese Methode immer <code>true</code> , aber die Logik der Methode kann geändert werden, um die Aktualisierung der Komponente zu steuern. </li><li>  <b>performUpdate ()</b> : implementiert, um die Aktualisierungszeit zu steuern, z. B. um sie in den Scheduler zu integrieren. </li><li>  <b>update (definedProperties)</b> : Diese Methode ruft <code>render()</code> .  Außerdem werden die Attribute eines Elements entsprechend dem Wert der Eigenschaft aktualisiert.  Das Festlegen von Eigenschaften innerhalb dieser Methode führt nicht zu einem weiteren Update. </li><li>  <b>firstUpdated (definedProperties)</b> : <b>Wird</b> nach der ersten Aktualisierung des DOM-Elements unmittelbar vor dem Aufruf von update <code>updated()</code> aufgerufen.  Diese Methode kann nützlich sein, um Links zu visualisierten statischen Knoten zu erfassen, mit denen Sie direkt arbeiten müssen, z. B. in <code>updated()</code> . </li><li>  <b>aktualisiert (geänderte Eigenschaften)</b> : <b>Wird</b> aufgerufen, wenn das DOM eines Elements aktualisiert und angezeigt wird.  Eine Implementierung zum Ausführen von Aufgaben nach dem Aktualisieren über die DOM-API, z. B. mit Schwerpunkt auf einem Element. </li><li>  <b>requestUpdate (name, oldValue)</b> : <b>Ruft</b> eine asynchrone Aktualisierungsanforderung für ein Element auf.  Dies sollte aufgerufen werden, wenn das Element basierend auf einem Status aktualisiert werden muss, der nicht durch das Festlegen der Eigenschaft verursacht wird. </li><li>  <b>createRenderRoot ()</b> : <b>Erstellt</b> standardmäßig eine Schattenwurzel für das Element.  Wenn die Verwendung des Schatten-DOM nicht erforderlich ist, sollte die Methode <code>this</code> . </li></ul><br><p>  Wie wird das Element aktualisiert: </p><br><ul><li>  Die Eigenschaft erhält einen neuen Wert. </li><li>  Wenn die <code>hasChanged(value, oldValue)</code> <code>false</code> zurückgibt, wird das Element nicht aktualisiert.  Andernfalls wird ein Update durch Aufrufen von <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : Aktualisiert das Element nach der Mikrotask (am Ende der Ereignisschleife und vor dem nächsten Neuzeichnen). </li><li>  <b>performUpdate ()</b> : Das Update wird ausgeführt und mit dem Rest der Update-API fortgesetzt. </li><li>  <b>shouldUpdate (definedProperties)</b> : Das Update wird fortgesetzt, wenn <code>true</code> zurückgegeben wird. </li><li>  <b>firstUpdated (changedProperties)</b> : <b>Wird</b> aufgerufen, wenn das Element zum ersten Mal aktualisiert wird, unmittelbar bevor <b>update ()</b> aufgerufen wird. </li><li>  <b>update (definedProperties)</b> : Aktualisiert das Element.  Das Ändern von Eigenschaften in dieser Methode führt nicht zu einem weiteren Update. <br><ul><li>  <b>render ()</b> : Gibt eine <code>lit-html</code> Vorlage zum Rendern eines Elements im DOM zurück.  Das Ändern von Eigenschaften in dieser Methode führt nicht zu einem weiteren Update. </li></ul><br></li><li>  <b>aktualisiert (geänderte Eigenschaften)</b> : <b>Wird</b> aufgerufen, wenn ein Element aktualisiert wird. </li></ul><br><p>  Um alle Nuancen des Komponentenlebenszyklus zu verstehen, empfehle ich Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zu konsultieren. </p><br><p>  Bei der Arbeit habe ich ein Projekt zu Adobe Experience Manager (AEM), in dessen Authoring der Benutzer Komponenten per Drag &amp; Drop auf die Seite ziehen kann. Gemäß der AEM-Ideologie enthält diese Komponente ein <code>script</code> Tag, das alles enthält, was zur Implementierung der Logik dieser Komponente erforderlich ist.  Tatsächlich führte dieser Ansatz jedoch zu vielen blockierenden Ressourcen und Schwierigkeiten bei der Implementierung der Front in diesem System.  Um die Front zu implementieren, wurden Webkomponenten ausgewählt, um das serverseitige Rendering nicht zu ändern (was er sehr gut gemacht hat) und um die alte Implementierung mit einem neuen Ansatz sanft und bitweise zu bereichern.  Meiner Meinung nach gibt es mehrere Möglichkeiten, das Laden von Webkomponenten für dieses System zu implementieren: Sammeln Sie ein Bundle (es kann sehr groß werden) oder teilen Sie es in Blöcke auf (viele kleine Dateien, dynamisches Laden ist erforderlich), oder verwenden Sie den aktuellen Ansatz, bei dem jeweils ein Skript eingebettet wird eine Komponente, die auf der Serverseite gerendert wird (ich möchte wirklich nicht darauf zurückkommen).  Meiner Meinung nach ist die erste und dritte Option keine Option.  Für den zweiten benötigen Sie einen dynamischen Bootloader wie in der Schablone.  Für das beleuchtete Element in der "Box" ist dies jedoch nicht vorgesehen.  Es gab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Versuch</a> der Lit-Element-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, einen dynamischen Loader zu erstellen</a> , aber es ist ein Experiment, und es wird nicht empfohlen, ihn in der Produktion zu verwenden.  Auch von Lit-Element-Entwicklern gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository für Webkomponentenspezifikationen</a> mit dem Vorschlag, der Spezifikation die Möglichkeit hinzuzufügen, die erforderlichen JS für die Webkomponente basierend auf dem HTML-Markup auf der Seite dynamisch zu laden.  Meiner Meinung nach ist dieses native Tool eine sehr gute Idee, mit der Sie einen Initialisierungspunkt für Webkomponenten erstellen und ihn einfach allen Seiten der Website hinzufügen können. </p><br><p>  Um die Webkomponenten mit beleuchteten Elementen dynamisch mit den PolymerLabs-Mitarbeitern zu laden, wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Split-Element</a> entwickelt.  Dies ist eine experimentelle Lösung.  Es funktioniert folgendermaßen: </p><br><ul><li>  Um ein SplitElement zu erstellen, schreiben Sie zwei Elementdefinitionen in zwei Module. </li><li>  Einer davon ist ein Stub, der die geladenen Teile eines Elements definiert: Normalerweise sind dies der Name und die Eigenschaften.  Eigenschaften müssen mit einem Stub definiert werden, damit lit-element rechtzeitig beobachtbare Attribute generieren kann, um <code>customElements.define()</code> . </li><li>  Der Stub muss außerdem über eine statische asynchrone Lademethode verfügen, die eine Implementierungsklasse zurückgibt. </li><li>  Eine andere Klasse ist die "Implementierung", die alles andere enthält. </li><li>  Der <code>SplitElement</code> Konstruktor lädt die Implementierungsklasse und führt <code>upgrade()</code> . </li></ul><br><p>  Stub Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Implementierungsbeispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  SplitElement-Beispiel für ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Wenn Sie die oben im Rollup vorgeschlagene Assembly weiterhin verwenden, müssen Sie babel so einstellen, dass dynamische Importe verarbeitet werden können </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  Und in den .babelrc Einstellungen hinzufügen </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Hier habe ich ein kleines Beispiel für die Implementierung des verzögerten Ladens von Webkomponenten erstellt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  Ich habe versucht, den Ansatz des dynamischen Ladens von Webkomponenten anzuwenden, bin jedoch zu folgendem Ergebnis gekommen: Das Tool funktioniert recht gut. Sie müssen alle Definitionen von Webkomponenten in einer Datei sammeln und die Beschreibung der Komponente selbst separat durch Blöcke verbinden.  Ohne http2 funktioniert dieser Ansatz nicht, weil  Es entsteht ein sehr großer Pool kleiner Dateien, die die Komponenten beschreiben.  Basierend auf dem Prinzip des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomdesigns</a> muss der Import von Atomen im Körper bestimmt werden, aber der Körper muss bereits als separate Komponente verbunden sein.  Einer der Engpässe besteht darin, dass der Benutzer viele Definitionen von Benutzerelementen im Browser erhält, die auf die eine oder andere Weise im Browser initialisiert werden, und der Anfangszustand wird bestimmt.  Eine solche Lösung ist überflüssig.  Eine der Optionen für eine einfache Lösung für den Komponentenlader ist der folgende Algorithmus: </p><br><ol><li>  Erforderliche Dienstprogramme laden, </li><li>  Polyfills laden, </li><li>  Bauen Sie benutzerdefinierte Elemente aus Light DOM zusammen: <br><ol><li>  Alle DOM-Elemente, die einen Bindestrich im Tag-Namen enthalten, werden ausgewählt </li><li>  Die Liste wird gefiltert und eine Liste der ersten Elemente gebildet. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A night experimenting with Lit-HTML…</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445438/">https://habr.com/ru/post/de445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445426/index.html">Optimierung für die PostgreSQL-Serving-Rails-Anwendung</a></li>
<li><a href="../de445428/index.html">Hochwertiges WLAN - die Basis moderner Gastfreundschaft und der Motor des Geschäfts</a></li>
<li><a href="../de445432/index.html">Unity Package Manager</a></li>
<li><a href="../de445434/index.html">Bester schlechtester Job der Welt: Auf der Suche nach einem Habraautor</a></li>
<li><a href="../de445436/index.html">Umschulung in DevOps - worauf Sie sich vorbereiten müssen</a></li>
<li><a href="../de445440/index.html">Codeüberprüfung: schlechte Tipps für Mitwirkende und Prüfer</a></li>
<li><a href="../de445444/index.html">Hochleistungs-Solarmodul-Update von REC und Trina (Solar)</a></li>
<li><a href="../de445446/index.html">Wie wir die verzögerte Replikation für die Notfallwiederherstellung mit PostgreSQL verwendet haben</a></li>
<li><a href="../de445448/index.html">Konfigurieren des automatischen Empfangs von Letsencrypt-Zertifikaten mit Docker unter Linux</a></li>
<li><a href="../de445450/index.html">Browser-Erweiterung für toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>