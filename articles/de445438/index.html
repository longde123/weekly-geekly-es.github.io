<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèº ‚úÖ üìê Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten üë∞üèΩ üì∑ üï¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwann musste ich mich dringend mit Webkomponenten vertraut machen und einen Weg finden, sie bequem zu entwickeln. Ich habe vor, eine Reihe von Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  Irgendwann musste ich mich dringend mit Webkomponenten vertraut machen und einen Weg finden, sie bequem zu entwickeln.  Ich habe vor, eine Reihe von Artikeln zu schreiben, die dies tun w√ºrden <br>  Organisieren Sie irgendwie das Wissen √ºber Webkomponenten, lit-element und geben Sie anderen eine kurze Einf√ºhrung in diese Technologie. <a name="habracut"></a>  Ich bin kein Experte f√ºr diese Technologie und nehme gerne Feedback entgegen. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lit-element</a> ist ein Wrapper (Basisvorlage) f√ºr native Webkomponenten.  Es implementiert viele bequeme Methoden, die nicht in der Spezifikation enthalten sind.  Aufgrund seiner N√§he zur nativen Implementierung zeigt lit-element in verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmarks</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich</a> zu anderen Ans√§tzen (Stand 02.06.2019) sehr gute Ergebnisse. </p><br><p>  Boni, die ich durch die Verwendung von lit-element als Basisklasse von Webkomponenten sehe: </p><br><ol><li>  Diese Technologie implementiert bereits die zweite Version und wurde ‚Äûkrank mit Kinderkrankheiten‚Äú, die den gerade erschienenen Instrumenten eigen sind. </li><li>  Die Montage kann sowohl mit Polymer als auch mit Webpack, Typoskript, Rollup usw. durchgef√ºhrt werden. Auf diese Weise k√∂nnen Sie lit-element problemlos in jedes moderne Projekt einbetten. </li><li>  Das beleuchtete Element verf√ºgt √ºber ein sehr praktisches System zum Arbeiten mit Eigenschaften, um Werte einzugeben, zu initiieren und zu konvertieren. </li><li>  lit-element implementiert fast die gleiche Logik wie die Reaktion, d.h.  Es bietet das Minimum - eine einzige Vorlage zum Erstellen von Komponenten und deren Rendering - und schr√§nkt den Entwickler bei der Auswahl eines √ñkosystems und zus√§tzlicher Bibliotheken nicht ein. </li></ol><br><p>  Erstellen Sie eine einfache Webkomponente f√ºr lit-element.  Wenden wir uns der Dokumentation zu.  Wir brauchen folgendes: </p><br><ol><li>  F√ºgen Sie unserer Baugruppe das npm-Paket mit lit-element hinzu <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Erstellen Sie unsere Komponente. </li></ol><br><p>  Zum Beispiel m√ºssen wir eine Webkomponente erstellen, die im <code>my-component</code> Tag initialisiert ist.  Erstellen Sie dazu die js-Datei <code>my-component.js</code> und definieren Sie deren Grundvorlage: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Zuerst importieren wir unsere Basisvorlage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Zweitens erstellen Sie die Webkomponente selbst mit <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  Und das Letzte ist, die Webkomponente im Browser zu registrieren </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Als Ergebnis erhalten wir Folgendes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Wenn Sie die Notwendigkeit ausschlie√üen, <code>my-component.js</code> mit HTML zu verbinden, dann ist es das.  Die einfachste Komponente ist fertig. </p><br><p>  Ich schlage vor, das Rad nicht neu zu erfinden und die fertige Montage des Rollups mit beleuchteten Elementen vorzunehmen.  Befolgen Sie die Anweisungen: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Nachdem alle Befehle ausgef√ºhrt wurden, gehen wir zur Seite im Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Wenn wir uns HTML ansehen, werden wir sehen, dass sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-loader.js</a> vor dem schlie√üenden Tag befindet.  Dies ist ein Satz von Polyf√ºllungen f√ºr Webkomponenten, und f√ºr den browser√ºbergreifenden Betrieb der Webkomponente ist es w√ºnschenswert, dass diese Polyf√ºllung vorhanden ist.  Schauen wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tabelle der Browser an</a> , die alle Standards f√ºr die Arbeit mit Webkomponenten implementieren. Dort hei√üt es, dass EDGE die Standards immer noch nicht vollst√§ndig implementiert (ich schweige √ºber IE11, das noch unterst√ºtzt werden muss). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  2 Optionen f√ºr diese Polyf√ºllung implementiert: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-bundle.js</a> - Diese Version enth√§lt alle m√∂glichen Optionen f√ºr die Polyf√ºllung. Sie werden alle initiiert, aber jede Polyf√ºllung funktioniert nur auf der Grundlage der erkannten Zeichen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webcomponents-loader.js</a> ist ein minimaler Bootloader, der basierend auf den erkannten Symptomen die erforderlichen Polyfills l√§dt </li></ol><br><p>  Ich bitte Sie auch, auf eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyf√ºllung</a> zu achten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">custom-elements-es5-adapter.js</a> .  Gem√§√ü der Spezifikation k√∂nnen nur native ESE-Klassen zu ES6-Klassen hinzugef√ºgt werden.  F√ºr eine optimale Leistung sollte ES6-Code nur an Browser √ºbergeben werden, die ihn unterst√ºtzen, und ES5 an alle anderen.  Dies ist nicht immer m√∂glich. Aus Gr√ºnden der besseren Cross-Browser-Kompatibilit√§t wird empfohlen, den gesamten ES6-Code in ES5 zu konvertieren.  In diesem Fall k√∂nnen die Webkomponenten von ES5 jedoch nicht in Browsern verwendet werden.  Um dieses Problem zu l√∂sen, gibt es custom-elements-es5-adapter.js. </p><br><p>  √ñffnen <code>./src/my-element.js</code> Datei <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Die lit-html-Vorlagen-Engine kann eine Zeichenfolge unterschiedlich verarbeiten.  Ich werde Ihnen mehrere Optionen geben: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Tipps zur Optimierung der Funktion render (): </p><br><ul><li>  darf den Zustand eines Elements nicht √§ndern, </li><li>  sollte keine Nebenwirkungen haben, </li><li>  sollte nur von den Eigenschaften des Elements abh√§ngen, </li><li>  sollte das gleiche Ergebnis zur√ºckgeben, wenn die gleichen Werte √ºbertragen werden. </li></ul><br><p>  Aktualisieren Sie das DOM nicht au√üerhalb der Funktion render (). </p><br><p>  Lit-html ist f√ºr das Rendern des lit-Elements verantwortlich. Dies ist eine deklarative Methode, um zu beschreiben, wie die Webkomponente angezeigt werden soll.  lit-html garantiert schnelle Aktualisierungen, indem nur die Teile des DOM ge√§ndert werden, die ge√§ndert werden m√ºssen. </p><br><p>  Fast der gesamte Code befand sich in einem einfachen Beispiel, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekorator</a> <code>@property</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> f√ºr die Eigenschaft <code>@property</code> hinzugef√ºgt.  Dieser Dekorateur gibt an, dass wir in unserem <code>my-element</code> ein Attribut namens <code>myprop</code> erwarten.  Wenn kein solches Attribut festgelegt ist, wird der Zeichenfolgenwert standardm√§√üig auf <code>stuff</code> . </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  lit-element bietet zwei M√∂glichkeiten, mit <code>property</code> zu arbeiten: </p><br><ol><li>  Durch den Dekorateur. </li><li>  √úber einen statischen Getter <code>properties</code> . </li></ol><br><p>  Die erste Option erm√∂glicht es, jede Eigenschaft separat anzugeben: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  Die zweite besteht darin, alles an einer Stelle anzugeben. In diesem Fall muss die Eigenschaft, wenn sie einen Standardwert hat, in die Klassenkonstruktormethode geschrieben werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  Die API f√ºr die Arbeit mit Eigenschaften in lit-element ist ziemlich umfangreich: </p><br><ul><li>  <b>Attribut</b> : Gibt an, ob eine Eigenschaft zu einem beobachtbaren Attribut werden kann.  Wenn <code>false</code> , wird das Attribut von der Beobachtung ausgeschlossen, und es wird kein Getter daf√ºr erstellt.  Wenn <code>true</code> oder ein <code>attribute</code> fehlt, entspricht die im Getter im LowerCamelCase-Format angegebene Eigenschaft dem Attribut im Zeichenfolgenformat.  Wenn eine Zeichenfolge angegeben wird, z. B. <code>my-prop</code> , entspricht sie in den Attributen demselben Namen. </li><li>  <b>Konverter</b> : Enth√§lt eine Beschreibung, wie ein Wert von / in ein Attribut / eine Eigenschaft konvertiert wird.  Der Wert kann eine Funktion sein, mit der der Wert serialisiert und deserialisiert werden kann, oder er kann ein Objekt mit den Schl√ºsseln <code>fromAttribute</code> und <code>toAttribute</code> . Diese Schl√ºssel enthalten separate Funktionen zum Konvertieren der Werte.  Standardm√§√üig enth√§lt die Eigenschaft eine Konvertierung in die Basistypen <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> und <code>Array</code> .  Die Konvertierungsregeln sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> aufgelistet. </li><li>  <b>Typ</b> : Gibt einen der Basistypen an, die diese Eigenschaft enthalten wird.  Es wird als ‚ÄûHinweis‚Äú f√ºr den Konverter verwendet, welchen Typ die Eigenschaft enthalten soll. </li><li>  <b>Reflect</b> : Gibt an, ob das Attribut der Eigenschaft ( <code>true</code> ) zugeordnet und gem√§√ü den Regeln von <code>type</code> und <code>converter</code> ge√§ndert werden soll. </li><li>  <b>hasChanged</b> : Jede Eigenschaft verf√ºgt √ºber eine Funktion, die bestimmt, ob zwischen dem alten und dem neuen Wert ge√§ndert wird, und einen <code>Boolean</code> Wert zur√ºckgibt.  Wenn <code>true</code> , wird das Element aktualisiert. </li><li>  <b>noAccessor</b> : Diese Eigenschaft akzeptiert einen <code>Boolean</code> <b>Wert</b> und ist standardm√§√üig <code>false</code> .  Es verbietet die Erzeugung von Gettern und Setzern f√ºr jede Eigenschaft, um von der Klasse aus auf sie zuzugreifen.  Dadurch wird die Konvertierung nicht abgebrochen. </li></ul><br><p>  Lassen Sie uns ein hypothetisches Beispiel machen: Wir schreiben eine Webkomponente, die einen Parameter enth√§lt, der eine Zeichenfolge enth√§lt. Dieses Wort sollte auf dem Bildschirm gezeichnet werden, in dem jeder Buchstabe gr√∂√üer als der vorherige ist. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  Am Ende bekommen wir: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  Wenn auf die Schaltfl√§che geklickt wurde, wurde die Eigenschaft ge√§ndert, wodurch die Pr√ºfung zuerst ausgel√∂st und dann zum erneuten Zeichnen gesendet wurde. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  und mit <code>reflect</code> wir auch HTML-√Ñnderungen sehen </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Wenn Sie dieses Attribut mit Code au√üerhalb dieser Webkomponente √§ndern, wird auch die Webkomponente neu gezeichnet. </p><br><p>  Betrachten Sie nun das Styling der Komponente.  Wir haben zwei M√∂glichkeiten, lit-element zu stylen: </p><br><ol><li>  Styling durch Hinzuf√ºgen eines Style-Tags zur Rendermethode <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  √úber statische Getter- <code>styles</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  Als Ergebnis erhalten wir, dass ein Tag mit Stilen nicht erstellt, sondern gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> in das <code>Shadow DOM</code> Elements geschrieben wird ( <code>&gt;= Chrome 73</code> ).  Dies verbessert die Leistung bei einer gro√üen Anzahl von Elementen, weil  Wenn er eine neue Komponente registriert, wei√ü er bereits, welche Eigenschaften seine Stile bestimmen. Sie m√ºssen nicht jedes Mal registriert und nachgez√§hlt werden. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  Wenn diese Spezifikation nicht unterst√ºtzt wird, wird in der Komponente ein regul√§res <code>style</code> Tag erstellt. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Vergessen Sie au√üerdem nicht, dass wir auf diese Weise auch trennen k√∂nnen, welche Stile auf der Seite hinzugef√ºgt und berechnet werden.  Zum Beispiel, um Medienabfragen nicht in CSS, sondern in JS zu verwenden und beispielsweise nur den gew√ºnschten Stil zu implementieren (dies ist wild, muss es aber sein): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Dementsprechend wird dies angezeigt, wenn sich der Benutzer an einem Ger√§t mit einer Bildschirmbreite von mehr als 400 Pixel angemeldet hat. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  Dies ist der Fall, wenn der Benutzer die Site von einem Ger√§t mit einer Breite von weniger als 400 Pixel aus besucht hat. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Meine Meinung: Es gibt praktisch keinen angemessenen Fall, in dem ein Benutzer w√§hrend der Arbeit an einem mobilen Ger√§t pl√∂tzlich einem vollwertigen Monitor mit einer Bildschirmbreite von 1920 Pixel gegen√ºbersteht.  Hinzu kommt das verz√∂gerte Laden von Komponenten.  Als Ergebnis erhalten wir eine sehr optimierte Front mit schnellem Komponenten-Rendering.  Das einzige Problem ist die Schwierigkeit bei der Unterst√ºtzung. </p><br><p>  Jetzt schlage ich vor, mich mit den Lebenszyklusmethoden von lit-element vertraut zu machen: </p><br><ul><li>  <b>render ()</b> : Implementiert eine Beschreibung des DOM-Elements mit <code>lit-html</code> .  Im Idealfall ist die <code>render</code> eine reine Funktion, die nur die aktuellen Eigenschaften des Elements verwendet.  Die <code>render()</code> -Methode wird von der <code>update()</code> -Funktion aufgerufen. </li><li>  <b>shouldUpdate (definedProperties)</b> : Wird implementiert, wenn die Aktualisierung und das Rendern gesteuert werden m√ºssen, wenn Eigenschaften ge√§ndert wurden oder <code>requestUpdate()</code> aufgerufen wurde.  Das Argument f√ºr die Funktion " <code>changedProperties</code> ist eine <code>Map</code> mit Schl√ºsseln f√ºr die ge√§nderten Eigenschaften.  Standardm√§√üig gibt diese Methode immer <code>true</code> , aber die Logik der Methode kann ge√§ndert werden, um die Aktualisierung der Komponente zu steuern. </li><li>  <b>performUpdate ()</b> : implementiert, um die Aktualisierungszeit zu steuern, z. B. um sie in den Scheduler zu integrieren. </li><li>  <b>update (definedProperties)</b> : Diese Methode ruft <code>render()</code> .  Au√üerdem werden die Attribute eines Elements entsprechend dem Wert der Eigenschaft aktualisiert.  Das Festlegen von Eigenschaften innerhalb dieser Methode f√ºhrt nicht zu einem weiteren Update. </li><li>  <b>firstUpdated (definedProperties)</b> : <b>Wird</b> nach der ersten Aktualisierung des DOM-Elements unmittelbar vor dem Aufruf von update <code>updated()</code> aufgerufen.  Diese Methode kann n√ºtzlich sein, um Links zu visualisierten statischen Knoten zu erfassen, mit denen Sie direkt arbeiten m√ºssen, z. B. in <code>updated()</code> . </li><li>  <b>aktualisiert (ge√§nderte Eigenschaften)</b> : <b>Wird</b> aufgerufen, wenn das DOM eines Elements aktualisiert und angezeigt wird.  Eine Implementierung zum Ausf√ºhren von Aufgaben nach dem Aktualisieren √ºber die DOM-API, z. B. mit Schwerpunkt auf einem Element. </li><li>  <b>requestUpdate (name, oldValue)</b> : <b>Ruft</b> eine asynchrone Aktualisierungsanforderung f√ºr ein Element auf.  Dies sollte aufgerufen werden, wenn das Element basierend auf einem Status aktualisiert werden muss, der nicht durch das Festlegen der Eigenschaft verursacht wird. </li><li>  <b>createRenderRoot ()</b> : <b>Erstellt</b> standardm√§√üig eine Schattenwurzel f√ºr das Element.  Wenn die Verwendung des Schatten-DOM nicht erforderlich ist, sollte die Methode <code>this</code> . </li></ul><br><p>  Wie wird das Element aktualisiert: </p><br><ul><li>  Die Eigenschaft erh√§lt einen neuen Wert. </li><li>  Wenn die <code>hasChanged(value, oldValue)</code> <code>false</code> zur√ºckgibt, wird das Element nicht aktualisiert.  Andernfalls wird ein Update durch Aufrufen von <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : Aktualisiert das Element nach der Mikrotask (am Ende der Ereignisschleife und vor dem n√§chsten Neuzeichnen). </li><li>  <b>performUpdate ()</b> : Das Update wird ausgef√ºhrt und mit dem Rest der Update-API fortgesetzt. </li><li>  <b>shouldUpdate (definedProperties)</b> : Das Update wird fortgesetzt, wenn <code>true</code> zur√ºckgegeben wird. </li><li>  <b>firstUpdated (changedProperties)</b> : <b>Wird</b> aufgerufen, wenn das Element zum ersten Mal aktualisiert wird, unmittelbar bevor <b>update ()</b> aufgerufen wird. </li><li>  <b>update (definedProperties)</b> : Aktualisiert das Element.  Das √Ñndern von Eigenschaften in dieser Methode f√ºhrt nicht zu einem weiteren Update. <br><ul><li>  <b>render ()</b> : Gibt eine <code>lit-html</code> Vorlage zum Rendern eines Elements im DOM zur√ºck.  Das √Ñndern von Eigenschaften in dieser Methode f√ºhrt nicht zu einem weiteren Update. </li></ul><br></li><li>  <b>aktualisiert (ge√§nderte Eigenschaften)</b> : <b>Wird</b> aufgerufen, wenn ein Element aktualisiert wird. </li></ul><br><p>  Um alle Nuancen des Komponentenlebenszyklus zu verstehen, empfehle ich Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zu konsultieren. </p><br><p>  Bei der Arbeit habe ich ein Projekt zu Adobe Experience Manager (AEM), in dessen Authoring der Benutzer Komponenten per Drag &amp; Drop auf die Seite ziehen kann. Gem√§√ü der AEM-Ideologie enth√§lt diese Komponente ein <code>script</code> Tag, das alles enth√§lt, was zur Implementierung der Logik dieser Komponente erforderlich ist.  Tats√§chlich f√ºhrte dieser Ansatz jedoch zu vielen blockierenden Ressourcen und Schwierigkeiten bei der Implementierung der Front in diesem System.  Um die Front zu implementieren, wurden Webkomponenten ausgew√§hlt, um das serverseitige Rendering nicht zu √§ndern (was er sehr gut gemacht hat) und um die alte Implementierung mit einem neuen Ansatz sanft und bitweise zu bereichern.  Meiner Meinung nach gibt es mehrere M√∂glichkeiten, das Laden von Webkomponenten f√ºr dieses System zu implementieren: Sammeln Sie ein Bundle (es kann sehr gro√ü werden) oder teilen Sie es in Bl√∂cke auf (viele kleine Dateien, dynamisches Laden ist erforderlich), oder verwenden Sie den aktuellen Ansatz, bei dem jeweils ein Skript eingebettet wird eine Komponente, die auf der Serverseite gerendert wird (ich m√∂chte wirklich nicht darauf zur√ºckkommen).  Meiner Meinung nach ist die erste und dritte Option keine Option.  F√ºr den zweiten ben√∂tigen Sie einen dynamischen Bootloader wie in der Schablone.  F√ºr das beleuchtete Element in der "Box" ist dies jedoch nicht vorgesehen.  Es gab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Versuch</a> der Lit-Element-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, einen dynamischen Loader zu erstellen</a> , aber es ist ein Experiment, und es wird nicht empfohlen, ihn in der Produktion zu verwenden.  Auch von Lit-Element-Entwicklern gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository f√ºr Webkomponentenspezifikationen</a> mit dem Vorschlag, der Spezifikation die M√∂glichkeit hinzuzuf√ºgen, die erforderlichen JS f√ºr die Webkomponente basierend auf dem HTML-Markup auf der Seite dynamisch zu laden.  Meiner Meinung nach ist dieses native Tool eine sehr gute Idee, mit der Sie einen Initialisierungspunkt f√ºr Webkomponenten erstellen und ihn einfach allen Seiten der Website hinzuf√ºgen k√∂nnen. </p><br><p>  Um die Webkomponenten mit beleuchteten Elementen dynamisch mit den PolymerLabs-Mitarbeitern zu laden, wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Split-Element</a> entwickelt.  Dies ist eine experimentelle L√∂sung.  Es funktioniert folgenderma√üen: </p><br><ul><li>  Um ein SplitElement zu erstellen, schreiben Sie zwei Elementdefinitionen in zwei Module. </li><li>  Einer davon ist ein Stub, der die geladenen Teile eines Elements definiert: Normalerweise sind dies der Name und die Eigenschaften.  Eigenschaften m√ºssen mit einem Stub definiert werden, damit lit-element rechtzeitig beobachtbare Attribute generieren kann, um <code>customElements.define()</code> . </li><li>  Der Stub muss au√üerdem √ºber eine statische asynchrone Lademethode verf√ºgen, die eine Implementierungsklasse zur√ºckgibt. </li><li>  Eine andere Klasse ist die "Implementierung", die alles andere enth√§lt. </li><li>  Der <code>SplitElement</code> Konstruktor l√§dt die Implementierungsklasse und f√ºhrt <code>upgrade()</code> . </li></ul><br><p>  Stub Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Implementierungsbeispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  SplitElement-Beispiel f√ºr ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Wenn Sie die oben im Rollup vorgeschlagene Assembly weiterhin verwenden, m√ºssen Sie babel so einstellen, dass dynamische Importe verarbeitet werden k√∂nnen </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  Und in den .babelrc Einstellungen hinzuf√ºgen </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Hier habe ich ein kleines Beispiel f√ºr die Implementierung des verz√∂gerten Ladens von Webkomponenten erstellt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  Ich habe versucht, den Ansatz des dynamischen Ladens von Webkomponenten anzuwenden, bin jedoch zu folgendem Ergebnis gekommen: Das Tool funktioniert recht gut. Sie m√ºssen alle Definitionen von Webkomponenten in einer Datei sammeln und die Beschreibung der Komponente selbst separat durch Bl√∂cke verbinden.  Ohne http2 funktioniert dieser Ansatz nicht, weil  Es entsteht ein sehr gro√üer Pool kleiner Dateien, die die Komponenten beschreiben.  Basierend auf dem Prinzip des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomdesigns</a> muss der Import von Atomen im K√∂rper bestimmt werden, aber der K√∂rper muss bereits als separate Komponente verbunden sein.  Einer der Engp√§sse besteht darin, dass der Benutzer viele Definitionen von Benutzerelementen im Browser erh√§lt, die auf die eine oder andere Weise im Browser initialisiert werden, und der Anfangszustand wird bestimmt.  Eine solche L√∂sung ist √ºberfl√ºssig.  Eine der Optionen f√ºr eine einfache L√∂sung f√ºr den Komponentenlader ist der folgende Algorithmus: </p><br><ol><li>  Erforderliche Dienstprogramme laden, </li><li>  Polyfills laden, </li><li>  Bauen Sie benutzerdefinierte Elemente aus Light DOM zusammen: <br><ol><li>  Alle DOM-Elemente, die einen Bindestrich im Tag-Namen enthalten, werden ausgew√§hlt </li><li>  Die Liste wird gefiltert und eine Liste der ersten Elemente gebildet. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A night experimenting with Lit-HTML‚Ä¶</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445438/">https://habr.com/ru/post/de445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445426/index.html">Optimierung f√ºr die PostgreSQL-Serving-Rails-Anwendung</a></li>
<li><a href="../de445428/index.html">Hochwertiges WLAN - die Basis moderner Gastfreundschaft und der Motor des Gesch√§fts</a></li>
<li><a href="../de445432/index.html">Unity Package Manager</a></li>
<li><a href="../de445434/index.html">Bester schlechtester Job der Welt: Auf der Suche nach einem Habraautor</a></li>
<li><a href="../de445436/index.html">Umschulung in DevOps - worauf Sie sich vorbereiten m√ºssen</a></li>
<li><a href="../de445440/index.html">Code√ºberpr√ºfung: schlechte Tipps f√ºr Mitwirkende und Pr√ºfer</a></li>
<li><a href="../de445444/index.html">Hochleistungs-Solarmodul-Update von REC und Trina (Solar)</a></li>
<li><a href="../de445446/index.html">Wie wir die verz√∂gerte Replikation f√ºr die Notfallwiederherstellung mit PostgreSQL verwendet haben</a></li>
<li><a href="../de445448/index.html">Konfigurieren des automatischen Empfangs von Letsencrypt-Zertifikaten mit Docker unter Linux</a></li>
<li><a href="../de445450/index.html">Browser-Erweiterung f√ºr toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>