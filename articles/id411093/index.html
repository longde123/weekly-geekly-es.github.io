<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¨ üí• ‚óÄÔ∏è Panel kontrol terpusat untuk sumber pencahayaan Rotor TsPKIO-2D üëà ‚û°Ô∏è ‚õîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maaf, saya belum lama bersenang-senang dengan penamaan, serta periferal untuk otomatisasi rumah. Khususnya, benda ini - remote control lampu - ternyat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panel kontrol terpusat untuk sumber pencahayaan Rotor TsPKIO-2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411093/"><img src="https://habrastorage.org/getpro/geektimes/post_images/72f/6a9/ceb/72f6a9ceb826b19cdb266c3d334da65b.jpg" alt="gambar"><br><br>  Maaf, saya belum lama bersenang-senang dengan penamaan, serta periferal untuk otomatisasi rumah.  Khususnya, benda ini - remote control lampu - ternyata karena saya menginginkan sesuatu dengan antarmuka push-twist-klik, dan bukan dengan hamburan tombol biasa.  Efek wow belum tercapai: di rumah saya tidak melihat remote pada jarak dekat, tapi setidaknya saya menutup gestalt. <br><a name="habracut"></a><br>  TOR singkat: <br><br>  1) Manajemen tiga kelompok pencahayaan di dapur <br>  2) Manajemen tiga kelompok pencahayaan di dalam ruangan <br>  3) Manajemen semua sumber cahaya secara bersamaan <br>  4) masa pakai baterai yang wajar (dari seminggu) <br>  5) Kompatibel dengan coding Livolo, SC2260, EV1527 <br><br>  Jadi, Anda tidak perlu membaca lebih lanjut jika Anda tidak suka Arduino, saklar Livolo, dan soket radio Cina.  Karena yang pertama adalah dasar untuk remote, dan yang kedua dan ketiga adalah pinggiran. <br><br><h2>  Konsep </h2><br>  Logika kontrol menurut saya adalah sebagai berikut: <br><br><ol><li>  Menekan "kenop" akan mengubah zona grup pencahayaan dalam sebuah cincin (dapur - ruangan - semuanya). </li><li>  Memutar knob, tergantung pada arah rotasi, menghidupkan atau mematikan pencahayaan dari grup yang dipilih. </li><li>  Mode operasi (grup yang dipilih) ditampilkan oleh indikasi LED yang tidak mencolok. </li></ol><br>  Karena saya menggunakan kontrol radio sesuai dengan opsi yang paling dibenci, tanpa perlindungan dari gangguan dan umpan balik, pada saat yang sama sedikit trik disediakan jika terjadi operasi yang tidak terjawab. <br><br>  Jika memutar kenop tidak mengarah ke hasil yang diinginkan, maka kombinasi menekan dan memutar ke arah yang berlawanan memungkinkan Anda untuk melewati perintah.  Maka perintah itu bisa diulang seperti biasa. <br><br>  Yaitu, jika saya memutar kenop searah jarum jam dan lampu utama tidak menyala, maka saya bisa menekan kenop, putar berlawanan arah jarum jam, lalu lepas dan putar searah jarum jam lagi untuk mengulang menyalakannya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V0ZpCxEb3-U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kenapa begitu sulit?  Kemudian, selain protokol yang aneh, saya juga punya perangkat yang aneh.  Sebagai contoh, lampu radio yang dikendalikan menghidupkan Livolo dan relay radio, yang memiliki perintah yang sama untuk menghidupkan dan mematikan, bersama dengan soket radio biasa, di mana perintah untuk menghidupkan dan mematikan terpisah. <br><br>  Trik skipping tim memungkinkan Anda untuk mengalahkan secara kreatif inklusi (non-pengecualian) tanpa melanggar skema umum pencahayaan.  Selain itu, melewatkan perintah memungkinkan Anda untuk melompati sumber cahaya yang tidak perlu Anda nyalakan atau matikan. <br><br>  Yah, tentu saja, untuk memahami apa yang terjadi dengan remote, ia memiliki indikator terpisah yang menyala saat mengirim perintah. <br><br>  Jika konsol tidak disentuh untuk beberapa waktu (dikonfigurasi dalam kode), maka controller akan tertidur.  Namun, dia tidak menyimpan status terakhir, dan ketika dia bangun dengan menekan pena, dia memulai hidup dari awal. <br><br>  Ini bukan kesalahan.  Saya ulangi, saya memiliki saklar tanpa umpan balik, dan konsol secara fisik tidak dapat memperoleh informasi tentang keadaan saat ini dari setiap perangkat periferal yang dikendalikan. <br><br>  Oleh karena itu, segera setelah bangun tidur, kenop tombol dapat menyalakan atau mematikan lampu dari awal. <br><br><h2>  Pendekatan pertama </h2><br>  Konsep visual dari tipe "box with twist" diperlukan, seperti yang Anda duga, dua hal: kotak dan tikungan.  Dalam versi pertama, peran kotak dimainkan oleh bank daya tipis, yang penggunaannya memecahkan dua masalah sekaligus: Saya punya kasing dan skema pengisian baterai, apalagi dengan konektor.  Baterai itu sendiri, tentu saja, harus diganti dengan yang lebih ringkas, jika tidak maka isiannya tidak lagi muat. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/640/299/4df/6402994df7e71b82835d12f42541f1f0.jpg" alt="gambar"><br><br>  Ternyata lebih rumit dengan twist.  Ketika saya mencari, saya menemukan bahwa tombol potensiometer yang lebih cantik dan semakin besar, semakin dekat biaya gramnya dengan biaya satu gram emas.  Karena itu, saya membeli pena, yang paling tidak cocok untuk properti estetika. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/232/a3e/b60/232a3eb6074d6d8724fdc76d353274cc.jpg" alt="gambar"><br><br>  Bagian kontrol adalah hasil dari percobaan dengan ATmega328P dan kelanjutan logis dari alur cerita yang ditetapkan oleh otomatisasi rumah yang ada (pada protokol radio Arduino dan primitif yang sama). <br><br>  Saya tidak terlalu mahal membeli sebaran kontroler yang disebutkan dan prototipe kondisional (pada kenyataannya, adaptor dari kasing kecil ke step besar) papan sirkuit dengan tujuan mencoba membuat versi Arduino yang murah dari mereka dengan jumlah elemen yang minimal (tapi masuk akal). <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/625/ebb/095/625ebb0959641911621741e00fb1b699.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/be0/e1c/ac4/be0e1cac460246c56f97f0c45e1c8bc7.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/53d/bc5/9f1/53dbc59f1bb9ec5583f84de546b2df76.jpg" alt="gambar"><br><br>  Eksperimen ini ternyata berhasil, dan pengontrol yang dikonfigurasi untuk lingkungan Arduino mem-flash LED dengan cukup sukses setelah menelan Blink klasik.  Nah, kemudian, pada prinsip "menyelesaikan burung hantu", saya menambahkan encoder (dengan tombol), tiga LED dan pemancar normal dengan modulasi amplitudo pada pembawa 433,92 MHz ke papan yang dihasilkan. <br><br>  Untuk meletakkan semua elemen dalam wadah kecil, saya harus sedikit menderita, tetapi kendali jarak jauh masih berfungsi.  Dan meskipun, tampaknya, masalahnya selesai, saya ingin lebih - kasus aslinya. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b0b/716/2cc/b0b7162cc2941009ef081f0f76e4a2a8.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/36b/08b/c76/36b08bc76093a6b66fe3f5e1b3597b1a.jpg" alt="gambar"><br><br><h2>  Pendekatan kedua </h2><br>  Sebenarnya, versi pertama (mengeluh) dalam penampilan sekelompok kawan hancur, jadi saya menundanya tanpa batas waktu.  Tapi dia tidak membukanya: sayang sekali. <br><br>  Tetapi ketika printer 3D muncul, suatu hari dia berjanji pada dirinya sendiri untuk membuat case asli yang sama dan dengan demikian menutup pertanyaan dengan remote control. <br><br>  Saya tidak tahu apakah hasilnya baik atau buruk - saya benar-benar tidak tahu cara mengevaluasi barang-barang saya.  Tetapi pada 3DToday tim lebih ramah daripada di MySKU (yang tidak saya keluhkan - ini bukan hadiah sendiri), dan mereka menilai case lebih tinggi daripada saya. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5a1/89d/905/5a189d905d402c93afba5e4f4d88c1da.jpg" alt="gambar"><br><br>  Tetapi setelah sepenuhnya bebas bertindak, saya meninggalkan baterai Cina yang rapuh dan mencoreng, dan mengambil 18650 tua yang baik sebagai sumber listrik. Dan, seperti yang dapat Anda lihat dengan mudah, justru dimensinya yang sangat menentukan dimensi seluruh casing. <br><br>  Saya mulai membuat casing itu sendiri modular, terdiri dari banyak bagian, yang memungkinkan saya untuk mencetak ulang hanya elemen individual (salah atau tidak terlalu optimal), dan bukan keseluruhan produk. <br><br>  Poin lain adalah saya benar-benar tidak suka membuat guntingan untuk konektor, yang saya benar-benar tidak bisa lakukan.  Karena itu, dalam rantai pasokan ada trik lain yang dikenal oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evelyn si landak</a> : pengisian nirkabel. <br><br><img src="https://habrastorage.org/webt/ie/zq/6m/iezq6m_73cckmk6y-bidsohs9ye.jpeg"><br><br>  Di zashashnik saya hanya meletakkan penerima lain, yang saya segera beraksi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fDLqxxDvQhM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Akhirnya, trik terakhir cukup jelas, tetapi tetap: agar kendali jarak jauh tidak merangkak di sekitar meja, saya menempelkan selembar tikar mobil yang tidak licin ke bagian bawah.  Dan pada akhirnya, benda ini adalah monolit absolut, meskipun menatanya kembali ke tempat lain juga bukan masalah. <br><br><h2>  Apa yang diperlukan untuk mengulanginya </h2><br><h3>  Sepotong besi </h3><br>  1) pengontrol ATmega328P - 1 pc.  (dalam paket TQFP saya, tetapi siapa pun bisa) <br>  2) 10 kOhm resistor - 5 pcs.  (4 untuk menekan bouncing encoder, 1 ke controller) <br>  3) 100 Ohm resistor - 3 pcs. <br>  4) Kapasitor keramik 0,1 mikrofarad - 4 pcs.  (untuk mengontrol dan menekan bouncing encoder) <br>  5) Push encoder (valcoder) - 1 pc.  (Saya punya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEC12-4220F-S0024</a> ) <br>  6) LED - 3 pcs.  (diameter 3 mm) <br>  7) Papan pengisian baterai Lithium - 1 pc.  (dari bank daya yang datang ke tangan, secara teori, siapa pun dengan pengaktifan otomatis di bawah beban akan dilakukan) <br>  8) penerima pengisian nirkabel Qi - 1 pc. <br>  9) Sebuah pemancar dengan modulasi amplitudo pada 433 MHz - 1 pc.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti ini</a> ) <br>  10) Beberapa fiberglass untuk papan encoder <br>  11) printer 3D <br>  12) Plastik yang cocok (Saya cetak PLA) <br>  13) sekrup M4x30 - 4 pcs. <br><br>  Secara umum, jumlah komponen dapat dikurangi.  Sebagai contoh, dalam versi yang sangat minim, controller tidak memerlukan pengikat sama sekali, meskipun saya memutuskan untuk mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saran Nick Gammon</a> dan tidak menyisakan beberapa kapasitor dan resistor. <br><br>  Dengan cara yang sama, Anda tidak bisa repot-repot dengan penekanan perangkat keras dari bouncing kontak, dan mencoba bergaul dengan perangkat lunak.  Kemudian Anda dapat mencoret empat resistor lagi dan sepasang kapasitor. <br><br>  Atau, Anda dapat menggunakan papan Arduino yang sudah jadi, seperti Pro Mini, tetapi dalam hal ini saya tidak dapat menjamin tingkat konsumsi energi yang rendah, dan Anda harus menyulapnya sendiri.  Pada saat yang sama, kasing harus diperbaiki. <br><br>  Skema: <br><br><img src="https://habrastorage.org/webt/wo/xv/hh/woxvhhfaucpc3emhiyipfk56m1s.png"><br><br>  Untuk referensi, ATmega328p pinout dalam paket TQFP-32 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hobby Electronics</a> : <br><br><img src="https://habrastorage.org/webt/1y/ea/sp/1yeasp0veriyrgvhrafu_inlwlm.jpeg"><br><br>  Untuk pembuat enkode, saya menggambar papan kecil: <br><br><img src="https://habrastorage.org/webt/i2/jg/d7/i2jgd7p7jlv1kyhbyjhoayd3d4k.jpeg"><br><br><img src="https://habrastorage.org/webt/ke/cr/yt/kecrytksno5yhwsjjdpcbwgc9-c.jpeg"><br><br><img src="https://habrastorage.org/webt/6y/vb/8j/6yvb8jl1h6zvpm-z-atgntumnsw.jpeg"><br><br>  Jika itu baik, itu harus dibor untuk memasang encoder, atau ditekan dengan "perutnya ke papan (menjaga isolasi sehingga tidak ada hubungan pendek) sehingga encoder dipasang a) kurang lebih merata dan b) tidak akan goyah.  Secara historis, saya memiliki opsi kedua. <br><br>  Untuk kasus ini, penting bahwa ketinggian papan dengan bagian-bagian, tidak termasuk encoder, tidak lebih (atau tidak lebih) 5 mm. <br><br><div class="spoiler">  <b class="spoiler_title">Jika papan Arduino tidak siap, maka agar semuanya berfungsi, Anda harus terlebih dahulu menulis bootloader Arduino ke pengontrol ATmega328P.</b> <div class="spoiler_text">  Untuk melakukan ini, pertama, tambahkan deskripsi pengontrol ke lingkungan Arduino.  Untuk melakukan ini, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Arduino resmi</a> dan unduh arsip deskripsi yang sesuai untuk versi lingkungan Anda ( <a href="">untuk 1.6</a> , <a href="">untuk 1.5</a> , <a href="">untuk 1.0</a> ). <br><br>  Isi arsip harus diekstraksi ke folder perangkat keras folder lingkungan Arduino.  Di masa depan, saya menggambarkan apa yang terjadi pada contoh lingkungan 1.0.3, yang masih saya gunakan. <br><br>  Ketika deskripsi disalin, Anda harus memulai Arduino dan memuat sketsa programmer ke Arduino, yang akan digunakan sebagai programmer ini sendiri.  Sketsa terletak di menu File - Contoh - ArduinoISP. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/037/517/98f/03751798f648adb8fea47a284a912667.jpg" alt="gambar"><br><br>  Tentu saja, Anda harus memilih board dan port Anda.  Saya memilih Mega, karena saya memilikinya: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/7e7/483/4bd/7e74834bdd786979f926f4b65e2e344f.jpg" alt="gambar"><br><br>  Setelah memuat sketsa programmer, Anda perlu beralih ke papan target.  Yaitu  dalam kasus kami - ATmega328 dengan frekuensi 8 MHz dan osilator master internal.  Itu akan ada dalam daftar papan jika deskripsi yang disebutkan di atas disalin dengan benar: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b89/e98/7b2/b89e987b2243a79cc1d36e95d5a7ebab.jpg" alt="gambar"><br><br>  Sekarang Anda perlu menghubungkan garis MISO, MOSI dan SCK dari papan programmer dan papan dengan Arduino masa depan, dan juga menghubungkan RESET, GND dan VCC.  Kekuatan plus adalah yang terbaik di tempat terakhir. <br><br>  Berdasarkan infografik dan deskripsi Arduino Mega di atas, gambar berikut muncul: <br><br>  SPI - Arduino Mega - ATmega328p <br><br>  MISO - 50 - 16 <br>  MOSI - 51 - 15 <br>  SCK - 52 - 17 <br>  SS (RESET) - 53 - 29 <br><br>  Koneksi fisik sesuai dengan selera Anda, saya menggunakan metode barbar khusus - kabel papan tempat memotong roti langsung ke lubang papan, tanpa menyolder dan insulasi: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c14/df6/d5f/c14df6d5f4cdda937de81eb2fa555ee0.jpg" alt="gambar"><br><br>  Jika semuanya siap, tulis bootloader.  Pertama, pastikan bahwa pemrogram yang benar dipilih (Layanan - Programmer - Arduino sebagai ISP): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e0c/dc4/a0c/e0cdc4a0c8914fbed3f5328c676f0210.jpg" alt="gambar"><br><br>  Kemudian kami melakukan Layanan - Rekam bootloader: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/568/21e/12f/56821e12f02cd705995d40429b15eec6.jpg" alt="gambar"><br></div></div><br>  Setelah itu, hasilnya adalah papan Arduino minimalis, untuk memuat sketsa di mana Anda dapat menggunakan adaptor USB-Serial atau papan Arduino penuh dengan adaptor seperti di papan.  Dalam kasus pertama, Anda harus menghubungkan RX dan TX, dan jangan lupa untuk menghubungkan landasan bersama.  Dalam kasus kedua, juga perlu untuk mempersingkat RESET Arduino, yang digunakan sebagai adaptor, ke ground. <br><br>  Jika Anda, seperti saya, tidak memiliki sirkuit untuk menyetel ulang pengontrol secara otomatis sebelum mengunduh sketsa, maka ada dua opsi: tarik tarikannya, atau cukup nyalakan daya ketika lingkungan Arduino mengatakan bahwa pengunduhan telah dimulai. <br><br><h3>  Perumahan </h3><br>  Kasing, seperti yang saya katakan, adalah modular.  Ini berarti bahwa pada bagian dalam tersembunyi dari mata, Anda dapat membiarkan plastik yang sudah basi dan tidak cocok lagi.  Anda dapat meletakkan barang elektronik di atasnya: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/030/0a3/251/0300a325144382295c6e3b8d54971e23.jpg" alt="gambar"><br><br>  Saya menarik perhatian pada fakta bahwa case ini spesifik dan dirancang agar sesuai dengan versi pengisian saya. <br><br>  Saya mengusulkan membuat rotor transparan sehingga mencerahkan lampu indikator.  Untuk bobot yang lebih besar, kacang M16 dapat dimasukkan ke dalam rotor: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9a0/8ef/68e/9a08ef68e2a079da4af3ed1eb148e961.jpg" alt="gambar"><br><br>  Masih membutuhkan baju rotor dan penutup untuk itu.  Tutupnya hanya dimasukkan ke dalam dan bersandar pada gesekan.  Dan, tentu saja, Anda tidak dapat melakukannya tanpa bagian atas dan bawah dari casing luar. <br><br>  Saya mencetak rotor dengan isian 10%, sisanya elemen dengan isian 5%.  Plastik - PLA.  Suhu nosel yang diatur pada printer saya adalah 200C pada tiga lapisan pertama, 185C pada lapisan berikutnya.  Sayangnya, saya tidak bisa mengatakan berapa suhu sebenarnya dari nozzle itu.  Meja itu dingin. <br><br>  Perakitan sederhana. <br><br><img src="https://habrastorage.org/webt/ka/cq/2-/kacq2-crn1cictkqxhpb0sok15u.jpeg"><br><br>  Papan ditempatkan di alur case tahan lama, LED - kaki di alur bagian bawah case tahan lama.  Antena pemancar diturunkan, penerima pengisian nirkabel diturunkan dengan cara yang sama - sehingga lebih dekat dengan muatan yang sama. <br><br><img src="https://habrastorage.org/webt/d9/zu/ex/d9zuextrjywuvjbj4ve68-c2rgg.png"><br><br>  Pengisian diperbaiki oleh pelat perantara, dalam alur yang melewati harness kawat encoder. <br><br>  Encoder diperbaiki dengan pelat atas, semuanya dikencangkan dengan sekrup M4x30, yang memotong sendiri benang dalam plastik. <br><br>  Sekarang case yang tahan lama dapat tertutup di bagian luar case luar.  Sebuah rotor diletakkan pada poros encoder, dan sebuah kemeja diletakkan di rotor.  Opsinya, non-slip mat direkatkan ke bagian bawah tubuh.  Pilihan lain adalah insert dekoratif yang menyembunyikan jahitan di antara dua bagian tubuh. <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text">  Dalam kode, Anda perlu menentukan perintah untuk menghidupkan dan mematikan perangkat periferal Anda.  Opsional - ubah batas waktu mati otomatis. <br><br>  Ini semua terletak di bagian variabel. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  : http://donalmorrissey.blogspot.ru/2010/04/sleeping-arduino-part-5-wake-up-via.html //  Livolo: http://forum.arduino.cc/index.php?action=dlattach;topic=153525.0;attach=108106 #include &lt;avr/sleep.h&gt; #include &lt;avr/power.h&gt; #include &lt;livolo.h&gt; #define adc_disable() (ADCSRA &amp;= ~(1&lt;&lt;ADEN)) // disable ADC (before power-off) #define adc_enable() (ADCSRA |= (1&lt;&lt;ADEN)) // re-enable ADC #define txPin 7 //   Livolo livolo(txPin); #define PULSESHORT 450 #define PULSELONG 1350 #define PULSESYNC 13950 #define encA 5 #define encB 6 //   #define buttonPin 2 //   () #define roomLed 10 //    #define kitchenLed 9 //    #define switchLed 3 //     #define switchLedTimeOut 150 //      #define switchTreshold 4 //      #define offDelay 15000 //   #define rLev 3 //     #define kLev 3 //     #define glev 2 //     #define txPowerPin 8 //    #define kitchenBackLightOn1 12 #define kitchenBackLightOn2 34 #define kitchenMainLightOn 56 #define roomBackLightOn 12 #define roomMainLightOn1 34 #define roomMainLightOn2 56 #define mainLightOn 12 #define kitchenBackLightOff1 12 #define kitchenBackLightOff2 34 #define kitchenMainLightOff 56 #define roomBackLightOff 12 #define roomMainLighOtff1 34 #define roomMainLightOff2 56 #define mainLightOff 12 #define LivoloID 8500 volatile byte rotorMode = 0; //   byte currentMode = 0; //    int curEncA, prevEncA, curButton, prevButton; //   ,  byte encCountPlus = 0; //   byte encCountMinus = 0; //   unsigned long offTimeOut = 0; //    unsigned long modeTimeOut = 0; //        unsigned long switchLedTime = 0; //      unsigned long modeTime = 0; //   unsigned int modeTreshold = 500; //     (  ) unsigned int bounceTreshold = 200; //     byte rLevState = 0; byte kLevState = 0; byte gLevState = 0; //   k - , r - , h - , b -  boolean kBackState = false; boolean kBackState1 = false; boolean kMainState = false; boolean rBackState = false; boolean rMainState = false; boolean rMainState1 = false; boolean hMainState = false; boolean bMainState = false; boolean afterSleep = false; //      boolean modeTimeOutStart = false; boolean switchLedOn = false; boolean allOn = false; //  " "    boolean allOff = false; //  " "    static void ookPulse(int on, int off) { digitalWrite(txPin, HIGH); delayMicroseconds(on); digitalWrite(txPin, LOW); delayMicroseconds(off); } static void rcSend(long remoteCode) { for (byte reSend = 0; reSend &lt; 8; reSend++) { for(byte repeat=0; repeat&lt;4; repeat++){ for (byte i = 24; i&gt;0; i--) { // transmit remoteID byte txPulse=bitRead(remoteCode, i-1); // read bits from remote ID // Serial.print(txPulse); switch (txPulse) { case 0: // 00 ookPulse(PULSESHORT,PULSELONG); //ookPulse(PULSESHORT,PULSELONG); break; case 1: // 11 ookPulse(PULSELONG,PULSESHORT); //ookPulse(PULSELONG,PULSESHORT); break; } // switch } // for loop ookPulse(PULSESHORT,PULSESYNC); // S(ync) // Serial.println(); } // repeat } delay(150); } void switchLedToggle() { digitalWrite(switchLed, HIGH); switchLedTime = millis(); switchLedOn = true; } void lightsUp(boolean lightsUpMode) { //       ""     //   "" -   if (afterSleep == true) { if (lightsUpMode == false) { gLevState = 1; rLevState = 3; kLevState = 3; } else {gLevState = 0; rLevState = 0; kLevState = 0; } afterSleep = false; //   " " } //   if (rotorMode == 2) { if (lightsUpMode == false){ if (allOff == false) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { //   gLevState = 0; rLevState = 0; kLevState = 0; rcSend(kitchenBackLightOff1); rcSend(kitchenBackLightOff2); rcSend(roomBackLightOff); livolo.sendButton(LivoloID, mainLightOff); } allOff = true; allOn = false; } } if (lightsUpMode == true){ //  ,    if (allOn == false) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { gLevState = 1; rLevState = 3; kLevState = 3; rcSend(kitchenBackLightOn1); rcSend(kitchenBackLightOn2); rcSend(roomBackLightOn); livolo.sendButton(LivoloID, mainLightOff); //    Livolo livolo.sendButton(LivoloID, kitchenMainLightOn); //#1   livolo.sendButton(LivoloID, roomMainLightOn1); // #2 livolo.sendButton(LivoloID, roomMainLightOn2); // #3 livolo.sendButton(LivoloID, mainLightOn); // #6 } allOn = true; allOff = false; } } } //  if (rotorMode == 1) { if (lightsUpMode == false &amp;&amp; kLevState &gt; 0) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { if (kLevState == 3) { //   livolo.sendButton(LivoloID, kitchenMainLightOff); // #3 } if (kLevState == 2) { //   2 livolo.sendButton(LivoloID, kitchenBackLightOff2); // #6 } if (kLevState == 1) { //   1 rcSend(kitchenBackLightOff1); } } if (kLevState!=0) { kLevState--;} // Serial.println(kLevState); } if (lightsUpMode == true &amp;&amp; kLevState &lt; 3) { switchLedToggle(); kLevState++; if (digitalRead(buttonPin) == HIGH) { if (kLevState &gt; 3) {kLevState = 3;} // Serial.println(kLevState); if (kLevState == 1) { //   1 rcSend(kitchenBackLightOn1); } if (kLevState == 2) { //   2 livolo.sendButton(LivoloID, kitchenBackLightOn2); // #6 } if (kLevState == 3) { //   livolo.sendButton(LivoloID, kitchenMainLightOn); // #3 } } } } //  if (rotorMode == 0) { if (lightsUpMode == false &amp;&amp; rLevState &gt; 0) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { if (rLevState == 3) { //  1 livolo.sendButton(LivoloID, roomMainLighOtff1); //#1 } if (rLevState == 2) { //   livolo.sendButton(LivoloID, roomMainLightOff2); // #2 } if (rLevState == 1) { //   rcSend(roomBackLightOff); } } if (rLevState != 0) { rLevState--; } } if (lightsUpMode == true &amp;&amp; rLevState &lt; 3) { switchLedToggle(); rLevState++; if (digitalRead(buttonPin) == HIGH) { if (rLevState == 1) { //   rcSend(roomBackLightOn); } if (rLevState == 2) { //   livolo.sendButton(LivoloID, roomMainLightOn1); //#1 } if (rLevState == 3) { //   1 livolo.sendButton(LivoloID, roomMainLightOn2); // #2 } } } } } void wakeUp() { detachInterrupt(0); } void setMode() { if (rotorMode &gt;= 2 ) { rotorMode = 0; } else { rotorMode++; } offTimeOut = millis(); } void ledBlink() { for (byte iLed = 0; iLed&lt;3; iLed++) { digitalWrite(kitchenLed, HIGH); digitalWrite(roomLed, HIGH); delay(100); digitalWrite(kitchenLed, LOW); digitalWrite(roomLed, LOW); delay(100); } } void setLed() { if (rotorMode == 0) { //  digitalWrite(roomLed, HIGH); digitalWrite(kitchenLed, LOW); } if (rotorMode == 1) { //  digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, HIGH); } if (rotorMode == 2) { //    digitalWrite(roomLed, HIGH); digitalWrite(kitchenLed, HIGH); } } void enterSleep() { // ledBlink(); afterSleep = true; digitalWrite(txPin, LOW); digitalWrite(txPowerPin, LOW); digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, LOW); digitalWrite(switchLed, LOW); pinMode(txPin, INPUT); pinMode(txPowerPin, INPUT); pinMode(roomLed, INPUT); pinMode(kitchenLed, INPUT); pinMode(switchLed, INPUT); attachInterrupt(0, wakeUp, LOW); adc_disable(); set_sleep_mode(SLEEP_MODE_PWR_DOWN); sleep_enable(); sleep_mode(); sleep_disable(); power_all_enable(); pinMode(txPin, OUTPUT); pinMode(txPowerPin, OUTPUT); pinMode(roomLed, OUTPUT); pinMode(kitchenLed, OUTPUT); pinMode(switchLed, OUTPUT); digitalWrite(txPin, LOW); digitalWrite(txPowerPin, HIGH); // ledBlink(); setLed(); offTimeOut = millis(); allOn = false; allOff = false; } void setup() { // Serial.begin(115200); pinMode(txPin, OUTPUT); pinMode(txPowerPin, OUTPUT); pinMode(roomLed, OUTPUT); pinMode(kitchenLed, OUTPUT); pinMode(switchLed, OUTPUT); digitalWrite(txPin, LOW); digitalWrite(txPowerPin, HIGH); digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, LOW); digitalWrite(switchLed, LOW); // pinMode(buttonPin, INPUT_PULLUP); pinMode(buttonPin, INPUT); pinMode(encA, INPUT); pinMode(encB, INPUT); prevEncA = digitalRead(encA); offTimeOut = millis(); rotorMode = 0; setLed(); prevButton = digitalRead(buttonPin); } void loop() { if ((millis() - offTimeOut) &gt; offDelay) { enterSleep(); } else { //     if (switchLedOn == true) { if ((millis() - switchLedTime) &gt; switchLedTimeOut) { digitalWrite(switchLed, LOW); switchLedOn = false; } } //       if (digitalRead(buttonPin) == LOW) { offTimeOut = millis(); } //   curButton = digitalRead(buttonPin); if ((prevButton == HIGH) &amp;&amp; (curButton == LOW)) { if (modeTimeOutStart == false) { modeTimeOut = millis(); modeTimeOutStart = true; } } else { if (modeTimeOutStart == true) { modeTime = millis() - modeTimeOut; if ((modeTime &lt; modeTreshold) &amp;&amp; (modeTime &gt; bounceTreshold)) { setMode(); modeTimeOutStart = false; prevButton = digitalRead(buttonPin); } else { modeTimeOutStart = false; prevButton = digitalRead(buttonPin); } } } //    if (currentMode != rotorMode) { //       ,     currentMode = rotorMode; //     setLed(); } //   curEncA = digitalRead(encA); if ((prevEncA == LOW) &amp;&amp; (curEncA == HIGH)) { offTimeOut = millis(); if (digitalRead(encB) == LOW) { encCountMinus++; encCountPlus = 0; // Serial.println("Encoder Minus"); if (encCountMinus &gt; switchTreshold) { encCountMinus = 0; lightsUp(false); } } else { encCountPlus++; encCountMinus = 0; // Serial.println("Encoder Plus"); if (encCountPlus &gt; switchTreshold) { encCountPlus = 0; lightsUp(true); } } } prevEncA = curEncA; } }</span></span></code> </pre> <br></div></div><br>  Model kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan referensi</a> . <br><br>  Itu saja. <br><br>  PS: Saya berusaha untuk tidak melupakan apa pun, tetapi saya bisa.  Jika demikian, saya minta maaf dan akan melakukan yang terbaik untuk menjawab pertanyaan utama dan memperbaiki kesalahan dengan benar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id411093/">https://habr.com/ru/post/id411093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id411083/index.html">Matahari Terbenam "Bintang-bintang kemanusiaan"</a></li>
<li><a href="../id411085/index.html">Pi-Sonos v3.0: mengerjakan bug atau proyek yang sama sekali baru?</a></li>
<li><a href="../id411087/index.html">Masa depan kartu video</a></li>
<li><a href="../id411089/index.html">Cara mengidentifikasi satelit di orbit</a></li>
<li><a href="../id411091/index.html">Teknologi Pusat Data: Informasi Umum tentang Switch QFX</a></li>
<li><a href="../id411095/index.html">Teleskop Kepler kehabisan bahan bakar. Final sudah dekat</a></li>
<li><a href="../id411097/index.html">Utusan seluler mandiri</a></li>
<li><a href="../id411099/index.html">Sangat mudah untuk mengevaluasi PPFD ketika menerangi pabrik dengan LED putih: 1000 lux = 15 Œºmol / s / m2</a></li>
<li><a href="../id411101/index.html">Otoritas New York diizinkan untuk meningkatkan biaya listrik untuk penambang</a></li>
<li><a href="../id411105/index.html">Kinerja drone kurir akan tergantung pada tempat Anda tinggal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>