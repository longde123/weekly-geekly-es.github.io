<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèΩ ‚úãüèø ‚õπüèº OpenSceneGraph: Detailebenen (LOD) und Hintergrundladen von Objekten üåô üèóÔ∏è üçë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Eine der interessantesten Aufgaben, die mit Hilfe dreidimensionaler Grafiken gel√∂st werden, ist die Schaffung "gro√üer Welten" - lange Sze...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Detailebenen (LOD) und Hintergrundladen von Objekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438454/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Eine der interessantesten Aufgaben, die mit Hilfe dreidimensionaler Grafiken gel√∂st werden, ist die Schaffung "gro√üer Welten" - lange Szenen mit einer gro√üen Anzahl von Objekten mit der M√∂glichkeit einer unbegrenzten Bewegung auf der B√ºhne.  Die L√∂sung f√ºr dieses Problem beruht auf den verst√§ndlichen Einschr√§nkungen, die der Computerhardware inh√§rent sind. <br><br>  <i>Ein typisches Beispiel: die "gro√üe Welt" bei der Visualisierung der Eisenbahn auf dem OSG-Motor.</i>  <i>Es fehlen nur noch die Langoliers, die die Welt hinter dem Zug verschlingen ...</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YEaYugmhO2Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In dieser Hinsicht besteht die Notwendigkeit, Anwendungsressourcen zu verwalten, was auf eine offensichtliche L√∂sung hinausl√§uft: Laden nur der Ressourcen (Modelle, Texturen usw.), die zum Erstellen einer Szene zum aktuellen Zeitpunkt mit der aktuellen Position des Beobachters erforderlich sind;  Reduzierung der Detailstufen entfernter Objekte;  Entladen von nicht mehr ben√∂tigten Objekten aus dem Systemspeicher.  Zum gr√∂√üten Teil bieten Grafik- und Spiele-Engines eine Reihe von Tools zur L√∂sung solcher Probleme.  Heute schauen wir uns an, welche davon in OpenSceneGraph verf√ºgbar sind. <br><a name="habracut"></a><br><h1>  1. Verwenden von Detailebenen (LOD) </h1><br>  Die Technik der Verwendung von Detailebenen erm√∂glicht es Ihnen, dasselbe Objekt je nach Entfernung zum Betrachter mehr oder weniger detailliert anzuzeigen.  Die Verwendung dieser Technik basiert auf der einfachen √úberlegung, dass die kleinen Details eines dreidimensionalen Modells √ºber eine gro√üe Entfernung nicht zu unterscheiden sind, was bedeutet, dass sie nicht gezeichnet werden m√ºssen.  Mit dieser Technik k√∂nnen Sie einerseits die Gesamtzahl der im Bildspeicher angezeigten geometrischen Grundelemente reduzieren und andererseits den Anzeigebereich von Szenenobjekten nicht verlieren, was beim Erstellen gro√üer offener Welten sehr n√ºtzlich ist. <br><br>  OSG bietet Tools zum Implementieren dieser Technik √ºber die osg :: LOD-Klasse, die von derselben osg :: Group geerbt wurde.  Mit dieser Klasse k√∂nnen Sie dasselbe Objekt in mehreren Detailebenen darstellen.  Jede Detailebene ist durch einen minimalen und maximalen Abstand zum Betrachter gekennzeichnet, bei dessen Einhaltung die Anzeige des Objekts in dieser Detailebene umgeschaltet wird. <br><br>  Mit osg :: LOD k√∂nnen Sie diesen Bereich sofort beim Definieren eines untergeordneten Knotens oder sp√§ter mithilfe der setRange () -Methoden angeben <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; lodNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; lodNode-&gt;addChild(node2, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>, FLT_MAX); lodNode-&gt;addChild(node1); . . . lodNode-&gt;setRange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">500.0f</span></span>);</code> </pre> <br>  Wir qu√§len Cessna weiterhin und veranschaulichen die beschriebene Technik anhand eines Beispiels <br><br><div class="spoiler">  <b class="spoiler_title">Lod Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/LOD&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgUtil/Simplifier&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; modelL2 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = dynamic_cast&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osgUtil::Simplifier simplifer; simplifer.setSampleRatio(0.5f); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(0.1f); modelL1-&gt;accept(simplifer); osg::ref_ptr&lt;osg::LOD&gt; root = new osg::LOD; root-&gt;addChild(modelL1.get(), 200.0f, FLT_MAX); root-&gt;addChild(modelL2.get(), 50.0f, 200.0f); root-&gt;addChild(modelL3.get(), 0.0f, 50.0f); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Laden Sie zuerst das Modell <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL3 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Jetzt m√ºssen Sie mehrere Modelle (wir beschr√§nken uns auf zwei Beispiele) mit einem geringeren Detaillierungsgrad generieren.  Kopieren Sie dazu den geladenen Knoten zweimal mit der Technik der sogenannten "tiefen" Kopie der Klasse f√ºr den von der clone () -Methode implementierten Knoten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; modelL2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL)); osg::ref_ptr&lt;osg::Node&gt; modelL1 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Node *&gt;(modelL3-&gt;clone(osg::CopyOp::DEEP_COPY_ALL));</code> </pre><br>  Jetzt reduzieren wir die Geometrie dieser Modelle mit der Klasse osgUtil :: Simplifer.  Der Grad der Vereinfachung des Modells wird durch die setSampleRatio () -Methode dieser Klasse festgelegt. Je kleiner der √ºbergebene Parameter ist, desto weniger detailliert ist das Modell nach Anwendung des Reduktionsverfahrens <br><br><pre> <code class="cpp hljs">osgUtil::Simplifier simplifer; simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); modelL2-&gt;accept(simplifer); simplifer.setSampleRatio(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>); modelL1-&gt;accept(simplifer);</code> </pre><br>  Wenn wir Modelle mit unterschiedlichen Detaillierungsgraden haben, k√∂nnen wir sie dem Stammknoten aufladen, der als intelligenter Zeiger auf osg :: LOD erstellt wurde.  Stellen Sie f√ºr jede Detailebene den Anzeigeabstand dieser Ebene ein <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LOD&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LOD; root-&gt;addChild(modelL1.get(), <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX); root-&gt;addChild(modelL2.get(), <span class="hljs-number"><span class="hljs-number">50.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>); root-&gt;addChild(modelL3.get(), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">50.0f</span></span>);</code> </pre><br>  Mit FLT_MAX ist in gewisser Weise eine "unendlich" gro√üe Entfernung zum Beobachter gemeint.  Nach dem Starten des Viewers erhalten wir das folgende Bild <br><br>  Detaillierungsgrad 3 <br><br><img src="https://habrastorage.org/webt/ww/d7/bq/wwd7bqrlttw9sgedue6m5xoxjgu.png"><br><br>  Detaillierungsgrad 2 <br><br><img src="https://habrastorage.org/webt/us/ku/h0/uskuh0x_zfchoklahjzoqjeq--c.png"><br><br>  Detaillierungsgrad 1 <br><br><img src="https://habrastorage.org/webt/lh/gi/ca/lhgica7l6z4dnl9w8yekiodyxn0.png"><br><br>  Es ist zu sehen, dass das Detail der angezeigten Geometrie abnimmt, wenn die Kamera vom Objekt wegbewegt wird.  Mit dieser Technik k√∂nnen Sie einen hohen Realismus der Szene bei geringem Ressourcenverbrauch erzielen. <br><br><h1>  2. Hintergrundladetechnik f√ºr Szenenknoten </h1><br>  Die OSG-Engine stellt die Klassen osg :: ProxyNode und osg :: PagedLOD bereit, um die Last beim Rendern der Szene auszugleichen.  Beide Klassen erben von osg :: Group. <br><br>  Ein Knoten vom Typ osg :: ProxyNode reduziert die Startzeit der Anwendung vor dem Rendern, wenn in der Szene eine gro√üe Anzahl geladener und angezeigter Modelle von der Festplatte geladen ist.  Es fungiert als Schnittstelle zu externen Dateien und erm√∂glicht das verz√∂gerte Laden von Modellen.  Verwenden Sie zum Hinzuf√ºgen untergeordneter Knoten die Methode setFileName () (anstelle von addChild), um den Namen der Modelldatei auf der Festplatte festzulegen und dynamisch zu laden. <br><br>  Der Knoten osg :: PagedNode erbt die osg :: LOD-Methoden und l√§dt und entl√§dt Detailebenen so, dass eine √úberlastung der OpenGL-Pipeline vermieden und ein reibungsloses Rendern der Szene sichergestellt wird. <br><br><h1>  3. Dynamisches Laden (Laufzeit) des Modells </h1><br>  Mal sehen, wie der Prozess des Ladens des Modells mit osg :: ProxyNode abl√§uft. <br><br><div class="spoiler">  <b class="spoiler_title">Proxynode-Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ProxyNode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ProxyNode&gt; root = new osg::ProxyNode; root-&gt;setFileName(0, "../data/cow.osg"); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Der Download-Vorgang hier ist etwas anders <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::ProxyNode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::ProxyNode; root-&gt;setFileName(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"../data/cow.osg"</span></span>);</code> </pre><br>  Anstatt das Kuhmodell explizit zu laden, geben wir dem Stammknoten den Namen der Datei an, in der sich das Modell befindet, und den Index des untergeordneten Knotens, in dem dieses Modell nach dem Laden platziert werden soll.  Bei der Ausf√ºhrung des Programms erhalten wir dieses Ergebnis <br><br><img src="https://habrastorage.org/webt/4u/z_/yb/4uz_ybvtau_okn8gtbsyvesuqo8.png"><br><br>  Es ist zu erkennen, dass der Blickwinkel nicht optimal gew√§hlt wurde - die Kamera ruht direkt auf der Spiegelseite der Kuh.  Dies geschah, weil das Modell nach dem Starten des Renderns und dem Initialisieren der Kamera geladen wurde, als Knoten 0 noch nicht sichtbar war.  Der Betrachter konnte die notwendigen Kameraparameter einfach nicht berechnen.  Das Modell wurde jedoch geladen und wir k√∂nnen den Anzeigemodus durch Manipulieren der Maus konfigurieren <br><br><img src="https://habrastorage.org/webt/kj/qp/hm/kjqphmpi5-thkedfpuqflwfywoa.png"><br><br>  Was passiert im obigen Beispiel?  osg :: ProxyNode und osg :: PagedLOD arbeiten in diesem Fall als Container.  Der interne Datenmanager von OSG sendet Anforderungen und l√§dt Daten in das Szenendiagramm, wenn Modelldateien und Detailebenen erforderlich sind. <br><br>  Dieser Mechanismus funktioniert in mehreren Hintergrundstr√∂men und steuert das Laden statischer Daten in Dateien auf der Festplatte sowie dynamischer Daten, die w√§hrend der Programmausf√ºhrung generiert und hinzugef√ºgt werden. <br><br>  Die Engine verarbeitet automatisch Knoten, die nicht im aktuellen Ansichtsfenster angezeigt werden, und entfernt sie aus dem Szenendiagramm, wenn das Rendern √ºberladen ist.  Dieses Verhalten wirkt sich jedoch nicht auf die osg :: ProxyNode-Knoten aus. <br><br>  Wie der Proxy-Knoten verf√ºgt auch die osg :: PagedLOD-Klasse √ºber eine setFileName () -Methode zum Angeben des Pfads zum geladenen Modell. Sie m√ºssen jedoch den Sichtbarkeitsbereich daf√ºr festlegen, wie f√ºr den osg :: LOD-Knoten.  Vorausgesetzt, wir haben eine cessna.osg-Datei und ein Low-Poly-Modell der Ebene L1, k√∂nnen wir den ausgelagerten Knoten wie folgt organisieren <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; pagedLOD-&gt;addChild(modelL1, <span class="hljs-number"><span class="hljs-number">200.0f</span></span>, FLT_MAX ); pagedLOD-&gt;setFileName( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span> ); pagedLOD-&gt;setRange( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">200.0f</span></span> );</code> </pre><br>  Sie m√ºssen verstehen, dass der Knoten modelL1 nicht aus dem Speicher entladen werden kann, da dies ein normaler untergeordneter Nicht-Proxy-Knoten ist. <br><br>  Beim Rendern ist der Unterschied zwischen osg :: LOD und osg :: PagedLOD von au√üen nicht sichtbar, wenn Sie nur eine Detailebene des Modells verwenden.  Eine interessante Idee w√§re, mit der Klasse osg :: MatrixTransform einen gro√üen Cluster von Cessna-Modellen zu organisieren.  Hierf√ºr k√∂nnen Sie beispielsweise eine solche Funktion verwenden <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLODNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3&amp; pos )</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PagedLOD; ‚Ä¶ osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;setMatrix( osg::Matrix::translate(pos) ); mt-&gt;addChild( pagedLOD.get() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mt.release(); }</code> </pre><br>  Ein Beispielprogramm, das das Laden von 10.000 Flugzeugen im Hintergrund implementiert <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PagedLOD&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLODNode(const std::string &amp;filepath, const osg::Vec3 &amp;pos) { osg::ref_ptr&lt;osg::PagedLOD&gt; pagedLOD = new osg::PagedLOD; pagedLOD-&gt;setFileName(0, filepath); pagedLOD-&gt;setRange(0, 0.0f, FLT_MAX); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;setMatrix(osg::Matrix::translate(pos)); mt-&gt;addChild(pagedLOD.get()); return mt.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; float dist = 50.0f; int N = 100; for (int i = 0; i &lt; N; ++i) { float x = i * dist; for (int j = 0; j &lt; N; ++j) { float y = j * dist; osg::Vec3 pos(x, y, 0.0f); osg::ref_ptr&lt;osg::Node&gt; node = createLODNode("../data/cessna.osg", pos); root-&gt;addChild(node.get()); } } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Es wird angenommen, dass sich das Flugzeug in einem Flugzeug mit einem Intervall von 50 Koordinateneinheiten befindet.  Beim Laden werden wir sehen, dass nur die Cessna geladen werden, die in den Rahmen gelangen.  Die Ebenen, die aus dem Rahmen verschwinden, verschwinden aus dem Szenenbaum. <br><br><img src="https://habrastorage.org/webt/zx/cc/j4/zxccj4cjwh5a0ejfpl6mjudq8zi.png"><br><br><h1>  Fazit </h1><br>  Diese Lektion in der OpenSceneGraph-Reihe ist die letzte im How To-Format.  In zw√∂lf Artikeln konnten die Grundprinzipien der Arbeit und Verwendung von OpenSceneGraph in die Praxis umgesetzt werden.  Ich hoffe wirklich, dass dieser Motor dem russischsprachigen Entwickler klarer geworden ist. <br><br>  Dies bedeutet nicht, dass ich das Thema OpenSceneGraph in der Ressource abschlie√üe. Im Gegenteil, es ist geplant, zuk√ºnftige Artikel fortgeschritteneren Techniken und Methoden zur Verwendung von OSG bei der Entwicklung grafischer Anwendungen zu widmen.  Daf√ºr m√ºssen Sie jedoch gutes Material sammeln und viele englischsprachige Quellen verarbeiten, was einige Zeit in Anspruch nimmt. <br><br>  Aber ich verabschiede mich nicht, danke f√ºr Ihre Aufmerksamkeit und bis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bald!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438454/">https://habr.com/ru/post/de438454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438438/index.html">Futter f√ºr Bitrix Papageien. Wir testen die Leistung, w√§hlen Eisen</a></li>
<li><a href="../de438442/index.html">Weiterleiten von Anfragen von Apache an Payara Server 5 in Ubuntu</a></li>
<li><a href="../de438446/index.html">Benchmark als Grundlage f√ºr die Entscheidung √ºber eine Code√§nderung</a></li>
<li><a href="../de438448/index.html">Was PC-Lautsprecher kann</a></li>
<li><a href="../de438450/index.html">Warum ist die Vorlage f√ºr Datenschutzrichtlinien nicht f√ºr Sie geeignet?</a></li>
<li><a href="../de438456/index.html">Einrichten von Single Sign-On in der Zimbra Collaboration Suite</a></li>
<li><a href="../de438458/index.html">Die DUMP 2019 Konferenz findet am 19. April statt. Wir laden Sie ein, in den Bereichen Frontend, Backend und Wissenschaft zu sprechen.</a></li>
<li><a href="../de438460/index.html">Serialisierung auf Datenbankebene</a></li>
<li><a href="../de438462/index.html">Eine schnelle M√∂glichkeit, einer Android-App Benachrichtigungen hinzuzuf√ºgen</a></li>
<li><a href="../de438464/index.html">SciPy, Graph-Algorithmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>