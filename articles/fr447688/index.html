<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèº üëë üë®üèΩ‚Äçü§ù‚Äçüë®üèº √Ä la question sur le bitset üßóüèª ‚è¨ ‚õ™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬´N'est-il pas temps, mes amis, que nous nous tournions vers William, vous voyez, notre Shakespeare? ". 


 J'ai r√©cemment lu un article sur un clavier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä la question sur le bitset</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447688/"><h3>  ¬´N'est-il pas temps, mes amis, que nous nous tournions vers William, vous voyez, notre Shakespeare?  ". </h3><br><img src="https://habrastorage.org/webt/p7/bz/aw/p7bzaw_ttw8pdlvlc4wmn3hltcw.jpeg"><br><br>  J'ai r√©cemment lu un article sur un clavier personnalis√© et j'ai encore une fois pens√© qu'il serait bien d'√©crire une r√©f√©rence (c'est-√†-dire qui n'a pas honte de signer avec son nom et de la mettre en exposition publique) une impl√©mentation de clavier.  Cette id√©e ne m'est pas venue pour la premi√®re fois, mais elle s'arr√™te en quelque sorte √† la premi√®re √©tape - lire les informations initiales, parce que je veux rendre cette √©tape facilement personnalisable, pratique √† utiliser, universelle et efficace, et je n'aime pas l'offre "choisissez-en deux". <br><br>  Remarque n√©cessaire - Je vois 4 couches d'impl√©mentation du clavier: 0 - d√©tection d'√©v√©nements, 1 - lecture de donn√©es, 2 - nettoyage et stockage de donn√©es, 3 - g√©n√©ration de messages, 4 - transcodage, etc.  Le plus prometteur pour la couche 1 et la couche 0 qui lui est associ√©e me semble l'utilisation de mod√®les Anton Chizhov pour travailler avec des broches MK (bas√©es sur la classe Loki) et, peut-√™tre un jour, le r√©sultat r√©sultant n'aura pas honte √† partager, mais certainement pas aujourd'hui.  Maintenant, je pense √† la couche 2. <br><a name="habracut"></a><br>  Formulons le probl√®me - il est n√©cessaire de stocker des informations sur un ensemble fixe de commutateurs qui prennent l'une des deux valeurs pr√©d√©finies - ¬´ferm√©¬ª et ¬´non ferm√©¬ª.  Les candidats les plus naturels sont les variables bool√©ennes et la biblioth√®que de bits, comme moyen de stocker un ensemble.  √âtant donn√© que l'exigence d'efficacit√© est un imp√©ratif cat√©gorique, il est souhaitable d'√©valuer la mise en ≈ìuvre du module de ce point de vue. <br><br>  La premi√®re pens√©e a √©t√© de regarder les codes sources et tout est imm√©diatement devenu clair, mais apr√®s une br√®ve connaissance avec eux, j'ai r√©alis√© que l'apprentissage des mod√®les d'autres personnes n'√©tait pas tr√®s int√©ressant (et pas tr√®s productif).  De plus, les sources ne donnent pas une √©valuation pr√©cise de l'efficacit√© de l'impl√©mentation, car elle est directement ferm√©e au compilateur.  En fait, le texte source devait encore √™tre √©tudi√©, sinon y apporter des modifications devient un processus tr√®s long (√† moins, bien s√ªr, que nous ne soyons int√©ress√©s √† obtenir un certain r√©sultat), mais c'est un sujet pour un autre article. <br><br>  Par cons√©quent, la technique d'√©tude de la "bo√Æte noire" est adopt√©e - nous introduisons divers fragments de code √† l'entr√©e et consid√©rons l'assembleur g√©n√©r√©.  Malheureusement, il n'est pas possible d'utiliser le site Godbolt pr√©f√©r√© pour l'architecture AVR famili√®re, car il n'y a pas de biblioth√®que √† l'√©tude dans cette impl√©mentation.  Vous pouvez bien s√ªr le faire glisser avec des stylos, mais rien ne garantit que ce sera le bon code source. <br><br>  Par cons√©quent, nous examinerons une architecture diff√©rente.  x51 n'est pas pr√©sent√© pour le compilateur gcc, je n'ai jamais aim√© x86, ARM a un assembleur pas tr√®s pratique (pour une personne) et compr√©hensible, MIPS est tr√®s sp√©cifique et pas trop commun, toutes sortes de SPARC sont encore pires (eh bien, eh bien, je n'offenserai personne avec votre architecture pr√©f√©r√©e, pas mieux), mais il y a un grand candidat MSP430, qui √©tait bas√© sur l'architecture cristalline et √©l√©gante de PDP et TI ne pouvait pas le g√¢cher beaucoup (bien que les gars aient essay√©).  Une biblioth√®que de plusieurs bits pour cette architecture est pr√©sent√©e, vous pouvez donc commencer √† √©tudier. <br><br>  Commen√ßons, car cela ne semble pas trivial, d√®s le d√©but, c'est-√†-dire avec l'annonce de la multitude.  Nous verrons imm√©diatement que la m√©moire pour le stockage est allou√©e en mots de quatre octets, malgr√© le fait que l'unit√© naturelle dans cette architecture est un mot de deux octets, et un travail assez pratique et efficace avec des octets est fourni, ce qui conduit √† des incidents √©tranges.  Vous pouvez comprendre l'auteur, la mise en ≈ìuvre d'un nombre 32 bits devrait √™tre partout et s'appuyer sur elle tout naturellement, mais dans ce cas, 8 bits serait pr√©f√©rable, et pour AVR, 8 bits serait la seule solution raisonnable. <br><br>  Une question int√©ressante, mais comment d√©terminer la profondeur de bits de l'architecture pendant le processus de compilation, vous devrez essayer uint8_t_fast.  Nous notons une optimisation possible et passons √† autre chose. <br><br>  Outre l'allocation de m√©moire, l'initialisation pr√©sente un int√©r√™t - pour les ensembles globaux, elle est effectu√©e de mani√®re standard - la mise √† z√©ro avant d'appeler main, pour les ensembles locaux, elle est √©galement effectu√©e de mani√®re standard, c'est-√†-dire en aucun cas si la valeur initiale n'est pas explicitement sp√©cifi√©e.  Eh bien, et, comme toujours, s'il est possible de d√©crire un ensemble statique avec une valeur initiale en dehors de la fonction, cela devrait √™tre utilis√© pour ne pas activer les indicateurs inutiles et ne pas passer de temps d'ex√©cution sur eux.  Mais ici, nous ne nous attendions pas √† des r√©v√©lations, nous avons juste v√©rifi√© les r√®gles g√©n√©rales. <br><br>  Commen√ßons √† travailler avec la modification de l'ensemble, pour lequel nous avons laiss√© des crochets et des m√©thodes set et reset.  Nous pouvons nous attendre √† voir quelque chose comme √ßa pour d√©finir l'√©l√©ment n dans l'ensemble M: <br><br><pre><code class="cpp hljs">M[n / w] |= (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;(n % w))</code> </pre> <br>  o√π w est le nombre de bits dans l'√©l√©ment de base, qui pour une architecture donn√©e, d√©fini statiquement n (par exemple, 4) et l'optimisation incluse conduit √† un code de la forme: <br><br><pre> <code class="cpp hljs">bis.w #<span class="hljs-number"><span class="hljs-number">0x0010</span></span>, m</code> </pre> <br>  En effet, nous voyons un tel code dans la moiti√© droite de la fen√™tre, et il est peu probable que quiconque risquerait s√©rieusement d'affirmer qu'une solution plus efficace est possible.  Mais cela ne concerne que les conditions indiqu√©es, pour un arbitraire n l'image change compl√®tement, pour les m√©thodes nous observons la validation de l'argument de validit√© avec la g√©n√©ration de l'exception correspondante, et pour les crochets nous voyons la restriction de l'argument avec un masque de bits de la plage acceptable avec un comportement ind√©fini compl√®tement pr√©visible, les deux cas sont tout √† fait coh√©rents avec la documentation.  Les valeurs n√©gatives sont trait√©es assez correctement, car les index sont consid√©r√©s comme des nombres non sign√©s. <br><br>  Nous attirons l'attention sur le fait que la valeur assign√©e pour un √©l√©ment d'un ensemble peut √™tre non seulement 0 et 1, comme on pourrait s'y attendre, mais aussi tout entier auquel la r√®gle ¬´Qu'est-ce que l'unit√©?  Pas z√©ro ¬ª, c'est tout √† fait logique, mais mal refl√©t√© dans la documentation.  Un peu √©trangement fait, mais les valeurs bool√©ennes seraient plus naturelles, cocher et passer √† autre chose. <br><br>  La comparaison du code g√©n√©r√© pour le cas d'un num√©ro d'√©l√©ment statiquement ind√©termin√© de l'ensemble montre que l'efficacit√© du code dans les deux cas ([] et les m√©thodes) est tr√®s proche et petite, puisqu'un sous-programme de la biblioth√®que standard est appel√© pour calculer (1 &lt;&lt; n), et ce sous-programme se d√©place Num√©ro 32 bits 0x00000001, plac√© dans deux registres.  Nous ne pouvons pas voir son texte source, mais le fait m√™me de l'appel conduit √† de tristes pens√©es.  Le fait est que dans l'architecture consid√©r√©e, il n'y a pas de d√©calage vers la gauche (et il n'y a pas non plus de droite) par un nombre arbitraire de positions, comme dans tous les (nombreux) ARM bien-aim√©s.  Il y a un d√©calage de 1 position (il serait √©trange s'il n'existait pas du tout), il y a un d√©calage de 2,3,4 positions (mais par un nombre strictement fix√© dans la commande, pas par un param√®tre), il y a un pr√©fixe REPT (mais sa vitesse d'ex√©cution laisse souhaiter le meilleur).  Vous pouvez impl√©menter le d√©calage de la plus petite unit√© (c'est important, une seule unit√©), c'est-√†-dire obtenir un masque de bits par le nombre de bits dans un temps relativement court par des astuces telles que l'√©change de t√©trades, mais ce sera une partie tr√®s d√©pendante et, dans le cas g√©n√©ral, il vaut mieux ne pas le faire. <br><br>  Par cons√©quent, une m√©thode universelle et rapide serait de stocker des masques de bits dans un tableau et un index, et sur cette architecture, il est √©galement tr√®s efficace, le code ressemble alors √† ceci: <br><br><pre> <code class="cpp hljs">M[n/w] |= BitArray[n %w]</code> </pre> <br>  obtenir un assembleur comme: <br><br><pre> <code class="cpp hljs"> bis.<span class="hljs-function"><span class="hljs-function">b </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BitArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r0)</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">M</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r1)</span></span></span></span></code> </pre> <br>  Puisque nous parlons de mod√®les et que w est un multiple de la taille d'un octet, les op√©rations de division sont impl√©ment√©es tr√®s efficacement ici.  Nous notons l'avantage √©vident d'un √©l√©ment de stockage √† impl√©mentation minimale: pour un octet, un tableau de 8 octets est requis pour un octet, -2 * 16 = 32 octets pour l'organisation des mots, et 4 * 32 = 128 octets pour un mot long de 32 bits pour stocker tout le n√©cessaire masques, pourquoi payer plus si le r√©sultat ne change pas.  Souvenons-nous d'une autre optimisation possible et passons. <br><br>  Nous notons un fait suppl√©mentaire - des impl√©mentations beaucoup plus efficaces des op√©rations avec un √©l√©ment d√©fini sont possibles si l'architecture cible a une r√©gion de m√©moire binaire (ici encore, l'ARM rejet√© pr√©c√©demment est rappel√©), o√π l'op√©ration d'installation d'√©l√©ment se transforme g√©n√©ralement en BitSetAddr [n] = citrouille 1, ce qui se traduit par une seule commande d'assembleur pour la constante n, mais il y a d√©j√† suffisamment de d√©calages effectifs, donc une telle optimisation serait plus redondante, surtout en tenant compte de ses limites.  En principe, il existe une zone adressable par bit similaire dans les deux x51 et AVR, mais il n'y a des commandes efficaces que pour des nombres d'√©l√©ments constants, et dans le cas g√©n√©ral, tout n'est pas si bon (franchement mauvais). <br><br>  Eh bien, regardez maintenant de pr√®s le code r√©sultant et notez que nous observons des artefacts associ√©s au stockage de l'ensemble en deux mots.  Le compilateur pour l'op√©ration de modification d'un √©l√©ment d'un ensemble g√©n√®re une s√©quence de commandes qui lisent le double mot correspondant de la m√©moire dans 2 registres (je me souviens que nous avons des registres 16 bits), les modifie et renvoie les r√©sultats en m√©moire.  Si nous ne modifions qu'un seul √©l√©ment, le masque d'op√©ration contiendra exactement une unit√© sur 32 possibles, les z√©ros restants.  Lorsque nous appliquons un num√©ro d'√©l√©ment d√©fini statiquement, les op√©rations qui ne modifient pas le r√©sultat doivent √™tre exclues au stade de l'optimisation.  En r√®gle g√©n√©rale, cela se produit, mais pour divers op√©randes, quelque chose ne va pas et des artefacts du formulaire fuient dans le code final: <br><br><pre> <code class="cpp hljs">bic #<span class="hljs-number"><span class="hljs-number">0</span></span>,r0</code> </pre> <br>  ce qui est particuli√®rement dr√¥le si vous remarquez que le registre n'est pas r√©√©crit en m√©moire, bien qu'il soit lu.  √Ä strictement parler, les r√©sultats des optimisations ne sont r√©glement√©s nulle part, ils peuvent donc √™tre n'importe quoi, et il n'y a rien √† redire, mais quoi qu'il en soit, "ce n'est pas clair comment cela fonctionne".  Nous ne pouvons pas influencer directement ce processus, si nous ne consid√©rons pas s√©rieusement le code source du compilateur, nous allons donc le contourner - nous aiderons l'optimiseur en simplifiant sa t√¢che. <br><br>  Soit dit en passant, je ne trouve toujours pas la r√©ponse √† la question - est-il possible en C ++ au niveau de la macro ou du mod√®le de d√©finir une impl√©mentation diff√©rente pour une d√©finition statique au stade de la compilation par rapport √† un param√®tre statiquement ind√©fini.  Si quelqu'un conna√Æt le chemin des samoura√Øs, dites-moi dans les commentaires, j'ai essay√© constexpr, √ßa n'a pas march√©. <br><br>  Nous poursuivons nos recherches et constatons que le compilateur optimise de mani√®re incontr√¥lable les appels √† l'ensemble (bien s√ªr, si l'optimisation est activ√©e), c'est-√†-dire que l'ordre d'installation / de nettoyage des diff√©rents √©l√©ments n'est absolument pas garanti et n'est en aucun cas li√© √† l'ordre des op√©rateurs de code source.  Mais je n'ai pas r√©ussi √† cr√©er un ensemble volatile, peut-√™tre que je fais quelque chose de mal?  Comme dans le cas de toute optimisation locale, l'appel √† une fonction externe force le compilateur √† forcer toutes les op√©rations pr√©par√©es pour le tableau global, mais c'est une solution trop forte et n'aide pas avec les locales.  Eh bien, il n'y a probablement rien √† faire, et il vous suffit de prendre en compte une fonctionnalit√© similaire et de ne pas utiliser d'ensembles pour transf√©rer des informations entre les flux √† l'aide d'interfaces s√©rie (c'est-√†-dire leurs homologues logiciels). <br><br>  Une conclusion g√©n√©rale peut √™tre tir√©e: l'utilisation du jeu de bits sous sa forme actuelle pour des architectures aux ressources limit√©es ne peut pas √™tre recommand√©e en raison de co√ªts excessifs en m√©moire et en temps d'ex√©cution.  Une √©ventuelle modification, qui prend en compte toutes les donn√©es sur le texte du commentaire, se trouve sur Github, tout le monde peut l'utiliser.  L'histoire de la cr√©ation de ce mod sera bient√¥t publi√©e sur Habr√©, il y a eu des moments amusants. <br><br>  En conclusion, une petite remarque - l'impl√©mentation de l'entrep√¥t de donn√©es "frontale", m√™me sur la version optimis√©e de l'ensemble, n√©cessitera N / 8 octets de m√©moire de donn√©es (pour 128 commutateurs, 16 octets seront n√©cessaires) et bien que les op√©rations n√©cessitent O (1), le multiplicateur sera de nombreuses unit√©s ( et m√™me jusqu'√† 10 cycles ou plus) de MK.  Par cons√©quent, en tenant compte des exigences du probl√®me et en introduisant certaines restrictions, nous pouvons proposer une impl√©mentation alternative du stockage de donn√©es. <br><br>  Si nous pensons qu‚Äôaucun interrupteur ne peut √™tre ferm√© √† tout moment (nous ignorons tous les autres jusqu‚Äô√† ce que le bouton qui est actuellement enfonc√© soit ouvert), alors nous pouvons contourner un octet (√† condition qu‚Äôil n‚Äôy ait pas plus de 256 interrupteurs) et l'√©criture / lecture prendra O (1) cycles de processeur, et le multiplicateur sera assez modeste. <br><br>  Cette approche est facile √† d√©velopper et √† stocker des informations sur n commutateurs ferm√©s simultan√©ment, mais vous ne devez pas rendre n trop grand, car la quantit√© de m√©moire requise augmente et le temps n√©cessaire pour effectuer des op√©rations d'inversion augmente lin√©airement avec une augmentation du nombre d'√©l√©ments dans l'ensemble, bien qu'il reste O (1) par par rapport au nombre de commutateurs.  L'augmentation de temps indiqu√©e peut √™tre consid√©rablement r√©duite en utilisant l'impl√©mentation triangulaire de l'arbre binaire √† O (loq2 (n)), mais pour les petits n ce n'est pas si important.  Oui, et il est peu probable que la complexit√© du calcul de l'index suivant lors de la recherche compense la diminution du nombre d'it√©rations simples.  Les inconv√©nients de cette impl√©mentation incluent un √©chec possible d'enregistrer l'√©l√©ment de l'ensemble, qui devrait √™tre trait√© dans le programme appelant (nous rejetons l'option avec une taille de tampon changeante imm√©diatement et avec indignation - ce n'est pas pour les solutions int√©gr√©es). <br><br>  La mise en ≈ìuvre de cette approche y sera donn√©e. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447688/">https://habr.com/ru/post/fr447688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447678/index.html">Le concept d'une br√®ve encyclop√©die</a></li>
<li><a href="../fr447680/index.html">Exercices d'√©mulation: manuel Xbox 360 FMA</a></li>
<li><a href="../fr447682/index.html">Space Data Center: 24 heures avant le lancement</a></li>
<li><a href="../fr447684/index.html">Comment afficher les valeurs de l'entreprise dans un bureau (sans affiches ni slogans)</a></li>
<li><a href="../fr447686/index.html">Un param√®tre tr√®s important des lampes LED, que peu de gens connaissent</a></li>
<li><a href="../fr447690/index.html">Configuration compilable d'un syst√®me distribu√©</a></li>
<li><a href="../fr447694/index.html">Configuration du syst√®me distribu√© compil√©</a></li>
<li><a href="../fr447696/index.html">Pourquoi les villes s'opposent √† Amazon Go, les premiers magasins non cash</a></li>
<li><a href="../fr447698/index.html">Poudlard rouge: acad√©micien sans dipl√¥me</a></li>
<li><a href="../fr447700/index.html">La flexibilit√© √©motionnelle est la cl√© de la croissance personnelle.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>