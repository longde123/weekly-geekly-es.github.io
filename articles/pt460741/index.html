<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 🎼 🤲🏽 Introdução ao ECMAScript 6 (ES-2015) 🖇️ 🌰 💖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introdução ao ES6 

 Sumário 
 1. Literais de modelo 
 2. deixe e const 
 3. Expressões da função de seta 
 4. Para ... de 
 5. Nomes de propriedades ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução ao ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Introdução ao ES6 </h2><br><br>  <b>Sumário</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Literais de modelo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. deixe e const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Expressões da função de seta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Para ... de</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Nomes de propriedades computados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Parâmetros de descanso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. Parâmetros padrão</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">9. Atribuição de reestruturação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">10. Mapa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">11. Definir</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">12. Classes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">13. Promessa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">14. Iteradores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">15. Geradores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Literais de modelo (sequências de modelo) </h2><br>  Literais de modelo são literais de string que permitem o uso de expressões internas.  Com eles, você pode usar literais de múltiplas linhas e interpolação de strings. <br><br>  Os literais de modelo são colocados em backticks (``) em vez de duplo ou único.  Eles podem conter curingas indicados por um cifrão e chaves ($ {expression}).  As expressões de substituição e o texto entre elas são passados ​​para a função.  Por padrão, a função simplesmente concatena todas as partes em uma sequência.  Se houver uma expressão antes da linha (aqui está a tag), a linha do modelo será chamada de "modelo de tag".  Nesse caso, a expressão da tag (geralmente uma função) é chamada com o literal do modelo processado, que você pode modificar antes da saída.  Para escapar da cota traseira em literais de modelo, especifique a barra invertida \. <br><a name="habracut"></a><br>  <b>Literais multilinhas</b> <br>  Os caracteres de nova linha fazem parte de literais curinga.  Usando cadeias regulares, a inserção de quebra automática exigiria a seguinte sintaxe: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  O mesmo com o uso de literais de modelo: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Interpolação de Expressão</b> <br>  Para inserir expressões em cadeias regulares, você teria que usar a seguinte sintaxe: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Agora, com a ajuda de literais de modelo, você pode usar o `açúcar sintático`, o que torna as substituições assim mais legíveis: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Modelos aninhados</b> <br>  Às vezes, aninhar um padrão é a maneira mais curta e talvez mais legível de criar uma sequência.  Basta colocar outro dentro do modelo com aspas posteriores, envolvendo-o na substituição $ {}.  Por exemplo, se a expressão for verdadeira, você poderá retornar um modelo literal. <br>  No ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  No ES2015 com literais de modelo sem aninhamento: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  No ES2015 com literais de modelo aninhados: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Modelos de tag</b> <br>  Uma forma estendida de literais de modelo é marcada com modelos.  Eles permitem que você analise literais de modelo usando uma função  O primeiro argumento dessa função contém uma matriz de valores de sequência e o restante contém expressões de substituições.  Como resultado, a função deve retornar a cadeia montada (ou algo completamente diferente, como será mostrado mais adiante).  O nome da função pode ser qualquer coisa. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  A função de tag não é necessária para retornar uma string. <br><cut></cut><br>  <b>Linhas brutas</b> <br>  A propriedade bruta especial, disponível para o primeiro argumento do modelo de marca, permite obter a sequência no formato em que foi inserida, sem interpretação. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  Além disso, existe um método String.raw () que retorna exatamente a mesma string de origem que a função de modelo padrão e a concatenação de string retornariam juntas. <br><cut></cut><br>  No ECMAScript 2016, os modelos marcados seguem as regras para escapar dos seguintes caracteres: <br><ul><li>  Caracteres Unicode começando com "\ u", por exemplo, \ u00A9 </li><li>  Pontos de código Unicode começando com "\ u {}", por exemplo, \ u {2F804} </li><li>  representações de caracteres hexadecimais começando com "\ x", por exemplo, \ xA9 </li><li>  representações octais de caracteres começando com "\", por exemplo, \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  deixe e const </h2><br>  O escopo das variáveis ​​declaradas pelas palavras-chave let e const é o bloco no qual elas são declaradas e todas sob os blocos.  Nesse sentido, a operação da diretiva let é semelhante à da diretiva var.  A principal diferença é que o escopo da variável declarada pela diretiva var é toda a função na qual ela é declarada.  Além das variáveis, o valor das constantes não pode ser alterado por uma nova atribuição, nem redefinido.  Ao declarar uma variável com a palavra-chave const, você deve usar o operador de atribuição para definir o valor da constante. <br><br>  As constantes globais não se tornam propriedades do objeto window, diferentemente das variáveis ​​var. <br>  É necessária a inicialização de uma constante. <br>  Você deve especificar um valor ao mesmo tempo que a declaração (a questão é que esse valor não poderá mais ser alterado). <br>  Declarar variáveis ​​com a palavra-chave const cria uma constante (uma nova referência nomeada para uma região da memória) que é somente leitura. <br>  Isso não significa que o valor indicado seja inalterado, mas significa que o identificador não pode ser reatribuído.  Por exemplo, se uma constante apontar para um objeto, o próprio objeto poderá ser modificado. <br>  Os nomes das constantes não podem coincidir com os nomes das funções ou variáveis ​​do mesmo escopo. <cut></cut><br><br>  Um exemplo da diferença entre o escopo global e o bloco: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Expressões de função de seta </h2><br>  As expressões de função de seta têm uma sintaxe mais curta que as expressões funcionais e estão lexicamente vinculadas ao valor disso (mas não vinculadas ao seu próprio, argumentos, super ou new.target).  A expressão das funções de seta não permite especificar um nome; portanto, as funções de seta são anônimas, a menos que sejam atribuídas a qualquer coisa. <br><cut></cut><br>  <b>Sintaxe básica</b> <br><pre> <code class="javascript hljs">(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, …, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Sintaxe estendida</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Mais informações sobre as funções das setas, você pode encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><a name="section004"></a><h2>  Para ... de </h2><br>  A instrução for ... executa um loop através de objetos iteráveis ​​(incluindo Array, Map, Set, um objeto de argumentos e similares), invocando a cada etapa da iteração os operadores para cada valor de várias propriedades do objeto. <br><cut></cut><br>  Por que NÃO DEVE usar um loop for ... para iterar?  Porque, dependendo do mecanismo, o JavaScript pode iterar em ordem aleatória, o que pode levar a resultados imprevisíveis.  Se uma propriedade mudar em uma iteração e depois mudar novamente, seu valor no loop será o último valor.  Uma propriedade excluída antes do ciclo chegar não participará dela.  As propriedades adicionadas aos objetos no loop podem ser ignoradas.  Em geral, é melhor não adicionar, modificar ou excluir uma propriedade do objeto durante a iteração, se você ainda não a passou.  Não há garantia de que a propriedade adicionada será visitada pelo ciclo, alterada após as alterações e excluída após a exclusão.  Além disso, a variável iterativa é uma sequência, não um número, o que significa que se você deseja fazer cálculos com a variável, precisará concatenar as sequências em vez de adicioná-las.  Portanto, para evitar erros lógicos, você não deve usá-lo! <br><br>  Diferentemente do loop for ... of, o loop for ... in retorna todas as propriedades enumeradas, incluindo aquelas com nomes não inteiros e herdados. <br><br>  <b>For ... da sintaxe do loop</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Exemplos: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Cada objeto herdará o método objCustom e cada Matriz herdará o método arrCustom, criando-os em Object.prototype e Array.prototype.  O objeto iterável herdará os métodos objCustom e arrCustom devido à herança do protótipo. <br><br>  O loop exibe apenas as propriedades enumeradas do objeto iterável, na ordem em que foram criadas.  Ele não imprime os valores 3, 5, 7 e hello, pois eles não são enumeráveis.  Os nomes das propriedades e métodos são exibidos, por exemplo, arrCustom e objCustom. <br><br>  O loop é semelhante ao anterior, mas usa hasOwnProperty () para verificar se essa propriedade do objeto é própria ou herdada.  Somente propriedades próprias são exibidas.  Os nomes 0, 1, 2 e foo pertencem apenas à instância do objeto (não herdada).  Os métodos arrCustom e objCustom não são gerados porque são herdados. <br><br>  Esse loop ignora iterável e exibe os valores do objeto iterável que são definidos no método de iteração sobre, ou seja,  não as propriedades do objeto, mas os valores da matriz 3, 5, 7. <br><br><a name="section005"></a><h2>  Nomes de propriedades computados </h2><br>  A sintaxe para declarar objetos e seus elementos suporta nomes de propriedades calculados.  Isso permite adicionar uma expressão aos colchetes [] que serão avaliados como o nome da propriedade.  Assemelha-se a literais de modelo. <br><br>  <b>Exemplo de nomes calculados:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  O método Object.assign () é usado para copiar os valores de todas as suas próprias propriedades enumeradas de um ou mais objetos de origem para o objeto de destino.  Após a cópia, ele retorna o objeto de destino. <br><br>  O método Object.assign () copia apenas propriedades enumeradas e nativas dos objetos de origem para o objeto de destino.  Ele usa o método interno [[Get]] nos objetos de origem e o método [[Set]] interno no objeto de destino, portanto também chama getters e setters.  É por isso que atribui propriedades em vez de simplesmente copiar ou definir novas propriedades.  Esse comportamento pode tornar o método inadequado para injetar novas propriedades no protótipo se os objetos de origem injetados contiverem getters.  Em vez disso, para copiar protótipos de definições de propriedades, incluindo um sinal de sua enumeração, os métodos Object.getOwnPropertyDescriptor () e Object.defineProperty () devem ser usados. <br><br>  As propriedades dos tipos de String e Symbol são copiadas. <br><br>  No caso de um erro, por exemplo, quando a propriedade não é gravável, é lançada uma exceção TypeError e o objeto de destino permanece inalterado. <br><br>  Observe que o método Object.assign () não lança uma exceção se os valores iniciais forem nulos ou indefinidos. <br><br>  <b>Exemplo: Clonando um Objeto</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Exemplo: Mesclando Objetos</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Parâmetros de descanso </h2><br>  A sintaxe dos demais parâmetros da função permite representar um conjunto ilimitado de argumentos na forma de uma matriz. <br><br>  Se o último argumento da função nomeada tiver um prefixo ..., ele se tornará automaticamente uma matriz com elementos de 0 a theArgs.length, de acordo com o número real de argumentos passados ​​para a função. <br><br>  <b>Sintaxe</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Um exemplo de uso da sintaxe dos parâmetros restantes:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  Neste exemplo, a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Se o parâmetro restante não for passado, será uma matriz vazia (diferente dos parâmetros comuns, nunca será indefinido). <br><br>  Essa sintaxe pode ser usada não apenas em argumentos de função, mas também em outros lugares, por exemplo, para copiar e combinar matrizes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Parâmetros padrão </h2><br>  Os parâmetros padrão permitem definir parâmetros formais da função com valores padrão se a função for chamada sem argumentos ou se o parâmetro for explicitamente passado indefinido. <br><br>  No JavaScript, os parâmetros de uma função que não recebem valores quando é chamada assumem o valor padrão indefinido.  No entanto, em alguns casos, pode ser útil definir um valor padrão diferente.  É nesses casos que as configurações padrão são pretendidas. <br><br>  O valor padrão é atribuído a um parâmetro formal somente se, durante uma chamada de função, o valor desse parâmetro não foi passado ou indefinido foi explicitamente passado. <br><br>  <b>Um exemplo de uso de parâmetros padrão:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Atribuição de reestruturação </h2><br>  A sintaxe da atribuição de desestruturação nas expressões JavaScript permite recuperar dados de matrizes ou objetos usando uma sintaxe semelhante à declaração de uma matriz ou literais em um objeto. <br><br>  As expressões de declaração de objeto ou matriz fornecem uma maneira fácil de criar um pacote de dados homogêneo.  Ao criar esse pacote, você tem a oportunidade de usá-lo de qualquer maneira possível.  Você também pode devolvê-lo em funções. <br><br>  Uma das principais maneiras de usar a atribuição destrutiva é ler a estrutura de dados com um operador, embora você possa encontrar muitos outros usos além disso. <br><br>  <b>Exemplo de atribuição destrutiva:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Você pode ver mais exemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><a name="section010"></a><h2>  Mapa </h2><br>  Mapa - um objeto que contém pares de valores-chave e preserva a ordem de inserção.  Qualquer valor (objetos e primitivas) pode ser usado como chaves. <br><br>  <b>Um exemplo:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Diferença do mapa do objeto:</b> <br><br><ul><li>  As chaves de objeto são Linhas e Símbolos, enquanto qualquer valor pode ser uma chave de Mapa, incluindo funções, objetos e primitivas. </li><li>  Ao contrário de Objetos, as chaves no Mapa são ordenadas.  Assim, durante a iteração do mapa, as chaves são retornadas em ordem de inserção. </li><li>  Você pode obter facilmente o número de elementos em um Mapa usando a propriedade size, enquanto o número de elementos em um Objeto pode ser determinado apenas manualmente. </li><li>  O mapa é um objeto iterável e pode ser iterado diretamente, enquanto o objeto requer o recebimento manual da lista de chaves e sua iteração. </li><li>  O objeto tem um protótipo e, portanto, possui um conjunto de chaves padrão, que, se descuidado, pode se cruzar com as chaves.  Desde o lançamento do ES5, isso pode ser alterado usando map = Object.create (null). </li><li>  O mapa pode ter um melhor desempenho em casos de adição ou remoção freqüentes de chaves. </li></ul><cut></cut><br>  <b>Propriedades e métodos:</b> <br><br><ul><li>  Map.prototype.size - Retorna o número de pares chave / valor em um Mapa </li><li>  Map.prototype.set (chave, valor) - Adiciona o par passado chave \ valor ao mapa.  Se a chave especificada já existir, ela será substituída pelo novo valor. </li><li>  Map.prototype.get (key) - Retorna o valor da chave passada.  Se não houver chave, o indefinido retornará </li><li>  Map.prototype.has (key) - Retorna true se a chave passada existir e false se não existir </li><li>  Map.prototype.delete (key) - exclui o par especificado \ key value e retorna true.  Retorna false se a chave não existir. </li><li>  Map.prototype.clear () - remove todos os pares chave / valor do mapa </li><li>  Map.prototype.keys () - Retorna um iterador de chaves em um mapa para cada elemento </li><li>  Map.prototype.values ​​() - Retorna um iterador de valores no Mapa para cada elemento </li><li>  Map.prototype.entries () - Retorna um iterador da matriz [chave, valor] no Mapa para cada elemento </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Definir </h2><br>  Permite salvar valores exclusivos de qualquer tipo, tanto primitivos quanto outros tipos de objetos. <br><br>  Os objetos Set representam coleções de valores que você pode percorrer na ordem em que os elementos são inseridos.  O valor de um elemento no Set pode estar presente em apenas uma instância, o que garante sua exclusividade na coleção Set. <br><br>  Conjunto de propriedades e métodos de instância <br><ul><li>  tamanho - Retorna o número de elementos no objeto Set. </li><li>  add (value) - adiciona um novo elemento com o valor fornecido ao objeto Set.  Retorna um objeto Set. </li><li>  clear () - Remove todos os elementos do objeto Set. </li><li>  delete (value) - exclui o elemento associado ao valor e retorna o valor que possui (value) retornaria anteriormente.  has (value) retornará false mais tarde. </li><li>  Entradas () - Retorna um novo objeto Iterator que contém uma matriz de [valor, valor] para cada elemento no objeto Definir na ordem de inserção.  Isso é armazenado de maneira semelhante ao objeto Mapa, portanto, cada entrada tem o mesmo valor para sua chave e valor aqui. </li><li>  forEach (callbackFn [, thisArg]) - Chama callbackFn uma vez para cada valor presente no objeto Set, em ordem de inserção.  Se thisArg for especificado para thisEach, será usado como o valor this para cada retorno de chamada. </li><li>  has (value) - Retorna um valor booleano confirmando se o elemento com o valor especificado está presente no objeto Set ou não. </li><li>  values ​​() - Retorna um novo objeto Iterator que contém os valores para cada elemento no objeto Set na ordem de inserção. </li></ul><br>  <b>Usando o objeto Set</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Conjunto de derivação</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Aulas </h2><br>  As classes em JavaScript foram introduzidas no ECMAScript 2015 e são um açúcar sintático sobre a herança de protótipo em JavaScript.  A sintaxe da classe não apresenta um novo modelo orientado a objetos, mas fornece uma maneira mais simples e intuitiva de criar objetos e organizar a herança. <br><br>  As classes são realmente "funções especiais", assim como você define funções (expressões e declarações de funções), você pode definir classes com: declarações de classe e expressões de classe. <br><br>  A diferença entre uma declaração de função e uma declaração de classe é que uma declaração de função é içada, enquanto uma declaração de classe não é.  Portanto, você deve primeiro declarar sua classe e somente trabalhar com ela, caso contrário, uma exceção do tipo ReferenceError será lançada. <br><cut></cut><br><h4>  Declaração de classe </h4><br>  A primeira maneira de definir uma classe é com uma declaração de classe.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para fazer isso, use a palavra-chave class e especifique o nome da classe (no exemplo, "myClass"). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda maneira de definir uma classe é a expressão de classe. </font><font style="vertical-align: inherit;">Você pode criar expressões nomeadas e sem nome. </font><font style="vertical-align: inherit;">No primeiro caso, o nome da expressão de classe está no escopo local da classe e pode ser obtido através das propriedades da própria classe, e não de sua instância.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As expressões de classe estão sujeitas aos mesmos problemas de elevação que as declarações de classe! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os corpos de declaração e expressões de classe são executados no modo estrito. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O modo estrito altera a sintaxe e o comportamento do tempo de execução. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ser mais preciso, o modo estrito é caracterizado pelo seguinte:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Converter erros em exceções </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alterações que simplificam o cálculo de uma variável em certos casos de uso de seu nome; </font></font></li><li> ,  eval  arguments; </li><li> ,   «» JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A sintaxe do sistema de números octais é proibida. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> É proibido definir propriedades com valores primitivos. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificação do trabalho com variáveis</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O modo estrito simplifica a comparação do nome da variável com o local de sua definição no código.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É proibido usar com. </font><font style="vertical-align: inherit;">O problema com é que, em tempo de execução, qualquer nome dentro do bloco pode se referir a uma propriedade do objeto que está sendo processado ou a uma variável no contexto circundante (ou até global) - é impossível saber sobre isso de antemão. </font><font style="vertical-align: inherit;">Já existe uma alternativa simples: atribuir o objeto a uma variável com um nome abreviado e acessar a propriedade desejada como propriedade dessa variável.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () no modo estrito não adiciona novas variáveis ​​ao contexto circundante. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> É proibido excluir nomes simples. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificação de avaliação e argumentos</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O modo estrito reduz o número de esquisitices no comportamento de argumentos e avaliação, ambas as quais misturam uma certa quantidade de magia no código regular. </font><font style="vertical-align: inherit;">Portanto, eval adiciona ou remove variáveis ​​e altera seus valores, e a variável argumentos pode surpreender com suas propriedades indexadas, que são referências (sinônimos) para argumentos de funções nomeadas.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As palavras-chave eval e argumentos não podem ser substituídas ou modificadas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os campos do objeto de argumentos não estão associados aos argumentos da função nomeada, mas são suas cópias duplicadas dos valores. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A propriedade argumentos.callee não é suportada. </font><font style="vertical-align: inherit;">No código regular, a propriedade argumentos.callee refere-se à própria função, para a qual o objeto de argumentos foi criado.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript "seguro"</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alguns sites oferecem aos usuários a capacidade de escrever JavaScript que será executado no site em nome de outros usuários. </font><font style="vertical-align: inherit;">Nos navegadores, o JavaScript pode ter acesso a informações particulares, o que é uma falha de segurança no JavaScript.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O valor passado para a função, pois não é convertido para o objeto no modo estrito. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Não é possível "executar" a pilha JavaScript através das extensões básicas do ECMAScript. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nas funções, a propriedade argumentos não fornece mais acesso às variáveis ​​criadas dentro da função. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode consultar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a especificação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1 para saber mais sobre o modo Estrito. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E também </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construtores </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O construtor é um método especial usado para criar e inicializar objetos criados usando a classe </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao criar novos objetos a partir da classe, o constructor () será iniciado, o que é necessário para inicializar os objetos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Só pode haver um método em uma classe chamada construtor. </font><font style="vertical-align: inherit;">Se a classe contiver mais de um construtor, uma exceção SyntaxError será lançada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A super palavra-chave pode ser usada no construtor para chamar o construtor da classe pai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você não definiu um método construtor, o construtor padrão será usado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para classes base, o construtor padrão é:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para classes derivadas, o construtor padrão é: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Métodos </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxe da declaração do método:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abreviação de métodos de gerador</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as definições de método, exceto os métodos de gerador, não podem ser construtores e lançarão um TypeError se você tentar instancia-las. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomes de propriedades computadas</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A palavra-chave static define métodos estáticos para uma classe. </font><font style="vertical-align: inherit;">Métodos estáticos são chamados sem instanciar sua classe e não podem ser chamados em instâncias da classe.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxe de getters e setters</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setter - Necessário para validação de parâmetros escritos (como no exemplo acima) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter - Necessário para obter propriedades (embora possam ser obtidas diretamente). </font><font style="vertical-align: inherit;">Não pode ter argumentos</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Não há encapsulamento interno no ES6, mas você pode organizá-lo. </font></font> Por exemplo, assim: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herança </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A palavra-chave extends é usada nas declarações e expressões de classe para criar uma classe que é filha de outra classe. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No construtor, a palavra-chave super () é usada como uma função que chama o construtor pai. </font><font style="vertical-align: inherit;">Ele deve ser chamado antes da primeira chamada para a palavra-chave this no corpo do construtor. </font><font style="vertical-align: inherit;">A super palavra-chave também pode ser usada para chamar funções do objeto pai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você substitui os métodos da classe pai na classe filho, os métodos da classe filho serão chamados por padrão, mas você pode chamar explicitamente os métodos da classe pai usando a função super ().</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estendendo objetos embutidos com extensões</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este exemplo estende um objeto Data embutido.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promessa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objeto Promise é usado para cálculos adiados e assíncronos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A promessa pode estar em três estados:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendente: estado inicial, não concluído e não rejeitado. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           « », , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="imagem"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um objeto Promise é criado usando a nova palavra-chave e seu construtor. </font><font style="vertical-align: inherit;">O construtor Promise aceita um argumento chamado função executora como argumento. </font><font style="vertical-align: inherit;">Esta função deve aceitar duas funções de retorno de chamada como parâmetros. </font><font style="vertical-align: inherit;">O primeiro (resolver) é chamado quando a operação assíncrona foi concluída com êxito e retornou o resultado de sua execução como um valor. </font><font style="vertical-align: inherit;">O segundo retorno de chamada (rejeição) é chamado quando a operação falha e retorna um valor indicando o motivo da falha, na maioria das vezes um objeto de erro.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um objeto de função com dois argumentos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolver</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rejeitar,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> faz com que a promessa seja bem-sucedida; o segundo a rejeita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fornecer à função a funcionalidade de promessa, você só precisa retornar o objeto Promise.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando. </font><font style="vertical-align: inherit;">os manipuladores de execução e rejeição são anexados.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métodos</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (iterável) - Aguarda que todas as promessas sejam executadas ou rejeitadas para qualquer uma delas. </font><font style="vertical-align: inherit;">Retorna uma promessa que será executada depois que todas as promessas forem executadas em iterável. </font><font style="vertical-align: inherit;">Caso alguma das promessas seja rejeitada, Promise.all também será rejeitado.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (iterável) - Aguarda a conclusão de todas as promessas recebidas (execução e rejeição). </font><font style="vertical-align: inherit;">Retorna uma promessa que é executada quando todas as promessas recebidas são concluídas (executadas ou rejeitadas), contendo uma matriz dos resultados da execução das promessas recebidas.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (iterável) - Aguarda a execução ou rejeição de qualquer uma das promessas recebidas. </font><font style="vertical-align: inherit;">Retorna uma promessa que será executada ou rejeitada com o resultado da execução da primeira promessa executada ou rejeitada de .iterable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (reason) - Retorna uma promessa rejeitada devido ao motivo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (value) - Retorna a promessa executada com o valor do resultado. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise Prototype</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected) - Adiciona uma função de retorno de chamada para lidar com a rejeição de uma promessa, que retorna uma nova promessa feita com o valor passado se chamado, ou o valor original de resolução se a promessa foi feita. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then (onFulfilled, onRejected) - Adiciona um manipulador de cumprimento e rejeição de promessa e retorna uma nova promessa executada com o valor do manipulador chamado ou o valor original se a promessa não foi processada (ou seja, se o manipulador onFulfilled ou onRejected correspondente não for uma função). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando uma solicitação http assíncrona: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode obter mais exemplos e informações sobre promessas na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">, bem como na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do Mozilla </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteradores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processar cada item em uma coleção é uma operação muito comum. O JavaScript fornece várias maneiras de iterar sobre uma coleção, de um simples loop for a map (), filter () e compreensão de array. Iteradores e geradores implementam o conceito de enumeração diretamente no núcleo da linguagem e fornecem um mecanismo para definir o comportamento de ... de loops. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um objeto é um iterador se puder acessar os elementos da coleção, um de cada vez, enquanto rastreia sua posição atual nessa sequência. Em JavaScript, um iterador é um objeto que fornece um método next () que retorna o próximo elemento de uma sequência. Este método retorna um objeto com duas propriedades: done e value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma vez criado, o objeto iterador pode ser usado explicitamente chamando o método next ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterável - Este é um objeto cujo conteúdo pode ser repetido. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objeto iterável difere do não iterável, pois possui um método especial que retorna um objeto para acesso ao qual um símbolo especial é usado: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objeto que retorna o método é formalmente chamado de iterador. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O iterador possui apenas um método next ()</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que retorna um objeto (vamos chamá-lo itreratorResult) com duas propriedades concluídas e valor </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> done indica se ainda existe um valor na sequência que está sendo pesquisada e o valor contém o próximo elemento da sequência. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após a inicialização, o método next () pode ser chamado para acessar os pares de valores-chave no objeto, um por um. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um objeto é iterável se definir um método para enumerar valores, ou seja, por exemplo, como os valores são enumerados na construção for..of. </font><font style="vertical-align: inherit;">Alguns tipos internos, como Matriz ou Mapa, são iteráveis ​​por padrão, enquanto outros tipos, como Objeto, não são. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ser iterável, um objeto deve implementar o método iterador, o que significa que ele (ou um dos objetos da cadeia de protótipos) deve ter uma propriedade chamada Symbol.iterator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É assim que o iterador padrão se parece:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geradores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geradores são um tipo especial de função que funciona como uma fábrica de iteradores. </font><font style="vertical-align: inherit;">Uma função se torna um gerador se contiver uma ou mais instruções de rendimento e usar a sintaxe da função *.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geradores são um novo tipo de função que pode pausar sua execução e retornar um resultado intermediário e retomar a execução posteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vejamos uma função regular que faz algumas contas e retorna um resultado:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora dê uma olhada em uma função de gerador semelhante: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como afirmado anteriormente, os geradores podem pausar sua execução e retornar um resultado intermediário. Este exemplo mostra que, no momento da primeira chamada, a função como se suspende sua execução no primeiro ponto de interrupção e retorna o resultado da primeira expressão. Na segunda chamada, a função continua do ponto de interrupção anterior e passa para a próxima, retornando o resultado da próxima expressão. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os geradores de funções fornecem uma ferramenta poderosa para escrever funções sequenciais complexas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os geradores calculam os resultados de suas expressões de rendimento sob demanda, o que lhes permite trabalhar eficientemente com sequências com alta complexidade computacional ou mesmo sequências infinitas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O método next () também assume um valor que pode ser usado para alterar o estado interno do gerador. O valor passado para next () será considerado o resultado da última expressão de rendimento que pausou o gerador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode forçar o gerador a lançar uma exceção chamando seu método throw () e passando o valor da exceção que deve ser lançada como um parâmetro. Essa exceção será lançada do contexto atual em pausa do gerador como se a declaração de rendimento atual em pausa fosse uma declaração de lançamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a declaração de rendimento não ocorrer durante o tratamento da exceção lançada, a exceção será passada acima através da chamada throw () e o resultado das chamadas subseqüentes para next () será a propriedade done igual a true.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os geradores têm um método de retorno (valor) que retorna o valor fornecido e para o gerador. </font></font><br><br><a name="section016"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Símbolo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol é um tipo de dados primitivo cujas instâncias são únicas e imutáveis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tempo de execução do JavaScript, um valor de "símbolo" é criado chamando a função Symbol (), que cria dinamicamente um valor anônimo e exclusivo. </font><font style="vertical-align: inherit;">O único uso razoável é salvar o caractere e, em seguida, usar o valor armazenado para criar a propriedade do objeto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando um caractere é usado como identificador em uma atribuição de propriedade, a propriedade (por exemplo, um caractere) é anônima; </font><font style="vertical-align: inherit;">e também não contável. </font><font style="vertical-align: inherit;">Como a propriedade não é computável, ela não será exibida no loop "for (... in ...)" e, como a propriedade é anônima, ela não será exibida no array de resultados "Object.getOwnPropertyNames ()". </font><font style="vertical-align: inherit;">O acesso a esta propriedade pode ser obtido usando o valor inicial do símbolo que a criou ou iterando através da matriz de resultados “Object.getOwnPropertySymbols ()”.</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Então você pode criar uma propriedade de caractere: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter uma matriz de objetos de caractere, use a propriedade Object.getOwnPropertySymbols (obj); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para acessar qualquer parte do seu código, use os métodos Symbol.for () e Symbol.keyFor (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter mais informações sobre o tipo de dados Sumbol, consulte a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">e também a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">Mozilla.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460741/">https://habr.com/ru/post/pt460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460729/index.html">Agradável e útil no ensino</a></li>
<li><a href="../pt460731/index.html">Autoridades dos EUA concluem uma investigação sobre um acidente de ônibus robótico em 2017</a></li>
<li><a href="../pt460735/index.html">CI \ CD para startups: quais ferramentas existem e por que não são usadas apenas por empresas grandes e conhecidas</a></li>
<li><a href="../pt460737/index.html">Ouça o histórico: Podcasts de gerenciamento de projetos</a></li>
<li><a href="../pt460739/index.html">Viemos em paz de toda a humanidade</a></li>
<li><a href="../pt460743/index.html">Guia do Iniciante do Flutter</a></li>
<li><a href="../pt460745/index.html">Experiência no uso de um módulo GSM em automação residencial</a></li>
<li><a href="../pt460747/index.html">Procure lucros ou aperte nozes: o Spotify parou de trabalhar com autores diretamente - o que significa</a></li>
<li><a href="../pt460751/index.html">Como lançamos robôs em pouco Chernobyl. Parte 1</a></li>
<li><a href="../pt460755/index.html">Robô de carrinho ROS - Parte 1: Ferro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>