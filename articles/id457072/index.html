<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ üéÖüèø üç£ Cara mengatasi masalah lama menggunakan ML dalam Python dan .Net üßìüèª üçñ üè≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebetulan beberapa tugas menghantui Anda selama bertahun-tahun. Bagi saya ini adalah tugas untuk menempelkan kalimat teks di mana transisi ke baris ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengatasi masalah lama menggunakan ML dalam Python dan .Net</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457072/"><p><img src="https://habrastorage.org/webt/bm/pi/vr/bmpivrmqylxi0ypvqte57qsnadw.png"></p><br><p>  Kebetulan beberapa tugas menghantui Anda selama bertahun-tahun.  Bagi saya ini adalah tugas untuk menempelkan kalimat teks di mana transisi ke baris baru, dan sering juga kata bungkus, tersumbat dengan kaku.  Dalam praktiknya, ini adalah teks yang diekstraksi dari PDF atau menggunakan OCR.  Seringkali orang dapat menemukan teks seperti itu di situs web perpustakaan online, dalam arsip dokumen lama yang diedit oleh editor DOS.  Dan format tersebut kemudian mengganggu penguraian yang tepat menjadi kalimat (dan, dengan tanda hubung, menjadi token) untuk pemrosesan NLP berikutnya.  Dan itu biasa untuk menunjukkan dokumen seperti itu di hasil pencarian - itu akan jelek. </p><br><p> Saya memecahkan masalah ini beberapa kali - dalam Delphi, C #.  Kemudian itu adalah algoritma yang sulit, di mana dengan tangan saya menulis, misalnya, berapa lebar teks, sehingga teks ini dianggap diformat "dengan cara lama."  Ini tidak selalu bekerja dengan sempurna, tetapi secara umum, itu sudah cukup. </p><a name="habracut"></a><br><p>  Saat ini, saya merangkak di beberapa proyek ML dengan Python.  Pada satu titik, ternyata kumpulan dokumen berikutnya terdiri dari teks yang diekstraksi dari versi PDF artikel ilmiah.  Tentu saja, teks diekstraksi dengan garis keras oleh karakter pada akhir paragraf, dengan tanda hubung.  Artinya, mustahil untuk bekerja secara normal dengan teks-teks semacam itu lebih jauh.  Python menarik karena ia memiliki hampir segalanya!  Tetapi beberapa jam pencarian tidak memberikan sesuatu yang waras (mungkin, tentu saja, ini yang saya cari).  Dan kemudian saya memutuskan sekali lagi untuk menulis post processor untuk dokumen semacam itu.  Pilihannya ada dua opsi - port kode masa lalu Anda dengan C #, atau tulis sesuatu yang bisa diajarkan.  Akhirnya, pendekatan kedua didorong oleh fakta bahwa teks ilmiah sebagian diekspor dari teks dua kolom, dan sebagian dari yang satu kolom.  Ukuran font juga berbeda.  Hal ini menyebabkan fakta bahwa versi lama, dengan batas-batas yang diizinkan terprogram, sering bekerja secara tidak benar.  Duduk secara manual lagi, mengambil opsi - yah, tidak, segera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">singularitas akan datang</a> , saya tidak punya waktu untuk ini!  Jadi, sudah diputuskan - kami sedang menulis perpustakaan menggunakan pembelajaran mesin. </p><br><p>  Semua kode dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori</a> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Notebook dengan langkah-langkah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utilitas (pada saat yang sama dan templat untuk pembuatan kode)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode yang dihasilkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kasus dokumen yang ditandai (dan tidak hanya)</a> </li></ul><br><h1 id="razmetka">  Markup </h1><br><p>  Apa buzz dan kerumitan pembelajaran mesin - jika algoritme gagal di suatu tempat, seringkali Anda tidak perlu mengubah program itu sendiri.  Cukup mengumpulkan data baru (seringkali harus dianotasi pada saat bersamaan) dan memulai kembali pembuatan model.  Komputer akan melakukan sisanya untuk Anda.  Tentu saja, ada kemungkinan bahwa untuk data baru Anda harus membuat fitur baru, mengubah arsitektur, tetapi dalam kebanyakan kasus ternyata Anda hanya perlu memverifikasi bahwa semuanya mulai berfungsi dengan baik.  Ini juga sulit - mengumpulkan dan menandai data bisa sulit.  Atau sangat sulit.  Dan juga -: sangat membosankan :-) </p><br><p>  Jadi, hal yang paling membosankan adalah markup.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Folder corpus</a> berisi dokumen yang baru saja saya ambil dari badan dokumen Krapivin2009 yang sedang saya kerjakan saat itu.  Ada 10 dokumen yang sepertinya khas bagi saya.  Saya menandai hanya 3, karena sudah pada awal pelatihan di pangkalan ini, kualitas yang cukup dari "perekat" diperoleh.  Jika di masa depan ternyata semuanya tidak begitu sederhana, maka dokumen baru dengan markup akan dimasukkan ke folder ini dan proses pembelajaran akan diulang. </p><br><p>  Dalam kasus ini, tampak nyaman bagi saya bahwa file-file tersebut tetap berupa teks, jadi format markupnya adalah menambahkan tanda di awal baris yang harus direkatkan dengan baris sebelumnya (karakter '+') atau tidak (karakter '*').  Berikut ini cuplikan (file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1005058.txt</a> ): </p><br><pre><code class="plaintext hljs">*Introduction *Customers on the web are often overwhelmed with options and flooded with promotional messages for +products or services they neither need nor want. When users cannot find what they are searching for, the +e-commerce site struggles to maintain good customer relations. *Employing a recommender system as part of a site's Customer Relationship Management (CRM) activities +can overcome the problems associated with providing users with too little information, or too much of +the wrong information. Recommender systems are able to assist customers during catalog browsing and are +an effective way to cross-sell and improve customer loyalty. *In this paper, we will compare several recommender systems being used as an essential component of +CRM tools under development at Verizon. Our solutions are purposely for the current customers and current +products - recommendations for new customers and new products are out of the scope of this paper.</code> </pre> <br><p>  Beberapa jam pekerjaan yang membosankan dan 3 file dengan 2300 contoh (satu baris - satu sampel) sudah siap.  Ini sudah cukup dalam banyak kasus untuk pengklasifikasi sederhana seperti regresi logistik, yang kemudian diterapkan. </p><br><h1 id="fichi">  Fitur </h1><br><p>  Pengklasifikasi tidak bekerja secara langsung dengan data teks.  Entri disajikan dengan fitur - angka atau tanda Boolean (yang, sekali lagi, terjemahkan ke angka 0/1) bahwa beberapa fitur ada atau tidak.  Membangun fitur yang tepat dari data yang baik adalah kunci keberhasilan pembelajaran mesin.  Fitur dari kasus kami adalah bahwa korpus kami adalah teks bahasa Inggris.  Dan saya ingin mendapatkan kebebasan bahasa minimal.  Setidaknya dalam bahasa Eropa.  Karena itu, untuk fitur teks kami menggunakan sedikit trik. </p><br><p>  Mengonversi teks ke daftar fitur dan label, apakah akan merekat dengan baris sebelumnya, dilakukan oleh fungsi pembantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">_featurize_text_with_annotation</a> : </p><br><pre> <code class="python hljs">x, y = pdf_lines_gluer._featurize_text_with_annotation(raw_text)</code> </pre> <br><p>  Catatan - di sini dan selanjutnya sebagian besar fragmen kode dalam python go, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat sepenuhnya di laptop</a> . </p><br><p>  Fitur yang Digunakan: </p><br><ul><li>  'this_len' - panjang baris saat ini dalam karakter. </li><li>  'mean_len' - panjang rata-rata garis dalam rentang -5 ... + 5 garis. </li><li>  'prev_len' - panjang baris sebelumnya dalam karakter. </li><li>  'first_chars' - di sini adalah fitur rumit kami.  2 karakter pertama dari string ditempatkan di sini.  Tetapi pada saat yang sama, semua huruf kecil (dari alfabet apa saja) digantikan oleh karakter bahasa Inggris 'a', huruf kapital diganti dengan 'A', angka digantikan oleh '0'.  Ini secara signifikan mengurangi jumlah tanda yang mungkin, sambil meringkasnya.  Contoh dari apa yang terjadi: 'Aa', 'aa', 'AA', '0.', 'a-' ... </li><li>  'isalpha' - apakah surat itu adalah karakter terakhir dari baris sebelumnya. </li><li>  'isdigit' - apakah digit adalah karakter terakhir dari baris sebelumnya. </li><li>  'islower' - apakah huruf kecil adalah karakter terakhir dari baris sebelumnya. </li><li>  'punct' - tanda baca yang berakhir dengan baris sebelumnya, atau spasi untuk karakter lain. </li></ul><br><p>  Contoh serangkaian fitur untuk satu baris: </p><br><pre> <code class="plaintext hljs">{'this_len': 12, 'mean_len': 75.0, 'prev_len': 0, 'first_chars': 'Aa', 'isalpha': False, 'isdigit': False, 'islower': False, 'punct': ' '}</code> </pre> <br><p>  Agar classifier dari paket sklearn dapat digunakan, kami menggunakan kelas DictVectorizer, yang fitur stringnya (kami punya 'first_chars') dikonversi menjadi beberapa kolom berjudul (nama dapat diperoleh melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">get_feature_names ()</a> ) sebagai 'first_chars = Aa ',' first_chars = 0. '.  Fitur Boolean berubah menjadi nol dan satu, sedangkan nilai numerik tetap angka - nama bidang tidak berubah.  Secara lahiriah, metode mengembalikan numpy.array kira-kira jenis ini (hanya satu baris ditampilkan): </p><br><pre> <code class="plaintext hljs">[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 39.1 30. 0. 1. 36. ]]</code> </pre> <br><h1 id="trenirovka-klassifikatora">  Pelatihan Klasifikasi </h1><br><p>  Setelah menerima serangkaian fitur dalam bentuk array angka floating point, kita sekarang dapat memulai proses pembelajaran.  Untuk melakukan ini, kami menggunakan regresi logistik sebagai penggolong.  Kelas tidak seimbang, oleh karena itu kami mengatur opsi class_weight = 'seimbang', kami memeriksa hasilnya pada bagian uji kasus: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LogisticRegression <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> classification_report clf = LogisticRegression(random_state=<span class="hljs-number"><span class="hljs-number">1974</span></span>, solver=<span class="hljs-string"><span class="hljs-string">'liblinear'</span></span>, max_iter=<span class="hljs-number"><span class="hljs-number">2000</span></span>, class_weight=<span class="hljs-string"><span class="hljs-string">'balanced'</span></span>) clf.fit(x_train, y_train) y_pred = clf.predict(x_test) print(classification_report(y_true=y_test, y_pred=y_pred))</code> </pre> <br><p>  Kami mendapatkan indikator kualitas seperti: </p><br><pre> <code class="plaintext hljs"> precision recall f1-score support False 0.82 0.92 0.86 207 True 0.96 0.91 0.94 483 accuracy 0.91 690 macro avg 0.89 0.91 0.90 690 weighted avg 0.92 0.91 0.91 690</code> </pre> <br><p>  Seperti yang Anda lihat, dalam sekitar 1/10 kasus, kami memiliki berbagai jenis kesalahan.  Namun dalam praktiknya, semuanya tidak begitu menakutkan.  Faktanya adalah bahwa bahkan dengan markup mata, tidak selalu jelas di mana akhir paragraf, dan di mana hanya akhir kalimat.  Karena itu, bahkan markup itu sendiri mungkin mengandung kesalahan seperti itu.  Tetapi kesalahan paling kritis bukanlah di mana mereka terjadi di perbatasan proposal, tetapi di mana proposal tersebut tetap sobek.  Dan ada beberapa kesalahan seperti itu dalam kenyataan. </p><br><h1 id="vosstanavlivaem-tekst">  Pulihkan teks </h1><br><p>  Waktunya telah tiba untuk mengembalikan teks yang rusak oleh ekstraksi dari PDF.  Kita sudah dapat menentukan apakah akan menempelkan garis dengan yang sebelumnya, tetapi ada satu hal lagi - tanda hubung.  Semuanya cukup mudah di sini, jadi saya mengkodekan bagian ini dengan keras (saya mengizinkan kode pseudocode): </p><br><pre> <code class="plaintext hljs">     :         :       :      :        \n</code> </pre> <br><p>  Berbekal strategi seperti itu, kami mengembalikan teks bahasa Inggris (ada kesalahan seperti "ff" dan "fi" dalam aslinya - hanya disalin dari kasing Krapivin2009): </p><br><div class="spoiler">  <b class="spoiler_title">Teks bahasa Inggris asli</b> <div class="spoiler_text"><pre> <code class="python hljs">text = <span class="hljs-string"><span class="hljs-string">"""The rapid expansion of wireless services such as cellular voice, PCS (Personal Communications Services), mobile data and wireless LANs in recent years is an indication that signicant value is placed on accessibility and portability as key features of telecommunication (Salkintzis and Mathiopoulos (Guest Ed.), 2000). devices have maximum utility when they can be used any- where at anytime". One of the greatest limitations to that goal, how- ever, is nite power supplies. Since batteries provide limited power, a general constraint of wireless communication is the short continuous operation time of mobile terminals. Therefore, power management is y Corresponding Author: Dr. Krishna Sivalingam. Part of the research was supported by Air Force Oce of Scientic Research grants F-49620-97-1- 0471 and F-49620-99-1-0125; by Telcordia Technologies and by Intel. Part of the work was done while the rst author was at Washington State Univer- sity. The authors' can be reached at cej@bbn.com, krishna@eecs.wsu.edu, pagrawal@research.telcordia.com, jcchen@research.telcordia.com c 2001 Kluwer Academic Publishers. Printed in the Netherlands. Jones, Sivalingam, Agrawal and Chen one of the most challenging problems in wireless communication, and recent research has addressed this topic (Bambos, 1998). Examples include a collection of papers available in (Zorzi (Guest Ed.), 1998) and a recent conference tutorial (Srivastava, 2000), both devoted to energy ecient design of wireless networks. Studies show that the signicant consumers of power in a typical laptop are the microprocessor (CPU), liquid crystal display (LCD), hard disk, system memory (DRAM), keyboard/mouse, CDROM drive, oppy drive, I/O subsystem, and the wireless network interface card (Udani and Smith, 1996, Stemm and Katz, 1997). A typical example from a Toshiba 410 CDT mobile computer demonstrates that nearly 36% of power consumed is by the display, 21% by the CPU/memory, 18% by the wireless interface, and 18% by the hard drive. Consequently, energy conservation has been largely considered in the hardware design of the mobile terminal (Chandrakasan and Brodersen, 1995) and in components such as CPU, disks, displays, etc. Signicant additional power savings may result by incorporating low-power strategies into the design of network protocols used for data communication. This paper addresses the incorporation of energy conservation at all layers of the protocol stack for wireless networks. The remainder of this paper is organized as follows. Section 2 introduces the network architectures and wireless protocol stack considered in this paper. Low-power design within the physical layer is brie y discussed in Section 2.3. Sources of power consumption within mobile terminals and general guidelines for reducing the power consumed are presented in Section 3. Section 4 describes work dealing with energy ecient protocols within the MAC layer of wireless networks, and power conserving protocols within the LLC layer are addressed in Section 5. Section 6 discusses power aware protocols within the network layer. Opportunities for saving battery power within the transport layer are discussed in Section 7. Section 8 presents techniques at the OS/middleware and application layers for energy ecient operation. Finally, Section 9 summarizes and concludes the paper. 2. Background This section describes the wireless network architectures considered in this paper. Also, a discussion of the wireless protocol stack is included along with a brief description of each individual protocol layer. The physical layer is further discussed. """</span></span> corrected = pdf_lines_gluer._preprocess_pdf(text, clf, v) print(corrected)</code> </pre> </div></div><br><p>  Setelah pemulihan, kami mendapatkan: </p><br><div class="spoiler">  <b class="spoiler_title">Teks Bahasa Inggris yang Dipulihkan</b> <div class="spoiler_text"><p>  Ekspansi layanan nirkabel yang cepat seperti suara seluler, PCS (Layanan Komunikasi Pribadi), data seluler, dan LAN nirkabel dalam beberapa tahun terakhir merupakan indikasi bahwa nilai signifikan diletakkan pada aksesibilitas dan portabilitas sebagai fitur utama telekomunikasi (Salkintzis dan Mathiopoulos (Tamu Ed) .), 2000).  perangkat memiliki utilitas maksimum ketika dapat digunakan di mana saja kapan saja. "Salah satu batasan terbesar untuk tujuan itu, bagaimanapun, adalah pasokan daya yang tidak terbatas. Karena baterai memberikan daya yang terbatas, kendala umum komunikasi nirkabel adalah waktu operasi singkat yang berkelanjutan dari ponsel. terminal. Oleh karena itu, manajemen daya adalah Penulis yang Berkorespondensi: Dr. Krishna Sivalingam. Bagian dari penelitian ini didukung oleh Angkatan Udara dari Penelitian Ilmiah hibah F-49620-97-10471 dan F-49620-99-1-0125; oleh Telcordia Teknologi dan oleh Intel. Bagian dari pekerjaan dilakukan ketika penulis pertama di Washington State University. Penulis dapat dihubungi di cej@bbn.com, krishna@eecs.wsu.edu, pagrawal@research.telcordia.com, jcchen@research.telcordia.com c <br>  Penerbit Akademik Kluwer 2001.  Dicetak di Belanda. <br>  Jones, Sivalingam, Agrawal dan Chen salah satu masalah yang paling menantang dalam komunikasi nirkabel, dan penelitian terbaru telah membahas topik ini (Bambos, 1998).  Contohnya termasuk kumpulan makalah yang tersedia di (Zorzi (Guest Ed.), 1998) dan tutorial konferensi baru-baru ini (Srivastava, 2000), keduanya dikhususkan untuk desain hemat energi jaringan nirkabel. <br>  Studi menunjukkan bahwa konsumen signifikan daya di laptop khas adalah mikroprosesor (CPU), liquid crystal display (LCD), hard disk, memori sistem (DRAM), keyboard / mouse, drive CDROM, drive oppy, subsistem I / O, dan kartu antarmuka jaringan nirkabel (Udani dan Smith, 1996, Stemm dan Katz, 1997).  Contoh khas dari komputer seluler Toshiba 410 CDT menunjukkan bahwa hampir 36% daya yang dikonsumsi adalah oleh layar, 21% oleh CPU / memori, <br>  18% oleh antarmuka nirkabel, dan 18% oleh hard drive.  Akibatnya, konservasi energi telah banyak dipertimbangkan dalam desain perangkat keras terminal seluler (Chandrakasan dan Brodersen, 1995) dan dalam komponen seperti CPU, disk, display, dll.  Penghematan daya tambahan yang signifikan dapat terjadi dengan memasukkan strategi berdaya rendah ke dalam desain protokol jaringan yang digunakan untuk komunikasi data.  Makalah ini membahas penggabungan konservasi energi di semua lapisan tumpukan protokol untuk jaringan nirkabel. <br>  Sisa dari makalah ini disusun sebagai berikut.  Bagian 2 memperkenalkan arsitektur jaringan dan tumpukan protokol nirkabel yang dipertimbangkan dalam makalah ini.  Desain berdaya rendah dalam lapisan fisik adalah singkat <br>  dibahas dalam Bagian 2.3.  Sumber konsumsi daya dalam terminal bergerak dan pedoman umum untuk mengurangi daya yang dikonsumsi disajikan pada Bagian 3. Bagian 4 menjelaskan pekerjaan yang berhubungan dengan protokol hemat energi dalam lapisan MAC jaringan nirkabel, dan protokol hemat daya dalam lapisan LLC dibahas dalam Bagian <br>  5. Bagian 6 membahas protokol yang mewaspadai kekuatan di dalam lapisan jaringan.  Peluang untuk menghemat daya baterai dalam lapisan transpor dibahas dalam Bagian 7. Bagian 8 menyajikan teknik di OS / middleware dan lapisan aplikasi untuk operasi hemat energi. <br>  Akhirnya, Bagian 9 merangkum dan menyimpulkan makalah ini. <br>  2. Latar Belakang <br>  Bagian ini menjelaskan arsitektur jaringan nirkabel yang dipertimbangkan dalam makalah ini.  Juga, diskusi tentang tumpukan protokol nirkabel disertakan bersama dengan deskripsi singkat dari setiap lapisan protokol individu.  Lapisan fisik dibahas lebih lanjut. </p></div></div><br><p>  Ada satu tempat yang kontroversial, tetapi secara umum, kalimat telah dipulihkan dan teks tersebut sudah dapat diproses sebagai kalimat utuh. </p><br><p>  Tetapi kami berencana untuk membuat pilihan bahasa-independen.  Dan inilah yang menjadi tujuan dari serangkaian fitur kami.  Mari kita periksa dalam teks Rusia (juga sebuah fragmen teks dari PDF): </p><br><div class="spoiler">  <b class="spoiler_title">Teks Rusia asli</b> <div class="spoiler_text"><pre> <code class="python hljs">ru_text = <span class="hljs-string"><span class="hljs-string">"""       -       (. 1.10),    ,   - .       ,      , -   .       ,       .          : 1.        ,       -  (   ,   . 1.10,    ). 2.    ( )           ,     .      ,     ."""</span></span> corrected = pdf_lines_gluer._preprocess_pdf(ru_text, clf, v) print(corrected)</code> </pre> </div></div><br><p>  Diterima: </p><br><div class="spoiler">  <b class="spoiler_title">Teks Rusia yang dipulihkan</b> <div class="spoiler_text"><p>  Metode vektor dukungan dirancang untuk menyelesaikan masalah klasifikasi dengan mencari batas keputusan yang baik (Gbr. 1.10) yang memisahkan dua set poin yang termasuk dalam kategori yang berbeda.  Batas yang menentukan dapat berupa garis atau permukaan yang membagi sampel data pelatihan ke dalam ruang yang termasuk dalam dua kategori.  Untuk mengklasifikasikan poin baru, cukup hanya memeriksa sisi perbatasan yang mana. <br>  Metode vektor pencarian mencari batas-batas tersebut dalam dua tahap: <br>  1. Data dipetakan ke dalam ruang baru dengan dimensi yang lebih tinggi, di mana batas dapat direpresentasikan sebagai hyperplane (jika data itu dua dimensi, seperti pada Gambar 1.10, hyperplane berdegenerasi menjadi sebuah garis). <br>  2. Batas keputusan yang baik (membagi hyperplane) dihitung dengan memaksimalkan jarak dari hyperplane ke titik terdekat dari setiap kelas, langkah ini disebut memaksimalkan gap.  Ini memungkinkan kami untuk menggeneralisasi klasifikasi sampel baru yang bukan milik dataset pelatihan. </p></div></div><br><p>  Semuanya sempurna di sini. </p><br><h1 id="kak-polzovatsya-kodogeneraciya">  Cara menggunakan (pembuatan kode) </h1><br><p>  Pada awalnya, saya punya rencana untuk membuat paket yang bisa dikirim menggunakan PIP, tetapi kemudian saya datang dengan cara yang lebih sederhana (untuk saya).  Seperangkat fitur ternyata tidak terlalu besar, regresi logistik itu sendiri dan DictVectorizer memiliki struktur sederhana: </p><br><ul><li>  Untuk DictVectorizer, cukup untuk menyimpan bidang <em>nama</em> dan kosa kata fitur </li><li>  LogisticRegression memiliki koefisien <em>, kelas</em> , intercept_ </li></ul><br><p>  Oleh karena itu, opsi lain terlahir dengan pembuatan kode (di laptop, ini masuk di bagian "Serialize sebagai kode"): </p><br><ol><li>  Kami membaca file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pdf_lines_gluer.py</a> , yang berisi kode tambahan untuk membuat vektor dan memulihkan teks menggunakan classifier terlatih. </li><li>  Di tempat yang ditentukan dalam kode sumber sebagai "# inject code here #", kami memasukkan kode yang menginisialisasi DictVectorizer dan LogisticRegression dalam status yang kami dapatkan di laptop setelah pelatihan.  Kami juga menyuntikkan di sini satu-satunya fungsi preprocess_pdf publik (sejauh mungkin untuk Python): <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">preprocess_pdf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text: str)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _preprocess_pdf(text, _clf, _v)</code> </pre> </li><li>  Kode yang dihasilkan ditulis ke file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pdf_preprocessor.py</a> </li></ol><br><p>  File pdf_preprocessor.py yang dihasilkan inilah yang berisi semua yang kita butuhkan.  Untuk menggunakannya, cukup ambil file yang satu ini dan letakkan di proyek Anda.  Penggunaan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pdf_preprocessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preprocess_pdf ... print(preprocess_pdf(text))</code> </pre> <br><p>  Jika Anda memiliki masalah pada beberapa teks, maka inilah yang perlu Anda lakukan: </p><br><ol><li>  Letakkan teks Anda di folder corpus, beri anotasi. </li><li>  Luncurkan laptop Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/serge-sotnyk/pdf-lines-gluer/blob/master/pdf_gluer.ipynb</a> - perlu waktu kurang dari 5 detik untuk teks saat ini. </li><li>  Ambil dan uji versi baru file pdf_preprocessor.py </li></ol><br><p>  Mungkin ada sesuatu yang salah dan kualitasnya tidak memuaskan Anda.  Maka akan sedikit lebih rumit - Anda perlu menambahkan fitur baru sampai Anda menemukan kombinasi yang benar. </p><br><h1 id="c-i-mlnet">  C # dan ML.NET </h1><br><p>  Di perusahaan kami, sebagian besar kode backend didasarkan pada .Net.  Tentu saja, berinteraksi dengan Python menambah ketidaknyamanan di sini.  Dan saya ingin memiliki solusi serupa di C #.  Saya telah mengikuti pengembangan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ML.NET</a> untuk waktu yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lama</a> .  Saya melakukan upaya kecil untuk melakukan sesuatu tahun lalu, tetapi mereka mengecewakan dengan cakupan yang tidak memadai dari berbagai kasus, sejumlah kecil dokumentasi, dan ketidakstabilan API.  Sejak musim semi tahun ini, kerangka kerja telah beralih ke status rilis dan saya memutuskan untuk mencobanya lagi.  Terlebih lagi, pekerjaan paling membosankan dengan tata letak tubuh telah dilakukan. </p><br><p>  Sekilas, kerangka kerja menambah kenyamanan.  Lebih sering saya mulai menemukan dokumentasi yang diperlukan (walaupun masih jauh dari kualitas dan kuantitas di sklearn).  Tapi yang paling penting - setahun yang lalu saya masih tidak tahu sklearn.  Dan sekarang saya mulai melihat bahwa banyak hal dalam ML.NET coba lakukan dalam gambar dan rupa (sejauh mungkin, mengingat perbedaan dalam platform).  Analogi ini telah membuatnya lebih mudah untuk mempelajari prinsip-prinsip ML.NET dalam praktiknya. </p><br><p>  Proyek yang berfungsi pada platform ini dapat dilihat di <a href="">https://github.com/serge-sotnyk/pdf-postprocess.cs</a> </p><br><p>  Prinsip-prinsip umum tetap sama - dalam folder corpus terletak dokumen anotized (dan tidak demikian).  Setelah meluncurkan proyek ModelCreator, di sebelah folder corpus, kita akan melihat folder model, di mana arsip dengan model yang terlatih akan ditempatkan.  Ini masih regresi logistik yang sama dengan fitur yang sama. </p><br><p>  Tapi di sini saya tidak mencoba-coba pembuatan kode lagi.  Untuk menggunakan model terlatih, ambil proyek PdfPostprocessor (yang secara internal memiliki model PdfPostprocessModel.zip dikompilasi sebagai sumber daya).  Setelah itu, model dapat digunakan, seperti yang ditunjukkan pada contoh minimum - <a href="">https://github.com/serge-sotnyk/pdf-postprocess.cs/blob/master/MinimalUsageExample/Program.cs</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PdfPostprocessor; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> postprocessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Postprocessor(); Console.WriteLine(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Restored paragraphs in the English text:"</span></span>); Console.WriteLine(postprocessor.RestoreText(EnText)); Console.WriteLine(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Restored paragraphs in the Russian text:"</span></span>); Console.WriteLine(postprocessor.RestoreText(RuText)); }</code> </pre> <br><p>  Sementara menyalin model dari folder model ke proyek PdfPostprocessor dilakukan secara manual - lebih mudah bagi saya untuk lebih mengontrol model mana yang masuk ke proyek akhir. </p><br><p>  Ada paket nuget - PdfPostprocessor.  Untuk menggunakan paket dan model yang Anda latih, gunakan konstruktor Postprocessor yang kelebihan beban. </p><br><h1 id="sravnenie-variantov-na-python-i-c35">  Membandingkan opsi dengan Python dan C # </h1><br><p>  Meskipun baru dari pengalaman pengembangan pada dua platform, mungkin masuk akal untuk menceritakannya kembali secara singkat.  Saya belum menjadi pendukung militan platform tertentu untuk waktu yang lama dan bersimpati pada perasaan orang-orang percaya dari berbagai agama.  Anda juga perlu memahami bahwa saya masih bekerja dengan bahasa dengan pengetikan statis untuk sebagian besar hidup saya, jadi mereka hanya sedikit lebih dekat dengan saya. </p><br><h3 id="chto-ne-ponravilos-pri-perehode-na-c35">  Apa yang saya tidak suka ketika beralih ke C # </h3><br><ul><li>  Verbositas.  Namun, kode Python lebih ringkas.  Ini adalah tidak adanya tanda kurung operator, dan tanda kurung setelah jika, untuk.  Kurangnya baru tak berujung.  Penggunaan bidang secara aktif karena mudah diubah menjadi properti jika perlu.  Bahkan dengan fakta bahwa privasi dalam Python, yang hanya ditunjukkan oleh garis bawah pada awal pengidentifikasi, Anda terbiasa dan dalam praktiknya ternyata sangat nyaman, lebih nyaman daripada sekelompok pengubah privasi dalam bahasa lain.  Dan singkatnya konstruksi mempercepat pengembangan dan memfasilitasi pembacaan kode. </li><li>  Dalam kebanyakan kasus, kode Python terlihat lebih bersih dan lebih elegan (ini hanya subjektif).  Ini membuatnya lebih mudah untuk dibaca dan dipelihara. </li><li>  Untuk Python, untuk hampir semuanya, ada semacam fungsi atau dekorator dalam beberapa jenis paket, tetapi dalam C # banyak yang harus ditambahkan.  Ini lebih lanjut mengembang kode dengan berbagai fungsi pembantu, kelas.  Dan itu membutuhkan lebih banyak waktu. </li><li>  Tingkat dokumentasi C # dan kerangka kerjanya secara signifikan lebih rendah daripada di ekosistem Python. </li><li>  Pengetikan yang lebih ketat dari ML.NET dibandingkan dengan sklearn omnivora juga memaksa kami untuk meluangkan waktu mencari transformasi yang tepat, dan paragraf sebelumnya tidak berkontribusi untuk memecahkan masalah ini. </li></ul><br><h3 id="chto-ponravilos-pri-perehode-na-c35">  Apa yang Anda sukai saat beralih ke C # </h3><br><ul><li>  Rasa keandalan.  Sudah tidak terlalu sering, tetapi cukup teratur, Python omnivora membawa saya ke masalah yang sulit dipahami.  Dan sekarang, ketika porting kode ke C #, ada kesalahan yang membuat beberapa fitur tidak berguna.  Setelah koreksi, akurasinya naik beberapa persen. </li><li>  Kecepatan.  Dalam kode Python, saya harus meninggalkan fitur yang terkait dengan keputusan menempel yang dibuat dalam penawaran sebelumnya - jika Anda mengirimkan proposal ke pengklasifikasi satu per satu, kecepatan keseluruhan akan lebih rendah daripada alas tiang.  Agar pemrosesan data dalam Python menjadi cepat, perlu untuk membuat vektor sebanyak mungkin dan kadang-kadang membuat kita menolak dari opsi yang berpotensi berguna, atau sangat sulit untuk membuatnya. </li><li>  Linq.  Mereka jauh lebih nyaman daripada List Comprehension (LC) dengan Python.  Bahkan sebuah LC dengan satu untuk memaksa saya untuk menulis terlebih dahulu apa setelah masuk, kemudian kembali ke awal dan menambahkan, dan hanya kemudian menulis ekspresi di awal LC.  Hanya saja, dalam urutan itu, saya pikir - sumber catatan, barang, apa yang harus dikonversi.  LINQ (  "" )     .    LC (  for)   . ,       ,   . </li><li> Lambda.    ,   .   ,   C#   . </li></ul><br><p>      ‚Äî      .      ,    .Net     ,   .    -  ‚Äî   REST       C#. </p><br><p>  C#   .            ‚Äî      ,    - .   Microsoft     Kotlin ‚Äî    .Net      ,         .          Python- ‚Äî ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Julia</a> .      . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>    : </p><br><ul><li>   ,     ‚Äî  ,    ,   -    . , ,   -   . </li><li>    .  ,   ML.NET     - .       . </li><li> ,    Python-     .Net.         , . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457072/">https://habr.com/ru/post/id457072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457062/index.html">Pusat Pelatihan Kosmonot di Star City</a></li>
<li><a href="../id457064/index.html">Untuk pertanyaan tentang modul</a></li>
<li><a href="../id457066/index.html">Cara memodifikasi robot FEDOR dan kursi penerbangan ISS</a></li>
<li><a href="../id457068/index.html">Antrian - apa itu, mengapa dan bagaimana menggunakannya? Lihatlah fitur AWS SQS</a></li>
<li><a href="../id457070/index.html">Textolite bukan karton. Beberapa kata tentang lencana interaktif OFFZONE 2019</a></li>
<li><a href="../id457074/index.html">Evolusi pengembang: game apa yang harus kita harapkan di masa depan</a></li>
<li><a href="../id457078/index.html">Cara mengubah avatar Telegram Anda menjadi arloji</a></li>
<li><a href="../id457082/index.html">Pemberian hak administrator yang tidak sensitif</a></li>
<li><a href="../id457086/index.html">Pola arsitektur "Builder" di alam semesta "Swift" dan "iOS" / "macOS"</a></li>
<li><a href="../id457090/index.html">Safety Cribs: JWT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>