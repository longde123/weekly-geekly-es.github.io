<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 👌🏽 🛕 Implementando a API do Spring Framework a partir do zero. Passo a passo para iniciantes. Parte 1 🔱 💇🏼 👨‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Spring Framework é um dos mais complicados para entender e aprender. A maioria dos desenvolvedores aprende devagar, através de tarefas práticas e do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementando a API do Spring Framework a partir do zero. Passo a passo para iniciantes. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  O Spring Framework é um dos mais complicados para entender e aprender.  A maioria dos desenvolvedores aprende devagar, através de tarefas práticas e do google.  Essa abordagem não é eficaz, pois não fornece uma imagem completa e, ao mesmo tempo, é cara. <br><br>  Gostaria de oferecer a você uma abordagem fundamentalmente nova para o estudo da primavera.  Consiste no fato de que uma pessoa passa por uma série de tutoriais especialmente preparados e implementa independentemente o funcionamento da primavera.  A peculiaridade dessa abordagem é que, além de uma compreensão 100% dos aspectos estudados do Spring, também oferece um grande aumento no Java Core (anotações, reflexão, arquivos, genéricos). <br><br>  O artigo fornecerá uma experiência inesquecível e fará você se sentir como um desenvolvedor Pivotal.  Passo a passo, você fará suas aulas se tornarem melhores e organizará seu ciclo de vida (o mesmo que em uma primavera real).  As classes que você implementará são <b>BeanFactory</b> , <b>Component</b> , <b>Service</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InitializingBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  Um pouco sobre você </h2><br>  Meu nome é Yaroslav e sou desenvolvedor Java com 4 anos de experiência.  No momento, trabalho na EPAM Systems (SPB) e me aprofundo nas tecnologias que usamos.  Muitas vezes tenho que lidar com a primavera, e vejo nela um meio-termo no qual você pode crescer (Java todo mundo sabe tão bem, e ferramentas e tecnologias específicas demais podem ir e vir). <br><br>  Há alguns meses, passei na certificação Spring Professional v5.0 (sem fazer cursos).  Depois disso, pensei em como ensinar outras pessoas a saltar.  Infelizmente, no momento não existe uma metodologia de ensino eficaz.  A maioria dos desenvolvedores tem uma idéia muito superficial da estrutura e seus recursos.  Depurar as fontes da primavera é muito difícil e absolutamente não é eficaz do ponto de vista do treinamento (eu gostava disso).  Faça 10 projetos?  Sim, você pode aprofundar seu conhecimento em algum lugar e obter muita experiência prática, mas muito do que está “escondido” nunca será aberto antes de você.  Leia Primavera em ação?  Legal, mas caro no esforço.  Eu trabalhei 40% (durante a preparação para a certificação), mas não foi fácil. <br><br>  A única maneira de entender algo até o fim é desenvolvê-lo você mesmo.  Recentemente, tive a ideia de que você pode liderar uma pessoa através de um tutorial interessante que supervisionará o desenvolvimento de sua estrutura de DI.  Sua principal característica será que a API coincidirá com a API que está sendo estudada.  A grandiosidade dessa abordagem é que, além de uma compreensão profunda (sem espaços) da primavera, uma pessoa terá uma enorme quantidade de experiência no Java Core.  Francamente, eu próprio aprendi muitas coisas novas durante a preparação do artigo, tanto no Spring quanto no Java Core.  Vamos começar a desenvolver! <br><br><h2>  Projeto do zero </h2><br>  Portanto, a primeira coisa a fazer é abrir seu IDE favorito e criar um projeto a partir do zero.  Não conectaremos nenhum Maven ou qualquer biblioteca de terceiros.  Nós nem vamos conectar as dependências do Spring.  Nosso objetivo é desenvolver uma API que seja mais semelhante à API Spring e implementá-la. <br><br>  Em um projeto limpo, crie 2 pacotes principais.  O primeiro pacote é seu aplicativo ( <code>com.kciray</code> ) e a classe <code>Main.java</code> dentro dele.  O segundo pacote é org.springframework.  Sim, duplicaremos a estrutura do pacote da mola original, o nome de suas classes e seus métodos.  Há um efeito tão interessante - quando você cria algo próprio, esse começa a parecer simples e compreensível.  Então, quando você trabalha em grandes projetos, parece que tudo é criado lá com base na sua peça de trabalho.  Essa abordagem pode ter um efeito muito positivo na compreensão do sistema como um todo, aprimorando-o, corrigindo bugs, resolvendo problemas e assim por diante. <br><br>  Se você tiver algum problema, pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fazer um</a> projeto em funcionamento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Crie um container </h2><br>  Para começar, defina a tarefa.  Suponha que tenhamos 2 classes - <code>ProductFacade</code> e <code>PromotionService</code> .  Agora imagine que você deseja conectar essas classes entre si, mas para que as próprias classes não se conheçam (Padrão DI).  Precisamos de uma classe separada que gerencie todas essas classes e determine as dependências entre elas.  Vamos chamar de contêiner.  Vamos criar a classe <code>Container</code> ... Embora não, espere!  O Spring não possui uma única classe de contêiner.  Temos muitas implementações de contêineres, e todas essas implementações podem ser divididas em 2 tipos - fábricas e contextos.  A fábrica de caixas cria beans e os vincula (injeção de dependência, DI), e o contexto faz o mesmo, além de adicionar alguns recursos adicionais (por exemplo, internacionalizar mensagens).  Mas como não precisamos dessas funções adicionais agora, trabalharemos com a fábrica de lixeiras. <br><br>  Crie uma nova classe <code>BeanFactory</code> e coloque-a no pacote <code>org.springframework.beans.factory</code> .  Deixe os <code>Map&lt;String, Object&gt; singletons</code> armazenados dentro dessa classe, na qual o <code>id</code> compartimento é mapeado para o próprio compartimento.  Adicione a ele o <code>Object getBean(String beanName)</code> , que extrai os beans pelo identificador. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Observe que <code>BeanFactory</code> e <code>FactoryBean</code> são duas coisas diferentes.  A primeira é a fábrica de lixeiras (contêiner) e a segunda é a fábrica de lixeiras, que fica dentro do contêiner e também produz caixas.  Fábrica dentro da fábrica.  Se você estiver confuso entre essas definições, lembre-se de que em inglês o segundo substantivo é o principal e o primeiro é algo como um adjetivo.  Na <b>Fábrica de</b> Feijão <b>, a</b> palavra principal é a fábrica, e na Fábrica de <b>Feijão</b> , o feijão. <br><br>  Agora, crie as classes <code>ProductService</code> e <code>PromotionsService</code> .  <code>ProductService</code> retornará o produto do banco de dados, mas antes disso você precisará verificar se há descontos (Promoções) aplicáveis ​​a este produto.  No comércio eletrônico, o trabalho com desconto geralmente é alocado para uma classe de serviço separada (e às vezes para um serviço da web de terceiros). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Agora precisamos fazer nosso contêiner ( <code>BeanFactory</code> ) detectar nossas classes, criá-las para nós e injetar uma na outra.  Operações como o <code>new ProductService()</code> devem estar localizadas dentro do contêiner e feitas pelo desenvolvedor.  Vamos usar a abordagem mais moderna (digitalização de classe e anotações).  Para fazer isso, precisamos criar uma anotação <code>@Component</code> com as <code>@Component</code> ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  Por padrão, as anotações não são carregadas na memória enquanto o programa está em execução ( <code>RetentionPolicy.CLASS</code> ).  Alteramos esse comportamento por meio de uma nova política de retenção ( <code>RetentionPolicy.RUNTIME</code> ). <br><br>  Agora adicione <code>@Component</code> antes das classes <code>ProductService</code> e antes do <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  Precisamos do <code>BeanFactory</code> escanear nosso pacote ( <code>com.kciray</code> ) e encontrar classes nele anotadas por <code>@Component</code> .  Esta tarefa está longe de ser trivial.  Não existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma solução pronta</a> no Java Core, e teremos que fazer uma muleta.  Milhares de aplicações de molas usam a digitalização de componentes nessa muleta.  Você aprendeu a terrível verdade.  Você terá que extrair os nomes de <code>ClassLoader</code> do <code>ClassLoader</code> e verificar <code>ClassLoader</code> eles terminam com ".class" ou não, e então criar seu nome completo e extrair objetos de classe! <br><br>  Quero avisar imediatamente que haverá muitas exceções verificadas, portanto, esteja preparado para quebrá-las.  Mas primeiro, vamos decidir o que queremos.  Queremos adicionar um método especial ao <code>BeanFactory</code> e chamá-lo em <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  Em seguida, precisamos obter o <code>ClassLoader</code> .  Ele é responsável pelo carregamento de classes e é extraído de maneira simples: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Você provavelmente já percebeu que os pacotes são separados por um ponto e os arquivos por uma barra.  Precisamos converter o caminho do lote para o caminho da pasta e obter algo como <code>List&lt;URL&gt;</code> (os caminhos no seu sistema de arquivos onde você pode procurar por arquivos de classe). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  Então espere um momento!  <code>Enumeration&lt;URL&gt;</code> não é uma <code>List&lt;URL&gt;</code> .  O que é isso tudo?  Ah, horror, esse é o antigo progenitor do <code>Iterator</code> , disponível desde o Java 1.0.  É com esse legado que devemos lidar.  Se for possível percorrer o <code>Iterable</code> usando for (todas as coleções o implementam), no caso de <code>Enumeration</code> você precisará fazer um desvio de identificador, através de <code>while(resources.hasMoreElements())</code> e <code>nextElement()</code> .  E, no entanto, não há como remover itens da coleção.  Apenas 1996, apenas hardcore.  Ah, sim, no Java 9 eles adicionaram o método <code>Enumeration.asIterator()</code> , para que você possa trabalhar com ele. <br><br>  Vamos mais longe.  Precisamos extrair as pastas e trabalhar com o conteúdo de cada uma delas.  Converta o URL em um arquivo e obtenha seu nome.  Deve-se notar aqui que não verificaremos pacotes aninhados para não complicar o código.  Você pode complicar sua tarefa e fazer uma recursão, se desejar. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  Em seguida, precisamos obter o nome do arquivo sem a extensão.  No estaleiro em 2018, o Java desenvolveu o File I / O (NIO 2) por muitos anos, mas ainda não pode separar a extensão do nome do arquivo.  Eu tenho que criar minha própria bicicleta, porque  decidimos não usar bibliotecas de terceiros como o Apache Commons.  Vamos usar o antigo avô como <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  Em seguida, podemos obter o objeto de classe usando o nome completo da classe (para isso chamamos de classe da classe <code>Class</code> ): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  Ok, agora nossas aulas estão em nossas mãos.  Além disso, resta apenas destacar entre eles aqueles que possuem a anotação <code>@Component</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Corra e verifique.  O console deve ser algo como isto: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Agora precisamos criar nosso bean.  Você precisa fazer algo como o <code>new ProductService()</code> , mas para cada bean, temos nossa própria classe.  A reflexão em Java nos fornece uma solução universal (o construtor padrão é chamado): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  Em seguida, precisamos colocar esse bean nos <code>Map&lt;String, Object&gt; singletons</code> .  Para fazer isso, selecione o nome do bean (seu ID).  Em Java, chamamos variáveis ​​como classes (apenas a primeira letra é minúscula).  Essa abordagem também pode ser aplicada aos beans, porque o Spring é uma estrutura Java!  Converta o nome da lixeira para que a primeira letra seja pequena e adicione-a ao mapa: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Agora verifique se tudo funciona.  O contêiner deve criar beans e eles devem ser recuperados pelo nome.  Observe que o nome do seu método <code>instantiate()</code> e o nome do método <code>classObject.newInstance();</code>  tem uma raiz comum.  Além disso, <code>instantiate()</code> faz parte do ciclo de vida do feijão.  Em Java, tudo está interconectado! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Tente também implementar a anotação <code>org.springframework.beans.factory.stereotype.Service</code> .  Ele executa exatamente a mesma função que o <code>@Component</code> , mas é chamado de maneira diferente.  O ponto principal está no nome - você demonstra que a classe é um serviço, não apenas um componente.  Isso é algo como digitação conceitual.  Na certificação da primavera, houve a pergunta "Quais anotações são estereotipadas?"  (dos listados). ”  Portanto, anotações estereotipadas são aquelas que estão no pacote de <code>stereotype</code> . <br><br><h2>  Preencha as propriedades </h2><br>  Veja o diagrama abaixo, que mostra o início do ciclo de vida do feijão.  O que fizemos antes disso é o Instantiate (criando beans através de <code>newInstance()</code> ).  O próximo passo é a injeção cruzada de feijão (injeção de dependência, é também a inversão de controle (IoC)).  Você precisa examinar as propriedades dos beans e entender quais propriedades você precisa injetar.  Se você chamar <code>productService.getPromotionsService()</code> , será <code>null</code> porque  dependência ainda não adicionada. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  Primeiro, crie o pacote <code>org.springframework.beans.factory.annotation</code> e adicione a anotação <code>@Autowired</code> .  A idéia é sinalizar campos que são dependências com esta anotação. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  Em seguida, adicione-o à propriedade: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Agora precisamos ensinar nosso <code>BeanFactory</code> encontrar essas anotações e injetar dependências nelas.  Adicione um método separado para isso e chame-o de <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  Em seguida, precisamos apenas examinar todos os nossos compartimentos no mapa de <code>singletons</code> e, para cada compartimento, todos os seus campos ( <code>object.getClass().getDeclaredFields()</code> retorna todos os campos, incluindo os privados).  E verifique se o campo possui uma anotação <code>@Autowired</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Em seguida, precisamos examinar todas as caixas mais uma vez e ver seu tipo - de repente, esse é o tipo que nossa lixeira quer usar por si mesma.  Sim, temos um ciclo tridimensional! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  Além disso, quando encontramos o vício, precisamos injetá-lo.  A primeira coisa que você pode pensar é escrever o campo <code>promotionsService</code> usando a reflexão diretamente.  Mas a primavera não funciona assim.  Afinal, se o campo tiver um modificador <code>private</code> , primeiro precisaremos defini-lo como <code>public</code> , depois escreva nosso valor e, em seguida, defina- <code>private</code> novamente como <code>private</code> (para manter a integridade).  Parece uma muleta grande.  Em vez de uma muleta grande, vamos fazer uma muleta pequena (formaremos o nome do levantador e o chamaremos): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  Agora execute seu projeto e certifique-se de que, ao chamar <code>productService.getPromotionsService()</code> vez de <code>null</code> , nosso bean seja retornado. <br><br>  O que implementamos é a injeção por tipo.  Também há uma injeção pelo nome (anotação <code>javax.annotation.Resource</code> ).  É diferente porque, em vez do tipo do campo, seu nome será extraído e, de acordo com ele - a dependência do mapa.  Tudo é semelhante aqui, mesmo em algo mais simples.  Eu recomendo que você experimente e crie seu próprio bean, injete-o com <code>@Resource</code> e estenda o método <code>populateProperties()</code> . <br><br><h2>  Apoiamos beans que sabem sobre seu nome </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  Há momentos em que você precisa colocar o nome dele dentro da lixeira.  Essa necessidade não surge frequentemente, porque  caixas, em essência, não devem saber um sobre o outro e que são caixas.  Nas primeiras versões da primavera, foi assumido que o bean é um POJO (Plain Old Java Objec, o bom e antigo objeto Java) e toda a configuração é renderizada em arquivos XML e separada da implementação.  Mas implementamos essa funcionalidade, pois a injeção de nome faz parte do ciclo de vida da lixeira. <br><br>  Como sabemos qual bean quer saber qual é o nome dele e o que ele não quer?  A primeira coisa que vem à mente é fazer uma nova anotação do tipo <code>@InjectName</code> e esculpir em campos do tipo String.  Mas essa solução será muito geral e permitirá que você se atire várias vezes (coloque essa anotação em campos de tipos inapropriados (não String) ou tente inserir um nome em vários campos da mesma classe).  Existe outra solução, mais precisa - para criar uma interface especial com um método de incubação.  Todos os compartimentos que o implementam recebem seu nome.  Crie a classe <code>BeanNameAware</code> no pacote <code>org.springframework.beans.factory</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  Em seguida, permita que o nosso <code>PromotionsService</code> implemente: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  E, finalmente, adicione um novo método à fábrica de feijão.  Tudo é simples aqui - examinamos nosso bin-singleton, verificamos se o bin implementa nossa interface e chamamos o setter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  Execute e verifique se tudo funciona: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  Note-se que na primavera existem outras interfaces semelhantes.  Eu recomendo que você implemente a interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BeanFactoryAware</a> , que permite que os beans recebam um link para a fábrica de beans.  É implementado de maneira semelhante. <br><br><h2>  Inicializar Beans </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Imagine que você tem uma situação em que precisa executar algum código após as dependências serem injetadas (as propriedades da bandeja são definidas).  Em termos simples, precisamos dar à lixeira a capacidade de se inicializar.  Como alternativa, podemos criar uma interface <code>InitializingBean</code> e colocar a assinatura do método <code>void afterPropertiesSet()</code> nela.  A implementação desse mecanismo é exatamente a mesma apresentada para a interface <code>BeanNameAware</code> , portanto, a solução está sob o spoiler.  Pratique e faça você mesmo em um minuto: <br><br><div class="spoiler">  <b class="spoiler_title">Solução de Inicialização do Bean</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Adicionando pós-processadores </h2><br>  Imagine-se no lugar dos primeiros desenvolvedores da primavera.  Sua estrutura está crescendo e é muito popular entre os desenvolvedores; cartas são enviadas diariamente para o correio com solicitações para adicionar um ou outro recurso útil.  Se, para cada um desses recursos, você adicionar sua própria interface e verificar o ciclo de vida do bean, ele (o ciclo de vida) ficará entupido com informações desnecessárias.  Em vez disso, podemos criar uma interface universal que nos permita adicionar alguma lógica (absolutamente qualquer, esteja ela verificando anotações, substituindo a bandeja por outra, definindo algumas propriedades especiais e assim por diante). <br><br>  Vamos pensar sobre o que é essa interface.  Ele precisa fazer algum pós-processamento dos beans, portanto, pode ser chamado de BeanPostProcessor.  Mas estamos diante de uma pergunta difícil - quando a lógica deve ser seguida?  Afinal, podemos executá-lo antes da inicialização, mas podemos executá-lo depois.  Para algumas tarefas, a primeira opção é melhor, para outras - a segunda ... Como ser? <br><br>  Podemos ativar as duas opções ao mesmo tempo.  Deixe um pós-processador transportar duas lógicas, dois métodos.  Um é executado antes da inicialização (antes do método <code>afterPropertiesSet()</code> ) e o outro depois.  Agora, vamos pensar nos próprios métodos - quais parâmetros eles devem ter?  Obviamente, o próprio <code>Object bean</code> ( <code>Object bean</code> ) deve estar lá.  Por conveniência, além do bean, você pode passar o nome desse bean.  Você se lembra que o próprio compartimento não sabe sobre o seu nome.  E não queremos forçar todos os beans a implementar a interface BeanNameAware.  Mas, no nível pós-processador, o nome do bean pode ser muito útil.  Portanto, nós o adicionamos como o segundo parâmetro. <br><br>  E o que o método deve retornar ao pós-processamento do bean?  Vamos fazer com que ele devolva a lixeira.  Isso nos dá uma super flexibilidade, porque em vez de uma lixeira, você pode colocar um objeto proxy que encerra suas chamadas (e adiciona segurança).  Ou você pode retornar completamente outro objeto recriando a bandeja novamente.  Os desenvolvedores têm uma grande liberdade de ação.  Abaixo está a versão final da interface projetada: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  Em seguida, precisamos adicionar uma lista de processadores simples à nossa fábrica de beans e a capacidade de adicionar novos.  Sim, este é um ArrayList regular. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  Agora mude o método <code>initializeBeans</code> para levar em conta os pós-processadores: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Vamos criar um pequeno pós-processador que simplesmente rastreia as chamadas para o console e adicione-o à nossa fábrica de feijão: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  Agora execute e verifique se tudo funciona.  Como tarefa de treinamento, crie um pós-processador que fornecerá a anotação <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  Ele fornece uma maneira alternativa de inicializar (enraizada em Java, não na primavera).  Sua essência é que você coloca a anotação em algum método, e esse método será chamado ANTES da inicialização padrão da primavera (InitializingBean). <br><br>  Certifique-se de criar todas as anotações e pacotes (mesmo javax.annotation) manualmente, não conecte as dependências!  Isso ajudará você a ver a diferença entre o núcleo da mola e suas extensões (suporte a javax), e lembre-se disso.  Isso manterá um estilo no futuro. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você estará interessado no fato de que, em uma primavera real, a anotação </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é implementada dessa maneira, por meio do CommonAnnotationBeanPostProcessor do pós-processador. </font><font style="vertical-align: inherit;">Mas não espie lá, escreva sua implementação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, recomendo que você adicione um método </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à classe </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e elabore mais dois mecanismos. </font><font style="vertical-align: inherit;">A primeira é uma anotação </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, destinada a métodos que devem ser chamados quando o contêiner é fechado. </font><font style="vertical-align: inherit;">O segundo é a interface </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contém o método </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Todos os compartimentos executando esta interface terão a capacidade de se destruir (liberar recursos, por exemplo).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + DisposableBean</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclo de vida completo do feijão </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, implementamos o ciclo de vida completo da lixeira, em sua forma moderna. </font><font style="vertical-align: inherit;">Espero que essa abordagem ajude você a se lembrar dela.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nosso contexto favorito </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os programadores costumam usar o termo contexto, mas nem todos entendem o que realmente significa. </font><font style="vertical-align: inherit;">Agora vamos colocar tudo em ordem. </font><font style="vertical-align: inherit;">Como observei no início do artigo, o contexto é a implementação do contêiner, assim como </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas, além das funções básicas (DI), ele ainda adiciona alguns recursos interessantes. </font><font style="vertical-align: inherit;">Um desses recursos é o envio e o processamento de eventos entre os compartimentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O artigo acabou sendo muito grande e o conteúdo começou a ser cortado, então coloquei as informações de contexto embaixo do spoiler.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percebemos o contexto</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     « »     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  Mas não.   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   —   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Conclusão </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, planejei este artigo para o Baeldung em inglês, mas depois pensei que o público do Habré poderia avaliar positivamente essa abordagem do treinamento. </font><font style="vertical-align: inherit;">Se você gostou das minhas idéias, não deixe de apoiar o artigo. </font><font style="vertical-align: inherit;">Se ela obtiver uma classificação superior a 30, prometo continuar. </font><font style="vertical-align: inherit;">Ao escrever o artigo, tentei mostrar exatamente o conhecimento do Spring Core, que é mais frequentemente usado, e também com base no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guia de Estudo de Certificação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Core Spring 5.0</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No futuro, com a ajuda desses tutoriais, você poderá cobrir toda a certificação e tornar a primavera mais acessível para os desenvolvedores Java.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atualização 05/10/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartas constantemente me chegam com perguntas "e quando a continuação estamos esperando por ele". </font><font style="vertical-align: inherit;">Mas não há tempo, e outros projetos pessoais são uma prioridade. </font><font style="vertical-align: inherit;">No entanto, se um de vocês realmente gostou da ideia, pode estudar a seção estreita da primavera e escrever um artigo de continuação. </font><font style="vertical-align: inherit;">Se você não possui uma conta habr, posso publicar um artigo da minha conta ou ajudá-lo a receber um convite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribuição de tópicos: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Container - [nome de usuário] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP - [nome de usuário] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Web - [nome de usuário] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [nome de usuário]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419679/">https://habr.com/ru/post/pt419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419669/index.html">Dez melhores mouses para jogos para qualquer carteira</a></li>
<li><a href="../pt419671/index.html">Limitações que precisam ser violadas ou como aceleramos os testes funcionais três vezes</a></li>
<li><a href="../pt419673/index.html">O universo primitivo 6. A dinâmica de um universo em expansão homogêneo, parte 2</a></li>
<li><a href="../pt419675/index.html">Avaliação do aluguel por minuto de scooters elétricas em Moscou, verão de 2018</a></li>
<li><a href="../pt419677/index.html">Como detectar o tráfego HTTPS de um dispositivo iOS</a></li>
<li><a href="../pt419683/index.html">O que as métricas significam para equipes ágeis?</a></li>
<li><a href="../pt419685/index.html">As estruturas de dados mais importantes que você deve saber sobre sua entrevista de programação</a></li>
<li><a href="../pt419687/index.html">Teclado secreto nível 3 ou como imprimir um traço longo</a></li>
<li><a href="../pt419689/index.html">I. Desadaptação. II TDAH ou um idiota preguiçoso?</a></li>
<li><a href="../pt419693/index.html">Mikrotik: reset, backups e DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>