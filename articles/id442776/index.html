<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â› ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ¤¬ Indeks dalam PostgreSQL - 3 (Hash) ğŸ˜– ğŸ¨ ğŸš</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel pertama menjelaskan mesin pengindeksan PostgreSQL , yang kedua berhubungan dengan antarmuka metode akses , dan sekarang kami siap untuk membah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 3 (Hash)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442776/">  Artikel pertama menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan PostgreSQL</a> , yang kedua berhubungan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka metode akses</a> , dan sekarang kami siap untuk membahas jenis indeks tertentu.  Mari kita mulai dengan indeks hash. <br><br><h1>  Hash </h1><br><h2>  Struktur </h2><br><h3>  Teori umum </h3><br>  Banyak bahasa pemrograman modern menyertakan tabel hash sebagai tipe data dasar.  Di luar, tabel hash terlihat seperti array biasa yang diindeks dengan tipe data apa pun (misalnya, string) daripada dengan angka integer.  Indeks hash di PostgreSQL disusun dengan cara yang serupa.  Bagaimana cara kerjanya? <br><br>  Sebagai aturan, tipe data memiliki rentang yang sangat besar dari nilai yang diizinkan: berapa banyak string yang berbeda yang dapat kita bayangkan dalam kolom tipe "teks"?  Pada saat yang sama, berapa banyak nilai yang berbeda sebenarnya disimpan dalam kolom teks dari beberapa tabel?  Biasanya tidak begitu banyak. <br><br>  Gagasan hashing adalah untuk mengasosiasikan sejumlah kecil (dari 0 hingga <em>N</em> âˆ’1, nilai total <em>N</em> ) dengan nilai tipe data apa pun.  Asosiasi seperti ini disebut <em>fungsi hash</em> .  Angka yang diperoleh dapat digunakan sebagai indeks dari array reguler di mana referensi ke baris tabel (TIDs) akan disimpan.  Elemen dari array ini disebut <em>bucket tabel hash</em> - satu ember dapat menyimpan beberapa TID jika nilai indeks yang sama muncul di baris yang berbeda. <br><br>  Semakin banyak fungsi hash mendistribusikan nilai sumber dengan bucket, semakin baik.  Tetapi bahkan fungsi hash yang baik kadang-kadang akan menghasilkan hasil yang sama untuk nilai sumber yang berbeda - ini disebut <em>collision</em> .  Jadi, satu ember dapat menyimpan TIDs yang sesuai dengan kunci yang berbeda, dan oleh karena itu, TIDs yang diperoleh dari indeks perlu diperiksa ulang. <br><a name="habracut"></a><br>  Sebagai contoh: fungsi hash untuk string apa yang bisa kita pikirkan?  Biarkan jumlah ember menjadi 256. Kemudian misalnya nomor ember, kita dapat mengambil kode karakter pertama (dengan asumsi pengkodean karakter bita tunggal).  Apakah ini fungsi hash yang baik?  Jelas, tidak: jika semua string dimulai dengan karakter yang sama, semuanya akan masuk ke dalam satu ember, sehingga keseragaman keluar dari pertanyaan, semua nilai perlu diperiksa ulang, dan hashing tidak akan masuk akal.  Bagaimana jika kita meringkas kode semua karakter modulo 256?  Ini akan jauh lebih baik, tetapi jauh dari ideal.  Jika Anda tertarik dengan internal fungsi hash di PostgreSQL, lihat definisi hash_any () di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hashfunc.c</a> . <br><br><h3>  Struktur indeks </h3><br>  Mari kita kembali ke indeks hash.  Untuk nilai beberapa tipe data (kunci indeks), tugas kami adalah menemukan TID yang cocok dengan cepat. <br><br>  Saat memasukkan ke dalam indeks, mari kita hitung fungsi hash untuk kunci tersebut.  Fungsi hash dalam PostgreSQL selalu mengembalikan tipe "integer", yang berada dalam kisaran 2 <sup>32</sup> â‰ˆ 4 miliar nilai.  Jumlah bucket awalnya sama dengan dua dan meningkat secara dinamis untuk menyesuaikan dengan ukuran data.  Nomor bucket dapat dihitung dari kode hash menggunakan bit aritmatika.  Dan ini adalah ember tempat kita akan meletakkan TID kita. <br><br>  Tapi ini tidak cukup karena TIDs yang cocok dengan kunci yang berbeda dapat dimasukkan ke dalam ember yang sama.  Apa yang harus kita lakukan?  Dimungkinkan untuk menyimpan nilai sumber kunci dalam ember, selain TID, tetapi ini akan secara signifikan meningkatkan ukuran indeks.  Untuk menghemat ruang, alih-alih kunci, ember menyimpan kode hash kunci. <br><br>  Saat mencari melalui indeks, kami menghitung fungsi hash untuk kunci dan mendapatkan nomor ember.  Sekarang tinggal memeriksa isi ember dan mengembalikan hanya TUT yang cocok dengan kode hash yang sesuai.  Ini dilakukan secara efisien karena pasangan "hash code - TID" yang disimpan telah dipesan. <br><br>  Namun, dua kunci yang berbeda dapat terjadi tidak hanya untuk masuk ke satu ember, tetapi juga memiliki kode hash empat byte yang sama - tidak ada yang menghilangkan tabrakan.  Oleh karena itu, metode akses meminta mesin pengindeksan umum untuk memverifikasi setiap TID dengan memeriksa kembali kondisi di baris tabel (mesin dapat melakukan ini bersama dengan pemeriksaan visibilitas). <br><br><h3>  Memetakan struktur data ke halaman </h3><br>  Jika kita melihat indeks yang dilihat oleh manajer cache buffer alih-alih dari perspektif perencanaan dan eksekusi permintaan, ternyata semua informasi dan semua baris indeks harus dimasukkan ke dalam halaman.  Halaman indeks tersebut disimpan dalam cache buffer dan diusir dari sana dengan cara yang sama persis seperti halaman tabel. <br><br><img src="https://habrastorage.org/web/aa7/83b/c8c/aa783bc8cbfc4be49baec029339eb539.png"><br><br>  Indeks hash, seperti yang ditunjukkan pada gambar, menggunakan empat jenis halaman (persegi panjang abu-abu): <br><br><ul><li>  Halaman meta - nomor halaman nol, yang berisi informasi tentang apa yang ada di dalam indeks. </li><li>  Halaman bucket - halaman utama indeks, yang menyimpan data sebagai pasangan "kode hash - TID". </li><li>  Halaman meluap - terstruktur dengan cara yang sama dengan halaman ember dan digunakan saat satu halaman tidak cukup untuk satu ember. </li><li>  Halaman Bitmap - yang melacak halaman overflow yang saat ini jelas dan dapat digunakan kembali untuk bucket lain. </li></ul><br>  Panah bawah mulai dari elemen halaman indeks mewakili TIDs, yaitu, referensi ke baris tabel. <br><br>  Setiap kali indeks meningkat, PostgreSQL secara instan membuat dua kali lebih banyak bucket (dan karenanya, halaman) seperti yang terakhir dibuat.  Untuk menghindari alokasi jumlah halaman yang berpotensi besar ini sekaligus, versi 10 membuat ukurannya bertambah lebih lancar.  Adapun halaman overflow, mereka dialokasikan tepat ketika kebutuhan muncul dan dilacak dalam halaman bitmap, yang juga dialokasikan ketika kebutuhan muncul. <br><br>  Perhatikan bahwa indeks hash tidak dapat mengurangi ukurannya.  Jika kami menghapus beberapa baris yang diindeks, halaman yang dialokasikan tidak akan dikembalikan ke sistem operasi, tetapi hanya akan digunakan kembali untuk data baru setelah VACUUMING.  Satu-satunya pilihan untuk mengurangi ukuran indeks adalah membangunnya kembali dari awal menggunakan perintah REINDEX atau VACUUM FULL. <br><br><h2>  Contoh </h2><br>  Mari kita lihat bagaimana indeks hash dibuat.  Untuk menghindari menyusun tabel kami sendiri, mulai sekarang kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database demo</a> transportasi udara, dan kali ini kami akan mempertimbangkan tabel penerbangan. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hash(flight_no);</code> </pre> <pre> <code class="plaintext hljs">WARNING: hash indexes are not WAL-logged and their use is discouraged CREATE INDEX</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0001'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (flight_no = 'PG0001'::bpchar) -&gt; Bitmap Index Scan on flights_flight_no_idx Index Cond: (flight_no = 'PG0001'::bpchar) (4 rows)</code> </pre><br>  Apa yang tidak nyaman tentang implementasi indeks hash saat ini adalah bahwa operasi dengan indeks tidak dicatat dalam log tulis-depan (yang diperingatkan PostgreSQL ketika indeks dibuat).  Karena itu, indeks hash tidak dapat dipulihkan setelah kegagalan dan tidak berpartisipasi dalam replikasi.  Selain itu, indeks hash jauh di bawah "B-tree" dalam fleksibilitas, dan efisiensinya juga dipertanyakan.  Jadi sekarang tidak praktis untuk menggunakan indeks tersebut. <br><br>  Namun, ini akan berubah sejak musim gugur ini (2017) setelah PostgreSQL versi 10 dirilis.  Dalam versi ini, indeks hash akhirnya mendapat dukungan untuk log write-ahead;  selain itu alokasi memori dioptimalkan dan pekerjaan bersamaan dibuat lebih efisien. <br><br><blockquote>  Itu benar.  Karena indeks hash PostgreSQL 10 telah mendapat dukungan penuh dan dapat digunakan tanpa batasan.  Peringatan tidak ditampilkan lagi. <br></blockquote><br><h2>  Hantaman semantik </h2><br>  Tetapi mengapa indeks hash bertahan hampir sejak kelahiran PostgreSQL menjadi 9,6 tidak dapat digunakan?  Masalahnya adalah bahwa DBMS menggunakan ekstensif algoritma hashing (khususnya, untuk hash joins dan pengelompokan), dan sistem harus menyadari fungsi hash mana yang berlaku untuk tipe data mana.  Tetapi korespondensi ini tidak statis, dan tidak dapat ditetapkan sekali dan untuk semua karena PostgreSQL mengizinkan tipe data baru untuk ditambahkan dengan cepat.  Dan ini adalah metode akses oleh hash, di mana korespondensi ini disimpan, direpresentasikan sebagai asosiasi fungsi tambahan dengan keluarga operator. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_name, amproc.amproc::<span class="hljs-type"><span class="hljs-type">regproc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_procedure <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amproc amproc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amproc.amprocfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_procedure;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_procedure --------------------+-------------------- abstime_ops | hashint4 aclitem_ops | hash_aclitem array_ops | hash_array bool_ops | hashchar ...</code> </pre><br>  Meskipun fungsi-fungsi ini tidak didokumentasikan, mereka dapat digunakan untuk menghitung kode hash untuk nilai tipe data yang sesuai.  Misalnya, fungsi "hashtext" jika digunakan untuk keluarga operator "text_ops": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'one'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 127722028 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'two'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 345620034 (1 row)</code> </pre><br><h2>  Properti </h2><br>  Mari kita lihat properti indeks hash, di mana metode akses ini memberikan sistem informasi tentang dirinya sendiri.  Kami memberikan pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> .  Sekarang kita tidak akan melampaui hasil: <br><br><pre> <code class="plaintext hljs"> name | pg_indexam_has_property ---------------+------------------------- can_order | f can_unique | f can_multi_col | f can_exclude | t name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | t name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Fungsi hash tidak mempertahankan relasi urutan: jika nilai fungsi hash untuk satu kunci lebih kecil dari untuk kunci lainnya, tidak mungkin untuk membuat kesimpulan bagaimana kunci itu sendiri dipesan.  Oleh karena itu, secara umum indeks hash dapat mendukung satu-satunya operasi "sama dengan": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opf.opfname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_name, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_name, opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_name | opfamily_operator ---------------+---------------------- abstime_ops | =(abstime,abstime) aclitem_ops | =(aclitem,aclitem) array_ops | =(anyarray,anyarray) bool_ops | =(boolean,boolean) ...</code> </pre><br>  Akibatnya, indeks hash tidak dapat mengembalikan data yang dipesan ("can_order", "orderable").  Indeks hash tidak memanipulasi NULL untuk alasan yang sama: operasi "sama dengan" tidak masuk akal untuk NULL ("search_nulls"). <br><br>  Karena indeks hash tidak menyimpan kunci (tetapi hanya kode hash mereka), maka indeks hash tidak dapat digunakan untuk akses hanya indeks ("dapat dikembalikan"). <br><br>  Metode akses ini tidak mendukung indeks multi-kolom ("can_multi_col"). <br><br><h2>  Internal </h2><br>  Dimulai dengan versi 10, dimungkinkan untuk melihat internal indeks hash melalui ekstensi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pageinspect</a> ".  Ini akan terlihat seperti: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Halaman meta (kami mendapatkan jumlah baris dalam indeks dan jumlah bucket maksimum yang digunakan): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- metapage (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ntuples, maxbucket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> ntuples | maxbucket ---------+----------- 33121 | 127 (1 row)</code> </pre><br>  Halaman ember (kami mendapatkan jumlah tupel hidup dan tupel mati, yaitu yang bisa disedot): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> hash_page_type(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> hash_page_type ---------------- bucket (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> live_items, dead_items <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hash_page_stats(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_flight_no_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><pre> <code class="plaintext hljs"> live_items | dead_items ------------+------------ 407 | 0 (1 row)</code> </pre><br>  Dan sebagainya.  Tetapi hampir tidak mungkin untuk mencari tahu arti dari semua bidang yang tersedia tanpa memeriksa kode sumber.  Jika Anda ingin melakukannya, Anda harus mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442776/">https://habr.com/ru/post/id442776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442760/index.html">Artikel tentang bagaimana CommVault membuat cadangan PostgreSQL</a></li>
<li><a href="../id442762/index.html">Trainee Vasya dan kisah-kisahnya tentang idempotency API</a></li>
<li><a href="../id442764/index.html">Manajemen Produk Digest. Apa yang menggairahkan produk dan pemasar pada 2019</a></li>
<li><a href="../id442770/index.html">Ikhtisar pemindai kode batang JavaScript</a></li>
<li><a href="../id442772/index.html">Matematika untuk Ilmuwan Data: Bagian yang Diperlukan</a></li>
<li><a href="../id442778/index.html">Learning Go: Pilihan laporan video</a></li>
<li><a href="../id442780/index.html">Kesalahpahaman paling umum dalam fisika populer</a></li>
<li><a href="../id442782/index.html">VShard - penskalaan horizontal di Tarantool</a></li>
<li><a href="../id442784/index.html">BGP membajak dengan menambahkan AS korban ke AS-SET penyerang</a></li>
<li><a href="../id442786/index.html">7 Tips Berguna untuk Menggunakan Kamar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>