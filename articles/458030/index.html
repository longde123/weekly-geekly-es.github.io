<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéø üíÉüèø üîë JavaScript funcional: cinco formas de encontrar la media aritm√©tica de los elementos de la matriz y el m√©todo .reduce () üòæ üßëüèæ‚Äçü§ù‚Äçüßëüèæ ü§≥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los m√©todos de iteraci√≥n de matriz son similares a "drogas iniciales" (por supuesto, no son drogas; y no estoy diciendo que las drogas sean buenas; so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript funcional: cinco formas de encontrar la media aritm√©tica de los elementos de la matriz y el m√©todo .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los m√©todos de iteraci√≥n de matriz son</a> similares a "drogas iniciales" (por supuesto, no son drogas; y no estoy diciendo que las drogas sean buenas; son solo una figura ret√≥rica).  Debido a ellos, muchos "se sientan" en la programaci√≥n funcional.  La cosa es que son incre√≠blemente convenientes.  Adem√°s, la mayor√≠a de estos m√©todos son muy f√°ciles de entender.  M√©todos como <code>.map()</code> y <code>.filter()</code> aceptan solo un argumento de devoluci√≥n de llamada y le permiten resolver problemas simples.  Pero existe la sensaci√≥n de que el m√©todo <code>.reduce()</code> causa algunas dificultades para muchos.  Comprenderlo es un poco m√°s dif√≠cil. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠</a> sobre por qu√© creo que <code>.reduce()</code> crea muchos problemas.  Esto se debe en parte al hecho de que muchos manuales demuestran el uso de <code>.reduce()</code> solo cuando se manejan n√∫meros.  Por lo tanto, escrib√≠ sobre cu√°ntas tareas que no implican operaciones aritm√©ticas se pueden resolver usando <code>.reduce()</code> .  Pero, ¬øqu√© pasa si absolutamente necesitas trabajar con n√∫meros? <br><br>  Un uso t√≠pico de <code>.reduce()</code> parece un c√°lculo de la media aritm√©tica de los elementos de una matriz.  A primera vista, parece que no hay nada especial en esta tarea.  Pero ella no es tan simple.  El hecho es que antes de calcular el promedio, debe encontrar los siguientes indicadores: <br><br><ol><li>  La cantidad total de valores de elementos de matriz. </li><li>  La longitud de la matriz. </li></ol><br>  Descubrir todo esto es bastante simple.  Y los promedios inform√°ticos para matrices num√©ricas tampoco es una operaci√≥n f√°cil.  Aqu√≠ hay un ejemplo elemental: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Como puede ver, no hay incomprensiones especiales aqu√≠.  Pero la tarea se vuelve m√°s dif√≠cil si tiene que trabajar con estructuras de datos m√°s complejas.  ¬øQu√© pasa si tenemos una matriz de objetos?  ¬øQu√© pasa si algunos objetos de esta matriz necesitan ser filtrados?  ¬øQu√© hacer si necesita extraer ciertos valores num√©ricos de los objetos?  En esta situaci√≥n, calcular el valor promedio de los elementos de la matriz ya es una tarea un poco m√°s complicada. <br><br>  Para lidiar con esto, resolveremos el problema de capacitaci√≥n (se basa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> tarea con FreeCodeCamp).  Lo resolveremos de cinco maneras diferentes.  Cada uno de ellos tiene sus propias ventajas y desventajas.  Un an√°lisis de estos cinco enfoques para resolver este problema mostrar√° cu√°n flexible puede ser JavaScript.  Y espero que el an√°lisis de las soluciones le permita reflexionar sobre c√≥mo usar <code>.reduce()</code> en proyectos reales. <br><br><h2>  <font color="#3AC1EF">Descripci√≥n general de la tarea</font> </h2><br>  Supongamos que tenemos una serie de objetos que describen expresiones de argot victorianas.  Debe filtrar aquellas expresiones que no se encuentran en Google Books (la propiedad <code>found</code> de los objetos correspondientes es <code>false</code> ) y encontrar una calificaci√≥n promedio para la popularidad de las expresiones.  As√≠ es como se ver√≠an dichos datos (tomados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu√≠</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Considere 5 formas de encontrar el valor promedio de evaluar la popularidad de las expresiones de esta matriz. <br><br><h2>  <font color="#3AC1EF">1. Resolver un problema sin usar .reduce () (bucle imperativo)</font> </h2><br>  En nuestro primer enfoque para resolver el problema, no se usar√° el m√©todo <code>.reduce()</code> .  Si no ha encontrado m√©todos para iterar matrices antes, entonces espero que analizar este ejemplo le aclare un poco la situaci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Si est√° familiarizado con JavaScript, comprender√° f√°cilmente este ejemplo.  De hecho, aqu√≠ sucede lo siguiente: <br><br><ol><li>  Inicializamos las variables <code>popularitySum</code> y <code>itemsFound</code> .  La primera variable, <code>popularitySum</code> , almacena la calificaci√≥n general de popularidad de las expresiones.  Y la segunda variable, <code>itemsFound</code> , (eso es una sorpresa) almacena el n√∫mero de expresiones encontradas. </li><li>  Luego, inicializamos la constante <code>len</code> y el <code>item</code> variable, que nos son √∫tiles al atravesar la matriz. </li><li>  En un bucle <code>for</code> , el contador <code>i</code> incrementa hasta que su valor alcanza el valor de √≠ndice del √∫ltimo elemento de la matriz. </li><li>  Dentro del bucle, tomamos el elemento de la matriz que queremos explorar.  Accedemos al elemento utilizando la construcci√≥n <code>victorianSlang[i]</code> . </li><li>  Luego descubrimos si esta expresi√≥n se encuentra en la colecci√≥n de libros. </li><li>  Si se produce una expresi√≥n en los libros, tomamos el valor de su calificaci√≥n de popularidad y lo agregamos al valor de la <code>popularitySum</code> variable. </li><li>  Al mismo tiempo, tambi√©n aumentamos el contador de las expresiones encontradas: <code>itemsFound</code> . </li><li>  Y, por √∫ltimo, encontramos el promedio dividiendo la <code>popularitySum</code> <code>itemsFound</code> por elementos <code>itemsFound</code> . </li></ol><br>  Entonces, hicimos frente a la tarea.  Quiz√°s nuestra decisi√≥n no fue particularmente hermosa, pero hace su trabajo.  El uso de m√©todos para iterar a trav√©s de matrices lo har√° un poco m√°s limpio.  Echemos un vistazo a si tenemos √©xito, y la verdad es, "limpiar" esta decisi√≥n. <br><br><h2>  <font color="#3AC1EF">2. Soluci√≥n simple # 1: .filter (), .map () y encontrar la cantidad usando .reduce ()</font> </h2><br>  Antes del primer intento de usar los m√©todos de matrices para resolver el problema, lo dividimos en partes peque√±as.  A saber, esto es lo que debemos hacer: <br><br><ol><li>  Seleccione objetos que representen expresiones que est√°n en la colecci√≥n de Google Books.  Aqu√≠ puede usar el m√©todo <code>.filter()</code> . </li><li>  Extraer de los objetos la evaluaci√≥n de la popularidad de las expresiones.  Para resolver esta subtarea, el m√©todo <code>.map()</code> es adecuado. </li><li>  Calcule la suma de las calificaciones.  Aqu√≠ podemos recurrir a la ayuda de nuestro viejo amigo <code>.reduce()</code> . </li><li>  Y finalmente, encuentre el valor promedio de las estimaciones. </li></ol><br>  As√≠ es como se ve en el c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Observe la funci√≥n <code>addScore</code> y la l√≠nea donde <code>.reduce()</code> llama <code>.reduce()</code> .  Tenga en cuenta que <code>addScore</code> acepta dos par√°metros.  El primero, <code>runningTotal</code> , se conoce como bater√≠a.  Almacena la suma de los valores.  Su valor cambia cada vez que iteramos sobre la matriz y ejecutamos la <code>return</code> .  El segundo par√°metro, la <code>popularity</code> , es un elemento separado de la matriz que estamos procesando.  Al principio de <code>addScore</code> sobre la matriz, la <code>return</code> <code>addScore</code> en <code>addScore</code> nunca se ha ejecutado.  Esto significa que <code>runningTotal</code> no se ha configurado autom√°ticamente.  Por lo tanto, al llamar a <code>.reduce()</code> , pasamos a este m√©todo el valor que debe escribirse en <code>runningTotal</code> desde el principio.  Este es el segundo par√°metro pasado a <code>.reduce()</code> . <br><br>  Entonces, aplicamos los m√©todos de iterar matrices para resolver el problema.  La nueva versi√≥n de la soluci√≥n result√≥ ser mucho m√°s limpia que la anterior.  En otras palabras, la decisi√≥n result√≥ ser m√°s declarativa.  No le decimos a JavaScript exactamente c√≥mo ejecutar el bucle; no seguimos los √≠ndices de los elementos de las matrices.  En cambio, declaramos funciones auxiliares simples de peque√±o tama√±o y las combinamos.  Todo el trabajo duro se hace por nosotros mediante los m√©todos de matriz <code>.filter()</code> , <code>.map()</code> y <code>.reduce()</code> .  Este enfoque para resolver tales problemas es m√°s expresivo.  Estos m√©todos de matriz son mucho m√°s completos de lo que puede hacer el ciclo, nos informan sobre la intenci√≥n establecida en el c√≥digo. <br><br><h2>  <font color="#3AC1EF">3. Soluci√≥n f√°cil # 2: uso de m√∫ltiples bater√≠as</font> </h2><br>  En la versi√≥n anterior de la soluci√≥n, creamos un mont√≥n de variables intermedias.  Por ejemplo, <code>foundSlangTerms</code> y <code>popularityScores</code> .  En nuestro caso, tal soluci√≥n es bastante aceptable.  Pero, ¬øqu√© pasa si nos fijamos un objetivo m√°s complejo con respecto al dise√±o del c√≥digo?  Ser√≠a bueno si pudi√©ramos usar el patr√≥n de dise√±o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz fluido</a> en el programa.  Con este enfoque, podr√≠amos encadenar las llamadas de todas las funciones y ser capaces de prescindir de variables intermedias.  Sin embargo, un problema nos espera aqu√≠.  Tenga en cuenta que necesitamos obtener el valor de <code>popularityScores.length</code> .  Si vamos a encadenar todo, entonces necesitamos otra forma de encontrar el n√∫mero de elementos en la matriz.  El n√∫mero de elementos en la matriz juega el papel de un divisor en el c√°lculo del valor promedio.  Veamos si podemos cambiar el enfoque para resolver el problema para que todo se pueda hacer combinando llamadas a m√©todos en una cadena.  Haremos esto mediante el seguimiento de dos valores al iterar sobre los elementos de la matriz, es decir, utilizando la "bater√≠a doble". <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Aqu√≠, para trabajar con dos valores, utilizamos el objeto en la funci√≥n reductora.  Cada pasada a trav√©s de la matriz realizada con <code>addScrores</code> , actualizamos el valor total de la clasificaci√≥n de popularidad y el n√∫mero de elementos.  Es importante tener en cuenta que estos dos valores est√°n representados como un solo objeto.  Con este enfoque, podemos "enga√±ar" al sistema y almacenar dos entidades dentro del mismo valor de retorno. <br><br>  La funci√≥n <code>addScrores</code> ser un poco m√°s complicada que la funci√≥n con el mismo nombre en el ejemplo anterior.  Pero ahora resulta que podemos usar una sola cadena de llamadas a m√©todos para realizar todas las operaciones con la matriz.  Como resultado del procesamiento de la matriz, obtenemos un objeto de <code>popularityInfo</code> que almacena todo lo que necesita para encontrar el promedio.  Esto hace que la cadena de llamadas sea ordenada y simple. <br><br>  Si siente el deseo de mejorar este c√≥digo, puede experimentar con √©l.  Por ejemplo, puede rehacerlo para deshacerse de muchas variables intermedias.  Incluso puede intentar poner este c√≥digo en una l√≠nea. <br><br><h2>  <font color="#3AC1EF">4. Composici√≥n de funciones sin usar notaci√≥n de puntos</font> </h2><br>  Si es nuevo en la programaci√≥n funcional, o si le parece que la programaci√≥n funcional es demasiado complicada, puede omitir esta secci√≥n.  Analizarlo te beneficiar√° si ya est√°s familiarizado con <code>curry()</code> y <code>compose()</code> .  Si desea profundizar en este tema, eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material sobre programaci√≥n funcional en JavaScript y, en particular, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercera</a> parte de la serie en la que est√° incluido. <br><br>  Somos programadores que adoptamos un enfoque funcional.  Esto significa que nos esforzamos por construir funciones complejas a partir de otras funciones, peque√±as y simples.  Hasta ahora, en el curso de considerar varias opciones para resolver el problema, hemos reducido el n√∫mero de variables intermedias.  Como resultado, el c√≥digo de la soluci√≥n se volvi√≥ m√°s simple y f√°cil.  Pero, ¬øqu√© pasa si esta idea se lleva al extremo?  ¬øQu√© pasa si intenta deshacerse de todas las variables intermedias?  ¬øE incluso tratar de escapar de algunos par√°metros? <br><br>  Puede crear una funci√≥n para calcular el promedio usando solo la funci√≥n <code>compose()</code> , sin usar variables.  Llamamos a esto "programaci√≥n sin el uso de notaci√≥n de grano fino" o "programaci√≥n impl√≠cita".  Para escribir tales programas, necesitar√° muchas funciones auxiliares. <br><br>  A veces, tal c√≥digo sorprende a la gente.  Esto se debe al hecho de que este enfoque es muy diferente del generalmente aceptado.  Pero descubr√≠ que escribir c√≥digo al estilo de la programaci√≥n impl√≠cita es una de las formas m√°s r√°pidas de comprender la esencia de la programaci√≥n funcional.  Por lo tanto, puedo aconsejarle que pruebe esta t√©cnica en alg√∫n proyecto personal.  Pero quiero decir que quiz√°s no deber√≠a escribir en el estilo de programaci√≥n impl√≠cita el c√≥digo que otras personas tienen que leer. <br><br>  Entonces, volvamos a nuestra tarea de construir un sistema para calcular promedios.  En aras de ahorrar espacio, pasaremos aqu√≠ al uso de las funciones de flecha.  Por lo general, como regla, es mejor usar funciones con nombre.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay un</a> buen art√≠culo sobre este tema.  Esto le permite obtener mejores resultados de seguimiento de pila en caso de errores. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Si todo este c√≥digo te parece una tonter√≠a completa, no te preocupes por eso.  Lo inclu√≠ aqu√≠ como un ejercicio intelectual, y no para molestarte. <br><br>  En este caso, el trabajo principal est√° en la funci√≥n <code>compose()</code> .  Si lee su contenido de abajo hacia arriba, resulta que los c√°lculos comienzan filtrando la matriz por la propiedad de sus elementos <code>found</code> .  Luego recuperamos la propiedad del elemento de <code>popularity</code> usando <code>map()</code> .  Despu√©s de eso usamos el llamado " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">combinador de mirlo</a> ".  Esta entidad se representa como una funci√≥n <code>B1</code> , que se utiliza para realizar dos pases de c√°lculos en un conjunto de datos de entrada.  Para comprender mejor esto, eche un vistazo a estos ejemplos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Nuevamente, si no comprende nada otra vez, no se preocupe.  Esto es solo una demostraci√≥n de que JavaScript se puede escribir de maneras muy diferentes.  De estas caracter√≠sticas, esta es la belleza de este lenguaje. <br><br><h2>  <font color="#3AC1EF">5. Resolver el problema de una sola vez con el c√°lculo del valor promedio acumulado</font> </h2><br>  Todas las construcciones de software anteriores hacen un buen trabajo para resolver nuestro problema (incluido el ciclo imperativo).  Aquellos que usan el m√©todo <code>.reduce()</code> tienen algo en com√∫n.  Se basan en dividir el problema en peque√±os fragmentos.  Estos fragmentos se ensamblan de varias maneras.  Al analizar estas soluciones, puede notar que en ellas damos la vuelta a la matriz tres veces.  Existe la sensaci√≥n de que es ineficaz.  Ser√≠a bueno si hubiera una manera de procesar la matriz y devolver el resultado en una sola pasada.  Este m√©todo existe, pero su aplicaci√≥n requerir√° recurrir a las matem√°ticas. <br><br>  Para calcular el valor promedio de los elementos de la matriz en una sola pasada, necesitamos un nuevo m√©todo.  Necesita encontrar una manera de calcular el promedio utilizando el promedio calculado previamente y el nuevo valor.  Buscamos este m√©todo usando √°lgebra. <br><br>  El valor promedio de <code>n</code> n√∫meros se puede encontrar usando esta f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Para encontrar los n√∫meros promedio <code>n + 1</code> , la misma f√≥rmula funcionar√°, pero en una entrada diferente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Esta f√≥rmula es la misma que esta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  Y lo mismo que esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Si convierte esto un poco, obtendr√° lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Si no ve el punto en todo esto, entonces est√° bien.  El resultado de todas estas transformaciones es que con la ayuda de la √∫ltima f√≥rmula podemos calcular el valor promedio durante un solo recorrido de la matriz.  Para hacer esto, debe conocer el valor del elemento actual, el valor promedio calculado en el paso anterior y el n√∫mero de elementos.  Adem√°s, la mayor√≠a de los c√°lculos se pueden realizar en la funci√≥n reductora: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Gracias a este enfoque, el valor necesario se puede encontrar sin pasar por la matriz solo una vez.  Otros enfoques usan una pasada para filtrar la matriz, otra para extraer los datos necesarios de ella y otra para encontrar la suma de los valores de los elementos.  Aqu√≠, todo encaja en un solo paso a trav√©s de la matriz. <br><br>  Tenga en cuenta que esto no necesariamente hace que los c√°lculos sean m√°s eficientes.  Con este enfoque, se deben hacer m√°s c√°lculos.  Cuando llega cada nuevo valor, realizamos las operaciones de multiplicaci√≥n y divisi√≥n, haciendo esto para mantener el valor promedio actual en el estado actual.  En otras soluciones a este problema, dividimos un n√∫mero en otro solo una vez, al final del programa.  Pero este enfoque es mucho m√°s eficiente en t√©rminos de uso de memoria.  Aqu√≠ no se utilizan matrices intermedias, como resultado tenemos que almacenar en la memoria solo un objeto con dos valores. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  ‚Äî   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   ‚Äî  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    ‚Äî  .      -  ‚Äî     ,          : <br><br><ol><li>    ,     .      ‚Äî   . </li><li>    ,    ,    ‚Äî     . </li><li> , ,        ‚Äî   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458030/">https://habr.com/ru/post/458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458014/index.html">Robot FEDOR: entrenamiento con el nuevo equipo de ISS y las primeras tareas espaciales</a></li>
<li><a href="../458018/index.html">compositor vs npm: desarrollo de m√≥dulos m√∫ltiples</a></li>
<li><a href="../458020/index.html">Resumen de eventos de TI de julio</a></li>
<li><a href="../458022/index.html">¬øHuellas digitales a trav√©s de anuncios publicitarios? Ahora esto es com√∫n</a></li>
<li><a href="../458026/index.html">Comparaci√≥n de formatos de serializaci√≥n</a></li>
<li><a href="../458040/index.html">De Mosc√∫ a Tomsk. La historia de un movimiento.</a></li>
<li><a href="../458042/index.html">C√≥mo organic√© el entrenamiento de aprendizaje autom√°tico en NSU</a></li>
<li><a href="../458044/index.html">Seguridad de la informaci√≥n provincial: ¬øestancamiento o desarrollo?</a></li>
<li><a href="../458046/index.html">Hoja de trucos de Gradle</a></li>
<li><a href="../458048/index.html">Delegaci√≥n como herramienta de gesti√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>