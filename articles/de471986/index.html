<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüíº üïµÔ∏è üíî Linke rekursive PEG-Grammatik ü•å ‚úäüèø üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe die linke Rekursion mehrmals als Stolperstein erw√§hnt, und es ist Zeit, es herauszufinden. Das Hauptproblem besteht darin, dass ein Parser mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linke rekursive PEG-Grammatik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p>  Ich habe die linke Rekursion mehrmals als Stolperstein erw√§hnt, und es ist Zeit, es herauszufinden.  Das Hauptproblem besteht darin, dass ein Parser mit einem linksrekursiven Abstieg sofort aufgrund eines Stapel√ºberlaufs abst√ºrzt. </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik f√ºr PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p>  Betrachten Sie diese hypothetische Grammatikregel: </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p>  Wenn wir diese Grammatik in die linksrekursive Parser-Methode implementieren w√ºrden, w√ºrden wir ungef√§hr Folgendes erhalten: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Daher beginnt <code>expr()</code> mit einem Aufruf von <code>expr()</code> , der mit einem Aufruf von <code>expr()</code> beginnt, der mit einem Aufruf beginnt ... Dies kann nur mit einem Stapel√ºberlauf enden, der als <code>RecursionError</code> Ausnahme ausgedr√ºckt wird. </p><br><p>  Die traditionelle L√∂sung besteht darin, die Grammatik neu zu schreiben.  In den vorherigen Teilen habe ich genau das getan.  Tats√§chlich kann die obige Grammatikregel wie folgt umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p>  Beim Erstellen des Analysebaums w√ºrde sich seine Form jedoch unterscheiden.  Dies k√∂nnte die Situation ruinieren, wenn wir der Grammatik den Operator <code>'-'</code> hinzuf√ºgen (da <code>a - (b - c)</code> nicht mit <code>(a - b) - c</code> identisch ist).  Dies wird normalerweise mit leistungsst√§rkeren PEG-Funktionen wie Gruppierung und Iteration gel√∂st, und wir k√∂nnen die obige Regel wie folgt umschreiben: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p>  Genau so wird die aktuelle Python-Grammatik f√ºr den pgen-Parser geschrieben (der die gleichen Probleme mit linksrekursiven Regeln hat). </p><br><p>  Es gibt jedoch ein kleines Problem: Da Operatoren wie <code>'+'</code> und <code>'-'</code> (in Python) meistens bin√§r sind, m√ºssen wir bei der Analyse von <code>a + b + c</code> das Ergebnis des Parsens durchlaufen (welches im Wesentlichen eine Liste von <code>['a', '+', 'b', '+', 'c']</code> ), um einen linksrekursiven Analysebaum zu erstellen (der ungef√§hr so ‚Äã‚Äãaussehen w√ºrde <code>[['a', '+', 'b'] , '+', 'c']</code> ). </p><br><p>  Die urspr√ºngliche linksrekursive Grammatik weist bereits auf die gew√ºnschte Assoziativit√§t hin, daher w√§re es sch√∂n, einen Parser direkt aus dieser Form zu generieren.  Und wir k√∂nnen!  Ein Leser wies auf einen guten Trick mit mathematischen Beweisen hin, der leicht zu implementieren war.  Jetzt werde ich versuchen zu erkl√§ren. </p><br><p>  Schauen wir uns ein Beispiel f√ºr die Eingabe <code>foo + bar + baz</code> .  Der Analysebaum, den wir daraus erhalten m√∂chten, entspricht <code>(foo + bar) + baz</code> .  Dies erfordert drei <code>expr()</code> Aufrufe der Funktion <code>expr()</code> : einer entspricht dem Operator <code>'+'</code> der obersten Ebene <code>expr()</code> dem zweiten);  eine weitere - an den internen Operator <code>'+'</code> (d. h. den ersten);  und die dritte ist die Wahl der zweiten Alternative (d. h. <code>term</code> ). </p><br><p>  Da ich mit Spezialwerkzeugen keine guten Diagramme zeichnen kann, werde ich dies hier mit ASCII-Grafik zeigen: </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p>  Die Idee ist, dass wir in der Funktion <code>expr()</code> ein ‚ÄûOrakel‚Äú ben√∂tigen, das uns sagt, ob wir die erste Alternative ( <code>expr()</code> den rekursiven Aufruf von <code>expr()</code> ) oder die zweite ( <code>expr()</code> den Aufruf von <code>expr()</code> ) w√§hlen sollen.  Beim ersten Aufruf von <code>expr()</code> Orakel uns <code>expr()</code> , der ersten Alternative zu folgen ( <code>expr()</code> );  im zweiten (rekursiven) Aufruf - √§hnlich, aber im dritten sollte es uns auffordern, <code>term()</code> aufzurufen.  Im Code sieht es folgenderma√üen aus: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Wie schreibe ich so ein Orakel?  Mal sehen ... Wir k√∂nnten versuchen, die Anzahl der ( <code>expr()</code> ) <code>expr()</code> -Aufrufe im Aufrufstapel zu verfolgen und sie mit der Anzahl der <code>'+'</code> Operatoren im folgenden Ausdruck zu vergleichen.  Wenn der Aufrufstapel tiefer als die Anzahl der Anweisungen ist, sollte das Orakel false zur√ºckgeben (zwingen Sie uns, <code>term()</code> auszuw√§hlen).  Ich kann es kaum erwarten, dies mit <code>sys._getframe()</code> zu implementieren, aber es gibt einen besseren Weg: Lassen Sie uns den Aufrufstapel umdrehen! </p><br><p>  Die Idee ist, dass wir mit einem Aufruf beginnen, bei dem das Orakel false zur√ºckgibt, und das Ergebnis speichern.  Dies gibt uns die Sequenz <code>expr() -&gt; term() -&gt; 'foo'</code> .  (Es sollte einen Analysebaum f√ºr den Anfangsbegriff zur√ºckgeben, <code>'foo'</code> . Der obige Code gibt nur <code>True</code> , aber im zweiten Teil der Artikelserie habe ich bereits gezeigt, wie der Analysebaum stattdessen zur√ºckgegeben wird.) Ein solches Orakel ist einfach zu implementieren, da es sollte <code>False</code> beim ersten Aufruf einfach <code>False</code> - es ist keine Stapelpr√ºfung oder ein Blick in die Zukunft erforderlich. </p><br><p>  Dann rufen wir erneut <code>expr()</code> auf, und dieses Mal gibt das Orakel <code>True</code> , aber anstelle des linken rekursiven Aufrufs von <code>expr()</code> ersetzen wir das gespeicherte Ergebnis aus dem vorherigen Aufruf.  Und da der erwartete Operator <code>'+'</code> und das n√§chste geeignete Token ebenfalls vorhanden sind, erhalten wir einen Analysebaum f√ºr <code>foo + bar</code> . </p><br><p>  Wieder wiederholen wir den Algorithmus und wieder stellt sich alles heraus: Dieses Mal erhalten wir einen Analysebaum f√ºr den vollst√§ndigen Ausdruck, und er ist wirklich linksrekursiv ( <code>(foo + bar) + baz</code> ). </p><br><p>  Dann wiederholen wir den Algorithmus erneut.  Obwohl Oracle dieses Mal <code>True</code> zur√ºckgibt und das gespeicherte Ergebnis des vorherigen Aufrufs ebenfalls verf√ºgbar ist, gibt es keinen Operator <code>'+'</code> mehr, und die erste Alternative schl√§gt fehl.  Daher versuchen wir die zweite Option, die erfolgreich ist, und finden nur den Anfangsbegriff ( <code>'foo'</code> ).  Dieses Ergebnis ist schlechter als das aus der ersten Alternative erhaltene, daher stoppen wir in diesem Stadium und speichern die l√§ngste Analyse (d. H. <code>(foo + bar) + baz</code> ). </p><br><p>  Um dies in <code>expr()</code> , habe ich zuerst den Algorithmus ein wenig modifiziert, um den Aufruf von <code>oracle()</code> mit dem <code>expr()</code> Aufruf von <code>expr()</code> zu <code>expr()</code> .  Nennen wir es <code>oracle_expr()</code> .  Code: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Als n√§chstes schreiben wir einen Wrapper, der die oben beschriebene Logik implementiert.  Es wird eine globale Variable verwendet (keine Sorge, ich werde sie sp√§ter entfernen).  Die Funktion <code>oracle_expr()</code> liest die globale Variable und der Wrapper steuert sie: </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p>  Der Code ist nat√ºrlich schrecklich, aber zumindest vermittelt er die Essenz des Algorithmus.  Lassen Sie es uns umgestalten, damit wir stolz darauf sein k√∂nnen. </p><br><p>  Das wichtigste Verst√§ndnis (das mir geh√∂rt, obwohl ich wahrscheinlich nicht der erste bin, der dies bemerkt) ist, dass wir den Memoization-Cache anstelle einer globalen Variablen verwenden k√∂nnen.  Darin speichern wir das Ergebnis von Anruf zu Anruf.  Also werden wir eine separate Funktion <code>oracle_expr()</code> los, weil  Wir k√∂nnen einen Standardaufruf f√ºr <code>expr()</code> generieren, unabh√§ngig davon, ob er sich links oder rechts in einer rekursiven Position befindet. </p><br><p>  Wir ben√∂tigen also einen separaten <code>@memoize_left_rec</code> Dekorator, der nur f√ºr <code>@memoize_left_rec</code> Regeln verwendet wird.  Es ruft die Funktion <code>oracle_expr()</code> , zieht den gespeicherten Wert aus dem Memoization-Cache und enth√§lt eine Schleife, die die Funktion <code>expr()</code> mehrmals <code>expr()</code> , bis jedes neue Ergebnis mit einem immer l√§ngeren Teil der Eingabedaten als dem vorherigen vergleichbar ist.  Und da jede Eingabeposition und jede Analysemethode separat zwischengespeichert wird, geht es nat√ºrlich nicht um das Zur√ºckverfolgen oder einige rekursive Regeln (in der von mir verwendeten Spielzeuggrammatik <code>expr</code> sowohl <code>expr</code> als auch <code>term</code> rekursiv). </p><br><p>  Ein weiterer Vorteil des Prototyps, den ich im dritten Teil erstellt habe, besteht darin, dass leicht √ºberpr√ºft werden kann, ob das neue Ergebnis l√§nger als das alte ist: Die Methode <code>mark()</code> gibt den Index im Array der Eingabetoken zur√ºck, sodass wir ihn einfach anstelle von <code>parsed_length</code> . </p><br><p>  Ich lasse den Beweis weg, warum dieser Algorithmus immer funktioniert, egal wie verr√ºckt die Grammatik ist.  Tats√§chlich habe ich es nicht einmal gelesen.  Ich sehe, dass dies f√ºr einfache F√§lle wie <code>expr</code> in meiner Spielzeuggrammatik sowie f√ºr etwas komplexere F√§lle <code>expr</code> (z. B. die Verwendung einer linken Rekursion, die alternativ hinter optionalen Elementen verborgen ist, oder die gegenseitige Rekursion zwischen mehreren Regeln).  Die schwierigste Situation, an die ich mich in der Python-Grammatik erinnern kann, wird immer noch durch diesen Algorithmus gel√∂st, daher vertraue ich nur dem Satz und den Leuten, die ihn bewiesen haben. </p><br><p>  Schreiben wir den Kampfcode. </p><br><p>  Zun√§chst muss der Parsergenerator bestimmen, welche Regeln rekursiv bleiben.  Dies ist ein gel√∂stes Problem in der Graphentheorie.  Ich werde den Algorithmus hier nicht zeigen, und tats√§chlich m√∂chte ich ihn noch weiter vereinfachen.  Ich <code>expr</code> davon aus, dass die einzigen <code>expr</code> Regeln in der Grammatik direkt <code>expr</code> sind, wie in unserer Spielzeuggrammatik.  Um die Rekursivit√§t der linken Seite zu √ºberpr√ºfen, m√ºssen Sie nur nach einer Alternative suchen, die mit dem Namen der aktuellen Regel beginnt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Jetzt werden wir den Parser-Generator so √§ndern, dass er f√ºr linksrekursive Regeln einen anderen Dekorator generiert.  Denken Sie daran, dass wir im dritten Teil alle Parser-Methoden in <code>@memoize</code> .  Jetzt nehmen wir eine kleine √Ñnderung im Generator vor, sodass wir f√ºr <code>@memoize_left_rec</code> Regeln <code>@memoize_left_rec</code> , und implementieren dann Magie im <code>memoize_left_rec</code> Dekorator.  Der Rest des Generators und anderer Code m√ºssen nicht ge√§ndert werden!  (Obwohl ich mit dem Visualisierungscode basteln musste) </p><br><p>  Als Referenz ist hier noch einmal der urspr√ºngliche <code>@memoize</code> Dekorator, der aus Teil 3 kopiert wurde. Denken Sie daran, dass <code>self</code> eine <code>Parser</code> Instanz ist, die √ºber ein <code>memo</code> Attribut (initialisiert mit einem leeren W√∂rterbuch) und <code>mark()</code> und <code>reset()</code> -Methoden verf√ºgt, mit denen die aktuelle Position abgerufen und festgelegt wird Tokenizer: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Der <code>@memoize</code> Dekorateur merkt sich fr√ºhere Aufrufe f√ºr jede Position im Eingabestream - f√ºr jede Position im (faulen) Array von Eingabetoken gibt es ein separates <code>memo</code> W√∂rterbuch.  Die ersten vier Zeilen von <code>memoize_wrapper</code> dazu, das richtige <code>memo</code> W√∂rterbuch zu erhalten. </p><br><p>  Und hier ist <code>@memoize_left_rec</code> .  Nur der <code>else</code> Zweig unterscheidet sich geringf√ºgig von der Implementierung in <code>@memoize</code> oben: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p>  Es ist wahrscheinlich interessant, wie dies f√ºr die <code>expr()</code> -Methode funktioniert.  Mal sehen, wie der folgende Code ausgef√ºhrt wird: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p>  Am Beispiel des Parsens von <code>foo + bar + baz</code> . </p><br><p>  Immer wenn Sie die Funktion <code>expr()</code> aufrufen, wird der Aufruf vom Dekorateur "verkn√ºpft", der an der aktuellen Position nach dem vorherigen Aufruf sucht.  Beim ersten Aufruf gelangen wir zum Zweig <code>else</code> , wo wir wiederholt die dekorierte Funktion <code>expr()</code> .  Nat√ºrlich werden wir zuerst wieder zum Dekorateur gelangen, aber dieses Mal befindet sich bereits ein Wert im Cache, sodass die Rekursion unterbrochen wird. </p><br><p>  Was passiert als n√§chstes?  Der anf√§ngliche Cache-Wert wird in dieser Zeile berechnet: </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p>  Dies f√ºhrt dazu, dass dekoriertes <code>expr()</code> <code>None</code> zur√ºckgibt, wonach das erste <code>if</code> in <code>expr()</code> f√§llt (wenn <code>expr: = self.expr()</code> ).  Das hei√üt, wir fahren mit dem zweiten <code>if</code> , das den <code>term</code> erfolgreich erkennt (in unserem Beispiel <code>'foo'</code> ) und <code>expr</code> eine Instanz von <code>Node</code> zur√ºckgibt.  Woher kommen wir zur√ºck?  Zur <code>while</code> im Dekorateur.  Wir aktualisieren den Memoization Cache mit einem neuen Ergebnis (dieser Instanz von <code>Node</code> ) und f√ºhren dann die n√§chste Iteration aus. </p><br><p>  <code>expr()</code> wird erneut aufgerufen, und diesmal gibt der abgefangene rekursive Aufruf die zwischengespeicherte Instanz von <code>Node</code> (term) zur√ºck und f√§hrt dann mit dem zu <code>expect('+')</code> Aufruf fort <code>expect('+')</code> .  Alles ist in Ordnung, da wir jetzt auf dem ersten <code>'+'</code> Operator sind.  Danach suchen wir nach einem Begriff, der auch erfolgreich ist (gefunden <code>'bar'</code> ). </p><br><p>  Jetzt <code>expr()</code> , nachdem es <code>foo + bar</code> bereits erkannt hat, zur <code>while</code> , die dieselben Aktionen ausf√ºhrt: Es aktualisiert den Memoization-Cache mit einem neuen (l√§ngeren) Ergebnis und startet die n√§chste Iteration. </p><br><p>  Dieses Spiel wird erneut wiederholt.  Wiederum ruft der abgefangene rekursive Aufruf <code>expr()</code> ein neues Ergebnis (diesmal <code>foo + bar</code> ) aus dem Cache ab, und wir erwarten ein weiteres <code>'+'</code> (zweites) und einen weiteren <code>term</code> ( <code>'baz'</code> ).  Wir erstellen einen <code>Node</code> der <code>(foo + bar) + baz</code> , und geben ihn an die <code>while</code> , die ihn in den Cache legt und erneut wiederholt. </p><br><p>  Aber jetzt gehen wir einen anderen Zweig des Algorithmus entlang.  Wir erwarten ein weiteres <code>'+'</code> , finden es aber nicht!  Daher kehrt dieser Aufruf von <code>expr()</code> zu seiner zweiten Alternative zur√ºck und gibt nur <code>term</code> .  Wenn dies vor der <code>while</code> angezeigt <code>while</code> , stellt sich heraus, dass dieses Ergebnis k√ºrzer als das letzte ist.  Es unterbricht also und gibt ein l√§ngeres Ergebnis ( <code>(foo + bar) + baz</code> ) an denjenigen zur√ºck, der den Aufruf von <code>expr()</code> initiiert hat (zum Beispiel wird der Aufruf von <code>statement()</code> hier nicht angezeigt). </p><br><p>  Hier endet also die heutige Geschichte: Wir haben die Linksrekursion erfolgreich in einem PEG-Parser implementiert.  N√§chste Woche m√∂chte ich das Hinzuf√ºgen von "Aktionen" zur Grammatik diskutieren, damit wir das von der Parser-Methode zur√ºckgegebene Ergebnis f√ºr diese Alternative anpassen k√∂nnen (anstatt immer eine <code>Node</code> ). </p><br><p>  Wenn Sie mit dem Code herumspielen m√∂chten, √ºberpr√ºfen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das GitHub-Repository</a> .  (Ich habe auch einen Visualisierungscode f√ºr die linke Rekursion hinzugef√ºgt, bin aber nicht ganz zufrieden damit, daher werde ich hier keinen Link dazu bereitstellen.) </p><br><p>  Lizenz f√ºr diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471986/">https://habr.com/ru/post/de471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471974/index.html">Wie zwei Kapit√§ne zu Gener√§len wurden: wei√ü und rot</a></li>
<li><a href="../de471976/index.html">Wie bekommt ein IT-Spezialist einen Job im Ausland?</a></li>
<li><a href="../de471978/index.html">Wir k√∂nnen KI-Systemen nicht vertrauen, die allein auf tiefem Lernen basieren</a></li>
<li><a href="../de471980/index.html">Telefonbetr√ºger. Vierter Akt, Finale ...</a></li>
<li><a href="../de471982/index.html">Die Zukunft von PHP diskutieren</a></li>
<li><a href="../de471988/index.html">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a></li>
<li><a href="../de471990/index.html">Meta-Grammatik f√ºr PEG-Parser</a></li>
<li><a href="../de471992/index.html">Implementierung der verbleibenden Funktionen von PEG</a></li>
<li><a href="../de471994/index.html">Arbeiten Sie an PEG im Core Developer Sprint</a></li>
<li><a href="../de471998/index.html">F # 10: Listen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>