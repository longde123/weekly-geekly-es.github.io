<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍💼 🕵️ 💔 Linke rekursive PEG-Grammatik 🥌 ✊🏿 🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe die linke Rekursion mehrmals als Stolperstein erwähnt, und es ist Zeit, es herauszufinden. Das Hauptproblem besteht darin, dass ein Parser mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linke rekursive PEG-Grammatik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p>  Ich habe die linke Rekursion mehrmals als Stolperstein erwähnt, und es ist Zeit, es herauszufinden.  Das Hauptproblem besteht darin, dass ein Parser mit einem linksrekursiven Abstieg sofort aufgrund eines Stapelüberlaufs abstürzt. </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzufügen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik für PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p>  Betrachten Sie diese hypothetische Grammatikregel: </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p>  Wenn wir diese Grammatik in die linksrekursive Parser-Methode implementieren würden, würden wir ungefähr Folgendes erhalten: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Daher beginnt <code>expr()</code> mit einem Aufruf von <code>expr()</code> , der mit einem Aufruf von <code>expr()</code> beginnt, der mit einem Aufruf beginnt ... Dies kann nur mit einem Stapelüberlauf enden, der als <code>RecursionError</code> Ausnahme ausgedrückt wird. </p><br><p>  Die traditionelle Lösung besteht darin, die Grammatik neu zu schreiben.  In den vorherigen Teilen habe ich genau das getan.  Tatsächlich kann die obige Grammatikregel wie folgt umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p>  Beim Erstellen des Analysebaums würde sich seine Form jedoch unterscheiden.  Dies könnte die Situation ruinieren, wenn wir der Grammatik den Operator <code>'-'</code> hinzufügen (da <code>a - (b - c)</code> nicht mit <code>(a - b) - c</code> identisch ist).  Dies wird normalerweise mit leistungsstärkeren PEG-Funktionen wie Gruppierung und Iteration gelöst, und wir können die obige Regel wie folgt umschreiben: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p>  Genau so wird die aktuelle Python-Grammatik für den pgen-Parser geschrieben (der die gleichen Probleme mit linksrekursiven Regeln hat). </p><br><p>  Es gibt jedoch ein kleines Problem: Da Operatoren wie <code>'+'</code> und <code>'-'</code> (in Python) meistens binär sind, müssen wir bei der Analyse von <code>a + b + c</code> das Ergebnis des Parsens durchlaufen (welches im Wesentlichen eine Liste von <code>['a', '+', 'b', '+', 'c']</code> ), um einen linksrekursiven Analysebaum zu erstellen (der ungefähr so ​​aussehen würde <code>[['a', '+', 'b'] , '+', 'c']</code> ). </p><br><p>  Die ursprüngliche linksrekursive Grammatik weist bereits auf die gewünschte Assoziativität hin, daher wäre es schön, einen Parser direkt aus dieser Form zu generieren.  Und wir können!  Ein Leser wies auf einen guten Trick mit mathematischen Beweisen hin, der leicht zu implementieren war.  Jetzt werde ich versuchen zu erklären. </p><br><p>  Schauen wir uns ein Beispiel für die Eingabe <code>foo + bar + baz</code> .  Der Analysebaum, den wir daraus erhalten möchten, entspricht <code>(foo + bar) + baz</code> .  Dies erfordert drei <code>expr()</code> Aufrufe der Funktion <code>expr()</code> : einer entspricht dem Operator <code>'+'</code> der obersten Ebene <code>expr()</code> dem zweiten);  eine weitere - an den internen Operator <code>'+'</code> (d. h. den ersten);  und die dritte ist die Wahl der zweiten Alternative (d. h. <code>term</code> ). </p><br><p>  Da ich mit Spezialwerkzeugen keine guten Diagramme zeichnen kann, werde ich dies hier mit ASCII-Grafik zeigen: </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p>  Die Idee ist, dass wir in der Funktion <code>expr()</code> ein „Orakel“ benötigen, das uns sagt, ob wir die erste Alternative ( <code>expr()</code> den rekursiven Aufruf von <code>expr()</code> ) oder die zweite ( <code>expr()</code> den Aufruf von <code>expr()</code> ) wählen sollen.  Beim ersten Aufruf von <code>expr()</code> Orakel uns <code>expr()</code> , der ersten Alternative zu folgen ( <code>expr()</code> );  im zweiten (rekursiven) Aufruf - ähnlich, aber im dritten sollte es uns auffordern, <code>term()</code> aufzurufen.  Im Code sieht es folgendermaßen aus: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Wie schreibe ich so ein Orakel?  Mal sehen ... Wir könnten versuchen, die Anzahl der ( <code>expr()</code> ) <code>expr()</code> -Aufrufe im Aufrufstapel zu verfolgen und sie mit der Anzahl der <code>'+'</code> Operatoren im folgenden Ausdruck zu vergleichen.  Wenn der Aufrufstapel tiefer als die Anzahl der Anweisungen ist, sollte das Orakel false zurückgeben (zwingen Sie uns, <code>term()</code> auszuwählen).  Ich kann es kaum erwarten, dies mit <code>sys._getframe()</code> zu implementieren, aber es gibt einen besseren Weg: Lassen Sie uns den Aufrufstapel umdrehen! </p><br><p>  Die Idee ist, dass wir mit einem Aufruf beginnen, bei dem das Orakel false zurückgibt, und das Ergebnis speichern.  Dies gibt uns die Sequenz <code>expr() -&gt; term() -&gt; 'foo'</code> .  (Es sollte einen Analysebaum für den Anfangsbegriff zurückgeben, <code>'foo'</code> . Der obige Code gibt nur <code>True</code> , aber im zweiten Teil der Artikelserie habe ich bereits gezeigt, wie der Analysebaum stattdessen zurückgegeben wird.) Ein solches Orakel ist einfach zu implementieren, da es sollte <code>False</code> beim ersten Aufruf einfach <code>False</code> - es ist keine Stapelprüfung oder ein Blick in die Zukunft erforderlich. </p><br><p>  Dann rufen wir erneut <code>expr()</code> auf, und dieses Mal gibt das Orakel <code>True</code> , aber anstelle des linken rekursiven Aufrufs von <code>expr()</code> ersetzen wir das gespeicherte Ergebnis aus dem vorherigen Aufruf.  Und da der erwartete Operator <code>'+'</code> und das nächste geeignete Token ebenfalls vorhanden sind, erhalten wir einen Analysebaum für <code>foo + bar</code> . </p><br><p>  Wieder wiederholen wir den Algorithmus und wieder stellt sich alles heraus: Dieses Mal erhalten wir einen Analysebaum für den vollständigen Ausdruck, und er ist wirklich linksrekursiv ( <code>(foo + bar) + baz</code> ). </p><br><p>  Dann wiederholen wir den Algorithmus erneut.  Obwohl Oracle dieses Mal <code>True</code> zurückgibt und das gespeicherte Ergebnis des vorherigen Aufrufs ebenfalls verfügbar ist, gibt es keinen Operator <code>'+'</code> mehr, und die erste Alternative schlägt fehl.  Daher versuchen wir die zweite Option, die erfolgreich ist, und finden nur den Anfangsbegriff ( <code>'foo'</code> ).  Dieses Ergebnis ist schlechter als das aus der ersten Alternative erhaltene, daher stoppen wir in diesem Stadium und speichern die längste Analyse (d. H. <code>(foo + bar) + baz</code> ). </p><br><p>  Um dies in <code>expr()</code> , habe ich zuerst den Algorithmus ein wenig modifiziert, um den Aufruf von <code>oracle()</code> mit dem <code>expr()</code> Aufruf von <code>expr()</code> zu <code>expr()</code> .  Nennen wir es <code>oracle_expr()</code> .  Code: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Als nächstes schreiben wir einen Wrapper, der die oben beschriebene Logik implementiert.  Es wird eine globale Variable verwendet (keine Sorge, ich werde sie später entfernen).  Die Funktion <code>oracle_expr()</code> liest die globale Variable und der Wrapper steuert sie: </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p>  Der Code ist natürlich schrecklich, aber zumindest vermittelt er die Essenz des Algorithmus.  Lassen Sie es uns umgestalten, damit wir stolz darauf sein können. </p><br><p>  Das wichtigste Verständnis (das mir gehört, obwohl ich wahrscheinlich nicht der erste bin, der dies bemerkt) ist, dass wir den Memoization-Cache anstelle einer globalen Variablen verwenden können.  Darin speichern wir das Ergebnis von Anruf zu Anruf.  Also werden wir eine separate Funktion <code>oracle_expr()</code> los, weil  Wir können einen Standardaufruf für <code>expr()</code> generieren, unabhängig davon, ob er sich links oder rechts in einer rekursiven Position befindet. </p><br><p>  Wir benötigen also einen separaten <code>@memoize_left_rec</code> Dekorator, der nur für <code>@memoize_left_rec</code> Regeln verwendet wird.  Es ruft die Funktion <code>oracle_expr()</code> , zieht den gespeicherten Wert aus dem Memoization-Cache und enthält eine Schleife, die die Funktion <code>expr()</code> mehrmals <code>expr()</code> , bis jedes neue Ergebnis mit einem immer längeren Teil der Eingabedaten als dem vorherigen vergleichbar ist.  Und da jede Eingabeposition und jede Analysemethode separat zwischengespeichert wird, geht es natürlich nicht um das Zurückverfolgen oder einige rekursive Regeln (in der von mir verwendeten Spielzeuggrammatik <code>expr</code> sowohl <code>expr</code> als auch <code>term</code> rekursiv). </p><br><p>  Ein weiterer Vorteil des Prototyps, den ich im dritten Teil erstellt habe, besteht darin, dass leicht überprüft werden kann, ob das neue Ergebnis länger als das alte ist: Die Methode <code>mark()</code> gibt den Index im Array der Eingabetoken zurück, sodass wir ihn einfach anstelle von <code>parsed_length</code> . </p><br><p>  Ich lasse den Beweis weg, warum dieser Algorithmus immer funktioniert, egal wie verrückt die Grammatik ist.  Tatsächlich habe ich es nicht einmal gelesen.  Ich sehe, dass dies für einfache Fälle wie <code>expr</code> in meiner Spielzeuggrammatik sowie für etwas komplexere Fälle <code>expr</code> (z. B. die Verwendung einer linken Rekursion, die alternativ hinter optionalen Elementen verborgen ist, oder die gegenseitige Rekursion zwischen mehreren Regeln).  Die schwierigste Situation, an die ich mich in der Python-Grammatik erinnern kann, wird immer noch durch diesen Algorithmus gelöst, daher vertraue ich nur dem Satz und den Leuten, die ihn bewiesen haben. </p><br><p>  Schreiben wir den Kampfcode. </p><br><p>  Zunächst muss der Parsergenerator bestimmen, welche Regeln rekursiv bleiben.  Dies ist ein gelöstes Problem in der Graphentheorie.  Ich werde den Algorithmus hier nicht zeigen, und tatsächlich möchte ich ihn noch weiter vereinfachen.  Ich <code>expr</code> davon aus, dass die einzigen <code>expr</code> Regeln in der Grammatik direkt <code>expr</code> sind, wie in unserer Spielzeuggrammatik.  Um die Rekursivität der linken Seite zu überprüfen, müssen Sie nur nach einer Alternative suchen, die mit dem Namen der aktuellen Regel beginnt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Jetzt werden wir den Parser-Generator so ändern, dass er für linksrekursive Regeln einen anderen Dekorator generiert.  Denken Sie daran, dass wir im dritten Teil alle Parser-Methoden in <code>@memoize</code> .  Jetzt nehmen wir eine kleine Änderung im Generator vor, sodass wir für <code>@memoize_left_rec</code> Regeln <code>@memoize_left_rec</code> , und implementieren dann Magie im <code>memoize_left_rec</code> Dekorator.  Der Rest des Generators und anderer Code müssen nicht geändert werden!  (Obwohl ich mit dem Visualisierungscode basteln musste) </p><br><p>  Als Referenz ist hier noch einmal der ursprüngliche <code>@memoize</code> Dekorator, der aus Teil 3 kopiert wurde. Denken Sie daran, dass <code>self</code> eine <code>Parser</code> Instanz ist, die über ein <code>memo</code> Attribut (initialisiert mit einem leeren Wörterbuch) und <code>mark()</code> und <code>reset()</code> -Methoden verfügt, mit denen die aktuelle Position abgerufen und festgelegt wird Tokenizer: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Der <code>@memoize</code> Dekorateur merkt sich frühere Aufrufe für jede Position im Eingabestream - für jede Position im (faulen) Array von Eingabetoken gibt es ein separates <code>memo</code> Wörterbuch.  Die ersten vier Zeilen von <code>memoize_wrapper</code> dazu, das richtige <code>memo</code> Wörterbuch zu erhalten. </p><br><p>  Und hier ist <code>@memoize_left_rec</code> .  Nur der <code>else</code> Zweig unterscheidet sich geringfügig von der Implementierung in <code>@memoize</code> oben: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p>  Es ist wahrscheinlich interessant, wie dies für die <code>expr()</code> -Methode funktioniert.  Mal sehen, wie der folgende Code ausgeführt wird: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p>  Am Beispiel des Parsens von <code>foo + bar + baz</code> . </p><br><p>  Immer wenn Sie die Funktion <code>expr()</code> aufrufen, wird der Aufruf vom Dekorateur "verknüpft", der an der aktuellen Position nach dem vorherigen Aufruf sucht.  Beim ersten Aufruf gelangen wir zum Zweig <code>else</code> , wo wir wiederholt die dekorierte Funktion <code>expr()</code> .  Natürlich werden wir zuerst wieder zum Dekorateur gelangen, aber dieses Mal befindet sich bereits ein Wert im Cache, sodass die Rekursion unterbrochen wird. </p><br><p>  Was passiert als nächstes?  Der anfängliche Cache-Wert wird in dieser Zeile berechnet: </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p>  Dies führt dazu, dass dekoriertes <code>expr()</code> <code>None</code> zurückgibt, wonach das erste <code>if</code> in <code>expr()</code> fällt (wenn <code>expr: = self.expr()</code> ).  Das heißt, wir fahren mit dem zweiten <code>if</code> , das den <code>term</code> erfolgreich erkennt (in unserem Beispiel <code>'foo'</code> ) und <code>expr</code> eine Instanz von <code>Node</code> zurückgibt.  Woher kommen wir zurück?  Zur <code>while</code> im Dekorateur.  Wir aktualisieren den Memoization Cache mit einem neuen Ergebnis (dieser Instanz von <code>Node</code> ) und führen dann die nächste Iteration aus. </p><br><p>  <code>expr()</code> wird erneut aufgerufen, und diesmal gibt der abgefangene rekursive Aufruf die zwischengespeicherte Instanz von <code>Node</code> (term) zurück und fährt dann mit dem zu <code>expect('+')</code> Aufruf fort <code>expect('+')</code> .  Alles ist in Ordnung, da wir jetzt auf dem ersten <code>'+'</code> Operator sind.  Danach suchen wir nach einem Begriff, der auch erfolgreich ist (gefunden <code>'bar'</code> ). </p><br><p>  Jetzt <code>expr()</code> , nachdem es <code>foo + bar</code> bereits erkannt hat, zur <code>while</code> , die dieselben Aktionen ausführt: Es aktualisiert den Memoization-Cache mit einem neuen (längeren) Ergebnis und startet die nächste Iteration. </p><br><p>  Dieses Spiel wird erneut wiederholt.  Wiederum ruft der abgefangene rekursive Aufruf <code>expr()</code> ein neues Ergebnis (diesmal <code>foo + bar</code> ) aus dem Cache ab, und wir erwarten ein weiteres <code>'+'</code> (zweites) und einen weiteren <code>term</code> ( <code>'baz'</code> ).  Wir erstellen einen <code>Node</code> der <code>(foo + bar) + baz</code> , und geben ihn an die <code>while</code> , die ihn in den Cache legt und erneut wiederholt. </p><br><p>  Aber jetzt gehen wir einen anderen Zweig des Algorithmus entlang.  Wir erwarten ein weiteres <code>'+'</code> , finden es aber nicht!  Daher kehrt dieser Aufruf von <code>expr()</code> zu seiner zweiten Alternative zurück und gibt nur <code>term</code> .  Wenn dies vor der <code>while</code> angezeigt <code>while</code> , stellt sich heraus, dass dieses Ergebnis kürzer als das letzte ist.  Es unterbricht also und gibt ein längeres Ergebnis ( <code>(foo + bar) + baz</code> ) an denjenigen zurück, der den Aufruf von <code>expr()</code> initiiert hat (zum Beispiel wird der Aufruf von <code>statement()</code> hier nicht angezeigt). </p><br><p>  Hier endet also die heutige Geschichte: Wir haben die Linksrekursion erfolgreich in einem PEG-Parser implementiert.  Nächste Woche möchte ich das Hinzufügen von "Aktionen" zur Grammatik diskutieren, damit wir das von der Parser-Methode zurückgegebene Ergebnis für diese Alternative anpassen können (anstatt immer eine <code>Node</code> ). </p><br><p>  Wenn Sie mit dem Code herumspielen möchten, überprüfen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das GitHub-Repository</a> .  (Ich habe auch einen Visualisierungscode für die linke Rekursion hinzugefügt, bin aber nicht ganz zufrieden damit, daher werde ich hier keinen Link dazu bereitstellen.) </p><br><p>  Lizenz für diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471986/">https://habr.com/ru/post/de471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471974/index.html">Wie zwei Kapitäne zu Generälen wurden: weiß und rot</a></li>
<li><a href="../de471976/index.html">Wie bekommt ein IT-Spezialist einen Job im Ausland?</a></li>
<li><a href="../de471978/index.html">Wir können KI-Systemen nicht vertrauen, die allein auf tiefem Lernen basieren</a></li>
<li><a href="../de471980/index.html">Telefonbetrüger. Vierter Akt, Finale ...</a></li>
<li><a href="../de471982/index.html">Die Zukunft von PHP diskutieren</a></li>
<li><a href="../de471988/index.html">Hinzufügen von Aktionen zur PEG-Grammatik</a></li>
<li><a href="../de471990/index.html">Meta-Grammatik für PEG-Parser</a></li>
<li><a href="../de471992/index.html">Implementierung der verbleibenden Funktionen von PEG</a></li>
<li><a href="../de471994/index.html">Arbeiten Sie an PEG im Core Developer Sprint</a></li>
<li><a href="../de471998/index.html">F # 10: Listen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>