<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèº üìâ üëáüèΩ OpenSceneGraph: Dasar-dasar Geometri Adegan üç° üî± ‚úèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 OpenGL, yang merupakan backend untuk OpenSceneGraph, menggunakan primitif geometris (seperti titik, garis, segitiga, dan wajah poligonal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Dasar-dasar Geometri Adegan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><br><h1>  Pendahuluan </h1><br>  OpenGL, yang merupakan backend untuk OpenSceneGraph, menggunakan primitif geometris (seperti titik, garis, segitiga, dan wajah poligonal) untuk membangun semua objek di dunia tiga dimensi. <br><br>  Primitif ini ditentukan oleh data tentang simpulnya, yang mencakup koordinat simpul, komponen normal, data warna, dan koordinat tekstur.  Data ini disimpan dalam array khusus.  Primitif dapat dibentuk, misalnya, dengan menentukan objek yang menggambarkan daftar indeks verteks.  Metode ini disebut metode array vertex, menghilangkan penyimpanan simpul redundan dalam memori dan memiliki kinerja yang baik. <br><br>  Selain itu, OpenGL dapat menggunakan mekanisme yang disebut <i>daftar tampilan</i> , ketika primitif yang disiapkan dalam memori video dapat digunakan kembali, yang secara signifikan mempercepat tampilan objek statis. <br><br>  Secara default, OSG menggunakan metode array vertex dan metode daftar tampilan untuk membuat geometri.  Namun, strategi rendering dapat diubah, tergantung pada bagaimana data geometri disajikan.  Pada artikel ini, kita akan membahas teknik dasar untuk bekerja dengan geometri di OSG. <br><a name="habracut"></a><br><h1>  1. Kelas Geode dan Drawable </h1><br>  Kelas osg :: Geode adalah terminal, yang disebut "daun" simpul pohon adegan.  Itu tidak dapat memiliki node anak, tetapi berisi semua informasi yang diperlukan untuk rendering geometri.  Namanya, Geode, adalah kependekan dari simpul geometri. <br><br>  Data geometris yang akan diproses oleh mesin disimpan dalam sekumpulan objek dari kelas osg :: Drawable, dikelola oleh kelas osg :: Geode.  The osg :: Drawable class adalah murni kelas virtual.  Sejumlah subclass diwarisi darinya, yang merupakan model tiga dimensi, gambar dan teks yang diproses oleh pipa OpenGL.  OSG mengacu pada drawable karena semua elemen yang dapat ditarik oleh mesin. <br><br>  Kelas osg :: Geode menyediakan sejumlah metode untuk melampirkan dan melepaskan drawable: <br><br><ul><li>  Metode publik addDrawable () - meneruskan sebuah pointer ke elemen yang dapat digambar dalam instance dari kelas osg :: Geode.  Semua elemen ini dikendalikan oleh osg :: ref_ptr &lt;&gt; smart pointer. <br></li><li>  Metode publik removeDrawable () dan removeDrawables () menghapus objek dari osg :: Geode dan mengurangi jumlah referensi untuk itu.  Metode removeDrawable () mengambil sebagai parameter tunggal penunjuk ke elemen yang diminati, dan metode removeDrawables () mengambil dua parameter: indeks awal dan jumlah elemen yang akan dihapus dari array objek osg :: Geode. <br></li><li>  Metode getDrawable () mengembalikan pointer ke elemen pada indeks yang diteruskan sebagai parameter. <br></li><li>  Metode getNumDrawables () mengembalikan jumlah total elemen yang dilampirkan ke osg :: Geode.  Misalnya, untuk menghapus semua elemen dari osg :: Geode, Anda dapat menggunakan kode tersebut <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Menggambar bentuk sederhana </h1><br>  OSG menyediakan kelas osg :: ShapeDrawable, yang merupakan turunan dari kelas osg :: Drawable dan dirancang untuk membuat primitif tiga dimensi sederhana.  Kelas ini mencakup objek osg :: Shape yang menyimpan informasi tentang geometri tertentu dan parameter lainnya.  Primitif dihasilkan menggunakan metode setShape (), misalnya <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  menciptakan kotak persegi panjang dengan pusat geometris di titik (1,0, 0,0, 0,0) dengan lebar dan tinggi 10 dan kedalaman 5 unit.  Kelas osg :: Vec3 mendefinisikan vektor dalam ruang tiga dimensi (selain itu, kelas osg :: Vec2 dan osg :: Vec4 yang menggambarkan vektor dari dimensi yang sesuai juga disajikan). <br><br>  Primitif paling populer diwakili dalam OSG oleh kelas osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder dan osg :: Sphere. <br><br>  Perhatikan contoh penerapan mekanisme ini. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Contoh ini terutama tidak memerlukan komentar: dalam program tiga bentuk sederhana dibuat, setelah kompilasi dan peluncuran kita akan melihat hasil seperti itu <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  Mekanisme yang ditunjukkan dalam contoh ini sederhana dan mudah, tetapi itu bukan cara paling efektif untuk membuat geometri dan dapat digunakan secara eksklusif untuk pengujian.  Kelas osg :: Geometry digunakan untuk membuat geometri dalam aplikasi berbasis OSG kinerja tinggi. <br><br><h1>  3. Penyimpanan data geometri: kelas osg :: Array dan osg :: Geometri </h1><br>  Kelas osg :: Array adalah kelas abstrak dasar, yang darinya beberapa keturunan diwarisi, dirancang untuk menyimpan data yang diteruskan ke fungsi OpenGL.  Bekerja dengan kelas ini mirip dengan bekerja dengan std :: vector dari pustaka standar C ++.  Kode berikut menggambarkan menambahkan vektor ke array vertex menggunakan metode push_back () <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Array OSG dialokasikan pada heap dan dikelola oleh smart pointer.  Namun, ini tidak berlaku untuk elemen array, seperti osg :: Vec3 atau osg :: Vec2, yang juga dapat dibuat di stack. <br><br>  Kelas osg :: Geometry adalah pembungkus fungsi OpenGL yang bekerja dengan array vertex.  Ini diturunkan dari kelas osg :: Drawable dan dapat dengan mudah ditambahkan ke daftar objek osg :: Geode.  Kelas ini mengambil array yang dijelaskan di atas sebagai input dan menggunakannya untuk menghasilkan geometri menggunakan OpenGL. <br><br><h1>  4. Verteks dan atributnya </h1><br>  Vertex adalah satuan atom primitif geometri.  Ini memiliki sejumlah atribut yang menggambarkan suatu titik dalam ruang dua atau tiga dimensi.  Atribut meliputi: posisi, warna, vektor normal, koordinat tekstur, koordinat kabut, dan sebagainya.  Bagian atas harus selalu memiliki posisi dalam ruang, seperti untuk atribut lainnya, mereka dapat hadir secara opsional.  OpenGL mendukung 16 atribut simpul dasar dan dapat menggunakan berbagai array untuk menyimpannya.  Semua array atribut didukung oleh osg :: Geometry class dan dapat diatur menggunakan metode dari form set * Array (). <br><br>  <b>Atribut Vertex dalam OpenSceneGraph</b> <br><table><tbody><tr><th>  Atribut </th><th>  Tipe data </th><th>  Osg :: Metode Geometri </th><th>  Panggilan OpenGL Setara </th></tr><tr><td>  Posisi </td><td>  3-vektor </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3-vektor </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Warna </td><td>  4-vektor </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Warna sekunder </td><td>  4-vektor </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Koordinat Kabut </td><td>  mengapung </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Koordinat tekstur </td><td>  2- atau 3-vektor </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Atribut lainnya </td><td>  Ditentukan Pengguna </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  Pada prinsipnya, perlu untuk mengatur atribut Anda sendiri untuk masing-masing simpul, yang mengarah pada pembentukan beberapa array atribut dengan ukuran yang sama - jika tidak, ketidaksesuaian dalam ukuran array dapat menyebabkan perilaku mesin yang tidak ditentukan.  OSG mendukung berbagai metode untuk menghubungkan atribut vertex, misalnya <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  berarti bahwa setiap titik dan setiap warna titik saling berkorelasi satu sama lain.  Namun, jika Anda melihat kode tersebut <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  lalu dia menerapkan satu warna ke seluruh geometri.  Demikian pula, hubungan antara atribut lain dapat dikonfigurasi dengan memanggil metode setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding (), dan setVertexAttribBinding (). <br><br><h1>  5. Set primitif geometri </h1><br>  Langkah selanjutnya setelah mendefinisikan array atribut vertex adalah untuk menggambarkan bagaimana data vertex akan diberikan.  Virtual osg :: PrimitiveSet class digunakan untuk mengontrol primitif geometri yang dihasilkan oleh renderer dari sekumpulan simpul.  The osg :: Kelas Geometri menyediakan beberapa metode untuk bekerja dengan set primitif geometri: <br><br><ul><li>  addPrimitiveSet () - meneruskan pointer ke sekumpulan primitif di objek osg :: Geometry. <br></li><li>  removePrimitiveSet () - menghapus satu set primitif.  Sebagai parameter, dibutuhkan indeks awal set dan jumlah set yang akan dihapus. <br></li><li>  getPrimitiveSet () - mengembalikan seperangkat primitif pada indeks yang diteruskan sebagai parameter. <br></li><li>  getNumPrimitiveSets () - mengembalikan jumlah total set primitif yang terkait dengan geometri ini. <br></li></ul><br>  Kelas osg :: PrimitiveSet adalah abstrak dan tidak dapat dipakai, tetapi beberapa kelas turunan yang merangkum set primitif yang beroperasi dengan OpenGL, seperti osg :: DrawArrays dan osg :: DrawElementsUInt, mewarisi darinya. <br><br>  Kelas osg :: DrawArrays menggunakan beberapa elemen berturut-turut dari sebuah array vertex untuk membangun sebuah geometri primitif.  Itu dapat dibuat dan dilampirkan ke geometri dengan memanggil metode. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  Mode parameter pertama menetapkan tipe primitif ke tipe primitif OpenGL yang sesuai: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS dan GL_POL. <br><br>  Parameter pertama dan kedua menentukan indeks pertama dalam array verteks dan jumlah simpul dari mana geometri harus dihasilkan.  <strong>Selain itu, OSG tidak memeriksa apakah jumlah simpul yang ditentukan cukup untuk membangun geometri yang ditentukan oleh mode, yang dapat menyebabkan aplikasi crash!</strong> <br><br><h1>  6. Contoh - menggambar kotak dicat </h1><br>  Kami menerapkan semua hal di atas sebagai contoh sederhana <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber lengkap untuk contoh quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Setelah kompilasi dan eksekusi, kami mendapatkan hasil yang mirip dengan ini <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Contoh ini perlu klarifikasi.  Jadi, pertama-tama, kita membuat array simpul dari persegi, di mana koordinatnya disimpan <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Selanjutnya kita atur array normals.  Dalam kasus sederhana kami, kami tidak perlu membuat yang normal untuk setiap titik - cukup jelaskan satu unit vektor yang diarahkan tegak lurus ke bidang persegi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Atur warna untuk setiap titik <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Sekarang buat objek geometri tempat deskripsi kuadrat kita akan disimpan, yang akan diproses oleh render.  Kami melewati array simpul ke geometri ini <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Melewati array normals, kami memberi tahu mesin bahwa satu normal tunggal akan digunakan untuk semua simpul, dengan menentukan metode penjilidan ("binding") dari normals BIND_OVAERALL <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  Melewati warna simpul, sebaliknya, kami menunjukkan bahwa setiap simpul akan memiliki warna sendiri <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Sekarang buat satu set primitif untuk geometri.  Kami menunjukkan bahwa wajah kuadrat (GL_QUADS) harus dihasilkan dari array vertex, mengambil verteks dengan indeks 0 sebagai verteks pertama, dan jumlah total simpul akan menjadi 4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Yah, saya pikir itu tidak layak menjelaskan transfer geometri dan peluncuran render <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Kode di atas setara dengan desain berikut di OpenGL murni <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Mengindeks simpul dalam primitif </h1><br>  Kelas osg :: DrawArrays berfungsi dengan baik saat membaca data titik langsung dari array, tanpa celah.  Namun, ini tidak begitu efektif ketika simpul yang sama dapat dimiliki oleh beberapa wajah dari suatu objek.  Mari kita lihat sebuah contoh. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  Kubus memiliki delapan simpul.  Namun, seperti yang dapat dilihat dari gambar (kita melihat pembukaan kubus di pesawat) beberapa simpul milik lebih dari satu wajah.  Jika Anda membuat kubus dengan 12 wajah segitiga, maka simpul-simpul ini akan diulang, dan alih-alih array 8 simpul, kita mendapatkan array yang terdiri dari 36 simpul, yang sebagian besar sebenarnya adalah simpul yang sama! <br><br>  Kelas OSG osg :: DrawElementsUInt, osg :: DrawElementsUByte dan osg :: DrawElementsUShort, yang menggunakan array indeks titik sebagai data, dirancang untuk menyelesaikan masalah yang dijelaskan.  Susunan indeks menyimpan indeks simpul primitif yang menggambarkan wajah dan elemen geometri lainnya.  Ketika menerapkan kelas-kelas ini untuk sebuah kubus, itu cukup untuk menyimpan array delapan simpul yang terkait dengan wajah melalui array indeks. <br><br>  Kelas tipe osg :: DrawElements * dibangun dengan cara yang sama dengan kelas standar std :: vector.  Kode semacam itu dapat digunakan untuk menambahkan indeks. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Kode ini mendefinisikan muka depan kubus yang ditunjukkan pada gambar. <br><br>  Mari kita pertimbangkan satu contoh ilustratif lagi - octahedron <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  Ini menarik karena hanya berisi enam simpul, tetapi setiap simpul masuk sebanyak empat wajah segitiga!  Kita dapat membuat array 24 simpul untuk menampilkan kedelapan wajah menggunakan osg :: DrawArrays.  Namun, kita akan melakukan sebaliknya - kita akan menyimpan simpul dalam array enam elemen, dan kita menghasilkan wajah menggunakan kelas osg :: DrawElementsUInt. <br><br><div class="spoiler">  <b class="spoiler_title">Sumber lengkap untuk contoh segi delapan</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Mari kita menganalisis kode ini lebih terinci.  Tentu saja, hal pertama yang kita lakukan adalah membuat array enam simpul <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Kami menginisialisasi setiap titik secara langsung dengan mengakses vektor koordinatnya menggunakan operasi penunjuk titik dari operator penunjuk dan operator [] (kami ingat bahwa osg :: Array serupa di perangkatnya dengan std :: vector). <br><br>  Sekarang buat wajah sebagai daftar indeks titik <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Wajah akan berbentuk segitiga, akan ada 8, yang berarti daftar indeks harus berisi 24 elemen.  Indeks wajah berjalan berurutan dalam larik ini: misalnya, wajah 0 dibentuk oleh simpul 0, 1, dan 2;  wajah 1 - simpul 0, 4 dan 1;  wajah 2 - simpul 4, 5 dan 1 dan seterusnya.  Verteks terdaftar dalam urutan berlawanan jika Anda melihat wajah wajah (lihat gambar di atas). <br><br>  Langkah-langkah lebih lanjut untuk membuat geometri yang kami lakukan dalam contoh sebelumnya.  Satu-satunya hal yang tidak kami lakukan adalah pembuatan otomatis normals yang dihaluskan (rata-rata), yang kami lakukan dalam contoh ini dengan memanggil <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  Memang, jika simpul dari sebuah wajah diberikan, maka mudah untuk menghitung normalnya.  Pada titik-titik di mana beberapa wajah bertemu, normal rata-rata tertentu dihitung - normal dari wajah yang bertemu ditambahkan dan jumlah yang dihasilkan dinormalisasi lagi.  Operasi-operasi ini (dan juga banyak lagi!) Dapat dilakukan oleh mesin itu sendiri menggunakan kelas-kelas dari perpustakaan osgUtil.  Oleh karena itu, dalam contoh kami, kami akan menambahkan instruksi ke linker untuk membangun program kami dengan perpustakaan ini di file * .pro <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  Hasilnya, kami mendapatkan hasil berikut <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Untuk memahami cara kerjanya, pertimbangkan pipa OpenGL <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  Mekanisme array vertex mengurangi jumlah panggilan OpenGL.  Ini menyimpan data titik dalam memori aplikasi, yang digunakan pada sisi klien.  Pipa OpenGL pada sisi server mendapat akses ke berbagai array vertex.  Seperti yang ditunjukkan dalam diagram, OpenGL menerima data dari buffer vertex di sisi klien dan, secara teratur, melakukan perakitan primitif.  Ini adalah bagaimana data diproses menggunakan metode set * Array () dari kelas osg :: Geometry.  Kelas osg :: DrawArrays melewati array ini secara langsung dan menampilkannya. <br><br>  Saat menggunakan osg :: DrawElements *, dimensi array verteks berkurang dan jumlah simpul yang ditransfer ke pipa berkurang.  Array indeks memungkinkan Anda membuat cache vertex di sisi server.  OpenGL membaca data vertex dari cache, alih-alih membaca dari buffer vertex di sisi klien.  Ini secara signifikan meningkatkan kinerja rendering keseluruhan. <br><br><h1>  8. Teknik pengolahan mesh poligon </h1><br>  OpenSceneGraph mendukung berbagai teknik untuk memproses mesh poligon objek geometri pemandangan.  Metode preprocessing ini, seperti pengurangan poligon dan tessellation, sering digunakan untuk membuat dan mengoptimalkan model poligon.  Mereka memiliki antarmuka yang sederhana, tetapi dalam prosesnya mereka melakukan banyak perhitungan yang rumit dan tidak terlalu cocok untuk eksekusi on-the-fly. <br><br>  Teknik yang dijelaskan meliputi: <br><br><ol><li>  osgUtil :: Simplifier - mengurangi jumlah segitiga dalam geometri.  Metode publik simplify () digunakan untuk menyederhanakan geometri model. <br></li><li>  osgUtil :: SmootingVisitor - penghitungan normals.  Metode smooth () dapat digunakan untuk menghasilkan normals yang dihaluskan untuk model, alih-alih secara independen menghitungnya dan secara eksplisit mengaturnya melalui array normals. <br></li><li>  osgUtil :: TangentSpaceGenerator - generasi vektor basis garis singgung untuk simpul model.  Ini diluncurkan dengan memanggil metode generate () dan menyimpan hasilnya dikembalikan oleh getTangentArray (), getNormalArray (), dan getBinormalArray () method.  Hasil ini dapat digunakan untuk berbagai atribut simpul saat menulis shader di GLSL. <br></li><li>  osgUtil :: Tesselator - melakukan tessellation poligon - membagi primitif kompleks menjadi urutan yang sederhana (metode retesselatePolygons ()) <br></li><li>  osgUtil :: TriStripVisitor - mengubah permukaan geometris menjadi set strip wajah segitiga, yang memungkinkan rendering dengan konsumsi memori yang efisien.  Metode stripify () mengubah satu set primitif model menjadi geometri berdasarkan pada set GL_TRIANGLE_STRIP. <br></li></ol><br>  Semua metode menerima geometri objek sebagai parameter yang dilewatkan oleh osg :: Geometri &amp; tautan, misalnya seperti ini <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  di mana geom mengacu pada contoh geometri yang dijelaskan oleh penunjuk pintar. <br><br>  Kelas osg :: Simplifier, osg :: SmoothingVisitor dan osg :: TriStripVisitor dapat bekerja secara langsung dengan node dalam grafik adegan, misalnya <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  Metode accept () memproses semua node anak hingga operasi yang ditentukan diterapkan ke semua node terminal dari bagian pohon adegan yang disimpan dalam node tipe osg :: Geode. <br><br>  Mari kita coba teknik tessellation dalam praktek. <br><br><div class="spoiler">  <b class="spoiler_title">Kode contoh tesselator penuh</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Berdasarkan posisi spasial dari simpul dalam contoh ini, jelas bahwa kami mencoba membuat poligon non-cembung dari delapan simpul, menggunakan generasi satu wajah dari tipe GL_POLYGON.  Perakitan dan pelaksanaan contoh ini menunjukkan bahwa hasil yang kami harapkan tidak berfungsi - contohnya ditampilkan secara tidak benar <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Untuk memperbaiki masalah ini, geometri yang dibangun harus di-tessellasikan sebelum meneruskannya ke pemirsa <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  setelah itu kita mendapatkan hasil yang benar <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Bagaimana cara kerjanya?  Poligon non-cembung, tanpa menggunakan tessellation yang benar, tidak akan ditampilkan seperti yang kami harapkan, karena OpenGL, yang berupaya mengoptimalkan kinerja, akan menganggapnya sebagai poligon cembung sederhana atau mengabaikannya, yang dapat memberikan hasil yang benar-benar tak terduga. <br><br>  Kelas osgUtil :: Tessellator menggunakan algoritma untuk mengubah poligon cembung menjadi serangkaian non-cembung - dalam kasus kami, ia mengubah geometri menjadi GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas ini dapat menangani poligon lubang dan poligon yang memotong sendiri. Menggunakan metode setWindingType () publik, Anda dapat menentukan berbagai aturan pemrosesan, seperti GLU_TESS_WINDING_ODD atau GLU_TESS_WINDING_NONZERO, yang menentukan wilayah bagian dalam dan luar dari poligon kompleks.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel ini, kami mendapat pemahaman dasar tentang bagaimana geometri objek tiga dimensi disimpan dan diproses dalam mesin OSG. </font><font style="vertical-align: inherit;">Jangan berpikir bahwa contoh sederhana dan tidak terlalu mengesankan yang dipertimbangkan dalam artikel adalah batas kemampuan mesin. </font><font style="vertical-align: inherit;">Hanya contoh-contoh ini yang dapat membantu pengembang memahami mekanisme OpenSceneGraph, dan tanpa pemahaman ini sulit membayangkan pekerjaan dari hal-hal yang lebih kompleks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ini didasarkan pada terjemahan dan pemrosesan teks dari bab-bab yang sesuai dari buku </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Panduan Pemula</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Semua contoh diperiksa oleh saya secara pribadi, dan kode sumbernya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersedia di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dilanjutkan ...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430212/">https://habr.com/ru/post/id430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430202/index.html">Menulis sistem partikel yang berinteraksi berpasangan dalam C ++ menggunakan DirectX 11</a></li>
<li><a href="../id430204/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: ‚ÄúPenjelajahan Pribadi Internet‚Äù, bagian 1</a></li>
<li><a href="../id430206/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: Penjelajahan Pribadi Internet, Bagian 2</a></li>
<li><a href="../id430208/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: "Penjelajahan Internet Pribadi", bagian 3</a></li>
<li><a href="../id430210/index.html">Tes Kesabaran Saya oleh Akademi Keamanan Titik Centang</a></li>
<li><a href="../id430216/index.html">Seperti yang saya pahami, saya makan banyak manisan, atau klasifikasi barang dengan memeriksa aplikasi</a></li>
<li><a href="../id430218/index.html">Optimalisasi Energi STM32: Panduan Praktis</a></li>
<li><a href="../id430220/index.html">Bagaimana mengubah hub usb "seratus tahun" menjadi smart dikelola dan menghemat $ 300</a></li>
<li><a href="../id430222/index.html">Insinyur Senior dalam mencari pekerjaan. Bagaimana saya melewati 20 wawancara dengan HR dan apa yang saya pikirkan</a></li>
<li><a href="../id430224/index.html">Gangguan Skizotip: An Inside Look</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>