<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✝️ 🏇🏻 🖲️ Docker: o que todo desenvolvedor .Net precisa saber 🍻 👨🏾‍✈️ 👐🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na era do DevOps vencedor, os desenvolvedores são simplesmente obrigados a saber sobre os contêineres do Docker, por que eles são necessários e como t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: o que todo desenvolvedor .Net precisa saber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/psb/blog/439942/"> Na era do DevOps vencedor, os desenvolvedores são simplesmente obrigados a saber sobre os contêineres do Docker, por que eles são necessários e como trabalhar com eles.  Isso facilita muito o trabalho.  Além disso, mesmo aqueles que trabalham com o .Net Core no ambiente de desenvolvimento do Visual Studio 2017 podem sentir todo o poder da conteinerização.Pavel Skiba, chefe do departamento de desenvolvimento de aplicativos para servidor, na reunião <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C # .Net</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Panda-Meetup</a> , falou sobre as ferramentas disponíveis e a configuração do Docker for VS. <br><br><img src="https://habrastorage.org/webt/-u/oc/-i/-uoc-itpzk__qajoj6vuduyvqsc.jpeg"><br><a name="habracut"></a><br>  O que um desenvolvedor deve ser capaz de fazer?  "Programa", você responde e ... Adivinha.  Porém, se antes a lista de conhecimentos necessários terminava com isso, agora na era do DevOps está apenas começando.  Quando escrevemos código, definitivamente precisamos conhecer a estrutura da rede: o que interage com o que.  É necessário suporte para várias linguagens de programação ao mesmo tempo, e diferentes partes de código em um projeto podem ser escritas em qualquer coisa. <br><br><img src="https://habrastorage.org/webt/kv/v8/e0/kvv8e0hdfubjxrh-ph7y8bqaxho.jpeg"><br><br>  Precisamos saber como reverter o software se um erro for detectado.  Precisamos gerenciar configurações para diferentes ambientes usados ​​na empresa - esses são pelo menos vários ambientes de desenvolvimento, ambientes de teste e combate.  Ah, sim, você ainda precisa entender scripts em diferentes servidores / sistemas operacionais, porque nem tudo pode ser feito usando código, às vezes você precisa escrever scripts. <br><br>  Precisamos conhecer os requisitos de segurança, e eles estão se tornando mais difíceis e gastam muito tempo com o desenvolvedor.  Não se esqueça do suporte e desenvolvimento de software relacionado: Git, Jenkins e assim por diante.  Como resultado, o desenvolvedor pode simplesmente não ter tempo suficiente para o desenvolvimento puro. <br><br>  O que fazer?  Existe uma saída e ela está nos contêineres do Docker e em seu sistema de gerenciamento.  Depois de implantar todo esse complexo colosso, e você, como nos velhos tempos, só escreverá código novamente.  Todo o resto será controlado por outras pessoas ou pelo próprio sistema. <br><br><h3>  Entendemos contêineres </h3><br>  O que é um contêiner de docker?  Esta é uma estrutura que consiste em várias camadas.  A camada superior é a camada binária do seu aplicativo.  A segunda e a terceira camada agora estão integradas no .Net Core, o contêiner já é SDK-shny.  A próxima camada depende do sistema operacional no qual o contêiner está implantado.  E a camada inferior é o próprio sistema operacional. <br><br><img src="https://habrastorage.org/webt/la/9r/rr/la9rrrk6nijaktzurbzvs6-7vem.jpeg"><br><br>  No nível inferior, o Windows Nanoserver é implantado.  Este é um aperto mega-aparado do Windows Server, que não pode fazer nada além de manter um programa utilitário implantado.  Mas o volume dela é 12 vezes menor. <br><br>  Se compararmos os servidores e contêineres físicos e virtuais, os benefícios destes serão óbvios. <br><br><img src="https://habrastorage.org/webt/rv/jf/bf/rvjfbftq2pa8vxkypp0cufyailq.jpeg"><br><br>  Quando tudo funcionava em servidores físicos, nos deparamos com vários problemas.  Não havia isolamento nos códigos da biblioteca; alguns aplicativos poderiam interferir um no outro.  Por exemplo: um aplicativo funcionou no .Net 1.1 e outro no .Net 2.0.  Na maioria das vezes, isso levou à tragédia.  Depois de algum tempo, os servidores virtuais apareceram, o problema do isolamento foi resolvido, não havia bibliotecas compartilhadas.  É verdade que, ao mesmo tempo, ficou muito caro em termos de recursos e mão-de-obra: era necessário acompanhar quantas máquinas virtuais giravam em uma máquina virtual, no Hyper-V e em um pedaço de ferro. <br><br>  Os contêineres foram projetados para serem uma solução barata e conveniente, minimamente dependente do sistema operacional.  Vamos ver como eles diferem.  Servidores virtuais dentro do sistema estão localizados aproximadamente assim. <br><br><img src="https://habrastorage.org/webt/7r/tx/hy/7rtxhyzwk89x504k4elpatklrue.jpeg"><br><br>  A camada inferior é o servidor host.  Pode ser físico ou virtual.  A próxima camada é qualquer sistema operacional com virtualização, acima é um hipervisor.  No topo, estão servidores virtuais que podem ser divididos em SO e aplicativos convidados.  Ou seja, em cada servidor virtual, um sistema operacional convidado é implantado no sistema operacional, e isso é um desperdício extra de recursos. <br><br>  Vamos ver como os contêineres do Linux estão localizados no sistema. <br><br><img src="https://habrastorage.org/webt/2i/fh/qm/2ifhqmfohluhldax3v5evaomvvo.jpeg"><br><br>  Como você pode ver, os binários com aplicativos são imediatamente localizados acima do servidor host e do SO.  O SO convidado não é necessário, os recursos são liberados, as licenças do SO convidado não são necessárias. <br><br>  Os contêineres do Windows são um pouco diferentes do Linux. <br><br><img src="https://habrastorage.org/webt/br/p3/td/brp3tdb9vl_yau-iwsqj_c5yfmm.jpeg"><br><br>  As camadas básicas são as mesmas: infraestrutura, SO host (mas agora Windows).  Porém, os contêineres podem trabalhar diretamente com o sistema operacional ou ser implantados no topo do hipervisor.  No primeiro caso, há isolamento de processos e espaços, mas eles usam o mesmo núcleo com outros contêineres, que do ponto de vista da segurança não são gelo.  Se você usar contêineres através do Hyper-V, tudo será isolado. <br><br><h3>  Learning Docker for VS </h3><br>  Vamos para o próprio Docker.  Suponha que você tenha o Visual Studio e esteja instalando o cliente Docker para Windows pela primeira vez.  Nesse caso, o Docker implantará o servidor demo do Docker, a interface no Rest para acesso a ele e o próprio cliente - a linha de comando do Docker.  Isso nos permitirá gerenciar tudo relacionado a contêineres: rede, imagens, contêineres, camadas. <br><br><img src="https://habrastorage.org/webt/h3/ft/dz/h3ftdzxhy9d-y2cz43xjbllnfiq.jpeg"><br><br>  O slide mostra os comandos mais simples: puxe o contêiner do Docker, inicie-o, colete, confirme, envie de volta. <br><br>  O Docker é muito emparelhado organicamente com o Visual Studio.  A captura de tela mostra um menu do painel do Visual Studio 2017. O suporte à composição do Docker é integrado diretamente ao Intellisense, o Dockerfile é suportado e todos os artefatos funcionam na linha de comando. <br><br><img src="https://habrastorage.org/webt/o6/lo/xq/o6loxq2u8gcuxqmeeqc9rf5d7jw.jpeg"><br><br>  O interessante é que podemos depurar contêineres do Docker diretamente em tempo real.  E se seus contêineres estiverem conectados entre si, eles serão imediatamente eliminados de uma só vez, e você não precisará executar vários ambientes. <br><br>  Como são montados os contêineres?  O elemento principal aqui é o dockerfile, que contém instruções para a construção da imagem.  Cada dockerfile é criado para cada projeto.  Indica: de onde obtemos a imagem básica, quais argumentos passamos, qual é o nome do diretório de trabalho com arquivos, portas. <br><br><img src="https://habrastorage.org/webt/cw/y4/s4/cwy4s4ukujlmx_ewfcr9rhq6wk4.jpeg"><br><br>  Este argumento de origem tem dois parâmetros.  O segundo parâmetro é o caminho no qual o resultado da montagem será colocado no projeto; o valor é definido por padrão.  Na minha opinião, esta não é uma opção muito boa.  Geralmente, há muito lixo nessa pasta, ela precisa ser limpa periodicamente e, quando limpamos essa pasta, podemos esfregar a montagem.  Portanto, se desejar, você pode alterá-lo, ele é definido pelo parâmetro do sistema Docker_build_source, que também pode ser martelado. <br><br>  A instrução Entrypoint permite configurar o contêiner como um arquivo executável.  Essa linha é necessária para o .Net Core, para que, depois que o contêiner seja iniciado com êxito, ele envie uma mensagem "Seu aplicativo está sendo executado" para a linha de comando. <br><br>  Agora, sobre depuração de contêineres.  Tudo aqui é como um .net regular, você quase não perceberá a diferença.  Na maioria das vezes, eu executo o .Net Core como auto-hospedado em dotnet.exe.  Ele usa o depurador CLRDBG, o cache de pacotes NuGet e o código fonte. <br><br>  O ASP.Net 4.5+ é hospedado pelo IIS ou IIS Express, usa o Microsoft Visual Studio Debugger e a origem da raiz do site no IIS. <br><br><img src="https://habrastorage.org/webt/1h/xa/ad/1hxaadi82m4yntfg6nurythtlui.jpeg"><br><br>  Existem dois ambientes para depuração: Debug e Release.  A tag da imagem de depuração é marcada como dev e a versão mais recente.  Ao depurar, o argumento Source é melhor definido como obj / Docker / empty, para não ficar confuso, mas quando você libera obj / Docker / publish.  Aqui você pode usar todos os mesmos binários, visualizações, pasta wwwroot e todas as dependências existentes. <br><br><h3>  Dominando o Docker Compose </h3><br>  Vamos para a parte divertida: a ferramenta de orquestração de composição do Docker.  Vejamos um exemplo: você tem algum tipo de serviço comercial que afeta 5-6 contêineres.  E você precisa, de alguma forma, corrigir como eles devem ser montados, em que ordem.  É aqui que o Docker-compor é útil, o que fornecerá toda a montagem, lançamento e dimensionamento de contêineres.  É gerenciado de forma simples, tudo é coletado por uma equipe. <br><br><img src="https://habrastorage.org/webt/d4/df/aq/d4dfaqe-8qt-k9wxxfs6y8gigke.jpeg"><br><br>  O Docker-compose usa arquivos YAML que armazenam a configuração de como os contêineres devem ser montados.  Eles descrevem quais configurações você precisa usar para as próprias imagens, montagens, serviços, volumes, redes, ambientes.  A sintaxe é idêntica para publicação em clusters.  Ou seja, depois que eles escrevem esse arquivo e, no futuro, for necessário implantar um serviço de negócios em um cluster, você não precisará adicionar mais nada. <br><br>  Considere a estrutura de um arquivo YAML.  Imagem é uma imagem do Docker.  Uma imagem é um contêiner sem uma camada de aplicação e é imutável. <br><br><img src="https://habrastorage.org/webt/no/y1/s7/noy1s7xjmk8uzkx9qw-7dgtubuc.jpeg"><br><br>  Build indica como construir, onde construir e onde implantar. <br>  Depends_on - Dependência de quais serviços é dependente. <br>  Meio ambiente - aqui definimos o meio ambiente. <br>  Portas - mapeamento de portas em que porta seu contêiner estará disponível. <br><br>  Considere um exemplo.  Temos apenas uma API sem serviço, essencialmente três contêineres: existe SQL.data no Linux, existe um aplicativo em si, depende da webapi e a webapi depende do SQL.data. <br><br><img src="https://habrastorage.org/webt/dl/_b/wz/dl_bwzfrtxf-dpiumh0d6mcmork.jpeg"><br><br>  Não importa em que ordem os componentes são gravados no arquivo.  Se tudo estiver descrito corretamente, o Compose criará automaticamente essas informações corretamente com base nas dependências do projeto.  Esse arquivo é suficiente para coletar todos os contêineres de uma só vez; a saída será uma versão finalizada. <br><br>  Existe uma espécie de “contêiner de contêiner”, um docker de contêiner especial-compose.ci.build.yml, no qual toda a composição é montada.  Você pode executar esse contêiner especial na linha de comando do Visual Studio e ele poderá concluir a montagem em um servidor de compilação, por exemplo, no Jenkins. <br><br><img src="https://habrastorage.org/webt/c-/n7/dt/c-n7dtz4rp_xdqlove2dxze5w7y.jpeg"><br><br>  Dê uma olhada dentro do arquivo.  O exemplo contém o diretório de trabalho e de onde ele vem.  Ele restaura o projeto do GIT, publica ele próprio essa solução, configura o Release e carrega o resultado.  Essa é toda a equipe a construir, nada mais precisa ser escrito.  Basta registrá-lo uma vez e iniciar a publicação com um botão. <br><br>  No que mais vale a pena prestar atenção.  A composição do Docker para cada ambiente coleta imagens, para cada configuração um arquivo separado.  Para cada configuração no Visual Studio, há um arquivo com as configurações necessárias para o ambiente. <br><br><img src="https://habrastorage.org/webt/hp/tl/mh/hptlmho5s80wvh-vqgpprnimnau.jpeg"><br><br>  Diretamente do VS, você pode iniciar remotamente a depuração de toda a composição. <br><br><h3>  Orquestradores de Cluster </h3><br>  Por fim, abordamos tópicos como orquestradores de cluster.  Não devemos pensar em como os contêineres continuam a existir, quais pessoas ou sistemas são gerenciados.  Para isso, existem quatro dos sistemas de gerenciamento de contêiner mais populares: Google Kubernetes, Mesos DC / OS, Docker Swarm e Azure Service Fabric.  Eles permitem gerenciar o armazenamento em cluster e a composição de contêineres. <br><br><img src="https://habrastorage.org/webt/5h/xd/lq/5hxdlqbpiyr2e7lytjagsikndec.jpeg"><br><br>  Esses sistemas são capazes de lidar com uma enorme camada de microsserviços, fornecendo tudo o que é necessário.  O desenvolvedor precisará configurar essa camada apenas uma vez. <br><br>  A versão completa da performance no Panda Meetup está disponível abaixo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GLMFaf39zxM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Para aqueles que desejam se aprofundar no assunto, aconselho que você estude os seguintes materiais: <br><br>  Http://dot.net <br>  Http://docs.docker.com <br>  Http://hub.docker.com/microsoft <br>  Http://docs.microsoft.com <br>  Http://visualstudio.com <br><br>  E, finalmente, um conselho importante da prática: o mais difícil é lembrar onde está o que está. <br><br>  A documentação ao trabalhar com contêineres de encaixe cairá sobre seus ombros.  Sem documentação, você esquecerá onde em qual contêiner o que está conectado com o que e o que funciona.  Quanto mais serviços, maior a rede total de conexões. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439942/">https://habr.com/ru/post/pt439942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439932/index.html">Como abrimos escritórios de desenvolvimento</a></li>
<li><a href="../pt439934/index.html">Processos de negócios. Extraia um modelo BPMN de um documento. Parte 1</a></li>
<li><a href="../pt439936/index.html">Tecnologia 3D para fundição: como criar um molde para fundição em uma semana</a></li>
<li><a href="../pt439938/index.html">O que chamar: política de privacidade e política de privacidade</a></li>
<li><a href="../pt439940/index.html">Teamlead Conf Msk 2019: resultados da campanha de aplicação, relatórios, considerações</a></li>
<li><a href="../pt439944/index.html">SAPUI5 para manequins parte 5: um exercício completo passo a passo</a></li>
<li><a href="../pt439946/index.html">Por que escolhemos Electron</a></li>
<li><a href="../pt439948/index.html">Intel SVT-AV1: Codificador AV1 de código aberto para serviços pesados</a></li>
<li><a href="../pt439950/index.html">3º Teste de Turing: condições de participação e prêmios aos vencedores</a></li>
<li><a href="../pt439952/index.html">Hospedando o servidor https Node.js com SSL atualizado automaticamente na nuvem e como eu configuro o ciclo de desenvolvimento (+ git, reage)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>