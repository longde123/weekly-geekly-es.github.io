<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° üîá ü•õ Gerenciamento de mem√≥ria Python üï§ üë∏üèø üë®üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Ent√£o, o longo fim de semana de mar√ßo terminou. Queremos dedicar a primeira publica√ß√£o p√≥s-feriado ao amado por muitos cursos - "Desenvol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerenciamento de mem√≥ria Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443312/">  Ol√° pessoal!  Ent√£o, o longo fim de semana de mar√ßo terminou.  Queremos dedicar a primeira publica√ß√£o p√≥s-feriado ao amado por muitos cursos - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Desenvolvedor Python"</a> , que come√ßa em menos de duas semanas.  Vamos l√° <br><br>  <b>Conte√∫do</b> <br><br><ol><li>  A mem√≥ria √© um livro vazio </li><li>  Gerenciamento de mem√≥ria: do hardware ao software </li><li>  Implementa√ß√£o b√°sica do Python </li><li>  Conceito Global Interpreter Lock (GIL) </li><li>  Coletor de lixo </li><li>  Gerenciamento de mem√≥ria no CPython: <br><ul><li>  Piscinas </li><li>  Blocos </li><li>  Arenas </li></ul></li><li>  Conclus√£o </li></ol><br><img src="https://habrastorage.org/webt/ww/vn/wj/wwvnwjqala4vtezc2ei4dx4ml_w.png"><br><br>  Voc√™ j√° se perguntou como o Python nos bastidores processa seus dados?  Como suas vari√°veis ‚Äã‚Äãs√£o armazenadas na mem√≥ria?  Em que ponto eles s√£o removidos? <br>  Neste artigo, vamos nos aprofundar na estrutura interna do Python para entender como o gerenciamento de mem√≥ria funciona. <br><br>  Depois de ler este artigo, voc√™: <br><br><ul><li>  Saiba mais sobre opera√ß√µes de baixo n√≠vel, especialmente mem√≥ria. </li><li>  Entenda como o Python abstrai opera√ß√µes de baixo n√≠vel. </li><li>  Aprenda sobre os algoritmos de gerenciamento de mem√≥ria no Python. </li></ul><br>  Conhecer a estrutura interna do Python fornecer√° uma melhor compreens√£o dos princ√≠pios de seu comportamento.  Espero que voc√™ possa dar uma olhada no Python de uma nova perspectiva.  Nos bastidores, existem muitas opera√ß√µes l√≥gicas para fazer seu programa funcionar corretamente. <a name="habracut"></a><br><br>  <b>A mem√≥ria √© um livro vazio.</b> <br><br>  Voc√™ pode imaginar a mem√≥ria do computador como um livro vazio, esperando que ele escreva muitos contos.  Ainda n√£o h√° nada em suas p√°ginas, mas em breve aparecer√£o autores que desejam escrever suas hist√≥rias.  Para fazer isso, eles precisar√£o de um lugar. <br>  Como eles n√£o podem escrever uma hist√≥ria em cima de outra, precisam ter muito cuidado com as p√°ginas nas quais escrevem.  Antes de come√ßar a escrever, eles consultam o gerente do livro.  O gerente decide onde, no livro, os autores podem escrever sua hist√≥ria. <br><br>  Como o livro existe h√° muitos anos, muitas hist√≥rias ficam desatualizadas.  Quando ningu√©m l√™ ou aborda a hist√≥ria, eles a removem para abrir caminho para novas hist√≥rias. <br>  No fundo, a mem√≥ria do computador √© como um livro vazio.  Blocos cont√≠nuos de mem√≥ria de tamanho fixo s√£o geralmente chamados de p√°ginas, portanto essa analogia √© √∫til. <br><br>  Os autores podem ser v√°rios aplicativos ou processos que precisam armazenar dados na mem√≥ria.  Um gerente que decide onde os autores podem escrever suas hist√≥rias desempenha o papel de um gerente de mem√≥ria - um classificador.  E quem apaga hist√≥rias antigas √© um coletor de lixo. <br><br>  <b>Gerenciamento de mem√≥ria: do hardware ao software</b> <br><br>  Gerenciamento de mem√≥ria √© o processo no qual os aplicativos de software l√™em e gravam dados.  O gerenciador de mem√≥ria determina onde colocar os dados do programa.  Como a quantidade de mem√≥ria √© obviamente, como o n√∫mero de p√°ginas do livro, o gerente precisa encontrar espa√ßo livre para fornecer o uso pelo aplicativo.  Esse processo √© chamado de "aloca√ß√£o de mem√≥ria". <br><br>  Por outro lado, quando os dados n√£o s√£o mais necess√°rios, eles podem ser exclu√≠dos.  Nesse caso, eles falam sobre liberar mem√≥ria.  Mas do que √© libertado e de onde vem? <br>  Em algum lugar dentro do computador, existe um dispositivo f√≠sico que armazena dados quando voc√™ executa programas Python.  O c√≥digo Python passa por muitos n√≠veis de abstra√ß√£o antes de chegar a este dispositivo. <br><br>  Um dos principais n√≠veis acima do equipamento (RAM, disco r√≠gido etc.) √© o sistema operacional.  Ele gerencia solicita√ß√µes de leitura e grava√ß√£o na mem√≥ria. <br>  Acima do sistema operacional, h√° uma camada de aplicativo na qual existe uma das implementa√ß√µes do Python (conectada ao seu sistema operacional ou baixada do python.org).  O gerenciamento de mem√≥ria para c√≥digo nessa linguagem de programa√ß√£o √© regulado por ferramentas especiais do Python.  Os algoritmos e estruturas que o Python usa para gerenciar a mem√≥ria s√£o o t√≥pico principal deste artigo. <br><br>  <b>Implementa√ß√£o b√°sica do Python</b> <br><br>  A implementa√ß√£o b√°sica do Python, ou "Python puro", √© CPython escrito em C. <br>  Fiquei muito surpreso quando soube disso pela primeira vez.  Como um idioma pode ser escrito em outro idioma ?!  Bem, n√£o literalmente, √© claro, mas a ideia √© algo assim. <br><br>  A linguagem Python √© descrita em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual de refer√™ncia especial em ingl√™s</a> .  No entanto, este guia por si s√≥ n√£o √© muito √∫til.  Voc√™ ainda precisa de uma ferramenta para interpretar o c√≥digo escrito pelas regras do diret√≥rio. <br><br>  Voc√™ tamb√©m precisar√° de algo para executar o c√≥digo no seu computador.  A implementa√ß√£o b√°sica do Python fornece as duas condi√ß√µes.  Ele converte o c√≥digo Python em instru√ß√µes executadas em uma m√°quina virtual. <br><br><blockquote>  Nota: As m√°quinas virtuais s√£o semelhantes aos computadores f√≠sicos, mas est√£o incorporadas no software.  Eles processam instru√ß√µes b√°sicas semelhantes ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo de montagem</a> . </blockquote><br><br>  Python √© uma linguagem de programa√ß√£o interpretada.  Seu c√≥digo Python √© compilado usando instru√ß√µes mais facilmente compreendidas pelo computador - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bytecode</a> .  Essas instru√ß√µes s√£o interpretadas pela m√°quina virtual quando voc√™ executa o c√≥digo. <br><br>  Voc√™ j√° viu arquivos com a extens√£o <i>.pyc</i> ou a pasta <i>__pycache__</i> ?  Este √© o mesmo bytecode que √© interpretado pela m√°quina virtual. <br>  √â importante entender que existem outras implementa√ß√µes al√©m do CPython, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IronPython</a> , que compila e executa no Microsoft Common Language Runtime (CLR).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Jython</a> compila no bytecode Java para executar em uma m√°quina virtual Java.  H√° tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyPy</a> sobre o qual voc√™ pode escrever um artigo separado, por isso vou mencionar apenas de passagem. <br><br>  Neste artigo, focaremos no gerenciamento de mem√≥ria usando ferramentas CPython. <br>  Nota: As vers√µes do Python s√£o atualizadas e tudo pode acontecer no futuro.  No momento da reda√ß√£o deste artigo, a vers√£o mais recente era o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python 3.7</a> . <br><br>  Ok, temos o CPython escrito em C que interpreta o bytecode do Python.  Como isso se relaciona com o gerenciamento de mem√≥ria?  Para come√ßar, existem algoritmos e estruturas para gerenciar mem√≥ria no c√≥digo CPython, em C. Para entender esses princ√≠pios no Python, voc√™ precisa de um entendimento b√°sico do CPython. <br><br>  O CPython √© escrito em C, que por sua vez n√£o suporta programa√ß√£o orientada a objetos.  Por esse motivo, o c√≥digo CPython possui uma estrutura bastante interessante. <br><br>  Voc√™ deve ter ouvido falar que tudo no Python √© um objeto, mesmo tipos como int e str, por exemplo.  Isso √© verdade no n√≠vel de implementa√ß√£o do CPython.  Existe uma estrutura chamada PyObject que todo objeto no CPython usa. <br><br>  Nota: Uma estrutura em C √© um tipo de dados definido pelo usu√°rio que agrupa diferentes tipos de dados em si.  Podemos desenhar uma analogia com linguagens orientadas a objetos e dizer que uma estrutura √© uma classe com atributos, mas sem m√©todos. <br><br>  PyObject √© o progenitor de todos os objetos em Python, contendo apenas duas coisas: <br><br><ul><li>  <b>ob_refcnt</b> : contador de refer√™ncia; </li><li>  <b>ob_type</b> : ponteiro para outro tipo. </li></ul><br>  Um contador de refer√™ncia √© necess√°rio para a coleta de lixo.  Tamb√©m temos um ponteiro para um tipo espec√≠fico de objeto.  Um tipo de objeto √© apenas outra estrutura que descreve objetos em Python (como dict ou int). <br><br>  Cada objeto possui um alocador de mem√≥ria orientado a objetos que sabe como alocar mem√≥ria e armazenar o objeto.  Cada objeto tamb√©m possui um liberador de recursos orientado a objetos que limpa a mem√≥ria se seu conte√∫do n√£o for mais necess√°rio. <br><br>  H√° um fator importante em falar sobre aloca√ß√£o de mem√≥ria e sua limpeza.  A mem√≥ria √© um recurso compartilhado de um computador, e uma coisa bastante desagrad√°vel pode acontecer se dois processos tentarem gravar dados no mesmo local de mem√≥ria ao mesmo tempo. <br><br>  <b>Bloqueio Global de Interpreta√ß√£o (GIL)</b> <br><br>  O GIL √© uma solu√ß√£o para o problema geral de compartilhar mem√≥ria entre recursos compartilhados, como a mem√≥ria do computador.  Quando dois encadeamentos tentam alterar o mesmo recurso ao mesmo tempo, eles pisam um no outro.  Como resultado, uma confus√£o completa √© formada na mem√≥ria e nenhum processo finaliza seu trabalho com o resultado desejado. <br><br>  Voltando √† analogia com o livro, suponha que, dos dois autores, cada um decida que ele deve escrever sua hist√≥ria na p√°gina atual neste momento espec√≠fico.  Cada um deles ignora as tentativas do outro de escrever uma hist√≥ria e come√ßa a escrever teimosamente na p√°gina.  Como resultado, temos duas hist√≥rias, uma em cima da outra, e uma p√°gina absolutamente ileg√≠vel. <br><br>  Uma das solu√ß√µes para esse problema √© precisamente o GIL, que bloqueia o int√©rprete enquanto o thread interage com o recurso alocado, permitindo assim que um e apenas um thread grave na √°rea de mem√≥ria alocada.  Quando o CPython aloca mem√≥ria, ele usa o GIL para garantir que esteja certo. <br>  Essa abordagem tem muitas vantagens e muitas desvantagens; portanto, o GIL causa conflitos na comunidade Python.  Para saber mais sobre o GIL, sugiro ler o seguinte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> . <br><br>  <b>Coletor de lixo</b> <br><br>  Voltemos √† nossa analogia com o livro e imaginemos que algumas hist√≥rias nele est√£o irremediavelmente desatualizadas.  Ningu√©m os l√™ e os aborda.  Nesse caso, uma solu√ß√£o natural seria se livrar deles como desnecess√°rios, liberando espa√ßo para novas hist√≥rias. <br>  Tais hist√≥rias antigas n√£o utilizadas podem ser comparadas com objetos no Python cuja contagem de refer√™ncia caiu para 0. Lembre-se de que todo objeto no Python tem uma contagem de refer√™ncia e um ponteiro para um tipo. <br><br>  A contagem de refer√™ncia pode aumentar por v√°rios motivos.  Por exemplo, aumentar√° se voc√™ atribuir uma vari√°vel a outra vari√°vel. <br><br><img src="https://habrastorage.org/webt/zv/me/dj/zvmedjrxhn3qqrac6tibjlrpnuu.png"><br><br>  Tamb√©m aumentar√° se voc√™ passar o objeto como argumento. <br><br><img src="https://habrastorage.org/webt/kq/np/pm/kqnppmeqfhl4pg6-4atqz_nnhhq.png"><br><br>  No √∫ltimo exemplo, a contagem de refer√™ncia aumentar√° se voc√™ incluir o objeto na lista. <br><br><img src="https://habrastorage.org/webt/ql/ro/mj/qlromj2eg80jfhzykfkpzv8syfg.png"><br><br>  O Python permite que voc√™ saiba o valor atual do contador de refer√™ncia usando o m√≥dulo sys.  Voc√™ pode usar <code>sys.getrefcount(numbers)</code> , mas lembre-se de que chamar <code>getrefcount()</code> aumentar√° o contador de refer√™ncia por outro. <br><br>  De qualquer forma, se o objeto no seu c√≥digo ainda for necess√°rio, seu valor para o contador de refer√™ncia ser√° maior que 0. E quando cair para zero, uma fun√ß√£o especial ser√° iniciada para limpar a mem√≥ria, que a liberar√° e disponibilizar√° para outros objetos. <br><br>  Mas o que significa ‚Äúliberar mem√≥ria‚Äù e como outros objetos a usam?  Vamos mergulhar diretamente no gerenciamento de mem√≥ria no CPython. <br><br>  <b>Gerenciamento de mem√≥ria no CPython</b> <br><br>  Nesta parte, mergulharemos na arquitetura de mem√≥ria CPython e nos algoritmos pelos quais ela opera. <br><br>  Como mencionado anteriormente, existem n√≠veis de abstra√ß√£o entre equipamentos f√≠sicos e CPython.  O sistema operacional (SO) abstrai a mem√≥ria f√≠sica e cria um n√≠vel de mem√≥ria virtual que aplicativos, incluindo Python, podem acessar. <br><br>  Um gerenciador de mem√≥ria virtual orientado ao sistema operacional aloca uma √°rea de mem√≥ria espec√≠fica para processos Python.  Na figura, as √°reas cinza escuras s√£o o espa√ßo que o processo Python ocupa. <br><br><img src="https://habrastorage.org/webt/6k/-f/n6/6k-fn6hhelja1ilktfil1yzmaas.png"><br><br>  Python usa parte da mem√≥ria para uso interno e mem√≥ria n√£o-objeto.  A outra parte √© dividida no armazenamento de objetos (seu <i>int, dict</i> etc.). Agora eu falo em uma linguagem muito simples, mas voc√™ pode olhar embaixo do cap√¥, ou seja, no <a href="">c√≥digo fonte do CPython</a> e ver como tudo isso acontece do ponto de vista pr√°tico. . <br><br>  No CPython, h√° um alocador de objetos respons√°vel por alocar mem√≥ria dentro de uma √°rea de mem√≥ria de objetos.  √â neste distribuidor de objetos que toda a magia √© realizada.  √â chamado sempre que cada novo objeto precisa ocupar ou liberar mem√≥ria. <br><br>  Geralmente, adicionar e remover dados no Python, como int ou list, por exemplo, n√£o usa muitos dados ao mesmo tempo.  √â por isso que a arquitetura do dispensador se concentra em trabalhar com pequenas quantidades de dados por unidade de tempo.  Al√©m disso, ele n√£o aloca mem√≥ria antecipadamente, ou seja, at√© aquele momento at√© que se torne absolutamente necess√°rio. <br><br>  Os coment√°rios no c√≥digo-fonte definem o alocador como "um alocador r√°pido de mem√≥ria para fins especiais que funciona como a fun√ß√£o malloc universal".  Assim, em C, o malloc √© usado para alocar mem√≥ria. <br><br>  Agora, vamos dar uma olhada na estrat√©gia de aloca√ß√£o de mem√≥ria do CPython.  Primeiro, vamos falar sobre as tr√™s partes principais e como elas se relacionam. <br><br>  As arenas s√£o as maiores √°reas de mem√≥ria que ocupam espa√ßo at√© as bordas das p√°ginas na mem√≥ria.  A borda da p√°gina (p√°gina espalhada) √© o ponto extremo de um bloco cont√≠nuo de mem√≥ria de comprimento fixo usado pelo sistema operacional.  Python define a borda da p√°gina do sistema para 256 KB. <br><br><img src="https://habrastorage.org/webt/cu/t2/ta/cut2ta8lwor00zy8h5k8ogjjhgy.png"><br><br>  Dentro das arenas, existem pools (pool), que s√£o considerados uma p√°gina virtual de mem√≥ria (4 Kb).  Eles parecem p√°ginas em nossa analogia.  Os pools s√£o divididos em peda√ßos ainda menores de mem√≥ria - blocos. <br><br>  Todos os blocos no pool s√£o encontrados em uma "classe de tamanho".  A classe de tamanho determina o tamanho do bloco, com uma certa quantidade de dados solicitados.  A gradua√ß√£o na tabela abaixo √© obtida diretamente dos coment√°rios no c√≥digo-fonte: <br><br><img src="https://habrastorage.org/webt/n9/sk/55/n9sk55ex-esbcfdnnxhavivbeta.png"><br><br>  Por exemplo, se forem necess√°rios 42 bytes, os dados ser√£o colocados em um bloco de 48 bytes. <br><br>  <b>Piscinas</b> <br><br>  Piscinas s√£o compostas de blocos da mesma classe de tamanho.  Cada pool trabalha com o princ√≠pio de uma lista duplamente vinculada a outros pools da mesma classe de tamanho.  Portanto, o algoritmo pode encontrar facilmente o local necess√°rio para o tamanho de bloco necess√°rio, mesmo entre muitos conjuntos. <br><br>  A <code>usedpools list</code> controla todos os conjuntos que possuem algum tipo de espa√ßo livre dispon√≠vel para dados de cada classe de tamanho.  Quando o tamanho do bloco necess√°rio √© solicitado, o algoritmo verifica a lista de conjuntos usados ‚Äã‚Äãpara encontrar um conjunto adequado para ele. <br><br>  As piscinas est√£o em tr√™s estados: usadas, cheias, vazias.  O pool usado cont√©m blocos nos quais algumas informa√ß√µes podem ser gravadas.  Os blocos do pool completo est√£o todos distribu√≠dos e j√° cont√™m dados.  Conjuntos vazios n√£o cont√™m dados e podem ser divididos em quais classes de tamanho s√£o adequadas, se necess√°rio. <br><br>  A lista de conjuntos vazios (lista de po√ßos <code>freepools list</code> ) cont√©m, respectivamente, todos os conjuntos em um estado vazio.  Mas em que ponto eles s√£o usados? <br><br>  Digamos que seu c√≥digo precise de uma √°rea de mem√≥ria de 8 bytes.  Se n√£o houver conjuntos na lista de conjuntos usados ‚Äã‚Äãcom um tamanho de classe de 8 bytes, um novo conjunto vazio ser√° inicializado como armazenamento de blocos de 8 bytes.  Em seguida, o pool vazio √© adicionado √† lista de pools usados ‚Äã‚Äãe pode ser usado nas seguintes consultas. <br><br>  Um pool completo libera alguns blocos quando essas informa√ß√µes n√£o s√£o mais necess√°rias.  Esse pool ser√° adicionado √† lista usada de acordo com sua classe de tamanho.  Voc√™ pode observar como os conjuntos alteram seus estados e at√© mesmo classificam o tamanho de acordo com o algoritmo. <br><br>  <b>Blocos</b> <br><br><img src="https://habrastorage.org/webt/p4/y1/_v/p4y1_v_kaiwweb9eut_gl3boybg.png"><br><br>  Como pode ser visto na figura, os conjuntos cont√™m ponteiros para liberar blocos de mem√≥ria.  H√° uma ligeira nuance em seu trabalho.  De acordo com os coment√°rios no c√≥digo fonte, o distribuidor "se esfor√ßa para nunca tocar em nenhuma √°rea de mem√≥ria em nenhum dos n√≠veis (arena, piscina, bloco) at√© que seja necess√°rio". <br><br>  Isso significa que um bloco pode ter tr√™s estados.  Eles podem ser definidos da seguinte maneira: <br><br><ul><li>  <b>Intocado</b> : √°reas da mem√≥ria que n√£o foram alocadas; </li><li>  <b>Livre</b> : √°reas de mem√≥ria que foram alocadas, mas posteriormente liberadas pelo CPython porque n√£o continham informa√ß√µes relevantes; </li><li>  <b>Distribu√≠do</b> : √°reas de mem√≥ria que atualmente cont√™m informa√ß√µes atuais. </li></ul><br>  O ponteiro de bloco livre √© uma lista vinculada √∫nica de blocos de mem√≥ria livre.  Em outras palavras, esta √© uma lista de locais gratuitos onde voc√™ pode escrever informa√ß√µes.  Se for necess√°ria mais mem√≥ria do que em blocos livres, o alocador usar√° os blocos intocados no pool. <br><br>  Assim que o gerenciador de mem√≥ria libera blocos, esses blocos s√£o adicionados ao topo da lista de blocos livres.  A lista real pode n√£o conter uma sequ√™ncia cont√≠nua de blocos de mem√≥ria, como na primeira figura "bem-sucedida". <br><br><img src="https://habrastorage.org/webt/cj/7g/d-/cj7gd-xeci1k_d0qwexo8zarr5y.png"><br><br>  <b>Arenas</b> <br><br>  Arenas cont√™m piscinas.  As arenas, diferentemente dos pools, n√£o possuem divis√µes de estado expl√≠citas. <br><br>  Eles mesmos s√£o organizados em uma lista duplamente vinculada, chamada lista de arenas utiliz√°veis ‚Äã‚Äã(usable_arenas).  Essa lista √© classificada pelo n√∫mero de pools gratuitos.  Quanto menos piscinas gratuitas, mais perto a arena do topo da lista. <br><br><img src="https://habrastorage.org/webt/4e/1f/fl/4e1ffl6eisaila8c1zxsmh3fc_m.png"><br><br>  Isso significa que a arena mais completa ser√° selecionada para gravar ainda mais dados.  Mas por que exatamente?  Por que n√£o gravar dados para onde est√° o espa√ßo mais livre? <br><br>  Isso nos leva √† id√©ia de liberar completamente a mem√≥ria.  O fato √© que, em alguns casos, quando a mem√≥ria √© liberada, ela permanece inacess√≠vel ao sistema operacional.  O processo Python o mant√©m distribu√≠do e o usa posteriormente para novos dados.  A desaloca√ß√£o de mem√≥ria cheia retorna a mem√≥ria para o sistema operacional. <br><br>  As arenas n√£o s√£o as √∫nicas √°reas que podem ser completamente desocupadas.  Assim, entendemos que as arenas que est√£o na lista ‚Äúmais perto do vazio‚Äù devem ser liberadas.  Nesse caso, a √°rea de mem√≥ria pode realmente ser completamente liberada e, portanto, a capacidade total de mem√≥ria do seu programa Python √© reduzida. <br><br>  <b>Conclus√£o</b> <br><br>  O gerenciamento de mem√≥ria √© uma das partes mais importantes no trabalho com um computador.  De uma forma ou de outra, o Python realiza praticamente todas as suas opera√ß√µes no modo furtivo. <br><br>  Neste artigo voc√™ aprendeu: <br><br><ul><li>  O que √© gerenciamento de mem√≥ria e por que √© importante; </li><li>  O que √© o CPython, uma implementa√ß√£o b√°sica do Python; </li><li>  Como as estruturas e algoritmos de dados funcionam no gerenciamento de mem√≥ria do CPython e armazenam seus dados. </li></ul><br>  O Python abstrai as muitas nuances de trabalhar com um computador.  Isso torna poss√≠vel trabalhar em um n√≠vel superior e se livrar da dor de cabe√ßa no t√≥pico de onde e como os bytes do seu programa s√£o armazenados. <br><br>  Ent√£o aprendemos sobre gerenciamento de mem√≥ria em Python.  Tradicionalmente, aguardamos seus coment√°rios e tamb√©m convidamos voc√™ para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dia aberto</a> no curso Python Developer, que ocorrer√° em 13 de mar√ßo </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443312/">https://habr.com/ru/post/pt443312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443302/index.html">Como a Apple se prepara para uma era ap√≥s o iPhone</a></li>
<li><a href="../pt443304/index.html">Ser tecnof√≥bico √© in√∫til, mesmo que a tecnofobia seja justificada</a></li>
<li><a href="../pt443306/index.html">Oito leis de nomenclatura no design de UX (parte 1)</a></li>
<li><a href="../pt443308/index.html">Mitos da f√≠sica moderna. Leis de conserva√ß√£o</a></li>
<li><a href="../pt443310/index.html">Revis√£o do gadget de bem-estar feminino Bellabeat</a></li>
<li><a href="../pt443314/index.html">O que √© cordentidade? [Tradu√ß√£o do artigo]</a></li>
<li><a href="../pt443318/index.html">Escrevendo um carregador wasm para Ghidra. Parte 1: Declara√ß√£o do Problema e Configura√ß√£o do Ambiente</a></li>
<li><a href="../pt443320/index.html">Sistema de gerenciamento eletr√¥nico de documentos "Vizier"</a></li>
<li><a href="../pt443322/index.html">GitLab 11.8 lan√ßado com SAST para JavaScript, p√°ginas GitLab para subgrupos e rastreamento de erros</a></li>
<li><a href="../pt443324/index.html">Python vs. Scala para Apache Spark - benchmark esperado com resultado inesperado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>