<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎓 👞 🏳️ 使用PVS-Studio静态分析器分析Apache Dubbo框架的RPC源代码 🧀 ⚙️ 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apache Dubbo是GitHub上最受欢迎的Java项目之一。 这并不奇怪。 它创建于8年前，被广泛用作高性能RPC环境。 当然，他的代码中的大多数错误早已得到修复，并且代码的质量始终保持较高水平。 但是，没有理由拒绝使用PVS-Studio静态代码分析器检查这种有趣的项目。 让我们看看我们设...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio静态分析器分析Apache Dubbo框架的RPC源代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465431/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/27c/6fa/0f927c6fa660b245e4b2d6de304356d5.png" alt="图片2"></div><br>  Apache Dubbo是GitHub上最受欢迎的Java项目之一。 这并不奇怪。 它创建于8年前，被广泛用作高性能RPC环境。 当然，他的代码中的大多数错误早已得到修复，并且代码的质量始终保持较高水平。 但是，没有理由拒绝使用PVS-Studio静态代码分析器检查这种有趣的项目。 让我们看看我们设法找到了什么。 <br><a name="habracut"></a><br><h2> 关于PVS-Studio </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>静态代码分析器在IT市场中已经存在了10多年，它是一种多功能且易于实施的软件解决方案。 目前，分析仪支持C，C ++，C＃，Java语言，并且可以在Windows，Linux和macOS平台上运行。 <br><br>  PVS-Studio是一种付费的B2B解决方案，已被各公司的众多团队使用。 如果要评估分析仪的功能，请下载分发套件并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>索取试用密钥。 <br><br> 如果有开源项目，或者您是学生，也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择</a>免费使用PVS-Studio。 <br><br><h2>  Apache Dubbo：它是什么，它吃什么？ </h2><br> 当前，几乎所有大型软件系统都是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分布式的</a> 。 如果在分布式系统中，远程组件之间的交互连接具有较短的响应时间和相对少量的已传输数据，则这是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RPC</a> （远程过程调用）环境的充分理由。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Dubbo</a>是一种高性能的，基于Java的开源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RPC</a> （远程过程调用）环境。 与许多RPC系统一样，dubbo基于创建服务的想法，该服务用于定义可以使用其参数和返回类型远程调用的方法。 在服务器端，实现了一个接口，并启动了dubbo服务器来处理客户端呼叫。 客户端上有一个存根，提供与服务器相同的方法。  Dubbo提供了三个关键功能，包括前端远程呼叫，容错和负载平衡，以及服务的自动注册和发现。 <br><br><h2> 关于分析 </h2><br> 分析步骤的顺序非常简单，不需要很多时间： <br><br><ul><li> 用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>获得Apache Dubbo; </li><li> 我按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>启动了Java分析器并开始了分析。 </li><li> 我收到了分析器报告，对其进行了分析并重点介绍了一些有趣的案例。 </li></ul><br> 分析结果：针对4000多个文件发出了73个置信度为高和中（分别为46和27）的警告，这很好地表明了代码的质量。 <br><br> 并非所有警告都是错误。 这是正常情况，在定期使用分析仪之前，需要对其进行配置。 然后，我们可以预期误报率会非常低（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如</a> ）。 <br><br> 在警告中，未考虑每个测试文件9个警告（7个高和2个中）。 <br><br> 结果，仍然保留了少量警告，但由于我未配置分析仪，因此其中也存在误报。 在一篇文章中对73条警告进行排序是一项漫长，愚蠢而乏味的任务，因此选择了最有趣的警告。 <br><br><h2>  Java中的已签名字节 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'endKey [i] &lt;0xff'始终为true。  OptionUtil.java（32） <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br> 将<i>字节</i>类型的值（从-128到127的值）与值0xff（255）比较。 在这种情况下，不会考虑Java中<i>字节</i>类型是有效的，因此将始终满足该条件，这意味着这没有任何意义。 <br><br><h2> 返回相同的值 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式“ isPreferIPV6Address（）”始终为false。  NetUtils.java（236） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Optional&lt;InetAddress&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toValidAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InetAddress address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Inet6Address) { Inet6Address v6Address = (Inet6Address) address; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPreferIPV6Address()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return Optional.ofNullable(normalizeV6Address(v6Address)); } } if (isValidV4Address(address)) { return Optional.of(address); } return Optional.empty(); }</span></span></code> </pre> <br>  <i>IsPreferIPV6Address</i>方法。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPreferIPV6Address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> preferIpv6 = Boolean.getBoolean(<span class="hljs-string"><span class="hljs-string">"java.net.preferIPv6Addresses"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preferIpv6) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } return false; // &lt;= }</span></span></code> </pre> <br>  <i>isPreferIPV6Address</i>方法在两种情况下均返回<i>false</i> ，很可能其中一种情况应按程序员的预期返回<i>true</i> ，否则该方法就没有意义。 <br><br><h2> 毫无意义的检查 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'！掩码[i] .equals（ipAddress [i]）'始终为true。  NetUtils.java（476） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchIpRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> UnknownHostException </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mask.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"*"</span></span>.equals(mask[i]) || mask[i].equals(ipAddress[i])) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[i].contains(<span class="hljs-string"><span class="hljs-string">"-"</span></span>)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mask[i].equals(ipAddress[i])) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } } return true; }</span></span></code> </pre> <br> 在第一个if-else-if条件中，将执行<i>“ *”</i>检查<i>。等于（掩码[i]）||。</i>  <i>mask [i] .equals（ipAddress [i]）</i> 。如果不满足此条件，则代码继续进行if-else-if的下一个检查，并且我们知道<i>mask [i]</i>和<i>ipAddress [i]</i>不相等。 但是在if-else-if中进行以下检查之一只是检查<i>掩码[i]</i>和<i>ipAddress [i]是否</i>等效。 由于在方法代码<i>中</i>未为<i>mask [i]</i>和<i>ipAddress [i]</i>分配任何值，因此第二次检查没有意义。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'message.length&gt; 0'始终为true。 不建议使用的TelnetCodec.java（302） <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'message！= Null'始终为true。 不建议使用的TelnetCodec.java（302） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(.... , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] message)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || message.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NEED_MORE_INPUT; } .... <span class="hljs-comment"><span class="hljs-comment">//   message  ! .... if (....) { String value = history.get(index); if (value != null) { byte[] b1 = value.getBytes(); if (message != null &amp;&amp; message.length &gt; 0) { // &lt;= byte[] b2 = new byte[b1.length + message.length]; System.arraycopy(b1, 0, b2, 0, b1.length); System.arraycopy(message, 0, b2, b1.length, message.length); message = b2; } else { message = b1; } } } .... }</span></span></code> </pre> <br> 在第302行检查<i>message！= Null &amp;&amp; message.length&gt; 0</i>没有意义。 在检查之前，第302行检查： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || message.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NEED_MORE_INPUT; }</code> </pre> <br> 如果不满足验证条件，则我们将知道<i>消息</i>不为<i>空</i>并且<i>消息</i>的长度也不为0。从该信息可以看出，消息的长度大于零（因为字符串的<i>长度</i>不能为负数）。 在第302行之前的本地变量<i>消息</i>未分配任何值，这意味着在第302行中使用了<i>消息</i>变量的值，如上面的代码所示。 从所有这些我们可以得出结论，表达式<i>message！= Null &amp;&amp; message.length&gt; 0</i>将始终为<i>true</i> ，这意味着<i>else</i>块中的代码将永远不会执行。 <br><br><h2> 设置未初始化参考字段的值 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'！ShouldExport（）'始终为false。  ServiceConfig.java（371） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkAndUpdateSubConfigs(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shouldExport()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return; } if (shouldDelay()) { .... } else { doExport(); }</span></span></code> </pre> <br>  <i>ServiceConfig</i>类的<i>shouldExport</i>方法调用在同一类中定义的<i>getExport</i>方法。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldExport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Boolean export = getExport(); <span class="hljs-comment"><span class="hljs-comment">// default value is true return export == null ? true : export; } .... @Override public Boolean getExport() { return (export == null &amp;&amp; provider != null) ? provider.getExport() : export; }</span></span></code> </pre> <br>  <i>getExport</i>方法调用<i>AbstractServiceConfig</i>抽象类的<i>getExport</i>方法，该类返回<i>Boolean</i>类型的<i>export</i>字段的<i>值</i> 。 还有一个用于设置字段值的<i>setExport</i>方法。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Boolean export; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getExport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> export; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setExport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Boolean export)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.export = export; }</code> </pre> <br> 代码中的<i>导出</i>字段仅通过<i>setExport</i>方法设置。 仅当Export字段不为null时，才在AbstractServiceBuilder抽象类的<i>构建</i>方法（扩展<i>AbstractServiceConfig</i> ）中调用<i>setExport</i>方法。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T instance)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (export != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { instance.setExport(export); } .... }</code> </pre> <br> 由于默认情况下所有引用字段都初始化为<i>null</i> ，并且在代码中的任何位置都没有为<i>导出</i>字段分配任何值，因此<i>将</i>永远不会调用<i>setExport</i>方法。 <br><br> 结果，扩展了<i>AbstractServiceConfig</i>类的<i>ServiceConfig</i>类的<i>getExport</i>方法将始终返回<i>null</i> 。 返回的值在<i>ServiceConfig</i>类的<i>shouldExport</i>方法中使用，因此<i>shouldExport</i>方法<i>将</i>始终返回<i>true</i> 。 由于返回true，因此表达式<i>！ShouldExport（）</i>的值始终为false。 事实证明，在执行代码之前，永远不会从<i>ServiceConfig</i>类的<i>export</i>方法返回任何结果： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shouldDelay()) { DELAY_EXPORT_EXECUTOR.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::doExport, getDelay(), ....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doExport(); }</code> </pre> <br><h2> 非负参数值 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6009</a> “子字符串”功能可以接收“ -1”值，而预期为非负值。 检查参数：2. AbstractEtcdClient.java（169） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createParentIfAbsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String fixedPath)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = fixedPath.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { String parentPath = fixedPath.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (categories.stream().anyMatch(c -&gt; fixedPath.endsWith(c))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!checkExists(parentPath)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doCreatePersistent(parentPath); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (categories.stream().anyMatch(c -&gt; parentPath.endsWith(c))) { String grandfather = parentPath .substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, parentPath.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (!checkExists(grandfather)) { this.doCreatePersistent(grandfather); } } } }</span></span></code> </pre> <br> 第二个参数将<i>lastIndexOf</i>函数的结果传递给<i>子字符串</i>函数，该<i>子字符串</i>函数的第二个参数不应为负数，尽管<i>lastIndexOf</i>如果在字符串中找不到值，则可以返回<i>-1</i> 。 如果<i>子字符串</i>方法的第二个参数小于第一个参数（-1 &lt;0），则将<i>抛出StringIndexOutOfBoundsException</i> 。 要修复该错误，您需要检查<i>lastIndexOf</i>函数返回的结果，如果结果正确（至少不是负数），则将其传递给<i>子字符串</i>函数。 <br><br><h2> 未使用的周期计数器 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6016</a>通过循环内的常量索引可疑地访问“类型”对象的元素。  RpcUtils.java（153） <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class&lt;?&gt;[] getParameterTypes(Invocation invocation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($INVOKE.equals(invocation.getMethodName()) &amp;&amp; invocation.getArguments() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; invocation.getArguments().length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; invocation.getArguments()[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String[]) { String[] types = (String[]) invocation.getArguments()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (types == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class&lt;?&gt;[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } Class&lt;?&gt;[] parameterTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class&lt;?&gt;[types.length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; types.length; i++) { parameterTypes[i] = ReflectUtils.forName(types[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } return parameterTypes; } return invocation.getParameterTypes(); }</span></span></code> </pre> <br>  <i>for</i>循环使用常量索引<i>0</i>来引用<i>类型</i>数组的元素。 也许是要使用变量<i>i</i>作为索引来访问数组的元素，但正如他们所说，它们并没有被忽略。 <br><br><h2> 毫无意义的做 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6019</a>检测<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不到</a>代码。 可能存在错误。  GrizzlyCodecAdapter.java（136） <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> NextAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FilterChainContext context)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { savedReadIndex = frame.readerIndex(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { msg = codec.decode(channel, frame); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { previousData = ChannelBuffers.EMPTY_BUFFER; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(e.getMessage(), e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) { frame.readerIndex(savedReadIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.getStopAction(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedReadIndex == frame.readerIndex()) { previousData = ChannelBuffers.EMPTY_BUFFER; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Decode without read data."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { context.setMessage(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.getInvokeAction(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.getInvokeAction(); } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frame.readable()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br> 循环条件中的表达式为<i>-while（frame.read（））</i>是无法访问的代码，因为循环的第一次迭代始终退出该方法。 在循环的主体中，使用if-else执行<i>msg</i>变量的多次检查，并且<i>if</i>和in <i>else</i>总是返回该方法的值或引发异常。 因此，循环主体仅执行一次，因此，使用do-while循环是没有意义的。 <br><br><h2> 复制粘贴到开关 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6067</a>两个或更多案件分支执行相同的操作。  JVMUtil.java（67），JVMUtil.java（71） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getThreadDumpString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadInfo threadInfo)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; threadInfo.getLockInfo() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Thread.State ts = threadInfo.getThreadState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ts) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BLOCKED: sb.append(<span class="hljs-string"><span class="hljs-string">"\t- blocked on "</span></span> + threadInfo.getLockInfo()); sb.append(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WAITING: <span class="hljs-comment"><span class="hljs-comment">// &lt;= sb.append("\t- waiting on " + threadInfo.getLockInfo()); // &lt;= sb.append('\n'); // &lt;= break; // &lt;= case TIMED_WAITING: // &lt;= sb.append("\t- waiting on " + threadInfo.getLockInfo()); // &lt;= sb.append('\n'); // &lt;= break; // &lt;= default: } } .... }</span></span></code> </pre> <br>  <i>WAITING</i>和<i>TIMED_WAITING</i>的<i>开关</i>代码包含复制粘贴代码。 如果确实需要执行相同的操作，则可以通过删除<i>WAITING</i>的<i>case</i>块中的内容来简化代码。 结果，将为<i>WAITING</i>和<i>TIMED_WAITING</i>执行记录在单个副本中的相同代码。 <br><br><h2> 结论 </h2><br> 任何对在Java中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RPC</a>感兴趣的人都可能听说过Apache Dubbo。 这是一个受欢迎的开源项目，具有悠久的历史和许多开发人员编写的代码。 该项目的代码质量极佳，但是PVS-Studio静态分析仪设法找到了许多错误。 由此可以得出结论，无论代码多么完美，静态分析在开发大中型项目时都非常重要。 <br><br> 注意事项 这样的一次性检查演示了静态代码分析器的功能，但是使用它是完全错误的方式。 这个想法在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>都有更详细的介绍。 定期使用分析！ <br><br> 感谢Apache Dubbo开发人员提供了如此出色的工具。 我希望本文可以帮助您改进代码。 本文没有介绍所有可疑的代码部分，因此，开发人员最好自己检查项目并评估结果。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Valery Komarov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过PVS-Studio静态代码分析器分析Apache Dubbo RPC框架</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465431/">https://habr.com/ru/post/zh-CN465431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465419/index.html">ITMO大学的明天：国外的教育过程，竞赛和教育-即将举行的活动</a></li>
<li><a href="../zh-CN465423/index.html">智能制造和工业4.0：三大技术趋势</a></li>
<li><a href="../zh-CN465425/index.html">Vepp-ISPsystem的新服务器和网站控制面板</a></li>
<li><a href="../zh-CN465427/index.html">通过PVS-Studio静态代码分析器分析Apache Dubbo RPC框架</a></li>
<li><a href="../zh-CN465429/index.html">但是C是一种底层语言</a></li>
<li><a href="../zh-CN465433/index.html">工作机器人-快乐的人</a></li>
<li><a href="../zh-CN465435/index.html">哪种发行版更适合您的嵌入式系统使用？</a></li>
<li><a href="../zh-CN465437/index.html">为什么我拒绝在AWS中工作</a></li>
<li><a href="../zh-CN465441/index.html">LuaVela：基于LuaJIT 2.0的Lua 5.1实现</a></li>
<li><a href="../zh-CN465445/index.html">物联网提供商的说明。 冲动出口诅咒</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>