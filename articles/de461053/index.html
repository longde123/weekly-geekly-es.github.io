<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 🙅🏾 ☎️ Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten 👩🏾‍💼 👩🏼‍⚕️ 🎛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir schreiben eine Serveranwendung, die PNG-Rasterkacheln basierend auf Online-Vektorkarten generiert. Verwenden Sie Web Scraping mit Puppeteer, um Ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Wir schreiben eine Serveranwendung, die PNG-Rasterkacheln basierend auf Online-Vektorkarten generiert.  Verwenden Sie Web Scraping mit Puppeteer, um Kartendaten abzurufen. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Inhalt: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-Rasterkarten</a> <br>  2 - Fortsetzung.  Schreiben eines einfachen Rasters für Vektorkarten <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Sonderfall.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir verbinden die OverpassTurbo-Karte</a> </p><br><h3 id="prodolzhenie">  Fortsetzung </h3><br><p>  Und so kamen wir zum interessantesten Thema.  Stellen Sie sich vor, wir haben eine Site mit einer Karte gefunden, die wir unserem Navigator wirklich hinzufügen möchten.  Wir machen alles in Übereinstimmung mit den Anweisungen aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil</a> .  Wir öffnen die Anzeige der Inhalte der Website und es gibt keine Bilder!  Absolut.  Nun, ein paar Symbole und das wars.  Und eine andere Textdatei mit einer Liste von Koordinaten. </p><br><p>  Herzlichen Glückwunsch, wir haben eine Vektorkarte gefunden.  Grob gesagt wird es von Ihrem Browser in Echtzeit gerendert.  Sie braucht also überhaupt keine vorbereiteten Fliesen.  Einerseits gibt es bisher nicht so viele Vektorkarten.  Diese Technologie ist jedoch sehr vielversprechend und kann im Laufe der Zeit um ein Vielfaches erweitert werden.  Nun, wir haben es herausgefunden.  Und doch, was machen wir jetzt? </p><br><p>  Zunächst können Sie versuchen, einen Browser einer sehr, sehr alten Version herunterzuladen.  Eine, die die zum Rendern der Karte erforderlichen Funktionen nicht unterstützt.  Möglicherweise wird Ihnen eine andere Version der Site angezeigt.  Mit Rasterkarte.  Nun, was Sie damit machen müssen, wissen Sie bereits. </p><br><p>  Wenn dieser Trick jedoch nicht funktioniert hat, Sie diese Karte aber dennoch wirklich erhalten möchten und darüber hinaus nicht im Browser des Smartphones, nämlich in Ihrem Navigator, gibt es einen Weg. </p><br><h3 id="osnovnaya-ideya">  Hauptidee </h3><br><p>  Wir gehen davon aus, dass wir eine Karte erhalten möchten, die in jedem der Navigatoren geöffnet werden kann.  Dann brauchen wir einen Adapter - eine Art Vermittler, der für uns Kacheln im PNG-Format generiert. </p><br><p>  Es stellt sich heraus, dass Sie brauchen <del>  ein Fahrrad erfinden </del>  Entwicklung einer weiteren Engine zur Visualisierung von Vektordaten.  Nun, oder Sie können ein Skript schreiben, das zur Site geht und es seine eigene Vektorkarte selbst zeichnen lässt.  Und dann wartet er auf den Download, macht einen Screenshot, schneidet ihn ab und kehrt zum Benutzer zurück.  Vielleicht werde ich die zweite Option wählen. </p><br><p>  Um Screenshots zu machen, verwende ich einen "Fernbedienungsbrowser" - Headless Chrome.  Sie können es mit dem Knoten js library <strong>Puppeteer</strong> steuern.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> erfahren Sie mehr über die Grundlagen der Arbeit mit dieser Bibliothek. </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Hallo Welt!  Oder erstellen und passen Sie ein Projekt an </h3><br><p>  Wenn Sie Node.js noch nicht installiert haben, gehen Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieser</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieser</a> Seite, wählen Sie Ihr Betriebssystem aus und schließen Sie die Installation gemäß den Anweisungen ab. </p><br><p>  Erstellen Sie einen neuen Ordner für das Projekt und öffnen Sie ihn im Terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Wir beginnen mit dem Manager für die Erstellung eines neuen Projekts </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Hier können Sie den Namen des Projekts ( <strong>Paketname</strong> ), den Namen der Datei für die Eingabe der Anwendung ( <strong>Einstiegspunkt</strong> ) und den Namen des Autors ( <strong>Autors</strong> ) angeben.  Für alle anderen Anfragen stimmen wir den Standardparametern zu: Wir geben nichts ein und drücken einfach die <strong>Eingabetaste</strong> .  Am Ende drücken Sie <strong>y</strong> und die <strong>Eingabetaste</strong> . </p><br><p>  Installieren Sie als Nächstes die erforderlichen Frameworks für die Arbeit.  Express zum Erstellen eines Servers und Puppenspieler zum Arbeiten mit einem Browser. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Infolgedessen wird die Projektkonfigurationsdatei <strong>package.json</strong> im <strong>Projektordner</strong> angezeigt.  In meinem Fall ist dies: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Ich werde die Startzeile zum Abschnitt "Skripte" hinzufügen, um unsere Anwendung bequemer zu starten. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Erstellen Sie nun zwei Dateien mit der Implementierung der Grundfunktionalität.  Die erste Datei ist der Einstiegspunkt in die Anwendung.  In meinem Fall <strong>router.js</strong> .  Er wird einen Server erstellen und das Routing durchführen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Erstellen Sie nun eine zweite Datei.  Er wird den Browser steuern und Screenshots machen.  Ich habe es <strong>mapshoter.js genannt</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Führen Sie unser Skript aus und überprüfen Sie die Leistung.  Geben Sie dazu die Konsole ein: </p><br><p> <code>$ npm start</code> </p> <br><p>  Es wird eine Meldung angezeigt, die besagt, dass der Server auf Port 5000 erstellt wurde.  Öffnen Sie nun einen Browser auf Ihrem Computer und rufen Sie die lokale Adresse unseres Servers auf.  Anstelle der <strong>x-, y- und z-</strong> Koordinaten <strong>können</strong> Sie beliebige Zahlen eingeben.  Ich habe 1, 2, 3 eingegeben. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Wenn alles richtig gemacht wurde, wird ein Screenshot der Google-Website angezeigt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="Bild"></p><br><p>  Drücken Sie Strg + C in der Konsole, um unser Skript zu stoppen. </p><br><p>  Herzlichen Glückwunsch, die Basis unserer Bewerbung ist fertig!  Wir haben einen Server erstellt, der unsere HTML-Anfragen akzeptiert, einen Screenshot macht und ein Bild an uns zurückgibt.  Jetzt ist es Zeit, mit der Implementierung der Details fortzufahren. </p><br><h3 id="rasschitaem-koordinaty">  Berechnen Sie die Koordinaten </h3><br><p>  Die Idee ist, dass der Browser eine Site mit einer Karte öffnet und die Koordinaten des gewünschten Ortes in die Suchleiste eingibt.  Nachdem Sie auf die Schaltfläche "Suchen" geklickt haben, befindet sich dieser Ort genau in der Mitte des Bildschirms.  So wird es einfach sein, den Bereich auszuschneiden, den wir brauchen. </p><br><p>  Aber zuerst müssen Sie die Koordinaten der Mitte der Kachel anhand ihrer Seriennummer berechnen.  Ich werde dies basierend auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Formel</a> zum Finden der oberen linken Ecke tun.  Ich habe es in die Funktion <strong>getCoordinates () eingefügt</strong> . </p><br><p>  Und da für einige Websites neben der Mitte der Kachel auch die Ränder angegeben werden müssen, werde ich auch nach ihnen suchen.  Nun, erstellen wir ein separates Modul für diese Berechnungen unter dem Namen <strong>geoTools.js</strong> .  Hier ist sein Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Jetzt können wir mit der Implementierung des Skripts für die Arbeit mit dem Browser beginnen.  Schauen wir uns einige Szenarien an, wie dies getan werden kann. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Szenario 1 - API-Suche </h3><br><p>  Beginnen wir mit dem einfachsten Fall, in dem Sie einfach die Koordinaten in die URL der Kartenseite eingeben können.  Zum Beispiel so: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Schauen wir uns das Skript an.  Ersetzen Sie einfach, löschen Sie den gesamten Inhalt der Datei <strong>mapshoter.js</strong> und fügen Sie den folgenden Code ein. </p><br><p>  In dieser Version geben wir beim Starten des Browsers zusätzliche Parameter an, mit denen er auf Linux-Servern wie Heroku gestartet und ausgeführt werden kann.  Auch jetzt werden wir die Größe des Fensters reduzieren, damit so wenig Kartenkacheln wie möglich auf den Bildschirm passen.  Dadurch erhöhen wir die Ladegeschwindigkeit der Seite. </p><br><p>  Als nächstes berechnen wir die Koordinaten der Mitte der gewünschten Kachel.  Wir fügen sie in die URL ein und klicken darauf.  Die Kachel wird genau in der Mitte des Bildschirms angezeigt.  Schneiden Sie ein Stück mit 256 x 256 Pixel.  Dies wird die Kachel sein, die wir brauchen.  Es bleibt nur, um es an den Benutzer zurückzugeben. </p><br><p>  Bevor ich zum Code übergehe, stelle ich fest, dass aus Gründen der Übersichtlichkeit alle Fehlerbehandlungen aus dem Skript entfernt wurden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Führen Sie nun unser Skript aus und sehen Sie sich die Karte für diesen Abschnitt an. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Wenn alles richtig gemacht wurde, sollte der Server eine solche Kachel zurückgeben: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Vergleichen Sie unsere Kachel mit dem Original von OpenStreetMaps.org, um sicherzustellen, dass wir beim Zuschneiden nichts verwechseln </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Szenario 2 - Suche über die Site-Oberfläche </h3><br><p>  Es ist jedoch nicht immer möglich, eine Karte über eine Browserzeile zu steuern.  In solchen Fällen verhält sich unser Skript wie ein lebender Benutzer.  Er druckt die Koordinaten in das Suchfeld und klickt auf die Schaltfläche Suchen.  Danach entfernt er die Markierung des gefundenen Punktes, die normalerweise in der Mitte des Bildschirms angezeigt wird.  Und dann klickt er auf die Schaltflächen, um die Skala zu vergrößern oder zu verkleinern, bis er die gewünschte erreicht hat.  Dann wird ein Screenshot erstellt und an den Benutzer zurückgegeben. </p><br><p>  Ich stelle fest, dass normalerweise nach der Suche derselbe Maßstab eingestellt wird.  15. zum Beispiel.  In unserem Beispiel ist dies nicht immer der Fall.  Daher erkennen wir die Zoomstufe an den Parametern der HTML-Elemente auf der Seite. </p><br><p>  Auch in diesem Beispiel werden wir mithilfe von XPath-Selektoren nach Schnittstellenelementen suchen.  Aber wie erkennt man sie? </p><br><p>  Öffnen Sie dazu die gewünschte Seite im Browser und öffnen Sie die Entwickler-Symbolleiste ( <strong>Ctll + Alt + I</strong> für Google Chrome).  Drücken Sie die Taste, um Elemente auszuwählen.  Wir klicken auf das Element, das Sie interessiert (ich habe auf das Suchfeld geklickt). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  Die Liste der Elemente scrollt zu der Liste, auf die Sie geklickt haben, und wird blau hervorgehoben.  Klicken Sie auf die Schaltfläche mit drei Punkten links neben dem Namen. </p><br><p>  Wählen Sie im Popup-Menü die Option Kopieren.  Wenn Sie als Nächstes eine reguläre Auswahl benötigen, klicken Sie auf <strong>Auswahl kopieren</strong> .  Für dasselbe Beispiel verwenden wir jedoch das Element <strong>XPath kopieren</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Ersetzen Sie nun den Inhalt der Datei <strong>mapshoter.js</strong> durch diesen Code.  Darin habe ich bereits Selektoren für alle notwendigen Schnittstellenelemente gesammelt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Führen Sie unser Skript aus und folgen Sie dem Link.  Wenn alles richtig gemacht wurde, wird das Skript uns so etwas wie diese Kachel zurückgeben. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimierung </h3><br><p>  Im Prinzip reichen die beiden oben beschriebenen Methoden aus, um mit Vektorkarten eine Verbindung zu vielen Standorten herzustellen.  Wenn Sie jedoch plötzlich Zugriff auf eine neue Karte benötigen, müssen Sie das Skript in der Datei mapshoter.js nur geringfügig ändern.  Das heißt, diese Methode macht es sehr einfach, neue Karten hinzuzufügen.  Dies liegt an seinen Vorteilen. </p><br><p>  Es gibt aber auch Nachteile.  Und das wichtigste ist die Arbeitsgeschwindigkeit.  Einfach vergleichen.  Im Durchschnitt dauert das Herunterladen einer normalen Rasterkachel etwa 0,5 Sekunden.  Der Empfang einer Kachel aus unserem Skript dauert derzeit ca. 8 Sekunden. </p><br><p>  Aber das ist noch nicht alles!  Wir verwenden Single-Threaded-Knoten js und unsere langen Anforderungen blockieren schließlich den Haupt-Thread, der von außen wie eine reguläre synchrone Warteschlange aussieht.  Wenn wir versuchen, die Karte für den gesamten Bildschirm herunterzuladen (auf dem beispielsweise 24 Kacheln platziert sind), besteht die Gefahr, dass ein Problem auftritt. </p><br><p>  Und noch etwas.  Einige Navigatoren haben eine Zeitüberschreitung: Sie werden nach 30 Sekunden nicht mehr geladen.  Dies bedeutet, dass mit der aktuellen Implementierung nur 3-4 Kacheln Zeit zum Laden haben.  Mal sehen, was wir dagegen tun können. </p><br><p>  Der wahrscheinlich naheliegendste Weg ist, einfach die Anzahl der Server zu erhöhen, auf denen unser Skript ausgeführt wird.  Wenn wir beispielsweise 10 Server haben, haben diese Zeit, die Kacheln für den gesamten Bildschirm in 30 Sekunden zu verarbeiten.  (Wenn Sie nicht viel Geld bezahlen möchten, können Sie es erhalten, indem Sie mehrere kostenlose Konten bei Heroku registrieren.) </p><br><p>  Zweitens ist es weiterhin möglich, Multithreading auf Knoten js mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_Threads-</a> Moduls zu implementieren.  Nach meinen Beobachtungen kann ich auf einem Server mit einem Single-Core-Prozessor auf einem kostenlosen Heroku-Konto drei Threads starten.  Drei Streams mit jeweils einem separaten Browser, die gleichzeitig arbeiten können, ohne sich gegenseitig zu blockieren.  Fairerweise stelle ich fest, dass sich die Download-Geschwindigkeit einer Kachel aufgrund der erhöhten Belastung des Prozessors sogar geringfügig erhöht hat.  Wenn Sie jedoch versuchen, eine Karte für den gesamten Bildschirm herunterzuladen, hat nach 30 Sekunden mehr als die Hälfte der Karte Zeit zum Laden.  Mehr als 12 Fliesen.  Schon besser. </p><br><p>  Drittens.  In der aktuellen Implementierung des Skripts verbringen wir bei jeder Anforderung Zeit damit, den Chrome-Browser herunterzuladen und dann abzuschließen.  Jetzt werden wir im Voraus einen Browser erstellen und einen Link in mapshoter.js darauf übertragen.  Infolgedessen ändert sich die Geschwindigkeit bei der ersten Anforderung nicht.  Bei allen nachfolgenden Downloads wird die Geschwindigkeit einer Kachel jedoch auf 4 Sekunden reduziert.  Und nach 30 Sekunden hat die gesamte Karte Zeit zum Laden - alle 24 Kacheln, die auf meinem Bildschirm platziert sind. </p><br><p>  Wenn Sie dies alles implementieren, kann das Skript durchaus brauchbar werden.  Also fangen wir an.  Für eine einfachere Arbeit mit Multithreading verwende ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Node-Worker-Threads-Pool-</a> Modul - eine Art Wrapper über worker_threads.  Lassen Sie es uns installieren. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Korrigieren Sie die Datei router.js.  Fügen Sie dazu die Erstellung eines Thread-Pools hinzu.  Die Fäden werden 3 Stück sein.  Ihr Code wird in der Datei <strong>worker.js beschrieben</strong> , wir werden ihn später betrachten.  Löschen Sie in der Zwischenzeit den Start des Screenshot-Moduls direkt.  Stattdessen fügen wir dem Thread-Pool eine neue Aufgabe hinzu.  Sie beginnen mit der Verarbeitung, wenn einer der Threads freigegeben wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Schauen Sie sich <strong>jetzt die</strong> Datei <strong>worker.js an</strong> .  Jedes Mal, wenn eine neue Aufgabe <strong>eintrifft, wird die</strong> Methode <strong>parentPort.on ()</strong> gestartet.  Leider kann es keine asynchronen / wartenden Funktionen verarbeiten.  Daher werden wir die <strong>Adapterfunktion</strong> in Form der Methode <strong>doMyAsyncCode ()</strong> verwenden. </p><br><p>  In einem bequemen lesbaren Format werden wir die Logik des Arbeiters einfügen.  Starten Sie also den Browser (falls er noch nicht ausgeführt wird) und aktivieren Sie die Methode zum Erstellen eines Screenshots.  Beim Start übergeben wir in diese Methode einen Link zum laufenden Browser. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  <strong>Kehren</strong> wir zur Klarheit zur ersten Version von <strong>mapshoter.js zurück</strong> .  Es wird sich nicht viel ändern.  In den Eingabeparametern wird nun ein Link zum Browser akzeptiert, und wenn das Skript endet, wird der Browser nicht ausgeschaltet, sondern einfach die erstellte Registerkarte geschlossen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Im Prinzip ist das alles.  Jetzt können Sie das Ergebnis auf eine für Sie bequeme Weise auf den Server hochladen.  Zum Beispiel über Docker.  Wenn Sie sich das fertige Ergebnis ansehen möchten, können Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diesen Link</a> klicken.  Den vollständigen Projektcode finden Sie auch auf meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Lassen Sie uns nun das Ergebnis bewerten.  Einerseits ist die Download-Geschwindigkeit trotz aller Tricks immer noch sehr niedrig.  Darüber hinaus ist eine solche Karte aufgrund der Bremsen einfach unangenehm zu scrollen. </p><br><p>  Andererseits bewältigt dieses Skript dennoch Karten, bei denen es zuvor im Allgemeinen unmöglich war, eine Verbindung zum Navigator auf dem Smartphone herzustellen.  Es ist unwahrscheinlich, dass diese Lösung jemals als Hauptmethode zum Abrufen kartografischer Daten angewendet wird.  Aber hier als zusätzliche, mit deren Hilfe es bei Bedarf möglich sein wird, eine exotische Karte zu öffnen - es ist durchaus möglich. </p><br><p>  Zu den Vorteilen dieses Skripts gehört auch die Tatsache, dass es einfach ist, damit zu arbeiten.  Es ist leicht zu schreiben.  Und vor allem kann es extrem einfach wiederholt werden, eine andere Online-Karte anzuschließen. </p><br><p>  Nun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im nächsten Artikel werde</a> ich mich genau damit befassen.  Ich werde das Skript in eine Art API für die Arbeit mit der interaktiven OverpassTurbo-Karte umwandeln. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461053/">https://habr.com/ru/post/de461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr über FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Behörden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
<li><a href="../de461051/index.html">Top 10 der häufigsten Fehler, auf die ich in Go-Projekten gestoßen bin</a></li>
<li><a href="../de461055/index.html">Rekko Challenge 2019: wie es war</a></li>
<li><a href="../de461057/index.html">Telegrammkanäle zur Spieleentwicklung</a></li>
<li><a href="../de461059/index.html">Schreiben einer Android-App für Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
<li><a href="../de461063/index.html">Interaktion von R mit Datenbanken am Beispiel von Microsoft SQL Server und anderen DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>