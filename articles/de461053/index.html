<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ö üôÖüèæ ‚òéÔ∏è Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten üë©üèæ‚Äçüíº üë©üèº‚Äç‚öïÔ∏è üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir schreiben eine Serveranwendung, die PNG-Rasterkacheln basierend auf Online-Vektorkarten generiert. Verwenden Sie Web Scraping mit Puppeteer, um Ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Wir schreiben eine Serveranwendung, die PNG-Rasterkacheln basierend auf Online-Vektorkarten generiert.  Verwenden Sie Web Scraping mit Puppeteer, um Kartendaten abzurufen. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Inhalt: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-Rasterkarten</a> <br>  2 - Fortsetzung.  Schreiben eines einfachen Rasters f√ºr Vektorkarten <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Sonderfall.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir verbinden die OverpassTurbo-Karte</a> </p><br><h3 id="prodolzhenie">  Fortsetzung </h3><br><p>  Und so kamen wir zum interessantesten Thema.  Stellen Sie sich vor, wir haben eine Site mit einer Karte gefunden, die wir unserem Navigator wirklich hinzuf√ºgen m√∂chten.  Wir machen alles in √úbereinstimmung mit den Anweisungen aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil</a> .  Wir √∂ffnen die Anzeige der Inhalte der Website und es gibt keine Bilder!  Absolut.  Nun, ein paar Symbole und das wars.  Und eine andere Textdatei mit einer Liste von Koordinaten. </p><br><p>  Herzlichen Gl√ºckwunsch, wir haben eine Vektorkarte gefunden.  Grob gesagt wird es von Ihrem Browser in Echtzeit gerendert.  Sie braucht also √ºberhaupt keine vorbereiteten Fliesen.  Einerseits gibt es bisher nicht so viele Vektorkarten.  Diese Technologie ist jedoch sehr vielversprechend und kann im Laufe der Zeit um ein Vielfaches erweitert werden.  Nun, wir haben es herausgefunden.  Und doch, was machen wir jetzt? </p><br><p>  Zun√§chst k√∂nnen Sie versuchen, einen Browser einer sehr, sehr alten Version herunterzuladen.  Eine, die die zum Rendern der Karte erforderlichen Funktionen nicht unterst√ºtzt.  M√∂glicherweise wird Ihnen eine andere Version der Site angezeigt.  Mit Rasterkarte.  Nun, was Sie damit machen m√ºssen, wissen Sie bereits. </p><br><p>  Wenn dieser Trick jedoch nicht funktioniert hat, Sie diese Karte aber dennoch wirklich erhalten m√∂chten und dar√ºber hinaus nicht im Browser des Smartphones, n√§mlich in Ihrem Navigator, gibt es einen Weg. </p><br><h3 id="osnovnaya-ideya">  Hauptidee </h3><br><p>  Wir gehen davon aus, dass wir eine Karte erhalten m√∂chten, die in jedem der Navigatoren ge√∂ffnet werden kann.  Dann brauchen wir einen Adapter - eine Art Vermittler, der f√ºr uns Kacheln im PNG-Format generiert. </p><br><p>  Es stellt sich heraus, dass Sie brauchen <del>  ein Fahrrad erfinden </del>  Entwicklung einer weiteren Engine zur Visualisierung von Vektordaten.  Nun, oder Sie k√∂nnen ein Skript schreiben, das zur Site geht und es seine eigene Vektorkarte selbst zeichnen l√§sst.  Und dann wartet er auf den Download, macht einen Screenshot, schneidet ihn ab und kehrt zum Benutzer zur√ºck.  Vielleicht werde ich die zweite Option w√§hlen. </p><br><p>  Um Screenshots zu machen, verwende ich einen "Fernbedienungsbrowser" - Headless Chrome.  Sie k√∂nnen es mit dem Knoten js library <strong>Puppeteer</strong> steuern.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> erfahren Sie mehr √ºber die Grundlagen der Arbeit mit dieser Bibliothek. </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Hallo Welt!  Oder erstellen und passen Sie ein Projekt an </h3><br><p>  Wenn Sie Node.js noch nicht installiert haben, gehen Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieser</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieser</a> Seite, w√§hlen Sie Ihr Betriebssystem aus und schlie√üen Sie die Installation gem√§√ü den Anweisungen ab. </p><br><p>  Erstellen Sie einen neuen Ordner f√ºr das Projekt und √∂ffnen Sie ihn im Terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Wir beginnen mit dem Manager f√ºr die Erstellung eines neuen Projekts </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Hier k√∂nnen Sie den Namen des Projekts ( <strong>Paketname</strong> ), den Namen der Datei f√ºr die Eingabe der Anwendung ( <strong>Einstiegspunkt</strong> ) und den Namen des Autors ( <strong>Autors</strong> ) angeben.  F√ºr alle anderen Anfragen stimmen wir den Standardparametern zu: Wir geben nichts ein und dr√ºcken einfach die <strong>Eingabetaste</strong> .  Am Ende dr√ºcken Sie <strong>y</strong> und die <strong>Eingabetaste</strong> . </p><br><p>  Installieren Sie als N√§chstes die erforderlichen Frameworks f√ºr die Arbeit.  Express zum Erstellen eines Servers und Puppenspieler zum Arbeiten mit einem Browser. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Infolgedessen wird die Projektkonfigurationsdatei <strong>package.json</strong> im <strong>Projektordner</strong> angezeigt.  In meinem Fall ist dies: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Ich werde die Startzeile zum Abschnitt "Skripte" hinzuf√ºgen, um unsere Anwendung bequemer zu starten. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Erstellen Sie nun zwei Dateien mit der Implementierung der Grundfunktionalit√§t.  Die erste Datei ist der Einstiegspunkt in die Anwendung.  In meinem Fall <strong>router.js</strong> .  Er wird einen Server erstellen und das Routing durchf√ºhren. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Erstellen Sie nun eine zweite Datei.  Er wird den Browser steuern und Screenshots machen.  Ich habe es <strong>mapshoter.js genannt</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  F√ºhren Sie unser Skript aus und √ºberpr√ºfen Sie die Leistung.  Geben Sie dazu die Konsole ein: </p><br><p> <code>$ npm start</code> </p> <br><p>  Es wird eine Meldung angezeigt, die besagt, dass der Server auf Port 5000 erstellt wurde.  √ñffnen Sie nun einen Browser auf Ihrem Computer und rufen Sie die lokale Adresse unseres Servers auf.  Anstelle der <strong>x-, y- und z-</strong> Koordinaten <strong>k√∂nnen</strong> Sie beliebige Zahlen eingeben.  Ich habe 1, 2, 3 eingegeben. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Wenn alles richtig gemacht wurde, wird ein Screenshot der Google-Website angezeigt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="Bild"></p><br><p>  Dr√ºcken Sie Strg + C in der Konsole, um unser Skript zu stoppen. </p><br><p>  Herzlichen Gl√ºckwunsch, die Basis unserer Bewerbung ist fertig!  Wir haben einen Server erstellt, der unsere HTML-Anfragen akzeptiert, einen Screenshot macht und ein Bild an uns zur√ºckgibt.  Jetzt ist es Zeit, mit der Implementierung der Details fortzufahren. </p><br><h3 id="rasschitaem-koordinaty">  Berechnen Sie die Koordinaten </h3><br><p>  Die Idee ist, dass der Browser eine Site mit einer Karte √∂ffnet und die Koordinaten des gew√ºnschten Ortes in die Suchleiste eingibt.  Nachdem Sie auf die Schaltfl√§che "Suchen" geklickt haben, befindet sich dieser Ort genau in der Mitte des Bildschirms.  So wird es einfach sein, den Bereich auszuschneiden, den wir brauchen. </p><br><p>  Aber zuerst m√ºssen Sie die Koordinaten der Mitte der Kachel anhand ihrer Seriennummer berechnen.  Ich werde dies basierend auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Formel</a> zum Finden der oberen linken Ecke tun.  Ich habe es in die Funktion <strong>getCoordinates () eingef√ºgt</strong> . </p><br><p>  Und da f√ºr einige Websites neben der Mitte der Kachel auch die R√§nder angegeben werden m√ºssen, werde ich auch nach ihnen suchen.  Nun, erstellen wir ein separates Modul f√ºr diese Berechnungen unter dem Namen <strong>geoTools.js</strong> .  Hier ist sein Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir mit der Implementierung des Skripts f√ºr die Arbeit mit dem Browser beginnen.  Schauen wir uns einige Szenarien an, wie dies getan werden kann. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Szenario 1 - API-Suche </h3><br><p>  Beginnen wir mit dem einfachsten Fall, in dem Sie einfach die Koordinaten in die URL der Kartenseite eingeben k√∂nnen.  Zum Beispiel so: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Schauen wir uns das Skript an.  Ersetzen Sie einfach, l√∂schen Sie den gesamten Inhalt der Datei <strong>mapshoter.js</strong> und f√ºgen Sie den folgenden Code ein. </p><br><p>  In dieser Version geben wir beim Starten des Browsers zus√§tzliche Parameter an, mit denen er auf Linux-Servern wie Heroku gestartet und ausgef√ºhrt werden kann.  Auch jetzt werden wir die Gr√∂√üe des Fensters reduzieren, damit so wenig Kartenkacheln wie m√∂glich auf den Bildschirm passen.  Dadurch erh√∂hen wir die Ladegeschwindigkeit der Seite. </p><br><p>  Als n√§chstes berechnen wir die Koordinaten der Mitte der gew√ºnschten Kachel.  Wir f√ºgen sie in die URL ein und klicken darauf.  Die Kachel wird genau in der Mitte des Bildschirms angezeigt.  Schneiden Sie ein St√ºck mit 256 x 256 Pixel.  Dies wird die Kachel sein, die wir brauchen.  Es bleibt nur, um es an den Benutzer zur√ºckzugeben. </p><br><p>  Bevor ich zum Code √ºbergehe, stelle ich fest, dass aus Gr√ºnden der √úbersichtlichkeit alle Fehlerbehandlungen aus dem Skript entfernt wurden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  F√ºhren Sie nun unser Skript aus und sehen Sie sich die Karte f√ºr diesen Abschnitt an. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Wenn alles richtig gemacht wurde, sollte der Server eine solche Kachel zur√ºckgeben: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Vergleichen Sie unsere Kachel mit dem Original von OpenStreetMaps.org, um sicherzustellen, dass wir beim Zuschneiden nichts verwechseln </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Szenario 2 - Suche √ºber die Site-Oberfl√§che </h3><br><p>  Es ist jedoch nicht immer m√∂glich, eine Karte √ºber eine Browserzeile zu steuern.  In solchen F√§llen verh√§lt sich unser Skript wie ein lebender Benutzer.  Er druckt die Koordinaten in das Suchfeld und klickt auf die Schaltfl√§che Suchen.  Danach entfernt er die Markierung des gefundenen Punktes, die normalerweise in der Mitte des Bildschirms angezeigt wird.  Und dann klickt er auf die Schaltfl√§chen, um die Skala zu vergr√∂√üern oder zu verkleinern, bis er die gew√ºnschte erreicht hat.  Dann wird ein Screenshot erstellt und an den Benutzer zur√ºckgegeben. </p><br><p>  Ich stelle fest, dass normalerweise nach der Suche derselbe Ma√üstab eingestellt wird.  15. zum Beispiel.  In unserem Beispiel ist dies nicht immer der Fall.  Daher erkennen wir die Zoomstufe an den Parametern der HTML-Elemente auf der Seite. </p><br><p>  Auch in diesem Beispiel werden wir mithilfe von XPath-Selektoren nach Schnittstellenelementen suchen.  Aber wie erkennt man sie? </p><br><p>  √ñffnen Sie dazu die gew√ºnschte Seite im Browser und √∂ffnen Sie die Entwickler-Symbolleiste ( <strong>Ctll + Alt + I</strong> f√ºr Google Chrome).  Dr√ºcken Sie die Taste, um Elemente auszuw√§hlen.  Wir klicken auf das Element, das Sie interessiert (ich habe auf das Suchfeld geklickt). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  Die Liste der Elemente scrollt zu der Liste, auf die Sie geklickt haben, und wird blau hervorgehoben.  Klicken Sie auf die Schaltfl√§che mit drei Punkten links neben dem Namen. </p><br><p>  W√§hlen Sie im Popup-Men√º die Option Kopieren.  Wenn Sie als N√§chstes eine regul√§re Auswahl ben√∂tigen, klicken Sie auf <strong>Auswahl kopieren</strong> .  F√ºr dasselbe Beispiel verwenden wir jedoch das Element <strong>XPath kopieren</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Ersetzen Sie nun den Inhalt der Datei <strong>mapshoter.js</strong> durch diesen Code.  Darin habe ich bereits Selektoren f√ºr alle notwendigen Schnittstellenelemente gesammelt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  F√ºhren Sie unser Skript aus und folgen Sie dem Link.  Wenn alles richtig gemacht wurde, wird das Skript uns so etwas wie diese Kachel zur√ºckgeben. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimierung </h3><br><p>  Im Prinzip reichen die beiden oben beschriebenen Methoden aus, um mit Vektorkarten eine Verbindung zu vielen Standorten herzustellen.  Wenn Sie jedoch pl√∂tzlich Zugriff auf eine neue Karte ben√∂tigen, m√ºssen Sie das Skript in der Datei mapshoter.js nur geringf√ºgig √§ndern.  Das hei√üt, diese Methode macht es sehr einfach, neue Karten hinzuzuf√ºgen.  Dies liegt an seinen Vorteilen. </p><br><p>  Es gibt aber auch Nachteile.  Und das wichtigste ist die Arbeitsgeschwindigkeit.  Einfach vergleichen.  Im Durchschnitt dauert das Herunterladen einer normalen Rasterkachel etwa 0,5 Sekunden.  Der Empfang einer Kachel aus unserem Skript dauert derzeit ca. 8 Sekunden. </p><br><p>  Aber das ist noch nicht alles!  Wir verwenden Single-Threaded-Knoten js und unsere langen Anforderungen blockieren schlie√ülich den Haupt-Thread, der von au√üen wie eine regul√§re synchrone Warteschlange aussieht.  Wenn wir versuchen, die Karte f√ºr den gesamten Bildschirm herunterzuladen (auf dem beispielsweise 24 Kacheln platziert sind), besteht die Gefahr, dass ein Problem auftritt. </p><br><p>  Und noch etwas.  Einige Navigatoren haben eine Zeit√ºberschreitung: Sie werden nach 30 Sekunden nicht mehr geladen.  Dies bedeutet, dass mit der aktuellen Implementierung nur 3-4 Kacheln Zeit zum Laden haben.  Mal sehen, was wir dagegen tun k√∂nnen. </p><br><p>  Der wahrscheinlich naheliegendste Weg ist, einfach die Anzahl der Server zu erh√∂hen, auf denen unser Skript ausgef√ºhrt wird.  Wenn wir beispielsweise 10 Server haben, haben diese Zeit, die Kacheln f√ºr den gesamten Bildschirm in 30 Sekunden zu verarbeiten.  (Wenn Sie nicht viel Geld bezahlen m√∂chten, k√∂nnen Sie es erhalten, indem Sie mehrere kostenlose Konten bei Heroku registrieren.) </p><br><p>  Zweitens ist es weiterhin m√∂glich, Multithreading auf Knoten js mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_Threads-</a> Moduls zu implementieren.  Nach meinen Beobachtungen kann ich auf einem Server mit einem Single-Core-Prozessor auf einem kostenlosen Heroku-Konto drei Threads starten.  Drei Streams mit jeweils einem separaten Browser, die gleichzeitig arbeiten k√∂nnen, ohne sich gegenseitig zu blockieren.  Fairerweise stelle ich fest, dass sich die Download-Geschwindigkeit einer Kachel aufgrund der erh√∂hten Belastung des Prozessors sogar geringf√ºgig erh√∂ht hat.  Wenn Sie jedoch versuchen, eine Karte f√ºr den gesamten Bildschirm herunterzuladen, hat nach 30 Sekunden mehr als die H√§lfte der Karte Zeit zum Laden.  Mehr als 12 Fliesen.  Schon besser. </p><br><p>  Drittens.  In der aktuellen Implementierung des Skripts verbringen wir bei jeder Anforderung Zeit damit, den Chrome-Browser herunterzuladen und dann abzuschlie√üen.  Jetzt werden wir im Voraus einen Browser erstellen und einen Link in mapshoter.js darauf √ºbertragen.  Infolgedessen √§ndert sich die Geschwindigkeit bei der ersten Anforderung nicht.  Bei allen nachfolgenden Downloads wird die Geschwindigkeit einer Kachel jedoch auf 4 Sekunden reduziert.  Und nach 30 Sekunden hat die gesamte Karte Zeit zum Laden - alle 24 Kacheln, die auf meinem Bildschirm platziert sind. </p><br><p>  Wenn Sie dies alles implementieren, kann das Skript durchaus brauchbar werden.  Also fangen wir an.  F√ºr eine einfachere Arbeit mit Multithreading verwende ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Node-Worker-Threads-Pool-</a> Modul - eine Art Wrapper √ºber worker_threads.  Lassen Sie es uns installieren. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Korrigieren Sie die Datei router.js.  F√ºgen Sie dazu die Erstellung eines Thread-Pools hinzu.  Die F√§den werden 3 St√ºck sein.  Ihr Code wird in der Datei <strong>worker.js beschrieben</strong> , wir werden ihn sp√§ter betrachten.  L√∂schen Sie in der Zwischenzeit den Start des Screenshot-Moduls direkt.  Stattdessen f√ºgen wir dem Thread-Pool eine neue Aufgabe hinzu.  Sie beginnen mit der Verarbeitung, wenn einer der Threads freigegeben wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Schauen Sie sich <strong>jetzt die</strong> Datei <strong>worker.js an</strong> .  Jedes Mal, wenn eine neue Aufgabe <strong>eintrifft, wird die</strong> Methode <strong>parentPort.on ()</strong> gestartet.  Leider kann es keine asynchronen / wartenden Funktionen verarbeiten.  Daher werden wir die <strong>Adapterfunktion</strong> in Form der Methode <strong>doMyAsyncCode ()</strong> verwenden. </p><br><p>  In einem bequemen lesbaren Format werden wir die Logik des Arbeiters einf√ºgen.  Starten Sie also den Browser (falls er noch nicht ausgef√ºhrt wird) und aktivieren Sie die Methode zum Erstellen eines Screenshots.  Beim Start √ºbergeben wir in diese Methode einen Link zum laufenden Browser. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  <strong>Kehren</strong> wir zur Klarheit zur ersten Version von <strong>mapshoter.js zur√ºck</strong> .  Es wird sich nicht viel √§ndern.  In den Eingabeparametern wird nun ein Link zum Browser akzeptiert, und wenn das Skript endet, wird der Browser nicht ausgeschaltet, sondern einfach die erstellte Registerkarte geschlossen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Im Prinzip ist das alles.  Jetzt k√∂nnen Sie das Ergebnis auf eine f√ºr Sie bequeme Weise auf den Server hochladen.  Zum Beispiel √ºber Docker.  Wenn Sie sich das fertige Ergebnis ansehen m√∂chten, k√∂nnen Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diesen Link</a> klicken.  Den vollst√§ndigen Projektcode finden Sie auch auf meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Lassen Sie uns nun das Ergebnis bewerten.  Einerseits ist die Download-Geschwindigkeit trotz aller Tricks immer noch sehr niedrig.  Dar√ºber hinaus ist eine solche Karte aufgrund der Bremsen einfach unangenehm zu scrollen. </p><br><p>  Andererseits bew√§ltigt dieses Skript dennoch Karten, bei denen es zuvor im Allgemeinen unm√∂glich war, eine Verbindung zum Navigator auf dem Smartphone herzustellen.  Es ist unwahrscheinlich, dass diese L√∂sung jemals als Hauptmethode zum Abrufen kartografischer Daten angewendet wird.  Aber hier als zus√§tzliche, mit deren Hilfe es bei Bedarf m√∂glich sein wird, eine exotische Karte zu √∂ffnen - es ist durchaus m√∂glich. </p><br><p>  Zu den Vorteilen dieses Skripts geh√∂rt auch die Tatsache, dass es einfach ist, damit zu arbeiten.  Es ist leicht zu schreiben.  Und vor allem kann es extrem einfach wiederholt werden, eine andere Online-Karte anzuschlie√üen. </p><br><p>  Nun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im n√§chsten Artikel werde</a> ich mich genau damit befassen.  Ich werde das Skript in eine Art API f√ºr die Arbeit mit der interaktiven OverpassTurbo-Karte umwandeln. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461053/">https://habr.com/ru/post/de461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr √ºber FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Beh√∂rden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
<li><a href="../de461051/index.html">Top 10 der h√§ufigsten Fehler, auf die ich in Go-Projekten gesto√üen bin</a></li>
<li><a href="../de461055/index.html">Rekko Challenge 2019: wie es war</a></li>
<li><a href="../de461057/index.html">Telegrammkan√§le zur Spieleentwicklung</a></li>
<li><a href="../de461059/index.html">Schreiben einer Android-App f√ºr Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
<li><a href="../de461063/index.html">Interaktion von R mit Datenbanken am Beispiel von Microsoft SQL Server und anderen DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>