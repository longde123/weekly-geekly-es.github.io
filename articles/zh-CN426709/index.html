<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎋 ▶️ 🎤 JavaScript计时器：所有您需要知道的 👩🏻‍🎓 ❇️ 👼🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 曾几何时，约翰·雷齐格（John Rezig）撰写了有关哈布雷（Habré） 的文章 。 十年过去了，这个话题仍然需要澄清。 因此，我们为那些有兴趣阅读Samer Buna的文章的人，该文章不仅提供了JavaScript中的计时器的理论概述（在Node.js的上下文中），而且还提供了有关它们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript计时器：所有您需要知道的</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426709/"> 大家好 曾几何时，约翰·雷齐格（John Rezig）撰写了有关哈布雷（Habré） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a> 。 十年过去了，这个话题仍然需要澄清。 因此，我们为那些有兴趣阅读Samer Buna的文章的人，该文章不仅提供了JavaScript中的计时器的理论概述（在Node.js的上下文中），而且还提供了有关它们的任务。 <br><br><img src="https://habrastorage.org/webt/zs/0c/vx/zs0cvxfhr8yi-cnds0y27thmg0u.png"><br><a name="habracut"></a><br><br> 几周前，我在一次采访中发布了以下问题： <br><br><blockquote>  “ setTimeout和setInterval函数的源代码在哪里？ 你要去哪里找他 您无法在Google上搜索它：)“ <br></blockquote><br>  ***自己回答，然后继续阅读*** <br><br><hr><br> 对此推文的回复中约有一半是不正确的。 不，这种情况与V8（或其他VM）无关！ 诸如<code>setTimeout</code>和<code>setInterval</code>类的功能（自豪地称为JavaScript JavaScript Timers）不属于任何ECMAScript规范或JavaScript引擎实现。 计时器功能是在浏览器级别实现的，因此它们的实现在不同的浏览器中会有所不同。 计时器也是在Node.js运行时本身中本地实现的。 <br><br> 在浏览器中，主要计时器功能是指<code>Window</code>界面，该界面也与其他一些功能和对象相关联。 该接口在JavaScript的主要范围内提供对其所有元素的全局访问。 这就是为什么可以在浏览器控制台中直接执行<code>setTimeout</code>函数的原因。 <br><br> 在Node中，计时器是<code>global</code>对象的一部分，该对象的设计类似于<code>Window</code>的浏览器界面。  <a href="">这里</a>显示了Node中计时器的源代码。 <br><br> 在某人看来，这只是面试中的一个坏问题-知道这一点有什么好处？ 作为JavaScript开发人员，我这样想：假定您应该了解这一点，因为相反的情况可能表明您不太了解V8（和其他虚拟机）如何与浏览器和Node交互。 <br><br> 让我们看一些示例并解决几个计时器任务，我们来吗？ <br><br>  <i>您可以使用node命令来运行本文中的示例。</i>  <i>我在Pluralsight <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上的Node.js入门</a>课程中介绍了此处讨论的大多数示例。</i> <br><br>  <b>延迟执行功能</b> <br><br> 计时器是高阶函数，您可以使用它们延迟或重复执行其他功能（计时器接收的功能作为第一个参数）。 <br><br> 这是延迟执行的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example1.js setTimeout( () =&gt; { console.log('Hello after 4 seconds'); }, 4 * 1000 );</span></span></code> </pre> <br> 在此示例中，使用<code>setTimeout</code>将问候消息延迟4秒。  <code>setTimeout</code>的第二个参数是延迟（以毫秒为单位）。 我将4乘以1000得到4秒。 <br><br>  <code>setTimeout</code>的第一个参数是一个函数，其执行将被延迟。 <br> 如果使用node命令执行<code>example1.js</code>文件，则Node会暂停4秒钟，然后显示一条欢迎消息（后面是退出消息）。 <br><br> 请注意： <code>setTimeout</code>的第一个参数只是一个<b>函数引用</b> 。 它不应是内置函数-例如<code>example1.js</code> 。 这是不使用内置函数的相同示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello after 4 seconds'</span></span>); }; setTimeout(func, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  <b>传递参数</b> <br><br> 如果使用<code>setTimeout</code>延迟的函数接受任何参数，则可以使用<code>setTimeout</code>函数本身的其余参数（在我们已经研究过的2个参数之后）将参数的值传输到延迟函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : func(arg1, arg2, arg3, ...) //  : setTimeout(func, delay, arg1, arg2, arg3, ...)</span></span></code> </pre> <br> 这是一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example2.js const rocks = who =&gt; { console.log(who + ' rocks'); }; setTimeout(rocks, 2 * 1000, 'Node.js');</span></span></code> </pre> <br> 上面的<code>rocks</code>函数延迟了2秒，它使用了<code>who</code>参数，并调用<code>setTimeout</code>将值“ Node.js”传递给了<code>who</code>参数。 <br><br> 当使用<code>node</code>命令执行<code>example2.js</code>时，将在2秒后显示短语“ Node.js rocks”。 <br><br>  <b>计时器任务1</b> <br><br> 因此，基于已经研究过的有关<code>setTimeout</code> ，我们将在相应的延迟之后显示以下2条消息。 <br><br><ul><li>  4秒后将显示消息“ 4秒后您好”。 </li><li>  8秒后将显示消息“ 8秒后您好”。 </li></ul><br>  <i>局限性</i> <br><br> 在您的解决方案中，您只能定义一个包含内置函数的函数。 这意味着许多<code>setTimeout</code>调用将必须使用相同的函数。 <br><br>  <i>解决方案</i> <br><br> 这是我如何解决此问题的方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// solution1.js const theOneFunc = delay =&gt; { console.log('Hello after ' + delay + ' seconds'); }; setTimeout(theOneFunc, 4 * 1000, 4); setTimeout(theOneFunc, 8 * 1000, 8);</span></span></code> </pre> <br> 对我而言， <code>theOneFunc</code>接收<code>delay</code>参数，并在屏幕上显示的消息中使用此<code>delay</code>参数的值。 因此，该函数可以显示不同的消息，具体取决于我们将告知它的延迟值。 <br><br> 然后，我在两个<code>setTimeout</code>调用中使用了<code>theOneFunc</code> ，第一个调用在4秒后触发，第二个在8秒后触发。 这两个<code>setTimeout</code>调用也都接收一个第3个参数，表示<code>theOneFunc</code>的<code>delay</code>参数。 <br><br> 通过使用node命令执行<code>solution1.js</code>文件，我们将显示任务的要求，第一条消息将在4秒后出现，第二条消息将在8秒后出现。 <br><br>  <b>重复功能</b> <br><br> 但是，如果我要您无限期每4秒显示一条消息怎么办？ <br> 当然，您可以<code>setTimeout</code>在一个循环中，但是计时器API还提供了<code>setInterval</code>函数，您可以使用该函数对任何操作的“永恒”执行进行编程。 <br><br> 这是<code>setInterval</code>的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example3.js setInterval( () =&gt; console.log('Hello every 3 seconds'), 3000 );</span></span></code> </pre> <br> 此代码将每3秒显示一条消息。 如果使用<code>node</code>命令执行<code>example3.js</code> ，则Node将输出此命令，直到您强制结束该过程（CTRL + C）。 <br><br>  <b>取消计时器</b> <br><br> 由于在调用计时器函数时分配了一个动作，因此在执行该动作之前也可以将其撤消。 <br><br>  <code>setTimeout</code>调用返回一个计时器ID，您可以在调用<code>clearTimeout</code>取消计时器时使用此计时器ID。 这是一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example4.js const timerId = setTimeout( () =&gt; console.log('You will not see this one!'), 0 ); clearTimeout(timerId);</span></span></code> </pre> <br> 这个简单的计时器应该在0毫秒后（即立即）触发，但这不会发生，因为我们捕获了<code>timerId</code>的值，并通过调用<code>clearTimeout</code>立即取消了此计时器。 <br><br> 使用<code>node</code>命令执行<code>example4.js</code>时，Node将不会输出任何内容-该过程将立即结束。 <br><br> 顺便说一下，Node.js还提供了另一种<code>setTimeout</code>的方式，值为0 ms。  Node.js计时器API中还有另一个名为<code>setImmediate</code> ，它的功能基本上与<code>setTimeout</code>相同，但值为0 ms，但是在这种情况下，您可以省略延迟： <br><br><pre> <code class="javascript hljs">setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am equivalent to setTimeout with 0 ms'</span></span>), );</code> </pre><br>  <code>setImmediate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所有浏览器都支持</a> <code>setImmediate</code>函数。 不要在客户端代码中使用它。 <br><br> 除了<code>clearTimeout</code>还有一个<code>clearInterval</code>函数，它的功能相同，但是有<code>setInerval</code>调用，还有一个<code>clearImmediate</code>调用。 <br><br>  <b>计时器延迟-无法保证</b> <br><br> 您是否注意到在前面的示例中，使用<code>setTimeout</code>在0 ms之后执行操作时，此操作不会立即发生（在<code>setTimeout</code>之后），而是仅在所有脚本代码都已完全执行（包括<code>clearTimeout</code>调用）之后发生吗？ <br><br> 让我用一个例子阐明这一点。 这是一个简单的<code>setTimeout</code>调用，应该在半秒钟内起作用-但这不会发生： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example5.js setTimeout( () =&gt; console.log('Hello after 0.5 seconds. MAYBE!'), 500, ); for (let i = 0; i &lt; 1e10; i++) { //    }</span></span></code> </pre><br> 在此示例中定义了计时器之后，我们立即使用大的<code>for</code>循环同步阻塞了运行时环境。  <code>1e10</code>值为1，带有10个零，因此该周期持续100亿个处理器周期（原则上，这模拟了处理器过载）。 在此循环完成之前，节点无法执行任何操作。 <br><br> 当然，实际上这是非常糟糕的，但是此示例有助于理解<code>setTimeout</code>延迟并不能保证，而是可以保证<b>最小值</b> 。  500 ms的值表示延迟将持续至少500 ms。 实际上，该脚本将需要更长的时间才能在屏幕上显示欢迎行。 首先，他将不得不等待直到阻塞周期完成。 <br><br>  <b>计时器问题2</b> <br><br> 编写一个脚本，该脚本每秒显示一次“ Hello World”消息，但仅显示5次。 经过5次迭代后，脚本应显示“ Done”消息，此后Node进程将完成。 <br><br>  <i>限制</i> ：解决此问题时，不能调用<code>setTimeout</code> 。 <br><br>  <i>提示</i> ：需要柜台。 <br><br>  <i>解决方案</i> <br><br> 这是我如何解决此问题的方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); clearInterval(intervalId); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br> 我将0设置为<code>counter</code>的初始值，然后调用<code>setInterval</code> ，它获取其ID。 <br><br> 延迟功能将显示一条消息，并且每次将计数器增加一。 在deferred函数内部，我们有一个if语句，它将检查是否已经经过5次迭代。  5次迭代后，程序将显示“ Done”，并使用捕获的<code>intervalId</code>常数清除间隔值。 间隔延迟为1000毫秒。 <br><br>  <b>谁确切地称为延迟函数？</b> <br><br> 使用JavaScript时，在常规函数中使用<code>this</code> ，例如： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoCalledMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>this</code>的值将与<b>调用方</b>匹配。 如果在Node REPL内定义上述函数，则<code>global</code>对象将调用它。 如果在浏览器控制台中定义一个函数，则<code>window</code>对象将调用它。 <br><br> 让我们定义一个函数作为对象的属性，以使其更加清晰： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'42'</span></span>, whoCalledMe() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">//     : obj.whoCallMe</span></span></code> </pre> <br> 现在，当我们在使用<code>obj.whoCallMe</code>函数时直接使用指向它的链接时， <code>obj</code>对象（由其<code>id</code> ）将充当调用者： <br><br><img src="https://habrastorage.org/webt/-p/ws/xl/-pwsxloqfbioi6rnk02prkje_wg.png"><br><br> 现在的问题是：如果将<code>obj.whoCallMe</code>的链接传递给<code>obj.whoCallMe</code> ， <code>setTimetout</code> ？ <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ?? setTimeout(obj.whoCalledMe, 0);</span></span></code> </pre> <br>  <b>在这种情况下，呼叫者是谁？</b> <br><br> 答案将根据执行计时器功能的位置而有所不同。 在这种情况下，对呼叫者是谁的依赖是完全不能接受的。 您将失去对调用方的控制，因为这将取决于计时器的实现，在这种情况下，计时器将调用您的函数。 如果您在Node REPL中测试此代码，则<code>Timeout</code>对象将成为调用方： <br><br><img src="https://habrastorage.org/webt/hx/bb/t5/hxbbt5rhcmm4l6e2hns0ph8icho.png"><br><br> 请注意：仅当在常规函数中使用JavaScript <code>this</code>时，这一点才重要。 使用箭头功能时，呼叫者根本不会打扰您。 <br><br>  <b>计时器问题3</b> <br><br> 编写一个脚本，该脚本将以不同的延迟连续输出“ Hello World”消息。 从一秒的延迟开始，然后在每次迭代时将其增加一秒。 在第二次迭代中，延迟将为2秒。 在第三个-三个，依此类推。 <br><br> 在显示的消息中包括延迟。 您应该得到这样的内容： <br><br> <code>Hello World. 1 <br> Hello World. 2 <br> Hello World. 3 <br> ...</code> <br> <br>  <i>限制</i> ：只能使用const定义变量。 不使用let或var。 <br><br>  <i>解决方案</i> <br><br> 由于此任务中延迟的持续时间是一个变量，因此您不能在此处使用<code>setInterval</code> ，但是可以在递归调用中使用<code>setTimeout</code>手动配置间隔执行。 使用<code>setTimeout</code>执行的第一个函数将创建下一个计时器，依此类推。 <br><br> 另外，由于您不能使用<code>let</code> / <code>var</code> ，所以我们没有计数器来增加每个递归调用的延迟。 相反，您可以使用递归函数的参数在递归调用期间执行增量。 <br><br> 解决此问题的方法如下： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span> + delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, delay * <span class="hljs-number"><span class="hljs-number">1000</span></span>); greeting(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  <b>计时器任务4</b> <br><br> 编写一个脚本，该脚本以与任务3中相同的延迟结构显示“ Hello World”消息，但是这次以5条消息为一组，并且该组将有一个主要的延迟间隔。 对于第一组5条消息，我们选择100 ms的初始延迟，接下来的-200 ms，第三次-300 ms，依此类推。 <br><br> 该脚本的工作方式如下： <br><br><ul><li> 在100 ms时，脚本首次显示“ Hello World”，并以100 ms为间隔增加5次。 第一条消息将在100毫秒后出现，第二条消息将在200毫秒后出现，依此类推。 </li><li> 在前5条消息之后，脚本应将主延迟增加200 ms。 因此，第6条消息将在500 ms + 200 ms（700 ms）之后显示，第7条消息-900 ms，第8条消息-在1100 ms之后显示，依此类推。 </li><li>  10条消息后，脚本应将主延迟间隔增加300 ms。 在500 ms + 1000 ms + 300 ms（18000 ms）之后应显示第11条消息。 第12条消息应在2100毫秒后显示，依此类推。 </li></ul><br> 根据此原则，程序应无限期地工作。 <br><br> 在显示的消息中包括延迟。 您应该得到这样的内容（无评论）： <br><br> <code>Hello World. 100 //  100  <br> Hello World. 100 //  200  <br> Hello World. 100 //  300  <br> Hello World. 100 //  400  <br> Hello World. 100 //  500  <br> Hello World. 200 //  700  <br> Hello World. 200 //  900  <br> Hello World. 200 //  1100  <br> ...</code> <br> <br>  <i>限制</i> ：您只能使用对<code>setInterval</code>调用（而不能使用<code>setTimeout</code> ），并且只能使用<code>if</code> 。 <br><br>  <i>解决方案</i> <br><br> 由于我们只能使用<code>setInterval</code>调用，因此在这里我们需要使用递归，还需要增加下一个<code>setInterval</code>调用的延迟。 此外，我们需要<code>if</code>才能仅在对该递归函数进行5次调用后才能使此操作发生。 <br><br> 这是一个可能的解决方案： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastIntervalId, counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { clearInterval(lastIntervalId); lastIntervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span>, delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">100</span></span>); }, delay); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; }; greeting(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br> 感谢所有阅读它的人。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426709/">https://habr.com/ru/post/zh-CN426709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426699/index.html">使用pytest进行Python测试。 简单，快速，高效和可扩展。 前言与引言</a></li>
<li><a href="../zh-CN426701/index.html">Flutter-跨平台开发的新视角</a></li>
<li><a href="../zh-CN426703/index.html">明斯克的DataVizDay有趣的是</a></li>
<li><a href="../zh-CN426705/index.html">Hyperledger Fabric智能合约开发和测试</a></li>
<li><a href="../zh-CN426707/index.html">审批系统。 我们如何发明自行车</a></li>
<li><a href="../zh-CN426713/index.html">英特尔至强W-3175X：家庭用28核</a></li>
<li><a href="../zh-CN426717/index.html">欺骗的错觉：基于逆向预测的视觉光学错觉</a></li>
<li><a href="../zh-CN426719/index.html">SIBUR上的数据科学黑客马拉松：过去的样子</a></li>
<li><a href="../zh-CN426721/index.html">在产品开发过程中避免失败：Rookee的10条建议</a></li>
<li><a href="../zh-CN426723/index.html">微软和合作伙伴希望在月球上创造一个时间胶囊</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>