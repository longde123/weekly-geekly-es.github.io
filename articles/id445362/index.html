<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🌾 🚩 🧑🏿‍🤝‍🧑🏼 Buku "Sistem Terdistribusi. Pola Desain ↩️ 🥂 🙍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dunia modern tidak dapat dibayangkan tanpa menggunakan sistem terdistribusi. Bahkan aplikasi seluler yang paling sederhana pun memiliki API yang terhu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Sistem Terdistribusi. Pola Desain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/445362/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/3r/m1/uj/3rm1ujuwrrda_3m1tyol46kyfh4.jpeg" align="left" alt="gambar"></a>  Dunia modern tidak dapat dibayangkan tanpa menggunakan sistem terdistribusi.  Bahkan aplikasi seluler yang paling sederhana pun memiliki API yang terhubung dengan penyimpanan cloud.  Namun, desain sistem terdistribusi masih merupakan seni, bukan ilmu pasti.  Kebutuhan untuk membawa dasar yang serius di bawahnya sudah lama tertunda, dan jika Anda ingin mendapatkan kepercayaan dalam penciptaan, dukungan dan pengoperasian sistem terdistribusi - mulailah dengan buku ini! <br><br>  Brendan Burns, spesialis terkemuka dalam teknologi cloud dan Kubernetes, menetapkan dalam karya kecil ini minimum absolut yang diperlukan untuk desain sistem terdistribusi yang tepat.  Buku ini menjelaskan pola awet muda dalam merancang sistem terdistribusi.  Ini akan membantu Anda tidak hanya membuat sistem seperti itu dari awal, tetapi juga secara efektif mengubah yang sudah ada. <br><br><a name="habracut"></a><br><h3>  Kutipan.  Pola dekorator.  Ubah permintaan atau tanggapan </h3><br>  FaaS ideal ketika Anda membutuhkan fungsi sederhana yang memproses input data dan kemudian mentransfernya ke layanan lain.  Pola semacam ini dapat digunakan untuk memperluas atau menghias permintaan HTTP yang dikirim atau diterima oleh layanan lain.  Pola ini secara skematis ditunjukkan pada Gambar.  8.1. <br><br>  Omong-omong, dalam bahasa pemrograman ada beberapa analogi dengan pola ini.  Secara khusus, Python memiliki dekorator fungsi yang secara fungsional mirip dengan dekorator permintaan atau respons.  Karena transformasi dekorasi tidak menyimpan keadaan dan sering ditambahkan secara ex-facto ketika layanan berkembang, mereka sangat cocok untuk implementasi sebagai FaaS.  Selain itu, cahaya FaaS berarti Anda dapat bereksperimen dengan dekorator yang berbeda hingga Anda menemukan yang terintegrasi lebih dekat dengan layanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/li/lc/ya/lilcyax3ox52bwtihgtfqb7qm40.png" alt="gambar"></div><br>  Menambahkan nilai default ke parameter input permintaan HTTP RESTful API menunjukkan manfaat dari pola Penghias.  Banyak permintaan API memiliki bidang yang perlu diisi dengan nilai wajar jika tidak ditentukan oleh pemanggil.  Misalnya, Anda ingin bidang menjadi default ke true.  Ini sulit dicapai dengan JSON klasik, karena bidang kosong default adalah nol, yang biasanya ditafsirkan sebagai salah.  Untuk mengatasi masalah ini, Anda dapat menambahkan logika penggantian nilai default baik di depan server API atau dalam kode aplikasi (misalnya, jika (bidang == null) bidang = benar).  Namun, kedua pendekatan ini tidak optimal, karena mekanisme substitusi default secara konseptual independen dari pemrosesan permintaan.  Sebagai gantinya, kita bisa menggunakan pola FaaS Decorator, yang mengubah permintaan di jalan antara pengguna dan implementasi layanan. <br><br>  Mempertimbangkan apa yang dikatakan sebelumnya pada bagian pola single-node, Anda mungkin bertanya-tanya mengapa kami tidak merancang layanan substitusi default dalam bentuk wadah adaptor.  Pendekatan ini masuk akal, tetapi itu juga berarti bahwa penskalaan layanan pencarian standar dan penskalaan layanan API itu sendiri menjadi saling bergantung satu sama lain.  Mengganti nilai default adalah operasi yang mudah secara komputasi, dan untuk itu, kemungkinan besar, Anda tidak akan membutuhkan banyak contoh layanan. <br><br><blockquote> Dalam contoh di bab ini, kita akan menggunakan kerangka FaaS kubeless (https://github.com/kubeless/kubeless).  Kubeless dikerahkan di atas layanan orkestra wadah Kubernetes.  Jika Anda sudah menyiapkan kluster Kubernetes, maka lanjutkan dengan instalasi Kubeless, yang dapat diunduh dari situs yang sesuai (https://github.com/kubeless/kubeless/releases).  Setelah Anda memiliki executable kubeless, Anda dapat menginstalnya di cluster dengan perintah install kubeless. <br><br>  Kubeless diinstal sebagai add-on API pihak ketiga Kubernetes.  Ini berarti bahwa setelah instalasi dapat digunakan sebagai bagian dari alat baris perintah kubectl.  Sebagai contoh, fungsi yang digunakan dalam cluster dapat dilihat dengan menjalankan perintah fungsi kubectl.  Saat ini tidak ada fungsi yang digunakan di cluster Anda. </blockquote><br><h3>  Bengkel  Substitusi nilai default sebelum memproses permintaan </h3><br>  Anda bisa mendemonstrasikan kegunaan pola Dekorator dalam FaaS dengan contoh mengganti nilai default di panggilan RESTful untuk parameter yang nilainya tidak ditetapkan oleh pengguna.  Dengan FaaS, ini cukup sederhana.  Fungsi pencarian standar ditulis dalam Python: <br><br><pre><code class="plaintext hljs">#  -,   #   def handler(context): #    obj = context.json #   "name" ,   #   if obj.get("name", None) is None: obj["name"] = random_name() #    'color',   #   'blue' if obj.get("color", None) is None: obj["color"] = "blue" #  API-     #   #    return call_my_api(obj)</code> </pre> <br>  Simpan fungsi ini ke file yang disebut defaults.py.  Ingatlah untuk mengganti panggilan call_my_api dengan API yang Anda inginkan.  Fungsi substitusi default ini dapat didaftarkan sebagai fungsi kubeless dengan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubeless function deploy add-defaults \ --runtime python27 \ --handler defaults.handler \ --from-file defaults.py \ --trigger-http</code> </pre> <br>  Untuk mengujinya, Anda dapat menggunakan alat kubeless: <br><br><pre> <code class="plaintext hljs">kubeless function call add-defaults --data '{"name": "foo"}'</code> </pre> <br>  Pola Penghias menunjukkan betapa mudahnya untuk beradaptasi dan memperluas API yang ada dengan fitur tambahan seperti memvalidasi atau mengganti nilai default. <br><br><h3>  Penanganan acara </h3><br>  Sebagian besar sistem berorientasi pada permintaan - mereka memproses aliran berkelanjutan permintaan pengguna dan API.  Meskipun demikian, ada beberapa sistem yang berorientasi pada peristiwa.  Perbedaan antara permintaan dan acara, menurut saya, terletak pada konsep sesi.  Permintaan adalah bagian dari proses interaksi yang lebih besar (sesi).  Dalam kasus umum, setiap permintaan pengguna adalah bagian dari proses berinteraksi dengan aplikasi web atau API secara keseluruhan.  Saya melihat acara sebagai lebih “satu kali”, asinkron.  Peristiwa penting dan harus ditangani sebagaimana mestinya, tetapi mereka disingkirkan dari konteks utama interaksi dan jawaban kepada mereka datang hanya setelah beberapa waktu.  Contoh acara adalah berlangganan pengguna ke layanan tertentu, yang akan menyebabkan pengiriman surat ucapan;  mengunggah file ke folder bersama, yang akan menyebabkan pengiriman pemberitahuan ke semua pengguna folder ini;  atau bahkan mempersiapkan komputer untuk reboot, yang akan memberi tahu operator atau sistem otomatis bahwa tindakan yang sesuai diperlukan. <br><br>  Karena acara ini sebagian besar independen dan tidak memiliki keadaan internal, dan frekuensinya sangat bervariasi, mereka ideal untuk bekerja dalam arsitektur FaaS yang berorientasi pada peristiwa.  Mereka sering ditempatkan di sebelah server aplikasi "pertempuran" untuk memberikan kemampuan tambahan atau untuk pemrosesan data di latar belakang sebagai tanggapan terhadap peristiwa yang muncul.  Selain itu, karena jenis baru dari acara yang diproses secara konstan ditambahkan ke layanan, kesederhanaan dari penyebaran fungsi membuatnya cocok untuk mengimplementasikan penangan acara.  Dan karena setiap peristiwa secara konseptual independen dari yang lain, melemahnya paksa hubungan dalam suatu sistem yang dibangun berdasarkan fungsi memungkinkan kita untuk mengurangi kompleksitas konseptualnya, memungkinkan pengembang untuk fokus pada langkah-langkah yang diperlukan untuk memproses hanya satu jenis peristiwa tertentu. <br><br>  Contoh spesifik mengintegrasikan komponen berorientasi peristiwa ke dalam layanan yang ada adalah penerapan otentikasi dua faktor.  Dalam hal ini, acara tersebut akan menjadi login pengguna ke sistem.  Suatu layanan dapat menghasilkan suatu peristiwa untuk tindakan ini dan meneruskannya ke fungsi penangan.  Prosesor, berdasarkan kode yang ditransmisikan dan rincian kontak pengguna, akan mengirimnya kode otentikasi dalam bentuk pesan teks. <br><br><h3>  Bengkel  Menerapkan Otentikasi Dua Faktor </h3><br>  Otentikasi dua faktor menunjukkan bahwa bagi pengguna untuk memasuki sistem, ia memerlukan sesuatu yang ia ketahui (misalnya, kata sandi), dan sesuatu yang ia miliki (misalnya, nomor telepon).  Otentikasi dua faktor jauh lebih baik daripada hanya kata sandi, karena penyerang harus mencuri kata sandi dan nomor telepon Anda untuk mendapatkan akses. <br><br>  Saat merencanakan implementasi otentikasi dua faktor, Anda perlu memproses permintaan untuk membuat kode acak, mendaftarkannya dengan layanan login dan mengirim pesan kepada pengguna.  Anda dapat menambahkan kode yang mengimplementasikan fungsi ini langsung ke layanan login itu sendiri.  Ini menyulitkan sistem, membuatnya lebih monolitik.  Mengirim pesan harus dilakukan bersamaan dengan kode yang menghasilkan halaman web login, yang dapat menyebabkan penundaan tertentu.  Penundaan ini menurunkan kualitas interaksi pengguna dengan sistem. <br><br>  Akan lebih baik untuk membuat layanan FaaS yang akan menghasilkan nomor acak secara tidak sinkron, mendaftarkannya dengan layanan login dan mengirimkannya ke telepon pengguna.  Dengan demikian, server login hanya dapat menjalankan permintaan asinkron ke layanan FaaS, yang secara paralel akan melakukan tugas yang relatif lambat untuk mendaftarkan dan mengirim kode. <br>  Untuk melihat bagaimana ini bekerja, pertimbangkan kode berikut: <br><br><pre> <code class="plaintext hljs">def two_factor(context): #     code = random.randint(1 00000, 9 99999) #        user = context.json["user"] register_code_with_login_service(user, code) #      Twillio account = "my-account-sid" token = "my-token" client = twilio.rest.Client(account, token) user_number = context.json["phoneNumber"] msg = ", {},   : {}.".format(user, code) message = client.api.account.messages.create(to=user_number, from_="+1 20652 51212", body=msg) return {"status": "ok"}</code> </pre> <br>  Kemudian daftarkan FaaS di kubeless: <br><br><pre> <code class="plaintext hljs">kubeless function deploy add-two-factor \ --runtime python27 \ --handler two_factor.two_factor \ --from-file two_factor.py \ --trigger-http</code> </pre> <br>  Sebuah instance dari fungsi ini dapat secara asinkron dihasilkan dari kode JavaScript sisi klien setelah pengguna memasukkan kata sandi yang benar.  Antarmuka web dapat segera menampilkan halaman untuk memasukkan kode, dan pengguna, segera setelah ia menerima kode, dapat memberitahukan kepadanya tentang layanan login di mana kode ini sudah terdaftar. <br><br>  Jadi, pendekatan FaaS telah sangat memfasilitasi pengembangan layanan yang sederhana, asinkron, dan berorientasi peristiwa yang dimulai ketika pengguna masuk ke sistem. <br><br><h3>  Konveyor Acara </h3><br>  Ada sejumlah aplikasi yang, pada kenyataannya, lebih mudah untuk dipertimbangkan sebagai saluran pipa dari peristiwa yang digabungkan secara longgar.  Pipa-pipa acara sering kali menyerupai bagan alur lama yang baik.  Mereka dapat direpresentasikan sebagai grafik diarahkan sinkronisasi acara terkait.  Dalam kerangka pola Pipa Acara, node terkait dengan fungsi, dan busur yang menghubungkannya sesuai dengan permintaan HTTP atau jenis panggilan jaringan lainnya. <br><br>  Di antara elemen-elemen wadah, sebagai suatu peraturan, tidak ada keadaan umum, tetapi mungkin ada konteks umum atau titik referensi lainnya, atas dasar di mana pencarian dalam penyimpanan akan dilakukan. <br><br>  Apa perbedaan antara pipeline dan microservice architecture?  Ada dua perbedaan penting.  Perbedaan pertama dan paling penting antara fungsi layanan dan layanan yang terus berjalan adalah bahwa pipa acara pada dasarnya didorong oleh peristiwa.  Arsitektur microservice, sebaliknya, menyiratkan seperangkat layanan yang terus bekerja.  Selain itu, pipeline acara dapat disinkronkan dan mengikat berbagai acara.  Sulit membayangkan bagaimana persetujuan aplikasi Jira dapat diintegrasikan ke dalam aplikasi layanan mikro.  Pada saat yang sama, mudah untuk membayangkan bagaimana itu terintegrasi ke dalam pipeline acara. <br><br>  Sebagai contoh, pertimbangkan pipa di mana sumber acara adalah pemuatan kode ke dalam sistem kontrol versi.  Peristiwa ini menyebabkan pembangunan kembali kode.  Majelis dapat berlangsung beberapa menit, setelah peristiwa yang dihasilkan yang memicu fungsi pengujian aplikasi yang dirakit.  Bergantung pada keberhasilan perakitan, fungsi pengujian mengambil tindakan yang berbeda.  Jika perakitan berhasil, aplikasi dibuat, yang harus disetujui oleh orang tersebut agar versi baru aplikasi dapat dioperasikan.  Menutup aplikasi berfungsi sebagai sinyal untuk mengaktifkan versi baru.  Jika perakitan gagal, Jira membuat permintaan untuk kesalahan yang terdeteksi dan pipa keluar. <br><br><h3>  Bengkel  Menerapkan saluran pipa untuk mendaftarkan pengguna baru </h3><br>  Pertimbangkan tugas menerapkan urutan tindakan untuk mendaftarkan pengguna baru.  Saat membuat akun baru, serangkaian tindakan selalu dilakukan, misalnya, mengirim email selamat datang.  Ada juga sejumlah tindakan yang tidak dapat dilakukan setiap kali, misalnya, berlangganan newsletter email tentang versi baru suatu produk (juga dikenal sebagai spam). <br><br>  Salah satu pendekatan melibatkan pembuatan layanan monolitik untuk membuat akun baru.  Dengan pendekatan ini, satu tim pengembangan bertanggung jawab untuk seluruh layanan, yang juga digunakan secara keseluruhan.  Ini membuatnya sulit untuk melakukan percobaan dan membuat perubahan pada proses interaksi pengguna dengan aplikasi. <br><br>  Pertimbangkan implementasi login pengguna sebagai saluran acara dari beberapa layanan FaaS.  Dengan pemisahan ini, fungsi pembuatan pengguna tidak tahu apa yang terjadi selama login pengguna.  Dia memiliki dua daftar: <br><br><ul><li>  daftar tindakan yang diperlukan (misalnya, mengirim email selamat datang); </li><li>  daftar tindakan opsional (misalnya, berlangganan buletin). </li></ul><br>  Setiap tindakan ini juga diimplementasikan sebagai FaaS, dan daftar tindakan tidak lebih dari daftar fungsi panggilan balik HTTP.  Oleh karena itu, fungsi pembuatan pengguna memiliki bentuk berikut: <br><br><pre> <code class="plaintext hljs">def create_user(context): #      for key, value in required.items(): call_function(value.webhook, context.json) #    #     for key, value in optional.items(): if context.json.get(key, None) is not None: call_function(value.webhook, context.json)</code> </pre> <br>  Masing-masing penangan sekarang juga dapat diimplementasikan sesuai dengan prinsip FaaS: <br><br><pre> <code class="plaintext hljs">def email_user(context): #    user = context.json['username'] msg = ', {}, ,     !".format(user) send_email(msg, contex.json['email]) def subscribe_user(context): #    email = context.json['email'] subscribe_user(email)</code> </pre> <br>  Didekomposisi dengan cara ini layanan FaaS menjadi lebih sederhana, mengandung lebih sedikit baris kode dan berfokus pada implementasi satu fungsi spesifik.  Pendekatan microservice menyederhanakan penulisan kode, tetapi dapat menyebabkan kesulitan dalam menggunakan dan mengelola tiga layanan microser yang berbeda.  Di sini pendekatan FaaS membuktikan dirinya dengan segala kemuliaan, karena sebagai akibat penggunaannya menjadi sangat mudah untuk mengelola potongan-potongan kode kecil.  Visualisasi proses menciptakan pengguna dalam bentuk pipeline peristiwa juga memungkinkan kita untuk memahami secara umum apa yang sebenarnya terjadi ketika pengguna login, hanya dengan melacak perubahan konteks dari fungsi ke fungsi dalam pipa. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  20% diskon kupon untuk Desainer - <b>Pola desain</b> <br><br>  Setelah pembayaran versi kertas buku, versi elektronik buku dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445362/">https://habr.com/ru/post/id445362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445352/index.html">Aplikasi Streaming Terstruktur Spark di Kubernetes. Pengalaman CEPAT RUS</a></li>
<li><a href="../id445354/index.html">Menemukan objek dalam gambar</a></li>
<li><a href="../id445356/index.html">Tinjauan umum bagian Seluler di DUMP-2019: maksimum diterapkan dan berguna dalam pekerjaan sehari-hari</a></li>
<li><a href="../id445358/index.html">Organisasi sistem acara di Unity - melalui mata seorang desainer game</a></li>
<li><a href="../id445360/index.html">5 tugas khas untuk wawancara JavaScript: penguraian dan solusi</a></li>
<li><a href="../id445366/index.html">Cara mempercepat enkripsi menurut GOST 28147-89 pada prosesor Baikal-T1 karena blok SIMD</a></li>
<li><a href="../id445368/index.html">Muat pengujian game dengan beberapa ratus ribu pengguna virtual</a></li>
<li><a href="../id445370/index.html">Analisis TSDB di Prometheus 2</a></li>
<li><a href="../id445372/index.html">Visi mesin vs intuisi manusia: algoritma untuk mengganggu operasi program pengenalan objek</a></li>
<li><a href="../id445378/index.html">Labirin: klasifikasi, pembangkitan, mencari solusi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>