<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 👼🏾 🙍🏿 Qu'est-ce que GitOps? 😩 🙋🏾 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Après la publication récente de matériel sur les méthodes pull and push dans GitOps, nous avons constaté un intérêt pour ce modèle d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce que GitOps?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/458878/"> <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Après la publication récente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matériel</a> sur les méthodes pull and push dans GitOps, nous avons constaté un intérêt pour ce modèle dans son ensemble, cependant, il y avait très peu de publications en russe sur ce sujet (elles ne sont tout simplement pas sur le hub).</i>  <i>Par conséquent, nous sommes heureux de porter à votre attention une traduction d'un autre article - bien qu'il y ait presque un an!</i>  <i>- de la société Weaveworks, dont le chef a inventé le terme "GitOps".</i>  <i>Le texte explique l'essence de l'approche et les principales différences par rapport aux approches existantes.</i> <br><br><img src="https://habrastorage.org/webt/i0/8b/fc/i08bfcph3kkhapzkitpwhylzdhc.png"><br><br>  Il y a un an, nous avons publié une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction à GitOps</a> .  Ensuite, nous avons expliqué comment l'équipe Weaveworks a lancé le SaaS basé sur Kubernetes et développé un ensemble de meilleures pratiques normatives pour le déploiement, la gestion et la surveillance dans un environnement natif cloud. <a name="habracut"></a><br><br>  L'article s'est avéré être populaire.  D'autres personnes ont commencé à parler de GitOps, ont commencé à publier de nouveaux outils pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">git push</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développement</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">secrets</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration continue</a> , etc.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grand nombre de</a> publications et de cas d'utilisation de GitOps sont apparus sur notre site.  Mais certaines personnes ont encore des questions.  En quoi le modèle diffère-t-il de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">infrastructure</a> traditionnelle en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tant que code</a> et livraison continue?  Est-il obligatoire d'utiliser Kubernetes? <br><br>  Bientôt, nous avons réalisé qu'une nouvelle description était nécessaire, offrant: <br><br><ol><li>  Un grand nombre d'exemples et d'histoires; </li><li>  La définition spécifique de GitOps; </li><li>  Comparaison avec la livraison continue traditionnelle. </li></ol><br>  Dans cet article, nous avons essayé de couvrir tous ces sujets.  Vous y trouverez une introduction mise à jour de GitOps et un regard du côté des développeurs et CI / CD.  Nous nous concentrons principalement sur Kubernetes, bien que le modèle puisse être généralisé. <br><br><h2>  Rencontrez GitOps </h2><br>  Imaginez Alice.  Elle dirige Family Insurance, une entreprise qui propose des polices d'assurance maladie, automobile, immobilier et voyage aux personnes trop occupées pour comprendre par elles-mêmes les nuances de leurs contrats.  Son entreprise a commencé comme un projet parallèle quand Alice a travaillé à la banque en tant que data scientist.  Une fois qu'elle a réalisé qu'elle pouvait utiliser des algorithmes informatiques avancés pour analyser plus efficacement les données et former des packages d'assurance.  Les investisseurs ont financé le projet, et maintenant son entreprise rapporte plus de 20 millions de dollars par an et connaît une croissance rapide.  Actuellement, 180 personnes y occupent différents postes.  Parmi eux, une équipe technologique qui développe, maintient un site, une base de données et analyse la clientèle.  Une équipe de 60 personnes est dirigée par Bob, directeur technique de l'entreprise. <br><br>  L'équipe de Bob déploie des systèmes de production dans le cloud.  Leurs principales applications fonctionnent sur GKE, profitant de Kubernetes sur Google Cloud.  De plus, ils utilisent divers outils pour travailler avec des données et des analyses dans leur travail. <br><br>  L'assurance familiale n'allait pas utiliser de conteneurs, mais était enthousiasmée par Docker.  Bientôt, les experts de l'entreprise ont découvert que GKE facilite et déploie facilement les clusters pour tester de nouvelles fonctionnalités.  Jenkins pour CI et Quay ont été ajoutés pour organiser le registre des conteneurs, des scripts pour Jenkins ont été écrits pour pousser ou créer de nouveaux conteneurs et configurations dans GKE. <br><br>  Un certain temps s'est écoulé.  Alice et Bob ont été déçus par la performance de l'approche choisie et son impact sur l'entreprise.  L'introduction de conteneurs n'a pas augmenté la productivité autant que l'espérait l'équipe.  Parfois, les déploiements se cassaient et il n'était pas clair si les modifications du code étaient à blâmer.  Il s'est également avéré difficile de suivre les changements dans les configurations.  Il était souvent nécessaire de créer un nouveau cluster et d'y déplacer des applications, car c'était le moyen le plus simple d'éliminer le gâchis dans lequel le système se transformait.  Alice craignait que la situation ne s'aggrave au fur et à mesure du développement de l'application (en outre, un nouveau projet basé sur l'apprentissage automatique se préparait).  Bob a automatisé la plupart des travaux et n'a pas compris pourquoi le pipeline est toujours instable, ne s'adapte pas bien et nécessite une intervention manuelle de temps en temps? <br><br>  <b>Ils ont ensuite découvert GitOps.</b>  <b>Cette décision s'est avérée être exactement ce dont ils avaient besoin pour avancer en toute confiance.</b> <br><br>  Alice et Bob ont entendu parler des workflows basés sur Git, DevOps et l'infrastructure comme code pendant des années.  Le caractère unique de GitOps est qu'il apporte un certain nombre de meilleures pratiques - catégoriques et normatives - pour mettre en œuvre ces idées dans le contexte de Kubernetes.  Ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a été soulevé à plusieurs reprises</a> , notamment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le blog Weaveworks</a> . <br><br>  L'assurance familiale décide de mettre en œuvre GitOps.  La société dispose désormais d'un modèle d'exploitation automatisé compatible avec Kubernetes qui allie <i>vitesse</i> et <i>stabilité</i> , car ils: <br><br><ul><li>  a constaté que l'équipe a doublé sa productivité et que personne ne devient fou; </li><li>  arrêté de réparer les scripts.  Au lieu de cela, ils peuvent désormais se concentrer sur de nouvelles fonctionnalités et améliorer les méthodes d'ingénierie - par exemple, introduire des déploiements de canaris et améliorer les tests; </li><li>  processus de déploiement amélioré - maintenant il se casse rarement; </li><li>  obtenu la possibilité de récupérer des déploiements après des échecs partiels sans intervention manuelle; </li><li>  acquis une plus grande confiance dans les systèmes d'approvisionnement.  Alice et Bob ont constaté que l'équipe peut être divisée en groupes qui travaillent en microservices et travaillent en parallèle; </li><li>  peut apporter 30 à 50 changements au projet chaque jour grâce aux efforts de chaque groupe et essayer de nouvelles techniques; </li><li>  ils sont facilement attirés par le projet par de nouveaux développeurs qui ont la possibilité de lancer des mises à jour sur la production en utilisant des requêtes pull en quelques heures; </li><li>  facilement audité dans SOC2 <i>(pour la conformité des fournisseurs de services avec les exigences de gestion sécurisée des données; en savoir plus, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> - traduction approximative)</i> . </li></ul><br><h3>  Qu'est-il arrivé? </h3><br>  Les GitOps sont deux choses: <br><br><ol><li>  Modèle de fonctionnement pour Kubernetes et cloud native.  Il fournit un ensemble de meilleures pratiques pour le déploiement, la gestion et la surveillance des clusters et applications conteneurisés.  Définition élégante dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seule diapositive</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Luis Faceira</a> : <br><br><img src="https://habrastorage.org/webt/or/fl/uu/orfluutk_hcqu6dnclf6pu1ewes.jpeg"></li><li>  Chemin vers la création d'un environnement orienté développeur pour la gestion des applications.  Nous appliquons le workflow Git à l'exploitation et au développement.  Veuillez noter qu'il ne s'agit pas seulement de Git push, mais de l'organisation de l'ensemble des outils CI / CD et UI / UX. </li></ol><br><h3>  Quelques mots sur Git </h3><br>  Si vous n'êtes pas familier avec les systèmes de contrôle de version et le workflow basé sur Git, nous vous recommandons fortement de les étudier.  Au début, travailler avec des branches et des demandes de tirage peut sembler de la magie noire, mais les pros en valent la peine.  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon article</a> pour commencer. <br><br><h2>  Comment fonctionne Kubernetes </h2><br>  Dans notre histoire, Alice et Bob se sont tournés vers GitOps après avoir travaillé avec Kubernetes pendant un certain temps.  En effet, GitOps est étroitement lié à Kubernetes - c'est un modèle opérationnel pour l'infrastructure et les applications basées sur Kubernetes. <br><br><h3>  Que propose Kubernetes aux utilisateurs? </h3><br>  Voici quelques fonctionnalités clés: <br><br><ol><li>  Dans le modèle Kubernetes, tout peut être décrit sous une forme déclarative. </li><li>  Le serveur API Kubernetes accepte une telle déclaration en entrée, puis essaie constamment d'amener le cluster à l'état décrit dans la déclaration. </li><li>  Les déclarations sont suffisantes pour décrire et gérer une grande variété de charges de travail - «applications». </li><li>  Par conséquent, les modifications apportées à l'application et au cluster sont dues à: <br><ul><li>  modifications des images de conteneurs; </li><li>  modifications de la spécification déclarative; </li><li>  des erreurs dans l'environnement - par exemple, un conteneur se bloque. </li></ul></li></ol><br><h3>  Les grandes capacités de convergence de Kubernetes </h3><br>  Lorsqu'un administrateur apporte des modifications de configuration, l'orchestrateur Kubernetes les applique au cluster jusqu'à ce que son état <i>approche de la nouvelle configuration</i> .  Ce modèle fonctionne pour toutes les ressources Kubernetes et s'étend aux définitions de ressources personnalisées (CRD).  Par conséquent, les déploiements Kubernetes ont les merveilleuses propriétés suivantes: <br><br><ul><li>  <b>Automatisation</b> : les mises à jour de Kubernetes fournissent un mécanisme pour automatiser le processus d'application des modifications correctement et en temps opportun. </li><li>  <b>Convergence</b> : Kubernetes continuera de tenter des mises à jour jusqu'à ce qu'il réussisse. </li><li>  <b>Idempotence</b> : des applications répétées de convergence produisent le même résultat. </li><li>  <b>Déterminisme</b> : avec des ressources suffisantes, l'état du cluster mis à jour ne dépend que de l'état souhaité. </li></ul><br><h2>  Comment fonctionne GitOps </h2><br>  Nous en avons assez appris sur Kubernetes pour expliquer le fonctionnement de GitOps. <br><br>  Revenons aux équipes d'assurance familiale liées aux microservices.  Que doivent-ils généralement faire?  Regardez la liste ci-dessous (si certains points semblent étranges ou inconnus - veuillez reporter les critiques et rester avec nous).  Ce ne sont que des exemples de workflows basés sur Jenkins.  Il existe de nombreux autres processus lorsque vous travaillez avec d'autres outils. <br><br>  L'essentiel est que nous voyons que chaque mise à jour se termine par des modifications des fichiers de configuration et des référentiels Git.  Ces modifications dans Git entraînent la mise à jour de la «déclaration GitOps» du cluster: <br><br>  1. Workflow: « <i>Jenkins Build - branche principale</i> ». <br>  La liste des tâches: <br><br><ul><li>  Jenkins envoie des images balisées à Quay; </li><li>  Jenkins push'it config et Helm charts vers le compartiment de stockage principal; </li><li>  La fonction cloud copie la configuration et les graphiques du compartiment de stockage principal dans le référentiel git principal; </li><li>  L'instruction GitOps met à jour le cluster. </li></ul><br>  2. <i>Jenkins build - branche release ou hotfix</i> : <br><br><ul><li>  Jenkins pousse des images non marquées à Quay; </li><li>  Jenkins pousse les graphiques de configuration et de barre dans le compartiment de stockage intermédiaire; </li><li>  La fonction cloud copie la configuration et les graphiques du compartiment du stockage intermédiaire au stockage intermédiaire du référentiel Git; </li><li>  L'instruction GitOps met à jour le cluster. </li></ul><br>  3. <i>Jenkins build - développer ou développer une branche</i> : <br><br><ul><li>  Jenkins pousse des images non marquées à Quay; </li><li>  Jenkins pousse les graphiques de configuration et de barre dans le compartiment de stockage de développement; </li><li>  La fonction cloud copie la configuration et les graphiques du compartiment de stockage de développement vers le référentiel de développement git; </li><li>  L'instruction GitOps met à jour le cluster. </li></ul><br>  4. <i>Ajout d'un nouveau client</i> : <br><br><ul><li>  Un gestionnaire ou un administrateur (LCM / ops) appelle Gradle pour déployer et configurer initialement les équilibreurs de charge réseau (NLB); </li><li>  LCM / ops commet une nouvelle configuration pour préparer le déploiement pour les mises à jour; </li><li>  L'instruction GitOps met à jour le cluster. </li></ul><br><h3>  Brève description de GitOps </h3><br><ol><li>  Décrivez l'état souhaité de l'ensemble du système à l'aide de spécifications déclaratives pour chaque environnement (dans notre histoire, l'équipe Bob définit la configuration complète du système dans Git). <br><br><ul><li>  Le référentiel git est la seule source de vérité concernant l'état souhaité de l'ensemble du système. </li><li>  Toutes les modifications de l'état souhaité sont effectuées via des validations dans Git. </li><li>  Tous les paramètres de cluster souhaités sont également observables dans le cluster lui-même.  Ainsi, nous pouvons déterminer si les états souhaités et observés coïncident (convergent, <i>convergent</i> ) ou diffèrent ( <i>divergent</i> , <i>divergent</i> ). </li></ul></li><li>  Si les états souhaités et observés sont différents, alors: <br><br><ul><li>  Il existe un mécanisme de convergence qui synchronise tôt ou tard automatiquement les états cible et observé.  À l'intérieur du cluster, Kubernetes fait cela. </li><li>  Le processus démarre immédiatement avec une notification de «modification validée». </li><li>  Après une période de temps configurable, une alerte diff peut être envoyée si les états sont différents. </li></ul></li><li>  Ainsi, toutes les validations dans Git déclenchent des mises à jour vérifiables et idempotentes dans le cluster. <br><br><ul><li>  La restauration est une convergence vers un état précédemment souhaité. </li></ul></li><li>  La convergence est définitive.  À propos de son apparition témoignent: <br><br><ul><li>  Absence d'alertes "diff" pendant un certain temps. </li><li>  Une alerte convergente (par exemple, webhook, événement d'écriture différée Git). </li></ul></li></ol><br><h3>  Qu'est-ce que la divergence? </h3><br>  Nous répétons encore une fois: <i>toutes les propriétés souhaitées du cluster doivent être observables dans le cluster lui-même</i> . <br><br>  Quelques exemples de divergence: <br><br><ul><li>  Changement dans le fichier de configuration en raison de la fusion des branches dans Git. </li><li>  Un changement dans le fichier de configuration en raison d'une validation dans Git effectuée par le client GUI. </li><li>  Plusieurs changements dans l'état souhaité en raison de PR dans Git avec l'assemblage ultérieur de l'image du conteneur et des modifications de la configuration. </li><li>  Changement d'état du cluster en raison d'une erreur, d'un conflit de ressources entraînant un «mauvais comportement» ou simplement d'une déviation accidentelle par rapport à l'état d'origine. </li></ul><br><h3>  Qu'est-ce qu'un mécanisme de convergence? </h3><br>  Quelques exemples: <br><br><ul><li>  Pour les conteneurs et les clusters, le mécanisme de convergence fournit Kubernetes. </li><li>  Le même mécanisme peut être utilisé pour gérer les applications et les conceptions basées sur Kubernetes (par exemple, Istio et Kubeflow). </li><li>  Le mécanisme de gestion de l'interaction de travail entre Kubernetes, les référentiels d'images et Git est fourni <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par l'opérateur Weave Flux GitOps</a> , qui fait partie du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Weave Cloud</a> . </li><li>  Pour les machines de base, le mécanisme de convergence doit être déclaratif et autonome.  D'après notre propre expérience, nous pouvons dire que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terraform est le</a> plus proche de cette définition, mais nécessite toujours un contrôle humain.  En ce sens, GitOps étend la tradition de l'infrastructure en tant que code. </li></ul><br>  GitOps combine Git avec l'excellent moteur de convergence de Kubernetes, offrant un modèle de fonctionnement. <br><br>  GitOps nous permet de déclarer que <i>seuls les systèmes qui peuvent être décrits et observés peuvent être automatisés et contrôlés</i> . <br><br><h3>  GitOps concerne l'ensemble de la pile native du cloud (par exemple Terraform, etc.) </h3><br>  GitOps n'est pas seulement Kubernetes.  Nous voulons que l'ensemble du système soit géré de manière déclarative et utilise la convergence.  Par un système entier, nous entendons un ensemble d'environnements qui fonctionnent avec Kubernetes - par exemple, «cluster de développement 1», «production», etc. Chaque environnement comprend des machines, des clusters, des applications, ainsi que des interfaces pour les services externes qui fournissent des données, la surveillance et etc. <br><br>  Remarquez à quel point Terraform est important dans ce cas pour le problème d'amorçage.  Kubernetes doit être déployé quelque part, et l'utilisation de Terraform signifie que nous pouvons utiliser les mêmes flux de travail GitOps pour créer la couche de contrôle qui sous-tend Kubernetes et les applications.  Il s'agit d'une bonne pratique exemplaire. <br><br>  Une grande attention est accordée à l'application des concepts GitOps aux couches sur Kubernetes.  Il existe actuellement des solutions de type GitOps pour Istio, Helm, Ksonnet, OpenFaaS et Kubeflow, ainsi que, par exemple, pour Pulumi, qui créent une couche pour développer des applications natives du cloud. <br><br><h2>  Kubernetes CI / CD: comparer GitOps avec d'autres approches </h2><br>  Comme indiqué, les GitOps sont deux choses: <br><br><ol><li>  Le modèle opérationnel pour Kubernetes et cloud native décrit ci-dessus. </li><li>  Le chemin vers l'organisation d'un environnement de gestion des applications centré sur les développeurs. </li></ol><br>  Pour beaucoup, GitOps est principalement un workflow basé sur Git push.  Nous l'aimons aussi.  Mais ce n'est pas tout: regardons maintenant les pipelines CI / CD. <br><br><h3>  GitOps fournit un déploiement continu (CD) pour Kubernetes </h3><br>  GitOps offre un mécanisme de déploiement continu qui élimine le besoin de «systèmes de gestion de déploiement» distincts.  Kubernetes fait tout le travail pour vous. <br><br><ul><li>  La mise à jour de l'application nécessite une mise à jour dans Git.  Il s'agit d'une mise à niveau transactionnelle vers l'état souhaité.  Le «déploiement» est ensuite effectué au sein du cluster par Kubernetes lui-même sur la base d'une description mise à jour. </li><li>  En raison des spécificités de Kubernetes, ces mises à jour sont convergentes.  Cela fournit un mécanisme de déploiement continu dans lequel toutes les mises à jour sont atomiques. </li><li>  Remarque: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Weave Cloud</a> propose un opérateur GitOps qui intègre Git et Kubernetes et vous permet d'exécuter un CD en faisant correspondre l'état souhaité et actuel du cluster. </li></ul><br><h3>  Sans kubectl et scripts </h3><br>  Évitez d'utiliser Kubectl pour mettre à niveau le cluster, et en particulier les scripts pour regrouper les commandes kubectl.  Au lieu de cela, avec un pipeline GitOps, un utilisateur peut mettre à niveau son cluster Kubernetes via Git. <br><br>  Les avantages comprennent: <br><br><ol><li>  <b>Exactitude</b> .  Un groupe de mises à jour peut être appliqué, convergé et finalement validé, ce qui nous rapproche de l'objectif du déploiement atomique.  Au contraire, l'utilisation de scripts ne donne aucune garantie de convergence (voir ci-dessous). </li><li>  <b>La sécurité</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Citant</a> Kelsey Hightower: «Limitez l'accès au cluster Kubernetes aux outils d'automatisation et aux administrateurs chargés de le déboguer ou de le maintenir.»  Voir aussi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma publication</a> sur la sécurité et la conformité, ainsi qu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur le piratage de Homebrew</a> en volant des informations d'identification d'un script Jenkins imprudemment écrit. </li><li>  <b>Expérience utilisateur</b> .  Kubectl expose la mécanique du modèle objet Kubernetes, qui est assez complexe.  Idéalement, les utilisateurs devraient interagir avec le système à un niveau d'abstraction plus élevé.  Ici, je vais à nouveau faire référence à Kelsey et recommander de consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un tel curriculum vitae</a> . </li></ol><br><h3>  La différence entre CI et CD </h3><br>  GitOps améliore les modèles CI / CD existants. <br><br>  Le serveur CI moderne est un instrument d'orchestration.  En particulier, c'est un instrument pour orchestrer les pipelines CI.  Ils incluent la génération, le test, la fusion vers le tronc, etc. Les serveurs CI automatisent la gestion des pipelines complexes en plusieurs étapes.  Une tentation courante consiste à créer un script pour l'ensemble de mises à jour Kubernetes et à l'exécuter en tant qu'élément de pipeline pour pousser les modifications dans le cluster.  En effet, c'est ce que font de nombreux experts.  Cependant, ce n'est pas optimal, et voici pourquoi. <br><br>  CI doit être utilisé pour effectuer des mises à jour du tronc, et le cluster Kubernetes doit se changer en fonction de ces mises à jour afin de gérer le CD «en interne».  Nous appelons cela le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle pull pour le CD</a> , contrairement au modèle push CI.  Le CD fait partie d'une <i>orchestration d'exécution</i> . <br><br><h3>  Pourquoi les serveurs CI ne devraient pas créer de CD via des mises à jour directes dans Kubernetes </h3><br>  <i>N'utilisez pas le serveur CI pour orchestrer les mises à jour directes dans Kubernetes en tant qu'ensemble de tâches CI.</i>  <i>C'est l'anti-pattern dont nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déjà parlé</a> sur notre blog.</i> <br><br>  Revenons à Alice et Bob. <br><br>  Quels problèmes ont-ils rencontrés?  Le serveur CI de Bob applique les modifications au cluster, mais s'il se bloque au cours du processus, Bob ne saura pas dans quel état le cluster est (ou devrait être) et comment le corriger.  La même chose est vraie en cas de succès. <br><br>  Supposons que l'équipe de Bob ait assemblé une nouvelle image, puis corrigé ses déploiements pour déployer l'image (le tout à partir du pipeline CI). <br><br>  Si l'image se construit normalement, mais que le pipeline tombe, l'équipe devra découvrir: <br><br><ul><li>  La mise à jour a-t-elle été déployée? </li><li>  Commençons-nous une nouvelle construction?        —           ? </li><li>      ,    ? </li><li>     ?     (     )? </li></ul><br> <i>   Git'    ,        .  -    push' ,    -  ;          --.</i> <br><br> ,   CI-    CD: <br><br><ul><li>     ;     . </li><li> CI-      . </li><li>   .       . </li><li>      . </li></ul><br> <i>  Helm'e:     Helm,      GitOps-,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flux-Helm</a> .    .    Helm    ,  .</i> <br><br><h2> GitOps     Continuous Delivery  Kubernetes </h2><br>      GitOps  ,        ,     .     , ,     . ,         ,  GitOps      . <br><br><h3>    Kubernetes </h3><br>    .   Git            : <br><br><ul><li>   ,       Git      . </li><li>  Runtime GitOps,      .       Git     . </li></ul><br><img src="https://habrastorage.org/webt/0h/mo/vs/0hmovs2jg182thgg_hxll6jabwk.png"><br><br><h3>   ? </h3><br><ol><li> <b> </b> :  ,      ,   Git   .  ,     CI  runtime-.    « » <i>(immutability firewall)</i> ,       .          72-87 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </li><li> <b>   CI-  Git-</b> : GitOps    .       CI-  Git-,     .      Continuous Delivery     CI-/Git-   .        cloud native.   GitOps     . </li><li> <b>   </b> :     Git , Weave Flux (  Weave Cloud)    runtime.  ,  Kubernetes   , Git .           GitOps,   . </li></ol><br><img src="https://habrastorage.org/webt/xh/wn/83/xhwn83itzgegzohc4vyp2sprpe8.png"><br><br><h2>  Conclusion </h2><br> GitOps    ,     CI/CD: <br><br><ul><li> ; </li><li> ; </li><li> ; </li><li> . </li></ul><br>  ,          cloud native. <br><br><ul><li>           ,    runbook' <i>(     — . .)</i> ,    deployment'. </li><li>   cloud native-         ,        . </li></ul><br>   ,              . GitOps  -      . <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> werf 1.0 stable:    GitOps,   </a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitOps:   Pull  Push</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  kubedog     Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   Kubernetes (   )</a> ». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458878/">https://habr.com/ru/post/fr458878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458866/index.html">Fonctionnement de l'équilibreur d'équipe dans World of Tanks Blitz</a></li>
<li><a href="../fr458868/index.html">Bruit dans les mégadonnées. Analyse d'entropie</a></li>
<li><a href="../fr458870/index.html">Problèmes informatiques les plus courants auxquels nous sommes confrontés tous les jours</a></li>
<li><a href="../fr458874/index.html">Liste de contrôle ASO: optimisation du texte</a></li>
<li><a href="../fr458876/index.html">Vendredi Mini CTF</a></li>
<li><a href="../fr458880/index.html">Développement Linux sur Windows avec WSL et Visual Studio Code Remote</a></li>
<li><a href="../fr458882/index.html">Prise de parole en public. En bref sur l'essentiel</a></li>
<li><a href="../fr458884/index.html">Un peu sur les normes de communication spatiale</a></li>
<li><a href="../fr458886/index.html">Conférences Mail.ru Design Conf × Dribbble Meetup 2019 les plus utiles par True Engineering</a></li>
<li><a href="../fr458888/index.html">Meetup Summer Droid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>