<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ ü§∏üèæ üé∞ Implementasi cutscene dan urutan aksi dalam game üåö üë®‚Äçüé§ üç∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini saya akan berbicara tentang bagaimana Anda dapat menerapkan urutan aksi dan adegan cut dalam video game. Artikel ini adalah terjemah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi cutscene dan urutan aksi dalam game</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427135/"> <i>Dalam posting ini saya akan berbicara tentang bagaimana Anda dapat menerapkan urutan aksi dan adegan cut dalam video game.</i>  <i>Artikel ini adalah terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> dan pada topik yang sama saya membuat presentasi di Lua di Moskow, jadi jika Anda lebih suka menonton video, Anda dapat menontonnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> <i><br><br></i>  <i>Kode artikel ditulis dalam Lua, tetapi dapat dengan mudah ditulis dalam bahasa lain (dengan pengecualian metode yang menggunakan coroutine, karena mereka tidak dalam semua bahasa).</i> <i><br></i> <br>  Artikel ini menunjukkan cara membuat mekanisme yang memungkinkan Anda untuk menulis adegan cutscene dari formulir berikut: <br><br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h1>  Entri </h1><br>  Urutan tindakan sering ditemukan di video game.  Misalnya, dalam adegan cutscenes: karakter bertemu musuh, mengatakan sesuatu kepadanya, musuh menjawab, dan sebagainya.  Urutan tindakan dapat ditemukan di gameplay.  Lihatlah gif ini: <br><br><img src="https://habrastorage.org/webt/5k/ry/ik/5kryik8wvq-b4ifoa3k3iobvolw.gif"><br><br>  1. Pintu terbuka <br>  2. Karakter memasuki rumah <br>  3. Pintu tertutup <br>  4. Layar secara bertahap menjadi gelap <br>  5. Levelnya berubah <br>  6. Layar memudar dengan cerah <br>  7. Karakter memasuki kafe <br><br>  Urutan tindakan juga dapat digunakan untuk skrip perilaku NPC atau untuk menerapkan pertempuran bos di mana bos melakukan beberapa tindakan satu demi satu. <br><a name="habracut"></a><br><h1>  Masalah </h1><br>  Struktur loop permainan standar membuat penerapan urutan tindakan sulit.  Katakanlah kita memiliki lingkaran permainan berikut: <br><br><img src="https://habrastorage.org/webt/uc/xs/an/ucxsanil2ovbawdzqehjmfjpja4.png" width="240"><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> game:isRunning() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> processInput() dt = <span class="hljs-built_in"><span class="hljs-built_in">clock</span></span>.delta() update(dt) render() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Kami ingin menerapkan cutscene berikut: pemain mendekati NPC, NPC mengatakan: "Anda berhasil!", Dan kemudian setelah jeda singkat mengatakan: "Terima kasih!".  Di dunia yang ideal, kita akan menulisnya seperti ini: <br><br><pre> <code class="lua hljs">player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>)</code> </pre><br>  Dan di sini kita dihadapkan dengan masalah.  Butuh beberapa waktu untuk menyelesaikan langkah-langkah ini.  Beberapa tindakan bahkan mungkin menunggu masukan dari pemain (misalnya, untuk menutup kotak dialog).  Alih-alih fungsi <code>delay</code> , Anda tidak dapat memanggil <code>sleep</code> sama - ini akan terlihat seperti permainan dibekukan. <br><br>  Mari kita lihat beberapa pendekatan untuk menyelesaikan masalah. <br><br><h1>  bool, enum, mesin negara </h1><br>  Cara yang paling jelas untuk menerapkan urutan tindakan adalah menyimpan informasi tentang keadaan saat ini dalam bools, string, atau enum.  Kode akan terlihat seperti ini: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'playerGoingToNpc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player:continueGoingTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:closeTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> dialogueWindow:show(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dialogueWindow:wasClosed() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'delay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> ... ... <span class="hljs-comment"><span class="hljs-comment">--   ... end end</span></span></code> </pre><br>  Pendekatan ini dengan mudah mengarah pada kode spaghetti dan rantai panjang ekspresi if-else, jadi saya sarankan menghindari metode pemecahan masalah ini. <br><br><h1>  Daftar tindakan </h1><br>  Daftar tindakan sangat mirip dengan mesin negara.  Daftar tindakan adalah daftar tindakan yang dilakukan satu demi satu.  Dalam loop game, fungsi <code>update</code> dipanggil untuk tindakan saat ini, yang memungkinkan kami untuk memproses input dan membuat game, bahkan jika tindakan itu membutuhkan waktu lama.  Setelah tindakan selesai, kami melanjutkan ke yang berikutnya. <br><br>  Dalam cutscene yang ingin kami terapkan, kami perlu mengimplementasikan tindakan berikut: GoToAction, DialogueAction, dan DelayAction. <br><br>  Untuk contoh lebih lanjut, saya akan menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">middleclass</a> untuk OOP di Lua. <br><br>  Begini cara <code>DelayAction</code> diimplementasikan: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--  function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt; self.delay then self.isFinished = true end end</span></span></code> </pre><br>  <code>ActionList:update</code> fungsi <code>ActionList:update</code> terlihat seperti ini: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionList:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.currentAction:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.currentAction.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:goToNextAction() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.currentAction <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Dan akhirnya, implementasi cutscene itu sendiri: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> makeCutsceneActionList(player, npc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ActionList:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { GoToAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = player, target = npc }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "You did it!" }, DelayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { delay = <span class="hljs-number"><span class="hljs-number">0.5</span></span> }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "Thank you" } } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... -    actionList:update(dt)</span></span></code> </pre><br>  <i>Catatan</i> : di Lua, panggilan ke <code>someFunction({ ... })</code> dapat dibuat seperti ini: <code>someFunction{...}</code> .  Ini memungkinkan Anda untuk menulis <code>DelayAction:new{ delay = 0.5 }</code> alih-alih <code>DelayAction:new({delay = 0.5})</code> . <br><br>  Terlihat jauh lebih baik.  Kode dengan jelas menunjukkan urutan tindakan.  Jika kita ingin menambahkan tindakan baru, kita dapat dengan mudah melakukannya.  Sangat mudah untuk membuat kelas seperti <code>DelayAction</code> untuk membuat cutscene penulisan lebih nyaman. <br><br>  Saya menyarankan Anda untuk melihat presentasi Sean Middleditch tentang daftar tindakan, yang memberikan contoh yang lebih kompleks. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/o6CaB-hmqoE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Daftar tindakan umumnya sangat bermanfaat.  Saya menggunakan mereka untuk permainan saya untuk beberapa waktu dan secara keseluruhan senang.  Namun pendekatan ini juga memiliki kelemahan.  Katakanlah kita ingin menerapkan cutscene yang sedikit lebih kompleks: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Untuk melakukan simulasi if / else, Anda perlu mengimplementasikan daftar non-linear.  Ini dapat dilakukan dengan menggunakan tag.  Beberapa tindakan dapat ditandai, dan kemudian, dengan beberapa syarat, alih-alih pindah ke tindakan berikutnya, Anda bisa pergi ke tindakan yang memiliki tag yang diinginkan.  Ini berfungsi, namun tidak mudah untuk membaca dan menulis seperti fungsi di atas. <br><br>  Lua coroutine membuat kode ini menjadi kenyataan. <br><br><h1>  Coroutine </h1><br><h2>  Dasar-dasar Corua di Lua </h2><br>  Corutin adalah fungsi yang dapat dijeda dan kemudian dilanjutkan.  Coroutine dieksekusi di utas yang sama dengan program utama.  Tidak ada utas baru yang pernah dibuat untuk coroutine. <br><br>  Untuk menjeda <code>coroutine.yield</code> , Anda perlu menghubungi <code>coroutine.yield</code> , untuk melanjutkan - <code>coroutine.resume</code> .  Contoh sederhana: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"world!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"uhh..."</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c)</code> </pre><br>  Output Program: <br><br><pre> halo
 uhh ...
 dunia
</pre><br><br>  Begini cara kerjanya.  Pertama, kita membuat <code>coroutine.create</code> menggunakan <code>coroutine.create</code> .  Setelah panggilan ini, corutin tidak mulai.  Agar ini terjadi, kita perlu menjalankannya menggunakan <code>coroutine.resume</code> .  Kemudian fungsi <code>f</code> disebut, yang menulis "halo" dan menjeda dirinya sendiri dengan <code>coroutine.yield</code> .  Ini mirip dengan <code>return</code> , tetapi kita dapat melanjutkan <code>f</code> dengan <code>coroutine.resume</code> . <br><br>  Jika Anda melewatkan argumen saat memanggil <code>coroutine.yield</code> , maka mereka akan menjadi nilai balik dari panggilan yang sesuai ke <code>coroutine.resume</code> di "aliran utama". <br><br>  Sebagai contoh: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"some text"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ok, num, text = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(num, text) <span class="hljs-comment"><span class="hljs-comment">-- will print '42 "some text"'</span></span></code> </pre><br>  <code>ok</code> adalah variabel yang memungkinkan kita untuk mengetahui status coroutine.  Jika <code>ok</code> <code>true</code> , maka dengan coroutine semuanya baik-baik saja, tidak ada kesalahan terjadi di dalam.  Nilai-nilai pengembalian yang mengikutinya ( <code>num</code> , <code>text</code> ) adalah argumen yang sama yang kami berikan untuk <code>yield</code> . <br><br>  Jika <code>ok</code> <code>false</code> , maka ada yang salah dengan coroutine, misalnya, fungsi <code>error</code> dipanggil di dalamnya.  Dalam hal ini, nilai pengembalian kedua akan menjadi pesan kesalahan.  Contoh coroutine di mana kesalahan terjadi: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> + notDefined) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) ok, msg = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ok <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Coroutine failed!"</span></span>, msg) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Kesimpulan: <br><br><pre> Coroutine gagal!  input: 4: upaya untuk melakukan aritmatika pada nilai nol (global 'notDefined')
</pre><br><br>  Status <code>coroutine.status</code> dapat diperoleh dengan memanggil <code>coroutine.status</code> .  Corutin mungkin dalam kondisi berikut: <br><br><ul><li>  "Running" - Coroutine sedang berjalan.  <code>coroutine.status</code> dipanggil dari corutin itu sendiri </li><li>  "Ditangguhkan" - Corutin dijeda atau belum pernah dimulai </li><li>  "Normal" - corutin aktif, tetapi tidak dieksekusi.  Artinya, corutin meluncurkan corutin lain di dalam dirinya </li><li>  "Mati" - eksekusi coroutine selesai (yaitu, fungsi dalam coroutine selesai) </li></ul><br>  Sekarang, dengan bantuan pengetahuan ini, kita dapat menerapkan sistem urutan tindakan dan adegan cutscene berdasarkan coroutine. <br><br><h2>  Membuat cutscene menggunakan corutin </h2><br>  Inilah yang akan terlihat seperti kelas <code>Action</code> pada sistem baru: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() self:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self:<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Pendekatannya mirip dengan daftar tindakan: fungsi <code>update</code> dari tindakan dipanggil hingga tindakan selesai.  Tapi di sini kita menggunakan coroutine dan <code>yield</code> di setiap iterasi dari loop game ( <code>Action:launch</code> dipanggil dari beberapa coroutine).  Di suatu tempat dalam <code>update</code> loop game, kami melanjutkan eksekusi cutscene saat ini seperti ini: <br><br><pre> <code class="lua hljs">coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c, dt)</code> </pre><br>  Dan akhirnya, membuat cutscene: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- -  ... local c = coroutine.create(cutscene, player, npc) coroutine.resume(c, dt)</span></span></code> </pre><br>  Inilah cara fungsi <code>delay</code> diimplementasikan: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(time)</span></span></span></span> action = DelayAction:new { delay = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Membuat pembungkus seperti itu sangat meningkatkan keterbacaan kode cutscene.  <code>DelayAction</code> diimplementasikan seperti ini: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Action -   DelayAction local DelayAction = class("DelayAction", Action) function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt;= self.delayTime then self.finished = true end end</span></span></code> </pre><br>  Implementasi ini identik dengan yang kami gunakan dalam daftar tindakan!  Mari kita lihat <code>Action:launch</code> fungsi <code>Action:launch</code> lagi: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-comment"><span class="hljs-comment">-- the most important part self:update(dt) end self:exit() end</span></span></code> </pre><br>  Hal utama di sini adalah <code>while</code> , yang berjalan hingga aksi selesai.  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/l3/_n/xw/l3_nxwnzshpxqhho12yqyi-y52o.png"><br><br>  Sekarang mari kita lihat fungsi <code>goTo</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:goTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = GoToAction:new { entity = self, target = target } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.entity:closeTo(self.target) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">--  , AI else self.finished = true end end</span></span></code> </pre><br>  Coroutine berjalan baik dengan berbagai acara.  Menerapkan kelas <code>WaitForEventAction</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">false</span></span> eventManager:subscribe { listener = self, eventType = params.eventType, callback = WaitForEventAction.onEvent } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:onEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Fungsi ini tidak memerlukan metode <code>update</code> .  Itu akan dieksekusi (meskipun tidak akan melakukan apa-apa ...) sampai menerima acara dengan jenis yang diperlukan.  Ini adalah aplikasi praktis dari kelas ini - implementasi fungsi <code>say</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span></span> DialogueWindow:show(text) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = WaitForEventAction:new { eventType = <span class="hljs-string"><span class="hljs-string">'DialogueWindowClosed'</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Sederhana dan mudah dibaca.  Ketika kotak dialog ditutup, ia mengirimkan acara bertipe 'DialogueWindowClosed`.  Tindakan say berakhir dan yang berikutnya mulai dijalankan. <br><br>  Menggunakan coroutine, Anda dapat dengan mudah membuat cutscenes nonlinear dan pohon dialog: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> answer = girl:say(<span class="hljs-string"><span class="hljs-string">'do_you_love_lua'</span></span>, { <span class="hljs-string"><span class="hljs-string">'YES'</span></span>, <span class="hljs-string"><span class="hljs-string">'NO'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> answer == <span class="hljs-string"><span class="hljs-string">'YES'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'happy_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'angry'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'angry_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/t4/e-/am/t4e-amhtwligikstvqtgi8bpyzu.gif"><br><br>  Dalam contoh ini, fungsi <code>say</code> sedikit lebih kompleks daripada yang saya tunjukkan sebelumnya.  Ini mengembalikan pilihan pemain dalam dialog, namun tidak sulit untuk diterapkan.  Misalnya, <code>WaitForEventAction</code> dapat digunakan secara <code>WaitForEventAction</code> , yang akan menangkap acara PlayerChoiceEvent dan kemudian mengembalikan pilihan pemain yang informasinya akan terkandung dalam objek acara. <br><br><h2>  Contoh yang sedikit lebih rumit </h2><br>  Dengan coroutine, Anda dapat dengan mudah membuat tutorial dan pencarian kecil.  Sebagai contoh: <br><br><pre> <code class="lua hljs">girl:say(<span class="hljs-string"><span class="hljs-string">"Kill that monster!"</span></span>) waitForEvent(<span class="hljs-string"><span class="hljs-string">'EnemyKilled'</span></span>) girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">"You did it! Thank you!"</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/wx/du/kh/wxdukhci9lald-fph9ypbu5h5fg.gif"><br><br>  Coroutine juga dapat digunakan untuk AI.  Misalnya, Anda dapat membuat fungsi yang akan membuat monster bergerak di sepanjang lintasan: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(monster, path)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> numberOfPoints = <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>:getNumberOfPoints() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">--      while true do monster:goTo(path:getPoint(i)) if i &lt; numberOfPoints - 1 then i = i + 1 --     else --   i = 0 end end end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/g7/m4/ou/g7m4ouls2l7al6xlovmm-qdbywc.gif"><br><br>  Ketika monster melihat pemain, kita bisa berhenti memenuhi coroutine dan menghapusnya.  Oleh karena itu, loop tak terbatas ( <code>while true</code> ) di dalam <code>followPath</code> tidak benar-benar tak terbatas. <br><br>  Dengan corutin, Anda dapat melakukan tindakan "paralel".  Cutscene tidak akan melanjutkan ke tindakan berikutnya sampai kedua tindakan selesai.  Sebagai contoh, kami akan membuat cutscene di mana seorang gadis dan kucing pergi ke titik teman dengan kecepatan yang berbeda.  Setelah mereka mendatanginya, kucing itu berkata "mengeong". <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cat, girl, meetingPoint)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c1 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> cat:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c2 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> girl:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) c1.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() c2.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() <span class="hljs-comment"><span class="hljs-comment">--  waitForFinish(c1, c2) --    cat:say("meow") ... end</span></span></code> </pre><br>  Bagian terpenting di sini adalah fungsi <code>waitForFinish</code> , yang merupakan pembungkus di sekitar kelas <code>WaitForFinishAction</code> , yang dapat diimplementasikan sebagai berikut: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForFinishAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c1, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c2, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Anda dapat membuat kelas ini lebih kuat jika Anda mengizinkan sinkronisasi jumlah tindakan ke-N. <br><br>  Anda juga dapat membuat kelas yang akan menunggu sampai <i>salah</i> satu coroutine selesai, alih-alih menunggu <i>semua</i> coroutine untuk menyelesaikan eksekusi.  Misalnya, dapat digunakan dalam balap mini-game.  Di dalam coroutine akan ada menunggu salah satu pembalap untuk mencapai garis finish dan kemudian melakukan beberapa tindakan. <br><br><h2>  Keuntungan dan kerugian dari corutin </h2><br>  Coroutine adalah mekanisme yang sangat berguna.  Dengan menggunakannya Anda dapat menulis cutscene dan kode gameplay yang mudah dibaca dan dimodifikasi.  Adegan seperti ini dapat dengan mudah ditulis oleh modder atau orang yang bukan programmer (misalnya, desainer game atau level). <br><br>  Dan semua ini dilakukan dalam satu utas, sehingga tidak ada masalah dengan sinkronisasi atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kondisi balapan</a> . <br><br>  Pendekatan ini memiliki kelemahan.  Misalnya, mungkin ada masalah dengan save.  Katakanlah permainan Anda memiliki tutorial panjang yang diimplementasikan dengan coroutine.  Selama tutorial ini pemain tidak akan dapat menyimpan karena  Untuk melakukan ini, Anda harus menyimpan keadaan saat ini dari coroutine (yang mencakup seluruh tumpukan dan nilai-nilai variabel di dalamnya), sehingga setelah memuat lebih lanjut dari save, Anda dapat melanjutkan tutorial. <br><br>  ( <i>Catatan</i> : menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PlutoLibrary,</a> coroutine dapat diserialisasi, tetapi perpustakaan hanya berfungsi dengan Lua 5.1) <br><br>  Masalah ini tidak terjadi dengan cutscene, seperti  biasanya dalam game di tengah cutscene tidak diperbolehkan. <br><br>  Masalah dengan tutorial yang panjang dapat diselesaikan jika Anda memecahnya menjadi potongan-potongan kecil.  Misalkan seorang pemain melewati bagian pertama tutorial dan harus pergi ke ruangan lain untuk melanjutkan tutorial.  Pada titik ini, Anda dapat membuat pos pemeriksaan atau memberikan pemain kesempatan untuk menabung.  Dalam save, kami akan menulis sesuatu seperti "pemain menyelesaikan bagian 1 dari tutorial".  Selanjutnya, pemain akan melalui bagian kedua tutorial, yang mana kita sudah akan menggunakan coroutine lain.  Dan seterusnya ... Saat memuat, kami baru mulai menjalankan coroutine yang sesuai dengan bagian yang harus dilalui pemain. <br><br><h1>  Kesimpulan </h1><br>  Seperti yang dapat Anda lihat, ada beberapa pendekatan berbeda untuk mengimplementasikan serangkaian tindakan dan adegan adegan.  Tampaknya bagi saya bahwa pendekatan coroutine sangat kuat dan saya senang membagikannya kepada para pengembang.  Saya harap solusi masalah ini akan membuat hidup Anda lebih mudah dan memungkinkan Anda membuat adegan-adegan epik dalam gim Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427135/">https://habr.com/ru/post/id427135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427117/index.html">Ruang pertemuan berdasarkan Asterisk</a></li>
<li><a href="../id427123/index.html">Turing game</a></li>
<li><a href="../id427129/index.html">Ancaman Intelijen - pendekatan modern terhadap keamanan informasi</a></li>
<li><a href="../id427131/index.html">Berkenalan dengan Audiomania: 15 materi tematik tentang produksi, desain, kantor, dan bisnis</a></li>
<li><a href="../id427133/index.html">Assortment - tugas optimasi klasik</a></li>
<li><a href="../id427137/index.html">Statistik Bank Sentral: pendapatan peretas dari serangan siber pada organisasi keuangan pada 2018 turun hampir 14 kali</a></li>
<li><a href="../id427139/index.html">[Pilihan] Pengembangan, desain dan promosi situs: 17 bahan yang bermanfaat</a></li>
<li><a href="../id427141/index.html">Peledakan ponsel</a></li>
<li><a href="../id427143/index.html">Badge Retrocomputer Kedua Hackaday</a></li>
<li><a href="../id427145/index.html">Cara terbaik untuk mulai mempelajari genetika modern, biologi molekuler, rekayasa genetika dan genomika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>