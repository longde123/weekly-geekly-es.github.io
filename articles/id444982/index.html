<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜” ğŸ± ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¾ Mockito dan cara memasaknya ğŸš– ğŸ“© ğŸ®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tentang artikel 


 Berikut ini panduan lain untuk Mockito. Di dalamnya, di satu sisi, saya mencoba mendeskripsikan fungsionalitas perpustakaan ini se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mockito dan cara memasaknya</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444982/"><h2 id="o-state">  Tentang artikel </h2><br><p>  Berikut ini panduan lain untuk Mockito.  Di dalamnya, di satu sisi, saya mencoba mendeskripsikan fungsionalitas perpustakaan ini sehingga pembaca yang tidak terbiasa dengan itu segera mendapat kesempatan untuk sepenuhnya menggunakannya, dan bukan hanya gagasan umum tentang itu.  Di sisi lain, saya ingin membuatnya cukup ringkas dan terstruktur sehingga saya dapat dengan cepat membacanya secara keseluruhan dan dengan cepat menemukan sesuatu yang pernah dibaca, tetapi dilupakan.  Secara umum, artikel ini, yang akan berguna bagi saya sendiri, ketika saya baru saja menemukan perpustakaan ini dan tidak benar-benar mengerti cara kerjanya. </p><br><p>  Saya kira itu bisa berguna bagi saya sekarang - kadang-kadang saya lupa beberapa hal ini, dan lebih mudah untuk mengingat materi tidak sesuai dengan dokumentasi resmi atau artikel orang lain, tetapi menurut saya sendiri, katakanlah, sinopsis.  Pada saat yang sama, saya mencoba untuk membuat teks sedemikian rupa sehingga nyaman terutama untuk menjelajahi Mockito dari awal, dan di beberapa tempat saya menganalisis secara terperinci hal-hal yang tampaknya jelas - tidak semuanya jelas bagi saya sejak awal. </p><a name="habracut"></a><br><h2 id="soderzhanie">  Konten: </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mockito: apa itu dan mengapa itu perlu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lingkungan, versi dan hewan percobaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengejek dan memata-matai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajemen perilaku</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengaturan kondisi panggilan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengatur Hasil Panggilan</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panggilan Metode Pelacakan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mock objek sebagai nilai bidang dan anotasi Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kembalikan perilaku ke sesi default dan Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa lagi</a> </li></ol><br><h2 id="mockito-chto-eto-takoe-i-zachem-nuzhno">  Mockito: apa itu dan mengapa itu perlu </h2><br><p>  Singkatnya, Mockito adalah kerangka kerja rintisan. </p><br><p>  Seperti yang Anda ketahui, saat menguji kode (terutama pengujian unit, tetapi tidak hanya), elemen yang diuji sering perlu memberikan contoh kelas yang harus digunakan saat bekerja.  Namun, seringkali mereka tidak harus berfungsi penuh - sebaliknya, mereka dituntut untuk berperilaku dengan cara yang didefinisikan secara ketat, sehingga perilaku mereka sederhana dan dapat diprediksi sepenuhnya.  Mereka disebut bertopik.  Untuk mendapatkannya, Anda bisa membuat implementasi uji alternatif dari antarmuka, mewarisi kelas yang diperlukan dengan redefinisi fungsi, dan sebagainya, tetapi semua ini cukup merepotkan, berlebihan dan penuh dengan kesalahan.  Solusi yang lebih nyaman dalam semua pengertian adalah kerangka kerja khusus untuk membuat bertopik.  Salah satunya (dan mungkin yang paling terkenal di Jawa) adalah Mockito. </p><br><p> Mockito memungkinkan Anda untuk membuat dengan satu baris kode yang disebut mock (sesuatu seperti dasar untuk rintisan yang diinginkan) dari kelas mana pun.  Untuk tiruan seperti itu, segera setelah pembuatan, perilaku default tertentu adalah karakteristik (semua metode mengembalikan nilai yang diketahui sebelumnya - biasanya ini <code>null</code> atau <code>0</code> ).  Anda dapat mendefinisikan kembali perilaku ini seperti yang Anda inginkan, mengendalikannya dengan tingkat detail yang tepat, dan sebagainya.  Akibatnya, tiruan menjadi rintisan dengan properti yang diperlukan.  Di bawah ini saya akan membahas secara rinci bagaimana melakukan ini. </p><br><p>  Saya perhatikan bahwa mock juga dapat dibuat untuk kelas-kelas itu, contoh baru yang sebenarnya tidak bisa Anda buat, khususnya, kelas-kelas dengan konstruktor khusus pribadi seperti kelas-kelas utilitas dan tunggal, dan dengan konfigurasi kerangka kerja minimal, dan enum. </p><br><h2 id="okruzhenie-versii-i-podopytnoe-zhivotnoe">  Lingkungan, versi dan hewan percobaan </h2><br><p>  Saat menulis artikel ini, saya menggunakan: </p><br><ul><li>  Mockito: 'org.mockito: mockito-core: 2.24.0' (versi stabil terbaru saat penulisan) </li><li>  TestNG: 'org.testng: testng: 6.14.3' sebagai kerangka uji </li><li>  AssertJ: 'org.assertj: assertj-core: 3.11.1' sebagai alat validasi </li><li>  Lombok: 'org.projectlombok: lombok: 1.18.6' (hanya untuk kenyamanan) </li><li>  Java 8 </li></ul><br><p>  Untuk eksperimen tidak manusiawi saya, saya menulis antarmuka layanan yang menyediakan akses ke data tertentu. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; dataToSave)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, Supplier&lt;String&gt; calculateIfAbsent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataListByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; idList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataByRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataSearchRequest request)</span></span></span></span>; }</code> </pre> <br><p>  Dan ini (biarkan demi pesanan) kode dari kelas permintaan diteruskan ke yang terakhir dari metode antarmuka. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSearchRequest</span></span></span><span class="hljs-class"> </span></span>{ String id; Date updatedBefore; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; }</code> </pre> <br><p>  Unit data diidentifikasi oleh ID dan memiliki beberapa karakteristik lebih, tetapi langsung dalam bentuk di mana mereka dikembalikan oleh layanan, mereka adalah string, dan bukan beberapa objek yang lebih kompleks.  Saya tidak ketinggalan sesuatu yang penting, dan contohnya lebih sederhana dan lebih jelas. </p><br><p>  Saya akan segera mencatat: dalam contoh di bawah ini, saya langsung memanggil metode yang ditimpa objek tiruan saya untuk kejelasan, tetapi dengan pengujian nyata idenya tidak sama sekali!  Dalam tes ini, saya akan secara konsisten melakukan hal berikut: </p><br><ul><li>  mengkonfigurasi tiruan layanan saya sesuai kebutuhan; </li><li>  melewatinya (kemungkinan besar, melalui konstruktor) ke instance dari kelas lain yang menggunakannya (misalkan berisi semacam logika bisnis menggunakan data yang disediakan oleh <code>DataService</code> ), yang sebenarnya akan saya uji; </li><li>  mengaktifkan fungsionalitas kelas yang diuji dan mengontrol hasilnya; </li><li>  jika perlu, saya akan mengontrol jumlah dan urutan panggilan ke metode mock saya, yang seharusnya dipanggil oleh kelas yang diuji sebagai hasil dari tindakan sebelumnya. </li></ul><br><h2 id="mock-i-spy">  mengejek dan memata-matai </h2><br><p>  Kelas pusat Mockito, di mana ia seharusnya mengakses sebagian besar fungsi, adalah, pada kenyataannya, kelas yang disebut <code>Mockito</code> (ada juga kelas <code>BDDMockito</code> yang menyediakan tentang kemungkinan yang sama dalam bentuk yang lebih cocok untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BDD</a> , tapi di sini saya tidak akan membahasnya) .  Akses ke fungsi diimplementasikan melalui metode statisnya. </p><br><p>  Untuk membuat tiruan dari kelas <code>DataService</code> , saya hanya perlu melakukan hal berikut: </p><br><pre> <code class="java hljs">DataService dataServiceMock = Mockito.mock(DataService.class);</code> </pre> <br><p>  Selesai - Saya mendapat instance dari kelas yang saya butuhkan.  Ini akan diterima oleh metode atau konstruktor apa pun yang memerlukan parameter jenis ini (misalnya, konstruktor dari kelas yang ingin saya uji).  Bahkan jika pemeriksaan kecanduan menunggu nanti, ia akan meneruskannya: tidak hanya <code>instanceof DataService</code> akan mengembalikan <code>true</code> , tetapi juga <code>dataServiceMock.getClass()</code> - yaitu <code>DataService.class</code> .  Dalam beberapa cara formal, untuk secara terprogram membedakan objek tiruan dari yang biasa ternyata menjadi tugas yang agak sulit, yang logis: setelah semua, yang pertama dimaksudkan hanya untuk bisa dibedakan dari yang kedua.  Namun, Mockito memiliki alat untuk ini - metode <code>Mockito.mockingDetails</code> .  Dengan melewatkannya objek sewenang-wenang, saya mendapatkan objek dari kelas <code>MockingDetails</code> .  Ini berisi informasi tentang apa yang diwakili objek ini dari sudut pandang Mockito: apakah itu tiruan, mata-mata (lihat di bawah), bagaimana benda itu digunakan, bagaimana benda itu dibuat, dan sebagainya. </p><br><p>  Dari catatan khusus adalah situasi ketika saya mencoba membuat tiruan untuk kelas akhir atau contoh tiruan dari enum atau untuk menimpa perilaku metode akhir.  Dalam hal ini, dengan perilaku default Mockito, kode di atas menolak untuk bekerja, dengan mengutip keadaan ini.  Namun, ini dapat diubah - cukup buat dalam proyek (dengan perangkat standar dari pohon direktori proyek) <code>test/resources/mockito-extensions/org.mockito.plugins.MockMaker</code> file <code>test/resources/mockito-extensions/org.mockito.plugins.MockMaker</code> dan masukkan baris di dalamnya: </p><br><pre> <code class="plaintext hljs">mock-maker-inline</code> </pre> <br><p>  Setelah itu, Anda dapat meniru kelas akhir dan enum dengan cara biasa, serta mengganti metode final. </p><br><p>  Mock yang saya dapatkan dalam aksi adalah sebagai fitur mungkin: tidak ada satu metode akan memiliki efek pada apa pun, dan nilai yang dikembalikan akan <code>null</code> untuk jenis objek dan <code>0</code> untuk yang primitif.  Harap dicatat: jika metode mengembalikan koleksi, tiruan standar tidak akan mengembalikan <code>null</code> , tetapi mengosongkan koleksi contoh.  Misalnya, untuk <code>List</code> ini akan berubah menjadi <code>LinkedList</code> kosong <code>LinkedList</code> terlepas dari apa metode yang seharusnya dikembalikan.  Tetapi sebagai nilai array, primitif atau objek, saya mendapatkan <code>null</code> .  Perilaku default (dan bukan hanya itu) dapat diubah menggunakan fungsi dari kelas <code>MockSettings</code> , tetapi ini jarang diperlukan. </p><br><p>  Dengan satu atau lain cara, dalam kebanyakan kasus saya tidak akan memerlukan perilaku default, dan pada bagian selanjutnya saya akan menganalisis secara rinci bagaimana mengatur apa yang diperlukan sebagai gantinya. </p><br><p>  Namun, bagaimana jika saya ingin menggunakan objek kelas nyata dengan fungsi yang tersedia sebagai rintisan, mendefinisikan ulang operasi hanya sebagian dari metodenya?  Jika kita berbicara tentang pengujian unit, kebutuhan seperti itu biasanya (tetapi tidak selalu) menunjukkan bahwa proyek tersebut tidak sepenuhnya sesuai dengan desain, dan pada prinsipnya, ini tidak direkomendasikan.  Namun, ada situasi ketika ini karena alasan tertentu tidak dapat dihindari.  Untuk kasus ini, Mockito memiliki mata-mata yang disebut, "mata-mata."  Tidak seperti mock, mereka dapat dibuat berdasarkan kelas dan objek yang sudah jadi: </p><br><pre> <code class="java hljs">DataService dataServiceSpy = Mockito.spy(DataService.class); <span class="hljs-comment"><span class="hljs-comment">// or DataService dataService = new DataService(); dataServiceSpy = Mockito.spy(dataService);</span></span></code> </pre> <br><p>  Saat membuat mata-mata berdasarkan kelas, jika tipenya adalah antarmuka, objek tiruan biasa akan dibuat, dan jika tipenya adalah kelas, maka Mockito akan mencoba membuat instance menggunakan konstruktor default (tanpa parameter).  Dan hanya jika tidak ada konstruktor seperti itu, kesalahan akan terjadi dan tes tidak akan berfungsi. </p><br><p>  Perilaku default objek mata-mata identik dengan perilaku instance kelas reguler, namun mereka memberi saya kemungkinan yang sama dengan objek tiruan: mereka memungkinkan saya untuk mendefinisikan kembali perilaku mereka dan memantau penggunaannya (lihat bagian berikut).  Poin penting: mata-mata bukanlah pembungkus contoh yang dibuatnya!  Oleh karena itu, memanggil metode mata-mata tidak akan memengaruhi keadaan instance asli. </p><br><h2 id="upravlenie-povedeniem">  Manajemen perilaku </h2><br><p>  Jadi, tentang cara mendapatkan tiruan atau mata-mata untuk melakukan apa yang saya butuhkan.  Lebih jauh, saya akan selalu menulis "mock" di mana-mana - ini berarti "mock atau spy", kecuali dinyatakan lain. </p><br><p>  Secara umum, mengendalikan perilaku objek tiruan diturunkan ke satu konsep yang jelas: ketika tiruan dipengaruhi sedemikian rupa (yaitu, metode ini dan itu disebut dengan argumen ini dan itu), ia harus merespons dengan cara ini dan itu.  Konsep ini memiliki dua implementasi dalam kelas Mockito - yang utama, direkomendasikan oleh pengembang untuk digunakan sedapat mungkin, dan yang alternatif, digunakan di mana yang utama tidak cocok. </p><br><p>  Implementasi utama didasarkan pada metode <code>Mockito.when</code> .  Metode ini mengambil sebagai "parameter" panggilan ke metode redefined objek-mock (cara ini tindakan yang terdeteksi diperbaiki) dan mengembalikan objek tipe <code>OngoingStubbing</code> , yang memungkinkan memanggil salah satu metode keluarga <code>Mockito.then...</code> (ini adalah bagaimana reaksi terhadap efek ini diatur).  Secara keseluruhan, dalam kasus paling sederhana, terlihat seperti ini: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Setelah operasi ini, dengan memanggil metode <code>getAllData()</code> pada objek <code>getAllData()</code> , saya mendapatkan objek yang ditentukan di baris pertama daftar. </p><br><p>  Di sini, intuisi "berorientasi objek" yang sudah dikenal mungkin memberikan semacam malfungsi, jadi ini layak untuk dibahas lebih rinci.  Dari sudut pandang sintaksis Java, nilai yang diteruskan ke metode <code>when</code> sebagai parameter, tentu saja, nilai yang dikembalikan oleh metode yang diganti.  Untuk mock, ini adalah nilai kosong, untuk mata-mata, ini adalah nilai yang dikembalikan oleh metode objek nyata.  Tetapi berkat sihir yang bertindak "di bawah tenda" Mockito, metode <code>when</code> akan bekerja secara normal (dan tidak akan crash ketika diluncurkan dengan kesalahan) hanya jika panggilan metode objek mock berada di dalam tanda kurung setelah <code>when</code> . </p><br><p>  Ideologi serupa sering kali berfungsi ketika mendefinisikan perilaku tiruan dalam Mockito: dengan memanggil metode (objek tiruan atau kelas <code>Mockito</code> ), saya mencoba untuk tidak mendapatkan nilai yang dikembalikan olehnya, tetapi entah bagaimana memengaruhi panggilan yang mungkin dari metode objek tiruan yang bekerja dengan saya: tentukan batas-batasnya, tentukan hasilnya, buat pengamatan tantangannya dan seterusnya.  Kedengarannya agak berkabut, saya akui, dan pada tabrakan pertama terlihat aneh, tetapi, setelah mengetahuinya, Anda segera mulai merasakan pendekatan ini sebagai sesuatu yang sepenuhnya alami dalam konteks bekerja dengan bertopik. </p><br><p>  Implementasi alternatif untuk menghubungkan kondisi dan hasil panggilan adalah metode dari keluarga <code>Mockito.do...</code> .  Metode ini memungkinkan Anda untuk mengatur perilaku yang dimulai dengan hasil panggilan dan mengembalikan objek dari kelas <code>Stubber</code> , yang dengannya Anda sudah dapat mengatur kondisinya.  Pengikatan yang sama seperti di atas dilakukan dengan cara ini terlihat seperti ini: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.doReturn(data).when(dataService).getData()</code> </pre> <br><p>  Apa bedanya, mengapa mengikat melalui <code>Mockito.when</code> dianggap lebih baik dan ketika Anda masih harus menggunakan metode <code>Mockito.do...</code> ?  Harap dicatat: dalam implementasi pertama, ketika mengatur perilaku metode (dalam hal ini, <code>getAllData()</code> ), panggilan ke versi yang belum didefinisikan ulang dilakukan terlebih dahulu, dan hanya kemudian, di perut Mockito, terjadi override.  Dalam yang kedua, panggilan seperti itu tidak terjadi - metode <code>Stubber.when</code> diteruskan langsung ke metode <code>Stubber.when</code> , dan objek dengan tipe yang sama dikembalikan oleh metode ini tetapi dari sifat yang berbeda disebut dengan metode yang dapat ditimpa.  Perbedaan ini menentukan segalanya.  Mengikat melalui <code>Mockito.do...</code> sekali tidak mengontrol pada tahap kompilasi metode mana yang akan didefinisikan ulang yang akan saya panggil dan apakah itu kompatibel dengan tipe dengan nilai pengembalian yang diberikan.  Karena itu, biasanya <code>Mockito.when</code> lebih disukai - tidak ada kesalahan dengan ini.  Tetapi mungkin ada kasus ketika saya ingin menghindari memanggil metode yang diganti - untuk tiruan yang baru dibuat, panggilan seperti itu cukup dapat diterima, tetapi jika saya telah mendefinisikan ulang metode ini atau berurusan dengan mata-mata, itu mungkin tidak diinginkan, dan melemparkan pengecualian tidak akan memungkinkan redefinisi yang diperlukan sama sekali .  Dan di sini mengikat melalui <code>Mockito.do...</code> datang untuk <code>Mockito.do...</code> </p><br><p>  Situasi lain di mana Anda tidak dapat melakukan tanpa metode <code>Mockito.do...</code> menimpa metode yang mengembalikan <code>void</code> : parameter <code>Mockito.when</code> tertunda ketika tidak dapat bekerja dengan metode seperti itu.  <code>Mockito.doReturn</code> , tentu saja, keluar dari pekerjaan, tetapi ada <code>Mockito.doThrow</code> , <code>Mockito.doAnswer</code> . <code>Mockito.doAnswer</code> dan <code>Mockito.doAnswer</code> jarang cukup <code>Mockito.doNothing</code> . Tidak ada. </p><br><p>  Selanjutnya, saya akan membahas sedikit lebih rinci cara mengatur kondisi dan hasil panggilan.  Saya hanya akan mempertimbangkan untuk mengikat melalui <code>Mockito.when</code> - cara alternatif hampir sepenuhnya sama dalam penanganannya. </p><br><h3 id="zadanie-usloviy-vyzova">  Pengaturan kondisi panggilan </h3><br><p>  Contoh di atas menyangkut metode tanpa parameter, dan kondisi panggilan yang terkait adalah mungkin satu hal - fakta panggilan.  Segera setelah parameter muncul, situasinya menjadi lebih rumit.  Minimal, untuk memanggil metode yang perilakunya saya setting, saya perlu menyampaikan sesuatu kepadanya.  Tetapi satu hal lagi yang lebih penting: mungkin ternyata saya tidak selalu ingin mendapatkan reaksi yang diberikan, tetapi hanya ketika saya menyebutnya dengan parameter yang memenuhi persyaratan tertentu.  <code>DataService</code> memiliki metode ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataItemById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code... }</span></span></code> </pre> <br><p>  Jika saya perlu mengatur respons terhadap panggilan apa pun ke metode ini, apa pun argumennya, saya harus menggunakan metode <code>Mockito.any</code> : </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(any())) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  Jika saya perlu mock untuk bereaksi hanya pada nilai argumen tertentu, Anda dapat menggunakan nilai ini secara langsung atau metode <code>Mockito.eq</code> (jika itu adalah kesetaraan) atau <code>Mockito.same</code> (jika diperlukan perbandingan tautan): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// or Mockito.when(dataService.getDataItemById(Mockito.eq("idValue"))) .thenReturn("dataItem");</span></span></code> </pre> <br><p>  Dan jika saya ingin argumen memenuhi beberapa persyaratan, ada sejumlah metode statis khusus yang mudah digunakan dari kelas <code>Mockito</code> sama (misalnya, string dapat diperiksa untuk konten di awal atau di akhir urutan karakter tertentu, pencocokan pola, dll.).  Ada juga metode umum Mockito.argThat (dan analognya untuk tipe primitif) yang menerima implementasi antarmuka fungsional ArgumentMatcher: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById( Mockito.argThat(arg -&gt; arg == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || arg.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>))) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  Kelas <code>ArgumentMatchers</code> dan <code>AdditionalMatchers</code> memungkinkan Anda untuk bekerja dengan beberapa implementasi yang berguna dari antarmuka ini.  Misalnya, <code>AdditionalMatchers.or</code> dan <code>AdditionalMatchers.and</code> memungkinkan Anda untuk menggabungkan korek api lain (catatan: metode statis kelas ini tidak mengembalikan instance korek api, tetapi hanya mengaksesnya!) </p><br><p>  Untuk metode yang sama, Anda bisa mengatur perilaku beberapa kali dengan persyaratan berbeda untuk argumen, dan semua model perilaku yang didefinisikan dengan cara ini akan bertindak secara bersamaan.  Tentu saja, dalam beberapa kasus, mereka mungkin berpotongan - katakanlah, saya akan meminta untuk mengembalikan satu hasil ketika nilai <code>int</code> parameter kurang dari 5 dan yang lainnya ketika nilai genap diterima.  Dalam situasi ini, perilaku yang ditentukan kemudian diutamakan.  Karena itu, ketika mendefinisikan pola perilaku yang kompleks, Anda harus mulai dengan persyaratan terlemah (dalam batas - <code>any()</code> ) dan baru kemudian beralih ke yang lebih spesifik. </p><br><p>  Ketika bekerja dengan metode dengan lebih dari satu argumen, persyaratan yang ditentukan digabungkan sesuai dengan logika AND, yaitu, untuk mendapatkan hasil yang diberikan, SETIAP argumen harus memenuhi persyaratan yang dinyatakan.  Saya tidak menemukan cara untuk mengatur cara sewenang-wenang untuk menggabungkan mereka, meskipun mungkin ada. </p><br><p>  Selain itu, ketika menentukan perilaku metode seperti itu, seseorang tidak dapat menggabungkan metode statis <code>Mockito</code> dan transfer nilai secara langsung.  Gunakan <code>Mockito.eq</code> atau <code>Mockito.same</code> . </p><br><h3 id="zadanie-rezultatov-vyzova">  Mengatur Hasil Panggilan </h3><br><p>  Setelah metode objek tiruan dipanggil, objek harus merespons panggilan.  Konsekuensi utama yang mungkin terjadi adalah mengembalikan hasilnya dan melemparkan pengecualian, dan justru pada opsi-opsi inilah toolkit Mockito dirancang secara utama. </p><br><p>  Dalam kasus paling sederhana yang sudah ditunjukkan di atas, respons terhadap panggilan adalah mengembalikan nilai.  Saya akan memberikan kodenya lagi: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Harap dicatat: Anda hanya dapat mengembalikan objek, tidak ada metode terpisah untuk primitif.  Oleh karena itu, jika metode mengembalikan nilai primitif, dalam situasi seperti itu un / boxing akan terjadi.  Dalam kebanyakan kasus, ini tidak mengganggu, tetapi jika kompilator berpikir sebaliknya, Anda harus setuju dengannya ... atau memasang peringatannya. </p><br><p>  Melempar pengecualian tidak lebih sulit: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException());</code> </pre> <br><p>  Ada cara lain: Anda bisa membuat objek pengecualian dan melemparkannya langsung, atau Anda bisa memberi Mockito hanya kelas pengecualian sehingga itu dibuat secara otomatis: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>  Dalam kedua kasus, sintaks memungkinkan Anda untuk menggunakan dan memeriksa pengecualian, tetapi Mockito tidak akan mengizinkan Anda untuk menjalankan tes seperti itu jika jenis pengecualian tidak cocok dengan metode yang saya ingin paksa melempar pengecualian ini. </p><br><p>  Ketika menggunakan kelas sebagai parameter, konstruktor (bahkan tanpa parameter), serta inisialisasi bidang langsung, diabaikan - objek dibuat melewati mereka (setelah semua, ini Mockito!), Sehingga semua bidang pengecualian yang dilempar akan menjadi <code>null</code> .  Oleh karena itu, jika konten pengecualian penting bagi Anda (misalnya, beberapa <code>type</code> bidang yang memiliki nilai default), Anda harus meninggalkan metode ini dan membuat pengecualian secara manual. </p><br><p>  Opsi reaksi ini cocok jika, sebagai tanggapan terhadap panggilan dengan kondisi tertentu, Anda selalu perlu mengembalikan nilai tertentu, selalu hasil yang sama atau selalu membuang pengecualian yang sama, dan dalam kebanyakan kasus kemampuan ini cukup memadai.  Tetapi bagaimana jika dibutuhkan lebih banyak fleksibilitas?  Misalkan metode saya menerima kumpulan nilai, dan mengembalikan koleksi nilai lain yang terkait dengan yang pertama ke satu (misalnya, memperoleh kumpulan objek data dengan set ID mereka), dan saya ingin menggunakan objek tiruan ini berulang kali dengan set input yang berbeda dalam pengujian data, dapatkan setiap kali hasil yang sesuai.  Anda dapat, tentu saja, menjelaskan reaksi secara terpisah untuk setiap set parameter tertentu, tetapi ada solusi yang lebih mudah - metode <code>Mockito.thenAnswer</code> , alias <code>Mockito.then</code> .  Ia menerima implementasi antarmuka fungsional <code>Answer</code> , satu-satunya metode yang menerima objek kelas <code>InvocationOnMock</code> .  Dari yang terakhir, saya dapat meminta parameter dari pemanggilan metode (satu dengan nomor atau sekaligus dalam bentuk array) dan bertindak dengan mereka sesuka saya.  Misalnya, Anda bisa mendapatkan nilai yang sesuai untuk masing-masing elemen koleksi saya, membentuk koleksi baru dari mereka dan mengembalikannya (catatan: hasil yang diinginkan hanya dikembalikan, dan tidak ditulis ke beberapa bidang objek parameter, seperti yang Anda harapkan): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataByIds(Mockito.any())) .thenAnswer(invocation -&gt; invocation .&lt;List&lt;String&gt;&gt;getArgument(<span class="hljs-number"><span class="hljs-number">0</span></span>).stream() .map(id -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemA"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemB"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }) .collect(Collectors.toList()));</code> </pre> <br><p>  Secara ideologis, ini seperti menulis model metode nyata: mendapatkan parameter, memproses, mengembalikan hasil.          -  ,    - ,      ,     ,    mock-    . </p><br><p>     <code>Answer</code> ,     , â€” , <code>AnswersWithDelay</code> , <code>ReturnsElementsOf</code>  . . </p><br><p>  :  <code>InvocationOnMock</code>   â€”       <code>Object[]</code> ,  generic-. </p><br><p>        â€” <code>thenCallRealMethod</code> .    .     mock-,    spy-.   mock   ,      ,  -   <code>null</code> .  spy   <code>thenCallRealMethod</code>     spy  ;    ,     -      . </p><br><p>        <code>thenAnswer</code> :  <code>InvocationOnMock</code>   <code>callRealMethod()</code> â€”   ,   ""    -  . </p><br><p>    <code>OngoingStubbing</code>    <code>OngoingStubbing</code> ,  ,   ,     .            ,   .  <code>thenReturn</code>  <code>thenThrow</code>   ,  varargs.       . </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"valueA1"</span></span>, <span class="hljs-string"><span class="hljs-string">"valueA2"</span></span>) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>         <code>"valueA1</code> ,  â€” <code>"valueA2</code> ( ),   (  )    <code>IllegalArgumentException</code> . </p><br><h2 id="slezhenie-za-vyzovami-metodov">     </h2><br><p>        :          (mock'    ),     .   ,     :   ,          ,       .      <code>verify</code> . </p><br><p>  ,           ,  : </p><br><pre> <code class="java hljs">Mockito.verify(dataService).getDataById(Mockito.any());</code> </pre> <br><p>      ,            <code>getDataById</code> ,  ,           . ,             Mockito,      <code>when</code> ,   ,  ,         mock-. , ,  ,      <code>when</code>  , â€”      mock',       (. ). </p><br><p>           : </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>           <code>Mockito.times</code> ;       <code>Mockito.never</code> .    <code>Mockito.atLeast</code> (  <code>Mockito.atLeastOnce</code>   1)  <code>Mockito.atMost</code> ,       ,    <code>Mockito.only</code> , ,         mock-  (. .     ). </p><br><p>  ,         <code>Mockito</code> ,     <code>VerificationAfterDelay</code>  <code>VerificationWithTimeout</code> ,    <code>Mockito.after</code>  <code>Mockito.timeout</code> .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.after(1000).times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>    ,    mock   ,      ,              ,       .        .   <code>after</code>  <code>timeout</code>  ,          ,    ,    â€”   ,     .  ,   <code>timeout</code>         â€”       .   <code>VerificationWithTimeout</code>   <code>never</code>  <code>atMost</code> :         . </p><br><p>  ,             <code>Mockito.any()</code> .          ,   ,     â€”    Mockito       ,    ,     . Mock-     ,        ,   , , : </p><br><pre> <code class="java hljs">dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"b"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).getDataById(Mockito.any()); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); Mockito.verify(dataService, Mockito.never()).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verifyNoMoreInteractions(dataService);</code> </pre> <br><p>      <code>verifyNoMoreInteractions</code> (  <code>verifyZeroInteractions</code> ) â€”    -  (            <code>verify</code> )    mock- â€”    .  :   varargs,     ,     ,         <strong> </strong> ! </p><br><p>       ,   ,      ,     .   ,    <code>InOrder</code> : </p><br><pre> <code class="java hljs">InOrder inOrder = Mockito.inOrder(dataService);</code> </pre> <br><p>     varargs;     â€”    mock-   ,    <code>InOrder</code>                .     <code>verify</code>    ,   <code>Mockito.verify</code> : </p><br><pre> <code class="java hljs">inOrder.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).saveData(any()); inOrder.verify(dataService).getData();</code> </pre> <br><p>       ,         <code>saveData</code> , <strong> </strong>  â€” <code>getData</code> .  ,   <code>InOrder</code>    ,      â€”     . </p><br><p>       ,   ,       â€” , .      -      ,    ,      â€”  ,     ,    .     <code>ArgumentCaptor</code>    <code>capture()</code> .  Sebagai contoh: </p><br><pre> <code class="java hljs">DataSearchRequest request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSearchRequest(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(System.currentTimeMillis()), <span class="hljs-number"><span class="hljs-number">50</span></span>); dataService.getDataByRequest(request); ArgumentCaptor&lt;DataSearchRequest&gt; requestCaptor = ArgumentCaptor.forClass(DataSearchRequest.class); Mockito.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataByRequest(requestCaptor.capture()); assertThat(requestCaptor.getAllValues()).hasSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); DataSearchRequest capturedArgument = requestCaptor.getValue(); assertThat(capturedArgument.getId()).isNotNull(); assertThat(capturedArgument.getId()).isEqualTo(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>); assertThat(capturedArgument.getUpdatedBefore()).isAfterYear(<span class="hljs-number"><span class="hljs-number">1970</span></span>); assertThat(capturedArgument.getLength()).isBetween(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br><p> <code>ArgumentCaptor</code>       ,      <strong> </strong> ,   <code>ArgumentCaptor</code>  . <code>getValue()</code>    , <code>getAllValues()</code> â€”     .   ,         ,   . </p><br><h2 id="mock-obekty-kak-znacheniya-poley-i-annotacii-mockito"> Mock-      Mockito </h2><br><p>      ,     mock-   ,      â€”     <code>@Mock</code>   -       : </p><br><pre> <code class="java hljs">MockitoAnnotations.initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br><p> (  ,       mock',       ) </p><br><p>  spy   <code>@Spy</code> â€”     <code>@Mock</code> â€¦   spy   ,      , ?          ,      â€”  spy     . </p><br><p>   <code>@Captor</code>    <code>ArgumentCaptor</code> â€”   , ,    . </p><br><p>   <code>@InjectMocks</code> .       -  Mockito,          .       mock-   ,   .        ,    .  -     ,     <code>null</code> ,   -     .         (      )  dependency injection. </p><br><h2 id="otkat-povedeniya-k-defoltnomu-i-sessii-mockito">       Mockito </h2><br><p>         ,  :   mock (spy, argument captor...),   ,    , .    ,  mock' â€”    ,    . JUnit           ,      ,    TestNG   â€”       . , ,   mock'    ,     ,   ,         . .  ,  ,  â€”  ,          . </p><br><p>   ,             mock-    .  TestNG     <code>@BeforeMethod</code> ( <code>@AfterMethod</code>  ).           mock'   ,        ,           (    JUnit â€”      <code>@Before</code> ). </p><br><p>   ,     , â€”   <code>Mockito.reset</code>  <code>Mockito.clearInvocations</code> .   varargs,      mock'.      ,    .     :     (,              )  ,   /   mock'    , â€”       .     ,    mock'       . .      , ,             . </p><br><p>       (,  ) â€”     <code>MockitoAnnotations.initMocks(this);</code>  .    ""  ,   Mockito. </p><br><p>    â€”     Mockito.    .     mock- ,          ( mock'      ).          ,      <code>MockitoSession</code> ,           .     TestNG: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> DataService dataService; MockitoSession session; <span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ session = Mockito.mockitoSession() .initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .startMocking(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code using the dataService field } @AfterMethod public void afterMethod() { session.finishMocking(); }</span></span></code> </pre> <br><p>  ,        â€”  ,  "" (,     )  ,   . </p><br><h2 id="chto-eschyo">  ? </h2><br><p>      Mockito:  mock  spy-,        .      ,       .  ,  , : </p><br><ul><li>  Mockito   mock-   <code>MockSettings</code> (      â€” ,   mock'    -  ); </li><li>     mock-,   <code>MockingDetails</code> ; </li><li>   <code>BDDMockito</code>   <code>Mockito</code> ; </li><li>     (    JUnit       Mockito,     ). </li></ul><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Mockito</a> .           javadoc'  <code>Mockito</code> . </p><br><p> , ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444982/">https://habr.com/ru/post/id444982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444972/index.html">Arsitektur Intel Gen11 GPU dan kartu grafis diskrit dari Intel</a></li>
<li><a href="../id444974/index.html">Kriptografi di Jawa. Message ClassDigest</a></li>
<li><a href="../id444976/index.html">Quester - Platform untuk membuat dan menyelesaikan pencarian (Beta)</a></li>
<li><a href="../id444978/index.html">Otoritas UE mendenda Google $ 1,7 miliar karena memblokir iklan pesaing</a></li>
<li><a href="../id444980/index.html">Parsing kesalahan kritis dalam algoritma enkripsi KIB SEARCHINFORM</a></li>
<li><a href="../id444984/index.html">Dari mana datangnya foto untuk menguji sistem pengenalan wajah?</a></li>
<li><a href="../id444986/index.html">IETF Menyetujui ACME - Ini adalah Standar untuk Bekerja dengan Sertifikat SSL</a></li>
<li><a href="../id444992/index.html">Kesalahan dibangun ke dalam sistem: peran mereka dalam statistik</a></li>
<li><a href="../id444994/index.html">Tentang drive dan penggunaannya pada komputer modern</a></li>
<li><a href="../id444996/index.html">Redis Streaming sebagai Struktur Data Bersih</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>