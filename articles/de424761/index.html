<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèæ üë®üèª‚Äç‚öñÔ∏è üé¨ Einf√ºhrung in das Booten und Booten von Linux-Kerneln ü§Æ üë∑üèº ‚ôêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Also haben wir den n√§chsten, vierten Stream in Folge des Linux Administrator- Kurses er√∂ffnet, der sicher seine Nische neben dem Dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in das Booten und Booten von Linux-Kerneln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424761/">  Hallo allerseits!  Also haben wir den n√§chsten, vierten Stream in Folge des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Administrator-</a> Kurses er√∂ffnet, der sicher seine Nische neben dem Devopersky-Kurs einnimmt.  Mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lehrer</a> , mehr Informationen und St√§nde.  Nun, wie immer, interessantere Informationen, die die Lehrer aufgegriffen haben. <br><br>  Lass uns gehen. <br><br>  Haben Sie sich jemals gefragt, was Ihr System ben√∂tigt, um Anwendungen ausf√ºhren zu k√∂nnen? <br><br>  Das Verst√§ndnis der Prozesse zum Laden des Kernels und Starten des Linux-Systems ist wichtig, um Linux zu konfigurieren und Startprobleme zu l√∂sen.  Dieser Artikel bietet einen √úberblick √ºber den Kernel-Boot-Prozess mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GRUB2-Bootloader</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom Systemd-Initialisierungssystem ausgef√ºhrten</a> Start. <br><br>  Tats√§chlich sind zwei Ereignisse erforderlich, um einen Linux-Computer in einen funktionsf√§higen Zustand zu versetzen: Kernel-Boot (Boot) und Systemstart (Startup).  Der Kernel-Startvorgang beginnt beim Einschalten des Computers und endet mit der Initialisierung und dem Start von systemd durch den Kernel.  Danach beginnt der Prozess des Startens des Systems, und er ist es, der den Linux-Computer in einen funktionsf√§higen Zustand versetzt. <br><br><img src="https://habrastorage.org/webt/fn/kk/zz/fnkkzz6scajfvnktxj_5hwxavby.png"><a name="habracut"></a><br><br>  Im Allgemeinen ist das Laden des Kernels und Starten des Linux-Systems recht einfach.  Es besteht aus den folgenden Schritten, die in den folgenden Abschnitten ausf√ºhrlicher beschrieben werden: <br><br><ul><li>  BIOS POST; </li><li>  Laden des Kernels (GRUB2); </li><li>  Kernel-Initialisierung; </li><li>  Ausf√ºhren von systemd, dem √ºbergeordneten Element aller Prozesse. </li></ul><br>  Bitte beachten Sie, dass sich dieser Artikel mit GRUB2 und systemd befasst, da sie das Kernel-Loader- und Initialisierungsprogramm f√ºr die meisten Distributionen sind.  Bisher wurden andere Optionen verwendet, die manchmal in einigen Distributionen noch vorhanden sind. <br><br>  <b>Kernel-Boot-Prozess</b> <br><br>  Der Kernel-Boot-Prozess kann auf verschiedene Arten initiiert werden.  Wenn der Computer ausgeschaltet ist, wird durch Einschalten des Computers der Startvorgang gestartet.  Zweitens kann der Benutzer den Kernel-Startvorgang programmgesteuert √ºber die GUI oder die Befehlszeile zum Neustart initiieren, wenn bereits ein lokaler Benutzer auf dem Computer ausgef√ºhrt wird, einschlie√ülich des Root-Benutzers und des nicht privilegierten Benutzers.  Durch einen Neustart wird der Computer zuerst ausgeschaltet und erst dann neu gestartet. <br><br>  <b>BIOS POST</b> <b><br></b> <br>  Der erste Schritt im Bootprozess des Linux-Kernels hat nichts mit Linux zu tun.  Dies ist der Hardware-Teil des Prozesses, der f√ºr alle Betriebssysteme gleich ist.  Wenn der Computer mit Strom versorgt wird, wird als erstes POST (Power On Self Test) gestartet, das Teil des BIOS (Basic I / O System, Basic Input / Output System) ist. <br><br>  Als IBM 1981 seinen ersten Personal Computer auf den Markt brachte, wurde das BIOS zur Initialisierung von Hardwarekomponenten entwickelt.  POST ist Teil des BIOS, dessen Aufgabe es ist, den ordnungsgem√§√üen Betrieb der Computerausr√ºstung sicherzustellen.  Wenn der POST fehlschl√§gt, funktioniert der Computer m√∂glicherweise nicht richtig und der Startvorgang wird nicht fortgesetzt. <br><br>  Der BIOS-POST √ºberpr√ºft die Grundleistung der Hardware und verursacht dann einen BIOS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt</a> - INT 13H, der die Bootsektoren des Kernels auf allen verbundenen Ger√§ten mit der F√§higkeit zum Booten findet.  Der erste gefundene Sektor, der einen g√ºltigen Startdatensatz enth√§lt, wird in den RAM geladen, wonach die Steuerung vom Startsektor auf den Code √ºbertragen wird. <br>  Der Bootsektor ist nur die erste Stufe.  Die meisten Linux-Distributionen verwenden eine von drei Bootloader-Optionen: GRUB, GRUB2 und LILO.  GRUB2 ist das neueste und wird jetzt viel h√§ufiger verwendet als √§ltere Versionen. <br><br>  <b>GRUB2</b> <br><br>  GRUB2 steht f√ºr "GRand Unified Bootloader, Version 2" und ist jetzt der Haupt-Bootloader f√ºr die meisten modernen Linux-Distributionen.  GRUB2 ist ein Programm, das einen Computer so intelligent macht, dass er den Kernel des Betriebssystems finden und in den Speicher laden kann.  Da es einfacher ist, nur GRUB zu sprechen und zu schreiben als GRUB2, werde ich in diesem Artikel wahrscheinlich den Begriff GRUB verwenden, aber GRUB2 implizieren, sofern nicht anders angegeben. <br><br>  GRUB ist mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Multiboot-Spezifikation</a> kompatibel, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> verschiedene Versionen von Linux und anderen Betriebssystemen geladen werden k√∂nnen.  Es kann auch die Startaufzeichnung von propriet√§ren Betriebssystemen in einer Kette starten. <br><br>  Mit GRUB kann der Benutzer auch aus mehreren m√∂glichen Kernel-Downloads f√ºr jede bereitgestellte Linux-Distribution ausw√§hlen.  Dies erm√∂glicht das Herunterladen der vorherigen Version des Kernels, wenn die aktualisierte Version nicht korrekt gestartet werden kann oder mit einem wichtigen Teil der Software nicht kompatibel ist.  GRUB kann in der Datei <code>/boot/grub/grub.conf</code> konfiguriert werden. <br><br>  GRUB1 gilt heute als veraltet und wird in den meisten modernen Distributionen durch GRUB2 ersetzt, die neu geschriebene Version.  Red Hat-basierte Distributionen, die um Fedora 15 und CentOS / RHEL 7 auf GRUB2 aktualisiert wurden. GRUB2 verf√ºgt √ºber die gleiche Startfunktionalit√§t wie GRUB1, bietet jedoch zus√§tzlich Mainframe-√§hnliche, befehlsbasierte Umgebungen vor dem Betriebssystem und mehr Flexibilit√§t in der Phase vor dem Start.  GRUB2 ist in <code>/boot/grub2/grub.cfg</code> konfiguriert. <br><br>  Die Hauptaufgabe von GRUB besteht darin, den Linux-Kernel in den Speicher zu laden und auszuf√ºhren.  Beide Versionen von GRUB funktionieren in drei Schritten √§hnlich, aber in diesem Artikel werde ich GRUB2 verwenden, um zu beschreiben, wie GRUB funktioniert.  Das Konfigurieren von GRUB und GRUB2 und die Verwendung von GRUB2-Befehlen geht √ºber den Rahmen dieses Artikels hinaus. <br><br>  Obwohl GRUB2 offiziell keine Schrittnummerierung verwendet, werde ich sie der Einfachheit halber in diesem Artikel verwenden. <br><br>  <b>Stufe 1</b> <br><br>  Wie bereits im Abschnitt BIOS-POST erw√§hnt, sucht das BIOS am Ende des POST nach Boot-Datens√§tzen auf angeschlossenen Datentr√§gern, die sich normalerweise im Master-Boot-Datensatz (MBR) befinden. Anschlie√üend l√§dt es den ersten gefundenen Datensatz in den Speicher und beginnt mit der Ausf√ºhrung.  Der Bootstrap-Code, dh die erste Stufe von GRUB2, nimmt nur sehr wenig Speicherplatz ein, da er zusammen mit der Partitionstabelle in den ersten 512-Byte-Sektor auf der Festplatte passen muss.  Der Gesamtspeicherplatz f√ºr den Bootstrap-Code selbst im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-MBR</a> betr√§gt 446 Byte.  Die 446-Byte-Datei f√ºr Stufe 1 hei√üt boot-img und enth√§lt keine Partitionstabelle - sie wird separat zum Boot-Datensatz hinzugef√ºgt. <br><br>  Da der Startdatensatz so klein sein sollte, ist er nicht sehr ‚Äûintelligent‚Äú und versteht die Struktur des Dateisystems nicht.  Daher besteht der einzige Zweck von Schritt 1 darin, Schritt 1.5 zu erkennen und zu laden.  Um dies zu erreichen, muss sich Schritt 1.5 von GRUB im Bereich zwischen dem Startdatensatz selbst und der ersten Partition auf der Festplatte befinden.  Nach dem Laden von Stufe 1.5 GRUB in den RAM √ºbertr√§gt Stufe 1 die Steuerung auf Stufe 1.5. <br><br>  <b>Stufe 1.5</b> <br><br>  Wie oben erw√§hnt, sollte Schritt 1.5 von GRUB zwischen dem Startdatensatz und der ersten Partition auf der Festplatte liegen.  Historisch gesehen bleibt dieser Raum aus technischen Gr√ºnden ungenutzt.  Die erste Partition auf der Festplatte startet in Sektor 63, und unter Ber√ºcksichtigung des MBR in Sektor 0 gibt es 62 512-Byte-Sektoren - 31744 Byte -, in denen Sie die Datei core.img speichern k√∂nnen - Stufe 1,5 GRUB.  Die Datei core.img wiegt 25389 Byte. Dies ist genug Speicherplatz, um sie zwischen dem MBR und der ersten Festplattenpartition zu speichern. <br><br>  Da f√ºr Schritt 1.5 mehr Code verwendet werden kann, kann es ausreichen, mehrere g√§ngige Dateisystemtreiber zu enthalten, z. B. Standard-EXT- und andere Linux-Dateisysteme, FAT und NTFS.  core.img in GRUB2 ist komplexer und funktionaler als in Schritt 1.5 von GRUB1.  Dies bedeutet, dass sich Stufe 2 von GRUB2 m√∂glicherweise in einem Standard-EXT-Dateisystem befindet, jedoch nicht in einem logischen Volume.  Daher ist der Standardspeicherort f√ºr Dateien der Stufe 2 das Dateisystem <code>/boot</code> bzw. <code>/boot/grub2</code> . <br><br>  Beachten Sie, dass sich das Verzeichnis / boot im von GRUB unterst√ºtzten Dateisystem befinden muss.  Nicht alle Dateisysteme unterst√ºtzen diese Funktion.  Die Aufgabe von Stufe 1.5 besteht darin, mit den erforderlichen Dateisystemtreibern zu beginnen, um nach Dateien der Stufe 2 im / boot-Dateisystem zu suchen und die erforderlichen Treiber zu laden. <br><br>  <b>Stufe 2</b> <br><br>  Alle GRUB Stage 2-Dateien befinden sich im <code>/boot/grub2</code> und in mehreren Unterverzeichnissen.  GRUB2 verf√ºgt nicht √ºber eine Image-Datei wie in den Schritten 1 und 2. Stattdessen besteht sie haupts√§chlich aus Laufzeit-Kernel-Modulen, die nach Bedarf aus dem <code>/boot/grub2/i386-pc</code> geladen werden. <br><br>  Die Aufgabe von GRUB2 Stufe 2 besteht darin, den Linux-Kernel zu erkennen und in den RAM zu laden und die Steuerung der Computersteuerung auf den Kernel zu √ºbertragen.  Der Kernel und die zugeh√∂rigen Dateien befinden sich im Verzeichnis <code>/boot</code> .  Kernel-Dateien sind leicht zu erkennen, da ihre Namen mit vmlinuz beginnen.  Sie k√∂nnen den Inhalt des Verzeichnisses <code>/boot</code> auflisten, um die aktuell auf Ihrem System installierten Kernel anzuzeigen. <br><br>  GRUB2 unterst√ºtzt wie GRUB1 das Laden eines von mehreren Linux-Kerneln.  Das Red Hat-Paketverwaltungssystem unterst√ºtzt das Speichern mehrerer Versionen des Kernels, sodass Sie bei Problemen mit der neuesten Version die alte Version des Kernels laden k√∂nnen.  Standardm√§√üig bietet GRUB ein vorinstalliertes Men√º installierter Kernel, einschlie√ülich der Rettungsoption und nach der Konfiguration der Wiederherstellungsoption. <br><br>  Stufe 2 GRUB2 l√§dt den ausgew√§hlten Kernel in den Speicher und √ºbertr√§gt die Kontrolle √ºber die Computersteuerung auf den Kernel. <br><br>  <b>Der Kern</b> <br><br>  Alle Kerne haben ein selbstextrahierendes, komprimiertes Format, um Platz zu sparen.  Die Kernel befinden sich zusammen mit dem urspr√ºnglichen RAM-Image und einer Liste der Partitionen auf den Festplatten im Verzeichnis <code>/boot</code> . <br><br>  Nachdem der ausgew√§hlte Kernel in den Speicher geladen wurde und mit der Ausf√ºhrung beginnt, muss er sich zun√§chst selbst aus der komprimierten Version der Datei extrahieren, bevor er n√ºtzliche Arbeiten ausf√ºhren kann.  Sobald die Extraktion erfolgt ist, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geladen</a> , das das alte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SysV-Init-</a> Programm ersetzt, und die Steuerung an dieses √ºbertragen. <br><br>  Dies ist das Ende des Kernel-Boot-Prozesses.  Zu diesem Zeitpunkt werden der Linux-Kernel und systemd ausgef√ºhrt, k√∂nnen jedoch keine n√ºtzlichen Aufgaben f√ºr den Endbenutzer ausf√ºhren, da nichts anderes zu tun ist. <br><br>  <b>Systemstartprozess</b> <br><br>  Der Systemstartprozess folgt dem Kernel-Boot-Prozess und bringt den Linux-Computer zum Laufen. <br><br>  <b>systemd</b> <br><br>  systemd ist das √ºbergeordnete Element aller Prozesse, die daf√ºr verantwortlich sind, den Linux-Host in einen effizienten Zustand zu versetzen.  Einige seiner Funktionen, die umfangreicher sind als die im alten Initialisierungsprogramm vorgestellten, sollten viele Aspekte des laufenden Linux-Hosts verwalten, einschlie√ülich des Bereitstellens des Dateisystems, des Startens und Verwaltens von Systemdiensten, die f√ºr ein effizientes Arbeiten des Linux-Hosts erforderlich sind.  Alle systemd-Aufgaben, die nicht mit dem Systemstartprozess zusammenh√§ngen, werden in diesem Artikel nicht behandelt. <br><br>  Zun√§chst stellt systemd Dateisysteme wie in <code>/etc/fstab</code> definiert bereit, einschlie√ülich aller Auslagerungsdateien und Partitionen.  Zu diesem Zeitpunkt kann er auf die Konfigurationsdateien in <code>/etc</code> zugreifen, einschlie√ülich seiner eigenen.  Es verwendet seine eigene Konfigurationsdatei <code>/etc/systemd/system/default.target</code> , um das Ziel zu bestimmen, f√ºr das der Host geladen werden soll.  Die Datei default.target ist nur ein Symlink zur realen Zieldatei.  Bei einer Desktop-Workstation ist dies normalerweise ein grafisches Ziel, das Runlevel 5 im alten SystemV-Initialisierer entspricht.  F√ºr den Server ist der Standardwert wahrscheinlich multi-user.target, √§hnlich wie bei Runlevel 3 in SystemV.  Emergency.Target √§hnelt dem Einzelbenutzermodus. <br><br>  Beachten Sie, dass Ziele und Dienste Systemeinheiten sind. <br><br>  Die folgende Tabelle 1 zeigt einen Vergleich aller systemd-Ziele mit den alten Runlevels in SystemV.  Systemd-Zielaliasnamen werden aus Gr√ºnden der Abw√§rtskompatibilit√§t von systemd bereitgestellt.  Ziel-Aliase erm√∂glichen es Skripten - und vielen Systemadministratoren, einschlie√ülich mir -, SystemV-Befehle wie init3 zu verwenden, um die Ausf√ºhrungsebenen zu √§ndern.  Nat√ºrlich werden die SystemV-Befehle von systemd zur Interpretation und Ausf√ºhrung geleitet. <br><div class="scrollable-table"><table><tbody><tr><th>  Systemv Runlevel </th><th>  <nobr>systemd Ziel</nobr> </th><th>  <nobr>systemd Ziel-</nobr> Aliase </th><th>  Beschreibung </th></tr><tr><td></td><td>  halt.target </td><td></td><td>  H√§lt das System an, ohne den Strom auszuschalten </td></tr><tr><td>  0 </td><td>  poweroff.target </td><td>  runlevel0.target </td><td>  H√§lt das System an und schaltet die Stromversorgung aus </td></tr><tr><td>  S. </td><td>  Notfallziel </td><td></td><td>  Einzelbenutzermodus.  Dienste werden nicht ausgef√ºhrt.  Dateisysteme sind nicht gemountet.  Dies ist die grundlegendste Bedienebene.  F√ºr die Benutzerinteraktion mit dem System wird nur die Notfall-Shell in der Hauptkonsole gestartet. </td></tr><tr><td>  1 </td><td>  retten.Ziel </td><td>  runlevel1.target </td><td>  Das Basissystem, einschlie√ülich der Bereitstellung des Dateisystems mit den grundlegendsten Diensten und der Rettungsshell in der Hauptkonsole. </td></tr><tr><td>  2 </td><td></td><td>  runlevel2.target </td><td>  Mehrbenutzermodus ohne NFS, aber alle Nicht-GUI-Dienste werden ausgef√ºhrt. </td></tr><tr><td>  3 </td><td>  multi-user.target </td><td>  runlevel3.target </td><td>  Alle Dienste werden ausgef√ºhrt, jedoch nur √ºber die Befehlszeilenschnittstelle (CLI). </td></tr><tr><td>  4 </td><td></td><td>  runlevel4.target </td><td>  Wird nicht benutzt. </td></tr><tr><td>  5 </td><td>  graphical.target </td><td>  runlevel5.target </td><td>  Mehrbenutzermodus mit GUI. </td></tr><tr><td>  6 </td><td>  reboot.target </td><td>  runlevel6.target </td><td>  Starten Sie neu </td></tr><tr><td></td><td>  default.target </td><td></td><td>  Dieses Ziel hat immer einen Symlink mit multi-user.target oder graphical.target.  systemd verwendet immer default.target, um das System zu starten.  default.target sollte niemals mit halt.target, poweroff.target oder reboot.target verkn√ºpft werden. </td></tr></tbody></table></div><br>  <i>Tabelle 1: Vergleich der SystemV-Kontrollstufen mit systemd-Zielen und einigen Zielaliasen.</i> <br><br>  Jedes Ziel verf√ºgt √ºber eine Reihe von Abh√§ngigkeiten, die in der Konfigurationsdatei beschrieben sind.  systemd f√ºhrt die notwendigen aus.  Diese Abh√§ngigkeiten sind die Dienste, die zum Ausf√ºhren eines Linux-Hosts mit einer bestimmten Funktionalit√§t erforderlich sind.  Wenn alle in den Zielkonfigurationsdateien aufgef√ºhrten Abh√§ngigkeiten geladen und gestartet wurden, arbeitet das System auf dieser Zielebene. <br><br>  systemd durchsucht auch veraltete SystemV-Initialisierungsverzeichnisse nach Startdateien.  Wenn dies der Fall ist, verwendet systemd sie als Konfigurationsdateien, um die in den Dateien beschriebenen Dienste auszuf√ºhren.  Ein veralteter Netzwerkdienst ist ein gutes Beispiel f√ºr einen Dienst, der weiterhin SystemV-Startdateien in Fedora verwendet. <br><br>  Abbildung 1 unten wird direkt von der Start <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Hauptseite</a> kopiert.  Es zeigt die allgemeine Abfolge der Ereignisse w√§hrend des Starts von systemd und die grundlegenden Anforderungen, um den Erfolg sicherzustellen. <br><br>  Die Ziele sysinit.target und basic.target k√∂nnen beim Systemstart als Pr√ºfpunkte betrachtet werden.  Obwohl eines der Ziele von systemd darin besteht, Systemdienste parallel auszuf√ºhren, m√ºssen einige Dienste und Funktionsziele vor anderen gestartet werden.  Diese Kontrollpunkte k√∂nnen erst √ºbergeben werden, wenn alle erforderlichen Dienste und Ziele abgeschlossen sind. <br><br>  Somit ist sysinit.target erreicht, wenn alle Einheiten, von denen es abh√§ngt, abgeschlossen sind.  Alle folgenden Einheiten sollten abgeschlossen sein: Mounten von Dateisystemen, Einrichten von Auslagerungsdateien, Starten von udev, Festlegen des Anfangszustands des Zufallszahlengenerators, Initialisieren von Diensten auf niedriger Ebene, Einrichten von Kryptografiediensten, wenn mindestens ein Dateisystem verschl√ºsselt ist.  In sysinit.target k√∂nnen sie parallel ausgef√ºhrt werden. <br>  sysinit.target f√ºhrt alle Dienste und Einheiten auf niedriger Ebene aus, die f√ºr die Mindestfunktionalit√§t des Systems erforderlich sind, sowie diejenigen, die f√ºr den Wechsel zu basic.target erforderlich sind. <br><br><img src="https://habrastorage.org/webt/gx/k_/yj/gxk_yjpanfeksjnoiyfxob5bqlw.png"><br>  <i>Abbildung 1. Systemd-Startzuordnung</i> <br><br>  Nach der Ausf√ºhrung von sysinit.target startet systemd basic.target, beginnend mit allen Einheiten, die zur Ausf√ºhrung erforderlich sind.  Das Basisziel bietet zus√§tzliche Funktionen, indem die f√ºr das n√§chste Ziel erforderlichen Einheiten gestartet werden, einschlie√ülich des Festlegens von Pfaden zu verschiedenen ausf√ºhrbaren Verzeichnissen, Kommunikationssockets und Timern. <br><br>  Schlie√ülich k√∂nnen Sie mit der Initialisierung von Zielen auf Benutzerebene beginnen: multi-user.target oder graphical.target.  Es ist zu beachten, dass multi-user.target erreicht werden muss, bevor die Abh√§ngigkeiten des Grafikziels ausgef√ºhrt werden. <br><br>  Die in Abbildung 1 unterstrichenen Ziele sind typische Startziele.  Der Systemstart endet, wenn einer von ihnen erreicht ist.  Wenn multi-user.target das Standardziel ist, wird in der Konsole die Anmeldung im Textmodus angezeigt.  Wenn graphical.target standardm√§√üig angegeben ist, wird eine grafische Anmeldung angezeigt.  Die Benutzeroberfl√§che des Anmeldebildschirms h√§ngt vom verwendeten Bildschirmmanager ab. <br><br>  <b>Die Probleme</b> <br><br>  Ich musste k√ºrzlich den Standard-Boot-Kernel auf einem Linux-Computer √§ndern, der GRUB2 verwendete.  Ich habe festgestellt, dass einige Befehle nicht mehr richtig funktionieren oder dass ich sie irgendwie falsch verwendet habe.  Ich wei√ü immer noch nicht, was das Problem war, es wird mehr Zeit brauchen, um es zu untersuchen. <br><br>  Der Befehl grub2-set-default hat den Standard-Kernel-Index in der Datei <code>/etc/default/grub</code> falsch konfiguriert, sodass der gew√ºnschte alternative Kernel nicht geladen wurde.  Ich habe <code>/etc/default/grub GRUB_DEFAULT=saved</code> manuell ge√§ndert. <code>/etc/default/grub GRUB_DEFAULT=saved</code> in <code>GRUB_DEFAULT=2</code> , wobei 2 der Index des installierten Kernels ist, den ich ausf√ºhren wollte.  Dann habe ich den <code>grub2-mkconfig &gt; /boot/grub2/grub.cfg</code> ausgef√ºhrt, um eine neue Grub-Konfigurationsdatei zu erstellen.  Dieser Trick hat funktioniert und ein alternativer Kernel wurde gestartet. <br><br>  <b>Schlussfolgerungen</b> <br><br>  GRUB2 und das Systemd-Initialisierungssystem sind Schl√ºsselkomponenten f√ºr die Kernel-Boot- und Systemstartphasen der meisten modernen Linux-Distributionen.  Trotz der Widerspr√ºche, insbesondere in Bezug auf systemd, arbeiten diese beiden Komponenten gut zusammen, um den Kernel zu laden und alle Systemdienste auszuf√ºhren, die zum Erstellen eines funktionierenden Linux-Systems erforderlich sind. <br>  Obwohl ich GRUB2 und systemd insgesamt als komplexer betrachte als ihre Vorg√§nger, sind sie nicht schwieriger zu beherrschen und zu verwalten.  Die Handb√ºcher enthalten viele Informationen zu systemd, und auf freedesktop.org wird die Liste der Seiten vollst√§ndig dargestellt.  Weitere Informationen finden Sie unter den folgenden Links: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU GRUB</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU GRUB Manua</a> l (GNU.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Master Boot Record</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiboot-Spezifikation</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemd-Startvorgang</a> (Freedesktop.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd Index der Manpages</a> (Freedesktop.org) </li></ul><br><br>  Das ist alles.  Wir warten hier auf Fragen und Kommentare oder sie k√∂nnen direkt in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer offenen Lektion gestellt werden</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424761/">https://habr.com/ru/post/de424761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424747/index.html">Der Ort, an dem der Klang lebt</a></li>
<li><a href="../de424751/index.html">Wie das einheitliche biometrische System funktioniert</a></li>
<li><a href="../de424753/index.html">Was ist neu in YouTrack 2018.3?</a></li>
<li><a href="../de424755/index.html">Geld liebt die Rechnung: wie Autos Rechnungen sortieren</a></li>
<li><a href="../de424757/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Fachkr√§fte im Bereich IT im Oktober 2018</a></li>
<li><a href="../de424763/index.html">Ein Texteditor ist nicht Ihre h√∂chste Mathematik, hier m√ºssen Sie nachdenken</a></li>
<li><a href="../de424765/index.html">Zustandsverwaltung in Flatteranwendungen</a></li>
<li><a href="../de424767/index.html">Wir machen einen Kuchen aus Habr. Wieder</a></li>
<li><a href="../de424771/index.html">Pers√∂nliche Erfahrung: von einer Idee und einem leeren Blatt bis zu einer Entwurfsversion einer Website</a></li>
<li><a href="../de424773/index.html">Biopharma und numerische Modellierung: Amgen Erfahrung und Praxis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>