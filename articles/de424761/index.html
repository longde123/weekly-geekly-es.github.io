<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 👨🏻‍⚖️ 🎬 Einführung in das Booten und Booten von Linux-Kerneln 🤮 👷🏼 ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Also haben wir den nächsten, vierten Stream in Folge des Linux Administrator- Kurses eröffnet, der sicher seine Nische neben dem Dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in das Booten und Booten von Linux-Kerneln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424761/">  Hallo allerseits!  Also haben wir den nächsten, vierten Stream in Folge des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux Administrator-</a> Kurses eröffnet, der sicher seine Nische neben dem Devopersky-Kurs einnimmt.  Mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lehrer</a> , mehr Informationen und Stände.  Nun, wie immer, interessantere Informationen, die die Lehrer aufgegriffen haben. <br><br>  Lass uns gehen. <br><br>  Haben Sie sich jemals gefragt, was Ihr System benötigt, um Anwendungen ausführen zu können? <br><br>  Das Verständnis der Prozesse zum Laden des Kernels und Starten des Linux-Systems ist wichtig, um Linux zu konfigurieren und Startprobleme zu lösen.  Dieser Artikel bietet einen Überblick über den Kernel-Boot-Prozess mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GRUB2-Bootloader</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom Systemd-Initialisierungssystem ausgeführten</a> Start. <br><br>  Tatsächlich sind zwei Ereignisse erforderlich, um einen Linux-Computer in einen funktionsfähigen Zustand zu versetzen: Kernel-Boot (Boot) und Systemstart (Startup).  Der Kernel-Startvorgang beginnt beim Einschalten des Computers und endet mit der Initialisierung und dem Start von systemd durch den Kernel.  Danach beginnt der Prozess des Startens des Systems, und er ist es, der den Linux-Computer in einen funktionsfähigen Zustand versetzt. <br><br><img src="https://habrastorage.org/webt/fn/kk/zz/fnkkzz6scajfvnktxj_5hwxavby.png"><a name="habracut"></a><br><br>  Im Allgemeinen ist das Laden des Kernels und Starten des Linux-Systems recht einfach.  Es besteht aus den folgenden Schritten, die in den folgenden Abschnitten ausführlicher beschrieben werden: <br><br><ul><li>  BIOS POST; </li><li>  Laden des Kernels (GRUB2); </li><li>  Kernel-Initialisierung; </li><li>  Ausführen von systemd, dem übergeordneten Element aller Prozesse. </li></ul><br>  Bitte beachten Sie, dass sich dieser Artikel mit GRUB2 und systemd befasst, da sie das Kernel-Loader- und Initialisierungsprogramm für die meisten Distributionen sind.  Bisher wurden andere Optionen verwendet, die manchmal in einigen Distributionen noch vorhanden sind. <br><br>  <b>Kernel-Boot-Prozess</b> <br><br>  Der Kernel-Boot-Prozess kann auf verschiedene Arten initiiert werden.  Wenn der Computer ausgeschaltet ist, wird durch Einschalten des Computers der Startvorgang gestartet.  Zweitens kann der Benutzer den Kernel-Startvorgang programmgesteuert über die GUI oder die Befehlszeile zum Neustart initiieren, wenn bereits ein lokaler Benutzer auf dem Computer ausgeführt wird, einschließlich des Root-Benutzers und des nicht privilegierten Benutzers.  Durch einen Neustart wird der Computer zuerst ausgeschaltet und erst dann neu gestartet. <br><br>  <b>BIOS POST</b> <b><br></b> <br>  Der erste Schritt im Bootprozess des Linux-Kernels hat nichts mit Linux zu tun.  Dies ist der Hardware-Teil des Prozesses, der für alle Betriebssysteme gleich ist.  Wenn der Computer mit Strom versorgt wird, wird als erstes POST (Power On Self Test) gestartet, das Teil des BIOS (Basic I / O System, Basic Input / Output System) ist. <br><br>  Als IBM 1981 seinen ersten Personal Computer auf den Markt brachte, wurde das BIOS zur Initialisierung von Hardwarekomponenten entwickelt.  POST ist Teil des BIOS, dessen Aufgabe es ist, den ordnungsgemäßen Betrieb der Computerausrüstung sicherzustellen.  Wenn der POST fehlschlägt, funktioniert der Computer möglicherweise nicht richtig und der Startvorgang wird nicht fortgesetzt. <br><br>  Der BIOS-POST überprüft die Grundleistung der Hardware und verursacht dann einen BIOS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt</a> - INT 13H, der die Bootsektoren des Kernels auf allen verbundenen Geräten mit der Fähigkeit zum Booten findet.  Der erste gefundene Sektor, der einen gültigen Startdatensatz enthält, wird in den RAM geladen, wonach die Steuerung vom Startsektor auf den Code übertragen wird. <br>  Der Bootsektor ist nur die erste Stufe.  Die meisten Linux-Distributionen verwenden eine von drei Bootloader-Optionen: GRUB, GRUB2 und LILO.  GRUB2 ist das neueste und wird jetzt viel häufiger verwendet als ältere Versionen. <br><br>  <b>GRUB2</b> <br><br>  GRUB2 steht für "GRand Unified Bootloader, Version 2" und ist jetzt der Haupt-Bootloader für die meisten modernen Linux-Distributionen.  GRUB2 ist ein Programm, das einen Computer so intelligent macht, dass er den Kernel des Betriebssystems finden und in den Speicher laden kann.  Da es einfacher ist, nur GRUB zu sprechen und zu schreiben als GRUB2, werde ich in diesem Artikel wahrscheinlich den Begriff GRUB verwenden, aber GRUB2 implizieren, sofern nicht anders angegeben. <br><br>  GRUB ist mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Multiboot-Spezifikation</a> kompatibel, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> verschiedene Versionen von Linux und anderen Betriebssystemen geladen werden können.  Es kann auch die Startaufzeichnung von proprietären Betriebssystemen in einer Kette starten. <br><br>  Mit GRUB kann der Benutzer auch aus mehreren möglichen Kernel-Downloads für jede bereitgestellte Linux-Distribution auswählen.  Dies ermöglicht das Herunterladen der vorherigen Version des Kernels, wenn die aktualisierte Version nicht korrekt gestartet werden kann oder mit einem wichtigen Teil der Software nicht kompatibel ist.  GRUB kann in der Datei <code>/boot/grub/grub.conf</code> konfiguriert werden. <br><br>  GRUB1 gilt heute als veraltet und wird in den meisten modernen Distributionen durch GRUB2 ersetzt, die neu geschriebene Version.  Red Hat-basierte Distributionen, die um Fedora 15 und CentOS / RHEL 7 auf GRUB2 aktualisiert wurden. GRUB2 verfügt über die gleiche Startfunktionalität wie GRUB1, bietet jedoch zusätzlich Mainframe-ähnliche, befehlsbasierte Umgebungen vor dem Betriebssystem und mehr Flexibilität in der Phase vor dem Start.  GRUB2 ist in <code>/boot/grub2/grub.cfg</code> konfiguriert. <br><br>  Die Hauptaufgabe von GRUB besteht darin, den Linux-Kernel in den Speicher zu laden und auszuführen.  Beide Versionen von GRUB funktionieren in drei Schritten ähnlich, aber in diesem Artikel werde ich GRUB2 verwenden, um zu beschreiben, wie GRUB funktioniert.  Das Konfigurieren von GRUB und GRUB2 und die Verwendung von GRUB2-Befehlen geht über den Rahmen dieses Artikels hinaus. <br><br>  Obwohl GRUB2 offiziell keine Schrittnummerierung verwendet, werde ich sie der Einfachheit halber in diesem Artikel verwenden. <br><br>  <b>Stufe 1</b> <br><br>  Wie bereits im Abschnitt BIOS-POST erwähnt, sucht das BIOS am Ende des POST nach Boot-Datensätzen auf angeschlossenen Datenträgern, die sich normalerweise im Master-Boot-Datensatz (MBR) befinden. Anschließend lädt es den ersten gefundenen Datensatz in den Speicher und beginnt mit der Ausführung.  Der Bootstrap-Code, dh die erste Stufe von GRUB2, nimmt nur sehr wenig Speicherplatz ein, da er zusammen mit der Partitionstabelle in den ersten 512-Byte-Sektor auf der Festplatte passen muss.  Der Gesamtspeicherplatz für den Bootstrap-Code selbst im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-MBR</a> beträgt 446 Byte.  Die 446-Byte-Datei für Stufe 1 heißt boot-img und enthält keine Partitionstabelle - sie wird separat zum Boot-Datensatz hinzugefügt. <br><br>  Da der Startdatensatz so klein sein sollte, ist er nicht sehr „intelligent“ und versteht die Struktur des Dateisystems nicht.  Daher besteht der einzige Zweck von Schritt 1 darin, Schritt 1.5 zu erkennen und zu laden.  Um dies zu erreichen, muss sich Schritt 1.5 von GRUB im Bereich zwischen dem Startdatensatz selbst und der ersten Partition auf der Festplatte befinden.  Nach dem Laden von Stufe 1.5 GRUB in den RAM überträgt Stufe 1 die Steuerung auf Stufe 1.5. <br><br>  <b>Stufe 1.5</b> <br><br>  Wie oben erwähnt, sollte Schritt 1.5 von GRUB zwischen dem Startdatensatz und der ersten Partition auf der Festplatte liegen.  Historisch gesehen bleibt dieser Raum aus technischen Gründen ungenutzt.  Die erste Partition auf der Festplatte startet in Sektor 63, und unter Berücksichtigung des MBR in Sektor 0 gibt es 62 512-Byte-Sektoren - 31744 Byte -, in denen Sie die Datei core.img speichern können - Stufe 1,5 GRUB.  Die Datei core.img wiegt 25389 Byte. Dies ist genug Speicherplatz, um sie zwischen dem MBR und der ersten Festplattenpartition zu speichern. <br><br>  Da für Schritt 1.5 mehr Code verwendet werden kann, kann es ausreichen, mehrere gängige Dateisystemtreiber zu enthalten, z. B. Standard-EXT- und andere Linux-Dateisysteme, FAT und NTFS.  core.img in GRUB2 ist komplexer und funktionaler als in Schritt 1.5 von GRUB1.  Dies bedeutet, dass sich Stufe 2 von GRUB2 möglicherweise in einem Standard-EXT-Dateisystem befindet, jedoch nicht in einem logischen Volume.  Daher ist der Standardspeicherort für Dateien der Stufe 2 das Dateisystem <code>/boot</code> bzw. <code>/boot/grub2</code> . <br><br>  Beachten Sie, dass sich das Verzeichnis / boot im von GRUB unterstützten Dateisystem befinden muss.  Nicht alle Dateisysteme unterstützen diese Funktion.  Die Aufgabe von Stufe 1.5 besteht darin, mit den erforderlichen Dateisystemtreibern zu beginnen, um nach Dateien der Stufe 2 im / boot-Dateisystem zu suchen und die erforderlichen Treiber zu laden. <br><br>  <b>Stufe 2</b> <br><br>  Alle GRUB Stage 2-Dateien befinden sich im <code>/boot/grub2</code> und in mehreren Unterverzeichnissen.  GRUB2 verfügt nicht über eine Image-Datei wie in den Schritten 1 und 2. Stattdessen besteht sie hauptsächlich aus Laufzeit-Kernel-Modulen, die nach Bedarf aus dem <code>/boot/grub2/i386-pc</code> geladen werden. <br><br>  Die Aufgabe von GRUB2 Stufe 2 besteht darin, den Linux-Kernel zu erkennen und in den RAM zu laden und die Steuerung der Computersteuerung auf den Kernel zu übertragen.  Der Kernel und die zugehörigen Dateien befinden sich im Verzeichnis <code>/boot</code> .  Kernel-Dateien sind leicht zu erkennen, da ihre Namen mit vmlinuz beginnen.  Sie können den Inhalt des Verzeichnisses <code>/boot</code> auflisten, um die aktuell auf Ihrem System installierten Kernel anzuzeigen. <br><br>  GRUB2 unterstützt wie GRUB1 das Laden eines von mehreren Linux-Kerneln.  Das Red Hat-Paketverwaltungssystem unterstützt das Speichern mehrerer Versionen des Kernels, sodass Sie bei Problemen mit der neuesten Version die alte Version des Kernels laden können.  Standardmäßig bietet GRUB ein vorinstalliertes Menü installierter Kernel, einschließlich der Rettungsoption und nach der Konfiguration der Wiederherstellungsoption. <br><br>  Stufe 2 GRUB2 lädt den ausgewählten Kernel in den Speicher und überträgt die Kontrolle über die Computersteuerung auf den Kernel. <br><br>  <b>Der Kern</b> <br><br>  Alle Kerne haben ein selbstextrahierendes, komprimiertes Format, um Platz zu sparen.  Die Kernel befinden sich zusammen mit dem ursprünglichen RAM-Image und einer Liste der Partitionen auf den Festplatten im Verzeichnis <code>/boot</code> . <br><br>  Nachdem der ausgewählte Kernel in den Speicher geladen wurde und mit der Ausführung beginnt, muss er sich zunächst selbst aus der komprimierten Version der Datei extrahieren, bevor er nützliche Arbeiten ausführen kann.  Sobald die Extraktion erfolgt ist, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geladen</a> , das das alte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SysV-Init-</a> Programm ersetzt, und die Steuerung an dieses übertragen. <br><br>  Dies ist das Ende des Kernel-Boot-Prozesses.  Zu diesem Zeitpunkt werden der Linux-Kernel und systemd ausgeführt, können jedoch keine nützlichen Aufgaben für den Endbenutzer ausführen, da nichts anderes zu tun ist. <br><br>  <b>Systemstartprozess</b> <br><br>  Der Systemstartprozess folgt dem Kernel-Boot-Prozess und bringt den Linux-Computer zum Laufen. <br><br>  <b>systemd</b> <br><br>  systemd ist das übergeordnete Element aller Prozesse, die dafür verantwortlich sind, den Linux-Host in einen effizienten Zustand zu versetzen.  Einige seiner Funktionen, die umfangreicher sind als die im alten Initialisierungsprogramm vorgestellten, sollten viele Aspekte des laufenden Linux-Hosts verwalten, einschließlich des Bereitstellens des Dateisystems, des Startens und Verwaltens von Systemdiensten, die für ein effizientes Arbeiten des Linux-Hosts erforderlich sind.  Alle systemd-Aufgaben, die nicht mit dem Systemstartprozess zusammenhängen, werden in diesem Artikel nicht behandelt. <br><br>  Zunächst stellt systemd Dateisysteme wie in <code>/etc/fstab</code> definiert bereit, einschließlich aller Auslagerungsdateien und Partitionen.  Zu diesem Zeitpunkt kann er auf die Konfigurationsdateien in <code>/etc</code> zugreifen, einschließlich seiner eigenen.  Es verwendet seine eigene Konfigurationsdatei <code>/etc/systemd/system/default.target</code> , um das Ziel zu bestimmen, für das der Host geladen werden soll.  Die Datei default.target ist nur ein Symlink zur realen Zieldatei.  Bei einer Desktop-Workstation ist dies normalerweise ein grafisches Ziel, das Runlevel 5 im alten SystemV-Initialisierer entspricht.  Für den Server ist der Standardwert wahrscheinlich multi-user.target, ähnlich wie bei Runlevel 3 in SystemV.  Emergency.Target ähnelt dem Einzelbenutzermodus. <br><br>  Beachten Sie, dass Ziele und Dienste Systemeinheiten sind. <br><br>  Die folgende Tabelle 1 zeigt einen Vergleich aller systemd-Ziele mit den alten Runlevels in SystemV.  Systemd-Zielaliasnamen werden aus Gründen der Abwärtskompatibilität von systemd bereitgestellt.  Ziel-Aliase ermöglichen es Skripten - und vielen Systemadministratoren, einschließlich mir -, SystemV-Befehle wie init3 zu verwenden, um die Ausführungsebenen zu ändern.  Natürlich werden die SystemV-Befehle von systemd zur Interpretation und Ausführung geleitet. <br><div class="scrollable-table"><table><tbody><tr><th>  Systemv Runlevel </th><th>  <nobr>systemd Ziel</nobr> </th><th>  <nobr>systemd Ziel-</nobr> Aliase </th><th>  Beschreibung </th></tr><tr><td></td><td>  halt.target </td><td></td><td>  Hält das System an, ohne den Strom auszuschalten </td></tr><tr><td>  0 </td><td>  poweroff.target </td><td>  runlevel0.target </td><td>  Hält das System an und schaltet die Stromversorgung aus </td></tr><tr><td>  S. </td><td>  Notfallziel </td><td></td><td>  Einzelbenutzermodus.  Dienste werden nicht ausgeführt.  Dateisysteme sind nicht gemountet.  Dies ist die grundlegendste Bedienebene.  Für die Benutzerinteraktion mit dem System wird nur die Notfall-Shell in der Hauptkonsole gestartet. </td></tr><tr><td>  1 </td><td>  retten.Ziel </td><td>  runlevel1.target </td><td>  Das Basissystem, einschließlich der Bereitstellung des Dateisystems mit den grundlegendsten Diensten und der Rettungsshell in der Hauptkonsole. </td></tr><tr><td>  2 </td><td></td><td>  runlevel2.target </td><td>  Mehrbenutzermodus ohne NFS, aber alle Nicht-GUI-Dienste werden ausgeführt. </td></tr><tr><td>  3 </td><td>  multi-user.target </td><td>  runlevel3.target </td><td>  Alle Dienste werden ausgeführt, jedoch nur über die Befehlszeilenschnittstelle (CLI). </td></tr><tr><td>  4 </td><td></td><td>  runlevel4.target </td><td>  Wird nicht benutzt. </td></tr><tr><td>  5 </td><td>  graphical.target </td><td>  runlevel5.target </td><td>  Mehrbenutzermodus mit GUI. </td></tr><tr><td>  6 </td><td>  reboot.target </td><td>  runlevel6.target </td><td>  Starten Sie neu </td></tr><tr><td></td><td>  default.target </td><td></td><td>  Dieses Ziel hat immer einen Symlink mit multi-user.target oder graphical.target.  systemd verwendet immer default.target, um das System zu starten.  default.target sollte niemals mit halt.target, poweroff.target oder reboot.target verknüpft werden. </td></tr></tbody></table></div><br>  <i>Tabelle 1: Vergleich der SystemV-Kontrollstufen mit systemd-Zielen und einigen Zielaliasen.</i> <br><br>  Jedes Ziel verfügt über eine Reihe von Abhängigkeiten, die in der Konfigurationsdatei beschrieben sind.  systemd führt die notwendigen aus.  Diese Abhängigkeiten sind die Dienste, die zum Ausführen eines Linux-Hosts mit einer bestimmten Funktionalität erforderlich sind.  Wenn alle in den Zielkonfigurationsdateien aufgeführten Abhängigkeiten geladen und gestartet wurden, arbeitet das System auf dieser Zielebene. <br><br>  systemd durchsucht auch veraltete SystemV-Initialisierungsverzeichnisse nach Startdateien.  Wenn dies der Fall ist, verwendet systemd sie als Konfigurationsdateien, um die in den Dateien beschriebenen Dienste auszuführen.  Ein veralteter Netzwerkdienst ist ein gutes Beispiel für einen Dienst, der weiterhin SystemV-Startdateien in Fedora verwendet. <br><br>  Abbildung 1 unten wird direkt von der Start <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Hauptseite</a> kopiert.  Es zeigt die allgemeine Abfolge der Ereignisse während des Starts von systemd und die grundlegenden Anforderungen, um den Erfolg sicherzustellen. <br><br>  Die Ziele sysinit.target und basic.target können beim Systemstart als Prüfpunkte betrachtet werden.  Obwohl eines der Ziele von systemd darin besteht, Systemdienste parallel auszuführen, müssen einige Dienste und Funktionsziele vor anderen gestartet werden.  Diese Kontrollpunkte können erst übergeben werden, wenn alle erforderlichen Dienste und Ziele abgeschlossen sind. <br><br>  Somit ist sysinit.target erreicht, wenn alle Einheiten, von denen es abhängt, abgeschlossen sind.  Alle folgenden Einheiten sollten abgeschlossen sein: Mounten von Dateisystemen, Einrichten von Auslagerungsdateien, Starten von udev, Festlegen des Anfangszustands des Zufallszahlengenerators, Initialisieren von Diensten auf niedriger Ebene, Einrichten von Kryptografiediensten, wenn mindestens ein Dateisystem verschlüsselt ist.  In sysinit.target können sie parallel ausgeführt werden. <br>  sysinit.target führt alle Dienste und Einheiten auf niedriger Ebene aus, die für die Mindestfunktionalität des Systems erforderlich sind, sowie diejenigen, die für den Wechsel zu basic.target erforderlich sind. <br><br><img src="https://habrastorage.org/webt/gx/k_/yj/gxk_yjpanfeksjnoiyfxob5bqlw.png"><br>  <i>Abbildung 1. Systemd-Startzuordnung</i> <br><br>  Nach der Ausführung von sysinit.target startet systemd basic.target, beginnend mit allen Einheiten, die zur Ausführung erforderlich sind.  Das Basisziel bietet zusätzliche Funktionen, indem die für das nächste Ziel erforderlichen Einheiten gestartet werden, einschließlich des Festlegens von Pfaden zu verschiedenen ausführbaren Verzeichnissen, Kommunikationssockets und Timern. <br><br>  Schließlich können Sie mit der Initialisierung von Zielen auf Benutzerebene beginnen: multi-user.target oder graphical.target.  Es ist zu beachten, dass multi-user.target erreicht werden muss, bevor die Abhängigkeiten des Grafikziels ausgeführt werden. <br><br>  Die in Abbildung 1 unterstrichenen Ziele sind typische Startziele.  Der Systemstart endet, wenn einer von ihnen erreicht ist.  Wenn multi-user.target das Standardziel ist, wird in der Konsole die Anmeldung im Textmodus angezeigt.  Wenn graphical.target standardmäßig angegeben ist, wird eine grafische Anmeldung angezeigt.  Die Benutzeroberfläche des Anmeldebildschirms hängt vom verwendeten Bildschirmmanager ab. <br><br>  <b>Die Probleme</b> <br><br>  Ich musste kürzlich den Standard-Boot-Kernel auf einem Linux-Computer ändern, der GRUB2 verwendete.  Ich habe festgestellt, dass einige Befehle nicht mehr richtig funktionieren oder dass ich sie irgendwie falsch verwendet habe.  Ich weiß immer noch nicht, was das Problem war, es wird mehr Zeit brauchen, um es zu untersuchen. <br><br>  Der Befehl grub2-set-default hat den Standard-Kernel-Index in der Datei <code>/etc/default/grub</code> falsch konfiguriert, sodass der gewünschte alternative Kernel nicht geladen wurde.  Ich habe <code>/etc/default/grub GRUB_DEFAULT=saved</code> manuell geändert. <code>/etc/default/grub GRUB_DEFAULT=saved</code> in <code>GRUB_DEFAULT=2</code> , wobei 2 der Index des installierten Kernels ist, den ich ausführen wollte.  Dann habe ich den <code>grub2-mkconfig &gt; /boot/grub2/grub.cfg</code> ausgeführt, um eine neue Grub-Konfigurationsdatei zu erstellen.  Dieser Trick hat funktioniert und ein alternativer Kernel wurde gestartet. <br><br>  <b>Schlussfolgerungen</b> <br><br>  GRUB2 und das Systemd-Initialisierungssystem sind Schlüsselkomponenten für die Kernel-Boot- und Systemstartphasen der meisten modernen Linux-Distributionen.  Trotz der Widersprüche, insbesondere in Bezug auf systemd, arbeiten diese beiden Komponenten gut zusammen, um den Kernel zu laden und alle Systemdienste auszuführen, die zum Erstellen eines funktionierenden Linux-Systems erforderlich sind. <br>  Obwohl ich GRUB2 und systemd insgesamt als komplexer betrachte als ihre Vorgänger, sind sie nicht schwieriger zu beherrschen und zu verwalten.  Die Handbücher enthalten viele Informationen zu systemd, und auf freedesktop.org wird die Liste der Seiten vollständig dargestellt.  Weitere Informationen finden Sie unter den folgenden Links: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU GRUB</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU GRUB Manua</a> l (GNU.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Master Boot Record</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiboot-Spezifikation</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemd-Startvorgang</a> (Freedesktop.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd Index der Manpages</a> (Freedesktop.org) </li></ul><br><br>  Das ist alles.  Wir warten hier auf Fragen und Kommentare oder sie können direkt in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer offenen Lektion gestellt werden</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424761/">https://habr.com/ru/post/de424761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424747/index.html">Der Ort, an dem der Klang lebt</a></li>
<li><a href="../de424751/index.html">Wie das einheitliche biometrische System funktioniert</a></li>
<li><a href="../de424753/index.html">Was ist neu in YouTrack 2018.3?</a></li>
<li><a href="../de424755/index.html">Geld liebt die Rechnung: wie Autos Rechnungen sortieren</a></li>
<li><a href="../de424757/index.html">Die Zusammenfassung der Ereignisse für HR-Fachkräfte im Bereich IT im Oktober 2018</a></li>
<li><a href="../de424763/index.html">Ein Texteditor ist nicht Ihre höchste Mathematik, hier müssen Sie nachdenken</a></li>
<li><a href="../de424765/index.html">Zustandsverwaltung in Flatteranwendungen</a></li>
<li><a href="../de424767/index.html">Wir machen einen Kuchen aus Habr. Wieder</a></li>
<li><a href="../de424771/index.html">Persönliche Erfahrung: von einer Idee und einem leeren Blatt bis zu einer Entwurfsversion einer Website</a></li>
<li><a href="../de424773/index.html">Biopharma und numerische Modellierung: Amgen Erfahrung und Praxis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>