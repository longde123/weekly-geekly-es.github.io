<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎻 👨🏾‍🏭 🔃 3-arah bergabung di werf: penyebaran di Kubernetes dengan Helm "on steroids" 🧜🏿 👩🏽‍🤝‍👨🏿 🕺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sesuatu terjadi yang kami (dan bukan hanya kami) telah menunggu: werf , utilitas Open Source kami untuk membangun aplikasi dan mengirimkannya ke Kuber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3-arah bergabung di werf: penyebaran di Kubernetes dengan Helm "on steroids"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Sesuatu terjadi yang kami (dan bukan hanya kami) telah menunggu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> , utilitas Open Source kami untuk membangun aplikasi dan mengirimkannya ke Kubernetes, sekarang mendukung penerapan perubahan menggunakan tambalan penggabungan 3 arah!  Selain itu, dimungkinkan untuk mengadopsi sumber daya K8 yang ada ke dalam rilis Helm tanpa menciptakan kembali sumber daya ini. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  Jika ini sangat singkat, maka atur <code>WERF_THREE_WAY_MERGE=enabled</code> - kami mendapatkan penyebaran "seperti di <code>kubectl apply</code> ", kompatibel dengan instalasi yang ada di Helm 2 dan bahkan sedikit lagi. <br><br>  Tapi mari kita mulai dengan teorinya: apa patch 3-way-merge secara umum, bagaimana orang-orang sampai pada pendekatan dengan generasi mereka, dan mengapa mereka penting dalam proses CI / CD dengan infrastruktur berbasis Kubernet?  Dan setelah itu - mari kita lihat apakah penggabungan 3-arah dalam werf itu, mode apa yang digunakan secara default dan bagaimana cara mengelolanya. <a name="habracut"></a><br><br><h2>  Apa itu tambalan 3 arah? </h2><br>  Jadi, mari kita mulai dengan tugas meluncurkan sumber daya yang dijelaskan dalam manifes YAML di Kubernetes. <br><br>  Untuk bekerja dengan sumber daya, API Kubernetes menawarkan operasi dasar berikut: membuat, menambal, mengganti, dan menghapus.  Diasumsikan bahwa dengan bantuan mereka perlu untuk membangun peluncuran sumber daya yang berkesinambungan untuk cluster.  Bagaimana? <br><br><h3>  Tim kubectl yang imperatif </h3><br>  Pendekatan pertama untuk mengelola objek di Kubernetes adalah menggunakan perintah kubectl imperatif untuk membuat, memodifikasi, dan menghapus objek-objek ini.  Sederhananya: <br><br><ul><li>  perintah <code>kubectl run</code> dapat menjalankan Deployment atau Pekerjaan: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  perintah <code>kubectl scale</code> - ubah jumlah replika: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  dll. </li></ul><br>  Pandangan seperti itu mungkin tampak nyaman pada pandangan pertama.  Namun, ada masalah: <br><br><ol><li>  Sulit untuk <b>diotomatisasi</b> . </li><li>  Bagaimana cara <b>mencerminkan konfigurasi</b> di Git?  Bagaimana cara meninjau perubahan yang terjadi pada sebuah cluster? </li><li>  Bagaimana memastikan <b>reproduksibilitas</b> konfigurasi saat restart? </li><li>  ... </li></ol><br>  Jelas bahwa pendekatan ini tidak cocok dengan menyimpan kode aplikasi dan infrastruktur sebagai kode (IaC; atau bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitOps</a> sebagai opsi yang lebih modern, mendapatkan popularitas di ekosistem Kubernetes).  Karenanya, tim-tim ini tidak menerima pengembangan lebih lanjut di kubectl. <br><br><h3>  Buat, dapatkan, ganti, dan hapus operasi </h3><br>  Dengan <b>kreasi</b> utama <b>,</b> semuanya sederhana: kami mengirim manifes ke operasi <code>create</code> api kubus dan sumber daya dibuat.  Representasi YAML dari manifes dapat disimpan di Git, dan untuk membuat, gunakan perintah <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>Menghapus</b> juga sederhana: kita mengganti <code>manifest.yaml</code> sama dari Git ke perintah <code>kubectl delete -f manifest.yaml</code> . <br><br>  Operasi <b><code>replace</code></b> memungkinkan Anda untuk sepenuhnya mengganti konfigurasi sumber daya dengan yang baru, tanpa membuat ulang sumber daya.  Ini berarti bahwa sebelum membuat perubahan ke sumber daya, logis untuk meminta versi saat ini dengan operasi <code>get</code> , ubah, dan perbarui dengan operasi <code>replace</code> .  Penguncian optimis dibangun ke dalam apiserver kubus, dan jika objek telah berubah setelah <code>get</code> operasi, operasi <code>replace</code> akan gagal. <br><br>  Untuk menyimpan konfigurasi di Git dan memperbarui menggunakan penggantian, Anda harus melakukan operasi <code>get</code> , tahan konfigurasi dari Git dengan apa yang kami dapatkan, dan lakukan <code>replace</code> .  Biasanya, kubectl hanya memungkinkan Anda untuk menggunakan perintah <code>kubectl replace -f manifest.yaml</code> , di mana <code>manifest.yaml</code> adalah <code>manifest.yaml</code> yang disiapkan sepenuhnya (dalam kasus kami, disatukan) yang perlu diinstal.  Ternyata pengguna perlu menerapkan manifes gabungan, tetapi ini bukan masalah sepele ... <br><br>  Perlu dicatat bahwa walaupun <code>manifest.yaml</code> disimpan di Git, kita tidak dapat mengetahui sebelumnya apakah kita perlu membuat objek atau memperbaruinya - ini harus dilakukan oleh perangkat lunak pengguna. <br><br>  Intinya: <b>dapatkah kita membangun peluncuran berkelanjutan</b> hanya dengan membuat, mengganti, dan menghapus, memastikan bahwa konfigurasi infrastruktur disimpan di Git bersama dengan kode dan CI / CD yang nyaman? <br><br>  Pada dasarnya, kita dapat ... Untuk melakukan ini, kita <b>perlu mengimplementasikan operasi gabungan</b> manifes dan semacam ikatan yang: <br><br><ul><li>  memeriksa keberadaan objek di kluster, </li><li>  melakukan penciptaan awal sumber daya, </li><li>  memperbarui atau menghapusnya. </li></ul><br>  Saat memperbarui, Anda perlu mempertimbangkan bahwa <i>sumber daya mungkin telah berubah</i> sejak yang terakhir <code>get</code> dan secara otomatis menangani kasus penguncian yang optimis - lakukan upaya berulang untuk memperbarui. <br><br>  Namun, mengapa menciptakan kembali roda ketika kube-apiserver menawarkan cara lain untuk memperbarui sumber daya: operasi <code>patch</code> , yang menghilangkan beberapa masalah yang dijelaskan dari pengguna? <br><br><h3>  Tambalan </h3><br>  Jadi kami sampai di tambalan. <br><br>  Patch adalah cara utama untuk menerapkan perubahan pada objek yang ada di Kubernetes.  Operasi <code>patch</code> berfungsi agar: <br><br><ul><li>  pengguna kube-apiserver perlu mengirim patch dalam format JSON dan menentukan objek, </li><li>  dan apiserver itu sendiri akan menangani keadaan objek saat ini dan membawanya ke bentuk yang diinginkan. </li></ul><br>  Penguncian optimis dalam hal ini tidak diperlukan.  Operasi ini lebih deklaratif dibandingkan dengan penggantian, meskipun pada awalnya mungkin tampak sebaliknya. <br><br>  Dengan cara ini: <br><br><ul><li>  menggunakan operasi <code>create</code> , kita membuat objek dari manifes dari Git, </li><li>  menggunakan <code>delete</code> - hapus jika objek tidak lagi diperlukan, </li><li>  menggunakan <code>patch</code> - kita memodifikasi objek, membawanya ke bentuk yang dijelaskan dalam Git. </li></ul><br>  Namun, untuk melakukan ini, Anda harus membuat <i>tambalan yang benar</i> ! <br><br><h3>  Bagaimana tambalan bekerja di Helm 2: 2-way-merge </h3><br>  Pertama kali rilis diinstal, Helm melakukan operasi <code>create</code> pada sumber daya grafik. <br><br>  Saat memperbarui rilis Helm untuk setiap sumber daya: <br><br><ul><li>  menghitung tambalan antara versi sumber daya dari bagan sebelumnya dan versi bagan saat ini, </li><li>  terapkan tambalan ini. </li></ul><br>  Kami akan menyebutnya patch <b>2-way-merge patch</b> , karena 2 manifesto berpartisipasi dalam pembuatannya: <br><br><ul><li>  Manifes sumber daya dari rilis sebelumnya, </li><li>  Manifes sumber daya dari sumber daya saat ini. </li></ul><br>  Saat menghapus, operasi <code>delete</code> dalam apiserver kubus dipanggil untuk sumber daya yang dideklarasikan dalam rilis sebelumnya tetapi tidak dideklarasikan dalam yang sekarang. <br><br>  Pendekatan dengan 2 cara menggabungkan tambalan memiliki masalah: itu mengarah ke <b>desync keadaan sebenarnya dari sumber daya di cluster dan manifes di Git</b> . <br><br><h3>  Contoh masalah </h3><br><ul><li>  Di Git, manifes disimpan pada bagan tempat bidang <code>image</code> Penerapan memiliki nilai <code>ubuntu:18.04</code> . </li><li>  Pengguna melalui <code>kubectl edit</code> mengubah nilai bidang ini ke <code>ubuntu:19.04</code> . </li><li>  Saat Anda menggunakan kembali bagan, Helm <i>tidak menghasilkan tambalan</i> , karena bidang <code>image</code> di versi rilis sebelumnya dan di bagan saat ini adalah sama. </li><li>  Setelah penyebaran <code>image</code> berulang, <code>ubuntu:19.04</code> tetap, meskipun <code>ubuntu:18.04</code> ditulis pada bagan. </li></ul><br>  Kami mendapatkan desync dan kehilangan declarativeness. <br><br><h3>  Apa itu sumber daya yang disinkronkan? </h3><br>  Secara umum, tidak mungkin untuk mendapatkan kecocokan <i>lengkap</i> antara manifes sumber daya dalam menjalankan cluster dan manifes dari Git.  Karena dalam manifes nyata mungkin ada anotasi layanan / label, wadah tambahan dan data lainnya ditambahkan dan dihapus secara dinamis oleh beberapa pengontrol dari sumber daya.  Kami tidak bisa dan tidak ingin menyimpan data ini di Git.  Namun, kami ingin saat meluncurkan, bidang yang kami tentukan secara eksplisit di Git mengambil nilai yang sesuai. <br><br>  Ternyata ini <b>aturan</b> umum <b>dari sumber daya yang disinkronkan</b> : ketika Anda meluncurkan sumber daya, Anda dapat mengubah atau menghapus hanya bidang-bidang yang secara eksplisit ditentukan dalam manifes dari Git (atau terdaftar di versi sebelumnya, tetapi sekarang dihapus). <br><br><h3>  Patch 3-arah-gabung </h3><br>  Gagasan utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan penggabungan 3-arah</a> : kami membuat tambalan antara versi terapan terakhir manifes dari Git dan versi target manifes dari Git, dengan mempertimbangkan versi manifes saat ini dari gugus kerja.  Tambalan terakhir harus mematuhi aturan sumber daya yang disinkronkan: <br><br><ul><li>  bidang baru yang ditambahkan ke versi target ditambahkan menggunakan tambalan; </li><li>  bidang yang sebelumnya ada dalam versi terakhir yang diterapkan dan tidak ada di bidang target diatur ulang menggunakan tambalan; </li><li>  Bidang dalam versi objek saat ini yang berbeda dari versi target manifes diperbarui menggunakan tambalan. </li></ul><br>  Dengan prinsip inilah <code>kubectl apply</code> tambalan dihasilkan: <br><br><ul><li>  versi terapan yang terakhir dari manifes disimpan dalam anotasi objek itu sendiri, </li><li>  target - diambil dari file YAML yang ditentukan, </li><li>  saat ini - dari cluster yang berfungsi. </li></ul><br>  Sekarang setelah kami memahami teorinya, saatnya untuk memberi tahu Anda apa yang kami lakukan di werf. <br><br><h2>  Terapkan perubahan ke werf </h2><br>  Sebelumnya, werf, seperti Helm 2, menggunakan patch 2-way-merge. <br><br><h3>  Perbaikan tambalan </h3><br>  Untuk beralih ke jenis tambalan baru - 3-way-merge - langkah pertama kami memperkenalkan <b>tambalan perbaikan yang</b> disebut. <br><br>  Saat digunakan, tambalan penggabungan 2 arah standar digunakan, tetapi tidak juga menghasilkan tambalan yang menyinkronkan keadaan sebenarnya dari sumber daya dengan apa yang ditulis dalam Git (tambalan semacam itu dibuat menggunakan aturan sumber daya tersinkronisasi yang sama seperti dijelaskan di atas). <br><br>  Dalam hal rassynchrony, pada akhir penyebaran, pengguna menerima PERINGATAN dengan pesan dan tambalan yang sesuai, yang harus diterapkan untuk membawa sumber daya ke formulir yang disinkronkan.  Juga, tambalan ini dicatat dalam <code>werf.io/repair-patch</code> anotasi khusus.  Diasumsikan bahwa pengguna <b>sendiri akan</b> menerapkan tambalan ini dengan tangannya: werf pada prinsipnya tidak akan menerapkannya. <br><br>  Membuat tambalan perbaikan adalah tindakan sementara yang memungkinkan Anda untuk benar-benar menguji pembuatan tambalan pada prinsip penggabungan 3 arah, tetapi tidak secara otomatis menerapkan tambalan ini.  Saat ini, mode operasi ini diaktifkan secara default. <br><br><h3>  Patch 3-arah-gabung hanya untuk rilis baru </h3><br>  Mulai 1 Desember 2019, versi beta dan alfa dari werf mulai <b>secara default untuk</b> menggunakan patch 3-way-merge penuh untuk menerapkan perubahan hanya untuk rilis Helm baru yang diluncurkan melalui werf.  Rilis yang ada akan terus menggunakan pendekatan perbaikan patch 2-arah-gabung +. <br><br>  Anda dapat mengaktifkan mode operasi ini secara eksplisit dengan mengatur <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> sekarang. <br><br>  <i><b>Catatan</b> : fitur muncul di werf lebih dari beberapa rilis: di saluran alpha menjadi siap dari versi <a href="">v1.0.5-alpha.19</a> , dan di saluran beta dengan <a href="">v1.0.4-beta.20</a> .</i> <br><br><h3>  Patch 3-arah-gabung untuk semua rilis </h3><br>  Mulai 15 Desember 2019, versi beta dan alfa dari werf mulai menggunakan tambalan penggabungan 3-arah sepenuhnya secara default untuk menerapkan perubahan untuk semua rilis. <br><br>  Mode operasi ini dapat <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> secara eksplisit <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> menetapkan <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> sekarang. <br><br><h3>  Apa yang harus dilakukan dengan sumber daya autoscaling? </h3><br>  Kubernetes memiliki 2 jenis autoscaling: HPA (horizontal) dan VPA (vertikal). <br><br>  Horisontal otomatis memilih jumlah replika, vertikal - jumlah sumber daya.  Baik jumlah replika dan persyaratan sumber daya ditentukan dalam manifes sumber daya (lihat <code>spec.replicas</code> atau <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> ). <br><br>  Masalah: jika pengguna mengkonfigurasi sumber daya pada bagan sehingga menampilkan nilai spesifik untuk sumber daya atau replika dan auto-scaler diaktifkan untuk sumber daya ini, maka dengan setiap penerapan werf akan mereset nilai-nilai ini ke apa yang tertulis dalam manifes grafik. <br><br>  Ada dua solusi untuk masalah ini.  Sebagai permulaan, yang terbaik adalah membuang nilai autoscale yang ditentukan secara eksplisit dalam manifes grafik.  Jika karena alasan tertentu opsi ini tidak cocok (misalnya, karena nyaman untuk menetapkan batas sumber daya awal dan jumlah replika pada grafik), maka werf menawarkan anotasi berikut: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Jika anotasi semacam itu ada, werf tidak akan mereset nilai yang sesuai pada setiap penyebaran, tetapi hanya menetapkannya pada awal pembuatan sumber daya. <br><br>  Untuk informasi lebih lanjut, lihat dokumentasi proyek untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HPA</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VPA</a> . <br><br><h3>  Tolak penggunaan patch 3-way-merge </h3><br>  Pengguna masih dapat melarang penggunaan tambalan baru di werf menggunakan variabel lingkungan <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  Namun, mulai <b>1 Maret 2020, larangan ini akan berhenti berfungsi</b> dan hanya akan mungkin menggunakan tambalan penggabungan 3 arah. <br><br><h2>  Adopsi sumber daya di werf </h2><br>  Menguasai metode menerapkan perubahan dalam 3-way-merge-patch memungkinkan kami untuk segera mengimplementasikan fitur seperti adopsi sumber daya yang ada di cluster dalam rilis Helm. <br><br>  Helm 2 memiliki masalah: Anda tidak dapat menambahkan ke manifes bagan sumber daya yang sudah ada di cluster tanpa membuat ulang sumber ini dari awal (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 3275</a> ).  Kami mengajar werf untuk menerima sumber daya yang ada dalam rilis.  Untuk melakukan ini, Anda perlu menetapkan anotasi pada versi sumber daya saat ini dari sebuah cluster yang berjalan (misalnya, menggunakan <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Sekarang sumber daya perlu dijelaskan pada bagan dan pada penyebaran berikutnya oleh rilis werf dari rilis dengan nama yang sesuai, sumber daya yang ada akan diterima ke dalam rilis ini dan akan tetap di bawah kendali.  Selain itu, dalam proses menerima sumber daya untuk dirilis, werf akan membawa status sumber daya saat ini dari kelompok kerja ke negara yang dijelaskan pada bagan menggunakan tambalan penggabungan 3 arah yang sama dan aturan sumber daya yang disinkronkan. <br><br>  <i><b>Catatan</b> : pengaturan <code>WERF_THREE_WAY_MERGE_MODE</code> tidak memengaruhi adopsi sumber daya - dalam hal adopsi, patch gabungan 3 arah selalu digunakan.</i> <br><br>  Detailnya ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br><h2>  Kesimpulan dan Rencana Masa Depan </h2><br>  Saya berharap bahwa setelah artikel ini menjadi lebih jelas apa patch 3-way-merge dan mengapa mereka datang kepada mereka.  Dari sudut pandang praktis pengembangan proyek werf, implementasi mereka adalah langkah lain menuju peningkatan penyebaran Helm-seperti.  Sekarang Anda dapat melupakan masalah dengan sinkronisasi konfigurasi, yang sering terjadi ketika menggunakan Helm 2. Pada saat yang sama, fitur baru yang bermanfaat dari adopsi sumber daya Kubernet yang sudah diunggah ke rilis Helm telah ditambahkan. <br><br>  Masih ada beberapa masalah dan kesulitan dalam penerapan seperti Helm, seperti penggunaan templat-Go, dan kami akan terus menyelesaikannya. <br><br>  Informasi tentang metode pembaruan sumber daya dan adopsi juga dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dokumentasi ini</a> . <br><br><h3>  Helm 3 </h3><br>  Catatan khusus layak untuk versi utama Helm yang baru dirilis baru-baru ini - v3 - yang juga menggunakan tambalan penggabungan 3 arah dan menyingkirkan Tiller.  Versi baru Helm memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">migrasi</a> instalasi yang ada untuk mengubahnya menjadi format penyimpanan rilis baru. <br><br>  Werf, pada bagiannya, sekarang telah menghilangkan penggunaan Tiller, beralih ke penggabungan 3-arah dan menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih banyak</a> , sambil tetap kompatibel dengan instalasi yang ada di Helm 2 (tidak ada skrip migrasi yang diperlukan).  Oleh karena itu, sampai werf beralih ke Helm 3, pengguna werf tidak kehilangan keunggulan utama Helm 3 dibandingkan Helm 2 (mereka juga ada di werf). <br><br>  Namun, beralih werf ke basis kode Helm 3 tidak bisa dihindari dan akan terjadi dalam waktu dekat.  Agaknya itu bukan werf 1.1 atau werf 1.2 (saat ini, versi utama werf adalah 1.0; untuk rincian lebih lanjut tentang perangkat versi werf lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Selama waktu ini, Helm 3 akan memiliki waktu untuk stabil. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  Serangkaian catatan tentang inovasi di werf: <br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan untuk monorepo dan multirepo di werf dan apa hubungannya dengan Docker Registry dengan itu</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sekarang kamu bisa membuat gambar Docker di werf menggunakan Dockerfile yang biasa</a> ." </li></ul></li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Werf adalah alat CI / CD kami di Kubernetes (review dan laporan video)</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perakitan dan penyebaran jenis layanan microser yang sama dengan werf dan GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan Helm 3.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476646/">https://habr.com/ru/post/id476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476626/index.html">PVS-Studio di Awan: GitLab CI / CD</a></li>
<li><a href="../id476628/index.html">PVS-Studio beralih ke cloud: GitLab CI / CD</a></li>
<li><a href="../id476636/index.html">Tuning Firebird dan Linux untuk database berukuran 691 GB dengan 1000+ pengguna</a></li>
<li><a href="../id476640/index.html">Melindungi Zimbra OSE dari brute force dan serangan DoS</a></li>
<li><a href="../id476644/index.html">Lapisan bahasa</a></li>
<li><a href="../id476648/index.html">Lenovo di FINOPOLIS 2019</a></li>
<li><a href="../id476650/index.html">Tempat enum di dunia yang berubah saat ini</a></li>
<li><a href="../id476656/index.html">26 November, Moskow - Alfa JS MeetUP # 3</a></li>
<li><a href="../id476658/index.html">VPS dengan kartu video (bagian 2): kemampuan komputasi</a></li>
<li><a href="../id476664/index.html">oktech: Frontend Meetup # 2: wawancara mini pembicara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>