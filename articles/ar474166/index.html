<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☠️ 🎰 👩‍👩‍👧‍👦 فهارس الغلاف لـ GiST 👦🏿 🏳️ ♟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مؤشر التغطية ليس مجرد ميزة أخرى قد تكون مفيدة. هذا الشيء عملي بحت. بدونها ، قد لا يعطي Index Only Scan الفوز. على الرغم من أن مؤشر التغطية في المواقف ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>فهارس الغلاف لـ GiST</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/474166/" style=";text-align:right;direction:rtl"> مؤشر التغطية ليس مجرد ميزة أخرى قد تكون مفيدة.  هذا الشيء عملي بحت.  بدونها ، قد لا يعطي Index Only Scan الفوز.  على الرغم من أن مؤشر التغطية في المواقف المختلفة فعال بطرق مختلفة. <br><br>  لا يتعلق الأمر بالفعل بتغطية الفهارس: بالمعنى الدقيق للكلمة ، ظهرت الفهارس الشاملة المزعومة في Postgres.  لكن بالترتيب: فهرس التغطية هو فهرس يحتوي على جميع قيم الأعمدة المطلوبة بواسطة الاستعلام ؛  ومع ذلك ، لم يعد الوصول إلى الجدول نفسه مطلوبًا.  تقريبا.  يمكنك أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تقرأ</a> عن "تقريبًا" والفروق الدقيقة الأخرى في مقال بقلم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إيجور روغوف</a> ، المتضمن في سلسلة فهرسه المكونة من 10 أجزاء (!).  ويتم إنشاء <b>الفهرس الشامل على</b> وجه التحديد للبحث في استعلامات نموذجية: تتم إضافة قيم الحقول التي لا يمكن البحث فيها إلى فهرس البحث ، فهي مطلوبة فقط حتى لا يتم الرجوع إلى الجدول مرة أخرى.  يتم تشكيل هذه الفهارس باستخدام الكلمة الأساسية INCLUDE. <br><br>  أنهت Anastasia Lubennikova (Postgres Professional) طريقة btree بحيث يمكن إدراج أعمدة إضافية في الفهرس.  تم تضمين هذا التصحيح في برنامج PostgreSQL 11. لكن لم يكن لدى تصحيحات طرق الوصول إلى GiST / SP-GiST وقت لتنضج قبل إصدار هذا الإصدار.  بحلول عيد الميلاد المجيد الثاني عشر. <br><a name="habracut"></a><br>  نشأت رغبة بناءة في الحصول على فهارس شاملة لـ GiST منذ فترة طويلة: تم تقديم تصحيح اختبار من Andrey Borodin <a href="">إلى</a> المجتمع مرة أخرى في منتصف أبريل 2018.  لقد قام بكل الأعمال الأساسية الصعبة للغاية. <br><br>  في أوائل أغسطس 2019 ، أضاف ألكساندر كوروتكوف تحسينات تجميلية وارتكب التصحيح. <br><br>  للتظاهر وبعض الأبحاث ، سنقوم بإنشاء مجموعة من 3 ملايين مستطيل.  في الوقت نفسه ، بضع كلمات حول نوع المربع ، لأنه ليس كل التلاعب بها بديهية. <br><br>  كان نوع الصندوق - أي المستطيل - طويلًا في بوستجرس ، ويتم تعريفه بنقطتين (نقطة الكتابة الهندسية) - الرؤوس المعاكسة للمستطيل (أي ، المستطيل لا يمكن أن يكون مائلًا ، مبعثرًا على الجانب).  نقرأ في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوثائق</a> : "تتم كتابة قيم مربع النوع في أحد النماذج التالية: <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">( ( x1 , y1 ) , ( x2 , y2 ) ) ( x1 , y1 ) , ( x2 , y2 ) x1 , y1 , x2 , y2</code> </pre> <br>  في الممارسة العملية ، عليك أن تكتب ، مثل ، مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'1,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (3,4),(1,2) (1 row)</span></span></code> </pre> <br>  أولاً ، يُظهر لنا Postgres القمة اليمنى العليا ، ثم أسفل اليسار.  إذا نكتب مثل هذا ، <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'5,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (5,4),(3,2) (1 row)</span></span></code> </pre> <br>  ثم سنتأكد من أن بوستجرس لم يعطِ القمم التي قدموها له.  قام بحساب اليمين العلوي والسفلي الأيسر من اليسار العلوي والسفلي الأيمن.  هذه خاصية ملائمة عندما يكون موقع القمم غير معروف مسبقًا - في حالة التوليد العشوائي ، على سبيل المثال.  التدوين "1،2" ، "3،4" يعادل النقطة (1،2) ، النقطة (3،4).  هذا النموذج هو في بعض الأحيان أكثر ملاءمة. <br><br><br><h3 style=";text-align:right;direction:rtl">  للعمل: ابحث في 3 ملايين مستطيل </h3><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> boxes(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, thebox <span class="hljs-type"><span class="hljs-type">box</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre><br>  سنقوم بتوليد 3 ملايين مستطيل عشوائي.  نريد توزيعًا طبيعيًا ، ولكن حتى لا نستخدم امتداد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">tablefunc</a> ، نستخدم الطريقة "السيئة": نحن نستخدم عشوائي () - عشوائي () ، والذي يعطي أيضًا صورة لطيفة (انظر الشكل). مع المستطيلات ، كلما كانت المستطيلات أكبر ، كلما كانت المسافة أقرب إلى المنتصف.  مراكز الجاذبية الخاصة بهم هي أيضا عشوائية.  هذه التوزيعات هي سمة لبعض أنواع بيانات المدينة الحقيقية.  وأولئك الذين يريدون الخوض في قوانين الإحصاء أو تحديث الذكريات يمكنهم أن يقرؤوا عن اختلاف المتغيرات العشوائية ، على سبيل المثال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . <br><br><img src="https://habrastorage.org/webt/2p/df/j4/2pdfj4sxnjja1ztiikvrkzrdniw.jpeg"><br><br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> boxes(thebox, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box( <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ), <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ) ), <span class="hljs-string"><span class="hljs-string">'box no.'</span></span> || x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br><br>  حجم الجدول الذي يعرض <code>\dt+</code> هو 242 ميغابايت.  الآن يمكنك البدء في البحث. <br><br>  نحن نبحث بدون فهرس: <br><br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------- Gather (cost=1000.00..47853.00 rows=3000 width=46) (actual time=0.140..246.998 rows=139189 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Parallel Seq Scan on boxes (cost=0.00..46553.00 rows=1250 width=46) (actual time=0.011..106.708 rows=46396 loops=3) Filter: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Rows Removed by Filter: 953604 Planning Time: 0.040 ms Execution Time: 259.262 ms (8 rows)</span></span></code> </pre> <br>  نرى أن هناك مسح تسلسلي متوازي - المسح المتسلسل (وإن كان متوازياً). <br><br>  قم بإنشاء فهرس منتظم وغير شامل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(thebox);</code> </pre> <br>  حجم فهرس <code>boxes_thebox_idx</code> ، والذي يعرض <code>\di+</code> ، 262 ميجابايت.  استجابة لنفس الطلب ، حصلنا على: <br><br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on boxes (cost=159.66..9033.30 rows=3000 width=46) (actual time=29.101..80.283 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_idx (cost=0.00..158.91 rows=3000 width=0) (actual time=25.029..25.029 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 0.053 ms Execution Time: 86.206 ms (7 rows)</span></span></code> </pre><br>  تم تقليل وقت البحث بعامل ثلاثة ، وبدلاً من Parallel Seq Scan ، حصلوا على مسح فهرس الصور النقطية.  لا تتوازى ، لكنها تعمل بشكل أسرع. <br><br>  الآن اقتل الفهرس القديم وقم بإنشاء فهرس شامل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  فهرس <code>boxes_thebox_name_idx</code> البدانة: 356 ميغابايت.  دعنا نذهب: <br><br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------ Bitmap Heap Scan on boxes (cost=207.66..9081.30 rows=3000 width=46) (actual time=86.822..152.014 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_name_idx (cost=0.00..206.91 rows=3000 width=0) (actual time=83.044..83.044 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 3.807 ms Execution Time: 157.997 ms (7 rows)</span></span></code> </pre> <br><br>  يتم استخدام Index Only Scan ، لكن الصورة حزينة: الوقت أطول تقريبًا من الوقت بدونه.  نقرأ كتيب مُنشئ المؤشرات ، في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء الأول</a> : <br><br>  es لا تحتوي فهارس Rang PostgreSQL على معلومات تتيح لك الحكم على مدى رؤية الصفوف.  لذلك ، تُرجع طريقة الوصول جميع إصدارات الصفوف التي تقع تحت شرط البحث ، بغض النظر عما إذا كانت مرئية للمعاملة الحالية أم لا.  ومع ذلك ، إذا اضطرت آلية الفهرسة إلى البحث في الجدول في كل مرة لتحديد مدى الرؤية ، فلن تختلف طريقة المسح هذه عن المسح العادي للفهرسة.  يتم حل المشكلة من خلال حقيقة أن PostgreSQL تدعم ما يسمى بخريطة الرؤية للجداول ، والتي تحدد فيها عملية الفراغ الصفحات التي لم تتغير فيها البيانات لفترة كافية حتى تراه جميع المعاملات ، بغض النظر عن وقت البدء ومستوى العزل.  إذا كان معرف الصف الذي تم إرجاعه بواسطة الفهرس يشير إلى مثل هذه الصفحة ، فلا يمكن التحقق من إمكانية الرؤية. ›› <br><br>  نحن نفعل فراغ.  نكرر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Index Only Scan using boxes_thebox_name_idx on boxes (cost=0.41..236.91 rows=3000 width=46) (actual time=0.104..38.651 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Fetches: 0 Planning Time: 0.052 ms Execution Time: 44.337 ms (5 rows)</span></span></code> </pre> <br>  مسألة مختلفة تماما!  ضعف الربح مقارنة بالمؤشر غير الشامل. <br><br><br><h3 style=";text-align:right;direction:rtl">  الانتقائية والكسب </h3><br>  يعتمد أداء الفهارس الشاملة على انتقائية الشروط في الاستعلامات.  للتحقيق في هذا الاعتماد قليلاً ، سنحل المشكلة العكسي: سنقوم بإنشاء تسمية مع فهرس لنقطة الكتابة ، وسوف نبحث عن عدد النقاط التي ستقع في المربع المحدد.  نشر النقاط مربعة بالتساوي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br>  حجم الجدول هو 211 ميغابايت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka);</code> </pre> <br>  الحجم 213 ميغابايت. <br><br>  من الواضح أننا سنأخذ جميع النقاط المتاحة في مربع: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1087.964..1864.059 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared read=54287 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1084.949..1084.949 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared read=27262 Planning Time: 0.102 ms Execution Time: 2029.501 ms (9 rows)</span></span></code> </pre> <br>  طلبنا شرح لإظهار المخازن المؤقتة.  وسوف يأتي في متناول اليدين.  الآن وقت تنفيذ الطلب أكثر من ثانيتين ، يمكن أن نرى أن المخازن المؤقتة: المشتركة قراءة = 54287.  في موقف آخر ، يمكن أن نرى مزيجًا من القراءة المشتركة والمشاركة المشتركة - أي ، تتم قراءة بعض المخازن المؤقتة من القرص (أو من ذاكرة التخزين المؤقت لنظام التشغيل) ، وبعض من ذاكرة التخزين المؤقت المخزن المؤقت.  نحن نعرف الحجم التقريبي للجدول والفهارس ، لذلك سنحمي أنفسنا من خلال تعيين مخازن مؤقتة مشتركة بحيث يناسب كل شيء - أعد تشغيل بوستجرس مع الخيار <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">-o "-c shared_buffers=1GB"</code> </pre> <br>  الآن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=231.032..613.326 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared hit=54248 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=228.068..228.068 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=27223 Planning Time: 0.070 ms Execution Time: 755.915 ms (9 rows)</span></span></code> </pre> <br>  وهذا هو ، أصبحت القراءة المشتركة نجاحًا مشتركًا ، وتم تقليل الوقت ثلاث مرات. <br><br>  تفصيل مهم آخر في EXPLAIN: يتم إرجاع 3 ملايين نقطة ، والتنبؤ بعدد السجلات التي تم إرجاعها هو 3 آلاف. Spoiler: لن يتغير هذا الرقم مع أي انتقائية.  لا يعرف المُحسّن كيفية تقييم العلاقة الأساسية عند العمل مع أنواع المربعات أو النقاط.  ولن تتغير الخطة: لأي حجم للمستطيل ، سيكون هناك فهرس مسح نقطي على test_covergist_tochka_idx. <br><br>  فيما يلي قياسان آخران مع عدد السجلات الصادرة ، يختلفان حسب أوامر الحجم: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=27.889..134.054 rows=269882 loops=1) Recheck Cond: ('(300000,300000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27024 Buffers: shared hit=29534 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=24.847..24.847 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Buffers: shared hit=2510 Planning Time: 0.074 ms Execution Time: 151.269 ms (9 rows)</span></span></code> </pre> <br>  تقوم بإرجاع سجلات أقل بـ 10 مرات (العدد الفعلي ... الصفوف = 269882) ، وقد انخفض الوقت بنحو 5 مرات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'30000,30000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1.882..16.095 rows=2780 loops=1) Recheck Cond: ('(30000,30000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2624 Buffers: shared hit=2655 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1.035..1.035 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Buffers: shared hit=31 Planning Time: 0.154 ms Execution Time: 16.702 ms (9 rows)</span></span></code> </pre> <br>  يتم احتساب محتويات مربع 30K × 30K (2780) في 16 مللي ثانية فقط.  وعندما يكون هناك عشرات السجلات ، يتم استخراجها بالفعل في أجزاء من ms ، وهذه القياسات غير موثوقة للغاية. <br><br>  أخيرًا ، قم بقياس الشيء نفسه باستخدام الفهرس الشامل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  الحجم 316 ميغابايت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.160..568.707 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=40492 Planning Time: 0.090 ms Execution Time: 709.837 ms (6 rows)</span></span></code> </pre> <br>  الوقت هو نفسه تقريبا كما هو الحال مع الفهرس التقليدي ، على الرغم من المسح الضوئي فقط. <br><br>  ولكن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.083..53.277 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=3735 Planning Time: 0.077 ms Execution Time: 66.162 ms (6 rows)</span></span></code> </pre> <br>  وكان 151 مللي.  وبناء على ذلك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.043..0.639 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=52 Planning Time: 0.053 ms Execution Time: 0.791 ms (6 rows)</span></span></code> </pre><br>  هذا بالفعل جزء صغير من مللي لنفس السجلات نقطة 2780. <br><br><h3 style=";text-align:right;direction:rtl">  المخازن المؤقتة مثل البنادق </h3><br>  يمكن التماس التفسير وإيجاده في بندقية لم تطلق النار بعد لكن ذلك كان معلقًا على الحائط: عدد الكتل المقروءة.  في حالة وجود فهرس شامل ، تتم قراءة كتل الفهرس نفسها فقط (Heap Fetches: 0).  في ثلاث حالات ، كانت هذه الأرقام 40492 و 3735 و 52. ولكن عند استخدام الفهرس العادي ، تتكون الكتل المقروءة من مجموع البتات المقروءة في فهرس Bitmap Heap Scan (54248 مع 3 ملايين سجل) وتلك التي يجب قراءتها من الكومة (27223) ، حيث لا يمكن استخراج حقل الاسم من فهرس عادي.  54248 + 27223 = 81471.  كان الحصري 40492. لحالتين أخريين: 29534 + 2510 = 31044 و ​​2655 + 31 = 2686.  في حالة وجود فهرس منتظم ، يتم قراءة المزيد من الكتل على أي حال ، ولكن مع تحسن في الانتقائية ، يبدأ عدد الكتل المقروءة في الاختلاف بترتيب الحجم بدلاً من مرتين بسبب حقيقة أن عدد الكتل الضرورية من الكومة يتناقص ببطء أكثر من قراءة كتل الفهرس. <br><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>مجموع السجلات التي تم إرجاعها</b> (بالألف) </td><td>  <b>3000</b> </td><td>  <b>270</b> </td><td>  <b>2.7</b> </td></tr><tr><td>  <b>كتل القراءة</b> (عادي / شامل) </td><td>  81471/40492 </td><td>  31044/3735 </td><td>  2686/52 </td></tr><tr><td>  <b>وقت</b> </td><td>  755/710 </td><td>  151/66 </td><td>  16 / 0.7 </td></tr></tbody></table></div><br><br>  ولكن ربما النقطة ليست الانتقائية على الإطلاق ، ولكن ببساطة حجم الجدول؟  في حالة تكرار ذلك ، نكرر نفس الخطوات ، حيث نقوم بإنشاء جدول به 300 ألف ، وليس 3 ملايين سجل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist_small(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist_small(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">300000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist_small (cost=14.61..867.19 rows=300 width=31) (actual time=36.115..130.435 rows=300000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2500 Buffers: shared hit=5225 -&gt; Bitmap Index Scan on test_covergist_small_tochka_idx (cost=0.00..14.53 rows=300 width=0) (actual time=35.894..35.895 rows=300000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=2725 Planning Time: 0.060 ms Execution Time: 158.580 (9 rows)</span></span></code> </pre><br>  بعد ذلك ، كرر الشيء نفسه بالنسبة للفهرس الشامل.  وهنا النتائج: <br><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>مجموع السجلات التي تم إرجاعها</b> (بالألف) </td><td>  <b>300</b> </td><td>  <b>27</b> </td><td>  <b>0.25</b> </td></tr><tr><td>  <b>كتل القراءة</b> (عادي / شامل) </td><td>  5225/3726 </td><td>  3026/352 </td><td>  270/8 </td></tr><tr><td>  <b>وقت</b> </td><td>  158/178 </td><td>  20/13 </td><td>  0.4 / 0.2 </td></tr></tbody></table></div><br><br>  في حالة تغطية النقاط بنسبة 100٪ ، كان الاستعلام أبطأ قليلاً من المؤشر المعتاد.  علاوة على ذلك ، كما في حالة 3 ملايين ، كل شيء سقط في مكانه.  وهذا هو ، الانتقائية مهمة. <br><br>  قامت شركتنا باختبار مؤشرات GiST الشاملة على بيانات حقيقية - مجموعة بها عدة ملايين من المستطيلات على خريطة موسكو.  الاستنتاج هو نفسه: في العديد من الحالات ، تسارع هذه الفهارس بشكل ملحوظ في الاستعلامات.  لكن لا يمكن توضيح المقالة بصور وأرقام الاختبارات: هذه البيانات ليست في المجال العام. <br><br><h3 style=";text-align:right;direction:rtl">  بدلا من الاستنتاج </h3><br>  دعنا نعود للحظة إلى المستطيلات العشوائية.  دعونا نحاول أن نفعل نفس الشيء مع spgist.  يمكنك تذكر أو معرفة معنى فهم الاختلافات بين SP-GiST و GiST من خلال قراءة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فهارس</a> المقالات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في PostgreSQL - 6</a> .  إنشاء فهرس شامل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>); ERROR: <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> "spgist" does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support included <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span></code> </pre> <br>  للأسف ، بالنسبة إلى SP-GiST ، لم يتم تطبيق الفهارس الشاملة بعد. <br>  لذلك هناك مجال للتحسين! <br><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar474166/">https://habr.com/ru/post/ar474166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar474144/index.html">كيفية إنشاء بدء التشغيل: مشروع إنترنت الأشياء من الفكرة إلى الإنتاج</a></li>
<li><a href="../ar474146/index.html">زيادة سرعة النسخ الاحتياطي والقدرة على اختيار نسبة الضغط في الإصدار الجديد من Zextras Backup</a></li>
<li><a href="../ar474150/index.html">اشتقاق نموذج نظام ديناميكي لمرشح Kalman المنفصل لنظام خطي تعسفي</a></li>
<li><a href="../ar474154/index.html">استئصال الزجاجية - نحرث المساحات المفتوحة من العالم التي تحدها تجويف العين</a></li>
<li><a href="../ar474164/index.html">زيمبرا هو كل شيء لدينا</a></li>
<li><a href="../ar474170/index.html">اعتراف التصميم - 15 نوفمبر ، موسكو ، دي تلغراف</a></li>
<li><a href="../ar474172/index.html">غرامة قدرها 30 ألف يورو للاستخدام غير القانوني لملفات تعريف الارتباط</a></li>
<li><a href="../ar474176/index.html">11 فيديو من اليوم الأول من DevFest 2019 في كالينينغراد</a></li>
<li><a href="../ar474178/index.html">IVR على Webhook</a></li>
<li><a href="../ar474180/index.html">كيفية تطبيق بنية الويب التي تتحمل الأخطاء في نظام Mail.ru Cloud Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>