<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥥 ↗️ 👌🏾 Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 2) 👔 💺 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita lanjutkan eksperimen dengan bytecode. Ini adalah kelanjutan dari artikel tentang byte-machine di assembler, di sini adalah bagian pertama . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433836/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="gambar"><br><br>  Mari kita lanjutkan eksperimen dengan bytecode.  Ini adalah kelanjutan dari artikel tentang byte-machine di assembler, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah bagian pertama</a> . <br><br>  Secara umum, saya berencana membuat fort interpreter di bagian kedua, dan fort compiler untuk mesin byte ini di bagian ketiga.  Tetapi volume yang diperoleh untuk artikel itu sangat besar.  Untuk membuat penerjemah, Anda perlu memperluas kernel (seperangkat perintah byte), dan mengimplementasikan: variabel, string parsing, memasukkan string, kamus, kamus pencarian ... Ya, setidaknya output angka harus bekerja.  Akibatnya, saya memutuskan untuk membagi artikel pada juru bahasa menjadi dua.  Oleh karena itu, dalam artikel ini kami akan memperluas kernel, menentukan variabel, menggambar output angka.  Berikut ini adalah contoh rencana: bagian ke-3 adalah juru bahasa, bagian ke-4 adalah kompiler.  Dan, tentu saja, tes kinerja.  Mereka akan berada di artikel 4 atau 5.  Artikel-artikel ini akan menjadi setelah tahun baru. <br><br>  Dan yang belum takut pada assembler dan bytecode yang mengerikan - selamat datang di cut!  :) <br><a name="habracut"></a><br>  Pertama, perbaiki kesalahan.  Mari kita atur ekstensi file .s, seperti kebiasaan untuk GAS (terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">mistergrim</a> ).  Kemudian, ganti int 0x80 dengan syscall dan gunakan register 64-bit (terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">qw1</a> ).  Pada awalnya, saya tidak hati-hati membaca deskripsi panggilan dan hanya mengoreksi register ... dan mendapatkan kesalahan Segmentasi.  Ternyata semuanya telah berubah untuk syscall, termasuk nomor panggilan.  sys_write untuk syscall adalah angka 1, dan sys_exit adalah 60. Sebagai hasilnya, perintah bad, type, dan bye mengambil bentuk sebagai berikut: <br><br><pre><code class="cpp hljs">b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, <span class="hljs-number"><span class="hljs-number">60</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_exit mov rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> syscall #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, <span class="hljs-number"><span class="hljs-number">60</span></span> #   № <span class="hljs-number"><span class="hljs-number">60</span></span> - sys_exit mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> syscall #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rsi push r8 syscall #   pop r8 jmp _next</code> </pre> <br>  Dan satu hal lagi.  Cukup benar, dalam komentar di artikel terakhir, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">berez</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">fpauk menulis</a> bahwa jika alamat prosesor digunakan dalam bytecode, maka bytecode tergantung pada platform.  Dan dalam contoh itu, alamat baris untuk "Halo, dunia!" Ditetapkan dalam bytecode oleh nilai (dengan perintah lit64).  Tentu saja ini tidak perlu.  Tapi itu cara termudah untuk memeriksa mesin byte.  Saya tidak akan melakukan ini lagi, tetapi saya akan mendapatkan alamat variabel dengan cara lain: khususnya, dengan perintah var (lebih lanjut tentang itu nanti). <br><br><h4>  Lakukan pemanasan </h4><br>  Dan sekarang, sebagai pemanasan, kita akan melakukan semua operasi aritmatika integer dasar (+, -, *, /, mod, / mod, abs).  Kami akan membutuhkannya. <br><br>  Kode ini sangat sederhana sehingga saya membawanya dalam spoiler tanpa komentar. <br><br><div class="spoiler">  <b class="spoiler_title">Aritmatika</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_add = <span class="hljs-number"><span class="hljs-number">0x21</span></span> bcmd_add: pop rax add [rsp], rax jmp _next b_sub = <span class="hljs-number"><span class="hljs-number">0x22</span></span> bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = <span class="hljs-number"><span class="hljs-number">0x23</span></span> bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = <span class="hljs-number"><span class="hljs-number">0x24</span></span> bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = <span class="hljs-number"><span class="hljs-number">0x25</span></span> bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = <span class="hljs-number"><span class="hljs-number">0x26</span></span> bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = <span class="hljs-number"><span class="hljs-number">0x27</span></span> bcmd_abs: mov rax, [rsp] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge _next neg rax mov [rsp], rax jmp _next</code> </pre></div></div><br>  Secara tradisional, di benteng, operasi presisi ganda ditambahkan ke operasi aritmatika dan stack biasa.  Kata-kata untuk operasi seperti itu biasanya dimulai dengan "2": 2DUP, 2SWAP, dll.  Tapi kami memiliki aritmatika standar sudah 64 bit, dan kami pasti tidak akan melakukan 128 hari ini :) <br><br>  Selanjutnya, kami menambahkan operasi stack dasar (drop, swap, root, -root, over, pick, roll). <br><br><div class="spoiler">  <b class="spoiler_title">Operasi tumpukan</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_drop = <span class="hljs-number"><span class="hljs-number">0x31</span></span> bcmd_drop: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_swap = <span class="hljs-number"><span class="hljs-number">0x32</span></span> bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = <span class="hljs-number"><span class="hljs-number">0x33</span></span> bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = <span class="hljs-number"><span class="hljs-number">0x34</span></span> bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = <span class="hljs-number"><span class="hljs-number">0x35</span></span> bcmd_over: push [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_pick = <span class="hljs-number"><span class="hljs-number">0x36</span></span> bcmd_pick: pop rcx push [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx] jmp _next b_roll = <span class="hljs-number"><span class="hljs-number">0x37</span></span> bcmd_roll: pop rcx mov rbx, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx] roll1: mov rax, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx - <span class="hljs-number"><span class="hljs-number">8</span></span>] mov [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx], rax dec rcx jnz roll1 push rbx jmp _next</code> </pre> </div></div><br>  Dan kami juga akan membuat perintah untuk membaca dan menulis ke memori (kata-kata Fort @ dan!).  Serta rekan-rekan mereka ke kedalaman bit yang berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Membaca dan menulis ke memori</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_get = <span class="hljs-number"><span class="hljs-number">0x40</span></span> bcmd_get: pop rcx push [rcx] jmp _next b_set = <span class="hljs-number"><span class="hljs-number">0x41</span></span> bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = <span class="hljs-number"><span class="hljs-number">0x42</span></span> bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = <span class="hljs-number"><span class="hljs-number">0x43</span></span> bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = <span class="hljs-number"><span class="hljs-number">0x44</span></span> bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = <span class="hljs-number"><span class="hljs-number">0x45</span></span> bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = <span class="hljs-number"><span class="hljs-number">0x46</span></span> bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = <span class="hljs-number"><span class="hljs-number">0x47</span></span> bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next</code> </pre> </div></div><br>  Kami mungkin masih membutuhkan tim pembanding, kami juga akan melakukannya. <br><br><div class="spoiler">  <b class="spoiler_title">Perintah perbandingan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># <span class="hljs-number"><span class="hljs-number">0</span></span>= b_zeq = <span class="hljs-number"><span class="hljs-number">0x50</span></span> bcmd_zeq: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz rfalse rtrue: push <span class="hljs-number"><span class="hljs-number">-1</span></span> jmp _next rfalse: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; b_zlt = <span class="hljs-number"><span class="hljs-number">0x51</span></span> bcmd_zlt: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jl rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; b_zgt = <span class="hljs-number"><span class="hljs-number">0x52</span></span> bcmd_zgt: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jg rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # = b_eq = <span class="hljs-number"><span class="hljs-number">0x53</span></span> bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &lt; b_lt = <span class="hljs-number"><span class="hljs-number">0x54</span></span> bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &gt; b_gt = <span class="hljs-number"><span class="hljs-number">0x55</span></span> bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &lt;= b_lteq = <span class="hljs-number"><span class="hljs-number">0x56</span></span> bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &gt;= b_gteq = <span class="hljs-number"><span class="hljs-number">0x57</span></span> bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre> </div></div><br>  Kami tidak akan menguji operasi.  Yang utama adalah assembler tidak akan memberikan kesalahan saat kompilasi.  Debugging akan sedang dalam proses menggunakannya. <br><br>  Segera buat kata kedalaman (stack depth).  Untuk melakukan ini, saat memulai, simpan nilai awal tumpukan data dan tumpukan kembali.  Nilai-nilai ini mungkin masih berguna ketika memulai ulang sistem. <br><br><pre> <code class="cpp hljs">init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_depth = <span class="hljs-number"><span class="hljs-number">0x38</span></span> bcmd_depth: mov rax, init_stack sub rax, rsp shr rax, <span class="hljs-number"><span class="hljs-number">3</span></span> push rax jmp _next</code> </pre> <br><h4>  Output angka </h4><br>  Nah, pemanasan sudah selesai, dan Anda harus sedikit berkeringat.  Ajari sistem kami untuk mengeluarkan angka.  Untuk menampilkan angka di benteng, kata "."  (titik).  Mari kita lakukan cara itu dilakukan dalam implementasi Fort standar, menggunakan kata-kata &lt;#, tahan, #, #s, #&gt;, basis.  Harus menyadari semua kata-kata ini.  Untuk membentuk angka, penyangga dan penunjuk ke karakter yang akan digunakan digunakan, ini akan menjadi kata holdbuf dan holdpoint. <br><br>  Jadi, kita perlu kata-kata ini: <br><br><ul><li>  <b>holdbuf</b> - buffer untuk menghasilkan representasi angka, formasi terjadi dari akhir </li><li>  <b>holdpoint</b> - alamat ke karakter yang terakhir ditampilkan (dalam holdbuf) </li><li>  <b>&lt;#</b> - awal pembentukan angka;  menetapkan holdpoint ke byte, setelah holdbuf byte terakhir </li><li>  <b>hold</b> - mengurangi holdpoint sebanyak 1 dan menyimpan karakter dari stack ke buffer di alamat yang diterima </li><li>  <b>#</b> - membagi kata di bagian atas tumpukan ke dasar sistem bilangan, menerjemahkan sisa divisi menjadi karakter dan menyimpannya ke buffer menggunakan penahan </li><li>  <b>#s</b> - mengonversi seluruh kata;  sebenarnya memanggil kata # dalam satu lingkaran sampai 0 tersisa di tumpukan </li><li>  <b>#&gt;</b> - penyelesaian konversi;  mendorong awal string yang terbentuk dan panjangnya ke tumpukan </li></ul><br>  Kami akan melakukan semua kata dalam bytecode, tetapi pertama-tama, mari kita berurusan dengan variabel. <br><br><h4>  Variabel </h4><br>  Dan di sini akan ada sedikit sihir Fortian.  Faktanya adalah bahwa dalam benteng variabel adalah sebuah kata.  Ketika kata ini dieksekusi, alamat sel memori yang menyimpan nilai variabel ada di tumpukan.  Anda dapat membaca atau menulis ke alamat ini.  Misalnya, untuk menulis nilai 12345 ke variabel A, Anda perlu menjalankan perintah berikut: "12345 A!".  Dalam contoh ini, 12345 didorong ke tumpukan, maka variabel A mendorong alamatnya, dan kata "!"  menghapus dua nilai dari tumpukan dan menulis 12345 ke alamat variabel A. Dalam implementasi khas benteng (dengan kode langsung), variabelnya adalah perintah CALL mikroprosesor dengan alamat _next, setelah itu tempat dicadangkan untuk menyimpan nilai variabel.  Ketika mengeksekusi kata seperti itu, mikroprosesor mentransfer kontrol ke _next dan mendorong alamat pengirim (via RSP) ke stack.  Tetapi di benteng, tumpukan mikroprosesor adalah aritmatika, dan kami tidak akan kembali ke mana pun.  Sebagai akibatnya, eksekusi berlanjut, dan pada stack adalah alamat variabel.  Dan semua ini dengan satu tim prosesor!  Di assembler, akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"> call _next #   _next,      ,   <span class="hljs-number"><span class="hljs-number">12345</span></span> .quad <span class="hljs-number"><span class="hljs-number">12345</span></span></code> </pre> <br>  Tapi kami punya bytecode, dan kami tidak bisa menggunakan mekanisme ini!  Saya tidak segera mencari tahu bagaimana membuat mekanisme seperti itu pada bytecode.  Tetapi, jika Anda berpikir logis, itu tidak mengganggu implementasi sesuatu yang sangat mirip.  Hanya perlu diingat bahwa ini bukan perintah prosesor, tetapi bytecode, lebih tepatnya, "subrutin" pada bytecode.  Inilah pernyataan masalahnya: <br><br><ul><li>  ini adalah kode byte, ketika mentransfer kontrol yang harus segera dikembalikan darinya </li><li>  setelah kembali, alamat tempat nilai variabel disimpan harus tetap berada di tumpukan aritmatika </li></ul><br>  Kami memiliki perintah byte keluar.  Mari kita membuat kata pada bytecode yang berisi perintah keluar tunggal.  Maka perintah ini akan kembali darinya.  Masih membuat perintah yang sama, yang juga mendorong alamat byte berikutnya pada stack (register R8).  Kami akan melakukan ini sebagai titik masuk tambahan untuk keluar untuk menghemat transisi: <br><br><pre> <code class="cpp hljs">b_var0 = <span class="hljs-number"><span class="hljs-number">0x28</span></span> bcmd_var0: push r8 b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br>  Sekarang variabel dasar akan terlihat seperti ini: <br><pre> <code class="cpp hljs">base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  By the way, mengapa tepatnya var0, dan bukan hanya var?  Faktanya adalah bahwa akan ada perintah lain untuk mengidentifikasi kata-kata yang lebih maju yang berisi data.  Saya akan menjelaskan secara lebih rinci dalam artikel berikut. <br><br>  Sekarang kita siap untuk menggambar.  Ayo mulai! <br><br><h4>  Kata dasar, holdbuf, holdpoint </h4><br>  Bagaimana variabel akan diatur sudah diputuskan.  Oleh karena itu, kata-kata dasar, holdbuf, holdpoint diperoleh sebagai berikut: <br><br><pre> <code class="cpp hljs">base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> holdbuf: .byte b_var0 .space holdbuf_len holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Ukuran buffer holdbuf dipilih 70. Jumlah bit bit maksimum adalah 64 (ini jika Anda memilih sistem biner).  Cadangan lain dari beberapa karakter telah dibuat untuk menempatkan, misalnya, tanda nomor dan spasi setelahnya.  Kami akan memeriksa buffer overflow, tetapi untuk saat ini kami tidak akan memasukkan karakter tambahan dalam buffer.  Maka akan memungkinkan untuk membuat diagnosis lain. <br><br><h4>  tahan </h4><br>  Sekarang Anda dapat membuat kata bertahan.  Di benteng, kodenya terlihat seperti ini: <br><br><pre> <code class="cpp hljs">: hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ;</code> </pre> <br>  Bagi mereka yang melihat benteng untuk pertama kalinya, saya akan menganalisis kode secara detail.  Untuk kata-kata selanjutnya saya tidak akan melakukan ini. <br><br>  Pada awalnya ada kata untuk definisi kata baru dan nama kata baru: ": tahan".  Setelah itu muncul kode yang diakhiri dengan kata ";".  Mari kita menganalisis kode kata tersebut.  Saya akan memberikan perintah dan status stack setelah menjalankan perintah.  Sebelum kata itu dipanggil, ada kode karakter pada tumpukan, yang ditempatkan di buffer (ditunjukkan oleh &lt;character&gt;).  Lebih lanjut ternyata seperti ini: <br><br><pre> <code class="cpp hljs">holdpoint &lt;&gt; &lt;  holdpoint&gt; @ &lt;&gt; &lt;  holdpoint&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>- &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; dup &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; holdbuf &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdbuf&gt; &gt; &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;,    holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>    holdbuf&gt;</code> </pre> <br>  Setelah itu adalah perintah if, yang mengkompilasi menjadi lompatan bersyarat ke urutan perintah antara yang lain dan kemudian.  Cabang bersyarat menghapus hasil perbandingan dari tumpukan dan melakukan transisi jika ada kebohongan di tumpukan.  Jika tidak ada transisi, cabang antara jika dan yang lain dijalankan, di mana ada dua perintah drop yang menghapus karakter dan alamat.  Jika tidak, eksekusi berlanjut.  Kata "!"  menyimpan nilai baru di holdpoint (alamat dan nilai dihapus dari tumpukan).  Dan kata "c!"  menulis karakter ke buffer, ini adalah perintah set8 byte (alamat dan nilai karakter dihapus dari stack). <br><br><pre> <code class="cpp hljs">dup &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; holdpoint &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint&gt; ! &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; c! ,  ,   ! :)</code> </pre> <br>  Inilah berapa banyak tindakan yang dilakukan oleh urutan pendek perintah ini!  Ya, benteng itu ringkas.  Dan sekarang kita menghidupkan "kompiler" manual di kepala :) Dan kita mengkompilasi semua ini menjadi bytecode: <br><pre> <code class="cpp hljs">hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ;</span></span></code> </pre> <br>  Di sini saya menggunakan label lokal (0 dan 1).  Label-label ini dapat diakses dengan nama khusus.  Misalnya, label 0 dapat diakses dengan nama 0f atau 0b.  Ini berarti tautan ke label 0 terdekat (maju atau mundur).  Cukup nyaman untuk label yang digunakan secara lokal, agar tidak muncul dengan nama yang berbeda. <br><br><h4>  Kata # </h4><br>  Mari kita buat kata #.  Di benteng, kodenya akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">: <span class="hljs-meta"><span class="hljs-meta"># base /mod swap dup 10 &lt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> c″ 0 + </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> 10 - c″ A + then hold ;</span></span></code> </pre> <br>  Kondisi di sini digunakan untuk memeriksa: apakah angka yang diterima kurang dari sepuluh?  Jika kurang, angka 0–9 digunakan, jika tidak, karakter yang dimulai dengan “A” digunakan.  Ini akan memungkinkan bekerja dengan sistem angka heksadesimal.  Urutan c ″ 0 mendorong kode karakter 0 ke tumpukan. Kami menghidupkan "kompiler": <br><br><pre> <code class="cpp hljs">conv: .byte b_call16 .word base - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta"># base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_lit8 .byte </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'0'</span></span></span><span class="hljs-meta"> # c″ 0 .byte b_add # + .byte b_branch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> .byte 1f - . 0: .byte b_lit8 .byte </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'A'</span></span></span><span class="hljs-meta"> # c″ A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ;</span></span></code> </pre> <br><h4>  Kata &lt;# </h4><br>  Kata &lt;# ini sangat sederhana: <br><br><pre> <code class="cpp hljs">: &lt;<span class="hljs-meta"><span class="hljs-meta"># holdbuf 70 + holdpoint ! ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_start: .byte b_call16 .word holdbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_exit</code> </pre> <br><h4>  Word #&gt; </h4><br>  Kata #&gt; untuk menyelesaikan konversi terlihat seperti ini: <br><br><pre> <code class="cpp hljs">: #&gt; holdpoint @ holdbuf <span class="hljs-number"><span class="hljs-number">70</span></span> + over - ;</code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_end: .byte b_call16 .word holdpoint - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word holdbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit</code> </pre> <br><h4>  Kata #s </h4><br>  Dan akhirnya, kata #s: <br><br><pre> <code class="cpp hljs">: <span class="hljs-meta"><span class="hljs-meta">#s do # dup 0= until ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_s: .byte b_call8 .byte conv - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit</code> </pre> <br>  Siapa pun yang berhati-hati akan melihat sedikit perbedaan antara bytecode dan kode benteng :) <br><br><h4>  Semuanya sudah siap </h4><br>  Sekarang, tidak ada yang akan menghentikan Anda dari membuat kata ".", Yang menampilkan angka: <br><br><pre> <code class="cpp hljs">: . &lt;# <span class="hljs-meta"><span class="hljs-meta">#s drop #&gt; type ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">dot: .byte b_call8 .byte conv_start - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call8 .byte conv_s - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_drop .byte b_call8 .byte conv_end - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_type .byte b_exit</code> </pre> <br>  Mari kita buat bytecode pengujian yang memeriksa poin kita: <br><br><pre> <code class="cpp hljs">start: .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">1234</span></span> .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre> <br>  Tentu saja, itu tidak berhasil sekaligus.  Tapi, setelah debugging, hasil berikut diperoleh: <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth 1234bye!</code> </pre><br>  Kusen terlihat segera.  Setelah nomor itu, benteng harus menampilkan spasi.  Tambahkan setelah conv_start (&lt;#) panggil perintah 32 hold. <br><br>  Kami juga menarik kesimpulan dari tanda itu.  Di awal, tambahkan dup abs, dan di akhir, periksa tanda salinan kiri dan masukkan minus jika angkanya negatif (0 &lt;jika c ″ tahan lalu).  Akibatnya, kata "."  mengambil formulir ini: <br><br><pre> <code class="cpp hljs">: . dup <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> &lt;# <span class="hljs-number"><span class="hljs-number">32</span></span> hold <span class="hljs-meta"><span class="hljs-meta">#s drop #&gt; 0&lt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> c″ - hold then type ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_lit8 .byte <span class="hljs-string"><span class="hljs-string">' '</span></span> .byte b_call16 .word hold - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call8 .byte conv_s - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_lit8 .byte <span class="hljs-string"><span class="hljs-string">'-'</span></span> .byte b_call16 .word hold - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_call8 .byte conv_end - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_type .byte b_exit</code> </pre> <br>  Di urutan awal perintah byte, masukkan angka negatif dan periksa: <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth -1234 bye!</code> </pre><br>  Ada kesimpulan angka! <br><br><div class="spoiler">  <b class="spoiler_title">Sumber lengkap</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq #<span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">-1234</span></span> .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> holdbuf: .byte b_var0 .space holdbuf_len holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp shr rax, 3 push rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #   № 1 - sys_write mov rdi, 1 #  № 1 — stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #   № 1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #   № 1 - sys_write mov rdi, 1 #  № 1 — stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #   № 60 - sys_exit mov rdi, 0 #    0 syscall #   b_type = 0x80 bcmd_type: mov rax, 1 #   № 1 - sys_write mov rdi, 1 #  № 1 - stdout pop rdx pop rsi push r8 syscall #   pop r8 jmp _next</span></span></span></span></code> </pre></div></div><br><h4>  Ringkasan </h4><br>  Sekarang kita memiliki inti perintah byte yang cukup baik: semua aritmatika dasar, operasi stack, operasi perbandingan, bekerja dengan memori, variabel.  Juga, sudah ada output angka, sepenuhnya diimplementasikan dalam bytecode.  Semuanya siap untuk dilakukan penerjemah, yang akan kita lakukan di artikel selanjutnya! <br><br>  Selamat Tahun Baru untuk semua! <br><br>  Kritik dipersilahkan!  :) <br><br>  Lanjutan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 3)</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433836/">https://habr.com/ru/post/id433836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433826/index.html">Persimmon 2.0 Petunjuk untuk digunakan</a></li>
<li><a href="../id433828/index.html">Menggunakan Peta QML untuk Membangun Airways - Bagian 1</a></li>
<li><a href="../id433830/index.html">Lampu Diall LED Baru</a></li>
<li><a href="../id433832/index.html">Pemformatan kode sumber ClangFormat di Linux: masalah dan solusi</a></li>
<li><a href="../id433834/index.html">Seperti yang dilakukan metrik Ivan, DevOps. Mulai</a></li>
<li><a href="../id433838/index.html">Surat publik biohacker Joshua Zayner</a></li>
<li><a href="../id433842/index.html">[Jumat] Graffiti ASCII pada monitor retro dan permukaan lainnya</a></li>
<li><a href="../id433844/index.html">Tentang tiga komponen yang diperlukan agar TI dapat bekerja dengan sukses</a></li>
<li><a href="../id433846/index.html">Tenaga nuklir sebelum munculnya pembangkit listrik tenaga nuklir</a></li>
<li><a href="../id433848/index.html">Paten Apple untuk kendaraan listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>