<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👩🏼‍🤝‍👨🏾 🤷 JVM TI: comment créer un plugin pour une machine virtuelle 👩🏼‍🚀 🤲🏿 🤛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Souhaitez-vous ajouter des fonctionnalités utiles à la JVM? Théoriquement, chaque développeur peut contribuer à OpenJDK, cependant, dans la pratique, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: comment créer un plugin pour une machine virtuelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  Souhaitez-vous ajouter des fonctionnalités utiles à la JVM?  Théoriquement, chaque développeur peut contribuer à OpenJDK, cependant, dans la pratique, toute modification non triviale de HotSpot n'est pas la bienvenue du côté, et même avec le cycle de publication raccourci actuel, il peut s'écouler des années avant que les utilisateurs de JDK voient votre fonctionnalité. <br><br>  Néanmoins, dans certains cas, il est possible d'étendre les fonctionnalités d'une machine virtuelle sans même toucher à son code.  L'interface de l'outil JVM, l'API standard pour interagir avec la JVM, est utile. <br><br>  Dans l'article, je vais montrer avec des exemples concrets ce qui peut être fait avec, dire ce qui a changé en Java 9 et 11 et honnêtement mettre en garde contre les difficultés (spoiler: je dois faire face à C ++). <br><br>  J'ai également parlé de ce matériel sur JPoint.  Si vous préférez la vidéo, vous pouvez regarder le rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo</a> . <br><a name="habracut"></a><br><h2>  Entrée </h2><br>  Le réseau social Odnoklassniki, où je travaille en tant qu'ingénieur principal, est presque entièrement écrit en Java.  Mais aujourd'hui, je vais vous parler d'une autre partie, qui n'est pas entièrement en Java. <br><br>  Comme vous le savez, le problème le plus courant chez les développeurs Java est NullPointerException.  Une fois, en service sur le portail, j'ai également rencontré NPE en production.  L'erreur était accompagnée de quelque chose comme cette trace de pile: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Bien sûr, sur la trace de la pile, vous pouvez tracer l'endroit où l'exception s'est produite jusqu'à une ligne spécifique dans le code.  Seulement dans ce cas, cela ne m'a pas fait me sentir mieux, car ici les NPE peuvent se rencontrer beaucoup où: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Ce serait formidable si la JVM suggérait exactement où était cette erreur, par exemple, comme ceci: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Mais, malheureusement, NPE ne contient plus rien de tel.  Bien qu'ils le demandent depuis longtemps, au moins avec Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce bug</a> a 16 ans.  Périodiquement, de plus en plus de bugs ont été ouverts sur ce sujet, mais ils ont toujours été fermés en tant que "Won't Fix": <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Cela ne se produit pas partout.  Volker Simonis de SAP a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqué</a> comment il avait implémenté cette fonctionnalité dans SAP JVM pendant longtemps et l'avait aidée plusieurs fois.  Un autre employé de SAP a de nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">soumis un</a> bogue dans OpenJDK et s'est porté volontaire pour implémenter un mécanisme similaire à celui de SAP JVM.  Et, voilà, cette fois, le bogue n'a pas été fermé - il y a une chance que cette fonctionnalité entre dans JDK 14. <br><br>  Mais quand le JDK 14 sortira-t-il et quand y passerons-nous?  Que faire si vous souhaitez étudier le problème ici et maintenant? <br><br>  Vous pouvez, bien sûr, maintenir votre fork d'OpenJDK.  La fonctionnalité de rapport NPE elle-même n'est pas si compliquée, nous aurions très bien pu l'implémenter.  Mais en même temps, il y aura tous les problèmes de support de votre propre assemblage.  Ce serait formidable d'implémenter la fonctionnalité une fois, puis de la connecter simplement à n'importe quelle version de la JVM en tant que plugin.  Et c'est vraiment possible!  La JVM possède une API spéciale (développée à l'origine pour toutes sortes de débogueurs et de profileurs): JVM Tool Interface. <br><br>  Plus important encore, cette API est standard.  Il a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification</a> stricte et lorsque vous implémentez une fonctionnalité conformément à celle-ci, vous pouvez être sûr qu'elle fonctionnera dans les nouvelles versions de la JVM. <br><br>  Pour utiliser cette interface, vous devez écrire un petit (ou grand, selon vos tâches) programme.  Natif: il est généralement écrit en C ou C ++.  La <code>jdk/include/jvmti.h</code> JDK standard possède un fichier d'en-tête <code>jdk/include/jvmti.h</code> que vous souhaitez inclure. <br><br>  Le programme est compilé dans une bibliothèque dynamique et connecté par le paramètre <code>-agentpath</code> lors du démarrage de la JVM.  Il est important de ne pas le confondre avec un autre paramètre similaire: <code>-javaagent</code> .  En fait, les agents Java sont un cas particulier des agents JVM TI.  Plus loin dans le texte sous le mot "agent", on entend précisément l'agent natif. <br><br><h2>  Par où commencer </h2><br>  Voyons en pratique comment écrire l'agent JVM TI le plus simple, une sorte de "bonjour le monde". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  La première ligne, j'inclus le même fichier d'en-tête.  Vient ensuite la fonction principale qui doit être implémentée dans l'agent: <code>Agent_OnLoad()</code> .  La machine virtuelle elle-même l'appelle au démarrage de l'agent, en passant un pointeur sur l'objet <code>JavaVM*</code> . <br><br>  En l'utilisant, vous pouvez obtenir un pointeur vers l'environnement JVM TI: <code>jvmtiEnv*</code> .  Et à travers elle, à son tour, déjà appeler JVM TI-fonctions.  Par exemple, à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GetSystemProperty,</a> lisez la valeur d'une propriété système. <br><br>  Si maintenant <code>-agentpath</code> ce "bonjour le monde" en passant le fichier dll compilé à <code>-agentpath</code> , la ligne imprimée par notre agent apparaîtra dans la console avant que le programme Java ne démarre: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Enrichissement NPE </h2><br>  Puisque Hello World n'est pas l'exemple le plus intéressant, revenons à nos exceptions.  Le code d'agent complet qui complète les rapports NPE se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> . <br><br>  Voici à quoi <code>Agent_OnLoad()</code> si je veux demander à la machine virtuelle de nous informer de toutes les exceptions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Je demande d'abord à la JVM TI la capacité correspondante (can_generate_exception_events).  Nous parlerons de la capacité séparément. <br><br>  L'étape suivante consiste à s'abonner aux événements d'exception.  Chaque fois que la JVM lève des exceptions (qu'elles soient interceptées ou non), notre fonction <code>ExceptionCallback()</code> sera appelée. <br><br>  La dernière étape consiste à appeler <code>SetEventNotificationMode()</code> pour activer la remise des notifications. <br><br><div class="spoiler">  <b class="spoiler_title">Dans ExceptionCallback, la JVM transmet tout ce dont nous avons besoin pour gérer les exceptions.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Ici, il y a à la fois l'objet du thread qui a levé l'exception (thread), et l'endroit où cela s'est produit (méthode, emplacement), et l'objet de l'exception (exception), et même l'endroit dans le code qui capture cette exception (catch_method, catch_location). <br><br>  Ce qui est important: dans ce rappel, en plus du pointeur vers l'environnement JVM TI, l'environnement JNI (env) est également passé.  Cela signifie que nous pouvons y utiliser toutes les fonctions JNI.  Autrement dit, JVM TI et JNI coexistent parfaitement, se complétant mutuellement. <br><br>  Dans mon agent, j'utilise les deux.  En particulier, via JNI, je vérifie que mon exception est de type <code>NullPointerException</code> , puis je remplace le champ <code>detailMessage</code> un message d'erreur. <br><br>  Puisque la JVM elle-même nous transmet l'emplacement - l'index de bytecode sur lequel l'exception s'est produite, alors je viens de mettre cet emplacement ici dans le message: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  Le nombre 66 indique l'index en bytecode où cette exception s'est produite.  Mais l'analyse manuelle du bytecode est morne: vous devez décompiler le fichier de classe, rechercher la 66e instruction, essayer de comprendre ce qu'elle faisait ... Ce serait formidable si notre agent lui-même pouvait montrer quelque chose de plus lisible par l'homme. <br><br>  Cependant, dans ce cas, la JVM TI a tout ce dont vous avez besoin.  Certes, vous devez demander des fonctionnalités supplémentaires de la JVM TI: obtenir le bytecode et la méthode du pool constant. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Maintenant, je vais développer ExceptionCallback: grâce à la fonction JVM TI <code>GetBytecodes()</code> je vais obtenir le corps de la méthode pour vérifier ce qu'il <code>GetBytecodes()</code> par index de localisation.  Vient ensuite une grande instruction de bytecode de commutateur: s'il s'agit d'un accès au tableau, il y aura un message d'erreur, si l'accès au champ est un autre message, si l'appel de méthode est le troisième, et ainsi de suite. <br><br><div class="spoiler">  <b class="spoiler_title">Code de rappel d'exception</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Il ne reste plus qu'à substituer le nom du champ ou de la méthode.  Vous pouvez l'obtenir à partir du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pool constant</a> , qui est à nouveau disponible grâce à la JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Vient ensuite un peu de magie, mais en réalité rien de délicat, juste conformément à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la spécification du</a> format de fichier de classe, nous analysons le pool constant et à partir de là, nous isolons la ligne - le nom de la méthode. <br><br><div class="spoiler">  <b class="spoiler_title">Analyse du pool constant</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Autre point important: certaines fonctions JVM TI, par exemple <code>GetConstantPool()</code> ou <code>GetBytecodes()</code> , allouent une certaine structure en mémoire native, qui doit être libérée lorsque vous avez fini de travailler avec. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Exécutez le programme source avec notre agent étendu, et voici une description complètement différente de l'exception: il signale que nous avons appelé la méthode longValue () sur l'objet null. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Autres applications </h2><br>  De manière générale, les développeurs souhaitent souvent gérer les exceptions à leur manière.  Par exemple, redémarrez automatiquement la JVM si une <code>StackOverflowError</code> . <br><br>  Ce désir peut être compris, car <code>StackOverflowError</code> est la même erreur fatale que <code>OutOfMemoryError</code> , après son occurrence, il n'est plus possible de garantir le bon fonctionnement du programme.  Ou, par exemple, parfois pour analyser le problème, je souhaite recevoir un vidage de thread ou un vidage de tas lorsqu'une exception se produit. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  En toute équité, l'IBM JDK a une telle opportunité hors de la boîte.  Mais maintenant, nous savons déjà qu'en utilisant l'agent JVM TI, vous pouvez implémenter la même chose dans HotSpot.  Il suffit de s'abonner au rappel d'exception et d'analyser l'exception.  Mais comment supprimer le vidage de thread ou le vidage de tas de notre agent?  La JVM TI a tout ce dont vous avez besoin pour ce cas: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  Il n'est pas très pratique d'implémenter l'ensemble du mécanisme de contournement du tas et de création d'un vidage.  Mais je vais partager le secret de la façon de le rendre plus facile et plus rapide.  Certes, ce n'est plus inclus dans la JVM TI standard, mais c'est une extension privée de Hotspot. <br><br>  Vous devez connecter le fichier d'en-tête <a href="">jmm.h à</a> partir des sources HotSpot et appeler la fonction <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Il renverra un pointeur vers l'interface de gestion HotSpot, qui en un seul appel générera un vidage de tas ou un vidage de thread.  Le code complet de l'exemple se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma réponse</a> à Stack Overflow. <br><br>  Naturellement, vous pouvez gérer non seulement des exceptions, mais également un tas d'autres événements liés à l'opération JVM: démarrage / arrêt de threads, chargement de classes, garbage collection, méthodes de compilation, entrée / sortie de méthodes, même accès ou modification de champs spécifiques d'objets Java. <br><br>  J'ai un exemple d'un autre agent <a href="">vmtrace</a> qui souscrit à de nombreux événements JVM TI standard et les enregistre.  Si je lance un programme simple avec cet agent, j'obtiendrai un journal détaillé, qui, une fois terminé, avec des horodatages: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Comme vous pouvez le voir, pour simplement imprimer Hello World, des centaines de classes sont chargées, des dizaines et des centaines de méthodes sont générées et compilées.  Il devient clair pourquoi Java prend autant de temps à fonctionner.  Tout sur tout a pris plus de deux cents millisecondes. <br><br><h2>  Ce que JVM TI peut faire </h2><br>  En plus de la gestion des événements, la JVM TI possède un tas d'autres fonctionnalités.  Ils peuvent être divisés en deux groupes. <br><br>  L'une est obligatoire, et toute JVM qui prend en charge la JVM TI doit l'implémenter.  Il s'agit notamment des opérations d'analyse des méthodes, des champs, des flux, de la possibilité d'ajouter de nouvelles classes au chemin de classe, etc. <br><br>  Il existe des fonctionnalités optionnelles qui nécessitent une demande de capacités préliminaire.  JVM n'est pas tenu de les prendre en charge tous, cependant HotSpot implémente l'intégralité de la spécification.  Les fonctionnalités optionnelles sont divisées en deux sous-groupes: ceux qui ne peuvent être connectés qu'au début de la machine virtuelle Java (par exemple, la possibilité de définir un point d'arrêt ou d'analyser des variables locales), et ceux qui peuvent être connectés à tout moment (en particulier, bytecode ou pool constant, que je utilisé ci-dessus). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  Vous pouvez remarquer que la liste des fonctionnalités est très similaire aux capacités du débogueur.  En fait, un débogueur Java n'est rien de plus qu'un cas particulier de l'agent JVM TI, qui tire parti de toutes ces capacités et demande toutes les capacités. <br><br>  La séparation des capacités entre celles qui peuvent être activées à tout moment et celles qui ne le sont qu'au démarrage est effectuée exprès.  Toutes les fonctionnalités ne sont pas gratuites, certaines comportent des frais généraux. <br><br>  Si tout est clair avec les frais généraux directs qui accompagnent l'utilisation de la fonctionnalité, alors il y a encore moins indirects qui apparaissent même si vous n'utilisez pas la fonctionnalité, mais simplement grâce à des capacités, vous déclarez que cela sera nécessaire dans le futur.  Cela est dû au fait que la machine virtuelle peut compiler le code différemment ou ajouter des vérifications supplémentaires à l'exécution. <br><br>  Par exemple, la capacité déjà envisagée de s'abonner à des exceptions (can_generate_exception_events) conduit au fait que toutes les exceptions de lancement se feront lentement.  En principe, ce n'est pas si effrayant, car les exceptions sont une chose rare dans un bon programme Java. <br><br>  La situation avec les variables locales est légèrement pire.  Pour can_access_local_variables, qui vous permet d'obtenir les valeurs des variables locales à tout moment, vous devez désactiver certaines optimisations importantes.  En particulier, Escape Analysis cesse complètement de fonctionner, ce qui peut entraîner une surcharge notable: selon l'application, 5 à 10%. <br><br>  D'où la conclusion: si vous exécutez Java avec l'agent de débogage activé, sans même l'utiliser, les applications s'exécuteront plus lentement.  Quoi qu'il en soit, inclure un agent de débogage dans la production n'est pas une bonne idée. <br><br>  Un certain nombre de fonctionnalités, par exemple, la définition d'un point d'arrêt ou le traçage de toutes les entrées / sorties d'une méthode, entraînent une surcharge beaucoup plus importante.  En particulier, certains événements JVM TI (FieldAccess, MethodEntry / Exit) ne fonctionnent que dans l'interpréteur. <br><br><h2>  Un agent est bon et deux, c'est mieux </h2><br>  Vous pouvez connecter plusieurs agents à un seul processus en spécifiant simplement plusieurs paramètres <code>-agentpath</code> .  Chacun aura son propre environnement JVM TI.  Cela signifie que chacun peut souscrire à ses capacités et intercepter ses événements de manière indépendante. <br><br>  Et si deux agents se sont abonnés à l'événement Breakpoint, et dans l'un, le point d'arrêt est défini dans une méthode, alors lorsque cette méthode est exécutée, le deuxième agent recevra-t-il l'événement? <br><br>  En réalité, une telle situation ne peut pas se produire (au moins dans HotSpot JVM).  Parce qu'il existe certaines capacités que seul un des agents peut posséder à un moment donné.  Il s'agit notamment de breakpoint_events.  Par conséquent, si le deuxième agent demande la même capacité, il recevra une erreur en réponse. <br><br>  Il s'agit d'une conclusion importante: l'agent doit toujours vérifier le résultat de la demande de capacités, même si vous exécutez sur HotSpot et sachez que tous sont disponibles.  La spécification JVM TI ne dit rien sur les capacités exclusives, mais HotSpot a une telle fonctionnalité de mise en œuvre. <br><br>  Certes, l'isolement des agents ne fonctionne pas toujours parfaitement.  Pendant le développement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">async-profiler,</a> je suis tombé sur ce problème: lorsque nous avons deux agents et que l'un demande la génération d'événements de compilation de méthodes, tous les agents reçoivent ces événements.  Bien sûr, j'ai déposé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bogue</a> , mais vous devez garder à l'esprit que des événements auxquels vous ne vous attendez pas peuvent se produire dans votre agent. <br><br><h2>  Utilisation dans un programme régulier </h2><br>  JVM TI peut sembler être une chose très spécifique pour les débogueurs et les profileurs, mais il peut également être utilisé dans un programme Java standard.  Prenons un exemple. <br><br>  Le paradigme de programmation réactive est maintenant répandu lorsque tout est asynchrone, mais il y a un problème avec ce paradigme. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  J'exécute deux tâches asynchrones qui ne diffèrent que par les paramètres.  Et si quelque chose se passe mal, une exception est levée: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  À partir de la trace de la pile, il est complètement difficile de déterminer laquelle de ces tâches a provoqué le problème.  Parce que l'exception se produit dans un thread complètement différent, où nous n'avons pas de contexte.  Comment comprendre dans quelle tâche? <br><br>  Comme l'une des solutions, vous pouvez ajouter des informations sur l'endroit où nous l'avons créé au constructeur de notre tâche asynchrone: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Autrement dit, rappelez-vous l'emplacement - un endroit spécifique dans le code, jusqu'à la ligne d'où le constructeur a été appelé.  Et en cas d'exception à le mettre en gage: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Maintenant, lorsqu'une exception se produit, nous verrons que cela s'est produit sur la ligne 14 dans le TaskRunner (où la tâche avec le paramètre BAD est créée): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Mais comment obtenir la place dans le code d'où le constructeur est appelé?  Avant Java 9, il y avait le seul moyen légal de le faire: obtenir une trace de pile, ignorer quelques images non pertinentes, et un peu plus bas sur la pile sera l'endroit que notre code appelait. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Mais il y a un problème.  Obtenir le StackTrace complet est assez lent.  J'ai tout un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> consacré à cela. <br><br>  Ce ne serait pas un si gros problème si cela arrivait rarement.  Mais, par exemple, nous avons un service Web - un frontend qui accepte les requêtes HTTP.  Ceci est une excellente application, des millions de lignes de code.  Et pour détecter les erreurs de rendu, nous utilisons un mécanisme similaire: dans les composants de rendu, nous nous souvenons de l'endroit où ils sont créés.  Nous avons des millions de ces composants, donc obtenir toutes les traces de pile prend un temps tangible pour démarrer l'application, pas seulement une minute.  Par conséquent, cette fonctionnalité était auparavant désactivée en production, bien que pour l'analyse des problèmes, elle soit nécessaire en production. <br><br>  Java 9 a introduit une nouvelle façon de contourner les piles de flux: StackWalker, qui via l'API Stream peut faire tout cela paresseusement, à la demande.  Autrement dit, nous pouvons sauter le bon nombre d'images et n'en obtenir qu'une qui nous intéresse. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Cela fonctionne un peu mieux que d'obtenir la trace complète de la pile, mais pas par ordre de grandeur ou même plusieurs fois.  Dans notre cas, cela s'est avéré environ une fois et demie plus rapide: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  Il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème connu</a> avec l'implémentation sous-optimale de StackWalker, et très probablement il sera même corrigé dans JDK 13. Mais encore une fois, que devons-nous faire maintenant en Java 8, où StackWalker n'est même pas lent? <br><br>  La JVM TI revient à la rescousse.  Il existe une fonction <code>GetStackTrace()</code> qui peut faire tout ce dont vous avez besoin: obtenir un fragment d'une trace de pile d'une longueur donnée, à partir du cadre spécifié, et ne rien faire de plus. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  Il ne reste qu'une question: comment appeler la fonction JVM TI depuis notre programme Java?  Comme toute autre méthode native: chargez la bibliothèque native avec <code>System.loadLibrary()</code> , où sera l'implémentation JNI de notre méthode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Un pointeur vers l'environnement JVM TI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être obtenu</a> non seulement à partir d'Agent_OnLoad (), mais également pendant l'exécution du programme, puis à l'utiliser à partir de méthodes JNI natives ordinaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href="">jvmtiEnter.xsl</a> . <br><br>  :    HotSpot       XSLT-.       HotSpot. <br><br>     ?       ,   .  ,   - jmethodID  ,      .      ,      . <br><br><h2>   </h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br>      JDK     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jattach</a> . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">async-profiler</a>      ,   -  JVM-,    jattach. <br><br>    JVM TI-    , ,  <code>Agent_OnLoad()</code> ,    <code>Agent_OnAttach()</code> .  :  <code>Agent_OnAttach()</code>    capabilities,       . <br><br>  ,           ,   <code>Agent_OnAttach()</code>   . <br><br>   .     IntelliJ IDEA:    Java-, ,          - . <br><br>  process ID  IDEA,   jattach     JVM TI- patcher.dll: <br> <code>jattach 8648 load patcher.dll true</code> <br> <br>          : <br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br>    ?   Java-   ( <code>javax.swing.AbstractButton</code> )    JNI  <code>setBackground()</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br><h2>    Java 9 </h2><br> JVM TI   , ,    ,     API,     .      Java 9. <br><br>  , Java 9     ,   .  ,    «» JDK,       . <br><br> ,  JDK     Direct ByteBuffer.    API: <br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br> ,  Cassandra    ,          MappedByteBuffer,      ,  JVM  . <br><br>          JDK 9,  IllegalAccessError: <br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br>      Reflection:      . <br><br> ,  Java       Linux.   -        <code>java.io.FileDescriptor</code>       JNI    -  .  ,     JDK 9,     : <br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br> ,   JVM,           .      ,   . ,    Cassandra  Java 11,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> : <br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> JVM TI    : <br><br><ul><li> GetAllModules </li><li> AddModuleExports </li><li> AddModuleOpens </li><li>  . . </li></ul><br>    ,    :    JVM,    ,    ,      . <br><br>      Direct ByteBuffer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br>     ,   IllegalAccessError.     agentpath    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">antimodule</a> ,     .     . <br><br><h2>    Java 11 </h2><br>     Java 11.   ,   !     :    <code>SampledObjectAlloc</code> ,    ,      . <br><br>  callback   ,     : ,  ,   ,  , .   <code>SetHeapSampingInterval</code>   ,      . <br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>   ?         ,    ,     .        Java Flight Recorder. <br><br>     ,     ,     ,  , . <br><br>           Thread Local Allocation Buffer   .      TLAB   ,   .        ,     . <br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br>     ,     TLAB,    .          JVM runtime   . <br><br>   ,        ,       —     5%. <br><br>  ,    ,    JDK 7,    Flight Recorder.    API     async-profiler.  ,   JDK 11,  API  ,   JVM TI,      .  , YourKit   .     API,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,    . <br><br>         . ,   ,    , , . <br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Conclusion </h2><br> JVM TI —      . <br><br> ,     ++,     JVM         .  ,  JVM TI        . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> GitHub</a> . ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458812/">https://habr.com/ru/post/fr458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458798/index.html">Nutrient Bot ou comment je veux prendre du pain avec des entraîneurs de fitness</a></li>
<li><a href="../fr458800/index.html">Apprentissage profond. Apprentissage fédéré</a></li>
<li><a href="../fr458804/index.html">Recueil d'articles sur l'apprentissage automatique et l'intelligence artificielle</a></li>
<li><a href="../fr458808/index.html">Rapport Habr post-mortem: un journal est tombé</a></li>
<li><a href="../fr458810/index.html">Corel et Parallels vendus au groupe d'investissement KKR des États-Unis</a></li>
<li><a href="../fr458814/index.html">Lancement d'un site pour un produit avec une demande informée</a></li>
<li><a href="../fr458818/index.html">Des contemporains éminents</a></li>
<li><a href="../fr458820/index.html">Sur l'implémentation du célèbre genre sur la plateforme Minecraft</a></li>
<li><a href="../fr458826/index.html">Comment éliminer les anciens articles pour qu'ils croissent fortement dans le bio: + 104% de trafic pendant six mois</a></li>
<li><a href="../fr458828/index.html">Pourquoi, pourquoi et quand utiliser ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>