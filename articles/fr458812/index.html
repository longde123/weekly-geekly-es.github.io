<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåï üë©üèº‚Äçü§ù‚Äçüë®üèæ ü§∑ JVM TI: comment cr√©er un plugin pour une machine virtuelle üë©üèº‚ÄçüöÄ ü§≤üèø ü§õüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Souhaitez-vous ajouter des fonctionnalit√©s utiles √† la JVM? Th√©oriquement, chaque d√©veloppeur peut contribuer √† OpenJDK, cependant, dans la pratique, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: comment cr√©er un plugin pour une machine virtuelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  Souhaitez-vous ajouter des fonctionnalit√©s utiles √† la JVM?  Th√©oriquement, chaque d√©veloppeur peut contribuer √† OpenJDK, cependant, dans la pratique, toute modification non triviale de HotSpot n'est pas la bienvenue du c√¥t√©, et m√™me avec le cycle de publication raccourci actuel, il peut s'√©couler des ann√©es avant que les utilisateurs de JDK voient votre fonctionnalit√©. <br><br>  N√©anmoins, dans certains cas, il est possible d'√©tendre les fonctionnalit√©s d'une machine virtuelle sans m√™me toucher √† son code.  L'interface de l'outil JVM, l'API standard pour interagir avec la JVM, est utile. <br><br>  Dans l'article, je vais montrer avec des exemples concrets ce qui peut √™tre fait avec, dire ce qui a chang√© en Java 9 et 11 et honn√™tement mettre en garde contre les difficult√©s (spoiler: je dois faire face √† C ++). <br><br>  J'ai √©galement parl√© de ce mat√©riel sur JPoint.  Si vous pr√©f√©rez la vid√©o, vous pouvez regarder le rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vid√©o</a> . <br><a name="habracut"></a><br><h2>  Entr√©e </h2><br>  Le r√©seau social Odnoklassniki, o√π je travaille en tant qu'ing√©nieur principal, est presque enti√®rement √©crit en Java.  Mais aujourd'hui, je vais vous parler d'une autre partie, qui n'est pas enti√®rement en Java. <br><br>  Comme vous le savez, le probl√®me le plus courant chez les d√©veloppeurs Java est NullPointerException.  Une fois, en service sur le portail, j'ai √©galement rencontr√© NPE en production.  L'erreur √©tait accompagn√©e de quelque chose comme cette trace de pile: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Bien s√ªr, sur la trace de la pile, vous pouvez tracer l'endroit o√π l'exception s'est produite jusqu'√† une ligne sp√©cifique dans le code.  Seulement dans ce cas, cela ne m'a pas fait me sentir mieux, car ici les NPE peuvent se rencontrer beaucoup o√π: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Ce serait formidable si la JVM sugg√©rait exactement o√π √©tait cette erreur, par exemple, comme ceci: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Mais, malheureusement, NPE ne contient plus rien de tel.  Bien qu'ils le demandent depuis longtemps, au moins avec Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce bug</a> a 16 ans.  P√©riodiquement, de plus en plus de bugs ont √©t√© ouverts sur ce sujet, mais ils ont toujours √©t√© ferm√©s en tant que "Won't Fix": <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Cela ne se produit pas partout.  Volker Simonis de SAP a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqu√©</a> comment il avait impl√©ment√© cette fonctionnalit√© dans SAP JVM pendant longtemps et l'avait aid√©e plusieurs fois.  Un autre employ√© de SAP a de nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">soumis un</a> bogue dans OpenJDK et s'est port√© volontaire pour impl√©menter un m√©canisme similaire √† celui de SAP JVM.  Et, voil√†, cette fois, le bogue n'a pas √©t√© ferm√© - il y a une chance que cette fonctionnalit√© entre dans JDK 14. <br><br>  Mais quand le JDK 14 sortira-t-il et quand y passerons-nous?  Que faire si vous souhaitez √©tudier le probl√®me ici et maintenant? <br><br>  Vous pouvez, bien s√ªr, maintenir votre fork d'OpenJDK.  La fonctionnalit√© de rapport NPE elle-m√™me n'est pas si compliqu√©e, nous aurions tr√®s bien pu l'impl√©menter.  Mais en m√™me temps, il y aura tous les probl√®mes de support de votre propre assemblage.  Ce serait formidable d'impl√©menter la fonctionnalit√© une fois, puis de la connecter simplement √† n'importe quelle version de la JVM en tant que plugin.  Et c'est vraiment possible!  La JVM poss√®de une API sp√©ciale (d√©velopp√©e √† l'origine pour toutes sortes de d√©bogueurs et de profileurs): JVM Tool Interface. <br><br>  Plus important encore, cette API est standard.  Il a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> stricte et lorsque vous impl√©mentez une fonctionnalit√© conform√©ment √† celle-ci, vous pouvez √™tre s√ªr qu'elle fonctionnera dans les nouvelles versions de la JVM. <br><br>  Pour utiliser cette interface, vous devez √©crire un petit (ou grand, selon vos t√¢ches) programme.  Natif: il est g√©n√©ralement √©crit en C ou C ++.  La <code>jdk/include/jvmti.h</code> JDK standard poss√®de un fichier d'en-t√™te <code>jdk/include/jvmti.h</code> que vous souhaitez inclure. <br><br>  Le programme est compil√© dans une biblioth√®que dynamique et connect√© par le param√®tre <code>-agentpath</code> lors du d√©marrage de la JVM.  Il est important de ne pas le confondre avec un autre param√®tre similaire: <code>-javaagent</code> .  En fait, les agents Java sont un cas particulier des agents JVM TI.  Plus loin dans le texte sous le mot "agent", on entend pr√©cis√©ment l'agent natif. <br><br><h2>  Par o√π commencer </h2><br>  Voyons en pratique comment √©crire l'agent JVM TI le plus simple, une sorte de "bonjour le monde". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  La premi√®re ligne, j'inclus le m√™me fichier d'en-t√™te.  Vient ensuite la fonction principale qui doit √™tre impl√©ment√©e dans l'agent: <code>Agent_OnLoad()</code> .  La machine virtuelle elle-m√™me l'appelle au d√©marrage de l'agent, en passant un pointeur sur l'objet <code>JavaVM*</code> . <br><br>  En l'utilisant, vous pouvez obtenir un pointeur vers l'environnement JVM TI: <code>jvmtiEnv*</code> .  Et √† travers elle, √† son tour, d√©j√† appeler JVM TI-fonctions.  Par exemple, √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GetSystemProperty,</a> lisez la valeur d'une propri√©t√© syst√®me. <br><br>  Si maintenant <code>-agentpath</code> ce "bonjour le monde" en passant le fichier dll compil√© √† <code>-agentpath</code> , la ligne imprim√©e par notre agent appara√Ætra dans la console avant que le programme Java ne d√©marre: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Enrichissement NPE </h2><br>  Puisque Hello World n'est pas l'exemple le plus int√©ressant, revenons √† nos exceptions.  Le code d'agent complet qui compl√®te les rapports NPE se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> . <br><br>  Voici √† quoi <code>Agent_OnLoad()</code> si je veux demander √† la machine virtuelle de nous informer de toutes les exceptions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Je demande d'abord √† la JVM TI la capacit√© correspondante (can_generate_exception_events).  Nous parlerons de la capacit√© s√©par√©ment. <br><br>  L'√©tape suivante consiste √† s'abonner aux √©v√©nements d'exception.  Chaque fois que la JVM l√®ve des exceptions (qu'elles soient intercept√©es ou non), notre fonction <code>ExceptionCallback()</code> sera appel√©e. <br><br>  La derni√®re √©tape consiste √† appeler <code>SetEventNotificationMode()</code> pour activer la remise des notifications. <br><br><div class="spoiler">  <b class="spoiler_title">Dans ExceptionCallback, la JVM transmet tout ce dont nous avons besoin pour g√©rer les exceptions.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Ici, il y a √† la fois l'objet du thread qui a lev√© l'exception (thread), et l'endroit o√π cela s'est produit (m√©thode, emplacement), et l'objet de l'exception (exception), et m√™me l'endroit dans le code qui capture cette exception (catch_method, catch_location). <br><br>  Ce qui est important: dans ce rappel, en plus du pointeur vers l'environnement JVM TI, l'environnement JNI (env) est √©galement pass√©.  Cela signifie que nous pouvons y utiliser toutes les fonctions JNI.  Autrement dit, JVM TI et JNI coexistent parfaitement, se compl√©tant mutuellement. <br><br>  Dans mon agent, j'utilise les deux.  En particulier, via JNI, je v√©rifie que mon exception est de type <code>NullPointerException</code> , puis je remplace le champ <code>detailMessage</code> un message d'erreur. <br><br>  Puisque la JVM elle-m√™me nous transmet l'emplacement - l'index de bytecode sur lequel l'exception s'est produite, alors je viens de mettre cet emplacement ici dans le message: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  Le nombre 66 indique l'index en bytecode o√π cette exception s'est produite.  Mais l'analyse manuelle du bytecode est morne: vous devez d√©compiler le fichier de classe, rechercher la 66e instruction, essayer de comprendre ce qu'elle faisait ... Ce serait formidable si notre agent lui-m√™me pouvait montrer quelque chose de plus lisible par l'homme. <br><br>  Cependant, dans ce cas, la JVM TI a tout ce dont vous avez besoin.  Certes, vous devez demander des fonctionnalit√©s suppl√©mentaires de la JVM TI: obtenir le bytecode et la m√©thode du pool constant. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Maintenant, je vais d√©velopper ExceptionCallback: gr√¢ce √† la fonction JVM TI <code>GetBytecodes()</code> je vais obtenir le corps de la m√©thode pour v√©rifier ce qu'il <code>GetBytecodes()</code> par index de localisation.  Vient ensuite une grande instruction de bytecode de commutateur: s'il s'agit d'un acc√®s au tableau, il y aura un message d'erreur, si l'acc√®s au champ est un autre message, si l'appel de m√©thode est le troisi√®me, et ainsi de suite. <br><br><div class="spoiler">  <b class="spoiler_title">Code de rappel d'exception</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Il ne reste plus qu'√† substituer le nom du champ ou de la m√©thode.  Vous pouvez l'obtenir √† partir du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pool constant</a> , qui est √† nouveau disponible gr√¢ce √† la JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Vient ensuite un peu de magie, mais en r√©alit√© rien de d√©licat, juste conform√©ment √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la sp√©cification du</a> format de fichier de classe, nous analysons le pool constant et √† partir de l√†, nous isolons la ligne - le nom de la m√©thode. <br><br><div class="spoiler">  <b class="spoiler_title">Analyse du pool constant</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Autre point important: certaines fonctions JVM TI, par exemple <code>GetConstantPool()</code> ou <code>GetBytecodes()</code> , allouent une certaine structure en m√©moire native, qui doit √™tre lib√©r√©e lorsque vous avez fini de travailler avec. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Ex√©cutez le programme source avec notre agent √©tendu, et voici une description compl√®tement diff√©rente de l'exception: il signale que nous avons appel√© la m√©thode longValue () sur l'objet null. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Autres applications </h2><br>  De mani√®re g√©n√©rale, les d√©veloppeurs souhaitent souvent g√©rer les exceptions √† leur mani√®re.  Par exemple, red√©marrez automatiquement la JVM si une <code>StackOverflowError</code> . <br><br>  Ce d√©sir peut √™tre compris, car <code>StackOverflowError</code> est la m√™me erreur fatale que <code>OutOfMemoryError</code> , apr√®s son occurrence, il n'est plus possible de garantir le bon fonctionnement du programme.  Ou, par exemple, parfois pour analyser le probl√®me, je souhaite recevoir un vidage de thread ou un vidage de tas lorsqu'une exception se produit. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  En toute √©quit√©, l'IBM JDK a une telle opportunit√© hors de la bo√Æte.  Mais maintenant, nous savons d√©j√† qu'en utilisant l'agent JVM TI, vous pouvez impl√©menter la m√™me chose dans HotSpot.  Il suffit de s'abonner au rappel d'exception et d'analyser l'exception.  Mais comment supprimer le vidage de thread ou le vidage de tas de notre agent?  La JVM TI a tout ce dont vous avez besoin pour ce cas: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  Il n'est pas tr√®s pratique d'impl√©menter l'ensemble du m√©canisme de contournement du tas et de cr√©ation d'un vidage.  Mais je vais partager le secret de la fa√ßon de le rendre plus facile et plus rapide.  Certes, ce n'est plus inclus dans la JVM TI standard, mais c'est une extension priv√©e de Hotspot. <br><br>  Vous devez connecter le fichier d'en-t√™te <a href="">jmm.h √†</a> partir des sources HotSpot et appeler la fonction <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Il renverra un pointeur vers l'interface de gestion HotSpot, qui en un seul appel g√©n√©rera un vidage de tas ou un vidage de thread.  Le code complet de l'exemple se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma r√©ponse</a> √† Stack Overflow. <br><br>  Naturellement, vous pouvez g√©rer non seulement des exceptions, mais √©galement un tas d'autres √©v√©nements li√©s √† l'op√©ration JVM: d√©marrage / arr√™t de threads, chargement de classes, garbage collection, m√©thodes de compilation, entr√©e / sortie de m√©thodes, m√™me acc√®s ou modification de champs sp√©cifiques d'objets Java. <br><br>  J'ai un exemple d'un autre agent <a href="">vmtrace</a> qui souscrit √† de nombreux √©v√©nements JVM TI standard et les enregistre.  Si je lance un programme simple avec cet agent, j'obtiendrai un journal d√©taill√©, qui, une fois termin√©, avec des horodatages: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Comme vous pouvez le voir, pour simplement imprimer Hello World, des centaines de classes sont charg√©es, des dizaines et des centaines de m√©thodes sont g√©n√©r√©es et compil√©es.  Il devient clair pourquoi Java prend autant de temps √† fonctionner.  Tout sur tout a pris plus de deux cents millisecondes. <br><br><h2>  Ce que JVM TI peut faire </h2><br>  En plus de la gestion des √©v√©nements, la JVM TI poss√®de un tas d'autres fonctionnalit√©s.  Ils peuvent √™tre divis√©s en deux groupes. <br><br>  L'une est obligatoire, et toute JVM qui prend en charge la JVM TI doit l'impl√©menter.  Il s'agit notamment des op√©rations d'analyse des m√©thodes, des champs, des flux, de la possibilit√© d'ajouter de nouvelles classes au chemin de classe, etc. <br><br>  Il existe des fonctionnalit√©s optionnelles qui n√©cessitent une demande de capacit√©s pr√©liminaire.  JVM n'est pas tenu de les prendre en charge tous, cependant HotSpot impl√©mente l'int√©gralit√© de la sp√©cification.  Les fonctionnalit√©s optionnelles sont divis√©es en deux sous-groupes: ceux qui ne peuvent √™tre connect√©s qu'au d√©but de la machine virtuelle Java (par exemple, la possibilit√© de d√©finir un point d'arr√™t ou d'analyser des variables locales), et ceux qui peuvent √™tre connect√©s √† tout moment (en particulier, bytecode ou pool constant, que je utilis√© ci-dessus). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  Vous pouvez remarquer que la liste des fonctionnalit√©s est tr√®s similaire aux capacit√©s du d√©bogueur.  En fait, un d√©bogueur Java n'est rien de plus qu'un cas particulier de l'agent JVM TI, qui tire parti de toutes ces capacit√©s et demande toutes les capacit√©s. <br><br>  La s√©paration des capacit√©s entre celles qui peuvent √™tre activ√©es √† tout moment et celles qui ne le sont qu'au d√©marrage est effectu√©e expr√®s.  Toutes les fonctionnalit√©s ne sont pas gratuites, certaines comportent des frais g√©n√©raux. <br><br>  Si tout est clair avec les frais g√©n√©raux directs qui accompagnent l'utilisation de la fonctionnalit√©, alors il y a encore moins indirects qui apparaissent m√™me si vous n'utilisez pas la fonctionnalit√©, mais simplement gr√¢ce √† des capacit√©s, vous d√©clarez que cela sera n√©cessaire dans le futur.  Cela est d√ª au fait que la machine virtuelle peut compiler le code diff√©remment ou ajouter des v√©rifications suppl√©mentaires √† l'ex√©cution. <br><br>  Par exemple, la capacit√© d√©j√† envisag√©e de s'abonner √† des exceptions (can_generate_exception_events) conduit au fait que toutes les exceptions de lancement se feront lentement.  En principe, ce n'est pas si effrayant, car les exceptions sont une chose rare dans un bon programme Java. <br><br>  La situation avec les variables locales est l√©g√®rement pire.  Pour can_access_local_variables, qui vous permet d'obtenir les valeurs des variables locales √† tout moment, vous devez d√©sactiver certaines optimisations importantes.  En particulier, Escape Analysis cesse compl√®tement de fonctionner, ce qui peut entra√Æner une surcharge notable: selon l'application, 5 √† 10%. <br><br>  D'o√π la conclusion: si vous ex√©cutez Java avec l'agent de d√©bogage activ√©, sans m√™me l'utiliser, les applications s'ex√©cuteront plus lentement.  Quoi qu'il en soit, inclure un agent de d√©bogage dans la production n'est pas une bonne id√©e. <br><br>  Un certain nombre de fonctionnalit√©s, par exemple, la d√©finition d'un point d'arr√™t ou le tra√ßage de toutes les entr√©es / sorties d'une m√©thode, entra√Ænent une surcharge beaucoup plus importante.  En particulier, certains √©v√©nements JVM TI (FieldAccess, MethodEntry / Exit) ne fonctionnent que dans l'interpr√©teur. <br><br><h2>  Un agent est bon et deux, c'est mieux </h2><br>  Vous pouvez connecter plusieurs agents √† un seul processus en sp√©cifiant simplement plusieurs param√®tres <code>-agentpath</code> .  Chacun aura son propre environnement JVM TI.  Cela signifie que chacun peut souscrire √† ses capacit√©s et intercepter ses √©v√©nements de mani√®re ind√©pendante. <br><br>  Et si deux agents se sont abonn√©s √† l'√©v√©nement Breakpoint, et dans l'un, le point d'arr√™t est d√©fini dans une m√©thode, alors lorsque cette m√©thode est ex√©cut√©e, le deuxi√®me agent recevra-t-il l'√©v√©nement? <br><br>  En r√©alit√©, une telle situation ne peut pas se produire (au moins dans HotSpot JVM).  Parce qu'il existe certaines capacit√©s que seul un des agents peut poss√©der √† un moment donn√©.  Il s'agit notamment de breakpoint_events.  Par cons√©quent, si le deuxi√®me agent demande la m√™me capacit√©, il recevra une erreur en r√©ponse. <br><br>  Il s'agit d'une conclusion importante: l'agent doit toujours v√©rifier le r√©sultat de la demande de capacit√©s, m√™me si vous ex√©cutez sur HotSpot et sachez que tous sont disponibles.  La sp√©cification JVM TI ne dit rien sur les capacit√©s exclusives, mais HotSpot a une telle fonctionnalit√© de mise en ≈ìuvre. <br><br>  Certes, l'isolement des agents ne fonctionne pas toujours parfaitement.  Pendant le d√©veloppement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">async-profiler,</a> je suis tomb√© sur ce probl√®me: lorsque nous avons deux agents et que l'un demande la g√©n√©ration d'√©v√©nements de compilation de m√©thodes, tous les agents re√ßoivent ces √©v√©nements.  Bien s√ªr, j'ai d√©pos√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bogue</a> , mais vous devez garder √† l'esprit que des √©v√©nements auxquels vous ne vous attendez pas peuvent se produire dans votre agent. <br><br><h2>  Utilisation dans un programme r√©gulier </h2><br>  JVM TI peut sembler √™tre une chose tr√®s sp√©cifique pour les d√©bogueurs et les profileurs, mais il peut √©galement √™tre utilis√© dans un programme Java standard.  Prenons un exemple. <br><br>  Le paradigme de programmation r√©active est maintenant r√©pandu lorsque tout est asynchrone, mais il y a un probl√®me avec ce paradigme. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  J'ex√©cute deux t√¢ches asynchrones qui ne diff√®rent que par les param√®tres.  Et si quelque chose se passe mal, une exception est lev√©e: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  √Ä partir de la trace de la pile, il est compl√®tement difficile de d√©terminer laquelle de ces t√¢ches a provoqu√© le probl√®me.  Parce que l'exception se produit dans un thread compl√®tement diff√©rent, o√π nous n'avons pas de contexte.  Comment comprendre dans quelle t√¢che? <br><br>  Comme l'une des solutions, vous pouvez ajouter des informations sur l'endroit o√π nous l'avons cr√©√© au constructeur de notre t√¢che asynchrone: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Autrement dit, rappelez-vous l'emplacement - un endroit sp√©cifique dans le code, jusqu'√† la ligne d'o√π le constructeur a √©t√© appel√©.  Et en cas d'exception √† le mettre en gage: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Maintenant, lorsqu'une exception se produit, nous verrons que cela s'est produit sur la ligne 14 dans le TaskRunner (o√π la t√¢che avec le param√®tre BAD est cr√©√©e): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Mais comment obtenir la place dans le code d'o√π le constructeur est appel√©?  Avant Java 9, il y avait le seul moyen l√©gal de le faire: obtenir une trace de pile, ignorer quelques images non pertinentes, et un peu plus bas sur la pile sera l'endroit que notre code appelait. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Mais il y a un probl√®me.  Obtenir le StackTrace complet est assez lent.  J'ai tout un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> consacr√© √† cela. <br><br>  Ce ne serait pas un si gros probl√®me si cela arrivait rarement.  Mais, par exemple, nous avons un service Web - un frontend qui accepte les requ√™tes HTTP.  Ceci est une excellente application, des millions de lignes de code.  Et pour d√©tecter les erreurs de rendu, nous utilisons un m√©canisme similaire: dans les composants de rendu, nous nous souvenons de l'endroit o√π ils sont cr√©√©s.  Nous avons des millions de ces composants, donc obtenir toutes les traces de pile prend un temps tangible pour d√©marrer l'application, pas seulement une minute.  Par cons√©quent, cette fonctionnalit√© √©tait auparavant d√©sactiv√©e en production, bien que pour l'analyse des probl√®mes, elle soit n√©cessaire en production. <br><br>  Java 9 a introduit une nouvelle fa√ßon de contourner les piles de flux: StackWalker, qui via l'API Stream peut faire tout cela paresseusement, √† la demande.  Autrement dit, nous pouvons sauter le bon nombre d'images et n'en obtenir qu'une qui nous int√©resse. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Cela fonctionne un peu mieux que d'obtenir la trace compl√®te de la pile, mais pas par ordre de grandeur ou m√™me plusieurs fois.  Dans notre cas, cela s'est av√©r√© environ une fois et demie plus rapide: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  Il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me connu</a> avec l'impl√©mentation sous-optimale de StackWalker, et tr√®s probablement il sera m√™me corrig√© dans JDK 13. Mais encore une fois, que devons-nous faire maintenant en Java 8, o√π StackWalker n'est m√™me pas lent? <br><br>  La JVM TI revient √† la rescousse.  Il existe une fonction <code>GetStackTrace()</code> qui peut faire tout ce dont vous avez besoin: obtenir un fragment d'une trace de pile d'une longueur donn√©e, √† partir du cadre sp√©cifi√©, et ne rien faire de plus. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  Il ne reste qu'une question: comment appeler la fonction JVM TI depuis notre programme Java?  Comme toute autre m√©thode native: chargez la biblioth√®que native avec <code>System.loadLibrary()</code> , o√π sera l'impl√©mentation JNI de notre m√©thode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Un pointeur vers l'environnement JVM TI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut √™tre obtenu</a> non seulement √† partir d'Agent_OnLoad (), mais √©galement pendant l'ex√©cution du programme, puis √† l'utiliser √† partir de m√©thodes JNI natives ordinaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href="">jvmtiEnter.xsl</a> . <br><br>  :    HotSpot       XSLT-.       HotSpot. <br><br>     ?       ,   .  ,   - jmethodID  ,      .      ,      . <br><br><h2>   </h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br>      JDK     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jattach</a> . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">async-profiler</a>      ,   -  JVM-,    jattach. <br><br>    JVM TI-    , ,  <code>Agent_OnLoad()</code> ,    <code>Agent_OnAttach()</code> .  :  <code>Agent_OnAttach()</code>    capabilities,       . <br><br>  ,           ,   <code>Agent_OnAttach()</code>   . <br><br>   .     IntelliJ IDEA:    Java-, ,          - . <br><br>  process ID  IDEA,   jattach     JVM TI- patcher.dll: <br> <code>jattach 8648 load patcher.dll true</code> <br> <br>          : <br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br>    ?   Java-   ( <code>javax.swing.AbstractButton</code> )    JNI  <code>setBackground()</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br><h2>    Java 9 </h2><br> JVM TI   , ,    ,     API,     .      Java 9. <br><br>  , Java 9     ,   .  ,    ¬´¬ª JDK,       . <br><br> ,  JDK     Direct ByteBuffer.    API: <br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br> ,  Cassandra    ,          MappedByteBuffer,      ,  JVM  . <br><br>          JDK 9,  IllegalAccessError: <br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br>      Reflection:      . <br><br> ,  Java       Linux.   -        <code>java.io.FileDescriptor</code>       JNI    -  .  ,     JDK 9,     : <br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br> ,   JVM,           .      ,   . ,    Cassandra  Java 11,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> : <br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> JVM TI    : <br><br><ul><li> GetAllModules </li><li> AddModuleExports </li><li> AddModuleOpens </li><li>  . . </li></ul><br>    ,    :    JVM,    ,    ,      . <br><br>      Direct ByteBuffer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br>     ,   IllegalAccessError.     agentpath    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">antimodule</a> ,     .     . <br><br><h2>    Java 11 </h2><br>     Java 11.   ,   !     :    <code>SampledObjectAlloc</code> ,    ,      . <br><br>  callback   ,     : ,  ,   ,  , .   <code>SetHeapSampingInterval</code>   ,      . <br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>   ?         ,    ,     .        Java Flight Recorder. <br><br>     ,     ,     ,  , . <br><br>           Thread Local Allocation Buffer   .      TLAB   ,   .        ,     . <br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br>     ,     TLAB,    .          JVM runtime   . <br><br>   ,        ,       ‚Äî     5%. <br><br>  ,    ,    JDK 7,    Flight Recorder.    API     async-profiler.  ,   JDK 11,  API  ,   JVM TI,      .  , YourKit   .     API,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,    . <br><br>         . ,   ,    , , . <br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Conclusion </h2><br> JVM TI ‚Äî      . <br><br> ,     ++,     JVM         .  ,  JVM TI        . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> GitHub</a> . ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458812/">https://habr.com/ru/post/fr458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458798/index.html">Nutrient Bot ou comment je veux prendre du pain avec des entra√Æneurs de fitness</a></li>
<li><a href="../fr458800/index.html">Apprentissage profond. Apprentissage f√©d√©r√©</a></li>
<li><a href="../fr458804/index.html">Recueil d'articles sur l'apprentissage automatique et l'intelligence artificielle</a></li>
<li><a href="../fr458808/index.html">Rapport Habr post-mortem: un journal est tomb√©</a></li>
<li><a href="../fr458810/index.html">Corel et Parallels vendus au groupe d'investissement KKR des √âtats-Unis</a></li>
<li><a href="../fr458814/index.html">Lancement d'un site pour un produit avec une demande inform√©e</a></li>
<li><a href="../fr458818/index.html">Des contemporains √©minents</a></li>
<li><a href="../fr458820/index.html">Sur l'impl√©mentation du c√©l√®bre genre sur la plateforme Minecraft</a></li>
<li><a href="../fr458826/index.html">Comment √©liminer les anciens articles pour qu'ils croissent fortement dans le bio: + 104% de trafic pendant six mois</a></li>
<li><a href="../fr458828/index.html">Pourquoi, pourquoi et quand utiliser ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>