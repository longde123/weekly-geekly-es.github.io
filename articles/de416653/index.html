<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèø üçã ü¶ë Bibliothek sortieren üéß üõ≥Ô∏è üò≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nehmen Sie ein Array in umgekehrter Reihenfolge und sortieren Sie es mit einfachen Einf√ºgungen . 



 Sehen Sie, mit welchem ‚Äã‚ÄãKnarren das n√§chste Ele...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bibliothek sortieren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416653/"><div style="text-align:center;"><img width="700" height="394" src="https://habrastorage.org/webt/8i/bj/do/8ibjdoxetlxsby3qiaj5seokxxa.jpeg"></div><br><br><a name="habracut"></a><br>  Nehmen Sie ein Array in umgekehrter Reihenfolge und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sortieren Sie</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit einfachen Einf√ºgungen</a> . <br><br><img width="684" height="95" src="https://habrastorage.org/webt/il/qa/vz/ilqavzmmhgxwuhcityv7wuqqqig.gif"><br><br>  Sehen Sie, mit welchem ‚Äã‚ÄãKnarren das n√§chste Element an der richtigen Stelle eingef√ºgt wird.  Daf√ºr m√ºssen Sie die Einf√ºgestelle freigeben, wodurch Sie alle zuvor eingef√ºgten Elemente verschieben m√ºssen. <br><br>  Und wie gut w√§re es, wenn zwischen den zuvor eingef√ºgten Elementen Leerzeichen w√§ren!  Dann m√ºsste man die Elementreihen nicht nur zum Einf√ºgen ziehen. <br><br>  Im Jahr 2004 beschlossen drei Informatik-Experten - Michael Bender, Martin Farah-Colton und Miguel Mostiro -, die Sortierung mit einfachen Eins√§tzen auf diese Weise zu √§ndern.  Sie schlugen vor, einen geordneten Teil des Arrays zu bilden und L√ºcken zwischen den eingef√ºgten Elementen zu lassen. <br><blockquote>  Der Bibliothekar muss die B√ºcher alphabetisch in einem langen Regal anordnen: Beginnend links vom Buchstaben ‚ÄûA‚Äú stehen die B√ºcher direkt nebeneinander bis zum ‚ÄûIch‚Äú.  Wenn die Bibliothek ein neues Buch mit Bezug zu Abschnitt "B" erhalten hat, m√ºssen Sie jedes Buch von der Mitte des Abschnitts "B" bis zum letzten "I" verschieben, um es an der richtigen Stelle ins Regal zu stellen.  Dies ist das Sortieren nach einfachen Einf√ºgungen.  Wenn der Bibliothekar jedoch den freien Platz in jedem Abschnitt reservierte, gen√ºgte es ihm, nur wenige B√ºcher zu verschieben, um Platz f√ºr Buchneuheiten zu schaffen.  Dies ist das Grundprinzip der Bibliothekssortierung. </blockquote><h2>  Algorithmus </h2><br><img width="693" height="168" src="https://habrastorage.org/webt/jl/-l/wc/jl-lwclcowy6aohvc82uksordtg.gif"><br><br><ul><li>  <strong>1. Erstellen Sie ein leeres Hilfsarray, das um ein Vielfaches gr√∂√üer ist als das Hauptarray.</strong> </li><li>  <strong>2. F√ºr das n√§chste Element suchen wir nach der Einf√ºgungsstelle im Hilfsarray.</strong> <ul><li>  <strong>2.1.</strong>  <strong>Wenn Sie einen Platz zum Einf√ºgen finden, √ºbertragen Sie den Artikel und kehren Sie zu Schritt 2 zur√ºck.</strong> </li><li>  <strong>2.2.</strong>  <strong>Wenn kein Platz zum Einf√ºgen vorhanden ist, gleichen Sie das Hilfsarray neu aus und kehren Sie zu Punkt 2 zur√ºck.</strong> </li></ul></li><li>  <strong>3. Nachdem Sie alle Elemente verarbeitet haben, √ºbertragen Sie sie zur√ºck in das Hauptarray.</strong> </li></ul><br>  Auf den ersten Blick scheint das Sortieren einfach und unkompliziert zu sein.  Um diese Illusion zu zerstreuen, betrachten wir die wichtigsten Punkte des Algorithmus genauer. <br><br><h2>  Gr√∂√üe des Zusatzarrays </h2><br>  Es gibt zwar keine etablierte Meinung, aber wie oft sollte das Hilfsarray gr√∂√üer sein als das Hauptarray. <br><br>  Wenn Sie zu viel nehmen, ist zwischen den Elementen viel Platz. Die Suche nach der Einf√ºgungsstelle und der Neuausgleich sind jedoch aufgrund der gro√üen Abst√§nde zwischen den Elementen langsamer.  Rebalancing wird seltener vorkommen, aber sie m√ºssen mehr Ressourcen f√ºr sie ausgeben.  Wenn Sie zu wenig nehmen, ist das Suchen und Neuausgleichen billiger, aber Sie m√ºssen das Array h√§ufiger neu formatieren.  Im Allgemeinen muss noch mit unterschiedlichen Werten getestet werden, und die Methode des wissenschaftlichen Stocherns bestimmt die beste Option. <br><br>  Wenn wir entschieden haben, wie oft das Hilfsarray gr√∂√üer als das Hauptarray ist, sieht die Formel zur Bestimmung der genauen Anzahl der Elemente folgenderma√üen aus: <br><br>  <b>NewSize = Œµ √ó (Gr√∂√üe + 1) - 1</b> <br><br>  <i>NewSize - Die Anzahl der Elemente im Hilfsarray</i> <i><br></i>  <i>Œµ - wie oft ist das Hilfsarray gr√∂√üer als das Hauptarray</i> <i><br></i>  <i>Gr√∂√üe - Die Anzahl der Elemente im Hauptarray</i> <br><br>  Wenn wir die Gr√∂√üe einfach mit einem Faktor multiplizieren: <b>NewSize = Size √ó Œµ</b> , dann haben wir f√ºr eine gleichm√§√üige Verteilung nicht gen√ºgend Zellen in der Menge von <b>Œµ - 1</b> St√ºck.  Das hei√üt, es ist m√∂glich, sie gleichm√§√üig anzuordnen, aber entweder die erste oder die letzte gef√ºllte Zelle befindet sich nahe dem Rand des Hilfsarrays.  Und wir m√ºssen die leeren Stellen in den gef√ºllten Zellen von allen Seiten reservieren - auch vor dem ersten und nach dem letzten Element. <br><br><img width="692" height="312" src="https://habrastorage.org/webt/am/np/py/amnppyndj34-6az2hiyjakiakbk.png"><br><br>  Es scheint eine Kleinigkeit zu sein, aber in der Tat ist es wichtig, das Gleichgewicht wieder herzustellen, um freie Stellen zum Einf√ºgen √ºberall zu gew√§hrleisten, auch bei der Verarbeitung der letzten Elemente des Hauptarrays. <br><br><h2>  Suchen Sie nach einem Einf√ºgeplatz im Hilfsarray </h2><br>  Nat√ºrlich ben√∂tigen Sie hier eine bin√§re Suche.  Die klassische Implementierung wird jedoch bei uns nicht funktionieren. <br><br>  Erstens besteht das Hilfsarray haupts√§chlich aus Hohlr√§umen.  Wenn wir die Struktur rekursiv dichotomisieren, werden wir daher gr√∂√ütenteils auf ungef√ºllte Zellen sto√üen.  In diesen F√§llen m√ºssen Sie ein wenig nach links oder rechts zur n√§chsten nicht leeren Zelle gehen.  Am Ende des Segments befinden sich dann wichtige Elemente, mit denen Sie das arithmetische Mittel berechnen und die bin√§re Suche eingehend fortsetzen k√∂nnen. <br><br>  Zweitens vergessen Sie nicht die Kanten.  Wenn Sie ein minimales oder maximales Element einf√ºgen m√ºssen, f√ºhrt eine bin√§re Suche unter den zuvor eingef√ºgten Elementen zu nichts.  Daher lohnt es sich, Grenzf√§lle zu ber√ºcksichtigen. √úberpr√ºfen Sie zun√§chst, ob ein Element in der N√§he des linken oder rechten Randes des Arrays platziert werden muss, und verwenden Sie dann die bin√§re Suche, wenn dies nicht der Fall ist. <br><br>  Drittens lohnt es sich unter Ber√ºcksichtigung der Besonderheiten des Antrags, zus√§tzliche √Ñnderungen vorzunehmen, um die Anzahl der Array-Neuausrichtungen zu minimieren.  Wenn das eingef√ºgte Element dem Wert an einem der Enden des Segments entspricht, sollten Sie es m√∂glicherweise nicht in der Mitte des Segments einf√ºgen.  Es ist logischer, neben ein Element zu stellen, dessen Wert diesem Wert entspricht.  Dadurch wird der leere Raum des Hilfsarrays effizienter gef√ºllt. <br><br>  Viertens, f√ºnftens und so weiter.  Die Qualit√§t der Suche nach dem Einf√ºgeort wirkt sich direkt auf die Sortiergeschwindigkeit aus, da die Auswahl nicht erfolgreicher Einf√ºgungsorte zu einem unn√∂tigen Neuausgleich f√ºhrt.  Zum Beispiel kann es sich lohnen, die Segmente nicht genau in der Mitte zu teilen, sondern n√§her am linken oder rechten Rand des Segments, je nachdem, an welcher Kante das Einf√ºgeelement n√§her am Wert liegt. <br><br>  Der bin√§re Suchalgorithmus selbst ist mit Fallstricken behaftet, und unter Ber√ºcksichtigung der oben genannten zus√§tzlichen Nuancen wird er schlie√ülich keineswegs zu einer nicht trivialen Aufgabe. <br><br><h2>  Array-Neuausrichtung </h2><br>  Die bin√§re Suche ist bei dieser Sortierung nicht am schwierigsten zu implementieren.  Es gibt immer noch ein Gleichgewicht. <br><br>  Wenn kein Platz zum Einf√ºgen vorhanden ist (√§hnliche Elemente wurden gefunden, aber keine freien Zellen zwischen ihnen), m√ºssen Sie das Hilfsarray sch√ºtteln, damit der Platz zum Einf√ºgen freigegeben wird.  Dieses Sch√ºtteln des Arrays gleicht das Gleichgewicht aus. <br><br>  Dar√ºber hinaus ist die Neuausrichtung <i>lokal</i> oder <i>vollst√§ndig</i> . <br><br><h3>  Lokale Neuausrichtung </h3><br>  Wir verschieben so viele Elemente wie n√∂tig, um die Einf√ºgemarke freizugeben.  Die Implementierung eines solchen Ausgleichs ist sehr einfach. Sie m√ºssen nur die n√§chste leere Zelle an der Einf√ºgemarke ermitteln und damit mehrere Elemente verschieben. <br><br>  Es gibt m√∂gliche Nuancen.  Wie kann man zum Beispiel nach dem n√§chsten freien Platz suchen?  Um die Situation zu vermeiden, in der eine Verschiebung nicht m√∂glich ist (dh wenn auf einer Seite alle Zellen bis zum √§u√üersten Rand des Arrays belegt sind), k√∂nnen Sie sich auf die Position der Einf√ºgemarke relativ zur Mitte des Arrays konzentrieren.  Wenn Sie auf der linken Seite des Arrays einf√ºgen m√ºssen, wechseln Sie nach rechts, wenn rechts, nach links.  Wenn <b>Œµ</b> ‚â• 2 ist, beseitigt dieser Ansatz die Situation, in der eine Verschiebung unm√∂glich ist (weil in der H√§lfte des Hilfsarrays mehr als genug Platz f√ºr alle Elemente vorhanden ist). <br><br>  In der Interpretation des Algorithmus durch den Autor wird eine lokale Neuausrichtung impliziert. <br><br><h3>  Komplette Neuausrichtung </h3><br>  Eine interessante Alternative zu lokal ist die vollst√§ndige Neuausrichtung.  Das hei√üt, im Hilfsarray werden alle verf√ºgbaren Elemente so verschoben, dass zwischen ihnen (fast) die gleichen Leerzeichen liegen. <br><br><img width="693" height="168" src="https://habrastorage.org/webt/xg/yi/nr/xgyinrhnartyvwhdgqvmucrmx7m.gif"><br><br>  Ich habe beide Optionen ausprobiert und bis jetzt beobachte ich, dass der Algorithmus beim lokalen Neuausgleich 1,5 bis 2 Mal schneller funktioniert als bei der vollst√§ndigen.  Eine vollst√§ndige Neuausrichtung kann jedoch weiterhin hilfreich sein.  Wenn Sie beispielsweise zu oft lokal neu ausgleichen m√ºssen, bedeutet dies, dass sich in einigen Bereichen im Array viele ‚ÄûBlutgerinnsel‚Äú angesammelt haben, die den gesamten Prozess hemmen.  Eine einmal durchgef√ºhrte vollst√§ndige Neuausrichtung erm√∂glicht es Ihnen, alle lokalen √úberlastungen auf einen Schlag zu beseitigen. <br><br>  Lassen Sie uns herausfinden, wie Sie das Gleichgewicht wieder vollst√§ndig herstellen k√∂nnen. <br><br>  Zuerst m√ºssen Sie berechnen, wie viele maximale Zellen wir jedem Element im Hilfsarray zuordnen k√∂nnen.  Es ist zu beachten, dass leere Zellen sowohl vor als auch nach der letzten gef√ºllten Zelle stehen m√ºssen.  Die Formel lautet: <br><br><img width="186" height="52" src="https://habrastorage.org/webt/9n/he/da/9nhedamesorkojp6daccahjow2q.png"><br><br>  <i>M - die Anzahl der Zellen, die jedem Element zugewiesen werden k√∂nnen</i> <i><br></i>  <i>NewSize - Gr√∂√üe des Hilfsarrays</i> <i><br></i>  <i>Count - Die aktuelle Anzahl nicht leerer Elemente im Hilfsarray</i> <br><br>  Dieser Bruch muss auf einen ganzzahligen Wert reduziert (dh abgerundet) werden.  Aus der Formel geht hervor, dass je mehr Elemente bereits auf das Hilfsarray √ºbertragen werden, desto weniger Zellen k√∂nnen wir f√ºr die Nachbarschaft jedes Elements ausw√§hlen. <br><br>  Wenn wir <b>M kennen</b> , erhalten wir leicht die genaue Position f√ºr jedes nicht leere Element in dem Hilfsarray, auf dem es sich befinden soll, nachdem der Neuausgleich abgeschlossen ist. <br><br>  <b>NewPos = Anzahl √ó M.</b> <br><br>  <i>NewPos - neue Artikelposition nach dem Ausgleich</i> <i><br></i>  <i>Zahl - Was ist das nicht leere Element im Hilfsarray <nobr>(1 ‚â§ Zahl ‚â§ Anzahl)?</nobr></i> <i><br></i>  <i>M - die Anzahl der Zellen, die jedem Element zugeordnet sind</i> <br><br>  Neue Positionen sind bekannt. K√∂nnen Sie nicht leere Elemente im Hilfsarray einfach aussortieren und an andere Stellen √ºbertragen?  Oh nein, beeil dich nicht.  Es ist nicht nur notwendig, Elemente zu √ºbertragen, es ist auch wichtig, ihre Reihenfolge aufrechtzuerhalten.  Und als Ergebnis der bin√§ren Suche und Einf√ºgung k√∂nnen sich Elemente als viel links und viel rechts von der Position herausstellen, an der sie sich nach dem Neuausgleich befinden sollten.  Und an dem Ort, an dem Sie umziehen m√∂chten, gibt es m√∂glicherweise ein anderes Element, das ebenfalls irgendwo angebracht werden muss.  Au√üerdem k√∂nnen Sie ein Element nicht √ºbertragen, wenn sich zwischen seiner alten und der neuen Position im Hilfsarray andere Elemente befinden. Andernfalls werden die Elemente verwechselt, und es ist √§u√üerst wichtig, dass wir die Reihenfolge nicht verwechseln. <br><br>  Um das Gleichgewicht wieder herzustellen, reicht es daher nicht aus, den √ºblichen Zyklus zu durchlaufen und einfach jedes Element von einer Tasche in eine andere zu verschieben.  Es ist weiterhin erforderlich, die Rekursion zu verwenden.  Wenn ein Element nicht an einen neuen Ort verschoben werden kann (andere Elemente wurden zwischen seiner alten und seiner neuen Position angezeigt), m√ºssen Sie zuerst diese ungebetenen G√§ste (rekursiv) herausfinden.  Und dann wird alles richtig angeordnet. <br><br><h2>  Entarteter Fall </h2><br>  F√ºr die meisten Sortierungen nach Einf√ºgungen ist ein Array in umgekehrter Reihenfolge die schlechteste Situation.  Und das Sortieren eines Bibliothekars ist leider keine Ausnahme. <br><br><img width="693" height="168" src="https://habrastorage.org/webt/mm/zm/_c/mmzm_cvt2fvcawbrkkswtav0huo.gif"><br><br>  Elemente tendieren zum linken Rand des Hilfsarrays, wodurch die leeren Stellen schnell ausgehen.  Sie m√ºssen das Array sehr oft neu ausbalancieren. <br><br>  √úbrigens, wenn wir ein fast geordnetes Array nehmen (der beste Fall f√ºr das Sortieren nach einfachen Einf√ºgungen), dann bekommen wir das gleiche Problem.  Neu ankommende Elemente verstopfen nicht die linke, sondern die rechte Seite des Hilfsarrays, was ebenfalls zu einem zu h√§ufigen Neuausgleich f√ºhrt. <br><br>  Die Bibliothekssortierung verarbeitet zuf√§llige Datens√§tze effizient.  Teilbestellungen (sowohl direkt als auch r√ºckw√§rts) beeintr√§chtigen die Geschwindigkeitsleistung. <br><br><h2>  Algorithmische Komplexit√§t </h2><br>  Bei gro√üen Mengen zuf√§lliger Daten gibt der Algorithmus die Zeitkomplexit√§t O ( <b>n</b> log <b>n</b> ) an.  Gar nicht schlecht! <br><br>  Bei S√§tzen zuf√§lliger eindeutiger (oder gr√∂√ütenteils eindeutiger) Daten mit der richtigen Auswahl des Koeffizienten <strong>Œµ</strong> und der erfolgreichen Implementierung der bin√§ren Suche kann die Anzahl der Neuausgleiche minimiert oder sogar vermieden werden.  Es kann argumentiert werden, dass der Algorithmus die beste Zeitkomplexit√§t O ( <b>n</b> ) aufweist. <br><br>  Ein gro√üer Prozentsatz von Daten, die sich im Wert wiederholen, sowie das Vorhandensein geordneter (in direkter oder umgekehrter Reihenfolge) Teilsequenzen im Array f√ºhren zu einem h√§ufigen Neuausgleich des Hilfsarrays und in den ung√ºnstigsten F√§llen zu einer Verschlechterung der Zeitkomplexit√§t auf O <b>(n <sup>2</sup></b> ). <br><br>  Das Minus des Algorithmus ist nat√ºrlich, dass das Hilfsarray O ( <b>n</b> ) zus√§tzlichen Speicher ben√∂tigt. <br><br><h2>  M√∂gliche Verbesserungsm√∂glichkeiten </h2><br>  Obwohl der Algorithmus selbst bei zuf√§lligen Daten lehrreich und effizient ist, haben in anderthalb Jahrzehnten nur wenige Interesse daran gezeigt. <br><br>  Wenn Sie auf die Anfrage "Bibliothekssortierung" googeln, finden Sie einen fl√ºchtigen Artikel in der englischen Wikipedia, das PDF des Autors (von dem wenig verstanden wird) und eine seltene Neuver√∂ffentlichung dieser mageren Informationen.  Au√üerdem gibt es eine gute Visualisierung in YouTube, wo die Haupt- und Hilfsarrays urspr√ºnglich kombiniert wurden.  Alle Links befinden sich am Ende des Artikels. <br><br>  Die Suche nach ‚ÄûBibliothekssortierung‚Äú macht noch mehr Spa√ü - im Beispiel finden Sie die verschiedenen Sortierungen, die in verschiedenen Bibliotheken enthalten sind. Diese Algorithmen beziehen sich jedoch nicht auf die <i>authentische Bibliothekssortierung</i> . <br><br>  Und es gibt etwas zu verbessern: <br><br><ol><li>  Empirische Auswahl des optimalen Koeffizienten <strong>Œµ</strong> . </li><li>  √Ñnderung (unter Ber√ºcksichtigung der Besonderheiten des allgemeinen Algorithmus) der bin√§ren Suche zur effizientesten Bestimmung der Einf√ºgemarke. </li><li>  Minimierung der Ausgleichskosten. </li></ol><br>  Wenn Sie diese Stellen polieren, entspricht die Sortierung der Bibliothek in der Geschwindigkeit m√∂glicherweise sogar der schnellen Sortierung? <br><br><h2>  Quellcode </h2><br>  Ich habe es nicht geschafft, die Implementierung in Python vorzubereiten, es gibt eine funktionierende Version in PHP. <br><br><div class="spoiler">  <b class="spoiler_title">Grundlegender Algorithmus</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibrarySort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $arr_new;<span class="hljs-comment"><span class="hljs-comment">//  $e = 3;//     $rebalance_local = true;// (true)   (false)  //   $newSize = $e * (count($arr) + 1) - 1; $arr_new = array_fill(0, $newSize, null); //       $arr_new[LibrarySort_Pos(1, 1, $newSize)] = $arr[0]; //    -    //     $start = 0; $finish = $newSize - 1; $i = 1; //      while($i &lt; count($arr)) { //        $pos = LibrarySort_BinarySearch($arr[$i], $start, $finish, $newSize); if($pos === false) {//        //    LibrarySort_Rebalance_Total($i, $newSize); } else {//  ,   ,    if($arr_new[$pos] !== null) {//   if($rebalance_local) {//  (+ ) LibrarySort_Rebalance_Local($arr[$i++], $pos, $newSize); } else {//  LibrarySort_Rebalance_Total($i, $newSize); } } else {//   ,   $arr_new[$pos] = $arr[$i++]; } } } //      $pos = 0; for($i = 0; $i &lt;= $newSize - 1; $i++) { if($arr_new[$i] !== null) $arr[$pos++] = $arr_new[$i]; } return $arr; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Die neue Position des Elements im zus√§tzlichen Array nach vollst√§ndigem Neuausgleich</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// $number-    $count //     //$number -      ( )  //$count -       //$newSize -     //$number &lt;= $count &lt;= count($arr) &lt;= $newSize) function LibrarySort_Pos($number, $count, $newSize) { return $number * floor(($newSize + 1) / ($count + 1)) - 1; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bin√§re Suche nach Insertionsstelle im Hilfsarray</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       //$search -     ,      //($start, $finish) -   ,     //$newSize -     function LibrarySort_BinarySearch($search, $start, $finish, $newSize) { global $arr_new;//  //      //      ,     //  ,       while($arr_new[$start] === null &amp;&amp; $start &lt; $newSize - 1) { ++$start; } //         , //         if($search == $arr_new[$start]) { return LibrarySort_PosNearby($start, $newSize); //  ,        } elseif($search &lt; $arr_new[$start]) { //      //     if($start &gt; 0) {// $start    $finish = $start; $start = 0; return floor(($start + $finish) / 2); } else {//$start == 0,      return $start;//    ,    } } //      ,     //  ,       while($arr_new[$finish] === null &amp;&amp; $finish &gt; 0) { --$finish; } //         , //         if($search == $arr_new[$finish]) { return LibrarySort_PosNearby($finish, $newSize); //  ,        } elseif($search &gt; $arr_new[$finish]) { //      //     if($finish &lt; $newSize - 1) {// $finish    $start = $finish; $finish = $newSize - 1; return ceil(($start + $finish) / 2); } else {//$finish == $newSize - 1,      return $finish;//    ,    } } //     , //,    -   //   ,       If($finish - $start &gt; 1) {//   ,    3  $middle = ceil(($start + $finish) / 2); //   $middle_Pos = 0; // ""     $offset = 0; //         //,    /,      while($middle - $offset &gt; $start &amp;&amp; $middle_Pos == 0){ if($arr_new[$middle - $offset] !== null) { $middle_Pos = $middle - $offset; } elseif($middle + $offset &lt; $finish &amp;&amp; $arr_new[$middle + $offset] !== null) { $middle_Pos = $middle + $offset; } ++$offset; } //    , ,     , //              If($middle_Pos) { if($arr_new[$middle_Pos] == $search) { return LibrarySort_PosNearby($middle_Pos, $newSize); } else { if($arr_new[$middle_Pos] &gt; $search) { $finish = $middle_Pos; } else {//$arr_new[$middle_Pos] &lt; $search $start = $middle_Pos; } return LibrarySort_BinarySearch($search, $start, $finish, $newSize); } } else {//$middle_Pos == 0 -   (   )     return $middle;//   - ,     } } else {//  ,       return floor(($start + $finish) / 2); } return false;//  ,       }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Wenn w√§hrend der Suche das Element gleich einem der Enden des Segments ist</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,        //$start - ,        //$newSize -     function LibrarySort_PosNearby($start, $newSize) { global $arr_new;//  //       for($left = $start - 1; $left &gt;= 0; $left--) { if($arr_new[$left] === null) {//  return $left;//   } elseif($arr_new[$left] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } //     ,    for($right = $start + 1; $right &lt;= $newSize - 1; $right++) { if($arr_new[$right] === null) {//  return $right; //   } elseif($arr_new[$right] &lt;&gt; $arr_new[$start]) {//     break; //   ,      } } return $start; //          .      ,     }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Lokale Neuausrichtung eines zus√§tzlichen Arrays</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$insert - ,    //$pos -            //$newSize -     function LibrarySort_Rebalance_Local($insert, $pos, $newSize) { global $arr_new;//  // $pos  $insert,       while($pos - 1 &gt;= 0 &amp;&amp; $arr_new[$pos - 1] !== null &amp;&amp; $arr_new[$pos - 1] &gt; $insert) {--$pos;} while($pos + 1 &lt;= $newSize - 1 &amp;&amp; $arr_new[$pos + 1] !== null &amp;&amp; $arr_new[$pos + 1] &lt; $insert) {++$pos;} $middle = (integer) $newSize / 2;//  if($pos &lt;= $middle) {//      if($arr_new[$pos] !== null &amp;&amp; $arr_new[$pos] &lt; $insert) ++$pos; //  $right = $pos; while($arr_new[++$right] !== null) {} for($i = $right; $i &gt; $pos; $i--) { $arr_new[$i] = $arr_new[$i - 1]; } } else {//      if($arr_new[$pos] !== null &amp;&amp; $insert &lt; $arr_new[$pos]) --$pos; //  $left = $pos; while($arr_new[--$left] !== null) {} for($i = $left; $i &lt; $pos; $i++) { $arr_new[$i] = $arr_new[$i + 1]; } } $arr_new[$pos] = $insert; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Neuausrichtung des zus√§tzlichen Arrays</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    //$count -        //$newSize -     function LibrarySort_Rebalance_Total($count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $library_Number = $count; //        $library_LeftPos = $newSize - 1;// ,     //         $i = $newSize - 1; while($i &gt;= 0) { if($arr_new[$i] !== null) {//   $pos = LibrarySort_Pos($library_Number, $count, $newSize);//   newSize=$newSize"); if($i == $pos) {//      --$i;//      } elseif($i &lt; $pos) {//    $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; --$i;//      } else {//$i &gt; $pos -     //      LibrarySort_RemoveLeft($i, $pos, $count, $newSize); $i = ($i &gt; $library_LeftPos) ? $library_LeftPos - 1 : --$i; } --$library_Number;//      } else {// ,   --$i;//      } } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bewegung des Elements nach links mit vollem Ausgleich</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     . //    ,   //$i -     ,    //$pos -       //$count -        //$newSize -     function LibrarySort_RemoveLeft($i, $pos, $count, $newSize) { global $arr_new;//  global $library_Number;//     global $library_LeftPos;//        $left = false; $left_Pos = false;//      $j = $i;//      //     while($j &gt; 0 &amp;&amp; $left === false) {//            --$j; //     if($arr_new[$j] !== null) $left = $j;//    } if($left === false || $left &lt; $pos) {//   (  )    //     } else { //$left &gt;= $pos,     --$library_Number;//,       $left_Pos = LibrarySort_Pos($library_Number, $count, $newSize);//     //        LibrarySort_RemoveLeft($left, $left_Pos, $count, $newSize); //  ,     } //    ,   $arr_new[$pos] = $arr_new[$i]; $arr_new[$i] = null; //,         if($pos &lt; $library_LeftPos) $library_LeftPos = $pos; }</span></span></code> </pre> </div></div><br>  Ich musste selbst von Grund auf neu programmieren, basierend auf einer allgemeinen Beschreibung der Methode.  Ich habe keine Geschwindigkeit gesehen, die der schnellen Sortierung nahe kommt. Meine Bibliothekssortieroption sortiert 10 bis 20 Mal langsamer als die schnelle Sortierung.  Aber der Grund ist nat√ºrlich, dass meine Implementierung zu grob ist, vieles wurde nicht ber√ºcksichtigt. <br><br>  Ich w√ºrde gerne eine Version von den Machern des Algorithmus sehen.  Ich werde heute an die Autoren schreiben (und ihnen einen Link zu diesem Habrastatu geben), sie werden pl√∂tzlich antworten.  Obwohl ... ich erinnere mich, ich habe versucht, Allen Beachich ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ABC-Sortierung</a> ) und Jason Morrison ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">J-Sortierung</a> ) zu kontaktieren, aber das Ergebnis war das gleiche, als h√§tte ich in Sportloto geschrieben. <br><br>  <b>UPD</b>  <b>Martin Farah-Colton antwortete mir, dass sie die Implementierung nie durchgef√ºhrt h√§tten:</b> <blockquote>  Ich f√ºrchte, wir haben diese Algorithmen nie implementiert. </blockquote>  <b>Die Hauptsache ist die Idee :)</b> <br><br><h2>  Algorithmusmerkmale </h2><div class="scrollable-table"><table><tbody><tr><th align="left">  Titel </th><td align="left" colspan="2">  Bibliothekssortierung, Bibliothekssortierung </td></tr><tr><th align="left">  Anderer Name </th><td align="left" colspan="2">  Gap Insertion Sort </td></tr><tr><th align="left">  Die Autoren </th><td align="left" colspan="2">  Michael A. Bender, Martin Farach-Colton, Miguel Mosteiro </td></tr><tr><th align="left">  Jahr </th><td align="left" colspan="2">  2004 </td></tr><tr><th align="left">  Klasse </th><td align="left" colspan="2">  Insertion Sorts </td></tr><tr><th align="left">  Vergleiche </th><td align="left" colspan="2">  Es gibt </td></tr><tr><th align="left" rowspan="3">  Zeitliche Komplexit√§t </th><th align="left">  das beste </th><td align="left">  O ( <b>n</b> ) </td></tr><tr><th align="left">  Durchschnitt </th><td align="left">  O ( <b>n</b> log <b>n</b> ) </td></tr><tr><th align="left">  das schlimmste </th><td align="left">  O ( <b>n <sup>2</sup></b> ) </td></tr><tr><th align="left">  Zus√§tzliche Speicherkomplexit√§t </th><td align="left" colspan="2">  O ( <b>n</b> ) </td></tr></tbody></table></div><br><h2>  Referenzen </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Bibliothek sortieren</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img width="30" height="30" src="https://habrastorage.org/webt/sb/ln/dw/sblndwenhewoyoas_n3xp7tyuuu.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Visualisierung des Bibliothekssortieralgorithmus</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Die Einf√ºgesortierung ist O (n log n).</a> <br><br><h3>  Autoren des Algorithmus: </h3><br><img align="right" width="392" height="120" src="https://habrastorage.org/webt/il/dh/l9/ildhl9tnc4alqaexulf-kw2rmt0.png"><br clear="left"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Michael A. Bender</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Martin Farah-Colton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Miguel Mostiro</a> </p><br><br><h3>  Serienartikel: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorte austauschen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Insertion Sorts</a> <ul><li>  <b>Bibliothekar Sort</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solitaire Sort</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortieren Sie "Turm von Hanoi"</a> </li><li>  Junge Tischsortierung </li><li>  Sortierung umkehren </li><li>  Sortiervergleich einf√ºgen </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Auswahl sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierungen zusammenf√ºhren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Verteilung sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hybridsortierung</a> </li></ul><br><br><img align="right" width="364" height="192" src="https://habrastorage.org/webt/9y/1b/d5/9y1bd57yvcw4rt65o3ztjb59xum.png"><br clear="left"><p>  Sortierung zu AlgoLab hinzugef√ºgt.  So k√∂nnen Sie mit kleinen Datenmengen experimentieren. <br><br>  In diesem Fall k√∂nnen Sie entscheiden, wie oft das Hilfsarray gr√∂√üer als das Hauptarray ist.  Um den Koeffizienten <strong>Œµ</strong> auszuw√§hlen <strong>, k√∂nnen</strong> Sie mit der rechten Maustaste auf die Zelle mit ‚ÄûBibliothekssortierung‚Äú klicken und ‚ÄûNotiz √§ndern‚Äú ausw√§hlen.  Stellen Sie in der Notiz den ganzzahligen Wert f√ºr <b>e</b> sorgf√§ltig von 2 auf 5 ein. Wenn Sie anstelle dieser Zahlen etwas anderes eingeben, wird der Standardwert = 2 verwendet. <br><br>  Sie k√∂nnen auch die Art der Neuausrichtung ausw√§hlen.  Wenn Sie local = 1 setzen, wird die lokale Neuausrichtung verwendet.  Wenn lokal = 0 - voll. <br><br>  Vergessen Sie nicht, vor Beginn der Visualisierung den optimalen Ma√üstab f√ºr das Prozessblatt festzulegen, da sonst das Hilfsarray nicht auf den Bildschirm passt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416653/">https://habr.com/ru/post/de416653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416641/index.html">8 Phasen des Prozesses zur Entwicklung einer mobilen Anwendungsschnittstelle</a></li>
<li><a href="../de416643/index.html">Bereitstellen von Elasticsearch unter AWS mit Kubernetes in 10 Schritten</a></li>
<li><a href="../de416645/index.html">MIS. Forschungsmuster</a></li>
<li><a href="../de416647/index.html">Tr√§umen Regierungsbeh√∂rden von elektrischen Risiken?</a></li>
<li><a href="../de416651/index.html">1M HTTP-RPS auf 1 CPU-Kern. DPDK anstelle von Nginx + Linux Kernel TCP / IP</a></li>
<li><a href="../de416657/index.html">Zwei Drittel der verwendeten Speicherkarten enthalten personenbezogene Daten von Vorbesitzern</a></li>
<li><a href="../de416659/index.html">Aufgrund dessen wird das Volumen der digitalen Zahlungen f√ºr die Gig Economy 1,2 Billionen Dollar erreichen</a></li>
<li><a href="../de416661/index.html">Welche Trends sollten Nutzer und Anbieter von Mobile Banking ber√ºcksichtigen?</a></li>
<li><a href="../de416665/index.html">Wiederverwendung privater Android-Bibliotheken mit Sonatype Nexus Repository OSS</a></li>
<li><a href="../de416667/index.html">Budget Staub- und Ger√§uschd√§mmung der alten Systemeinheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>