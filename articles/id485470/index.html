<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐲 👩🏽‍🌾 ♾ HighLoad ++, Andrey Gushchin (Zabbix): kinerja tinggi dan partisi asli 👩🏾‍✈️ 🤶🏾 🤟🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita akan melihat bagaimana Zabbix bekerja dengan database TimescaleDB sebagai backend. Kami menunjukkan cara memulai dari awal dan cara bermigrasi de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Andrey Gushchin (Zabbix): kinerja tinggi dan partisi asli</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/485470/"> Kita akan melihat bagaimana Zabbix bekerja dengan database TimescaleDB sebagai backend.  Kami menunjukkan cara memulai dari awal dan cara bermigrasi dengan PostgreSQL.  Kami juga memberikan uji kinerja komparatif dari kedua konfigurasi tersebut. <br><br><img src="https://habrastorage.org/webt/h4/jl/nw/h4jlnwupm_dewx7jasafurn-ibm.jpeg"><br><br>  HighLoad ++ Siberia 2019. Tomsk Hall.  24 Juni 16:00.  Abstrak dan <a href="https://www.highload.ru/siberia/2019/abstracts/5390">presentasi</a> .  Konferensi HighLoad ++ berikutnya akan diadakan pada 6 dan 7 April 2020 di St. Petersburg.  Detail dan tiket di <a href="http://bit.ly/2sSxgBx">sini</a> . <br><br>  <b>Andrey Gushchin (selanjutnya</b> disebut sebagai <b>AG):</b> - Saya seorang insinyur dukungan teknis ZABBIX (selanjutnya disebut sebagai Zabbix), seorang pelatih.  Saya telah bekerja dalam dukungan teknis selama lebih dari 6 tahun dan telah berhadapan langsung dengan kinerja.  Hari ini saya akan berbicara tentang kinerja yang TimescaleDB dapat berikan bila dibandingkan dengan PostgreSQL biasa 10. Juga, beberapa bagian pengantar - tentang cara kerjanya. <a name="habracut"></a><br><br><h3>  Tantangan Kinerja Utama: Dari Akuisisi Data </h3><br>  Untuk memulainya, ada tantangan kinerja tertentu yang dihadapi oleh setiap sistem pemantauan.  Tantangan kinerja pertama adalah pengumpulan dan pemrosesan data secara cepat. <br><br><img src="https://habrastorage.org/webt/jl/xr/hv/jlxrhv3huan1s0w4otmxoknifzy.jpeg"><br><br>  Sistem pemantauan yang baik harus segera, tepat waktu menerima semua data, memprosesnya sesuai dengan pemicu ekspresi, yaitu, memprosesnya sesuai dengan beberapa kriteria (dalam sistem yang berbeda berbeda) dan menyimpannya ke database untuk menggunakan data ini di masa depan. <br><br><img src="https://habrastorage.org/webt/d5/vq/-l/d5vq-lgcwljaq50nc-zxfeugi3k.jpeg"><br><br>  Tantangan kinerja kedua adalah menjaga sejarah.  Simpan dalam database sering dan memiliki akses cepat dan mudah ke metrik ini yang dikumpulkan selama periode waktu tertentu.  Yang paling penting adalah nyaman untuk mendapatkan data ini, menggunakannya dalam laporan, grafik, pemicu, dalam beberapa nilai ambang, untuk peringatan, dll. <br><br><img src="https://habrastorage.org/webt/k2/1l/3g/k21l3gg3vmeayv-d8oqpatgssv8.jpeg"><br><br>  Tantangan kinerja ketiga adalah membersihkan sejarah, yaitu, ketika hari Anda sedemikian rupa sehingga Anda tidak perlu menyimpan metrik terperinci yang telah dikumpulkan selama 5 tahun (bahkan berbulan-bulan atau dua bulan).  Beberapa node jaringan telah dihapus, atau beberapa host, metrik tidak lagi diperlukan karena mereka sudah usang dan tidak lagi dikumpulkan.  Semua ini perlu dibersihkan agar basis data Anda tidak bertambah besar.  Secara umum, membersihkan sejarah paling sering merupakan ujian serius untuk penyimpanan - sangat sering mempengaruhi kinerja. <br><br><h3>  Bagaimana cara mengatasi masalah caching? </h3><br>  Sekarang saya akan berbicara secara khusus tentang Zabbix.  Di Zabbix, panggilan pertama dan kedua diselesaikan menggunakan caching. <br><br><img src="https://habrastorage.org/webt/mg/2b/tb/mg2btblcs3cxvlnddc0yg6lwxrw.jpeg"><br><br>  Pengumpulan dan pemrosesan data - kami menggunakan RAM untuk menyimpan semua data ini.  Sekarang data ini akan dibahas secara lebih rinci. <br><br>  Juga di sisi database ada caching tertentu untuk sampel utama - untuk grafik, hal-hal lain. <br><br>  Caching di sisi server Zabbix itu sendiri: kami memiliki ConfigurationCache, ValueCache, HistoryCache, TrendsCache.  Apa ini <br><br><img src="https://habrastorage.org/webt/6j/4e/_a/6j4e_acyhx8ldzgjfziqhuzvwz0.jpeg"><br><br>  ConfigurationCache adalah cache utama tempat kami menyimpan metrik, host, item data, pemicu;  semua yang Anda butuhkan untuk memproses preprocessing, mengumpulkan data, dari host mana yang dikumpulkan, dengan frekuensi berapa.  Semua ini disimpan dalam ConfigurationCache, agar tidak pergi ke database, bukan untuk membuat permintaan yang tidak perlu.  Setelah server dimulai, kami memperbarui cache ini (buat) dan memperbarui secara berkala (tergantung pada pengaturan konfigurasi). <br><br><img src="https://habrastorage.org/webt/q1/zc/dg/q1zcdgan2c5rcep47ebef24xrn0.jpeg"><br><br><h3>  Caching di Zabbix.  Pengumpulan data </h3><br>  Di sini skemanya cukup besar: <br><br><img src="https://habrastorage.org/webt/88/mh/gd/88mhgd974zcj8eou8kghhodhwf0.jpeg"><br><br>  Yang utama dalam skema ini adalah para kolektor ini: <br><br><img src="https://habrastorage.org/webt/2y/co/f7/2ycof750qb71iooc2qiahs-5i9y.jpeg"><br><br>  Ini adalah proses perakitan itu sendiri, berbagai "jajak pendapat" yang bertanggung jawab untuk berbagai jenis majelis.  Mereka mengumpulkan data melalui icmp, ipmi, sesuai dengan protokol yang berbeda dan mentransfer semuanya ke preprocessing. <br><br><h3>  PreCiproses HistoryCache </h3><br>  Selain itu, jika kami telah menghitung elemen data (siapa yang tahu Zabbix - tahu), yaitu elemen data yang dihitung, dikumpulkan, kami membawanya langsung dari ValueCache.  Tentang bagaimana itu diisi, saya akan katakan nanti.  Semua kolektor ini menggunakan ConfigurationCache untuk mendapatkan pekerjaan mereka dan kemudian meneruskannya ke preprocessing. <br><br><img src="https://habrastorage.org/webt/b4/qb/mh/b4qbmhsqtxvrfli40n-espjba6c.jpeg"><br><br>  Preprocessing juga menggunakan ConfigurationCache untuk mendapatkan langkah preprocessing, ia memproses data ini dengan berbagai cara.  Dimulai dengan versi 4.2, kami menyerahkannya ke proxy.  Ini sangat mudah, karena preprocessing itu sendiri adalah operasi yang agak sulit.  Dan jika Anda memiliki "Zabbix" yang sangat besar, dengan sejumlah besar elemen data dan koleksi frekuensi tinggi, ini sangat memudahkan pekerjaan. <br><br>  Karenanya, setelah kami memproses data ini dengan beberapa cara menggunakan preprocessing, kami menyimpannya di HistoryCache untuk memprosesnya lebih lanjut.  Ini mengakhiri pengumpulan data.  Kami beralih ke proses utama. <br><br><h3>  Operasi syncer sejarah </h3><br><img src="https://habrastorage.org/webt/40/yj/9-/40yj9-h-hgm5wcd2hu2ygt5uyp4.jpeg"><br><br>  Proses utama dalam Zabbix (karena merupakan arsitektur monolitik) adalah History syncer.  Ini adalah proses utama yang berkaitan secara khusus dengan pemrosesan atom dari setiap elemen data, yaitu dari setiap nilai: <br><br><ul><li>  nilai datang (dibutuhkan dari HistoryCache); </li><li>  check in Configuration syncer: apakah ada pemicu untuk perhitungan? menghitungnya; <br>  jika ada, itu menciptakan peristiwa, menciptakan eskalasi untuk membuat peringatan, jika perlu oleh konfigurasi; </li><li>  catatan pemicu untuk pemrosesan selanjutnya, agregasi;  jika Anda mengumpulkan dalam satu jam terakhir dan seterusnya, nilai ini mengingat ValueCache, agar tidak masuk ke tabel sejarah;  Dengan demikian, ValueCache diisi dengan data yang diperlukan yang diperlukan untuk menghitung pemicu, elemen yang dihitung, dll. </li><li>  kemudian syncer sejarah menulis semua data ke database; </li><li>  database menulisnya ke disk - disinilah proses pemrosesan berakhir. </li></ul><br><h3>  Basis data  Caching </h3><br>  Di sisi DB, ketika Anda ingin melihat grafik atau semacam laporan acara, ada berbagai cache.  Tetapi sebagai bagian dari laporan ini, saya tidak akan membicarakannya. <br><br>  Untuk MySQL, ada Innodb_buffer_pool, sekelompok cache yang berbeda yang juga dapat dikonfigurasi. <br>  Tapi ini yang utama: <br><br><ul><li>  shared_buffers; </li><li>  ukuran efektif_cache_; </li><li>  shared_pool. </li></ul><br><img src="https://habrastorage.org/webt/fw/7n/0z/fw7n0ziowm_jbvs--peokkswjdw.jpeg"><br><br>  Saya telah mengutip untuk semua database bahwa ada cache tertentu yang memungkinkan Anda untuk menyimpan dalam memori data yang sering diperlukan untuk permintaan.  Di sana mereka memiliki teknologi sendiri untuk ini. <br><br><h3>  Tentang kinerja basis data </h3><br>  Karenanya, ada lingkungan kompetitif, yaitu, server Zabbix mengumpulkan data dan mencatatnya.  Saat memulai ulang, itu juga membaca dari sejarah untuk mengisi ValueCache dan sebagainya.  Di sini Anda dapat memiliki skrip dan laporan yang menggunakan Zabbix-API, yang dibangun berdasarkan antarmuka web.  "Zabbiks" -API termasuk dalam database dan menerima data yang diperlukan untuk mendapatkan grafik, laporan atau daftar peristiwa, masalah terkini. <br><br><img src="https://habrastorage.org/webt/gr/to/vp/grtovpkr0x6kkytkg5bw2zllpqw.jpeg"><br><br>  Juga solusi visualisasi yang sangat populer adalah Grafana, yang digunakan oleh pengguna kami.  Mampu langsung memasukkan keduanya melalui "Zabbiks" -API, dan melalui database.  Hal ini juga menciptakan persaingan tertentu untuk mendapatkan data: penyempurnaan yang lebih baik, penyempurnaan yang lebih baik dari basis data diperlukan agar sesuai dengan pengiriman hasil dan pengujian yang cepat. <br><br><img src="https://habrastorage.org/webt/aj/ak/l-/ajakl-q1nyal8mce-xw4snwrgye.jpeg"><br><br><h3>  Bersihkan riwayat.  Zabbix memiliki Pengurus Rumah Tangga </h3><br>  Tantangan ketiga yang digunakan oleh Zabbix adalah untuk membersihkan cerita dengan Housekeeper.  Hauskiper mematuhi semua pengaturan, yaitu, dalam elemen data kami ditunjukkan berapa banyak untuk menyimpan (dalam hari), berapa banyak untuk menyimpan tren, dinamika perubahan. <br><br>  Saya tidak berbicara tentang TrendCache, yang kami hitung dengan cepat: data tiba, kami menjumlahkannya dalam satu jam (pada dasarnya ini adalah angka dalam jam terakhir), jumlahnya rata-rata / minimum dan menuliskannya sekali per jam di tabel perubahan dinamika (Tren) .  Hauskiper memulai dan menghapus data dari database menggunakan pilihan reguler, yang tidak selalu efektif. <br><br>  Bagaimana memahami bahwa itu tidak efisien?  Anda dapat melihat gambar berikut pada grafik kinerja proses internal: <br><br><img src="https://habrastorage.org/webt/cw/au/u3/cwauu3n4dk0-u_nonnfzbf0og6g.jpeg"><br><br>  Syncer History Anda selalu sibuk (grafik merah).  Dan grafik "merah" yang berada di atas.  Ini adalah Hauskiper, yang memulai dan menunggu untuk database ketika menghapus semua baris yang ditentukan. <br><br>  Ambil beberapa ID Item: Anda harus menghapus 5 ribu terakhir;  Tentu saja dengan indeks.  Tetapi biasanya dataset cukup besar - database masih membaca ini dari disk dan menaikkannya ke cache, dan ini adalah operasi yang sangat mahal untuk database.  Tergantung pada ukurannya, ini dapat menyebabkan masalah kinerja tertentu. <br><br>  Anda dapat menonaktifkan Hauskiper dengan cara sederhana - kami memiliki antarmuka web yang umum untuk semua orang.  Pengaturan dalam Administrasi umum (pengaturan untuk "Housekeeper") kami menonaktifkan housekeeping internal untuk sejarah dan tren internal.  Karenanya, Hauskiper tidak lagi mengontrol ini: <br><br><img src="https://habrastorage.org/webt/cp/si/jo/cpsijomx2kl2p1trw0it8ujvpga.jpeg"><br><br>  Apa yang bisa saya lakukan selanjutnya?  Anda terputus, jadwal Anda naik level ... Masalah apa yang bisa lebih jauh dalam kasus ini?  Apa yang bisa membantu? <br><br><h3>  Partisi (partisi) </h3><br>  Ini biasanya dikonfigurasi pada setiap basis data relasional yang telah saya daftarkan dengan cara yang berbeda.  MySQL memiliki teknologinya sendiri.  Tetapi secara keseluruhan mereka sangat mirip ketika datang ke PostgreSQL 10 dan MySQL.  Tentu saja, ada banyak perbedaan internal dalam bagaimana semua itu diterapkan dan bagaimana semuanya mempengaruhi kinerja.  Namun secara umum, pembuatan partisi baru seringkali juga mengarah pada masalah tertentu. <br><br><img src="https://habrastorage.org/webt/g3/ru/gs/g3rugs9kazu4fcyk70inqtrnrd4.jpeg"><br><br>  Tergantung pada pengaturan Anda (berapa banyak data yang Anda buat dalam satu hari), mereka biasanya menetapkan minimal satu - 1 hari / partisi, dan untuk tren, dinamika perubahan - 1 bulan / partisi baru.  Ini dapat berubah jika Anda memiliki pengaturan yang sangat besar. <br><br>  Katakan langsung tentang ukuran pengaturan: hingga 5 ribu nilai baru per detik (disebut nvps) - ini akan dianggap sebagai "pengaturan" kecil.  Rata-rata - dari 5 hingga 25 ribu nilai per detik.  Semua yang ada di atas sudah instalasi besar dan sangat besar yang membutuhkan konfigurasi database yang sangat hati-hati. <br><br>  Pada instalasi yang sangat besar, 1 hari - ini mungkin tidak optimal.  Saya pribadi melihat partisi MySQL sebesar 40 gigabyte per hari (dan mungkin ada lebih banyak).  Ini adalah jumlah data yang sangat besar, yang dapat menyebabkan beberapa masalah.  Itu perlu dikurangi. <br><br><h3>  Mengapa harus dipartisi? </h3><br>  Apa yang Partitioning berikan, saya pikir semua orang tahu, adalah tabel partisi.  Seringkali ini adalah file terpisah pada permintaan disk dan span.  Dia lebih optimal memilih satu partisi, jika ini adalah bagian dari partisi yang biasa. <br><br><img src="https://habrastorage.org/webt/nd/u2/6a/ndu26acwf_st_axq0rfws4t0yhu.jpeg"><br><br>  Untuk Zabbix, khususnya, digunakan oleh rentang, oleh rentang, yaitu, kami menggunakan timestamp (jumlahnya biasa, waktu dari awal era).  Anda menentukan awal hari / akhir hari, dan ini adalah partisi.  Dengan demikian, jika Anda melamar data dua hari yang lalu, ini semua dipilih dari database lebih cepat, karena Anda hanya perlu mengunggah satu file ke cache dan mengeluarkan (bukan tabel besar). <br><br><img src="https://habrastorage.org/webt/n8/-5/h0/n8-5h0inf3gdrt6fv2jaqeguoxm.jpeg"><br><br>  Banyak basis data juga mempercepat penyisipan (penyisipan ke tabel satu anak).  Meskipun saya berbicara secara abstrak, tetapi itu juga mungkin.  Berpartisi sering membantu. <br><br><h3>  Elasticsearch untuk NoSQL </h3><br>  Baru-baru ini, dalam 3.4, kami menerapkan solusi untuk NoSQL.  Menambahkan kemampuan untuk menulis di Elasticsearch.  Anda dapat menulis beberapa jenis terpisah: pilih - baik tuliskan nomor atau beberapa tanda;  kami memiliki teks string, Anda dapat menulis log di Elasticsearch ... Dengan demikian, antarmuka web juga akan mengakses Elasticsearch.  Ini berfungsi dengan baik dalam beberapa kasus, tetapi saat ini dapat digunakan. <br><br><img src="https://habrastorage.org/webt/xq/f_/kc/xqf_kcj7pttjfkqtvykodkhf1ne.jpeg"><br><br><h3>  TimescaleDB.  Hipertabel </h3><br>  Untuk 4.4.2, kami memperhatikan satu hal seperti TimescaleDB.  Apa ini  Ini adalah ekstensi untuk Postgres, yaitu, ia memiliki antarmuka asli PostgreSQL.  Plus, ekstensi ini memungkinkan Anda untuk bekerja dengan data deret waktu jauh lebih efisien dan memiliki partisi otomatis.  Seperti apa tampilannya: <br><br><img src="https://habrastorage.org/webt/_q/nk/mz/_qnkmz4mbfzhveegk3d2hjzgafg.jpeg"><br><br>  Ini hipertensi - ada konsep seperti itu di Timescale.  Ini adalah hipertensi yang Anda buat, dan berisi potongan.  Bongkahan adalah partisi, ini adalah meja anak-anak, jika saya tidak salah.  Ini sangat efektif. <br><br><img src="https://habrastorage.org/webt/un/gu/pk/ungupk6uffgezcunuoaa4tjkk0g.jpeg"><br><br><h3>  TimescaleDB dan PostgreSQL </h3><br>  Seperti yang dipastikan oleh produsen TimescaleDB, mereka menggunakan algoritma pemrosesan permintaan yang lebih benar, khususnya insert'ov, yang memungkinkan Anda memiliki kinerja yang hampir konstan dengan ukuran insert data yang meningkat.  Yaitu, setelah 200 juta baris "Postgres", yang biasa mulai melorot sangat banyak dan kehilangan kinerja secara harfiah menjadi nol, sedangkan "Timescale" memungkinkan Anda untuk memasukkan sisipan seefisien mungkin dengan sejumlah data. <br><br><img src="https://habrastorage.org/webt/xo/zb/-o/xozb-o86ammklruo6wbmreoddga.jpeg"><br><br><h3>  Bagaimana cara menginstal TimescaleDB?  Semuanya sederhana! </h3><br>  Dia memilikinya dalam dokumentasi, dijelaskan - itu dapat dikirim dari paket untuk ... Itu tergantung pada paket resmi Postgres.  Itu dapat dikompilasi secara manual.  Kebetulan saya harus mengkompilasi untuk database. <br><br><img src="https://habrastorage.org/webt/vm/t8/ab/vmt8ab42ehsl-ne-cxb70skn9ik.jpeg"><br><br>  Di Zabbix, kami hanya mengaktifkan Extention.  Saya pikir mereka yang menggunakan Extention di Postgres ... Anda cukup mengaktifkan Extention, buat untuk database Zabbix yang Anda gunakan. <br><br>  Dan langkah terakhir ... <br><br><h3>  TimescaleDB.  Tabel riwayat migrasi </h3><br>  Anda harus membuat hipertensi.  Ada fungsi khusus untuk ini - Buat hipertensi.  Di dalamnya, parameter pertama menunjukkan tabel yang diperlukan dalam database ini (yang Anda perlu buat hipertensi). <br><br><img src="https://habrastorage.org/webt/rs/p0/ja/rsp0ja0xplwviw9abiqvsody8zw.jpeg"><br><br>  Bidang yang ingin Anda buat, dan chunk_time_interval (ini adalah interval chunks (partisi yang akan digunakan). 86.400 adalah satu hari. <br><br>  Parameter migrate_data: jika Anda memasukkan true, maka ini mentransfer semua data saat ini ke potongan yang dibuat sebelumnya. <br><br>  Saya sendiri menggunakan migrate_data - butuh waktu yang layak, tergantung seberapa besar basis data Anda.  Saya memiliki lebih dari satu terabyte - pembuatannya membutuhkan waktu lebih dari satu jam.  Dalam beberapa kasus, saat pengujian, saya menghapus data historis untuk teks (history_text) dan string (history_str), agar tidak mentransfernya - mereka tidak benar-benar menarik bagi saya. <br><br>  Dan kami melakukan pembaruan terakhir di db_extention kami: kami menetapkan timescaledb sehingga database dan, khususnya, Zabbix kami memahami apa itu db_extention.  Ini mengaktifkannya dan menggunakan sintaksis yang benar dan query database, menggunakan "fitur" yang diperlukan untuk TimescaleDB. <br><br><h3>  Konfigurasi server </h3><br>  Saya menggunakan dua server.  Server pertama adalah mesin virtual yang cukup kecil, 20 prosesor, 16 gigabytes RAM.  Siapkan Postgres 10.8 di atasnya: <br><br><img src="https://habrastorage.org/webt/q_/h-/fe/q_h-fey52vutiin_dcat3zezb1g.jpeg"><br><br>  Sistem operasi adalah Debian, sistem file adalah xfs.  Saya membuat pengaturan minimal untuk menggunakan database khusus ini, minus apa yang akan digunakan Zabbix.  Pada mesin yang sama adalah server Zabbix, PostgreSQL, dan agen beban. <br><br><img src="https://habrastorage.org/webt/vl/jv/bu/vljvbuggjlj1vz5tvptvzsicauo.jpeg"><br><br>  Saya menggunakan 50 agen aktif yang menggunakan LoadableModule untuk dengan cepat menghasilkan berbagai hasil.  Mereka menghasilkan garis, angka, dan sebagainya.  Saya menyumbat DB dengan banyak data.  Awalnya, konfigurasi berisi 5 ribu elemen data per host, dan kira-kira setiap elemen data berisi pemicu - sehingga itu merupakan pengaturan nyata.  Terkadang bahkan dibutuhkan lebih dari satu pemicu untuk digunakan. <br><br><img src="https://habrastorage.org/webt/9e/z0/os/9ez0os1zg6wv3k3d176svhoauqe.jpeg"><br><br>  Saya mengatur interval pembaruan, beban itu sendiri sehingga saya tidak hanya menggunakan 50 agen (ditambahkan lebih banyak), tetapi juga dengan bantuan elemen data dinamis dan mengurangi interval pembaruan menjadi 4 detik. <br><br><h3>  Tes kinerja.  PostgreSQL: 36 ribu NVP </h3><br>  Peluncuran pertama, pengaturan pertama saya pada PostreSQL 10 murni pada perangkat keras ini (35 ribu nilai per detik).  Secara umum, seperti yang dapat Anda lihat di layar, memasukkan data membutuhkan sepersekian detik - semuanya baik-baik saja dan cepat, SSD (200 gigabyte).  Satu-satunya hal adalah bahwa 20 GB dengan cepat terisi. <br><br><img src="https://habrastorage.org/webt/st/er/oh/sterohufqkrwjzwicbau9fxyeg8.jpeg"><br><br>  Akan ada lebih banyak grafik seperti itu.  Ini adalah dasbor kinerja standar server Zabbix. <br><br><img src="https://habrastorage.org/webt/2m/31/jy/2m31jys-j4bm3ocrwo7bqtp5ftu.jpeg"><br><br>  Grafik pertama adalah jumlah nilai per detik (biru, kiri atas), 35 ribu nilai dalam kasus ini.  Ini (pusat pemuatan) adalah pemuatan proses perakitan, dan ini (kanan atas) memuat proses internal: penyelaraskan riwayat dan pembantu rumah tangga, yang telah berjalan di sini untuk waktu yang cukup. <br><br>  Grafik ini (tengah bawah) menunjukkan penggunaan ValueCache - berapa banyak hit ValueCache untuk pemicu (beberapa ribu nilai per detik).  Grafik penting lainnya adalah yang keempat (kiri bawah), yang menunjukkan penggunaan HistoryCache, yang saya bicarakan, yang merupakan buffer sebelum memasukkan ke dalam database. <br><br><h3>  Tes kinerja.  PostgreSQL: 50 ribu NVP </h3><br>  Selanjutnya, saya menambah beban menjadi 50 ribu nilai per detik pada perangkat keras yang sama.  Saat memuat dengan Hauskiper, 10 ribu nilai tercatat sudah dalam 2-3 detik dengan perhitungan.  Faktanya, yang ditunjukkan pada tangkapan layar berikut: <br><br><img src="https://habrastorage.org/webt/z7/ml/st/z7mlstfkfw8weobkfvj83zxy4w4.jpeg"><br><br>  Hauskiper sudah mulai mengganggu pekerjaan, tetapi pemuatan keseluruhan penjebak sejarah-sinker masih di 60% (grafik ketiga, kanan atas).  HistoryCache sudah selama karya "Hauskiper" mulai aktif mengisi (kiri bawah).  Itu sekitar setengah gigabyte, terisi 20%. <br><br><img src="https://habrastorage.org/webt/mk/-k/q4/mk-kq4jre2iwk-6fdt9xlejoaje.jpeg"><br><br><h3>  Tes kinerja.  PostgreSQL: 80 ribu NVP </h3><br>  Selanjutnya meningkat menjadi 80 ribu nilai per detik: <br><br><img src="https://habrastorage.org/webt/7g/zj/jq/7gzjjqaa68jpj_9yltg7mhfvz0a.jpeg"><br><br>  Itu sekitar 400 ribu elemen data, 280 ribu pemicu.  Sisipan, seperti yang Anda lihat, untuk memuat sinker historis (ada 30 dari mereka) sudah cukup tinggi.  Selanjutnya, saya meningkatkan berbagai parameter: history-sinkers, cache ... Pada hardware ini, memuat history-sinkers mulai meningkat secara maksimal, hampir "ke rak" - karena itu, HistoryCache pergi ke beban yang sangat tinggi: <br><br><img src="https://habrastorage.org/webt/xd/3z/ky/xd3zkydh5zu-vkewwstgk12qc-s.jpeg"><br><br>  Selama ini saya memperhatikan semua parameter sistem (bagaimana prosesor digunakan, RAM) dan menemukan bahwa pemanfaatan disk maksimum - saya mencapai kapasitas maksimum disk ini pada perangkat keras ini, pada mesin virtual ini.  "Postgres" dimulai pada intensitas untuk membuang data dengan cukup aktif, dan disk tidak lagi punya waktu untuk menulis, membaca ... <br><br><img src="https://habrastorage.org/webt/d7/3l/2z/d73l2zoa7tqmhkjoji9z4hx1poy.jpeg"><br><br>  Saya mengambil server lain yang sudah memiliki 48 prosesor dengan 128 gigabytes RAM: <br><br><img src="https://habrastorage.org/webt/-x/-b/9d/-x-b9dzzor5kwaba8sloo01yhk0.jpeg"><br><br>  Juga, saya "menodai" itu - saya menginstal syncer Sejarah (60 buah) dan mencapai kinerja yang dapat diterima.  Faktanya, kita tidak "berada di rak", tetapi ini mungkin adalah batas produktivitas, di mana kita perlu melakukan sesuatu untuk itu. <br><br><h3>  Tes kinerja.  TimescaleDB: 80 ribu NVP </h3><br>  Tugas utama saya adalah menggunakan TimescaleDB.  Kegagalan terlihat di setiap grafik: <br><br><img src="https://habrastorage.org/webt/zr/2l/hb/zr2lhbdocfwqknn3sgd_4agzsus.jpeg"><br><br>  Penurunan ini hanya migrasi data.  Setelah itu, di server "Zabbix", profil pemuatan sejarah-sinker, seperti yang Anda lihat, telah banyak berubah.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini hampir 3 kali lebih cepat yang memungkinkan Anda untuk memasukkan data dan menggunakan lebih sedikit HistoryCache - karena itu, Anda akan menerima data tepat waktu. </font><font style="vertical-align: inherit;">Sekali lagi, 80 ribu nilai per detik adalah tingkat yang cukup tinggi (tentu saja, bukan untuk Yandex). </font><font style="vertical-align: inherit;">Secara umum, ini adalah pengaturan yang cukup besar, dengan satu server.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tes kinerja PostgreSQL: 120 ribu NVP </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, saya meningkatkan nilai jumlah elemen data menjadi setengah juta dan mendapatkan nilai perkiraan 125 ribu per detik: </font></font><br><br><img src="https://habrastorage.org/webt/cd/ay/e6/cdaye6egnxctvuobxadw6hf7bhw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan saya mendapatkan grafik ini: </font></font><br><br><img src="https://habrastorage.org/webt/ts/di/fg/tsdifgr_chfu20nox8il6o2dtha.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada prinsipnya, ini adalah pengaturan yang berfungsi, ia dapat bekerja untuk waktu yang agak lama. Tetapi karena saya hanya memiliki 1,5 terabyte disk, saya menghabiskannya dalam beberapa hari. Yang paling penting, pada saat yang sama, partisi TimescaleDB baru dibuat, dan ini benar-benar tidak diperhatikan untuk kinerja, yang tidak dapat dikatakan tentang MySQL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partisi biasanya dibuat pada malam hari, karena memblokir penyisipan umum dan operasi tabel, dan dapat menyebabkan degradasi layanan. Dalam hal ini, ini bukan! Tugas utama adalah menguji kemampuan TimescaleDB. Hasilnya adalah angka seperti itu: 120 ribu nilai per detik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada juga contoh di komunitas:</font></font><br><br><img src="https://habrastorage.org/webt/rz/rn/m-/rzrnm-wfnbq8unwrcvozg8neccy.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pria itu juga menyalakan TimescaleDB dan beban untuk menggunakan io.weight jatuh pada prosesor; </font><font style="vertical-align: inherit;">dan penggunaan elemen proses internal juga menurun berkat dimasukkannya TimescaleDB. </font><font style="vertical-align: inherit;">Dan ini adalah disk pancake biasa, yaitu, mesin virtual biasa pada disk biasa (bukan SSD)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk beberapa pengaturan kecil yang mengandalkan kinerja disk, TimescaleDB, menurut saya, adalah solusi yang sangat bagus. </font><font style="vertical-align: inherit;">Ini akan memungkinkan Anda untuk terus bekerja dengan baik sebelum bermigrasi ke perangkat keras yang lebih cepat untuk basis data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengundang Anda semua ke acara kami: Konferensi - di Moskow, KTT - di Riga. </font><font style="vertical-align: inherit;">Gunakan saluran kami - Telegram, forum, IRC. </font><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan - datang ke konter kami, kami dapat membicarakan semuanya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertanyaan pemirsa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan dari hadirin (selanjutnya - A): - Jika TimescaleDB sangat mudah dikonfigurasi, dan memberikan peningkatan kinerja seperti itu, maka mungkin itu harus digunakan sebagai praktik terbaik untuk mengatur Zabbix dengan Postgres? Dan apakah ada kekurangan dan kekurangan dari keputusan ini, atau masih, jika saya memutuskan untuk membuat Zabbix sendiri, saya dapat dengan aman mengambil Postgres, langsung menempatkan Timescale di sana, menggunakannya dan tidak memikirkan masalah apa pun ? </font></font><br><br><img src="https://habrastorage.org/webt/5j/k8/og/5jk8ogejgbixfe_a0tfxzh8vbmw.jpeg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AH:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ya, saya akan mengatakan bahwa ini adalah rekomendasi yang bagus: segera gunakan Postgres dengan ekstensi TimescaleDB. Seperti yang saya katakan, banyak ulasan bagus, meskipun faktanya "fitur" ini bersifat eksperimental. Tetapi pada kenyataannya, tes menunjukkan bahwa ini adalah solusi hebat (dengan TimescaleDB), dan saya pikir itu akan berkembang! Kami mengamati bagaimana ekspansi ini berkembang dan akan memperbaiki apa yang dibutuhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan selama pengembangan, kami mengandalkan salah satu "fitur" terkenal mereka: di sana Anda dapat bekerja dengan potongan sedikit berbeda. Tapi kemudian mereka melihatnya di rilis berikutnya, dan kami tidak lagi bergantung pada kode ini. Saya akan merekomendasikan menggunakan solusi ini pada banyak pengaturan. Jika Anda menggunakan MySQL ... Untuk pengaturan menengah, solusi apa pun berfungsi dengan baik. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Pada grafik terbaru, yang berasal dari komunitas, ada grafik dengan "Housekeeper": </font></font><br><br><img src="https://habrastorage.org/webt/xh/pg/0j/xhpg0jw0a7davjqyru9gqg7xnx8.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu terus bekerja. Apa yang dilakukan Hauskiper dengan TimescaleDB? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AG:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sekarang saya tidak bisa mengatakan dengan pasti - Saya akan melihat kode dan mengatakan lebih detail. Itu tidak menggunakan kueri TimescaleDB untuk menghapus potongan, tapi entah bagaimana menggabungkannya. Meskipun saya belum siap untuk menjawab pertanyaan teknis ini. Kami akan mengklarifikasi di stand hari ini atau besok. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya punya pertanyaan serupa - tentang kinerja operasi hapus di Timescale.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A (respons dari audiens): - Ketika Anda menghapus data dari tabel, jika Anda melakukannya melalui delete, maka Anda harus melalui tabel - hapus, bersih, tandai semua untuk vakum di masa mendatang. Di Timescale, karena Anda memiliki bongkahan, Anda bisa jatuh. Secara kasar, Anda hanya mengatakan pada file yang ada dalam data besar: "Hapus!" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Skala waktu" hanya memahami bahwa tidak ada potongan seperti itu lagi. Dan karena ia terintegrasi ke dalam perencana kueri, ia menangkap kondisi Anda pada hook di operasi tertentu atau lainnya dan segera memahami bahwa bidak ini tidak ada lagi - “Saya tidak akan pergi ke sana lagi!” (Data tidak tersedia). Itu saja! Artinya, pemindaian tabel digantikan oleh penghapusan file biner, jadi itu cepat. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Sudah menyentuh topik bukan SQL. Sejauh yang saya mengerti, Zabbix tidak benar-benar perlu memodifikasi data, tetapi semua ini seperti log. Apakah mungkin untuk menggunakan basis data khusus yang tidak dapat mengubah data mereka, tetapi pada saat yang sama menyimpan, mengakumulasi, memberikan - Clickhouse, katakanlah sesuatu seperti kafka? .. Kafka juga merupakan log! Apakah mungkin untuk mengintegrasikannya? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AH:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Bongkar dapat dilakukan. Kami memiliki "fitur" tertentu dari versi 3.4: Anda dapat menulis semua file historis, acara, semua lainnya ke file; dan kemudian mengirimkannya oleh penangan mana saja ke basis data lain. Bahkan, banyak yang mengulang dan menulis langsung ke database. Saat itu juga, sinkronisasi sejarah menulis semua ini ke file, memutar file-file ini, dan seterusnya, dan Anda dapat membuang ini ke Clickhouse. Saya tidak bisa mengatakan tentang rencana tersebut, tetapi, mungkin, dukungan lebih lanjut untuk solusi NoSQL (seperti "Clickhouse") akan terus berlanjut. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Secara umum, ternyata Anda benar-benar dapat menyingkirkan postgres? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AH:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Tentu saja, bagian yang paling sulit di Zabbix adalah tabel sejarah, yang menciptakan banyak masalah, dan peristiwa. Dalam hal ini, jika Anda tidak menyimpan acara untuk waktu yang lama dan menyimpan sejarah dengan tren di beberapa penyimpanan cepat lainnya, maka, secara umum, tidak akan ada masalah. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Bisakah Anda menilai seberapa cepat semuanya akan bekerja jika Anda pergi ke Clickhouse, misalnya? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AG:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya tidak menguji. Saya pikir setidaknya angka yang sama dapat dicapai dengan cukup sederhana, mengingat "Clickhouse" memiliki antarmuka sendiri, tetapi saya tidak bisa mengatakannya dengan pasti. Lebih baik diuji. Itu semua tergantung pada konfigurasi: berapa banyak host yang Anda miliki dan sebagainya. Sisipan adalah satu hal, tetapi Anda masih perlu mengambil data ini - Grafana atau yang lainnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Artinya, kita berbicara tentang pertarungan yang setara, dan bukan tentang keuntungan besar dari database cepat ini? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AG:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya pikir ketika kami berintegrasi, akan ada tes yang lebih akurat. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Kemana perginya RRD tua yang baik? </font><font style="vertical-align: inherit;">Apa yang membuat Anda beralih ke database SQL? </font><font style="vertical-align: inherit;">Awalnya, pada RRD, semua metrik dikumpulkan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AG:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dalam RRD "Zabbix", mungkin itu dalam versi yang sangat kuno. </font><font style="vertical-align: inherit;">Selalu ada database SQL - pendekatan klasik. </font><font style="vertical-align: inherit;">Pendekatan klasiknya adalah MySQL, PostgreSQL (sudah ada sejak lama). </font><font style="vertical-align: inherit;">Kami memiliki antarmuka umum untuk database SQL dan RRD, kami hampir tidak pernah menggunakannya.</font></font><br><br><img src="https://habrastorage.org/webt/a4/oi/25/a4oi25ls8s9shibkxhx1ckuxfqk.jpeg"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/umRk94j5M8o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Sedikit iklan :) </h3><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikan kepada teman Anda, <a href="https://ua-hosting.company/cloudvps/nl">VPS berbasis cloud untuk pengembang mulai $ 4,99</a> , <b>analog unik dari server entry-level yang diciptakan oleh kami untuk Anda:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Seluruh kebenaran tentang VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps mulai dari $ 19 atau cara membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah di pusat data Equinix Tier IV di Amsterdam?</b>  Hanya kami yang memiliki <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://habr.com/company/ua-hosting/blog/329618/">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485470/">https://habr.com/ru/post/id485470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485458/index.html">Knalpot howitzer</a></li>
<li><a href="../id485460/index.html">20 perpustakaan untuk aplikasi iOS yang spektakuler</a></li>
<li><a href="../id485462/index.html">Kami berurusan dengan eSIM (+ wawancara dengan pakar)</a></li>
<li><a href="../id485464/index.html">Game html5 pertama saya, dari Alice Yandex dan memberikan kemenangan untuk aplikasi seluler</a></li>
<li><a href="../id485468/index.html">Varian bekerja dengan soket web di iOS di Swift / Menulis manajer untuk bekerja dengan websocket</a></li>
<li><a href="../id485472/index.html">Apa yang baru dari AMD?</a></li>
<li><a href="../id485476/index.html">Tren dan perdagangan di bursa: 4 indikator populer untuk analisis teknis</a></li>
<li><a href="../id485480/index.html">Kolom portabel Z-poject Doublebeef - mono ganda dalam bahasa Rusia. Uji, bongkar, dan tingkatkan</a></li>
<li><a href="../id485482/index.html">3 masalah mentransfer data ke Google Analytics melalui Protokol Pengukuran</a></li>
<li><a href="../id485484/index.html">[Case Locomizer] Pengetahuan apa yang sebenarnya bisa diekstraksi dari dataset anonim dengan koordinat pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>