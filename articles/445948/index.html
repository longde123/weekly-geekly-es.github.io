<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèòÔ∏è üíó ü§¶üèΩ Herencia en C ++: principiante, intermedio, avanzado ü¶Ñ üéÆ üèÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo describe la herencia en tres niveles: principiante, intermedio y avanzado. Experto no. Y ni una palabra sobre SOLID. Honestamente 
 Prin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Herencia en C ++: principiante, intermedio, avanzado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p>  Este art√≠culo describe la herencia en tres niveles: principiante, intermedio y avanzado.  Experto no.  Y ni una palabra sobre SOLID.  Honestamente </p><br><h1 id="beginner">  Principiante </h1><br><h3 id="chto-takoe-nasledovanie">  ¬øQu√© es la herencia? </h3><br><p>  La herencia es uno de los principios fundamentales de la POO.  Seg√∫n esto, una clase puede usar las variables y m√©todos de otra clase como propios. </p><br><p>  Una clase que hereda datos se llama una subclase, una clase derivada o una clase secundaria.  La clase de la que se heredan los datos o m√©todos se denomina superclase, clase base o clase primaria.  Los t√©rminos "padre" e "hijo" son extremadamente √∫tiles para comprender la herencia.  Cuando un ni√±o recibe las caracter√≠sticas de sus padres, la clase derivada recibe los m√©todos y variables de la clase base. </p><br><p>  La herencia es √∫til porque le permite estructurar y reutilizar el c√≥digo, que a su vez <a name="habracut"></a>  puede acelerar significativamente el proceso de desarrollo.  A pesar de esto, la herencia debe usarse con precauci√≥n, ya que la mayor√≠a de los cambios en la superclase afectar√°n a todas las subclases, lo que puede conducir a consecuencias imprevistas. </p><br><p> En este ejemplo, el m√©todo <code>turn_on()</code> y la variable <code>serial_number</code> no se declararon ni definieron en la subclase <code>Computer</code> .  Sin embargo, se pueden usar porque se heredan de la clase base. </p><br><p>  <em>Nota importante</em> : Las variables y m√©todos privados no se pueden heredar. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Tipos de herencia </h3><br><p>  Hay varios tipos de herencia en C ++: </p><br><ul><li>  public: los datos p√∫blicos ( <code>public</code> ) y protegidos ( <code>protected</code> ) se heredan sin cambiar el nivel de acceso a ellos; </li><li>  protegido ( <code>protected</code> ): todos los datos heredados quedan protegidos; </li><li>  privado: todos los datos heredados se vuelven privados. </li></ul><br><p>  Para la clase base <code>Device</code> , el nivel de acceso a datos no cambia, pero dado que la clase derivada de <code>Computer</code> hereda los datos como privados, los datos se vuelven privados para la clase <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  La clase <code>Computer</code> ahora usa el m√©todo <code>turn_on()</code> como cualquier m√©todo privado: se puede <code>turn_on()</code> desde la clase, pero intentar llamarlo directamente desde <code>main</code> dar√° como resultado un error en el momento de la compilaci√≥n.  Para el <code>Device</code> clase base, el m√©todo <code>turn_on()</code> se <code>turn_on()</code> mantenido p√∫blico y se puede llamar desde <code>main</code> . </p><br><h3 id="konstruktory-i-destruktory">  Constructores y destructores </h3><br><p>  En C ++, los constructores y destructores no se heredan.  Sin embargo, se les llama cuando la clase secundaria inicializa su objeto.  Los constructores se llaman jer√°rquicamente uno tras otro, comenzando con la clase base y terminando con la √∫ltima clase derivada.  Los destructores se llaman en orden inverso. </p><br><p>  <em>Nota importante:</em> este art√≠culo no cubre los destructores virtuales.  Se puede encontrar material adicional sobre este tema, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este art√≠culo sobre Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Constructores: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Destructores: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Herencia m√∫ltiple </h3><br><p>  La herencia m√∫ltiple ocurre cuando una subclase tiene dos o m√°s superclases.  En este ejemplo, la clase <code>Laptop</code> hereda tanto <code>Monitor</code> como <code>Computer</code> al mismo tiempo. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  M√∫ltiples problemas de herencia </h3><br><p>  La herencia m√∫ltiple requiere un dise√±o cuidadoso, ya que puede conducir a consecuencias imprevistas.  La mayor√≠a de estas consecuencias son causadas por la ambig√ºedad en la herencia.  En este ejemplo, <code>Laptop</code> hereda el m√©todo <code>turn_on()</code> de ambos padres y no est√° claro qu√© m√©todo deber√≠a llamarse. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  A pesar de que los datos privados no se heredan, es imposible resolver la herencia ambigua cambiando el nivel de acceso a los datos a privados.  Al compilar, primero se realiza una b√∫squeda de un m√©todo o variable, y luego se verifica el nivel de acceso a ellos. </p><br><h1 id="intermediate">  Intermedio </h1><br><h3 id="problema-romba">  Problema rombo </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  El problema del diamante es un problema cl√°sico en idiomas que admiten herencia m√∫ltiple.  Este problema ocurre cuando las clases <code>B</code> y <code>C</code> heredan <code>A</code> , y la clase <code>D</code> hereda <code>B</code> y <code>C</code> </p><br><p>  Por ejemplo, las clases <code>A</code> , <code>B</code> y <code>C</code> definen el m√©todo <code>print_letter()</code> .  Si la clase <code>D</code> llamar√° a <code>print_letter()</code> , no est√° claro qu√© m√©todo deber√≠a llamarse: un m√©todo de clase <code>A</code> , <code>B</code> o <code>C</code>  Diferentes idiomas tienen diferentes enfoques para resolver problemas en forma de diamante.  En C ++, la soluci√≥n al problema se deja al programador. <br><br clear="all">  El problema en forma de diamante es principalmente un problema de dise√±o, y debe proporcionarse en la etapa de dise√±o.  En la etapa de desarrollo, se puede resolver de la siguiente manera: </p><br><ul><li>  llamar al m√©todo de una superclase espec√≠fica; </li><li>  referirse al objeto de la subclase como un objeto de una superclase particular; </li><li>  anular el m√©todo problem√°tico en la √∫ltima clase secundaria (en el c√≥digo, <code>turn_on()</code> en la subclase <code>Laptop</code> ). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Si el m√©todo <code>turn_on()</code> no se ha anulado en Laptop, llamar a <code>Laptop_instance.turn_on()</code> generar√° un error de compilaci√≥n.  Un objeto <code>Laptop</code> puede acceder a dos <code>turn_on()</code> m√©todo <code>turn_on()</code> simult√°neamente: <code>Device:Computer:Laptop.turn_on()</code> y <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  El problema del diamante: constructores y destructores </h3><br><p>  Como en C ++, cuando se inicializa un objeto de una clase secundaria, se llama a los constructores de todas las clases primarias, surge otro problema: el constructor de la clase base <code>Device</code> se llamar√° dos veces. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Herencia virtual </h3><br><p>  La herencia virtual evita que aparezcan m√∫ltiples objetos de clase base en la jerarqu√≠a de herencia.  Por lo tanto, el constructor de la clase base <code>Device</code> se llamar√° solo una vez, y una llamada al m√©todo <code>turn_on()</code> sin <code>turn_on()</code> en la clase secundaria no causar√° un error de compilaci√≥n. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Nota</em> : la herencia virtual en las clases <code>Computer</code> y <code>Monitor</code> no permitir√° la herencia romboidal si la clase secundaria <code>Laptop</code> no hereda virtualmente la clase <code>Device</code> ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Clase abstracta </h3><br><p>  En C ++, una clase en la que existe al menos un m√©todo virtual puro se considera abstracta.  Si el m√©todo virtual no se anula en la clase secundaria, el c√≥digo no se compilar√°.  Adem√°s, en C ++ es imposible crear un objeto de una clase abstracta; un intento tambi√©n causar√° un error durante la compilaci√≥n. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Interfaz </h3><br><p>  C ++, a diferencia de algunos lenguajes OOP, no proporciona una palabra clave separada para denotar una interfaz.  Sin embargo, la implementaci√≥n de la interfaz es posible creando una clase abstracta pura, una clase en la que solo hay declaraciones de m√©todos.  Dichas clases tambi√©n se denominan a menudo Clase base abstracta (ABC). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Avanzado </h1><br><p>  Aunque la herencia es un principio fundamental de la POO, debe usarse con precauci√≥n.  Es importante pensar que cualquier c√≥digo que se utilizar√° es probable que se modifique y se pueda usar de una manera que no sea obvia para el desarrollador. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Herencia de una clase implementada o parcialmente implementada </h3><br><p>  Si la herencia no proviene de una interfaz (una clase abstracta pura en el contexto de C ++), sino de una clase en la que hay implementaciones, vale la pena considerar que el heredero est√° conectado a la clase padre por la conexi√≥n m√°s cercana posible.  La mayor√≠a de los cambios en la clase principal pueden afectar al heredero, lo que puede conducir a un comportamiento inesperado.  Tales cambios en el comportamiento del heredero no siempre son obvios: puede producirse un error en el c√≥digo ya probado y en funcionamiento.  Esta situaci√≥n se ve exacerbada por la presencia de una compleja jerarqu√≠a de clases.  Siempre vale la pena recordar que el c√≥digo puede ser cambiado no solo por la persona que lo escribi√≥, y sus colegas no pueden tener en cuenta las rutas de herencia obvias para el autor. </p><br><p>  Por el contrario, vale la pena se√±alar que la herencia de clases implementadas parcialmente tiene una ventaja innegable.  Las bibliotecas y los marcos a menudo funcionan de la siguiente manera: proporcionan al usuario una clase abstracta con varios m√©todos virtuales y muchos implementados.  Por lo tanto, la mayor cantidad de trabajo ya se ha realizado: la l√≥gica compleja ya se ha escrito y el usuario solo puede personalizar la soluci√≥n preparada para satisfacer sus necesidades. </p><br><h3 id="interfeys-1">  Interfaz </h3><br><p>  La herencia de una interfaz (clase abstracta pura) presenta la herencia como una oportunidad para estructurar el c√≥digo y proteger al usuario.  Dado que la interfaz describe qu√© trabajo realizar√° la clase de implementaci√≥n, pero no describe c√≥mo, cualquier usuario de la interfaz est√° protegido de los cambios en la clase que implementa esta interfaz. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Interfaz: ejemplo de uso </h3><br><p>  En primer lugar, vale la pena se√±alar que el ejemplo est√° estrechamente relacionado con el concepto de polimorfismo, pero se considerar√° en el contexto de la herencia de una clase abstracta pura. </p><br><p>  Una aplicaci√≥n que ejecuta l√≥gica de negocio abstracta debe configurarse desde un archivo de configuraci√≥n separado.  En una etapa temprana de desarrollo, el formato de este archivo de configuraci√≥n no estaba completamente formado.  Pasar el an√°lisis de archivos detr√°s de una interfaz ofrece varias ventajas. </p><br><p>  La falta de claridad con respecto al formato del archivo de configuraci√≥n no ralentiza el proceso de desarrollo del programa principal.  Dos desarrolladores pueden trabajar en paralelo: uno en la l√≥gica de negocios y el otro en el analizador.  Como interact√∫an a trav√©s de esta interfaz, cada uno de ellos puede trabajar de forma independiente.  Este enfoque facilita la codificaci√≥n de pruebas unitarias con c√≥digo, ya que las pruebas necesarias se pueden escribir utilizando simulacro para esta interfaz. </p><br><p>  Adem√°s, al cambiar el formato del archivo de configuraci√≥n, la l√≥gica empresarial de la aplicaci√≥n no se ve afectada.  Lo √∫nico que requiere una transici√≥n completa de un formato a otro es escribir una nueva implementaci√≥n de la clase abstracta ya existente (clase parser).  Adem√°s, volver al formato de archivo original requiere un trabajo m√≠nimo: reemplazar un analizador existente por otro. </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  La herencia proporciona muchos beneficios, pero debe dise√±arse cuidadosamente para evitar los problemas para los que presenta una oportunidad.  En el contexto de la herencia, C ++ proporciona una amplia gama de herramientas que abren un mont√≥n de posibilidades para el programador. </p><br><p>  Y SOLID es bueno. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445948/">https://habr.com/ru/post/445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445928/index.html">C√≥mo aumentamos la productividad de servicio de Tensorflow en un 70%</a></li>
<li><a href="../445932/index.html">Seguridad de la aplicaci√≥n del cliente: consejos pr√°cticos para un desarrollador front-end</a></li>
<li><a href="../445936/index.html">Desarrollo de electr√≥nica. Sobre microcontroladores en los dedos</a></li>
<li><a href="../445940/index.html">AMA con Habr, v 7.0. Lim√≥n, Donuts y Noticias</a></li>
<li><a href="../445946/index.html">MWC: instrucciones de uso</a></li>
<li><a href="../445952/index.html">Un trill√≥n de solteros</a></li>
<li><a href="../445954/index.html">Acelerador de IA de HSE, MTS y Rostelecom</a></li>
<li><a href="../445958/index.html">SPDS GraphiCS - sistema de fachadas y cubiertas</a></li>
<li><a href="../445962/index.html">Pr√°cticas en TI: visi√≥n del gerente</a></li>
<li><a href="../445964/index.html">MEPhI organizar√° una olimpiada de seguridad de la informaci√≥n del estudiante: c√≥mo participar y qu√© ofrece</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>