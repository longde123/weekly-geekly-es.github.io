<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚒 ⏲️ 🈁 Semacam Kekacauan 👩🏼 ⛩️ ♊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti yang diperlihatkan oleh praktik, sebagian besar masalah muncul bukan karena solusi itu sendiri, tetapi karena bagaimana komunikasi antara komp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Semacam Kekacauan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442380/"><p> Seperti yang diperlihatkan oleh praktik, sebagian besar masalah muncul bukan karena solusi itu sendiri, tetapi karena bagaimana komunikasi antara komponen-komponen sistem terjadi.  Jika ada kekacauan dalam komunikasi antara komponen-komponen sistem, maka, karena Anda tidak mencoba menulis masing-masing komponen dengan baik, sistem secara keseluruhan akan gagal. </p><br><p>  Perhatian  Di dalam sepeda. </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi">  Masalah atau pernyataan masalah </h1><br><p>  Beberapa waktu yang lalu, kebetulan bekerja pada sebuah proyek untuk sebuah perusahaan yang membawa ke massa seperti CRM, sistem ERM dan turunannya.  Selain itu, perusahaan mengeluarkan produk yang agak komprehensif dari perangkat lunak untuk register kas ke call-center dengan kemungkinan menyewa operator dalam jumlah hingga 200 jiwa. </p><br><p>  Saya sendiri mengerjakan aplikasi front-end untuk call-center. </p><br><p>  Mudah dibayangkan bahwa informasi dari semua komponen sistem yang mengalir ke aplikasi operator.  Dan jika kita memperhitungkan fakta bahwa itu bukan operator tunggal, tetapi juga manajer dan administrator, maka Anda dapat membayangkan berapa banyak komunikasi dan informasi yang harus "dicerna" aplikasi dan saling berhubungan satu sama lain. </p><br><p>  Ketika proyek sudah diluncurkan dan bahkan bekerja cukup stabil untuk dirinya sendiri, masalah transparansi sistem muncul dalam semua pertumbuhannya. </p><br><p>  Ini intinya.  Ada banyak komponen dan mereka semua bekerja dengan sumber data mereka.  Tetapi hampir semua komponen ini pernah ditulis sebagai produk mandiri.  Artinya, bukan sebagai elemen dari sistem keseluruhan, tetapi sebagai keputusan terpisah untuk dijual.  Akibatnya, tidak ada API (sistem) tunggal dan tidak ada standar komunikasi umum di antara mereka. </p><br><p>  Saya akan jelaskan.  Beberapa komponen mengirim JSON, “seseorang” mengirim baris dengan kunci: nilai di dalam, “seseorang” mengirim biner secara umum dan melakukan apa pun yang Anda inginkan dengannya.  Tapi, dan aplikasi terakhir untuk call-center harus mendapatkan semuanya dan memprosesnya entah bagaimana.  Yah dan yang paling penting, tidak ada tautan dalam sistem yang dapat mengenali bahwa format / struktur data telah berubah.  Jika beberapa komponen mengirim JSON kemarin, dan hari ini memutuskan untuk mengirim biner - tidak ada yang akan melihat ini.  Hanya aplikasi terakhir yang akan mulai macet seperti yang diharapkan. </p><br><p>  Segera menjadi jelas (bagi orang-orang di sekitar saya, bukan untuk saya, karena saya berbicara tentang masalah pada tahap desain) bahwa tidak adanya "bahasa komunikasi terpadu" antara komponen menyebabkan masalah serius. </p><br><p>  Kasus paling sederhana adalah ketika klien diminta untuk mengubah beberapa dataset.  Mereka menulis tugas kepada pemuda yang “memegang” komponen untuk bekerja dengan basis data barang / jasa, misalnya.  Dia melakukan pekerjaannya, mengimplementasikan dataset baru, dan baginya, brengsek, semuanya bekerja.  Tapi, sehari setelah pembaruan ... oh ... aplikasi di pusat panggilan tiba-tiba mulai berfungsi tidak seperti yang mereka harapkan darinya. </p><br><p>  Anda mungkin sudah menebak.  Pahlawan kami tidak hanya mengubah dataset, tetapi juga struktur data yang dikirim komponennya ke sistem.  Akibatnya, aplikasi call-center sama sekali tidak dapat bekerja dengan komponen ini, dan ada dependensi lain terbang di sepanjang rantai. </p><br><p>  Mereka mulai berpikir tentang apa yang sebenarnya ingin kami dapatkan di jalan keluar.  Sebagai hasilnya, kami merumuskan persyaratan berikut untuk solusi potensial: </p><br><p>  <strong>Pertama</strong> dan terpenting: setiap perubahan dalam struktur data harus segera "disorot" dalam sistem.  Jika seseorang telah membuat perubahan di suatu tempat dan perubahan ini tidak sesuai dengan apa yang diharapkan sistem, kesalahan harus terjadi pada tahap pengujian komponen, yang telah diubah. </p><br><p>  <strong>Yang kedua</strong> .  Tipe data harus diperiksa tidak hanya selama kompilasi, tetapi juga saat dijalankan. </p><br><p>  <strong>Yang ketiga</strong> .  Karena sejumlah besar orang dengan tingkat keterampilan yang sangat berbeda bekerja pada komponen, bahasa deskripsi harus lebih sederhana. </p><br><p>  <strong>Keempat</strong> .  Apa pun solusinya, harus senyaman mungkin untuk bekerja dengannya.  Jika memungkinkan, IDE harus menyoroti sebanyak mungkin. </p><br><p>  Pikiran pertama adalah menerapkan protobuf.  Sederhana, mudah dibaca dan mudah.  Pengetikan data yang ketat.  Sepertinya itu yang diperintahkan dokter.  Namun sayang, tidak semua sintaksis protobuf tampak sederhana.  Selain itu, bahkan protokol yang dikompilasi memerlukan perpustakaan tambahan, tetapi Javascript tidak didukung oleh protobuf dan merupakan hasil kerja komunitas.  Secara umum, mereka menolak. </p><br><p>  Kemudian muncul ide untuk menggambarkan protokol di JSON.  Nah, seberapa mudah? </p><br><p>  Baiklah, lalu saya berhenti.  Dan dalam hal ini pos ini bisa diselesaikan, karena setelah kepergian saya tidak ada orang lain yang mulai berurusan dengan masalah tersebut. </p><br><p>  Namun, mengingat beberapa proyek pribadi di mana masalah komunikasi antar komponen kembali ke potensi penuh, saya memutuskan untuk mulai menerapkan ide sendiri.  Apa yang akan dibahas di bawah ini. </p><br><p>  Jadi, saya sajikan kepada Anda proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres</a> , yang meliputi: </p><br><ul><li>  generator protokol </li><li>  penyedia </li><li>  klien </li><li>  implementasi transportasi </li></ul><br><h1 id="protokol">  Protokol </h1><br><p>  Tugasnya adalah membuatnya: </p><br><ul><li>  mudah untuk mengatur struktur pesan dalam sistem. </li><li>  mudah untuk menentukan tipe data dari semua bidang pesan. </li><li>  adalah mungkin untuk mendefinisikan entitas bantu dan merujuknya. </li><li>  dan tentu saja, agar semua ini disorot oleh IDE </li></ul><br><p>  Saya berpikir bahwa dengan cara yang sepenuhnya alami, sebagai bahasa di mana protokol dikonversi, Typecript dipilih bukan Javascript murni.  Yaitu, yang dilakukan oleh generator protokol adalah mengubah JSON menjadi Typefon. </p><br><p>  Untuk menggambarkan pesan yang tersedia di sistem, Anda hanya perlu tahu apa itu JSON.  Dengan itu, saya yakin tidak ada yang punya masalah. </p><br><p>  Alih-alih Hello World, saya menawarkan contoh yang tidak kurang basi - obrolan. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Semuanya sangat sederhana.  Kami memiliki beberapa acara NewMessage dan UsersListUpdated;  serta beberapa permintaan UsersList dan AddUserResult.  Ada dua entitas lagi: ChatMessage dan Pengguna. </p><br><p>  Seperti yang Anda lihat, uraiannya cukup transparan dan dapat dimengerti.  Sedikit tentang aturannya. </p><br><ul><li>  Objek di JSON akan menjadi kelas dalam protokol yang dibuat </li><li>  Nilai properti adalah definisi tipe data atau referensi ke kelas (entitas) </li><li>  Objek bersarang dari sudut pandang protokol yang dihasilkan akan menjadi kelas "bersarang", yaitu, objek bersarang akan mewarisi semua properti orang tua mereka. </li></ul><br><p>  Sekarang yang perlu Anda lakukan adalah membuat protokol untuk mulai menggunakannya. </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p>  Sebagai hasilnya, kita mendapatkan protokol yang dihasilkan oleh Scripteks.  Kami terhubung dan menggunakan: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="gambar"><br><p>  Jadi, protokol sudah memberikan sesuatu kepada pengembang: </p><br><ul><li>  IDE menyoroti apa yang kita miliki dalam protokol.  IDE juga menyoroti semua properti yang diharapkan. </li><li>  Naskah, yang pasti akan memberi tahu kami jika ada sesuatu yang salah dengan tipe data.  Tentu saja, ini dilakukan pada tahap pengembangan, tetapi protokol itu sendiri sudah akan menjalankan-waktu memeriksa tipe data dan melemparkan pengecualian jika pelanggaran terdeteksi </li><li>  Secara umum, Anda bisa melupakan validasi.  Protokol akan melakukan semua pemeriksaan yang diperlukan. </li><li>  Protokol yang dihasilkan tidak memerlukan pustaka tambahan.  Semua yang dia butuhkan untuk bekerja, dia sudah mengandung.  Dan itu sangat nyaman. </li></ul><br><blockquote>  Ya, ukuran protokol yang dihasilkan mungkin mengejutkan Anda, untuk sedikitnya.  Tapi, jangan lupa tentang minifikasi, yang file protokol yang dihasilkan cocok dengan baik. </blockquote><p>  Sekarang kita dapat "mengepak" pesan dan mengirim </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p>  Penting untuk melakukan reservasi di sini, paket akan menjadi array byte, yang sangat baik dan benar dari sudut pandang beban lalu lintas, karena mengirim JSON "biaya" yang sama, tentu saja, lebih mahal.  Namun, protokol memiliki satu fitur - dalam mode debug akan menghasilkan JSON yang dapat dibaca sehingga pengembang dapat "melihat" lalu lintas dan melihat apa yang terjadi. </p><br><p>  Ini dilakukan langsung saat run-time. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p>  Di server (atau penerima lainnya), kami dapat dengan mudah membongkar pesan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p>  Protokol mendukung semua tipe data utama: </p><br><table><thead><tr><th>  Jenis </th><th>  Nilai-nilai </th><th>  Deskripsi </th><th>  Ukuran, byte </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  String yang dikodekan UTF8 </td><td>  x </td></tr><tr><td>  asciiString </td><td></td><td>  string ascii </td><td>  1 karakter - 1 byte </td></tr><tr><td>  int8 </td><td>  -128 hingga 127 </td><td></td><td>  1 </td></tr><tr><td>  int16 </td><td>  -32768 hingga 32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648 hingga 2147483647 </td><td></td><td>  4 </td></tr><tr><td>  uint8 </td><td>  0 hingga 255 </td><td></td><td>  1 </td></tr><tr><td>  uint16 </td><td>  0 hingga 65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0 hingga 4294967295 </td><td></td><td>  4 </td></tr><tr><td>  float32 </td><td>  1.2x10 <sup>-38</sup> hingga 3.4x10 <sup>38</sup> </td><td></td><td>  4 </td></tr><tr><td>  float64 </td><td>  5.0x10 <sup>-324</sup> hingga 1.8x10 <sup>308</sup> </td><td></td><td>  8 </td></tr><tr><td>  boolean </td><td></td><td></td><td>  1 </td></tr></tbody></table><br><p>  Dalam protokol, tipe data ini disebut primitif.  Namun, fitur lain dari protokol ini adalah Anda dapat menambahkan tipe data Anda sendiri (disebut "tipe data tambahan"). </p><br><p>  Misalnya, Anda mungkin sudah memperhatikan bahwa <strong>ChatMessage</strong> memiliki bidang yang <strong>dibuat</strong> dengan tipe data <strong>datetime</strong> .  Pada tingkat aplikasi - jenis ini sesuai dengan <strong>Tanggal</strong> , dan di dalam protokol disimpan (dan dikirim) sebagai <strong>uint32</strong> . </p><br><p>  Menambahkan tipe Anda ke protokol cukup sederhana.  Misalnya, jika kita ingin memiliki tipe data <strong>email</strong> , katakan untuk pesan berikut dalam protokol: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Yang perlu Anda lakukan adalah menulis definisi untuk jenis email. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p>  Itu saja.  Dengan membuat protokol, kami mendapatkan dukungan untuk tipe data <strong>email</strong> baru.  Saat kami mencoba membuat entitas dengan alamat yang salah, kami mendapatkan kesalahan </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p>  Oh ... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p>  Jadi, protokol tidak memungkinkan data "buruk" masuk ke sistem. </p><br><p>  Harap perhatikan, saat mendefinisikan tipe data baru, kami menetapkan beberapa properti utama: </p><br><ul><li>  <strong>binaryType</strong> - referensi ke tipe data primitif yang harus digunakan untuk menyimpan, menyandikan / mendekode data.  Dalam kasus ini, kami menunjukkan bahwa alamat tersebut adalah string ascii. </li><li>  <strong>tsType</strong> adalah referensi ke tipe Javascript, yaitu, bagaimana tipe data harus diwakili dalam lingkungan Javascript.  Dalam hal ini kita berbicara tentang <strong>string</strong> </li><li>  Perlu juga dicatat bahwa kita perlu mendefinisikan tipe data baru hanya pada saat menghasilkan protokol.  Pada output, kami mendapatkan protokol yang dihasilkan yang sudah berisi tipe data baru. </li></ul><br><blockquote>  Anda dapat melihat informasi terperinci tentang semua fitur protokol di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.protocol</a> . </blockquote><br><h1 id="provayder-i-klient">  Penyedia dan pelanggan </h1><br><p>  Pada umumnya, protokol itu sendiri dapat digunakan untuk mengatur komunikasi.  Namun, jika kita berbicara tentang browser dan nodejs, maka penyedia dan klien tersedia. </p><br><h2 id="klient">  Pelanggan </h2><br><h3 id="sozdanie">  Ciptaan </h3><br><p>  Untuk membuat klien, Anda perlu klien dan transportasi. </p><br><p>  Instalasi </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p>  Ciptaan </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote>  Klien, serta penyedia, dirancang khusus untuk protokol.  Artinya, mereka hanya akan bekerja dengan protokol (ceres.protocol). </blockquote><br><h3 id="sobytiya">  Acara </h3><br><p>  Setelah klien dibuat, pengembang dapat berlangganan acara </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Harap dicatat bahwa klien akan memanggil event handler hanya jika data pesan sepenuhnya benar.  Dengan kata lain, aplikasi kita dilindungi terhadap data yang tidak benar dan pengendali event <strong>NewMessage</strong> akan selalu dipanggil dengan instance dari <strong>Protokol</strong> . <strong>Acara.NewMessage</strong> sebagai argumen. </p><br><p>  Secara alami, klien dapat menghasilkan acara. </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Perhatikan bahwa kami tidak menentukan nama acara di mana pun, kami cukup menggunakan tautan ke kelas dari protokol, atau meneruskan turunannya. </p><br><p>  Kami juga dapat mengirim pesan ke grup penerima terbatas dengan menetapkan objek tipe sederhana <code>{ [key: string]: string }</code> sebagai argumen kedua.  Di dalam ceres, objek ini disebut <strong>kueri</strong> . </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Dengan demikian, dengan tambahan menunjukkan <code>{ location: "UK" }</code> , kami dapat memastikan bahwa hanya pelanggan yang telah mengidentifikasi posisi mereka sebagai Inggris akan menerima pesan ini. </p><br><p>  Untuk mengaitkan klien itu sendiri dengan <strong>permintaan</strong> tertentu, Anda hanya perlu memanggil metode referensi: </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p>  Setelah kami menghubungkan klien dengan <strong>permintaan</strong> , ia memiliki kesempatan untuk menerima pesan "pribadi" atau "grup". </p><br><h3 id="zaprosy">  Pertanyaan </h3><br><p>  Kami juga dapat membuat permintaan </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Patut diperhatikan bahwa sebagai argumen kedua kami menentukan hasil yang diharapkan ( <strong>Protocol.Responses.UsersList</strong> ), yang berarti bahwa permintaan kami akan berhasil diselesaikan hanya jika responsnya adalah instance dari <strong>UsersList</strong> , dalam semua kasus lain kami akan "jatuh" ke menangkap  Sekali lagi, ini memastikan kita dari memproses data yang salah. </p><br><p>  Klien sendiri juga dapat berbicara dengan mereka yang dapat memproses permintaan.  Untuk melakukan ini, Anda hanya perlu "mengidentifikasi" diri Anda sebagai "bertanggung jawab" untuk permintaan tersebut. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Catatan, secara opsional, sebagai argumen ketiga, kita dapat menentukan objek <strong>permintaan</strong> yang dapat digunakan untuk mengidentifikasi klien.  Dengan demikian, jika seseorang mengirim kueri dengan <strong>kueri</strong> , katakanlah, <code>{ location: "RU" }</code> , maka klien kami tidak akan menerima permintaan seperti itu, karena kueri <code>{ location: "UK" }</code> . </p><br><p>  <strong>Kueri</strong> dapat menyertakan jumlah properti yang tidak terbatas.  Misalnya, Anda dapat menentukan yang berikut ini </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p>  Kemudian, selain pencocokan <strong>kueri</strong> lengkap, kami juga akan berhasil memproses kueri berikut: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p>  atau </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder">  Penyedia </h2><br><h3 id="sozdanie-1">  Ciptaan </h3><br><p>  Untuk membuat penyedia (juga untuk membuat klien), Anda memerlukan penyedia dan transportasi. </p><br><p>  Instalasi </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p>  Ciptaan </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p>  Dari saat penyedia dibuat, ia dapat menerima koneksi dari klien. </p><br><h3 id="sobytiya-1">  Acara </h3><br><p>  Seperti halnya klien, penyedia dapat "mendengarkan" pesan dan menghasilkannya. </p><br><p>  Mendengarkan </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p>  Hasilkan </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1">  Pertanyaan </h3><br><p>  Secara alami, penyedia dapat (dan harus) "mendengarkan" permintaan </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Hanya ada satu perbedaan dari klien, penyedia selain badan permintaan akan menerima <strong>clientId</strong> unik, yang ditugaskan secara otomatis ke semua klien yang terhubung. </p><br><h1 id="primer">  Contoh </h1><br><p>  Bahkan, saya benar-benar tidak ingin membuat Anda bosan dengan kutipan dari dokumentasi, saya yakin akan lebih mudah dan lebih menarik bagi Anda untuk hanya melihat sepotong kode pendek. </p><br><p>  Anda dapat dengan mudah menginstal contoh obrolan dengan mengunduh <a href="">sumber</a> dan melakukan beberapa tindakan sederhana </p><br><p>  Instalasi dan peluncuran klien </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p>  Klien akan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 3000</a> .  Buka segera beberapa tab dengan klien untuk melihat "komunikasi". </p><br><p>  Instalasi dan peluncuran penyedia (server) </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p>  Saya yakin Anda terbiasa dengan paket <strong>ts-node</strong> , tetapi jika tidak, ini memungkinkan Anda untuk menjalankan file TS.  Jika Anda tidak ingin menginstal, cukup kompilasi server, dan kemudian jalankan file JS. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat">  Apa?  Lagi ?! </h1><br><p>  Mengantisipasi pertanyaan tentang mengapa harus menciptakan sepeda lain, karena ada begitu banyak solusi yang telah dikerjakan, dari protobuf hingga hardcore joynr dari BMW, saya hanya dapat mengatakan bahwa itu menarik bagi saya.  Seluruh proyek dilakukan semata-mata atas inisiatif pribadi tanpa dukungan, di waktu luang saya dari pekerjaan. </p><br><p>  Itulah sebabnya umpan balik Anda <strong>sangat berharga</strong> bagi saya.  Dalam upaya memotivasi Anda, saya bisa berjanji bahwa untuk setiap bintang di github, saya akan membelai hamster (yang, secara halus, saya tidak suka).  Untuk garpu, uhhh, aku akan menggaruk pussiko-nya ... brrrr. </p><br><p>  <em>Hamster bukan milikku, hamster putra</em> . </p><br><p>  Selain itu, dalam beberapa minggu proyek ini akan diuji untuk mantan kolega saya (yang saya sebutkan di awal posting dan yang tertarik pada apa versi alfa itu).  Tujuannya adalah debugging dan berjalan pada banyak komponen.  Saya sangat berharap ini berhasil. </p><br><h1 id="ssylki-i-pakety">  Tautan dan paket </h1><br><p>  Proyek ini diselenggarakan oleh dua repositori </p><br><ul><li>  sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres</a> : ceres.provider, ceres.consumer dan semua transportasi yang tersedia saat ini. </li><li>  sumber generator protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.protocol</a> </li></ul><br><p>  Paket-paket NPM berikut tersedia </p><br><ul><li>  generator protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.protocol</a> </li><li>  penyedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.provider</a> </li><li>  pelanggan konsumen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.provider.node.longpoll</a> transport untuk penyedia berdasarkan polling panjang </li><li>  <a href="">ceres.provider.node.ws</a> transport untuk penyedia yang berbasis Web Socket </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceres.consumer.browser.longpoll</a> transport untuk klien berdasarkan polling panjang </li><li>  <a href="">ceres.consumer.browser.ws</a> transport untuk klien berdasarkan Web Socket </li></ul><br><p>  Bagus dan ringan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442380/">https://habr.com/ru/post/id442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442370/index.html">Pemuatan Malas Modul Fitur dari folder "node_modules"</a></li>
<li><a href="../id442372/index.html">Pemrograman yang andal dalam konteks bahasa. Bagian 2 - Penantang</a></li>
<li><a href="../id442374/index.html">Pengembangan boost converter pada DSP: prinsip operasi, perhitungan, pembuatan prototipe</a></li>
<li><a href="../id442376/index.html">Kepadatan plot eceran</a></li>
<li><a href="../id442378/index.html">Satu klik pada antarmuka Pemesanan com dapat merusak liburan atau mengapa sistem peringkat kerja penting</a></li>
<li><a href="../id442384/index.html">Memperluas fungsi sistem audio standar</a></li>
<li><a href="../id442386/index.html">Thymeleaf: Tata Letak Dialek + Spring Boot 2</a></li>
<li><a href="../id442392/index.html">Log NodeJS dibuat benar</a></li>
<li><a href="../id442396/index.html">Acara digital di Moskow dari 04 Maret hingga 10 Maret</a></li>
<li><a href="../id442402/index.html">Paling penting. Integrasi dengan layanan eksternal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>