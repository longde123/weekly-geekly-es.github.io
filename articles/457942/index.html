<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÑ üóìÔ∏è ‚≠êÔ∏è Lo que aprend√≠ sobre la optimizaci√≥n en Python üë∂üèª ‚úèÔ∏è üë©üèΩ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos Hoy queremos compartir otra traducci√≥n preparada en la v√≠spera del lanzamiento del curso Python Developer . Vamos! 



 Us√© Python con m√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que aprend√≠ sobre la optimizaci√≥n en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/">  Hola a todos  Hoy queremos compartir otra traducci√≥n preparada en la v√≠spera del lanzamiento del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python Developer</a> .  Vamos! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  Us√© Python con m√°s frecuencia que cualquier otro lenguaje de programaci√≥n en los √∫ltimos 4-5 a√±os.  Python es el lenguaje predominante para compilaciones bajo Firefox, pruebas y la herramienta CI.  Mercurial tambi√©n se escribe principalmente en Python.  Tambi√©n escrib√≠ muchos de mis proyectos de terceros en √©l. <br><br>  Durante mi trabajo, adquir√≠ un poco de conocimiento sobre el rendimiento de Python y sus herramientas de optimizaci√≥n.  En este art√≠culo, me gustar√≠a compartir este conocimiento. <br><br>  Mi experiencia con Python est√° relacionada principalmente con el int√©rprete de CPython, especialmente CPython 2.7.  No todas mis observaciones son universales para todas las distribuciones de Python, o para aquellas que tienen las mismas caracter√≠sticas en versiones similares de Python.  Tratar√© de mencionar esto durante la narraci√≥n.  Tenga en cuenta que este art√≠culo no es una descripci√≥n detallada del rendimiento de Python.  Solo hablar√© de lo que encontr√© solo. <a name="habracut"></a><br><br><h2>  La carga debido a las peculiaridades de iniciar e importar m√≥dulos </h2><br>  Iniciar el int√©rprete de Python e importar los m√≥dulos es un proceso bastante largo cuando se trata de milisegundos. <br><br>  Si necesita iniciar cientos o miles de procesos de Python en cualquiera de sus proyectos, entonces este retraso en milisegundos se convertir√° en un retraso de hasta varios segundos. <br><br>  Si usa Python para proporcionar herramientas de CLI, la sobrecarga puede causar una congelaci√≥n notable para el usuario.  Si necesita herramientas CLI al instante, ejecutar el int√©rprete de Python con cada llamada har√° que sea m√°s dif√≠cil obtener esta herramienta compleja. <br><br>  Ya escrib√≠ sobre este problema.  Algunas de mis notas anteriores hablan de esto, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en 2014</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en mayo de 2018</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octubre de 2018</a> . <br><br>  No hay muchas cosas que puede hacer para reducir el retraso de inicio: arreglar este caso se refiere a manipular el int√©rprete de Python, ya que es √©l quien controla la ejecuci√≥n del c√≥digo, lo que lleva demasiado tiempo.  Lo mejor que puede hacer es desactivar la importaci√≥n del m√≥dulo del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> en las llamadas para evitar ejecutar c√≥digo Python adicional al inicio.  Por otro lado, muchas aplicaciones usan la funcionalidad del m√≥dulo site.py, por lo que puede usar esto bajo su propio riesgo. <br><br>  Tambi√©n debemos considerar el problema de importar m√≥dulos.  ¬øDe qu√© sirve el int√©rprete de Python si no procesa ning√∫n c√≥digo?  El hecho es que el c√≥digo se pone a disposici√≥n del int√©rprete con mayor frecuencia mediante el uso de m√≥dulos. <br><br>  Para importar m√≥dulos, debe seguir varios pasos.  Y en cada uno de ellos hay una fuente potencial de cargas y retrasos. <br><br>  Se produce un cierto retraso debido a la b√∫squeda de m√≥dulos y la lectura de sus datos.  Como demostr√© con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyOxidizer</a> , al reemplazar la b√∫squeda y la carga de un m√≥dulo de un sistema de archivos con una soluci√≥n arquitect√≥nicamente m√°s simple, que consiste en leer los datos del m√≥dulo de una estructura de datos en la memoria, puede importar la biblioteca Python est√°ndar para el 70-80% del tiempo de soluci√≥n inicial para esta tarea.  Tener un m√≥dulo por archivo del sistema de archivos aumenta la carga en el sistema de archivos y puede ralentizar una aplicaci√≥n Python durante los primeros milisegundos cr√≠ticos de ejecuci√≥n.  Soluciones como PyOxidizer pueden ayudar a evitar esto.  Espero que la comunidad de Python vea estos costos del enfoque actual y est√© considerando la transici√≥n a los mecanismos de distribuci√≥n de los m√≥dulos, que no dependen tanto de los archivos individuales en el m√≥dulo. <br><br>  Otra fuente de costos de importaci√≥n adicionales para un m√≥dulo es la ejecuci√≥n de c√≥digo en ese m√≥dulo durante la importaci√≥n.  Algunos m√≥dulos contienen partes del c√≥digo en un √°rea fuera de las funciones y clases del m√≥dulo, que se ejecuta cuando se importa el m√≥dulo.  La ejecuci√≥n de dicho c√≥digo aumenta el costo de importaci√≥n.  Soluci√≥n alternativa: no ejecute todo el c√≥digo en el momento de la importaci√≥n, solo ejec√∫telo si es necesario.  Python 3.7 es compatible con el m√≥dulo <code>__getattr__</code> , que se llamar√° si no se encuentra el atributo de un m√≥dulo.  Esto se puede usar para llenar perezosamente los atributos del m√≥dulo en el primer acceso. <br><br>  Otra forma de deshacerse de la desaceleraci√≥n de la importaci√≥n es importar perezosamente el m√≥dulo.  En lugar de cargar el m√≥dulo directamente durante la importaci√≥n, registra un m√≥dulo de importaci√≥n personalizado que devuelve un c√≥digo auxiliar.  Cuando accede por primera vez a este c√≥digo auxiliar, cargar√° el m√≥dulo real y "mutar√°" para convertirse en este m√≥dulo. <br><br>  Puede ahorrar decenas de milisegundos con aplicaciones que importan varias decenas de m√≥dulos si omite el sistema de archivos y evita ejecutar partes innecesarias del m√≥dulo (los m√≥dulos generalmente se importan globalmente, pero solo se utilizan ciertas funciones del m√≥dulo). <br><br>  La importaci√≥n diferida de m√≥dulos es algo fr√°gil.  Muchos m√≥dulos tienen plantillas que tienen las siguientes cosas: <code>try: import foo</code> ;  <code>except ImportError:</code>  Un importador de m√≥dulo perezoso nunca puede lanzar un ImportError, porque si lo hace, tendr√° que buscar en el sistema de archivos un m√≥dulo para ver si existe en principio.  Esto agregar√° una carga adicional y aumentar√° el tiempo dedicado, por lo que los importadores perezosos no hacen esto en principio.  Este problema es bastante molesto.  Importador de m√≥dulos diferidos Mercurial procesa una lista de m√≥dulos que no pueden importarse de manera diferida y debe omitirlos.  Otro problema es la sintaxis <code>from foo import x, y</code> , que tambi√©n interrumpe la importaci√≥n del m√≥dulo diferido, en los casos en que foo es un m√≥dulo (a diferencia de un paquete), ya que el m√≥dulo a√∫n debe importarse para devolver una referencia a x e y. <br><br>  PyOxidizer tiene un conjunto fijo de m√≥dulos conectados al binario, por lo que puede ser efectivo para aumentar ImportError.  El m√≥dulo __getattr__ de Python 3.7 proporciona flexibilidad adicional para los importadores de m√≥dulos perezosos.  Espero integrar un importador perezoso confiable en PyOxidizer para automatizar algunos procesos. <br><br>  La mejor soluci√≥n para evitar iniciar el int√©rprete y causar retrasos es iniciar el proceso en segundo plano en Python.  Si inicia el proceso de Python como un proceso de demonio, digamos para un servidor web, entonces puede hacerlo.  La soluci√≥n que ofrece Mercurial es iniciar un proceso en segundo plano que proporcione un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo de servidor de comandos</a> .  hg es el ejecutable C (o ahora Rust), que se conecta a este proceso en segundo plano y env√≠a un comando.  Para encontrar un enfoque para el servidor de comandos, debe hacer mucho trabajo, es extremadamente inestable y tiene problemas de seguridad.  Estoy considerando la idea de entregar un servidor de comandos usando PyOxidizer para que el ejecutable tenga sus ventajas, y el problema del costo de la soluci√≥n de software en s√≠ se resolvi√≥ creando el proyecto PyOxidizer. <br><br><h2>  Retardo de llamada de funci√≥n </h2><br>  Llamar a funciones en Python es un proceso relativamente lento.  (Esta observaci√≥n es menos aplicable a PyPy, que puede ejecutar c√≥digo JIT). <br><br>  Vi docenas de parches para Mercurial, que hicieron posible alinear y combinar el c√≥digo de manera que se evite una carga innecesaria al llamar a las funciones.  En el ciclo de desarrollo actual, se han realizado algunos esfuerzos para reducir el n√∫mero de funciones llamadas al actualizar la barra de progreso.  (Utilizamos barras de progreso para cualquier operaci√≥n que pueda llevar alg√∫n tiempo, de modo que el usuario comprenda lo que est√° sucediendo).  Obtener los resultados de llamadas a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones</a> y evitar b√∫squedas simples entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones</a> ahorra decenas de cientos de milisegundos cuando se ejecuta, cuando hablamos de un mill√≥n de ejecuciones, por ejemplo. <br><br>  Si tiene bucles estrechos o funciones recursivas en Python donde pueden ocurrir cientos de miles o m√°s llamadas a funciones, debe tener en cuenta la sobrecarga de llamar a una funci√≥n individual, ya que esto es de gran importancia.  Tenga en cuenta las funciones integradas simples y la capacidad de combinar funciones para evitar gastos generales. <br><br><h2>  B√∫squeda de atributos sobrecarga </h2><br>  Este problema es similar a la sobrecarga debido a una llamada de funci√≥n, ya que el significado es casi el mismo. <br><br>  Encontrar atributos de resoluci√≥n en Python puede ser lento.  (Y de nuevo, en PyPy, esto es m√°s r√°pido).  Sin embargo, manejar este problema es lo que solemos hacer en Mercurial. <br><br>  Digamos que tiene el siguiente c√≥digo: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  Omita que hay formas m√°s eficientes de escribir este ejemplo (por ejemplo, <code>total = sum(obj.member)</code> ), y tenga en cuenta que el ciclo debe definir obj.member en cada iteraci√≥n.  Python tiene un mecanismo relativamente sofisticado para definir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atributos</a> .  Para tipos simples, puede ser lo suficientemente r√°pido.  Pero para los tipos complejos, este acceso de atributo puede llamar autom√°ticamente a <code>__getattr__</code> , <code>__getattribute__</code> , varios m√©todos <code>dunder</code> e incluso a <code>@property</code> funciones definidas por el usuario.  Esto es similar a una b√∫squeda r√°pida de un atributo que puede realizar varias llamadas a funciones, lo que conducir√° a una carga adicional.  Y esta carga puede agravarse si usa cosas como <code>obj.member1.member2.member3</code> , etc. <br><br>  Cada definici√≥n de atributo provoca una carga adicional.  Y dado que casi todo en Python es un diccionario, podemos decir que cada b√∫squeda de atributo es una b√∫squeda de diccionario.  A partir de conceptos generales sobre estructuras de datos b√°sicas, sabemos que la b√∫squeda de diccionario no es tan r√°pida como, por ejemplo, la b√∫squeda de √≠ndice.  S√≠, por supuesto, hay algunos trucos en CPython que pueden eliminar la sobrecarga debido a las b√∫squedas en el diccionario.  Pero el tema principal que quiero tocar es que cualquier b√∫squeda de atributos es una posible fuga de rendimiento. <br><br>  Para los bucles ajustados, especialmente aquellos que potencialmente exceden cientos de miles de iteraciones, puede evitar estos gastos generales medibles para encontrar atributos asignando un valor a una variable local.  Veamos el siguiente ejemplo: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  Por supuesto, esto solo se puede hacer de manera segura si no se reemplaza en un ciclo.  Si esto sucede, el iterador mantendr√° un enlace al elemento antiguo y todo puede explotar. <br>  Se puede realizar el mismo truco cuando se llama al m√©todo del objeto.  En cambio <br><br><pre> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  Puedes hacer lo siguiente: <br><br><pre> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  Tambi√©n vale la pena se√±alar que en el caso en que la b√∫squeda de atributos necesita llamar a un m√©todo (como en el ejemplo anterior), Python 3.7 es relativamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s r√°pido</a> que las versiones anteriores.  Pero estoy seguro de que aqu√≠ la carga excesiva est√° conectada, en primer lugar, con la llamada a la funci√≥n, y no con la carga en la b√∫squeda de atributos.  Por lo tanto, todo funcionar√° m√°s r√°pido si abandona la b√∫squeda adicional de atributos. <br><br>  Finalmente, dado que una b√∫squeda de atributos llama a una funci√≥n para esto, se puede decir que la b√∫squeda de atributos generalmente es un problema menor que una carga debido a una llamada de funci√≥n.  Por lo general, para notar cambios significativos en la velocidad, deber√° eliminar muchas b√∫squedas de atributos.  En este caso, tan pronto como d√© acceso a todos los atributos dentro del bucle, puede hablar sobre 10 o 20 atributos solo en el bucle antes de llamar a la funci√≥n.  Y los bucles con tan solo miles o menos de decenas de miles de iteraciones pueden proporcionar r√°pidamente cientos de miles o millones de b√∫squedas de atributos.  ¬°As√≠ que ten cuidado! <br><br><h2>  Carga de objeto </h2><br>  Desde el punto de vista del int√©rprete de Python, todos los valores son objetos.  En CPython, cada elemento es una estructura PyObject.  Cada objeto controlado por el int√©rprete est√° en el mont√≥n y tiene su propia memoria que contiene el recuento de referencia, el tipo de objeto y otros par√°metros.  Cada objeto es eliminado por el recolector de basura.  Esto significa que cada nuevo objeto agrega sobrecarga debido al recuento de referencias, recolecci√≥n de basura, etc.  (Y de nuevo, PyPy puede evitar esta carga innecesaria, ya que es m√°s "cuidadoso" sobre la vida √∫til de los valores a corto plazo). <br><br>  En general, mientras m√°s valores √∫nicos y objetos de Python crees, las cosas m√°s lentas te funcionar√°n. <br><br>  Digamos que iteras sobre una colecci√≥n de un mill√≥n de objetos.  Llama a una funci√≥n para recopilar este objeto en una tupla: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  En este ejemplo, <code>process()</code> devolver√° una tupla de 8 tuplas.  No importa si destruimos el valor de retorno o no: esta tupla requiere crear al menos 9 valores en Python: 1 para la tupla misma y 8 para sus miembros internos.  Bueno, en la vida real podr√≠a haber menos valores si <code>process()</code> devuelve una referencia a un objeto existente.  O, por el contrario, puede haber m√°s si sus tipos no son simples y requieren muchos PyObjects para representar.  Solo quiero decir que bajo el cap√≥ del int√©rprete hay una verdadera combinaci√≥n de objetos para la presentaci√≥n completa de ciertas construcciones. <br><br>  Desde mi propia experiencia, puedo decir que estos gastos generales son relevantes solo para operaciones que proporcionan ganancias de velocidad cuando se implementan en un idioma nativo como C o Rust.  El problema es que el int√©rprete de CPython simplemente no puede ejecutar el c√≥digo de bytes tan r√°pido que la carga adicional debido a la cantidad de objetos es importante.  En cambio, es m√°s probable que reduzca el rendimiento llamando a una funci√≥n, o mediante c√°lculos engorrosos, etc.  antes de que pueda notar la carga adicional debido a los objetos.  Existen, por supuesto, algunas excepciones, a saber, la construcci√≥n de tuplas o diccionarios de varios valores. <br><br>  Como un ejemplo concreto de sobrecarga, puede citar Mercurial con c√≥digo C que analiza estructuras de datos de bajo nivel.  Para una mayor velocidad de an√°lisis, el c√≥digo C ejecuta un orden de magnitud m√°s r√°pido que CPython.  Pero tan pronto como el c√≥digo C crea PyObject para representar el resultado, la velocidad cae varias veces.  En otras palabras, la carga implica crear y administrar elementos de Python para que puedan usarse en el c√≥digo. <br><br>  Una forma de evitar este problema es producir menos elementos en Python.  Si necesita referirse a un solo elemento, inicie la funci√≥n y devu√©lvala, y no una tupla o un diccionario de N elementos.  Sin embargo, ¬°no deje de monitorear la posible carga debido a llamadas a funciones! <br><br>  Si tiene una gran cantidad de c√≥digo que funciona lo suficientemente r√°pido utilizando la API de CPython C, y elementos que deben distribuirse entre diferentes m√≥dulos, no utilice tipos de Python que representen datos diferentes como estructuras C y ya haya compilado c√≥digo para acceder a estas estructuras en lugar de pasar por la API de CPython C.  Al evitar la API de CPython C para acceder a los datos, eliminar√° una gran cantidad de carga adicional. <br><br>  El tratamiento de elementos como datos (en lugar de tener funciones para acceder a todo en una fila) ser√≠a el mejor enfoque para un pitonista.  Otra soluci√≥n para el c√≥digo ya compilado es crear una instancia perezosa de PyObject.  Si crea un tipo personalizado en Python (PyTypeObject) para representar elementos complejos, debe definir los <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">campos</a></i> <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tp_members</a></i> o <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tp_getset</a></i> para crear funciones C personalizadas para buscar el valor del atributo.  Si, por ejemplo, escribe un analizador y sabe que los clientes solo tendr√°n acceso a un subconjunto de los campos analizados, puede crear r√°pidamente un tipo que contenga datos sin procesar, devolver este tipo y llamar a una funci√≥n C para buscar atributos de Python que procesen PyObject.  ¬°Incluso puede retrasar el an√°lisis hasta que se llame a la funci√≥n para ahorrar recursos si el an√°lisis nunca es necesario!  Esta t√©cnica es bastante rara, porque requiere escribir c√≥digo no trivial, pero da un resultado positivo. <br><br><h2>  Determinaci√≥n preliminar del tama√±o de la colecci√≥n. </h2><br>  Esto se aplica a la API de CPython C. <br><br>  Al crear colecciones, como listas o diccionarios, use <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> para completar una nueva colecci√≥n si su tama√±o ya est√° definido en el momento de la creaci√≥n.  Esto predeterminar√° el tama√±o de la colecci√≥n para poder contener un n√∫mero finito de elementos en ella.  Esto ayuda a omitir la comprobaci√≥n de un tama√±o de colecci√≥n suficiente al insertar elementos.  ¬°Al crear una colecci√≥n de miles de art√≠culos, esto le ahorrar√° algunos recursos! <br><br><h2>  Uso de copia cero en la API de C </h2><br>  A la API de Python C realmente le gusta crear copias de objetos en lugar de devolverles referencias.  Por ejemplo, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyBytes_FromStringAndSize ()</a></i> copia <code>char*</code> en la memoria reservada por Python.  Si hace esto para una gran cantidad de valores o grandes datos, entonces podr√≠amos hablar sobre gigabytes de E / S de memoria y la carga asociada en el asignador. <br><br>  Si necesita escribir c√≥digo de alto rendimiento sin una API C, debe familiarizarse con el <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo de b√∫fer</a></i> y los tipos relacionados, como <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> est√° integrado en los tipos de Python y permite a los int√©rpretes emitir el tipo de / a bytes.  Tambi√©n permite que el int√©rprete de c√≥digo C reciba un descriptor <code>void*</code> de cierto tama√±o.  Esto le permite asociar cualquier direcci√≥n en memoria con PyObject.  Muchas funciones que funcionan con datos binarios aceptan de manera transparente cualquier objeto que implemente el <code>buffer protocol</code> .  Y si desea aceptar cualquier objeto que pueda considerarse como bytes, debe usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unidades del formato</a> <code>s*</code> , <code>y*</code> o <code>w*</code> al recibir argumentos de funci√≥n. <br><br>  Usando el <code>buffer protocol</code> , le da al int√©rprete la mejor oportunidad disponible para usar operaciones de <code>zero-copy</code> y rechazar copiar bytes adicionales a la memoria. <br><br>  Mediante el uso de tipos en Python del formulario <code>memoryview</code> , tambi√©n permitir√° que Python acceda a los niveles de memoria por referencia, en lugar de hacer copias. <br><br>  Si tiene gigabytes de c√≥digo que pasan por su programa Python, el uso perspicaz de los tipos de Python que admiten copia cero lo salvar√° de las diferencias de rendimiento.  Una vez not√© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python-zstandard</a> result√≥ ser m√°s r√°pido que cualquier enlace Python LZ4 (aunque deber√≠a ser al rev√©s), ya que us√© demasiado el <code>buffer protocol</code> y evit√© la E / S de memoria excesiva en <code>python-zstandard</code> . <br><br><h2>  Conclusi√≥n </h2><br>  En este art√≠culo, trat√© de hablar sobre algunas de las cosas que aprend√≠ al optimizar mis programas de Python durante varios a√±os.  Repito y digo que no es de ninguna manera una descripci√≥n completa de los m√©todos de mejora del rendimiento de Python.  Admito que probablemente uso Python m√°s exigente que otros, y mis recomendaciones no se pueden aplicar a todos los programas.  <b>De ninguna manera debe corregir masivamente su c√≥digo de Python y eliminar, por ejemplo, la b√∫squeda de atributos despu√©s de leer este art√≠culo</b> .  Como siempre, cuando se trata de la optimizaci√≥n del rendimiento, primero arregle d√≥nde el c√≥digo es especialmente lento.    <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">py-spy</a></i>     Python.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   ‚Äì     PyPy,        .  Python      .    ,     Python  ,     .      ,          ¬´  ¬ª.   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457942/">https://habr.com/ru/post/457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457928/index.html">Clasificaci√≥n profunda para comparar dos im√°genes</a></li>
<li><a href="../457930/index.html">Escritura din√°mica est√°ticamente segura a la Python</a></li>
<li><a href="../457932/index.html">An√°lisis del concurso IDS Bypass en Positive Hack Days 9</a></li>
<li><a href="../457936/index.html">Te invitamos a la primera conferencia de Zabbix en Rusia</a></li>
<li><a href="../457940/index.html">C√≥mo mirar a la contraparte</a></li>
<li><a href="../457946/index.html">10 mejores bibliotecas de JavaScript para visualizar datos en gr√°ficos y tablas</a></li>
<li><a href="../457948/index.html">Juegos de mesa en los que tienes que aplastarte la cabeza</a></li>
<li><a href="../457952/index.html">C√≥mo se dise√±an y fabrican los procesadores: fabricaci√≥n de chips</a></li>
<li><a href="../457954/index.html">Por qu√© Swift puede convertirse en un gran evento en el aprendizaje profundo</a></li>
<li><a href="../457956/index.html">C√≥mo elegir el almacenamiento sin dispararte en el pie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>