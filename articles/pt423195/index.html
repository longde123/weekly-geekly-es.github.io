<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌬️ 👰🏿 🍾 O que há de novo no JPA 2.2 🐺 👩🏿‍🤝‍👩🏾 ☔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Feliz feriado a todos! 

 De repente, aconteceu que o início do segundo grupo "Java Enterprise Developer" coincidiu com o 256º dia do ano. Coincidênci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que há de novo no JPA 2.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Feliz feriado a todos! <br><br>  De repente, aconteceu que o início do segundo grupo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Java Enterprise Developer"</a> coincidiu com o 256º dia do ano.  <s>Coincidência?</s>  <s>Eu acho que não.</s> <br><br>  Bem, compartilhamos o penúltimo interesse: que novidades o JPA 2.2 trouxe - resultados de streaming, conversão aprimorada de datas, novas anotações - apenas alguns exemplos de melhorias úteis. <br><br>  Vamos lá! <br><br>  A Java Persistence API (JPA) é uma especificação Java EE fundamental que é amplamente usada no setor.  Independentemente de você estar desenvolvendo para a plataforma Java EE ou para a estrutura Java alternativa, o JPA é sua escolha para salvar dados.  O JPA 2.1 melhorou a especificação, permitindo que os desenvolvedores resolvessem problemas como geração automática de esquemas de banco de dados e trabalho eficiente com procedimentos armazenados no banco de dados.  A versão mais recente, JPA 2.2, aprimora a especificação com base nessas alterações. <br>  Neste artigo, falarei sobre novas funcionalidades e darei exemplos que ajudarão você a começar.  Como exemplo, eu uso o projeto "Java EE 8 Playground", disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  O aplicativo de amostra é baseado na especificação Java EE 8 e usa as estruturas JavaServer Faces (JSF), Enterprise JavaBeans (EJB) e JPA para persistência.  Você precisa estar familiarizado com o JPA para entender do que se trata. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Usando o JPA 2.2</b> <br><br>  O JPA versão 2.2 faz parte da plataforma Java EE 8. É importante notar que apenas os servidores de aplicativos compatíveis com Java EE 8 fornecem uma especificação pronta para uso imediato.  No momento da redação deste texto (final de 2017), havia muitos servidores de aplicativos.  No entanto, é fácil usar o JPA 2.2 com Java EE7.  Primeiro, você precisa baixar os arquivos JAR apropriados usando o <a href="">Maven Central</a> e adicioná-los ao projeto.  Se você estiver usando o Maven em seu projeto, adicione as coordenadas ao arquivo POM do Maven: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Em seguida, selecione a implementação JPA que você deseja usar.  A partir do JPA 2.2, o EclipseLink e o Hibernate têm implementações compatíveis.  Como exemplos neste artigo, eu uso o <a href="">EclipseLink</a> adicionando a seguinte dependência: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Se você estiver usando um servidor compatível com Java EE 8, como GlassFish 5 ou Payara 5, poderá especificar a área "fornecida" para essas dependências no arquivo POM.  Caso contrário, especifique a área "compilar" para incluí-los na montagem do projeto. <br><br>  <b>Suporte a data e hora do Java 8</b> <br><br>  Talvez uma das adições mais positivas seja o suporte à API de data e hora do Java 8.  Desde o lançamento do Java SE 8 em 2014, os desenvolvedores usaram soluções alternativas para usar a API Date and Time com JPA.  Embora a maioria das soluções alternativas seja bastante simples, a necessidade de adicionar suporte básico para a API de data e hora atualizada está atrasada.  O suporte JPA para a API Data e hora inclui os seguintes tipos: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Para um melhor entendimento, explicarei primeiro como o suporte à API de data e hora funciona sem o JPA 2.2.  O JPA 2.1 só pode funcionar com construções de data mais antigas, como <code>java.util.Date</code> e <code>java.sql.Timestamp</code> .  Portanto, você deve usar um conversor para converter a data armazenada no banco de dados em um design antigo suportado pelo JPA 2.1 e, em seguida, convertê-lo em uma API de Data e Hora atualizada para uso no aplicativo.  Um conversor de data no JPA 2.1 capaz dessa conversão pode se parecer com a Listagem 1. O conversor nele é usado para converter entre <code>LocalDate</code> e <code>java.util.Date</code> . <br><br>  <i>Listagem 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  O JPA 2.2 não precisa mais gravar esse conversor, pois você está usando tipos de data e hora suportados.  O suporte para esses tipos é incorporado, portanto, você pode simplesmente especificar o tipo suportado no campo de classe da entidade sem código adicional.  O trecho de código abaixo demonstra esse conceito.  Observe que não há necessidade de adicionar anotação ao código <code>@Temporal</code> , porque o mapeamento de tipo ocorre automaticamente. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Como os tipos de data e hora suportados são objetos de primeira classe na JPA, eles podem ser especificados sem cerimônias adicionais.  No JPA 2.1 <code>@Temporal</code> anotação deve ser descrita em todos os campos e propriedades constantes dos <code>java.util.Calendar</code> e <code>java.util.Calendar</code> . <br><br>  Vale ressaltar que apenas alguns dos tipos de data e hora são suportados nesta versão, mas o conversor de atributos pode ser facilmente gerado para funcionar com outros tipos, por exemplo, para converter <code>LocalDateTime</code> em <code>ZonedDateTime</code> .  O maior problema ao escrever esse conversor é determinar a melhor forma de converter entre tipos diferentes.  Para facilitar ainda mais, os conversores de atributos agora podem ser implementados.  Vou dar um exemplo de implementação abaixo. <br><br>  O código na Listagem 2 mostra como converter o tempo de <code>LocalDateTime</code> para <code>ZonedDateTime</code> . <br><br>  <i>Listagem 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Especificamente, este exemplo é muito direto porque <code>ZonedDateTime</code> contém métodos fáceis de converter.  A conversão ocorre chamando o método <code>toLocalDateTime()</code> .  A conversão inversa pode ser feita chamando o método <code>ZonedDateTimeOf()</code> e passando o valor <code>LocalDateTime</code> junto com <code>ZoneId</code> para usar o fuso horário. <br><br>  <b>Conversores de atributos incorporados</b> <br><br>  Os conversores de atributo foram uma adição muito interessante ao JPA 2.1, pois permitiram que os tipos de atributo fossem mais flexíveis.  A atualização do JPA 2.2 adiciona uma capacidade útil para tornar os conversores de atributos implementáveis.  Isso significa que você pode incorporar recursos CDI (Contexts and Injection Dependency Injection) diretamente no conversor de atributos.  Essa modificação é consistente com outros aprimoramentos de CDI nas especificações do Java EE 8, como conversores JSF avançados, pois agora eles também podem usar a injeção de CDI. <br><br>  Para aproveitar esse novo recurso, basta incorporar os recursos CDI no conversor de atributos, conforme necessário.  A Listagem 2 fornece um exemplo de conversor de atributo e agora vou desmontá-lo, explicando todos os detalhes importantes. <br><br>  A classe converter deve implementar a interface <code>javax.persistence.AttributeConverter</code> , transmitindo os valores X e Y. O valor X corresponde ao tipo de dados no objeto Java e o valor Y deve corresponder ao tipo da coluna do banco de dados.  Em seguida, a classe do conversor deve ser anotada com <code>@Converter</code> .  Por fim, a classe deve substituir os <code>convertToDatabaseColumn()</code> e <code>convertToEntityAttribute()</code> .  A implementação em cada um desses métodos deve converter valores de tipos específicos e retornar a eles. <br><br>  Para aplicar o conversor automaticamente toda vez que o tipo de dados especificado for usado, adicione "automático", como em <code>@Converter(autoApply=true)</code> .  Para aplicar um conversor a um único atributo, use a anotação @Converter no nível do atributo, conforme mostrado aqui: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  O conversor também pode ser aplicado no nível da classe: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Suponha que eu queira criptografar os valores contidos no campo <code>creditLimit</code> da entidade <code>Customer</code> quando ele for salvo.  Para implementar esse processo, os valores devem ser criptografados antes de serem salvos e descriptografados após serem recuperados do banco de dados.  Isso pode ser feito pelo conversor e, usando o JPA 2.2, posso incorporar o objeto de criptografia no conversor para obter o resultado desejado.  A Listagem 3 fornece um exemplo. <br><br>  <i>Listagem 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  Nesse código, o processo é realizado <code>CreditLimitEncryptor</code> classe <code>CreditLimitEncryptor</code> no conversor e, em seguida, usando-a para ajudar no processo. <br><br>  <b>Resultados da consulta de streaming</b> <br><br>  Agora você pode tirar proveito fácil dos recursos de fluxos do Java SE 8 ao trabalhar com os resultados da consulta.  Os threads não apenas simplificam a leitura, gravação e manutenção de código, mas também ajudam a melhorar o desempenho da consulta em algumas situações.  Algumas implementações de encadeamentos também ajudam a evitar um número simultâneo excessivamente grande de solicitações de dados, embora em alguns casos o uso da paginação <code>ResultSet</code> possa funcionar melhor que os fluxos. <br><br>  Para ativar essa função, o método <code>getResultStream()</code> foi adicionado às <code>TypedQuery</code> <code>Query</code> e <code>TypedQuery</code> .  Essa pequena alteração permite que a JPA retorne simplesmente um fluxo de resultados em vez de uma lista.  Portanto, se você estiver trabalhando com um <code>ResultSet</code> grande, faz sentido comparar o desempenho entre uma nova implementação de encadeamento e um <code>ResultSets</code> ou paginação rolável.  O motivo é que as implementações de encadeamento recuperam todos os registros de uma só vez, armazenam-nos em uma lista e depois os devolvem.  Uma <code>ResultSet</code> rolável e uma técnica de paginação recuperam dados aos poucos, o que pode ser melhor para grandes conjuntos de dados. <br><br>  Os provedores de persistência podem decidir substituir o novo método <code>getResultStream()</code> uma implementação aprimorada.  O Hibernate já inclui um método stream () que usa um <code>ResultSet</code> rolável para analisar os resultados dos registros em vez de retorná-los completamente.  Isso permite que o Hibernate trabalhe com conjuntos de dados muito grandes e faça-o bem.  Pode-se esperar que outros provedores substituam esse método para fornecer recursos semelhantes que são benéficos para a JPA. <br><br>  Além do desempenho, a capacidade de transmitir resultados é uma boa adição ao JPA, que fornece uma maneira conveniente de trabalhar com dados.  Vou demonstrar alguns cenários em que isso pode ser útil, mas as possibilidades são infinitas.  Nos dois cenários, eu consulto a entidade <code>Job</code> e retorno o fluxo.  Primeiro, observe o código a seguir, onde eu simplesmente analiso o fluxo de <code>Jobs</code> relação a um <code>Customer</code> específico, chamando o método de interface <code>Query</code> <code>getResultStream()</code> .  Então, eu uso esse encadeamento para exibir detalhes sobre o <code>customer</code> e a <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Este método pode ser ligeiramente modificado para que ele retorne uma lista de resultados usando o método <code>Collectors .toList()</code> seguinte maneira. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  No cenário a seguir, mostrado abaixo, encontro uma <code>List</code> tarefas relacionadas aos conjuntos de um formulário específico.  Nesse caso, retorno todas as tarefas que correspondem ao formulário enviado como uma sequência.  Semelhante ao primeiro exemplo, primeiro retorno um fluxo de registros de <code>Jobs</code> .  Em seguida, filtro os registros com base no formulário do pool de clientes.  Como você pode ver, o código resultante é muito compacto e fácil de ler. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Como mencionei anteriormente, é importante lembrar o desempenho em cenários em que grandes quantidades de dados são retornadas.  Existem condições em que os threads são mais úteis na consulta de bancos de dados, mas também existem aqueles em que eles podem causar degradação no desempenho.  Uma boa regra geral é que, se os dados puderem ser consultados como parte de uma consulta SQL, faz sentido fazer exatamente isso.  Às vezes, os benefícios do uso de sintaxe de encadeamento elegante não superam o melhor desempenho possível com a filtragem SQL padrão. <br><br>  <b>Suporte de anotação duplicada</b> <br><br>  Quando o Java SE 8 foi lançado, as anotações duplicadas se tornaram possíveis, permitindo que você reutilizasse as anotações na declaração.  Algumas situações exigem o uso da mesma anotação em uma classe ou campo várias vezes.  Por exemplo, pode haver mais de uma anotação <code>@SqlResultSetMapping</code> para uma determinada classe de entidade.  Nas situações em que o suporte à re-anotação é necessário, a anotação do contêiner deve ser usada.  As anotações duplicadas não apenas reduzem o requisito de agrupar coleções de anotações idênticas nas anotações de contêiner, mas também podem facilitar a leitura do código. <br><br>  Isso funciona da seguinte maneira: a implementação da classe de anotação deve ser marcada com a meta-anotação <code>@Repeatable</code> para indicar que ela pode ser usada mais de uma vez.  A meta-anotação <code>@Repeatable</code> usa o tipo da classe de anotação do contêiner.  Por exemplo, a <code>NamedQuery</code> anotação <code>NamedQuery</code> agora <code>NamedQuery</code> marcada com a <code>@Repeatable(NamedQueries.class)</code> .  Nesse caso, a anotação de contêiner ainda está em uso, mas você não precisa pensar nisso ao usar a mesma anotação na declaração ou classe, porque <code>@Repeatable</code> abstrai esse detalhe. <br><br>  Nós damos um exemplo.  Se você deseja adicionar mais de uma anotação <code>@NamedQuery</code> a uma classe de entidade no JPA 2.1, precisará encapsulá-las dentro da anotação <code>@NamedQueries</code> , conforme mostrado na Listagem 4. <br><br>  <i>Listagem 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  No entanto, na JPA 2.2, tudo é diferente.  Como <code>@NamedQuery</code> é uma anotação duplicada, ela pode ser especificada na classe de entidade mais de uma vez, conforme mostrado na Listagem 5. <br><br>  <i>Listagem 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Lista de anotações duplicadas: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Conclusão</b> <br><br>  A versão JPA 2.2 possui algumas alterações, mas as melhorias incluídas são significativas.  Por fim, o JPA está alinhado com o Java SE 8, permitindo que os desenvolvedores usem recursos como a API de Data e Hora, transmitindo resultados de consultas e repetindo anotações.  Esta versão também aprimora a consistência do CDI, adicionando a capacidade de incorporar recursos CDI em conversores de atributos.  O JPA 2.2 já está disponível e faz parte do Java EE 8, acho que você gostaria de usá-lo. <br><br>  O FIM <br><br>  Como sempre, estamos aguardando perguntas e comentários. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423195/">https://habr.com/ru/post/pt423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423185/index.html">Não coma! Impressão útil de açúcar 3D</a></li>
<li><a href="../pt423187/index.html">Certificados raiz e intermediários das autoridades de certificação autorizadas da Rússia</a></li>
<li><a href="../pt423189/index.html">Pesquisa: metade das empresas corrige vulnerabilidades em um mês - por quê?</a></li>
<li><a href="../pt423191/index.html">Lançamento dos elementos das plataformas offshore. Parte 1</a></li>
<li><a href="../pt423193/index.html">Configurar notificações por push da Web usando pywebpush passo a passo</a></li>
<li><a href="../pt423197/index.html">LOLWUT: uma obra de arte em uma equipe de db</a></li>
<li><a href="../pt423203/index.html">Líder de equipe legal será responsável pelo serviço</a></li>
<li><a href="../pt423205/index.html">Projeto de armazenamento no MS SQL Server, integração com 1C 7.7 e automação de desenvolvimento em SSDT</a></li>
<li><a href="../pt423207/index.html">Como fazer uma atualização automática de um cliente de jogo online</a></li>
<li><a href="../pt423209/index.html">Formulário 2 do assassino? Visão geral da impressora 3D dental MoonRay S100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>