<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏫 〽️ 📪 Padrão BIF: código front-end limpo e trabalho conveniente com dados do servidor 👩🏻‍🤝‍👨🏾 👩🏼‍🎨 👐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O material, cuja tradução publicamos hoje, se concentrará no que fazer em uma situação em que os dados recebidos do servidor não pareçam com as necess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Padrão BIF: código front-end limpo e trabalho conveniente com dados do servidor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416011/">  O material, cuja tradução publicamos hoje, se concentrará no que fazer em uma situação em que os dados recebidos do servidor não pareçam com as necessidades do cliente.  Nomeadamente, inicialmente consideraremos um problema típico desse tipo e, depois, analisaremos várias maneiras de resolvê-lo. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/7dc/108/edd/7dc108edd1850ed1da6eb12f865f93a5.jpg" alt="imagem"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O problema da API do servidor com falha</font> </h2><br>  Vamos considerar um exemplo condicional com base em vários projetos reais.  Suponha que estamos desenvolvendo um novo site para uma organização que já existe há algum tempo.  Ela já possui pontos de extremidade REST, mas eles não foram totalmente projetados para o que vamos criar.  Aqui, precisamos acessar o servidor apenas para autenticar o usuário, obter informações sobre ele e baixar uma lista de notificações não visualizadas desse usuário.  Como resultado, estamos interessados ​​nos seguintes pontos de extremidade da API do servidor: <br><br><ul><li> <code>/auth</code> : autoriza o usuário e retorna um token de acesso. </li><li>  <code>/profile</code> : retorna informações básicas do usuário. </li><li>  <code>/notifications</code> : permite receber notificações de usuários não lidas. </li></ul><br>  Imagine que nosso aplicativo sempre precise receber todos esses dados em uma única unidade, ou seja, idealmente seria bom se, em vez de três pontos de extremidade, tivéssemos apenas um. <br>  No entanto, somos confrontados com muito mais problemas do que muitos pontos de extremidade.  Em particular, estamos falando sobre o fato de que os dados que recebemos não parecem da melhor maneira. <br><br>  Por exemplo, o nó de extremidade <code>/profile</code> foi criado nos tempos antigos, não foi escrito em JavaScript; como resultado, os nomes das propriedades nos dados retornados parecem incomuns para um aplicativo JS: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Profiles"</span></span>: [   {     <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"David"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Gilbertson"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [       {         <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,         <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [           <span class="hljs-string"><span class="hljs-string">"/images/david.png"</span></span>         ]       }     ],     <span class="hljs-attr"><span class="hljs-attr">"Last_Login"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-01"</span></span>   } ] }</code> </pre> <br>  Em geral - nada de bom. <br><br>  É verdade que, se você observar o que o ponto de extremidade <code>/notifications</code> produz, os dados acima de <code>/profile</code> parecerão bastante agradáveis: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"msg-1234"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529739612"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Guthbertson"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Enhanced"</span></span>: <span class="hljs-string"><span class="hljs-string">"True"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/alice.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it re"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it really goes nice with your eyes"</span></span>   },   <span class="hljs-attr"><span class="hljs-attr">"msg-5678"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529731234"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Smelthsen"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/smelth.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocu"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocurrency soon and many thanks for you to look at and talk about"</span></span>   } } }</code> </pre> <br>  Aqui a lista de mensagens é um objeto, não uma matriz.  Além disso, existem dados do usuário aqui, que são tão desconfortavelmente organizados quanto no caso do terminal <code>/profile</code> .  E - eis uma surpresa - a propriedade <code>timestamp</code> contém o número de segundos desde o início de 1970. <br><br>  Se eu tivesse que desenhar um diagrama da arquitetura daquele sistema infernalmente inconveniente sobre o qual acabamos de falar, seria semelhante ao mostrado na figura abaixo.  A cor vermelha é usada para as partes deste circuito que correspondem a dados mal preparados para trabalhos futuros. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e1/6c4/42f/8e16c442f3af8ad8ca702875e25207e0.png"><br>  <i><font color="#999999">Diagrama do sistema</font></i> <br><br>  Nessas circunstâncias, não podemos nos esforçar para corrigir a arquitetura deste sistema.  Você pode simplesmente carregar dados dessas três APIs e usar esses dados no aplicativo.  Por exemplo, se você precisar exibir o nome de usuário completo na página, precisaremos combinar as propriedades <code>Christian_Name</code> e <code>Surname</code> . <br><br>  Aqui eu gostaria de fazer uma observação sobre nomes.  A ideia de dividir o nome completo de uma pessoa em um nome e sobrenome pessoais é característica dos países ocidentais.  Se você estiver desenvolvendo algo projetado para uso internacional, tente considerar o nome completo da pessoa como uma sequência indivisível e não faça suposições sobre como dividir essa sequência em partes menores para usar o que aconteceu em locais onde precisa de brevidade ou deseja apelar para o usuário em um estilo informal. <br><br>  De volta às nossas estruturas de dados imperfeitas.  O primeiro problema óbvio que pode ser visto aqui é expresso na necessidade de combinar dados diferentes no código da interface do usuário.  Consiste no fato de que talvez seja necessário repetir essa ação em vários lugares.  Se você precisar fazer isso apenas ocasionalmente, o problema não será tão sério, mas se você precisar disso com frequência, será muito pior.  Como resultado, existem fenômenos indesejáveis ​​causados ​​pela incompatibilidade de como os dados recebidos do servidor são organizados e como eles são usados ​​no aplicativo. <br><br>  O segundo problema é a complexidade do código usado para formar a interface do usuário.  Eu acredito que esse código deve ser, em primeiro lugar, o mais simples possível e, em segundo lugar - o mais claro possível.  Quanto mais transformações internas de dados você precisar fazer no cliente, maior será sua complexidade e o código complexo será o local onde os erros geralmente se ocultam. <br><br>  A terceira questão diz respeito aos tipos de dados.  Nos trechos de código acima, você pode ver que, por exemplo, identificadores de mensagens são cadeias de caracteres e identificadores de usuários são números.  Do ponto de vista técnico, está tudo bem, mas essas coisas podem confundir o programador.  Além disso, veja a apresentação das datas!  Mas e a bagunça na parte dos dados relacionada à imagem do perfil?  Afinal, tudo o que precisamos é de uma URL que leve ao arquivo correspondente, e não algo a partir do qual teremos que criar essa URL, percorrendo a selva de estruturas de dados aninhadas. <br><br>  Se processarmos esses dados, passando-os para o código da interface do usuário e analisando os módulos, não poderemos entender imediatamente exatamente com o que estamos trabalhando lá.  A conversão da estrutura de dados interna e seu tipo ao trabalhar com eles cria uma carga adicional para o programador.  Mas sem todas essas dificuldades, é bem possível fazer isso. <br><br>  De fato, como opção, seria possível implementar um sistema de tipo estático para resolver esse problema, mas a digitação estrita não é capaz, apenas pelo fato de sua presença, de tornar bons códigos ruins. <br><br>  Agora que você pode ver a seriedade do problema que estamos enfrentando, vamos falar sobre maneiras de resolvê-lo. <br><br><h2>  <font color="#3AC1EF">Solução 1: alterando a API do servidor</font> </h2><br>  Se o dispositivo inconveniente da API existente não for ditado por alguns motivos importantes, nada o impedirá de criar uma nova versão que melhor atenda às necessidades do projeto e de localizar essa nova versão, digamos, em <code>/v2</code> .  Talvez essa abordagem possa ser chamada de solução mais bem-sucedida para os problemas acima.  O esquema desse sistema é apresentado na figura abaixo; a estrutura de dados que corresponde perfeitamente às necessidades do cliente é destacada em verde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/59d/c18/c5959dc18590ec9bce0368e4b9ba1967.png"><br>  <i><font color="#999999">A nova API do servidor que produz exatamente o que o lado do cliente do sistema precisa</font></i> <br><br>  Começando a desenvolver um novo projeto, cuja API deixa muito a desejar, estou sempre interessado na possibilidade de implementar a abordagem descrita.  No entanto, algumas vezes o dispositivo da API, embora inconveniente, tem alguns objetivos importantes, ou alterar a API do servidor simplesmente não é possível.  Nesse caso, recorro à seguinte abordagem. <br><br><h2>  <font color="#3AC1EF">Solução # 2: Padrão BFF</font> </h2><br>  Esse é um bom e velho padrão de BFF ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">back-end para o front-end</a> ).  Usando esse padrão, você pode abstrair dos intricados pontos de extremidade REST universais e fornecer ao front end exatamente o que ele precisa.  Aqui está uma representação esquemática de uma solução desse tipo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea5/484/437/ea5484437a08ed68db006b5194dd9a9b.png"><br>  <i><font color="#999999">Aplicando o padrão BFF</font></i> <br><br>  O significado da existência da camada BFF é satisfazer as necessidades do frontend.  Talvez ele use pontos de extremidade REST adicionais, serviços GraphQL, soquetes da Web ou qualquer outra coisa.  Seu principal objetivo é fazer todo o possível para a conveniência do lado do cliente do aplicativo. <br><br>  Minha arquitetura favorita é o NodeJS BFF, usando quais desenvolvedores front-end podem fazer o que precisam, criando ótimas APIs para os aplicativos clientes que desenvolvem.  Idealmente, o código correspondente está no mesmo repositório que o código do front-end, o que simplifica o compartilhamento de código, por exemplo, para verificar os dados enviados, tanto no cliente quanto no servidor. <br><br>  Além disso, isso significa que as tarefas que requerem alterações na parte do cliente do aplicativo e na API do servidor são executadas em um repositório.  Um pouco, como eles dizem, mas legal. <br><br>  No entanto, o BFF nem sempre pode ser usado.  E esse fato nos leva a outra solução para o problema do uso conveniente de APIs ruins de servidor. <br><br><h2>  <font color="#3AC1EF">Solução 3: Padrão BIF</font> </h2><br>  O padrão BIF (back-end no front-end) usa a mesma lógica que pode ser aplicada usando o BFF (combinando várias APIs e limpeza de dados), mas essa lógica se move para o lado do cliente.  Na verdade, essa ideia não é nova, poderia ter sido vista vinte anos atrás, mas essa abordagem pode ajudar no trabalho com APIs de servidor mal organizadas, é por isso que estamos falando sobre isso.  Aqui está como fica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/185/102/d39/185102d39436b6119ead19f230eb8196.png"><br>  <i><font color="#999999">Aplicando o padrão BIF</font></i> <br><br><h3>  <font color="#3AC1EF">▍ O que é um BIF?</font> </h3><br>  Como pode ser visto na seção anterior, o BIF é um padrão, isto é, uma abordagem para entender o código e sua organização.  Seu uso não leva à necessidade de remover nenhuma lógica do projeto.  Apenas separa a lógica de um tipo (modificação de estruturas de dados) da lógica de outro tipo (a formação da interface do usuário).  Isso é semelhante à idéia de uma "separação de responsabilidades", que todo mundo está ouvindo. <br><br>  Aqui eu gostaria de observar que, embora isso não possa ser chamado de desastre, muitas vezes eu tinha que ver implementações analfabetas de BIF.  Portanto, parece-me que muitos estarão interessados ​​em ouvir uma história sobre como implementar corretamente esse padrão. <br><br>  O código BIF deve ser considerado como um código que pode ser usado e transferido para o servidor Node.js. Depois disso, tudo funcionará da mesma maneira que antes.  Ou até mesmo transfira-o para um pacote NPM privado, que será usado em vários projetos front-end dentro da estrutura de uma empresa, o que é simplesmente incrível. <br><br>  Lembre-se de que discutimos acima os principais problemas que surgem ao trabalhar com uma API do servidor com falha.  Entre eles, há uma chamada muito frequente para a API e o fato de os dados retornados por eles não atenderem às necessidades do front-end. <br><br>  Dividiremos a solução de cada um desses problemas em blocos de código separados, cada um dos quais será colocado em seu próprio arquivo.  Como resultado, a camada BIF da parte do cliente do aplicativo consistirá em dois arquivos.  Além disso, um arquivo de teste será anexado a eles. <br><br><h3>  <font color="#3AC1EF">▍ Combinando chamadas de API</font> </h3><br>  Fazer muitas chamadas para as APIs do servidor em nosso código de cliente não é um problema tão sério.  No entanto, gostaria de abstraí-lo, para possibilitar o atendimento de uma única “solicitação” (do código do aplicativo à camada BIF) e obter exatamente o que é necessário em resposta. <br><br>  Obviamente, no nosso caso, não há como fazer três solicitações HTTP para o servidor, mas o aplicativo não precisa saber sobre isso. <br><br>  A API da minha camada BIF é representada como funções.  Portanto, quando o aplicativo precisar de alguns dados sobre o usuário, ele chamará a função <code>getUser()</code> , que retornará esses dados para ele.  Aqui está a aparência dessa função: <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; import fetchJson from <span class="hljs-string"><span class="hljs-string">'./fetchJson'</span></span>; export const getUser = async () =&gt; { const auth = await fetchJson(<span class="hljs-string"><span class="hljs-string">'/auth'</span></span>); const [ <span class="hljs-type"><span class="hljs-type">profile</span></span>, <span class="hljs-type"><span class="hljs-type">notifications</span></span> ] = await Promise.all([   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">profile</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>),   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">notifications</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>), ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseUserData(auth, profile, notifications); };</code> </pre> <br>  Aqui, primeiro, é feita uma solicitação ao serviço de autenticação para obter um token, que pode ser usado para autorizar o usuário (não falaremos sobre mecanismos de autenticação aqui, mas nosso principal objetivo é o BIF). <br><br>  Após receber o token, você pode executar simultaneamente duas solicitações que recebem dados e informações do perfil do usuário sobre notificações não lidas. <br><br>  A propósito, observe como a construção <code>async/await</code> é bonita ao trabalhar com ela usando <code>Promise.all</code> e usando atribuição destrutiva. <br><br>  Portanto, este foi o primeiro passo, aqui abstraímos o fato de que o acesso ao servidor inclui três solicitações.  No entanto, o caso ainda não foi concluído.  Ou seja, preste atenção na chamada para a função <code>parseUserData()</code> , que, como você pode julgar pelo nome, organiza os dados recebidos do servidor.  Vamos conversar sobre ela. <br><br><h3>  <font color="#3AC1EF">▍ Limpeza de dados</font> </h3><br>  Quero dar imediatamente uma recomendação que, acredito, pode afetar seriamente um projeto que anteriormente não possuía uma camada BIF, em particular um novo projeto.  Tente não pensar no que você recebe do servidor por um tempo.  Em vez disso, concentre-se em quais dados seu aplicativo precisa. <br><br>  Além disso, é melhor não tentar, ao projetar o aplicativo, levar em consideração suas possíveis necessidades futuras, digamos, relacionadas a 2021.  Apenas tente fazer o aplicativo funcionar exatamente como deveria hoje.  O fato é que o entusiasmo excessivo pelo planejamento e as tentativas de prever o futuro é o principal motivo da complicação injustificada dos projetos de software. <br><br>  Então, voltando ao nosso negócio.  Agora sabemos como são os dados recebidos das três APIs do servidor e sabemos em que eles devem se transformar após a análise. <br><br>  Parece que este é um daqueles casos raros em que o uso do TDD realmente faz sentido.  Portanto, escreveremos um grande teste longo para a função <code>parseUserData()</code> : <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; it(<span class="hljs-string"><span class="hljs-string">'should parse the data'</span></span>, () =&gt; { const authApiData = {   userId: <span class="hljs-number"><span class="hljs-number">1234</span></span>,   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>, }; const profileApiData = {   Profiles: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,       <span class="hljs-type"><span class="hljs-type">Christian_Name</span></span>: <span class="hljs-string"><span class="hljs-string">'David'</span></span>,       <span class="hljs-type"><span class="hljs-type">Surname</span></span>: <span class="hljs-string"><span class="hljs-string">'Gilbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">Photographs</span></span>: [         {           <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,           <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [             <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,           ],         },       ],       <span class="hljs-type"><span class="hljs-type">Last_Login</span></span>: <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>     },   ], }; const notificationsApiData = {   <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: {     <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529739612'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Guthbertson'</span></span>,         Enhanced: <span class="hljs-string"><span class="hljs-string">'True'</span></span>,         Photographs: [           {             <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,             <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [               <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>             ]           }         ]       },       message_summary: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it re'</span></span>,       message: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529731234'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Smelthsen'</span></span>,       },       message_summary: <span class="hljs-string"><span class="hljs-string">'I\'</span></span>m launching my own cryptocu<span class="hljs-string"><span class="hljs-string">',       message: '</span></span>I\<span class="hljs-string"><span class="hljs-string">'m launching my own cryptocurrency soon and many thanks for you to look at and talk about'</span></span>     },   }, }; const parsedData = parseUserData(authApiData, profileApiData, notificationsApiData); expect(parsedData).toEqual({   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>,   id: <span class="hljs-string"><span class="hljs-string">'1234'</span></span>,   name: <span class="hljs-string"><span class="hljs-string">'David Gilbertson'</span></span>,   photoUrl: <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,   notifications: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alice Guthbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob Smelthsen'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'I\'</span></span><span class="hljs-type"><span class="hljs-type">m</span></span> <span class="hljs-type"><span class="hljs-type">launching</span></span> <span class="hljs-type"><span class="hljs-type">my</span></span> <span class="hljs-type"><span class="hljs-type">own</span></span> <span class="hljs-type"><span class="hljs-type">cryptocurrency</span></span> <span class="hljs-type"><span class="hljs-type">soon</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">many</span></span> <span class="hljs-type"><span class="hljs-type">thanks</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">you</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">look</span></span> <span class="hljs-type"><span class="hljs-type">at</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">talk</span></span> <span class="hljs-type"><span class="hljs-type">about</span></span><span class="hljs-string"><span class="hljs-string">'     },   ], }); });</span></span></code> </pre> <br>  E aqui está o código da própria função: <br><br><pre> <code class="hljs powershell">const getPhotoFromProfile = profile =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> profile.Photographs[<span class="hljs-number"><span class="hljs-number">0</span></span>].URLS[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>; //   } }; const getFullNameFromProfile = profile =&gt; `${profile.Christian_Name} <span class="hljs-variable"><span class="hljs-variable">$</span></span>{profile.Surname}`; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseUserData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(authApiData, profileApiData, notificationsApiData)</span></span></span></span> { const profile = profileApiData.Profiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const result = {   jwt: authApiData.jwt,   id: authApiData.userId.toString(), // ID        name: getFullNameFromProfile(profile),   photoUrl: getPhotoFromProfile(profile),   notifications: [], //      ,     }; Object.entries(notificationsApiData.data).forEach(([<span class="hljs-type"><span class="hljs-type">id</span></span>, <span class="hljs-type"><span class="hljs-type">notification</span></span>]) =&gt; {   result.notifications.push({     id,     dateTime: new Date(Number(notification.timestamp) * <span class="hljs-number"><span class="hljs-number">1000</span></span>), // ,   ,   ,     Unix,         name: getFullNameFromProfile(notification.user),     photoUrl: getPhotoFromProfile(notification.user),     message: notification.message,     premiumMember: notification.user.Enhanced === <span class="hljs-string"><span class="hljs-string">'True'</span></span>,   }) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Gostaria de observar que, quando é possível coletar em um local duzentas linhas de código responsáveis ​​pela modificação dos dados espalhados antes disso por todo o aplicativo, isso causa uma sensação maravilhosa.  Agora, tudo isso está em um arquivo, testes de unidade são escritos para esse código e todos os momentos ambíguos são fornecidos com comentários. <br><br>  Eu disse anteriormente que o BFF é minha abordagem favorita para combinar e limpar dados, mas existe uma área em que o BIF é superior ao BFF.  Ou seja, os dados recebidos do servidor podem incluir objetos JavaScript que não suportam JSON, como objetos <code>Date</code> ou <code>Map</code> (talvez esse seja um dos recursos JavaScript mais subutilizados).  Por exemplo, no nosso caso, temos que converter a data que veio do servidor (expressa em segundos, não em milissegundos) em um objeto JS do tipo <code>Date</code> . <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Se você acha que seu projeto tem algo em comum com aquele em que examinamos os problemas de APIs malsucedidas, analise seu código fazendo as seguintes perguntas sobre o uso de dados do servidor no cliente: <br><br><ul><li>  Você precisa combinar propriedades que nunca são usadas separadamente (por exemplo, nome e sobrenome do usuário)? </li><li>  O código JS precisa trabalhar com nomes de propriedades formados de uma maneira que não seja aceita em JS (algo como PascalCase)? </li><li>  Quais são os tipos de dados dos vários identificadores?  Talvez às vezes sejam cordas, às vezes números? </li><li>  Como as datas são apresentadas no seu projeto?  Talvez, às vezes, esses sejam objetos <code>Date</code> JS prontos para uso na interface e, às vezes, números ou até strings? </li><li>  Você geralmente precisa verificar as propriedades quanto à existência delas ou se uma entidade é uma matriz antes de começar a enumerar os elementos dessa entidade para formar algum fragmento da interface do usuário com base?  Será que essa entidade não será uma matriz, mesmo que vazia? </li><li>  Você precisa classificar ou filtrar matrizes ao formar a interface, que, idealmente, já deve ser classificada e filtrada corretamente? </li><li>  Se acontecer que, ao verificar as propriedades quanto à sua existência, não há propriedades procuradas, é necessário mudar para usar alguns valores padrão (por exemplo, use a imagem padrão quando não houver foto do usuário nos dados recebidos do servidor)? </li><li>  As propriedades são nomeadas de maneira uniforme?  Ocorre que a mesma entidade pode ter nomes diferentes, o que é possivelmente causado pelo uso conjunto de APIs de servidor “antigas” e “novas”, relativamente falando? </li><li>  Você precisa, juntamente com dados úteis, transferir para algum lugar os dados que nunca são usados, fazendo isso apenas porque são provenientes da API do servidor?  Esses dados não utilizados interferem na depuração? </li></ul><br>  Se você puder responder positivamente a uma ou duas perguntas dessa lista, talvez não deva reparar algo que já funcione corretamente. <br><br>  No entanto, se você, lendo essas perguntas, descobrir em cada uma delas os problemas do seu projeto, se o dispositivo do seu código é desnecessariamente complicado por causa de tudo isso, se for difícil de perceber e testar, se houver erros difíceis de detectar, dê uma olhada no padrão BIF. <br><br>  No final, quero dizer que, ao introduzir a camada BIF em aplicativos existentes, as coisas ficam mais fáceis devido ao fato de que isso pode ser feito em etapas, em pequenas etapas.  Digamos que a primeira versão da função para a preparação de dados, vamos chamá-la de <code>parseData()</code> , pode simplesmente, sem alterações, retornar o que vem à sua entrada.  Em seguida, você pode mover gradualmente a lógica do código responsável pela criação da interface do usuário para esta função. <br><br>  <b>Caros leitores!</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Você encontrou problemas para os quais o autor deste material sugere o uso do padrão BIF? </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416011/">https://habr.com/ru/post/pt416011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416001/index.html">Mensagens de um site em VK - simples e eficaz - PHP + CUrl</a></li>
<li><a href="../pt416003/index.html">Renderização de arquivo HTML: um capítulo do livro ReactPHP for Beginners de Skyeng</a></li>
<li><a href="../pt416005/index.html">16 Reagir ferramentas para desenvolvedores de interface</a></li>
<li><a href="../pt416007/index.html">Quase complicado. O início da criação de uma "casa inteligente" sem fio. Baseado na tecnologia Linux, nos softwares Z-Wave e MajorDoMo</a></li>
<li><a href="../pt416009/index.html">Tente excrementos de coelho, é vigoroso, ele pega - extratos em farmacologia</a></li>
<li><a href="../pt416013/index.html">Como começar a investir e economizar dinheiro: os especialistas da Dow Jones apontaram os cinco principais erros de traders iniciantes</a></li>
<li><a href="../pt416015/index.html">Brincando com threads no Node.JS 10.5.0</a></li>
<li><a href="../pt416017/index.html">Coletamos análise de coorte / análise de fluxos no exemplo do Excel</a></li>
<li><a href="../pt416019/index.html">Quão bom é o ecossistema de código aberto da R para resolver problemas de negócios?</a></li>
<li><a href="../pt416021/index.html">Desenvolvendo sua própria estrutura e crescimento profissional de um programador de JS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>