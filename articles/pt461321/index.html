<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜñ üßôüèª üèñÔ∏è Modelos gen√©ricos e de metaprograma√ß√£o: Go, Rust, Swift, D e outros üëâüèº üà≤ üíÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em algumas √°reas da programa√ß√£o, √© normal escrever uma estrutura ou algoritmo de dados que possa funcionar com elementos de diferentes tipos. Por exem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelos gen√©ricos e de metaprograma√ß√£o: Go, Rust, Swift, D e outros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  Em algumas √°reas da programa√ß√£o, √© normal escrever uma estrutura ou algoritmo de dados que possa funcionar com elementos de diferentes tipos.  Por exemplo, uma lista de gen√©ricos ou um algoritmo de classifica√ß√£o que precisa apenas de uma fun√ß√£o de compara√ß√£o.  Em v√°rias linguagens, s√£o oferecidas v√°rias maneiras de solucionar esse problema: desde apontar as fun√ß√µes comuns apropriadas (C, Go) at√© os programadores e sistemas gen√©ricos t√£o poderosos que eles se tornam completos em Turing ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++</a> ).  Neste artigo, falarei sobre sistemas gen√©ricos de diferentes idiomas e sua implementa√ß√£o.  Come√ßarei resolvendo o problema em idiomas sem um sistema semelhante (como C) e depois mostrarei como a adi√ß√£o gradual de extens√µes leva a sistemas de outros idiomas. <br><a name="habracut"></a><br>  Considero os gen√©ricos uma op√ß√£o interessante, porque s√£o um caso especial simples da tarefa geral de metaprograma√ß√£o: escrever programas que podem gerar classes de outros programas.  Como prova, mostrarei como tr√™s m√©todos de metaprograma√ß√£o diferentes e completamente gerais podem ser considerados extens√µes multidirecionais no espa√ßo de sistemas gen√©ricos: linguagens din√¢micas como Python, macro sistemas procedurais como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Template Haskel</a> e compila√ß√£o em fases como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zig</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terra</a> . <br><br><h2>  Revis√£o </h2><br>  Desenhei um diagrama de blocos de todos os sistemas descritos no artigo para que voc√™ possa apresentar seu conte√∫do e como esses sistemas est√£o interconectados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Id√©ias principais </h2><br>  Suponha que estamos escrevendo em uma linguagem sem sistemas gen√©ricos e queremos criar uma estrutura de dados de estrutura de dados de pilha gen√©rica que funcione com dados de qualquer tipo.  O problema √© que cada defini√ß√£o de fun√ß√£o e tipo funcionar√° apenas com dados do mesmo tamanho e copiados de uma maneira e geralmente funcionar√° da mesma forma. <br><br>  H√° duas maneiras de contornar isso: verifique se todos os tipos de dados agem da mesma maneira em nossa estrutura ou fa√ßa muitas c√≥pias da estrutura de dados com pequenas altera√ß√µes para funcionar corretamente com cada tipo de dado.  Essas id√©ias formaram a base de dois grandes grupos de solu√ß√µes com gen√©ricos: boxe e monomorfiza√ß√£o. <br><br>  Empacotar significa colocar tudo em uma linha em "caixas" unificadas que funcionam da mesma maneira.  Isso geralmente √© feito assim: os dados s√£o colocados em um heap e os ponteiros para eles s√£o colocados na estrutura de dados.  Voc√™ pode fazer ponteiros para todos os tipos que funcionar√£o da mesma maneira, para que o mesmo c√≥digo funcione com dados de qualquer tipo!  No entanto, isso leva ao aumento do consumo de mem√≥ria, pesquisa din√¢mica e falhas de cache.  Em C, isso significa que sua estrutura de dados armazena ponteiros <code>void*</code> e simplesmente armazena em cache os dados de e para <code>void*</code> (se os dados n√£o estiverem no heap, eles ser√£o colocados l√°). <br><br>  Monomorfiza√ß√£o significa copiar repetidamente o c√≥digo para os diferentes tipos de dados que queremos armazenar.  Cada inst√¢ncia de c√≥digo pode usar diretamente os m√©todos de tamanho e dados com os quais trabalha, sem pesquisa din√¢mica.  Com essa abordagem, o c√≥digo executa o mais r√°pido, mas seu tamanho e tempo de compila√ß√£o aumentam, porque compilamos repetidamente o mesmo c√≥digo com pequenas altera√ß√µes.  Em C, isso corresponde √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">defini√ß√£o de toda a estrutura de dados como uma macro</a> , seguida por sua chamada para cada tipo de dado. <br><br>  Em geral, durante a compila√ß√£o, o c√≥digo √© compilado mais rapidamente, mas seu desempenho pode se deteriorar durante a execu√ß√£o, enquanto durante a monomorfiza√ß√£o geramos c√≥digo r√°pido, mas leva mais tempo para compilar e otimizar todas as inst√¢ncias do c√≥digo.  Outra diferen√ßa √© que, quando as extens√µes de empacotamento permitem um comportamento mais din√¢mico do c√≥digo execut√°vel, a monomorfiza√ß√£o permite separar com mais flexibilidade diferentes inst√¢ncias diferentes do c√≥digo gen√©rico.  Tamb√©m √© importante notar que, em alguns programas grandes, os benef√≠cios da monomorfiza√ß√£o podem ser compensados ‚Äã‚Äãpor falhas no cache de instru√ß√µes adicionais do c√≥digo gerado. <br><br>  Cada um dos esquemas descritos para trabalhar com gen√©ricos pode ser expandido em dire√ß√µes diferentes, se voc√™ precisar de mais recursos ou seguran√ßa, e os autores de v√°rios idiomas apresentaram solu√ß√µes muito interessantes.  Por exemplo, ambas as abordagens podem ser usadas em Rust e C #! <br><br><h2>  Embalagem </h2><br>  Vamos come√ßar com um exemplo de embalagem b√°sica no Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Al√©m disso, o empacotamento √© usado em C ( <code>void*</code> ), Go ( <code>interface{}</code> ), Java pr√©-gen√©rico ( <code>Object</code> ) e Objective-C pr√©-gen√©rico ( <code>id</code> ). <br><br><h2>  Gen√©ricos compactados com tipos de purifica√ß√£o </h2><br>  O principal m√©todo de embalagem tem desvantagens: <br><br><ul><li>  Dependendo do idioma, geralmente precisamos converter valores para ou do tipo correto sempre que lemos ou gravamos na estrutura de dados. <br></li><li>  Nada nos impede de inserir elementos de tipos diferentes na estrutura, o que pode provocar bugs que parecem travamentos durante a execu√ß√£o do c√≥digo. <br></li></ul><br>  Ambos os problemas podem ser resolvidos adicionando gen√©ricos ao sistema de tipos de funcionalidade, enquanto o m√©todo de empacotamento principal √© usado da mesma maneira que antes durante a execu√ß√£o do c√≥digo.  Essa abordagem costuma ser chamada de apagamento de tipo, porque os tipos no sistema gen√©rico s√£o substitu√≠dos e se tornam um tipo sob o cap√¥ (como <code>Object</code> ). <br><br>  Java e Objective-C come√ßaram com o empacotamento usual e, posteriormente, adquiriram ferramentas de linguagem para gen√©ricos com tipo de mash, por motivos de compatibilidade, usando os mesmos tipos de cole√ß√£o de antes, mas com os par√¢metros opcionais de tipos gen√©ricos.  Considere um exemplo de um artigo da Wikipedia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gen√©ricos em Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Gen√©ricos em pacote derivados com desempenho unificado </h3><br>  O OCaml desenvolve ainda mais a ideia de uma vis√£o unificada.  N√£o h√° tipos primitivos que precisam de posicionamento adicional de empacotamento (como um <code>int</code> deve se transformar em <code>Integer</code> para entrar em um <code>ArrayList</code> em Java), porque tudo j√° est√° compactado ou representado por um valor inteiro do tamanho de um ponteiro, ou seja, tudo se encaixa em uma palavra de m√°quina.  Mas quando o coletor de lixo olha os dados armazenados em estruturas gen√©ricas, ele precisa distinguir ponteiros de n√∫meros, para que os n√∫meros sejam marcados com um bit, colocados onde os ponteiros alinhados corretamente n√£o t√™m um bit, deixando intervalos de apenas 31 ou 63 bits. <br><br>  O OCaml tamb√©m possui um sistema de infer√™ncia de tipos, para que voc√™ possa escrever uma fun√ß√£o e o compilador produzir√° o tipo gen√©rico mais adequado se voc√™ n√£o anot√°-la e, portanto, as fun√ß√µes parecer√£o uma linguagem de tipo din√¢mico: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  O tipo especificado pode ser chamado de "uma fun√ß√£o da lista de elementos do tipo <code>'a</code> em algo com o tipo <code>'a</code> ".  Isso significa que o tipo de retorno ser√° o mesmo que o tipo de lista e pode ser de qualquer tipo. <br><br><h2>  Interfaces </h2><br>  Outra limita√ß√£o da embalagem convencional √© que os tipos embalados s√£o <i>completamente</i> opacos.  Isso n√£o √© um problema para estruturas de dados como uma pilha, mas ferramentas como classificar fun√ß√µes gen√©ricas precisam de recursos adicionais, como fun√ß√µes de compara√ß√£o espec√≠ficas de tipo.  Existem v√°rias maneiras de implementar isso em tempo de execu√ß√£o e refletir no idioma. Tecnicamente, essas s√£o dire√ß√µes diferentes, e voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementar o mesmo idioma com v√°rias abordagens semelhantes</a> .  No entanto, os recursos de diferentes idiomas afetam sua implementa√ß√£o, e somente ent√£o as extens√µes aumentam os pontos fortes das implementa√ß√µes selecionadas.  Isso significa que existem duas fam√≠lias de idiomas baseadas em abordagens diferentes para o tempo de execu√ß√£o: tabelas de m√©todos virtuais (vtables) e transfer√™ncia de dicion√°rio. <br><br><h3>  Tabelas de m√©todo de interface </h3><br>  Se queremos fornecer fun√ß√µes espec√≠ficas de tipo, aderindo √† estrat√©gia de empacotamento em prol do trabalho unificado com tudo, √© suficiente ter uma maneira unificada de encontrar fun√ß√µes semelhantes que precisamos obter do objeto.  Essa abordagem √© chamada de "tabelas de m√©todos virtuais" (vtables, tabelas de m√©todos virtuais), embora ningu√©m use o nome completo.  Ele √© implementado da seguinte maneira: em um deslocamento zero em cada objeto de estrutura gen√©rica, h√° um ponteiro para uma tabela de ponteiros de fun√ß√£o com um circuito consistente.  Nessas tabelas, o c√≥digo gen√©rico procura ponteiros para fun√ß√µes espec√≠ficas de tipo, indexando ponteiros espec√≠ficos em deslocamentos fixos. <br><br>  √â assim que os tipos de <code>interface</code> s√£o implementados nos objetos Go e <code>dyn trait</code> no Rust.  Quando voc√™ converte um tipo para um tipo de interface do que implementa, um wrapper √© criado para a interface que cont√©m um ponteiro para o objeto de origem e um ponteiro para a tabela de fun√ß√µes espec√≠ficas de tipo.  Mas isso requer um n√≠vel adicional de endere√ßamento indireto de ponteiros e outro esquema.  Portanto, a classifica√ß√£o em Go usa a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface do cont√™iner com o m√©todo Swap</a> e n√£o pega a fatia da interface Comparable, porque isso exigiria colocar na mem√≥ria uma fatia completamente nova dos tipos de interface que seriam classificados em vez da fatia original! <br><br><h3>  Programa√ß√£o orientada a objetos </h3><br>  OOP √© uma propriedade de linguagem que faz bom uso dos recursos das tabelas de tipos virtuais.  Em vez de objetos de interface separados com vtables, linguagens OOP como Java simplesmente inserem um ponteiro em uma tabela de tipos virtuais no in√≠cio de cada objeto.  Linguagens do tipo Java possuem um sistema de heran√ßa e interfaces que podem ser totalmente implementadas usando essas tabelas de objetos do tipo virtual. <br><br>  Al√©m de fornecer recursos adicionais, a incorpora√ß√£o de vtable em cada objeto resolve o problema da necessidade de construir novos tipos de interface com endere√ßamento indireto.  Ao contr√°rio de Go, em Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, a fun√ß√£o de classifica√ß√£o</a> pode aplicar a interface <code>Comparable</code> aos tipos que implementa. <br><br><h3>  Reflex√£o </h3><br>  Se voc√™ possui tabelas de tipos virtuais, n√£o ser√° dif√≠cil for√ßar o compilador a gerar tabelas de outros tipos de informa√ß√µes, por exemplo, nomes de campos, tipos e locais.  Isso permitir√° o acesso a todos os dados desse tipo usando um c√≥digo que pode exibir todos os dados de qualquer outro tipo.  Esse comportamento pode ser usado para adicionar "reflex√£o" ao idioma, o que permite serializa√ß√£o e exibi√ß√£o bonita de tipos arbitr√°rios.  A reflex√£o, como uma extens√£o do paradigma de empacotamento, tem uma desvantagem: para isso, apenas uma c√≥pia do c√≥digo √© suficiente, mas voc√™ precisa executar muitas pesquisas din√¢micas, o que reduz a velocidade da serializa√ß√£o. <br><br>  Linguagens que usam reflex√£o para serializa√ß√£o e outras fun√ß√µes: Java, C # e Go. <br><br><h3>  Idiomas de tipo din√¢mico </h3><br>  O Reflection √© uma ferramenta muito poderosa que permite resolver v√°rias tarefas de metaprograma√ß√£o.  Mas isso n√£o permite que voc√™ crie novos tipos ou edite informa√ß√µes sobre os tipos de valores existentes.  Se adicionarmos esse recurso e fizermos com que as sintaxes de acesso e modifica√ß√£o de dados usem reflex√£o por padr√£o, obteremos linguagens dinamicamente digitadas!  A incr√≠vel flexibilidade da metaprograma√ß√£o em linguagens como Python e Ruby surgiu gra√ßas aos sistemas de reflex√£o eficazes e poderosos que s√£o usados ‚Äã‚Äãpara resolver qualquer problema. <br><br>  Voc√™ pode dizer: ‚ÄúMas linguagens din√¢micas n√£o funcionam assim, elas apenas implementam tudo usando tabelas de hash!‚Äù  As tabelas de hash s√£o apenas uma boa estrutura de dados para criar tabelas edit√°veis ‚Äã‚Äãcom informa√ß√µes de tipo.  Al√©m disso, alguns int√©rpretes, como o CPython, funcionam dessa maneira.  Em um JIT de alto desempenho, por exemplo, V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existem muitas tabelas de tipos virtuais e</a> informa√ß√µes de reflex√£o.  Na V8, as classes ocultas (vtables e informa√ß√µes de reflex√£o) e a estrutura dos objetos s√£o semelhantes √†s que voc√™ pode ver na Java VM, com a capacidade de substituir objetos por novas tabelas de tipos virtuais em tempo de execu√ß√£o.  Isso n√£o √© uma coincid√™ncia, porque n√£o h√° coincid√™ncias: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criador da V8</a> costumava <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalhar na Java VM de alto desempenho</a> . <br><br><h3>  Transfer√™ncia de dicion√°rio </h3><br>  Outra maneira de implementar interfaces din√¢micas √© transferir uma tabela com os ponteiros de fun√ß√£o necess√°rios para a fun√ß√£o gen√©rica que precisa deles.  Isso √© algo semelhante √† constru√ß√£o de objetos de interface em forma de Go no local da chamada, apenas no nosso caso a tabela √© passada como um argumento oculto e n√£o empacotada em um pacote configur√°vel como um dos argumentos existentes. <br><br>  Essa abordagem √© usada nas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classes de tipo em Haskell</a> , embora o GHC permita executar algum tipo de monomorfiza√ß√£o usando inlining e especializa√ß√£o.  O OCaml usa a transfer√™ncia de dicion√°rio com um argumento expl√≠cito na forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de m√≥dulos de primeira classe</a> , mas j√° foi proposto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionar a capacidade de tornar o par√¢metro impl√≠cito</a> . <br><br><h3>  Tabelas de testemunhas em Swift </h3><br>  Os autores do Swift usaram uma solu√ß√£o interessante: transferir o dicion√°rio, al√©m de colocar dados sobre os tamanhos dos tipos e como mov√™-los, copi√°-los e liber√°-los na tabela, permite fornecer todas as informa√ß√µes necess√°rias para o trabalho unificado com qualquer tipo sem embal√°-los.  Assim, o Swift pode implementar gen√©ricos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sem monomorfiza√ß√£o e coloca√ß√£o na mem√≥ria em uma representa√ß√£o unificada de</a> todas as entidades!  Sim, voc√™ precisa pagar por pesquisas din√¢micas, como √© caracter√≠stico de toda a fam√≠lia que usa embalagens, mas economiza recursos para posicionamento na mem√≥ria, consumo e inconsist√™ncia no cache.  Usando as fun√ß√µes <a href="">anotadas como @inlinable</a> , o compilador Swift tamb√©m pode se especializar (monomorfizar) e gen√©ricos em linha dentro de um m√≥dulo ou entre m√≥dulos para evitar as despesas mencionadas.  Provavelmente, √© usada uma avalia√ß√£o heur√≠stica do efeito no tamanho do c√≥digo. <br><br>  Isso tamb√©m explica como o Swift pode <a href="">implementar a estabilidade da ABI</a> , enquanto ainda permite adicionar e redistribuir campos na estrutura, embora os autores forne√ßam o atributo <code>@frozen</code> para recusar pesquisas din√¢micas para obter melhor desempenho. <br><br><h3>  An√°lise Intensiva de Tipo </h3><br>  H√° outra maneira de implementar interfaces para tipos de pacotes.  Adicionamos o identificador de tipo a uma determinada parte do objeto, seguindo o exemplo do ponteiro vtable, e depois geramos fun√ß√µes para cada m√©todo de interface que possui uma express√£o de <code>switch</code> grande para todos os tipos que implementam esse m√©todo e o transmitimos ao m√©todo espec√≠fico espec√≠fico do tipo. <br><br>  N√£o me importo com o uso de linguagens que usam essa abordagem, mas os compiladores C ++ e as m√°quinas virtuais Java agem de maneira semelhante. Ao usar a otimiza√ß√£o baseada em perfis, eles descobrem que um determinado local de chamada de gen√©ricos geralmente funciona com objetos de certos tipos.  Compiladores e VMs substituem os pontos de chamada pelas verifica√ß√µes de cada tipo comum e depois despacham estaticamente esses tipos, como um fallback usando o despacho din√¢mico convencional.  Portanto, o algoritmo de previs√£o de ramifica√ß√£o pode prever em qual ramifica√ß√£o o c√≥digo continuar√° e continuar√° a despachar instru√ß√µes usando chamadas est√°ticas. <br><br><h2>  Monomorfiza√ß√£o </h2><br>  Esta √© uma alternativa √† embalagem.  Com a monomorfiza√ß√£o, precisamos encontrar uma maneira de gerar v√°rias vers√µes do c√≥digo para cada tipo que queremos usar.  Os compiladores t√™m v√°rias fases de apresenta√ß√£o pelas quais o c√≥digo passa e, teoricamente, podem ser copiados para qualquer um desses est√°gios. <br><br><h3>  Gera√ß√£o de c√≥digo fonte </h3><br>  A maneira mais f√°cil de monomorfizar √© copiar no primeiro est√°gio da apresenta√ß√£o: copie o c√≥digo fonte!  Em seguida, o compilador nem precisa oferecer suporte a gen√©ricos, e isso √†s vezes √© feito por usu√°rios das linguagens C e Go, cujos compiladores n√£o t√™m esse suporte. <br><br>  Em C, voc√™ pode usar um pr√©-processador e definir a estrutura de dados em uma macro ou cabe√ßalho, inserindo-o repetidamente com <code>#define</code> diferente.  O Go possui scripts como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">genny</a> que facilitam a gera√ß√£o de c√≥digo. <br><br>  A desvantagem de duplicar o c√≥digo-fonte √© que, dependendo do idioma, pode ser necess√°rio lidar com v√°rios problemas e casos extremos, al√©m disso, o compilador analisa muitas vezes e verifica os tipos para praticamente o mesmo c√≥digo.  Novamente, dependendo do idioma e das ferramentas, esses gen√©ricos de m√©todos podem ser dif√≠ceis de escrever e usar, como se dentro de uma macro C cada linha terminasse com uma barra invertida e todos os tipos e nomes de fun√ß√µes fossem colados manualmente em seus identificadores para evitar colis√µes. <br><br><h3>  Mixins de strings em D </h3><br>  No entanto, a gera√ß√£o de c√≥digo tem suas vantagens, como o fato de que voc√™ pode gerar c√≥digo usando uma linguagem de programa√ß√£o completa, al√©m de usar uma exibi√ß√£o familiar para os usu√°rios. <br><br>  Alguns idiomas nos quais os gen√©ricos s√£o implementados de maneira diferente tamb√©m permitem gerar c√≥digo para casos de metaprograma√ß√£o mais gerais que n√£o s√£o considerados em seus sistemas gen√©ricos, por exemplo, para serializa√ß√£o.  O exemplo mais compreens√≠vel s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mixins de strings em D</a> , que permitem compilar o c√≥digo D na forma de valores de strings no meio da compila√ß√£o, usando todos os recursos do idioma. <br><br><h3>  Macros processuais de ferrugem </h3><br>  Um exemplo semelhante, apenas com uma representa√ß√£o no compilador em apenas um est√°gio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As macros de procedimento da Rust</a> usam fluxos de token como entrada e sa√≠da, fornecendo utilit√°rios para converter esses fluxos em string e vice-versa.  A vantagem dessa abordagem √© que os fluxos de token podem armazenar informa√ß√µes de localiza√ß√£o do c√≥digo-fonte.  O c√≥digo escrito pelo usu√°rio, a macro pode ser inserida como tokens diretamente da entrada para o fim de semana.  E se esse c√≥digo levar a um erro de compila√ß√£o na sa√≠da dos macos, o compilador exibir√° uma mensagem e apontar√° com precis√£o para o arquivo, linha e coluna da parte quebrada do c√≥digo.  Mas se a macro gerar um c√≥digo quebrado, uma mensagem de erro indicar√° uma chamada de macro.  Por exemplo, se voc√™ usar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">macro que agrupa uma fun√ß√£o no registro de chamadas</a> e comete um erro na implementa√ß√£o de uma fun√ß√£o agrupada, a mensagem de erro apontar√° diretamente para o erro no arquivo e n√£o para o c√≥digo gerado pela macro. <br><br><h3>  Macros de √°rvore de sintaxe </h3><br>  Alguns idiomas v√£o ainda mais longe e oferecem ferramentas para usar e criar diferentes tipos de √°rvores de sintaxe abstrata em macros (Abstract Syntax Tree, AST).  Exemplos incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Template Haskell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">macros Nim</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OCaml PPX</a> e quase todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lisp</a> . <br><br>  A desvantagem das macros AST √© que voc√™ n√£o deseja for√ßar os usu√°rios a aprender v√°rias fun√ß√µes para criar tipos AST, bem como idiomas b√°sicos.  Na fam√≠lia de linguagens Lisp, isso √© resolvido com a ajuda de uma forte simplifica√ß√£o e a m√°xima correspond√™ncia entre a sintaxe e a estrutura do AST; no entanto, nem sempre √© f√°cil criar estruturas. <br><br>  Assim, em todas as linguagens que mencionei, de uma forma ou de outra, existe uma primitiva de "cita√ß√£o" na qual voc√™ fornece um peda√ßo de c√≥digo na linguagem, e que retorna uma √°rvore de sintaxe.  Essas primitivas podem mesclar os valores da √°rvore de sintaxe usando a semelhan√ßa da interpola√ß√£o de cadeias.  Aqui est√° um exemplo no Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> ,    ,  </a> ! <br><br><h3>  Padr√µes </h3><br>    ‚Äî        .   ++  D    ,         ¬´ ¬ª.        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C++20  ¬´¬ª</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      ¬´    ¬ª. , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terra</a>    ,   . Terra ‚Äî   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     ‚Äî  Swift  Haskell. <br><br>  Rust      ¬´ ¬ª (trait bounds). <code>Trait</code> ‚Äî      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        ‚Äî          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461321/">https://habr.com/ru/post/pt461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461307/index.html">Convidamos voc√™ para o VK Hackathon 2019. O pr√™mio total deste ano √© de dois milh√µes de rublos.</a></li>
<li><a href="../pt461309/index.html">Tudo, exceto Kotlin: Andrei Breslav sobre o equil√≠brio de g√™nero em TI, emo√ß√µes e muito mais</a></li>
<li><a href="../pt461313/index.html">Lan√ßamento do Zimbra 8.8.15 LTS</a></li>
<li><a href="../pt461317/index.html">9 princ√≠pios para criar aplicativos iOS de qualidade</a></li>
<li><a href="../pt461319/index.html">O que um designer de jogos faz?</a></li>
<li><a href="../pt461323/index.html">Uma explica√ß√£o acess√≠vel do algoritmo de colapso da fun√ß√£o de onda</a></li>
<li><a href="../pt461325/index.html">Vit√≥ria na PHDays 9. Compartilhamos hacks em tr√™s partes. Parte 3</a></li>
<li><a href="../pt461327/index.html">Crise de front-end?</a></li>
<li><a href="../pt461329/index.html">Segmenta√ß√£o autom√°tica de √≥rg√£os respirat√≥rios</a></li>
<li><a href="../pt461333/index.html">ITX5 mitap: JAVA ao vivo, magia Kotlin e tinder de tomate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>