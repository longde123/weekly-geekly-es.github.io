<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 🚛 ❇️ Kennen Sie Ihre JIT: näher am Auto 🧙🏽 👩🏻‍🚒 🔽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bevor der von uns geschriebene Code ausgeführt wird, ist es ein ziemlich langer Weg. Andrey Melikhov hat in seinem Bericht zu RIT ++ 2018 jeden Schrit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kennen Sie Ihre JIT: näher am Auto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Bevor der von uns geschriebene Code ausgeführt wird, ist es ein ziemlich langer Weg.  <strong>Andrey Melikhov hat</strong> in seinem Bericht zu RIT ++ 2018 jeden Schritt auf diesem Weg am Beispiel der V8-Engine untersucht.  Kommen Sie unter die Katze, um herauszufinden, was uns ein tiefes Verständnis der Prinzipien des Compilers gibt und wie Sie JavaScript-Code produktiver machen können. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Wir werden herausfinden, ob WASM eine Silberkugel zur Verbesserung der Codeleistung ist und ob Optimierungen immer gerechtfertigt sind. <br><br>  <strong><em>Spoiler:</em></strong> „Vorzeitige Optimierung ist die Wurzel aller Krankheiten“, Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>Über den Sprecher:</em></strong> Andrei Melikhov arbeitet bei Yandex.Money, schreibt aktiv auf Node.js und weniger im Browser, sodass Server-JavaScript näher bei ihm ist.  Andrew unterstützt und entwickelt die devShacht-Community. Schauen Sie sich also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium an</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivation und Glossar</strong> </h2><br>  Heute werden wir über die JIT-Kompilierung sprechen.  Ich denke, das ist interessant für dich, da du das liest.  Lassen Sie uns jedoch klären, warum Sie wissen müssen, was JIT ist und wie V8 funktioniert, und warum das Schreiben von React in einem Browser nicht ausreicht. <br><br><ul><li>  Ermöglicht das <strong>Schreiben von effizienterem Code</strong> , da unsere Sprache spezifisch ist. </li><li>  <strong>Es zeigt Rätsel,</strong> warum der Code in den Bibliotheken anderer Leute so geschrieben ist und nicht anders.  Manchmal stoßen wir auf alte Bibliotheken und sehen, dass das, was dort geschrieben steht, irgendwie seltsam ist, aber wenn dies notwendig ist, ist es nicht notwendig - es ist nicht klar.  Wenn Sie wissen, wie es funktioniert, verstehen Sie, warum dies getan wurde. <br></li><li>  <strong>Das ist einfach interessant</strong> .  Darüber hinaus können wir verstehen, was Axel Rauschmeier, Benedict Moyrer und Dan Abramov auf Twitter kommunizieren. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Laut Wikipedia ist JavaScript eine hochinterpretierte Programmiersprache mit dynamischer Typisierung.  Wir werden uns mit diesen Bedingungen befassen. <br><br>  <strong>Zusammenstellung und Interpretation</strong> <br><br>  Kompilierung - Wenn das Programm in Binärcode geliefert wird und zunächst für die Umgebung optimiert ist, in der es funktionieren wird. <br><br>  Interpretation - wenn wir den Code so liefern, wie er ist. <br><br>  JavaScript wird so geliefert, wie es ist - es ist eine interpretierte Sprache, wie sie auf Wikipedia geschrieben ist. <br><br>  <strong>Dynamische und statische Eingabe</strong> <br><br>  Statische und dynamische Typisierung wird oft mit schwacher und starker Typisierung verwechselt.  Zum Beispiel ist C eine Sprache mit statisch schwacher Typisierung.  JavaScript hat eine schwache dynamische Typisierung. <br><br>  Welches ist besser?  Wenn das Programm kompiliert wird, ist es auf die Umgebung ausgerichtet, in der es ausgeführt wird, was bedeutet, dass es besser funktioniert.  Durch statische Eingabe wird dieser Code effizienter.  In JavaScript ist das Gegenteil der Fall. <br><br>  Gleichzeitig wird unsere Anwendung immer komplexer: Sowohl auf dem Client als auch auf dem Server erscheinen auf Node.js riesige Cluster, die einwandfrei funktionieren und Java-Anwendungen ersetzen. <br><br>  Aber wie funktioniert das alles, wenn es zunächst ein Verlierer zu sein scheint? <br><br><blockquote>  JIT wird alle versöhnen!  Oder zumindest versuchen. </blockquote><br>  Wir haben eine JIT (Just In Time Compilation), die zur Laufzeit stattfindet.  Wir werden über sie sprechen. <br><br><h3>  <strong>Js Motoren</strong> </h3><br><ul><li>  Ungeliebtes Chakra, das sich im Internet Explorer befindet.  Es funktioniert nicht einmal mit JavaScript, sondern mit Jscript - es gibt eine solche Teilmenge. <br></li><li>  Modernes Chakra und ChakraCore, die in Edge funktionieren; <br></li><li>  SpiderMonkey in FireFox; </li><li>  JavaScriptCore in WebKit.  Es wird auch in React Native verwendet.  Wenn Sie eine RN-Anwendung für Android haben, läuft diese auch auf JavaScriptCore - die Engine wird mit der Anwendung geliefert. <br></li><li>  V8 ist mein Favorit.  Es ist nicht das Beste, ich arbeite nur mit Node.js, in dem es die Haupt-Engine ist, wie in allen Chrome-basierten Browsern. <br></li><li>  Rhino und Nashorn sind die in Java verwendeten Engines.  Mit ihrer Hilfe können Sie dort auch JavaScript ausführen. <br></li><li>  JerryScript - für eingebettete Geräte; <br></li><li>  und andere... </li></ul><br>  Sie können Ihre eigene Engine schreiben, aber wenn Sie sich einer effektiven Ausführung nähern, kommen Sie zu ungefähr demselben Schema, das ich später zeigen werde. <br><br>  Heute werden wir über den V8 sprechen, und ja, er ist nach dem 8-Zylinder-Motor benannt. <br><br><h2>  <strong>Wir klettern unter die Haube</strong> </h2><br>  Wie wird Javascript ausgeführt? <br><br><ul><li>  In JavaScript ist Code enthalten, der mitgeliefert wird. <br></li><li>  er analysiert; </li><li>  wird ausgeführt; </li><li>  das Ergebnis wird erhalten. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  Durch das Parsen wird Code in einen <strong>abstrakten Syntaxbaum umgewandelt</strong> .  AST ist eine Anzeige der syntaktischen Struktur des Codes in Form eines Baums.  Dies ist eigentlich praktisch für das Programm, obwohl es schwer zu lesen ist. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Das Abrufen eines Array-Elements mit Index 1 in Form eines Baums wird als Operator und zwei Operanden dargestellt: Laden Sie die Eigenschaft mit dem Schlüssel und diesen Schlüsseln. <br><br><h3>  <strong>Wo wird AST eingesetzt?</strong> </h3><br>  AST ist nicht nur in Motoren.  Mit AST schreiben viele Dienstprogramme Erweiterungen, darunter: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Schöner </li><li>  Jscodeshift. </li></ul><br>  Mit der coolen Sache Jscodeshift, über die noch nicht jeder Bescheid weiß, können Sie beispielsweise Transformationen schreiben.  Wenn Sie die API einer Funktion ändern, können Sie diese Transformationen festlegen und Änderungen im gesamten Projekt vornehmen. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Wir gehen weiter.  Der Prozessor versteht den abstrakten Syntaxbaum nicht und benötigt <strong>Maschinencode</strong> .  Daher findet eine weitere Transformation durch den Interpreter statt, da die Sprache interpretiert wird. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  So war es, während Browser ein bisschen JavaScript hatten - markieren Sie die Zeile, öffnen Sie etwas, schließen Sie.  Aber jetzt haben wir Anwendungen - SPA, Node.js, und der <strong>Interpreter wird zu einem Engpass</strong> . <br><br><h2>  <strong>JIT-Compiler optimieren</strong> </h2><br>  Anstelle eines Interpreters wird ein optimierender JIT-Compiler angezeigt, dh ein Just-in-Time-Compiler.  Ahead-of-Time-Compiler arbeiten vor der Anwendungsausführung und JIT - während.  In Bezug auf das Optimierungsproblem versucht der JIT-Compiler zu erraten, wie der Code ausgeführt wird, welche Typen verwendet werden, und den Code so zu optimieren, dass er besser funktioniert. <br><br>  Eine solche Optimierung wird als <strong>spekulativ bezeichnet</strong> , da sie über das Wissen darüber <strong>spekuliert</strong> , was zuvor mit dem Code geschehen ist.  Das heißt, wenn etwas mit dem Nummerntyp zehnmal aufgerufen wurde, glaubt der Compiler, dass dies die ganze Zeit passieren wird, und optimiert für diesen Typ. <br><br>  Wenn Boolean in die Eingabe eingeht, tritt natürlich eine Deoptimierung auf.  Stellen Sie sich eine Funktion vor, die Zahlen hinzufügt. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Einmal gefaltet, das zweite Mal.  Der Compiler erstellt die Vorhersage: "Dies sind Zahlen, ich habe eine coole Lösung zum Hinzufügen von Zahlen!"  Und Sie schreiben <code>foo('WTF', 'JS')</code> und übergeben die Zeilen an die Funktion - wir haben JavaScript, wir können eine Zeile mit einer Zahl hinzufügen. <br><br>  Zu diesem Zeitpunkt tritt eine Deoptimierung auf. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Also wurde der Interpreter durch den Compiler ersetzt.  Das obige Diagramm scheint eine sehr einfache Pipeline zu haben.  In Wirklichkeit ist alles etwas anders. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  Das war bis letztes Jahr.  Letztes Jahr konnte man viele Berichte von Google hören, dass sie eine neue Pipeline mit TurboFan gestartet haben, und jetzt sieht das Schema einfacher aus. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Interessanterweise erschien hier ein Dolmetscher. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  Ein Interpreter wird benötigt, um einen abstrakten Syntaxbaum in einen Bytecode umzuwandeln und den Bytecode an einen Compiler zu übergeben.  Im Falle einer Deoptimierung geht er erneut zum Dolmetscher. <br><br><h2>  <strong>Dolmetscherzündung</strong> </h2><br>  Bisher gab es kein Ignition-Interpreter-Schema.  Google sagte zunächst, dass kein Dolmetscher benötigt wird - JavaScript ist bereits kompakt und interpretierbar genug - wir werden nichts gewinnen. <br><br>  Das Team, das mit mobilen Anwendungen arbeitete, stieß jedoch auf das folgende Problem. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  In den Jahren 2013 bis 2014 nutzten die Menschen häufiger mobile Geräte, um auf das Internet zuzugreifen als auf den Desktop.  Grundsätzlich ist dies kein iPhone, sondern von einfacheren Geräten - sie haben wenig Speicher und einen schwachen Prozessor. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Oben sehen Sie eine grafische Darstellung der anfänglichen Analyse von 1 MB Code vor dem Starten des Interpreters.  Es ist zu sehen, dass der Desktop sehr viel gewinnt.  Das iPhone ist auch nicht schlecht, aber es hat eine andere Engine, und wir sprechen über V8, das in Chrome funktioniert. <br><br><blockquote>  Wussten Sie, dass Chrome auf dem iPhone weiterhin unter JavaScriptCore funktioniert? </blockquote><br>  Somit wird Zeit verschwendet - und dies ist nur eine Analyse, keine Ausführung - Ihre Datei wurde geladen und versucht zu verstehen, was darin geschrieben ist. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Wenn eine Deoptimierung auftritt, müssen Sie den Quellcode erneut verwenden, d. H.  es muss irgendwo aufbewahrt werden.  Es hat viel Gedächtnis gekostet. <br><br>  Somit hatte der Dolmetscher zwei Aufgaben: <br><br><ol><li>  Reduzieren Sie den Parsing-Overhead. <br></li><li>  Speicherverbrauch reduzieren. <br></li></ol><br>  Die Aufgaben wurden durch den Wechsel zu einem Bytecode-Interpreter gelöst. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode in Chrome ist ein Registriergerät mit einer Batterie</strong> .  SpiderMonkey hat eine gestapelte Maschine, dort befinden sich alle Daten auf dem Stapel, aber es gibt keine Register.  Hier sind sie. <br><br>  Wir werden nicht vollständig analysieren, wie dies funktioniert. Schauen Sie sich nur das Codefragment an. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Hier heißt es: Nehmen Sie den Wert, der in der Batterie liegt, und addieren Sie ihn zu dem Wert, der im Register <strong>a0</strong> liegt, <strong>dh</strong> in der Variablen <strong>a</strong> .  Über Typen ist hier noch nichts bekannt.  Wenn es sich um echten Assembler-Code handeln würde, würde er mit dem Verständnis geschrieben, welche Art von Verschiebungen sich im Speicher befinden und was sich darin befindet.  Hier ist nur eine Anweisung - nehmen Sie, was im Register <strong>a0 liegt,</strong> und addieren Sie es zu dem Wert, der in der Batterie liegt. <br><br>  Natürlich nimmt der Interpreter nicht nur den abstrakten Syntaxbaum und übersetzt ihn in Bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Es gibt auch Optimierungen, zum Beispiel die Beseitigung von totem Code. <br>  Wenn ein Codeabschnitt nicht aufgerufen wird, wird er weggeworfen und nicht weiter gespeichert.  Wenn Ignition zwei Zahlen hinzufügt, fügt er sie hinzu und lässt sie so, dass keine unnötigen Informationen gespeichert werden.  Erst danach wird der Bytecode erhalten. <br><br><h2>  <strong>Optimierung und Deoptimierung</strong> </h2><br><h3>  Kalte und heiße Züge </h3><br>  Dies ist das einfachste Thema. <br><br>  Kalte Funktionen sind solche, die einmal oder gar nicht aufgerufen wurden, heiße Funktionen sind solche, die mehrmals aufgerufen wurden.  Es ist unmöglich genau zu sagen, wie oft - zu jedem Zeitpunkt kann dies wiederholt werden.  Aber irgendwann wird die Funktion heiß und der Motor versteht, dass sie optimiert werden muss. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  Das Arbeitsschema. <br><br><ul><li>  Zündung (Dolmetscher) sammelt Informationen.  Er konvertiert nicht nur JavaScript in Bytecode, sondern versteht auch, welche Typen eingegangen sind, welche Funktionen heiß geworden sind, und erzählt dem Compiler davon. </li><li>  Es gibt eine Optimierung. </li><li>  Der Compiler führt den Code aus.  Alles funktioniert gut, aber hier kommt ein Typ an, den er nicht erwartet hat, er hat keinen Code, um mit diesem Typ zu arbeiten. </li><li>  Es kommt zu einer Deoptimierung.  Der Compiler greift auf den Ignition-Interpreter für diesen Code zu. </li></ul><br>  Dies ist ein normaler Zyklus, der ständig auftritt, aber nicht unendlich ist.  Irgendwann sagt der Motor: "Nein, es ist unmöglich zu optimieren" und beginnt ohne Optimierung auszuführen.  Es ist wichtig zu verstehen, dass Monomorphismus beobachtet werden muss. <br><br>  <strong>Monomorphismus</strong> ist, wenn immer die gleichen Typen zum Eingang Ihrer Funktion kommen.  Das heißt, wenn Sie ständig Zeichenfolgen erhalten, müssen Sie dort keinen Booleschen Wert übergeben. <br><br>  Aber was tun mit Objekten?  Objekte sind alle Objekte.  Wir haben Klassen, aber sie sind nicht real - es ist nur Zucker über dem Prototypmodell.  Aber innerhalb der Engine gibt es sogenannte versteckte Klassen. <br><br><h3>  Versteckte Klassen </h3><br>  Es gibt versteckte Klassen in allen Engines, nicht nur in V8.  Überall werden sie anders genannt, in Bezug auf V8 ist es Map. <br><br>  Alle von Ihnen erstellten Objekte haben versteckte Klassen.  Wenn Sie <br>  Wenn Sie sich den Speicherprofiler ansehen, werden Sie feststellen, dass es Elemente gibt, in denen die Liste der Elemente gespeichert ist, Eigenschaften, in denen die Eigenschaft gespeichert ist, und Map (normalerweise der erste Parameter), in der ein Link dazu in der ausgeblendeten Klasse angegeben ist. <br><br>  Map beschreibt die Struktur von Objekten, da in JavaScript die Eingabe grundsätzlich nur strukturell und nicht nominal möglich ist.  Wir können beschreiben, wie unser Objekt aussieht und wofür es funktioniert. <br><br>  Beim Löschen / Hinzufügen von Eigenschaften von Objekten mit ausgeblendeten Klassen ändert sich das Objekt und es wird ein neues zugewiesen.  Schauen wir uns den Code an. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Wir haben einen Konstruktor, der ein neues Objekt vom Typ Point erstellt. <br><br><ul><li>  Erstellen Sie ein Objekt. </li><li>  Binden Sie eine versteckte Klasse daran, die besagt, dass es sich um ein Objekt vom Typ Point handelt. </li><li>  Wir haben das x-Feld hinzugefügt - eine neue versteckte Klasse, die besagt, dass es sich um ein Objekt vom Typ Point handelt, bei dem der x-Wert an erster Stelle steht. </li><li>  Y hinzugefügt - die neuen versteckten Klassen, in denen x und dann y. </li><li>  Erstellt ein anderes Objekt - das gleiche passiert.  Das heißt, er bindet auch das, was bereits geschaffen wurde.  In diesem Moment sind diese beiden Objekte vom gleichen Typ (über versteckte Klassen). </li><li>  Wenn dem zweiten Objekt ein neues Feld hinzugefügt wird, wird im Objekt eine neue ausgeblendete Klasse angezeigt.  Für die Motoren p1 und p2 sind dies Objekte unterschiedlicher Klassen, da sie unterschiedliche Strukturen haben </li><li>  Wenn Sie das erste Objekt irgendwohin übertragen, tritt beim Übertragen des zweiten Objekts eine Deoptimierung auf.  Die erste bezieht sich auf eine versteckte Klasse, die zweite auf eine andere. </li></ul><br>  <strong>Wie kann ich nach versteckten Klassen suchen?</strong> <br><br>  In Node.js können Sie die Node-Allow-Natives-Syntax ausführen.  Dann haben Sie die Möglichkeit, Befehle in einer speziellen Syntax zu schreiben, die natürlich nicht in der Produktion verwendet werden kann.  Es sieht so aus: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Niemand garantiert, dass diese Befehle morgen funktionieren, sie sind nicht in der ECMAScript-Spezifikation enthalten, das ist alles zum Debuggen. <br><br>  Was ist Ihrer Meinung nach das Ergebnis des Aufrufs der% HaveSameMap-Funktion für zwei Objekte?  Die richtige Antwort ist falsch, weil einer ein Feld hat und der andere <strong>b</strong> .  Dies sind verschiedene Objekte.  Dieses Wissen kann für die Inline-Caches-Technik verwendet werden. <br><br><h3>  Inline-Caches </h3><br>  Wir rufen eine sehr einfache Funktion auf, die ein Feld von einem Objekt zurückgibt.  Die Rücksendung des Geräts scheint sehr einfach zu sein.  Wenn Sie sich jedoch die ECMAScript-Spezifikation ansehen, werden Sie feststellen, dass es eine große Liste der Schritte gibt, die Sie ausführen müssen, um das Feld vom Objekt abzurufen.  Denn wenn sich das Feld nicht im Objekt befindet, befindet es sich möglicherweise in seinem Prototyp.  Vielleicht ist es Setter, Getter und so weiter.  All dies muss überprüft werden. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  In diesem Fall hat das Objekt einen Link zur Karte, der besagt: Um das Feld <strong>x zu erhalten</strong> , müssen Sie einen Versatz um eins machen, und wir erhalten <strong>x</strong> .  Sie müssen nirgendwo klettern, in keinem Prototyp ist alles in der Nähe.  Inline-Caches verwenden dies. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Wenn wir die Funktion zum ersten Mal aufrufen, ist alles in Ordnung, der Interpreter hat die Optimierung durchgeführt </li><li>  Beim zweiten Aufruf wird ein monomorpher Zustand gespeichert. </li><li>  Ich rufe die Funktion ein drittes Mal auf und übergebe ein etwas anderes Objekt {x: 3, y: 1}.  Deoptimierung tritt auf, wenn erscheint, gehen wir in einen polymorphen Zustand über.  Jetzt weiß der Code, der diese Funktion ausführt, dass zwei verschiedene Arten von Objekten hineinfliegen können. </li><li>  Wenn wir mehrere Objekte mehrmals passieren, bleibt es in einem polymorphen Zustand und fügt neue ifs hinzu.  Aber irgendwann ergibt sich und geht in einen megamorphen Zustand über, d.h.  wann: "Zu viele verschiedene Typen kommen am Eingang an - ich weiß nicht, wie ich es optimieren soll!" </li></ul><br>  Es scheint, dass jetzt 4 polymorphe Zustände erlaubt sind, aber morgen können es 8 sein. Dies wird von den Entwicklern der Engine entschieden.  Wir bleiben besser in einem monomorphen, im Extremfall polymorphen Zustand.  Der Übergang zwischen monomorphen und polymorphen Zuständen ist teuer, da Sie zum Interpreter gehen, den Code erneut abrufen und erneut optimieren müssen. <br><br><h3>  Arrays </h3><br>  In JavaScript gibt es neben den spezifischen typisierten Arrays einen Typ <br>  Array.  Es gibt 6 davon im V8-Motor: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - nur ein gepacktes Array kleiner Ganzzahlen.  Es gibt Optimierungen für ihn. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS - ein gepacktes Array von Doppelelementen, es gibt auch Optimierungen dafür, aber langsamere. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - ein gepacktes Array, in dem sich Objekte, Zeichenfolgen und alles andere befinden.  Auch für ihn gibt es Optimierungen. <br><br>  Die folgenden drei Typen sind Arrays des gleichen Typs wie die ersten drei, jedoch mit Löchern: <br><br>  4. [1, / * Loch * /, 2, / * Loch * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * Loch * /, 2, / * Loch * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * hole * /, 'X'] // HOLEY_ELEMENTS <br><br>  Wenn in Ihren Arrays Löcher auftreten, werden Optimierungen weniger effizient.  Sie beginnen schlecht zu arbeiten, weil es unmöglich ist, dieses Array hintereinander zu durchlaufen und Iterationen zu sortieren.  Jeder nachfolgende Typ ist weniger optimiert <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  Im Diagramm wird alles oben Genannte schneller optimiert.  Das heißt, alle Ihre nativen Methoden - Map, Reduce, Sort - Inside sind gut optimiert.  Mit jedem Typ wird die Optimierung jedoch schlechter. <br><br>  Zum Beispiel kam ein einfaches Array [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] zum Eingang (typgepackte kleine Ganzzahl).  Wir haben dieses Array leicht geändert, indem wir ihm ein Double hinzugefügt haben - es ist in den Status PACKED_DOUBLE_ELEMENTS übergegangen.  Fügen Sie ein Objekt hinzu - wechseln Sie zum nächsten Status, dem grünen Rechteck PACKED_ELEMENTS.  Fügen Sie Löcher hinzu - wechseln Sie in den Status HOLEY_ELEMENTS.  Wir möchten den vorherigen Zustand wiederherstellen, damit er wieder „gut“ wird - wir löschen alles, was wir geschrieben haben, und bleiben im selben Zustand ... mit Löchern!  Das heißt, HOLEY_ELEMENTS unten rechts im Diagramm.  Zurück funktioniert das nicht.  Ihre Arrays können nur schlechter werden, aber nicht umgekehrt. <br><br><h2>  <strong>Array-ähnliches Objekt</strong> </h2><br>  Wir stoßen häufig auf Array-ähnliche Objekte - dies sind Objekte, die wie Arrays aussehen, weil sie ein Längenzeichen haben.  Tatsächlich sind sie wie eine Piratenkatze, das heißt, sie scheinen ähnlich zu sein, aber in Bezug auf die Effizienz des Rumkonsums ist eine Katze schlechter als ein Pirat.  Ebenso ist ein Array-ähnliches Objekt wie ein Array, jedoch nicht effizient. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Unsere beiden bevorzugten Array-ähnlichen Objekte sind Argumente und document.querySelectorAII.  Es gibt so schöne funktionale Dinge. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Wir haben eine Karte - wir haben sie aus dem Prototyp herausgerissen und können sie anscheinend verwenden.  Wenn jedoch kein Array zu seiner Eingabe gelangt ist, erfolgt keine Optimierung.  Unsere Engine ist nicht in der Lage, Objekte zu optimieren. <br><br>  Was muss getan werden? <br><br><ul><li>  Die Old-School-Option - durch Slice.call () wird ein echtes Array. </li><li>  Die moderne Option ist noch besser: schreiben (... ruhen), ein sauberes Array erhalten - keine Argumente - alles ist in Ordnung! </li></ul><br>  Mit querySelectorAll das Gleiche - aufgrund der Verbreitung können wir es in ein vollwertiges Array verwandeln und mit allen Optimierungen arbeiten. <br><br><h2>  <strong>Große Arrays</strong> </h2><br><blockquote>  <strong>Rätsel:</strong> neues Array (1000) vs Array = [] <br>  Welche Option ist besser: Erstellen Sie sofort ein großes Array und füllen Sie es mit 1000 Objekten in einer Schleife oder erstellen Sie ein leeres und füllen Sie es schrittweise? <br></blockquote><br>  <strong>Richtige Antwort:</strong> hängt von ab. <br><br>  Was ist der Unterschied? <br><br><ul><li>  Wenn wir auf die erste Weise ein Array erstellen und 1000 Elemente füllen, erstellen wir 1000 Löcher.  Dieses Array wird nicht optimiert.  Aber er wird schnell schreiben. <br></li><li>  Wenn Sie ein Array gemäß der zweiten Variante erstellen, wird ein wenig Speicher zugewiesen, wir schreiben beispielsweise 60 Elemente, ein wenig mehr Speicher wird zugewiesen usw. </li></ul><br>  Das heißt, im ersten Fall schreiben wir schnell - wir arbeiten langsam;  im zweiten schreiben wir langsam - wir arbeiten schnell. <br><br><h2>  <strong>Müllsammler</strong> </h2><br>  Der Müllsammler frisst auch ein wenig Zeit und Ressourcen.  Ohne tief zu tauchen, werde ich die häufigste Basis geben. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Unser generatives Modell hat einen <strong>Raum aus jungen und alten Objekten</strong> .  Das erstellte Objekt fällt in den Raum junger Objekte.  Nach einiger Zeit beginnt die Reinigung.  Wenn das Objekt nicht über Links von der Wurzel aus erreicht werden kann, kann es im Müll gesammelt werden.  Wenn das Objekt noch verwendet wird, wird es in den Bereich alter Objekte verschoben, der weniger häufig gereinigt wird.  Irgendwann werden jedoch die alten Objekte gelöscht. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  So funktioniert ein automatischer Garbage Collector - er bereinigt Objekte auf der Grundlage, dass keine Links zu ihnen vorhanden sind.  Dies sind zwei verschiedene Algorithmen. <br><br><ol><li>  <strong>Das Spülen</strong> ist schnell, aber nicht effektiv. <br></li><li>  <strong>Mark-Sweep</strong> ist langsam aber effizient. <br></li></ol><br>  Wenn Sie mit der Profilerstellung des Speicherverbrauchs in Node.js beginnen, erhalten Sie so etwas. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  Zuerst wächst es abrupt - das ist die Arbeit des Scavenge-Algorithmus.  Dann tritt ein scharfer Abfall auf - dieser Mark-Sweep-Algorithmus hat Müll im Raum alter Objekte gesammelt.  In diesem Moment beginnt sich alles etwas zu verlangsamen.  <strong>Sie können es nicht kontrollieren</strong> , weil Sie nicht wissen, wann es passieren wird.  Sie können nur die Größen anpassen. <br><br>  Daher verfügt die Pipeline über eine Speicherbereinigungsphase, die Zeit in Anspruch nimmt. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Noch schneller?</strong> </h2><br>  Schauen wir in die Zukunft.  Was tun als nächstes, wie schneller sein? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  In dieser Zeile hängen die Blockgrößen in etwa in der dafür benötigten Zeit zusammen. <br><br>  Das erste, was Menschen in den Sinn kommt, die von Bytecode gehört haben - senden Sie sofort einen Bytecode an die Eingabe und dekodieren Sie ihn, anstatt ihn zu analysieren -, ist schneller! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  Das Problem ist, dass der Bytecode jetzt anders ist.  Wie gesagt: in Safari eins, in FireFox ein anderes, in Chrome drittens.  Trotzdem haben Entwickler von Mozilla, Bloomberg und Facebook einen solchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorschlag unterbreitet</a> , aber dies ist die Zukunft. <br><br>  Es gibt ein weiteres Problem - Kompilieren, Optimieren und erneutes Optimieren, wenn der Compiler dies nicht erraten hat.  Stellen Sie sich vor, es gibt eine statisch typisierte Sprache an der Eingabe, die effektiven Code erzeugt, was bedeutet, dass keine Neuoptimierung mehr erforderlich ist, da das, was wir haben, bereits effizient ist.  Eine solche Eingabe kann nur einmal kompiliert und optimiert werden.  Der resultierende Code ist effizienter und wird schneller ausgeführt. <br><br>  Was kann man noch tun?  Stellen Sie sich vor, diese Sprache verfügt über eine manuelle Speicherverwaltung.  Dann brauchen Sie keinen Müllsammler.  Die Linie ist kürzer und schneller geworden. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Ratet mal, wie es aussieht?  <strong>WebAssembly</strong> ungefähr <br>  So funktioniert es: manuelle Speicherverwaltung, statisch typisiert <br>  Sprachen und schnelle Ausführung. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  Ist WebAssembly eine Silberkugel? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  Nein, weil es für JavaScript steht.  WASM kann noch nichts tun.  Er hat keinen Zugriff auf die DOM-API.  Es befindet sich in der JavaScript-Engine - in derselben Engine!  Es erledigt alles über JavaScript, sodass <strong>WASM Ihren Code nicht beschleunigt</strong> .  Es kann einzelne Berechnungen beschleunigen, aber Ihr Austausch zwischen JavaScript und WASM wird ein Engpass sein. <br><br>  Daher, während unsere Sprache JavaScript ist und nur es, und einige Hilfe von der Black Box. <br><br><h2>  <strong>Insgesamt</strong> </h2><br>  Es können drei Arten der Optimierung unterschieden werden. <br><br>  ● <strong>Algorithmische Optimierungen</strong> <br><br>  Es gibt einen Artikel von Vyacheslav Egorov, der einst V8 entwickelt hat und jetzt Dart entwickelt, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielleicht brauchen Sie Rust nicht, um Ihr JS zu beschleunigen</a> ".  Erzählen Sie kurz ihre Geschichte. <br><br>  Es gab eine JavaScript-Bibliothek, die nicht sehr schnell funktionierte.  Einige Leute haben es in Rust umgeschrieben, kompiliert und WebAssembly erhalten, und die Anwendung begann schneller zu arbeiten.  Vyacheslav Egorov als erfahrener JS-Entwickler beschloss, diese zu beantworten.  Er wandte algorithmische Optimierungen an und die JavaScript-Lösung wurde viel schneller als die Rust-Lösung.  Im Gegenzug haben diese Leute dies gesehen, die gleichen Optimierungen vorgenommen und erneut gewonnen, aber nicht sehr viel - es hängt von der Engine ab: In Mozilla haben sie gewonnen, in Chrome nicht. <br><br>  Heute haben wir nicht über algorithmische Optimierungen gesprochen, und Front-End-Renderings sprechen normalerweise nicht darüber.  Dies ist sehr schlecht, da die <strong>Algorithmen auch ermöglichen, dass der Code schneller ausgeführt wird</strong> .  Sie entfernen einfach die Zyklen, die Sie nicht benötigen. <br><br>  ● <strong>Sprachspezifische Optimierungen</strong> <br><br>  Darüber haben wir heute gesprochen: Unsere Sprache wird dynamisch typisiert interpretiert.  Wenn Sie wissen, wie Arrays, Objekte und Monomorphismus funktionieren, <strong>können Sie effizienten Code schreiben</strong> .  Dies muss bekannt und korrekt geschrieben sein. <br><br>  ● <strong>Motorspezifische Optimierungen</strong> <br><br>  Dies sind die gefährlichsten Optimierungen.  Wenn Ihr sehr kluger, aber nicht sehr kontaktfreudiger Entwickler, der viele solcher Optimierungen angewendet und niemandem davon erzählt hat, die Dokumentation nicht geschrieben hat, wird beim Öffnen des Codes nicht JavaScript angezeigt, sondern beispielsweise Crankshaft Script.  Das heißt, JavaScript wurde mit einem tiefen Verständnis der Funktionsweise des Kurbelwellenmotors vor zwei Jahren geschrieben.  Es funktioniert alles, wird aber jetzt nicht mehr benötigt. <br><br>  Daher müssen solche Optimierungen unbedingt dokumentiert und mit Tests abgedeckt werden, die ihre derzeitige Wirksamkeit belegen.  Sie müssen überwacht werden.  Sie müssen nur dann zu ihnen gehen, wenn Sie irgendwo wirklich langsamer geworden sind - ohne das Wissen über so tiefe Geräte können Sie einfach nicht auskommen.  Daher scheint der berühmte Satz von Donald Knuth logisch. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  Sie müssen nicht versuchen, harte Optimierungen zu implementieren, nur weil Sie positive Bewertungen darüber gelesen haben. <br><br>  Man sollte Angst vor solchen Optimierungen haben, unbedingt Metriken dokumentieren und belassen.  Sammeln Sie im Allgemeinen immer Metriken.  <strong>Metriken sind wichtig!</strong> <br><br>  <strong>Nützliche Links:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abstracts und Präsentation des Berichts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist los mit Monomorphismus?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was macht WebAssembly schnell?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Weg zum Verständnis des V8-Bytecodes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417459/">https://habr.com/ru/post/de417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417447/index.html">Expedition zu den mysteriösen Feenkreisen in der Namibwüste</a></li>
<li><a href="../de417449/index.html">Jurassic World: Können wir Dinosaurier wirklich wiederbeleben?</a></li>
<li><a href="../de417451/index.html">Fünf häufige Fehler für Anfänger</a></li>
<li><a href="../de417453/index.html">Organisation von Praktika für Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
<li><a href="../de417461/index.html">Ivan Tulup: asynchron in JS unter der Haube</a></li>
<li><a href="../de417463/index.html">Ein unerwartetes Treffen. Kapitel 17</a></li>
<li><a href="../de417465/index.html">Eine Übersicht über Textverknüpfungsmethoden</a></li>
<li><a href="../de417469/index.html">Fünf egoistische Gründe, reproduzierbar zu arbeiten</a></li>
<li><a href="../de417471/index.html">Einfaches Lot MK936 SMD. DIY Lötstation für SMD-Komponenten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>