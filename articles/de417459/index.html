<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèª üöõ ‚ùáÔ∏è Kennen Sie Ihre JIT: n√§her am Auto üßôüèΩ üë©üèª‚Äçüöí üîΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bevor der von uns geschriebene Code ausgef√ºhrt wird, ist es ein ziemlich langer Weg. Andrey Melikhov hat in seinem Bericht zu RIT ++ 2018 jeden Schrit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kennen Sie Ihre JIT: n√§her am Auto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Bevor der von uns geschriebene Code ausgef√ºhrt wird, ist es ein ziemlich langer Weg.  <strong>Andrey Melikhov hat</strong> in seinem Bericht zu RIT ++ 2018 jeden Schritt auf diesem Weg am Beispiel der V8-Engine untersucht.  Kommen Sie unter die Katze, um herauszufinden, was uns ein tiefes Verst√§ndnis der Prinzipien des Compilers gibt und wie Sie JavaScript-Code produktiver machen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Wir werden herausfinden, ob WASM eine Silberkugel zur Verbesserung der Codeleistung ist und ob Optimierungen immer gerechtfertigt sind. <br><br>  <strong><em>Spoiler:</em></strong> ‚ÄûVorzeitige Optimierung ist die Wurzel aller Krankheiten‚Äú, Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>√úber den Sprecher:</em></strong> Andrei Melikhov arbeitet bei Yandex.Money, schreibt aktiv auf Node.js und weniger im Browser, sodass Server-JavaScript n√§her bei ihm ist.  Andrew unterst√ºtzt und entwickelt die devShacht-Community. Schauen Sie sich also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium an</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivation und Glossar</strong> </h2><br>  Heute werden wir √ºber die JIT-Kompilierung sprechen.  Ich denke, das ist interessant f√ºr dich, da du das liest.  Lassen Sie uns jedoch kl√§ren, warum Sie wissen m√ºssen, was JIT ist und wie V8 funktioniert, und warum das Schreiben von React in einem Browser nicht ausreicht. <br><br><ul><li>  Erm√∂glicht das <strong>Schreiben von effizienterem Code</strong> , da unsere Sprache spezifisch ist. </li><li>  <strong>Es zeigt R√§tsel,</strong> warum der Code in den Bibliotheken anderer Leute so geschrieben ist und nicht anders.  Manchmal sto√üen wir auf alte Bibliotheken und sehen, dass das, was dort geschrieben steht, irgendwie seltsam ist, aber wenn dies notwendig ist, ist es nicht notwendig - es ist nicht klar.  Wenn Sie wissen, wie es funktioniert, verstehen Sie, warum dies getan wurde. <br></li><li>  <strong>Das ist einfach interessant</strong> .  Dar√ºber hinaus k√∂nnen wir verstehen, was Axel Rauschmeier, Benedict Moyrer und Dan Abramov auf Twitter kommunizieren. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Laut Wikipedia ist JavaScript eine hochinterpretierte Programmiersprache mit dynamischer Typisierung.  Wir werden uns mit diesen Bedingungen befassen. <br><br>  <strong>Zusammenstellung und Interpretation</strong> <br><br>  Kompilierung - Wenn das Programm in Bin√§rcode geliefert wird und zun√§chst f√ºr die Umgebung optimiert ist, in der es funktionieren wird. <br><br>  Interpretation - wenn wir den Code so liefern, wie er ist. <br><br>  JavaScript wird so geliefert, wie es ist - es ist eine interpretierte Sprache, wie sie auf Wikipedia geschrieben ist. <br><br>  <strong>Dynamische und statische Eingabe</strong> <br><br>  Statische und dynamische Typisierung wird oft mit schwacher und starker Typisierung verwechselt.  Zum Beispiel ist C eine Sprache mit statisch schwacher Typisierung.  JavaScript hat eine schwache dynamische Typisierung. <br><br>  Welches ist besser?  Wenn das Programm kompiliert wird, ist es auf die Umgebung ausgerichtet, in der es ausgef√ºhrt wird, was bedeutet, dass es besser funktioniert.  Durch statische Eingabe wird dieser Code effizienter.  In JavaScript ist das Gegenteil der Fall. <br><br>  Gleichzeitig wird unsere Anwendung immer komplexer: Sowohl auf dem Client als auch auf dem Server erscheinen auf Node.js riesige Cluster, die einwandfrei funktionieren und Java-Anwendungen ersetzen. <br><br>  Aber wie funktioniert das alles, wenn es zun√§chst ein Verlierer zu sein scheint? <br><br><blockquote>  JIT wird alle vers√∂hnen!  Oder zumindest versuchen. </blockquote><br>  Wir haben eine JIT (Just In Time Compilation), die zur Laufzeit stattfindet.  Wir werden √ºber sie sprechen. <br><br><h3>  <strong>Js Motoren</strong> </h3><br><ul><li>  Ungeliebtes Chakra, das sich im Internet Explorer befindet.  Es funktioniert nicht einmal mit JavaScript, sondern mit Jscript - es gibt eine solche Teilmenge. <br></li><li>  Modernes Chakra und ChakraCore, die in Edge funktionieren; <br></li><li>  SpiderMonkey in FireFox; </li><li>  JavaScriptCore in WebKit.  Es wird auch in React Native verwendet.  Wenn Sie eine RN-Anwendung f√ºr Android haben, l√§uft diese auch auf JavaScriptCore - die Engine wird mit der Anwendung geliefert. <br></li><li>  V8 ist mein Favorit.  Es ist nicht das Beste, ich arbeite nur mit Node.js, in dem es die Haupt-Engine ist, wie in allen Chrome-basierten Browsern. <br></li><li>  Rhino und Nashorn sind die in Java verwendeten Engines.  Mit ihrer Hilfe k√∂nnen Sie dort auch JavaScript ausf√ºhren. <br></li><li>  JerryScript - f√ºr eingebettete Ger√§te; <br></li><li>  und andere... </li></ul><br>  Sie k√∂nnen Ihre eigene Engine schreiben, aber wenn Sie sich einer effektiven Ausf√ºhrung n√§hern, kommen Sie zu ungef√§hr demselben Schema, das ich sp√§ter zeigen werde. <br><br>  Heute werden wir √ºber den V8 sprechen, und ja, er ist nach dem 8-Zylinder-Motor benannt. <br><br><h2>  <strong>Wir klettern unter die Haube</strong> </h2><br>  Wie wird Javascript ausgef√ºhrt? <br><br><ul><li>  In JavaScript ist Code enthalten, der mitgeliefert wird. <br></li><li>  er analysiert; </li><li>  wird ausgef√ºhrt; </li><li>  das Ergebnis wird erhalten. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  Durch das Parsen wird Code in einen <strong>abstrakten Syntaxbaum umgewandelt</strong> .  AST ist eine Anzeige der syntaktischen Struktur des Codes in Form eines Baums.  Dies ist eigentlich praktisch f√ºr das Programm, obwohl es schwer zu lesen ist. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Das Abrufen eines Array-Elements mit Index 1 in Form eines Baums wird als Operator und zwei Operanden dargestellt: Laden Sie die Eigenschaft mit dem Schl√ºssel und diesen Schl√ºsseln. <br><br><h3>  <strong>Wo wird AST eingesetzt?</strong> </h3><br>  AST ist nicht nur in Motoren.  Mit AST schreiben viele Dienstprogramme Erweiterungen, darunter: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Sch√∂ner </li><li>  Jscodeshift. </li></ul><br>  Mit der coolen Sache Jscodeshift, √ºber die noch nicht jeder Bescheid wei√ü, k√∂nnen Sie beispielsweise Transformationen schreiben.  Wenn Sie die API einer Funktion √§ndern, k√∂nnen Sie diese Transformationen festlegen und √Ñnderungen im gesamten Projekt vornehmen. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Wir gehen weiter.  Der Prozessor versteht den abstrakten Syntaxbaum nicht und ben√∂tigt <strong>Maschinencode</strong> .  Daher findet eine weitere Transformation durch den Interpreter statt, da die Sprache interpretiert wird. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  So war es, w√§hrend Browser ein bisschen JavaScript hatten - markieren Sie die Zeile, √∂ffnen Sie etwas, schlie√üen Sie.  Aber jetzt haben wir Anwendungen - SPA, Node.js, und der <strong>Interpreter wird zu einem Engpass</strong> . <br><br><h2>  <strong>JIT-Compiler optimieren</strong> </h2><br>  Anstelle eines Interpreters wird ein optimierender JIT-Compiler angezeigt, dh ein Just-in-Time-Compiler.  Ahead-of-Time-Compiler arbeiten vor der Anwendungsausf√ºhrung und JIT - w√§hrend.  In Bezug auf das Optimierungsproblem versucht der JIT-Compiler zu erraten, wie der Code ausgef√ºhrt wird, welche Typen verwendet werden, und den Code so zu optimieren, dass er besser funktioniert. <br><br>  Eine solche Optimierung wird als <strong>spekulativ bezeichnet</strong> , da sie √ºber das Wissen dar√ºber <strong>spekuliert</strong> , was zuvor mit dem Code geschehen ist.  Das hei√üt, wenn etwas mit dem Nummerntyp zehnmal aufgerufen wurde, glaubt der Compiler, dass dies die ganze Zeit passieren wird, und optimiert f√ºr diesen Typ. <br><br>  Wenn Boolean in die Eingabe eingeht, tritt nat√ºrlich eine Deoptimierung auf.  Stellen Sie sich eine Funktion vor, die Zahlen hinzuf√ºgt. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Einmal gefaltet, das zweite Mal.  Der Compiler erstellt die Vorhersage: "Dies sind Zahlen, ich habe eine coole L√∂sung zum Hinzuf√ºgen von Zahlen!"  Und Sie schreiben <code>foo('WTF', 'JS')</code> und √ºbergeben die Zeilen an die Funktion - wir haben JavaScript, wir k√∂nnen eine Zeile mit einer Zahl hinzuf√ºgen. <br><br>  Zu diesem Zeitpunkt tritt eine Deoptimierung auf. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Also wurde der Interpreter durch den Compiler ersetzt.  Das obige Diagramm scheint eine sehr einfache Pipeline zu haben.  In Wirklichkeit ist alles etwas anders. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  Das war bis letztes Jahr.  Letztes Jahr konnte man viele Berichte von Google h√∂ren, dass sie eine neue Pipeline mit TurboFan gestartet haben, und jetzt sieht das Schema einfacher aus. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Interessanterweise erschien hier ein Dolmetscher. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  Ein Interpreter wird ben√∂tigt, um einen abstrakten Syntaxbaum in einen Bytecode umzuwandeln und den Bytecode an einen Compiler zu √ºbergeben.  Im Falle einer Deoptimierung geht er erneut zum Dolmetscher. <br><br><h2>  <strong>Dolmetscherz√ºndung</strong> </h2><br>  Bisher gab es kein Ignition-Interpreter-Schema.  Google sagte zun√§chst, dass kein Dolmetscher ben√∂tigt wird - JavaScript ist bereits kompakt und interpretierbar genug - wir werden nichts gewinnen. <br><br>  Das Team, das mit mobilen Anwendungen arbeitete, stie√ü jedoch auf das folgende Problem. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  In den Jahren 2013 bis 2014 nutzten die Menschen h√§ufiger mobile Ger√§te, um auf das Internet zuzugreifen als auf den Desktop.  Grunds√§tzlich ist dies kein iPhone, sondern von einfacheren Ger√§ten - sie haben wenig Speicher und einen schwachen Prozessor. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Oben sehen Sie eine grafische Darstellung der anf√§nglichen Analyse von 1 MB Code vor dem Starten des Interpreters.  Es ist zu sehen, dass der Desktop sehr viel gewinnt.  Das iPhone ist auch nicht schlecht, aber es hat eine andere Engine, und wir sprechen √ºber V8, das in Chrome funktioniert. <br><br><blockquote>  Wussten Sie, dass Chrome auf dem iPhone weiterhin unter JavaScriptCore funktioniert? </blockquote><br>  Somit wird Zeit verschwendet - und dies ist nur eine Analyse, keine Ausf√ºhrung - Ihre Datei wurde geladen und versucht zu verstehen, was darin geschrieben ist. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Wenn eine Deoptimierung auftritt, m√ºssen Sie den Quellcode erneut verwenden, d. H.  es muss irgendwo aufbewahrt werden.  Es hat viel Ged√§chtnis gekostet. <br><br>  Somit hatte der Dolmetscher zwei Aufgaben: <br><br><ol><li>  Reduzieren Sie den Parsing-Overhead. <br></li><li>  Speicherverbrauch reduzieren. <br></li></ol><br>  Die Aufgaben wurden durch den Wechsel zu einem Bytecode-Interpreter gel√∂st. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode in Chrome ist ein Registrierger√§t mit einer Batterie</strong> .  SpiderMonkey hat eine gestapelte Maschine, dort befinden sich alle Daten auf dem Stapel, aber es gibt keine Register.  Hier sind sie. <br><br>  Wir werden nicht vollst√§ndig analysieren, wie dies funktioniert. Schauen Sie sich nur das Codefragment an. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Hier hei√üt es: Nehmen Sie den Wert, der in der Batterie liegt, und addieren Sie ihn zu dem Wert, der im Register <strong>a0</strong> liegt, <strong>dh</strong> in der Variablen <strong>a</strong> .  √úber Typen ist hier noch nichts bekannt.  Wenn es sich um echten Assembler-Code handeln w√ºrde, w√ºrde er mit dem Verst√§ndnis geschrieben, welche Art von Verschiebungen sich im Speicher befinden und was sich darin befindet.  Hier ist nur eine Anweisung - nehmen Sie, was im Register <strong>a0 liegt,</strong> und addieren Sie es zu dem Wert, der in der Batterie liegt. <br><br>  Nat√ºrlich nimmt der Interpreter nicht nur den abstrakten Syntaxbaum und √ºbersetzt ihn in Bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Es gibt auch Optimierungen, zum Beispiel die Beseitigung von totem Code. <br>  Wenn ein Codeabschnitt nicht aufgerufen wird, wird er weggeworfen und nicht weiter gespeichert.  Wenn Ignition zwei Zahlen hinzuf√ºgt, f√ºgt er sie hinzu und l√§sst sie so, dass keine unn√∂tigen Informationen gespeichert werden.  Erst danach wird der Bytecode erhalten. <br><br><h2>  <strong>Optimierung und Deoptimierung</strong> </h2><br><h3>  Kalte und hei√üe Z√ºge </h3><br>  Dies ist das einfachste Thema. <br><br>  Kalte Funktionen sind solche, die einmal oder gar nicht aufgerufen wurden, hei√üe Funktionen sind solche, die mehrmals aufgerufen wurden.  Es ist unm√∂glich genau zu sagen, wie oft - zu jedem Zeitpunkt kann dies wiederholt werden.  Aber irgendwann wird die Funktion hei√ü und der Motor versteht, dass sie optimiert werden muss. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  Das Arbeitsschema. <br><br><ul><li>  Z√ºndung (Dolmetscher) sammelt Informationen.  Er konvertiert nicht nur JavaScript in Bytecode, sondern versteht auch, welche Typen eingegangen sind, welche Funktionen hei√ü geworden sind, und erz√§hlt dem Compiler davon. </li><li>  Es gibt eine Optimierung. </li><li>  Der Compiler f√ºhrt den Code aus.  Alles funktioniert gut, aber hier kommt ein Typ an, den er nicht erwartet hat, er hat keinen Code, um mit diesem Typ zu arbeiten. </li><li>  Es kommt zu einer Deoptimierung.  Der Compiler greift auf den Ignition-Interpreter f√ºr diesen Code zu. </li></ul><br>  Dies ist ein normaler Zyklus, der st√§ndig auftritt, aber nicht unendlich ist.  Irgendwann sagt der Motor: "Nein, es ist unm√∂glich zu optimieren" und beginnt ohne Optimierung auszuf√ºhren.  Es ist wichtig zu verstehen, dass Monomorphismus beobachtet werden muss. <br><br>  <strong>Monomorphismus</strong> ist, wenn immer die gleichen Typen zum Eingang Ihrer Funktion kommen.  Das hei√üt, wenn Sie st√§ndig Zeichenfolgen erhalten, m√ºssen Sie dort keinen Booleschen Wert √ºbergeben. <br><br>  Aber was tun mit Objekten?  Objekte sind alle Objekte.  Wir haben Klassen, aber sie sind nicht real - es ist nur Zucker √ºber dem Prototypmodell.  Aber innerhalb der Engine gibt es sogenannte versteckte Klassen. <br><br><h3>  Versteckte Klassen </h3><br>  Es gibt versteckte Klassen in allen Engines, nicht nur in V8.  √úberall werden sie anders genannt, in Bezug auf V8 ist es Map. <br><br>  Alle von Ihnen erstellten Objekte haben versteckte Klassen.  Wenn Sie <br>  Wenn Sie sich den Speicherprofiler ansehen, werden Sie feststellen, dass es Elemente gibt, in denen die Liste der Elemente gespeichert ist, Eigenschaften, in denen die Eigenschaft gespeichert ist, und Map (normalerweise der erste Parameter), in der ein Link dazu in der ausgeblendeten Klasse angegeben ist. <br><br>  Map beschreibt die Struktur von Objekten, da in JavaScript die Eingabe grunds√§tzlich nur strukturell und nicht nominal m√∂glich ist.  Wir k√∂nnen beschreiben, wie unser Objekt aussieht und wof√ºr es funktioniert. <br><br>  Beim L√∂schen / Hinzuf√ºgen von Eigenschaften von Objekten mit ausgeblendeten Klassen √§ndert sich das Objekt und es wird ein neues zugewiesen.  Schauen wir uns den Code an. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Wir haben einen Konstruktor, der ein neues Objekt vom Typ Point erstellt. <br><br><ul><li>  Erstellen Sie ein Objekt. </li><li>  Binden Sie eine versteckte Klasse daran, die besagt, dass es sich um ein Objekt vom Typ Point handelt. </li><li>  Wir haben das x-Feld hinzugef√ºgt - eine neue versteckte Klasse, die besagt, dass es sich um ein Objekt vom Typ Point handelt, bei dem der x-Wert an erster Stelle steht. </li><li>  Y hinzugef√ºgt - die neuen versteckten Klassen, in denen x und dann y. </li><li>  Erstellt ein anderes Objekt - das gleiche passiert.  Das hei√üt, er bindet auch das, was bereits geschaffen wurde.  In diesem Moment sind diese beiden Objekte vom gleichen Typ (√ºber versteckte Klassen). </li><li>  Wenn dem zweiten Objekt ein neues Feld hinzugef√ºgt wird, wird im Objekt eine neue ausgeblendete Klasse angezeigt.  F√ºr die Motoren p1 und p2 sind dies Objekte unterschiedlicher Klassen, da sie unterschiedliche Strukturen haben </li><li>  Wenn Sie das erste Objekt irgendwohin √ºbertragen, tritt beim √úbertragen des zweiten Objekts eine Deoptimierung auf.  Die erste bezieht sich auf eine versteckte Klasse, die zweite auf eine andere. </li></ul><br>  <strong>Wie kann ich nach versteckten Klassen suchen?</strong> <br><br>  In Node.js k√∂nnen Sie die Node-Allow-Natives-Syntax ausf√ºhren.  Dann haben Sie die M√∂glichkeit, Befehle in einer speziellen Syntax zu schreiben, die nat√ºrlich nicht in der Produktion verwendet werden kann.  Es sieht so aus: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Niemand garantiert, dass diese Befehle morgen funktionieren, sie sind nicht in der ECMAScript-Spezifikation enthalten, das ist alles zum Debuggen. <br><br>  Was ist Ihrer Meinung nach das Ergebnis des Aufrufs der% HaveSameMap-Funktion f√ºr zwei Objekte?  Die richtige Antwort ist falsch, weil einer ein Feld hat und der andere <strong>b</strong> .  Dies sind verschiedene Objekte.  Dieses Wissen kann f√ºr die Inline-Caches-Technik verwendet werden. <br><br><h3>  Inline-Caches </h3><br>  Wir rufen eine sehr einfache Funktion auf, die ein Feld von einem Objekt zur√ºckgibt.  Die R√ºcksendung des Ger√§ts scheint sehr einfach zu sein.  Wenn Sie sich jedoch die ECMAScript-Spezifikation ansehen, werden Sie feststellen, dass es eine gro√üe Liste der Schritte gibt, die Sie ausf√ºhren m√ºssen, um das Feld vom Objekt abzurufen.  Denn wenn sich das Feld nicht im Objekt befindet, befindet es sich m√∂glicherweise in seinem Prototyp.  Vielleicht ist es Setter, Getter und so weiter.  All dies muss √ºberpr√ºft werden. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  In diesem Fall hat das Objekt einen Link zur Karte, der besagt: Um das Feld <strong>x zu erhalten</strong> , m√ºssen Sie einen Versatz um eins machen, und wir erhalten <strong>x</strong> .  Sie m√ºssen nirgendwo klettern, in keinem Prototyp ist alles in der N√§he.  Inline-Caches verwenden dies. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Wenn wir die Funktion zum ersten Mal aufrufen, ist alles in Ordnung, der Interpreter hat die Optimierung durchgef√ºhrt </li><li>  Beim zweiten Aufruf wird ein monomorpher Zustand gespeichert. </li><li>  Ich rufe die Funktion ein drittes Mal auf und √ºbergebe ein etwas anderes Objekt {x: 3, y: 1}.  Deoptimierung tritt auf, wenn erscheint, gehen wir in einen polymorphen Zustand √ºber.  Jetzt wei√ü der Code, der diese Funktion ausf√ºhrt, dass zwei verschiedene Arten von Objekten hineinfliegen k√∂nnen. </li><li>  Wenn wir mehrere Objekte mehrmals passieren, bleibt es in einem polymorphen Zustand und f√ºgt neue ifs hinzu.  Aber irgendwann ergibt sich und geht in einen megamorphen Zustand √ºber, d.h.  wann: "Zu viele verschiedene Typen kommen am Eingang an - ich wei√ü nicht, wie ich es optimieren soll!" </li></ul><br>  Es scheint, dass jetzt 4 polymorphe Zust√§nde erlaubt sind, aber morgen k√∂nnen es 8 sein. Dies wird von den Entwicklern der Engine entschieden.  Wir bleiben besser in einem monomorphen, im Extremfall polymorphen Zustand.  Der √úbergang zwischen monomorphen und polymorphen Zust√§nden ist teuer, da Sie zum Interpreter gehen, den Code erneut abrufen und erneut optimieren m√ºssen. <br><br><h3>  Arrays </h3><br>  In JavaScript gibt es neben den spezifischen typisierten Arrays einen Typ <br>  Array.  Es gibt 6 davon im V8-Motor: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - nur ein gepacktes Array kleiner Ganzzahlen.  Es gibt Optimierungen f√ºr ihn. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS - ein gepacktes Array von Doppelelementen, es gibt auch Optimierungen daf√ºr, aber langsamere. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - ein gepacktes Array, in dem sich Objekte, Zeichenfolgen und alles andere befinden.  Auch f√ºr ihn gibt es Optimierungen. <br><br>  Die folgenden drei Typen sind Arrays des gleichen Typs wie die ersten drei, jedoch mit L√∂chern: <br><br>  4. [1, / * Loch * /, 2, / * Loch * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * Loch * /, 2, / * Loch * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * hole * /, 'X'] // HOLEY_ELEMENTS <br><br>  Wenn in Ihren Arrays L√∂cher auftreten, werden Optimierungen weniger effizient.  Sie beginnen schlecht zu arbeiten, weil es unm√∂glich ist, dieses Array hintereinander zu durchlaufen und Iterationen zu sortieren.  Jeder nachfolgende Typ ist weniger optimiert <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  Im Diagramm wird alles oben Genannte schneller optimiert.  Das hei√üt, alle Ihre nativen Methoden - Map, Reduce, Sort - Inside sind gut optimiert.  Mit jedem Typ wird die Optimierung jedoch schlechter. <br><br>  Zum Beispiel kam ein einfaches Array [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] zum Eingang (typgepackte kleine Ganzzahl).  Wir haben dieses Array leicht ge√§ndert, indem wir ihm ein Double hinzugef√ºgt haben - es ist in den Status PACKED_DOUBLE_ELEMENTS √ºbergegangen.  F√ºgen Sie ein Objekt hinzu - wechseln Sie zum n√§chsten Status, dem gr√ºnen Rechteck PACKED_ELEMENTS.  F√ºgen Sie L√∂cher hinzu - wechseln Sie in den Status HOLEY_ELEMENTS.  Wir m√∂chten den vorherigen Zustand wiederherstellen, damit er wieder ‚Äûgut‚Äú wird - wir l√∂schen alles, was wir geschrieben haben, und bleiben im selben Zustand ... mit L√∂chern!  Das hei√üt, HOLEY_ELEMENTS unten rechts im Diagramm.  Zur√ºck funktioniert das nicht.  Ihre Arrays k√∂nnen nur schlechter werden, aber nicht umgekehrt. <br><br><h2>  <strong>Array-√§hnliches Objekt</strong> </h2><br>  Wir sto√üen h√§ufig auf Array-√§hnliche Objekte - dies sind Objekte, die wie Arrays aussehen, weil sie ein L√§ngenzeichen haben.  Tats√§chlich sind sie wie eine Piratenkatze, das hei√üt, sie scheinen √§hnlich zu sein, aber in Bezug auf die Effizienz des Rumkonsums ist eine Katze schlechter als ein Pirat.  Ebenso ist ein Array-√§hnliches Objekt wie ein Array, jedoch nicht effizient. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Unsere beiden bevorzugten Array-√§hnlichen Objekte sind Argumente und document.querySelectorAII.  Es gibt so sch√∂ne funktionale Dinge. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Wir haben eine Karte - wir haben sie aus dem Prototyp herausgerissen und k√∂nnen sie anscheinend verwenden.  Wenn jedoch kein Array zu seiner Eingabe gelangt ist, erfolgt keine Optimierung.  Unsere Engine ist nicht in der Lage, Objekte zu optimieren. <br><br>  Was muss getan werden? <br><br><ul><li>  Die Old-School-Option - durch Slice.call () wird ein echtes Array. </li><li>  Die moderne Option ist noch besser: schreiben (... ruhen), ein sauberes Array erhalten - keine Argumente - alles ist in Ordnung! </li></ul><br>  Mit querySelectorAll das Gleiche - aufgrund der Verbreitung k√∂nnen wir es in ein vollwertiges Array verwandeln und mit allen Optimierungen arbeiten. <br><br><h2>  <strong>Gro√üe Arrays</strong> </h2><br><blockquote>  <strong>R√§tsel:</strong> neues Array (1000) vs Array = [] <br>  Welche Option ist besser: Erstellen Sie sofort ein gro√ües Array und f√ºllen Sie es mit 1000 Objekten in einer Schleife oder erstellen Sie ein leeres und f√ºllen Sie es schrittweise? <br></blockquote><br>  <strong>Richtige Antwort:</strong> h√§ngt von ab. <br><br>  Was ist der Unterschied? <br><br><ul><li>  Wenn wir auf die erste Weise ein Array erstellen und 1000 Elemente f√ºllen, erstellen wir 1000 L√∂cher.  Dieses Array wird nicht optimiert.  Aber er wird schnell schreiben. <br></li><li>  Wenn Sie ein Array gem√§√ü der zweiten Variante erstellen, wird ein wenig Speicher zugewiesen, wir schreiben beispielsweise 60 Elemente, ein wenig mehr Speicher wird zugewiesen usw. </li></ul><br>  Das hei√üt, im ersten Fall schreiben wir schnell - wir arbeiten langsam;  im zweiten schreiben wir langsam - wir arbeiten schnell. <br><br><h2>  <strong>M√ºllsammler</strong> </h2><br>  Der M√ºllsammler frisst auch ein wenig Zeit und Ressourcen.  Ohne tief zu tauchen, werde ich die h√§ufigste Basis geben. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Unser generatives Modell hat einen <strong>Raum aus jungen und alten Objekten</strong> .  Das erstellte Objekt f√§llt in den Raum junger Objekte.  Nach einiger Zeit beginnt die Reinigung.  Wenn das Objekt nicht √ºber Links von der Wurzel aus erreicht werden kann, kann es im M√ºll gesammelt werden.  Wenn das Objekt noch verwendet wird, wird es in den Bereich alter Objekte verschoben, der weniger h√§ufig gereinigt wird.  Irgendwann werden jedoch die alten Objekte gel√∂scht. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  So funktioniert ein automatischer Garbage Collector - er bereinigt Objekte auf der Grundlage, dass keine Links zu ihnen vorhanden sind.  Dies sind zwei verschiedene Algorithmen. <br><br><ol><li>  <strong>Das Sp√ºlen</strong> ist schnell, aber nicht effektiv. <br></li><li>  <strong>Mark-Sweep</strong> ist langsam aber effizient. <br></li></ol><br>  Wenn Sie mit der Profilerstellung des Speicherverbrauchs in Node.js beginnen, erhalten Sie so etwas. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  Zuerst w√§chst es abrupt - das ist die Arbeit des Scavenge-Algorithmus.  Dann tritt ein scharfer Abfall auf - dieser Mark-Sweep-Algorithmus hat M√ºll im Raum alter Objekte gesammelt.  In diesem Moment beginnt sich alles etwas zu verlangsamen.  <strong>Sie k√∂nnen es nicht kontrollieren</strong> , weil Sie nicht wissen, wann es passieren wird.  Sie k√∂nnen nur die Gr√∂√üen anpassen. <br><br>  Daher verf√ºgt die Pipeline √ºber eine Speicherbereinigungsphase, die Zeit in Anspruch nimmt. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Noch schneller?</strong> </h2><br>  Schauen wir in die Zukunft.  Was tun als n√§chstes, wie schneller sein? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  In dieser Zeile h√§ngen die Blockgr√∂√üen in etwa in der daf√ºr ben√∂tigten Zeit zusammen. <br><br>  Das erste, was Menschen in den Sinn kommt, die von Bytecode geh√∂rt haben - senden Sie sofort einen Bytecode an die Eingabe und dekodieren Sie ihn, anstatt ihn zu analysieren -, ist schneller! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  Das Problem ist, dass der Bytecode jetzt anders ist.  Wie gesagt: in Safari eins, in FireFox ein anderes, in Chrome drittens.  Trotzdem haben Entwickler von Mozilla, Bloomberg und Facebook einen solchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorschlag unterbreitet</a> , aber dies ist die Zukunft. <br><br>  Es gibt ein weiteres Problem - Kompilieren, Optimieren und erneutes Optimieren, wenn der Compiler dies nicht erraten hat.  Stellen Sie sich vor, es gibt eine statisch typisierte Sprache an der Eingabe, die effektiven Code erzeugt, was bedeutet, dass keine Neuoptimierung mehr erforderlich ist, da das, was wir haben, bereits effizient ist.  Eine solche Eingabe kann nur einmal kompiliert und optimiert werden.  Der resultierende Code ist effizienter und wird schneller ausgef√ºhrt. <br><br>  Was kann man noch tun?  Stellen Sie sich vor, diese Sprache verf√ºgt √ºber eine manuelle Speicherverwaltung.  Dann brauchen Sie keinen M√ºllsammler.  Die Linie ist k√ºrzer und schneller geworden. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Ratet mal, wie es aussieht?  <strong>WebAssembly</strong> ungef√§hr <br>  So funktioniert es: manuelle Speicherverwaltung, statisch typisiert <br>  Sprachen und schnelle Ausf√ºhrung. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  Ist WebAssembly eine Silberkugel? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  Nein, weil es f√ºr JavaScript steht.  WASM kann noch nichts tun.  Er hat keinen Zugriff auf die DOM-API.  Es befindet sich in der JavaScript-Engine - in derselben Engine!  Es erledigt alles √ºber JavaScript, sodass <strong>WASM Ihren Code nicht beschleunigt</strong> .  Es kann einzelne Berechnungen beschleunigen, aber Ihr Austausch zwischen JavaScript und WASM wird ein Engpass sein. <br><br>  Daher, w√§hrend unsere Sprache JavaScript ist und nur es, und einige Hilfe von der Black Box. <br><br><h2>  <strong>Insgesamt</strong> </h2><br>  Es k√∂nnen drei Arten der Optimierung unterschieden werden. <br><br>  ‚óè <strong>Algorithmische Optimierungen</strong> <br><br>  Es gibt einen Artikel von Vyacheslav Egorov, der einst V8 entwickelt hat und jetzt Dart entwickelt, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielleicht brauchen Sie Rust nicht, um Ihr JS zu beschleunigen</a> ".  Erz√§hlen Sie kurz ihre Geschichte. <br><br>  Es gab eine JavaScript-Bibliothek, die nicht sehr schnell funktionierte.  Einige Leute haben es in Rust umgeschrieben, kompiliert und WebAssembly erhalten, und die Anwendung begann schneller zu arbeiten.  Vyacheslav Egorov als erfahrener JS-Entwickler beschloss, diese zu beantworten.  Er wandte algorithmische Optimierungen an und die JavaScript-L√∂sung wurde viel schneller als die Rust-L√∂sung.  Im Gegenzug haben diese Leute dies gesehen, die gleichen Optimierungen vorgenommen und erneut gewonnen, aber nicht sehr viel - es h√§ngt von der Engine ab: In Mozilla haben sie gewonnen, in Chrome nicht. <br><br>  Heute haben wir nicht √ºber algorithmische Optimierungen gesprochen, und Front-End-Renderings sprechen normalerweise nicht dar√ºber.  Dies ist sehr schlecht, da die <strong>Algorithmen auch erm√∂glichen, dass der Code schneller ausgef√ºhrt wird</strong> .  Sie entfernen einfach die Zyklen, die Sie nicht ben√∂tigen. <br><br>  ‚óè <strong>Sprachspezifische Optimierungen</strong> <br><br>  Dar√ºber haben wir heute gesprochen: Unsere Sprache wird dynamisch typisiert interpretiert.  Wenn Sie wissen, wie Arrays, Objekte und Monomorphismus funktionieren, <strong>k√∂nnen Sie effizienten Code schreiben</strong> .  Dies muss bekannt und korrekt geschrieben sein. <br><br>  ‚óè <strong>Motorspezifische Optimierungen</strong> <br><br>  Dies sind die gef√§hrlichsten Optimierungen.  Wenn Ihr sehr kluger, aber nicht sehr kontaktfreudiger Entwickler, der viele solcher Optimierungen angewendet und niemandem davon erz√§hlt hat, die Dokumentation nicht geschrieben hat, wird beim √ñffnen des Codes nicht JavaScript angezeigt, sondern beispielsweise Crankshaft Script.  Das hei√üt, JavaScript wurde mit einem tiefen Verst√§ndnis der Funktionsweise des Kurbelwellenmotors vor zwei Jahren geschrieben.  Es funktioniert alles, wird aber jetzt nicht mehr ben√∂tigt. <br><br>  Daher m√ºssen solche Optimierungen unbedingt dokumentiert und mit Tests abgedeckt werden, die ihre derzeitige Wirksamkeit belegen.  Sie m√ºssen √ºberwacht werden.  Sie m√ºssen nur dann zu ihnen gehen, wenn Sie irgendwo wirklich langsamer geworden sind - ohne das Wissen √ºber so tiefe Ger√§te k√∂nnen Sie einfach nicht auskommen.  Daher scheint der ber√ºhmte Satz von Donald Knuth logisch. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  Sie m√ºssen nicht versuchen, harte Optimierungen zu implementieren, nur weil Sie positive Bewertungen dar√ºber gelesen haben. <br><br>  Man sollte Angst vor solchen Optimierungen haben, unbedingt Metriken dokumentieren und belassen.  Sammeln Sie im Allgemeinen immer Metriken.  <strong>Metriken sind wichtig!</strong> <br><br>  <strong>N√ºtzliche Links:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abstracts und Pr√§sentation des Berichts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist los mit Monomorphismus?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was macht WebAssembly schnell?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Weg zum Verst√§ndnis des V8-Bytecodes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417459/">https://habr.com/ru/post/de417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417447/index.html">Expedition zu den mysteri√∂sen Feenkreisen in der Namibw√ºste</a></li>
<li><a href="../de417449/index.html">Jurassic World: K√∂nnen wir Dinosaurier wirklich wiederbeleben?</a></li>
<li><a href="../de417451/index.html">F√ºnf h√§ufige Fehler f√ºr Anf√§nger</a></li>
<li><a href="../de417453/index.html">Organisation von Praktika f√ºr Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
<li><a href="../de417461/index.html">Ivan Tulup: asynchron in JS unter der Haube</a></li>
<li><a href="../de417463/index.html">Ein unerwartetes Treffen. Kapitel 17</a></li>
<li><a href="../de417465/index.html">Eine √úbersicht √ºber Textverkn√ºpfungsmethoden</a></li>
<li><a href="../de417469/index.html">F√ºnf egoistische Gr√ºnde, reproduzierbar zu arbeiten</a></li>
<li><a href="../de417471/index.html">Einfaches Lot MK936 SMD. DIY L√∂tstation f√ºr SMD-Komponenten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>