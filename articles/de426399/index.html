<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 🙋🏼 🏆 Kronos: Keine Zeitreise auch in verteilten Systemen 🙍 👩‍⚖️ 🐁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In verteilten Systemen gibt es eine Reihe grundlegender Probleme: effiziente verteilte Transaktionen, genau einmalige Datenverarbeitung, genaue Synchr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kronos: Keine Zeitreise auch in verteilten Systemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/goto/blog/426399/"><p> In verteilten Systemen gibt es eine Reihe grundlegender Probleme: effiziente verteilte Transaktionen, genau einmalige Datenverarbeitung, genaue Synchronisation der physischen Uhren.  Um das letztere Problem zu lösen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, wurden</a> verschiedene Arten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logiktakten</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfunden</a> . </p><br><p>  Trotzdem haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vektoruhren</a> unangenehme Eigenschaften: Sie führen eine bedingte Abhängigkeit zwischen Ereignissen ein, bei denen sie nicht existieren, und verlieren sie dort, wo sie tatsächlich sind. </p><br><p>  Sie können sich jedoch etwas Zuverlässigeres einfallen lassen - Kronos.  In diesem Artikel werden wir uns den Ursache-Wirkungs-Beziehungsabrechnungsalgorithmus und seine Anwendung zum Erstellen von Schlüsselwertspeichern mit verteilten Transaktionen ansehen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b9e/7e5/9fd/b9e7e59fdf49111679ce30f147448e39.png" alt="Bild"></p><a name="habracut"></a><br><h2 id="problemy">  Die Probleme </h2><br><p>  Wie bereits erwähnt, gibt es eine Reihe von Problemen mit der logischen Uhr: </p><br><ul><li><p>  <em>Nicht existierende Abhängigkeiten</em> entstehen, weil eine logische Uhr eine <em>vollständige Reihenfolge</em> von Ereignissen einführt - das heißt, jedes von zwei Ereignissen kann als bedingt früher und welches bedingt später bezeichnet werden.  Der Vertrag ist an Bedingungen geknüpft, da es unmöglich ist, die Beziehung zwischen Ereignissen in der Zeit genau zu bestimmen, auch aufgrund der speziellen Relativitätstheorie. </p><br></li><li><p>  Andererseits berücksichtigt ein Logiktakt nur die Verbindung durch Nachrichten innerhalb des Systems.  Wenn zwei Ereignisse miteinander verbunden sind, jedoch außerhalb des Systems, z. B. durch den Benutzer (Hinzufügen von Waren zum Warenkorb in einem Teil des Systems -&gt; Zahlung für die Bestellung), kann die logische Uhr eine solche Beziehung übersehen. </p><br></li><li><p>  Auf logische Uhren kann nicht von außen zugegriffen werden, und es ist auch schwierig, mehrere unabhängige Komponenten (verteiltes Dateisystem, Anforderungsverarbeitungsdienste, Analyse) miteinander zu verbinden. </p><br></li></ul><br><h2 id="reshenie">  Lösung </h2><br><p>  Ein Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kronos aus dem Jahr</a> 2014 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">: Das Design und die Implementierung eines Event Ordering Service</a> schlägt eine Lösung vor - einen eigenständigen Service, der die Ursache-Wirkungs-Beziehungen in Events berücksichtigt. </p><br><p>  Die Hauptabstraktion in Kronos ist ein Ereignis, bei dem eine teilweise Ordnung eingeführt wird.  Das Kausalitätsverhältnis ist transitiv - das heißt, wenn wir beispielsweise wissen, dass die Erstellung einer Datei ihrer Änderung vorausgeht und die Änderung der Löschung vorausgeht, können wir eine logische Schlussfolgerung ziehen, dass die Erstellung vor dem Löschen erfolgt ist. </p><br><p>  Die Mindest-API kann mit den folgenden Methoden definiert werden: </p><br><table><thead><tr><th>  Methode </th><th>  Ergebnis </th><th>  Kommentar </th></tr></thead><tbody><tr><td><code>create_event()</code> </td> <td> <code>e</code> </td> <td>  Erstellt ein neues Ereignis in Kronos </td></tr><tr><td> <code>query_order([(e_1, e_2), ...])</code> </td> <td> <code>[&lt;-, concurrent, -&gt;, ...]</code> </td> <td>  Für jedes Paar der Anforderung wird die Ursache-Wirkungs-Beziehungsrichtung oder die <em>Gleichzeitigkeit von</em> Ereignissen zurückgegeben </td></tr><tr><td> <code>assign_order([(e_1, e_2, must), (e_3, e_4, prefer), ...])</code> </td> <td> <code>OK/FAIL</code> </td> <td>  Legt für jedes Paar der Anforderung die Richtung der Verursachung fest </td></tr><tr><td> <code>acquire_ref(e)</code> </td> <td> <code>OK</code> </td> <td>  Erhöht den Referenzzähler für dieses Ereignis. </td></tr><tr><td> <code>release_ref(e)</code> </td> <td> <code>OK</code> </td> <td>  Verringert die Referenzanzahl für dieses Ereignis. </td></tr></tbody></table><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Es ist logisch, dass das System auf einem orientierten Ereignisdiagramm mit einer effektiven Breitensuche zur Überprüfung der Beziehung von Ereignissen, einem Stabilitätsmechanismus im Fehlerfall und einer Speicherbereinigung basiert. </p><br><p>  Wie aus der API <code>assign_order</code> akzeptiert die Anforderung <code>assign_order</code> einen Kausalbeziehungstyp: <code>must</code> oder <code>prefer</code> .  <code>must</code> entspricht strengen Invarianten - z. B. " <code>_-&gt;_</code> , darf " <code>_-&gt;_</code> nicht angewendet werden, wenn es mit " <code>must</code> Beziehungen" in Konflikt steht.  Ein Beispiel für die Verwendung von " <code>prefer</code> ist, dass früher eingegangene Anforderungen besser früher verpackt werden. Dies hat jedoch keinen Einfluss auf die Richtigkeit. </p><br><h3 id="effektivnyy-bfs">  Effektives BFS </h3><br><p>  In unserem Fall ist das Diagramm möglicherweise groß, aber Ereignisse, für die Überprüfungsanforderungen ausgeführt werden, sind normalerweise geschlossen.  Daher müssen Sie BFS in solchen Fällen schneller ausführen. </p><br><p>  In der Standardimplementierung ist der längste Ort die Initialisierung des Arrays der besuchten Scheitelpunkte, die immer Zeit benötigt, die der Anzahl der Scheitelpunkte im Diagramm entspricht.  Stattdessen können Sie eine Hash-Tabelle verwenden oder andere Tricks anwenden. </p><br><h3 id="sborka-musora">  Müllabfuhr </h3><br><p>  Wie Sie der Tabelle <code>acquire_ref</code> können, gibt es zwei weitere Methoden: <code>acquire_ref</code> und <code>release_ref</code> . </p><br><p>  In Kronos wird für jedes Ereignis ein Referenzzähler gespeichert.  Während einige Dienste das Ereignis verarbeiten oder die Möglichkeit behalten, neue Ereignisse hinzuzufügen, <em>die nach dem</em> aktuellen Ereignis auftreten, wird der Link gespeichert.  Wenn diese Notwendigkeit verschwindet, ruft der Dienst <code>release_ref</code> . </p><br><p>  Kronos löscht das Ereignis, wenn alle Bedingungen erfüllt sind: </p><br><ol><li>  Die Anzahl der Links hat Null erreicht </li><li>  Alle Ereignisse davor sind bereits aus dem Diagramm gelöscht. </li></ol><br><p>  Dieser Ansatz schränkt mögliche Abfragen nicht ein, spart jedoch Speicher in Kronos. </p><br><h2 id="prilozheniya">  Anwendungen </h2><br><p>  Betrachten Sie die Verwendung des Systems am Beispiel der Schlüsselwertspeicherung mit verteilten Transaktionen. </p><br><p>  Angenommen, es gibt mehrere Server. Jeder Server ist für eine Reihe von Schlüsseln verantwortlich. </p><br><p>  Jede Transaktion entspricht einem Ereignis in Kronos.  Für jeden Schlüssel muss der Server die Nummer der letzten Transaktion speichern, an der dieser Schlüssel teilgenommen hat.  Der Client erstellt ein Ereignis und sendet seine Nummer an alle Server, deren Schlüssel von dieser Transaktion betroffen sind.  Der Server versucht, in Kronos eine Abhängigkeit zwischen der aktuellen Transaktionsnummer und dem vorherigen Ereignis zu erstellen, das für diesen Schlüssel gespeichert wurde.  Wenn Sie die Abhängigkeit nicht erstellen können, wird die Transaktion als nicht erfolgreich erkannt (beachten Sie, dass bis jetzt noch keine Interaktion mit den Daten besteht). </p><br><p>  Wenn alle Operationen zum Hinzufügen von Abhängigkeiten erfolgreich abgeschlossen wurden, bedeutet dies, dass die Transaktion stattfindet und ausgeführt werden kann.  Server erfahren dies vom Client und beginnen, Teile der Transaktion auszuführen. </p><br><p>  Beachten Sie, dass solche Transaktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACID sind</a> : </p><br><ul><li>  <strong>Atomarität</strong> : Die Transaktion wird entweder nicht in Kronos oder für die Ausführung auf allen Knoten geplant. </li><li>  <strong>Konsistenz</strong> : automatisch in KV-Repositorys. </li><li>  <strong>Isolation</strong> : Wenn sich zwei Transaktionen gemäß Daten überschneiden, werden sie durch einen Kausalzusammenhang in Kronos verbunden, was bedeutet, dass eine vor der anderen ausgeführt wird. </li><li>  <strong>Haltbarkeit</strong> : Da Kronos sturzsicher ist und davon ausgeht, dass jede Replik des Tresors auch stabil ist, muss nur die Persistenz der Daten ausstehender Transaktionen nachgewiesen werden.  Wenn die Transaktion vom Client als erfolgreich markiert wird, der Datensatz jedoch noch nicht auf dem Server abgeschlossen wurde, ist diese Tatsache leicht festzustellen, da der Server auch die abgeschlossenen Teile der Transaktionen verfolgt. </li></ul><br><h3 id="proizvoditelnost">  Leistung </h3><br><p>  Die Implementierung eines solchen KV-Speichers kann tatsächlich effektiv sein.  Der ursprüngliche Artikel zitiert Daten, dass die beschriebene Implementierung von KV-Speicher viermal schneller ist als die auf Sperren basierende Transaktion. </p><br><p>  Darüber hinaus liegt das System über Kronos im Vergleich zu MongoDB nur 6% zurück, obwohl MongoDB keine verteilten Transaktionen verwendet. </p><br><h2 id="analiz">  Analyse </h2><br><p>  Der Betrieb von Kronos hat jedoch mehrere Nachteile. </p><br><ul><li>  Erstens gibt es den Aufwand für den Zugriff auf Kronos - für jede Anforderung ist mindestens ein Anruf erforderlich. </li><li>  Kronos wird auch eine einzige Fehlerquelle sein - die Autoren des Artikels bieten keine Möglichkeiten zum Partitionieren des Ereignisdiagramms. </li><li>  Es wäre schön, dem System eine Reihe von Methoden hinzuzufügen.  Im Beispiel mit KV-Speicher wäre es beispielsweise schön, einen Rückruf zu haben, der den Server über den Status der Transaktion informiert - er wurde erfolgreich mit allen erforderlichen Abhängigkeiten zum Diagramm hinzugefügt - oder umgekehrt konnte die Transaktion nicht abgeschlossen werden. </li></ul><br><p>  Das beschriebene System ermöglicht jedoch eine flexible Kontrolle des Kausalzusammenhangs zwischen Ereignissen, wodurch eine vorhersehbare Einhaltung der erforderlichen Invarianten sichergestellt wird. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Darüber unterrichten wir an der GoTo School Schüler und Schüler in Richtung verteilter Systeme. </p><br><p>  Und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen und Anwendungen</a> , Angewandte Programmierung, Bioinformatik und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenanalyse</a> </p><br><p>  Besuchen Sie unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herbstschule</a> vom 27. Oktober bis 4. November oder die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winterschule</a> Anfang Januar. </p><br><p>  Und wenn Sie kein Schüler oder Schüler mehr sind, <a href="">kommen Sie, um zu unterrichten</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426399/">https://habr.com/ru/post/de426399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426387/index.html">Grafik in Julia. Seltsame Muster, die Reflexion eines Dreiecks von einer geraden Linie und die Konstruktion der Normalen einer kugelförmigen Katze im Vakuum</a></li>
<li><a href="../de426389/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 334 (7.-14. Oktober 2018)</a></li>
<li><a href="../de426391/index.html">PHP Digest Nr. 141 (1. - 15. Oktober 2018)</a></li>
<li><a href="../de426395/index.html">Zum Zeitpunkt des Kaufs wird eine Gebühr für Waren aus ausländischen Online-Shops erhoben</a></li>
<li><a href="../de426397/index.html">Internet Keeper</a></li>
<li><a href="../de426401/index.html">Amazon wird seiner KI beibringen, menschliche Emotionen zu definieren</a></li>
<li><a href="../de426405/index.html">Hacker im Rahmen der Gesetze der Russischen Föderation</a></li>
<li><a href="../de426407/index.html">Wie man die Reise zur Konferenz so nutzlos wie möglich macht</a></li>
<li><a href="../de426409/index.html">Der Hacker Alexei, der MikroTik-Router ohne Erlaubnis der Eigentümer schützt, ist berühmt geworden</a></li>
<li><a href="../de426411/index.html">Entwickeln von C ++ / CLI-Deskriptorklassen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>