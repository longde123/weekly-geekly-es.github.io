<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌮 👸🏻 🌷 Benchmarking von PostgreSQL mit großen Linux-Seiten 🕗 🤜🏼 👣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Linux-Kernel bietet eine Vielzahl von Konfigurationsoptionen, die sich auf die Leistung auswirken können. Es geht darum, die richtige Konfiguratio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmarking von PostgreSQL mit großen Linux-Seiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458910/"><img width="40%" align="left" src="https://habrastorage.org/webt/u0/hs/uc/u0hsucgpyp_pgw1mwtyzdtkvd1o.jpeg">  Der Linux-Kernel bietet eine Vielzahl von Konfigurationsoptionen, die sich auf die Leistung auswirken können.  Es geht darum, die richtige Konfiguration für Ihre Anwendung und Arbeitslast zu erhalten.  Wie jede andere Datenbank verwendet PostgreSQL den Linux-Kernel für eine optimale Konfiguration.  Schlecht eingestellte Einstellungen können zu einer schlechten Leistung führen.  Daher ist es wichtig, dass Sie die Datenbankleistung nach jeder Optimierungssitzung messen, um Leistungseinbußen zu vermeiden.  In einer meiner früheren Veröffentlichungen, „Optimieren von Linux-Kernel-Parametern für die PostgreSQL-Optimierung“, habe ich einige der nützlichsten Linux-Kernel-Parameter beschrieben und erläutert, wie sie Ihnen bei der Verbesserung der Datenbankleistung helfen können.  Jetzt werde ich meine Testergebnisse teilen, nachdem ich große Linux-Seiten mit einer anderen PostgreSQL-Workload eingerichtet habe.  Ich habe eine Reihe von Tests für verschiedene PostgreSQL-Lastgrößen und die gleichzeitige Anzahl von Clients durchgeführt. <br><br><h2>  Prüfmaschine </h2><br><ul><li>  Supermicro Server: <br><ul><li>  Intel® Xeon® CPU E5-2683 v3 bei 2,00 GHz </li><li>  2 Sockel / 28 Kerne / 56 Gewinde </li><li>  Speicher: 256 GB RAM </li><li>  Speicher: SAMSUNG SM863 1.9 TB Enterprise SSD </li><li>  Dateisystem: ext4 / xfs </li></ul></li><li>  Betriebssystem: Ubuntu 16.04.4, Kernel 4.13.0-36-generic </li><li>  PostgreSQL: Version 11 </li></ul><a name="habracut"></a><br><h2>  Linux-Kernel-Einstellungen </h2><br>  Ich habe die Standard-Kernel-Einstellungen ohne Optimierung / Optimierung verwendet, außer durch Deaktivieren transparenter großer Seiten (Transparent HugePages).  Transparente große Seiten sind standardmäßig aktiviert und markieren die Seitengröße, die für die Verwendung durch die Datenbank möglicherweise nicht empfohlen wird.  Datenbanken erfordern normalerweise große Seiten mit fester Größe, die nicht von transparenten großen Seiten abgedeckt werden.  Daher wird immer empfohlen, diese Funktion zu deaktivieren und standardmäßig klassische große Seiten zu verwenden. <br><br><h2>  PostgreSQL-Einstellungen </h2><br>  Ich habe die einheitlichen PostgreSQL-Einstellungen für alle Tests verwendet, um verschiedene PostgreSQL-Workloads mit unterschiedlichen Einstellungen für große Linux-Seiten aufzuzeichnen.  Hier ist das PostgreSQL-Setup, das für alle Tests verwendet wird: <br><br>  <sup>postgresql.conf</sup> <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">shared_buffers</span></span> = <span class="hljs-string"><span class="hljs-string">'64GB'</span></span> work_mem = <span class="hljs-string"><span class="hljs-string">'1GB'</span></span> random_page_cost = <span class="hljs-string"><span class="hljs-string">'1'</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'2GB'</span></span> synchronous_commit = <span class="hljs-string"><span class="hljs-string">'on'</span></span> seq_page_cost = <span class="hljs-string"><span class="hljs-string">'1'</span></span> max_wal_size = <span class="hljs-string"><span class="hljs-string">'100GB'</span></span> checkpoint_timeout = <span class="hljs-string"><span class="hljs-string">'10min'</span></span> synchronous_commit = <span class="hljs-string"><span class="hljs-string">'on'</span></span> checkpoint_completion_target = <span class="hljs-string"><span class="hljs-string">'0.9'</span></span> autovacuum_vacuum_scale_factor = <span class="hljs-string"><span class="hljs-string">'0.4'</span></span> effective_cache_size = <span class="hljs-string"><span class="hljs-string">'200GB'</span></span> min_wal_size = <span class="hljs-string"><span class="hljs-string">'1GB'</span></span> wal_compression = <span class="hljs-string"><span class="hljs-string">'ON'</span></span></code> </pre> <br><h2>  Testschema </h2><br>  Beim Testen spielt das Testschema eine wichtige Rolle.  Alle Tests werden für jeden Lauf dreimal 30 Minuten lang durchgeführt.  Ich habe den Durchschnitt dieser drei Indikatoren genommen.  Die Tests wurden mit dem Leistungstest-Tool PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgbench durchgeführt</a> .  pgbench arbeitet mit einem Skalierungsfaktor mit einem Skalierungsfaktor von ungefähr 16 MB Arbeitslast. <br><br><h2>  Große Seiten (HugePages) </h2><br>  Linux verwendet standardmäßig 4K-Speicherseiten zusammen mit großen Seiten.  BSD hat Superseiten, während Windows große Seiten hat.  PostgreSQL unterstützt nur große Seiten (Linux).  Bei hoher Speichernutzung verringern kleine Seiten die Leistung.  Durch die Installation großer Seiten erhöhen Sie den zugewiesenen Speicher für die Anwendung und reduzieren folglich die Betriebskosten, die während der Zuweisung / des Austauschs entstehen.  Das heißt, Sie steigern die Produktivität mit großen Seiten. <br><br>  Hier ist das Setup für große Seiten bei Verwendung einer großen Seitengröße von 1 GB.  Sie können diese Informationen jederzeit von / proc erhalten. <br><br>  <sup>$ cat / proc / meminfo |</sup>  <sup>grep -i riesig</sup> <br><br><pre> <code class="nginx hljs">AnonHugePages: 0 <span class="hljs-attribute"><span class="hljs-attribute">kB</span></span> ShmemHugePages: <span class="hljs-number"><span class="hljs-number">0</span></span> kB HugePages_Total: <span class="hljs-number"><span class="hljs-number">100</span></span> HugePages_Free: <span class="hljs-number"><span class="hljs-number">97</span></span> HugePages_Rsvd: <span class="hljs-number"><span class="hljs-number">63</span></span> HugePages_Surp: <span class="hljs-number"><span class="hljs-number">0</span></span> Hugepagesize: <span class="hljs-number"><span class="hljs-number">1048576</span></span> kB</code> </pre> <br>  Weitere Informationen zu großen Seiten finden Sie in meinem vorherigen Blogbeitrag. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.percona.com/blog/2018/08/29/tune-linux-kernel-parameters-for-postgresql-optimization/</a> <br><br>  In der Regel sind große Seiten 2 MB und 1 GB groß. Daher ist es sinnvoll, eine Größe von 1 GB anstelle einer viel kleineren Größe von 2 MB zu verwenden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-transhuge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://kerneltalks.com/services/what-is-huge-pages-in-linux/</a> <br><br><h2>  Testergebnisse </h2><br>  Dieser Test zeigt den Gesamteffekt verschiedener Größen großer Seiten.  Die erste Testsuite wurde mit der Standardseitengröße unter Linux 4K ohne große Seiten erstellt.  Beachten Sie, dass transparente große Seiten ebenfalls deaktiviert wurden und während all dieser Tests deaktiviert blieben. <br><br>  Dann wurde der zweite Satz von Tests auf großen Seiten von 2 MB durchgeführt.  Schließlich wird der dritte Testsatz mit großen Seiten von 1 GB ausgeführt. <br><br>  Alle diese Tests wurden in PostgreSQL Version 11 durchgeführt. Die Sets enthalten eine Kombination verschiedener Größen der Datenbank und der Clients.  Die folgende Grafik zeigt die vergleichenden Leistungsergebnisse für diese Tests mit TPS (Transaktionen pro Sekunde) auf der Y-Achse, Datenbankgröße und Anzahl der Clients pro Datenbankgröße auf der X-Achse. <br><br><img src="https://habrastorage.org/webt/1k/pu/1r/1kpu1rufj-fpl3iszxtzvnjxfgg.png"><br><br>  Aus dem obigen Diagramm ist ersichtlich, dass der Leistungsgewinn bei großen Seiten mit der Anzahl der Clients und der Größe der Datenbank zunimmt, wenn die Größe im zuvor zugewiesenen Puffer im gemeinsam genutzten Speicher verbleibt. <br><br>  Dieser Test zeigt TPS im Vergleich zur Anzahl der Clients.  In diesem Fall beträgt die Datenbankgröße 48 GB.  Auf der Y-Achse haben wir TPS und auf der X-Achse haben wir die Anzahl der verbundenen Clients.  Die Datenbankgröße ist klein genug, um in einen gemeinsam genutzten Puffer zu passen, der auf 64 GB festgelegt ist. <br><br><img src="https://habrastorage.org/webt/fc/j_/kn/fcj_knw5ujqg-vvyzcxnl2wkclu.png"><br><br>  Wenn große Seiten auf 1 GB festgelegt sind, ist der relative Leistungsgewinn umso höher, je mehr Clients vorhanden sind. <br><br>  Das folgende Diagramm ist bis auf die Datenbankgröße von 96 GB das gleiche wie oben.  Dies überschreitet die Größe des gemeinsam genutzten Puffers, der auf 64 GB festgelegt ist. <br><br><img src="https://habrastorage.org/webt/z8/6r/je/z86rjeljjqfr_nyaylzzpv7xf9q.png"><br><br>  Die wichtigste Beobachtung hierbei ist, dass die Leistung mit großen Seiten von 1 GB mit zunehmender Anzahl von Clients zunimmt und letztendlich mehr Leistung bietet als große Seiten mit 2 MB oder die Standardseitengröße von 4 KB. <br><br>  Dieser Test zeigt TPS abhängig von der Größe der Datenbank.  In diesem Fall beträgt die Anzahl der verbundenen Clients 32. Auf der Y-Achse haben wir TPS und auf der X-Achse die Datenbankgrößen. <br><br><img src="https://habrastorage.org/webt/cg/90/oi/cg90oidu2mlqyp40deo9fzcmlki.png"><br><br>  Wenn die Datenbank über die vorab zugewiesenen großen Seiten hinausgeht, wird die Leistung erwartungsgemäß erheblich reduziert. <br><br><h2>  Zusammenfassung </h2><br>  Eine meiner wichtigsten Empfehlungen ist, dass wir Transparent HugePages deaktivieren sollten.  Sie werden den größten Leistungsgewinn sehen, wenn die Datenbank in einem gemeinsam genutzten Puffer mit aktivierten großen Seiten abgelegt wird.  Die Auswahl der Größe großer Seiten erfordert einen geringen Aufwand an Versuchen und Irrtümern. Dies kann jedoch möglicherweise zu einer signifikanten Erhöhung des TPS führen, wenn die Datenbankgröße groß ist, aber klein genug bleibt, um in einen gemeinsam genutzten Puffer zu passen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458910/">https://habr.com/ru/post/de458910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458900/index.html">Konsolenpatronen als Modems</a></li>
<li><a href="../de458902/index.html">5 Häufige Python-Anfängerfehler</a></li>
<li><a href="../de458904/index.html">Visualisierung der Anzahl der Siege für NBA-Teams mithilfe animierter Balkendiagramme in R.</a></li>
<li><a href="../de458906/index.html">[Jekaterinburg, Ankündigung] Flutteron - ein Workshop zur Entwicklung von Flutter</a></li>
<li><a href="../de458908/index.html">Scannen von Dokumenten über das Netzwerk</a></li>
<li><a href="../de458912/index.html">Mit Imapsync nach Zimbra migrieren</a></li>
<li><a href="../de458914/index.html">Was (nicht) Sie wissen müssen, um Spiele auf Unity zu erstellen</a></li>
<li><a href="../de458916/index.html">Unter der Haube von React. Wir schreiben unsere Implementierung von Grund auf neu</a></li>
<li><a href="../de458918/index.html">Was Sie aus dem Design von Hyper-Casual-Spielen lernen können</a></li>
<li><a href="../de458920/index.html">Konferenz für DevOps-Fans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>