<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíº ü§∑ üòΩ Arend - idioma do tipo dependente baseado no HoTT (parte 2) üéà üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üìí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte do artigo sobre a linguagem Arend, examinamos os tipos indutivos mais simples, fun√ß√µes recursivas, classes e conjuntos. 

 2. Classi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - idioma do tipo dependente baseado no HoTT (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na primeira parte do artigo</a> sobre a linguagem Arend, examinamos os tipos indutivos mais simples, fun√ß√µes recursivas, classes e conjuntos. <br><br><h2>  2. Classificando listas no Arend </h2><br><h3>  2.1 Listas ordenadas no Arend </h3><br>  Definimos o tipo de lista ordenada como um par que consiste em uma lista e uma prova de sua ordem.  Como j√° dissemos, em Arend, pares dependentes s√£o definidos usando a palavra-chave <code>\Sigma</code> .  Fornecemos a defini√ß√£o do tipo <code>Sorted</code> por meio de compara√ß√£o com a amostra, inspirada na defini√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> j√° mencionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre listas ordenadas.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Nota: Arend conseguiu inferir automaticamente que o tipo <code>Sorted</code> est√° contido no universo <code>\Prop</code> .  Isso aconteceu porque todos os tr√™s padr√µes na defini√ß√£o <code>Sorted</code> s√£o mutuamente exclusivos e o construtor <code>consSorted</code> possui dois par√¢metros, ambos pertencentes a <code>\Prop</code> . <br>  Vamos provar alguma propriedade √≥bvia do predicado <code>Sorted</code> , digamos que o final de uma lista ordenada seja ela pr√≥pria uma lista ordenada (essa propriedade ser√° √∫til para n√≥s no futuro). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  Na <code>tail-sorted</code> usamos a correspond√™ncia de padr√µes na lista <code>xs</code> e o predicado <code>Sorted</code> ao mesmo tempo; al√©m disso, usamos o <i>caractere de salto</i> ‚Äú_‚Äù, que pode ser substitu√≠do por vari√°veis ‚Äã‚Äãn√£o utilizadas. <br><br>  Algu√©m pode perguntar se √© poss√≠vel em Arend provar a propriedade de listas ordenadas, mencionadas na se√ß√£o 1.3 como um exemplo de um fato que n√£o pode ser provado na Agda sem anota√ß√µes de imaterialidade.  Lembre-se de que essa propriedade afirma que, para provar a igualdade de listas ordenadas definidas por meio de pares dependentes, basta verificar a igualdade dos primeiros componentes dos pares. <br><br>  Argumenta-se que em Arend essa propriedade √© facilmente obtida como conseq√º√™ncia da constru√ß√£o <code>inProp</code> mencionada acima e da propriedade de extensionalidade para pares <code>SigmaExt</code> dependentes. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  A propriedade <code>SigmaPropExt</code> provada no m√≥dulo <a href="">Paths</a> da biblioteca padr√£o, e muitos outros fatos do segundo cap√≠tulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do livro HoTT</a> , incluindo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedade de extensionalidade funcional</a> , tamb√©m s√£o provados l√°. <br><br>  O operador <code>.n</code> usado no Arend para acessar o projetor do tipo sigma com o n√∫mero n (no nosso caso, o tipo sigma √© <code>SortedList A</code> , e a express√£o <code>l1.1</code> significa que o primeiro componente desse tipo √© uma express√£o do tipo <code>List A</code> ). <br><br><h3>  2.2 Implementa√ß√£o da propriedade ‚Äúbe permutation‚Äù </h3><br>  Agora vamos tentar implementar a fun√ß√£o de classifica√ß√£o de lista no Arend.  Naturalmente, queremos ter n√£o uma implementa√ß√£o simples do algoritmo de classifica√ß√£o, mas uma implementa√ß√£o junto com uma prova de algumas propriedades. <br><br>  Claramente, esse algoritmo deve ter pelo menos 2 propriedades: <br>  1. O resultado do algoritmo deve ser uma lista ordenada. <br>  2. A lista resultante deve ser uma permuta√ß√£o da lista original. <br><br>  Primeiro, vamos tentar implementar a propriedade "ser permuta√ß√£o" das listas no Arend.  Para fazer isso, adaptamos a defini√ß√£o retirada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> para Arend. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  O predicado <code>InsertSpec</code> introduzido por n√≥s tem o seguinte significado intuitivo: <code>InsertSpec xs a ys</code> significa exatamente que a lista <code>ys</code> √© o resultado da inser√ß√£o do elemento a dentro da lista <code>xs</code> (em qualquer posi√ß√£o).  Assim, <code>InsertSpec</code> pode ser tomado como uma especifica√ß√£o da fun√ß√£o de inser√ß√£o. <br><br>  Claramente, o tipo de dados <code>Perm</code> realmente define o relacionamento "ser permuta√ß√£o": o construtor <code>permInsert</code> exatamente que <code>xs</code> e <code>ys</code> s√£o mutuamente permut√°veis ‚Äã‚Äãse <code>xs</code> e <code>ys</code> s√£o obtidos inserindo o mesmo elemento a em algumas listas <code>xs'</code> e <code>ys'</code> comprimentos mais curtos, que j√° s√£o permuta√ß√µes um do outro. <br><br>  Para nossa defini√ß√£o da propriedade "ser permuta√ß√£o", √© f√°cil verificar a propriedade simetria. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  A propriedade transitividade tamb√©m √© satisfeita para <code>Perm</code> , mas sua verifica√ß√£o √© muito mais complicada.  Como essa propriedade n√£o desempenha nenhum papel na implementa√ß√£o de nosso algoritmo de classifica√ß√£o, deixamos isso para o leitor como um exerc√≠cio. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 Mudan√ßa nos n√≠veis de homotopia quando comparada com a amostra </h3><br>  Agora vamos tentar implementar uma fun√ß√£o que insere um elemento em uma lista ordenada para que a lista resultante permane√ßa ordenada.  Vamos come√ßar com a seguinte implementa√ß√£o ing√™nua. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  A constru√ß√£o <code>\case</code> permite a correspond√™ncia com uma amostra de uma express√£o arbitr√°ria ( <code>\elim</code> pode ser usado apenas no n√≠vel mais alto de uma defini√ß√£o de fun√ß√£o e apenas para seus par√¢metros).  Se voc√™ solicitar √† Arend para verificar o tipo de <code>insert</code> , a seguinte mensagem de erro ser√° exibida. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  O problema √© que, na classe <code>LinearOrder.Dec</code> defini√ß√£o de <code>trichotomy</code> fornecida usando o operador <code>||</code>  , que, por sua vez, √© determinado usando truncamento proposicional.  Como j√° mencionado, para tipos pertencentes ao universo <code>\Prop</code> , a correspond√™ncia com um padr√£o em Arend √© permitida apenas se o tipo da express√£o resultante for uma asser√ß√£o (para a fun√ß√£o acima, o resultado √© do tipo <code>List OE</code> e esse tipo √© um conjunto). <br><br>  Existe alguma maneira de contornar esse problema?  A maneira mais f√°cil de resolver isso √© alterar a defini√ß√£o da propriedade da tricotomia.  Considere a seguinte defini√ß√£o de tricotomia, usando o tipo n√£o truncado <code>Or</code> vez do truncado <code>||</code>  : <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  Esta defini√ß√£o <code>trichotomy</code> em algo da defini√ß√£o original da <code>trichotomy</code> atrav√©s de <code>||</code>  ?  Por que usamos um tipo propositalmente truncado se isso apenas complica nossa vida e nos impede de usar a correspond√™ncia de padr√µes? <br><br>  Vamos tentar responder √† primeira pergunta para come√ßar: para pedidos estritos do <code>StrictPoset</code> diferen√ßa entre <code>trichotomy</code> e <code>trichotomy</code> <code>set-trichotomy</code> n√£o √© de todo.  Observe que o tipo de <code>set-trichotomy</code> √© uma afirma√ß√£o.  Esse fato decorre do fato de que todas as tr√™s alternativas na defini√ß√£o de tricotomia s√£o mutuamente exclusivas devido a axiomas de ordem, e cada um dos tr√™s tipos <code>x = y, x &lt; y, y &lt; x</code> √© em si uma afirma√ß√£o ( <code>x = y</code> √© uma afirma√ß√£o, portanto como na defini√ß√£o da classe <code>BaseSet</code> exigimos que a m√≠dia <code>E</code> um conjunto!). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  Na lista acima, <code>absurd</code> √© a designa√ß√£o para o princ√≠pio ex falso quodlibet, definido no m√≥dulo <a href="">Logic</a> .  Como o tipo <code>Empty</code> n√£o possui construtores na defini√ß√£o (consulte a se√ß√£o 1.2), n√£o √© necess√°rio analisar os casos na defini√ß√£o de <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Como sabemos agora que <code>set-trichotomy</code> √© uma afirma√ß√£o, podemos derivar a propriedade <code>set-trichotomy</code> propriedade usual da <code>trichotomy</code> em ordens decid√≠veis.  Para fazer isso, podemos usar a constru√ß√£o <code>\return \level</code> , que informa ao timer Arend que, neste ponto, combinar com o padr√£o √© uma opera√ß√£o permitida (nesse caso, temos que mostrar a prova de que o resultado da fun√ß√£o <code>set-trichotomy-property</code> √© uma instru√ß√£o). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Vamos agora tentar responder √† segunda pergunta, a saber, por que √© prefer√≠vel usar constru√ß√µes n√£o comuns, mas propositalmente truncadas, ao formular as propriedades de objetos matem√°ticos.  Considere para isso um fragmento da defini√ß√£o de ordens lineares n√£o lineares (defini√ß√µes completas de <code>Lattice</code> e <code>TotalOrder</code> podem ser encontradas no m√≥dulo <a href="">LinearOrder</a> ): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Vamos tentar imaginar agora como o significado da classe <code>TotalOrder</code> mudaria se <code>TotalOrder</code> a defini√ß√£o do campo da totalidade atrav√©s da constru√ß√£o <code>Or</code> n√£o truncada. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  Nesse caso, o tipo <code>(x &lt;= y) `Or` (y &lt;= x)</code> n√£o <code>(x &lt;= y) `Or` (y &lt;= x)</code> mais uma declara√ß√£o, porque  no caso de valores iguais de <code>y</code> ambas as alternativas na defini√ß√£o de <code>badTotality</code> podem ser implementadas, e a escolha do ramo esquerdo ou direito na prova de <code>badTotality</code> absolutamente arbitr√°ria e permanece a crit√©rio do usu√°rio - n√£o h√° raz√£o para preferir um construtor <code>Or</code> a outro. <br><br>  Agora est√° claro qual √© a diferen√ßa entre <code>TotalOrder</code> e <code>BadTotalOrder</code> .  Dois conjuntos ordenados <code>O1 O2</code> : <code>TotalOrder</code> s√£o sempre iguais quando √© poss√≠vel provar a igualdade dos conjuntos <code>O1.E, O2.E</code> e as ordens <code>O1.&lt;, O2.&lt;</code> Dados sobre eles (esta √© a propriedade desejada).  Por outro lado, para <code>O1 O2</code> : <code>BadTotalOrder</code> √© <code>BadTotalOrder</code> provar a igualdade de <code>O1</code> e <code>O2</code> somente quando, al√©m de todos os elementos <code>x</code> de <code>E</code> igualdade <code>O1.badTotality xx</code> e <code>O2.badTotality xx</code> . <br><br>  Assim, verifica-se que a classe <code>BadTotalOrder</code> intuitivamente precisa ser considerada n√£o como um "conjunto ordenado linearmente", mas como um "conjunto ordenado linearmente junto com a escolha para cada elemento <code>x</code> campo <code>E</code> ramo esquerdo ou direito <code>Or</code> na implementa√ß√£o de <code>badTotality xx</code> ". <br><br><h3>  2.4 Algoritmo de classifica√ß√£o </h3><br>  Agora, implementamos o algoritmo de classifica√ß√£o.  Vamos tentar corrigir a implementa√ß√£o ing√™nua da fun√ß√£o de <code>insert</code> da se√ß√£o anterior usando a propriedade comprovada <code>set-trichotomy-property</code> (neste caso, devido ao arranjo mais bem-sucedido de colchetes na defini√ß√£o de <code>set-trichotomy</code> de <code>set-trichotomy</code> , reduzimos o n√∫mero de casos considerados). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Agora vamos tentar implementar um an√°logo dessa defini√ß√£o para listas ordenadas.  Usaremos a constru√ß√£o especial <code>\let ‚Ä¶ \in</code> , que nos permite adicionar novas vari√°veis ‚Äã‚Äãlocais ao contexto. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Deixamos na prova um fragmento incompleto (indicado pela express√£o <code>{?}</code> ) No local em que voc√™ deseja mostrar que a lista <code>x :-: result</code> ordenada.  Embora no contexto haja evid√™ncias da ordem da lista de <code>result</code> , resta verificar se <code>x</code> n√£o excede o valor do primeiro elemento da lista de <code>result</code> , o que n√£o √© t√£o f√°cil de seguir a partir das premissas do contexto (para ver todas as premissas no destino atual - √© assim que chamamos ramo atual dos c√°lculos - √© necess√°rio solicitar a verifica√ß√£o do tipo na fun√ß√£o de <code>insert</code> ). <br><br>  Acontece que a <code>insert</code> muito mais f√°cil de implementar se provarmos a ordem da lista resultante em paralelo com a prova da especifica√ß√£o da <code>insert</code> .  Altere a assinatura do <code>insert</code> e escreva a prova desta especifica√ß√£o nos casos mais simples: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  Para um √∫nico fragmento deixado sem prova, o Arend produzir√° o seguinte valor de contexto: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Para concluir a prova, teremos que usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">toda a pot√™ncia do</a> operador <code>\case</code> : usaremos a correspond√™ncia de padr√µes com 5 vari√°veis ‚Äã‚Äãdiferentes e, como os tipos de algumas vari√°veis ‚Äã‚Äãpodem depender dos valores de outras vari√°veis, usaremos a correspond√™ncia de padr√µes dependentes. <br><br>  A constru√ß√£o dos dois pontos indica explicitamente como o tipo de algumas vari√°veis ‚Äã‚Äãcomparadas depende dos valores de outras vari√°veis ‚Äã‚Äã(portanto, no tipo de vari√°veis <code>xs-sorted, result-spec</code> <code>result-sorted</code> em cada um dos <code>\case</code> vez de <code>xs'</code> e <code>result</code> corresponder√° √†s amostras correspondentes). <br><br>  A constru√ß√£o <code>\return</code> associa as vari√°veis ‚Äã‚Äãusadas para combinar o padr√£o com o tipo de resultado esperado.  Em outras palavras, no destino atual, em cada uma das cl√°usulas <code>\case</code> , a amostra correspondente ser√° substitu√≠da pela vari√°vel de <code>result</code> .  Sem essa constru√ß√£o, essa substitui√ß√£o n√£o seria realizada e o objetivo de todas as cl√°usulas <code>\case</code> coincidiria com o destino no lugar da pr√≥pria <code>\case</code> expression. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  No bloco de c√≥digo acima, os primeiros argumentos complexos do construtor <code>consSorted</code> nos dois √∫ltimos par√°grafos da compara√ß√£o de padr√µes merecem coment√°rios adicionais.  Para entender o que essas duas express√µes significam, as substitu√≠mos pela express√£o <code>{?}</code> E pedimos ao cron√¥metro Arend que determine os alvos em ambas as posi√ß√µes. <br><br>  Voc√™ pode ver que, ali e ali, o destino atual √© o tipo <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  Al√©m disso, no contexto do primeiro objetivo, existem premissas <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  e no contexto das segundas instala√ß√µes <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Intuitivamente claro: para provar o primeiro objetivo, basta substituir a vari√°vel <code>r</code> pela instru√ß√£o correta <code>Or (x = y) (O.&lt; xy)</code> e depois mudar para o tipo propositalmente truncado <code>||</code>  usando a fun√ß√£o <code>Or-to-||</code> definida na Se√ß√£o 1.3  .  Para provar o segundo objetivo, basta substituir em <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> vez da vari√°vel <code>x'</code> vari√°vel <code>r</code> . <br><br>  Para formalizar a opera√ß√£o de substitui√ß√£o de express√£o descrita, existe uma fun√ß√£o de <code>transport</code> especial na biblioteca Arend padr√£o.  Considere a assinatura dela: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  No nosso caso, em vez da vari√°vel <code>A</code> precisamos substituir o tipo <code>OE</code> (pode ser omitido explicitamente se os outros argumentos de <code>transport</code> forem especificados) e, em vez de <code>B</code> , a express√£o <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  A implementa√ß√£o do algoritmo de classifica√ß√£o de inser√ß√£o junto com a especifica√ß√£o n√£o causa mais dificuldades particulares: para classificar a lista <code>x :-: xs'</code> , primeiro classificamos o <code>insertSort</code> da lista <code>xs'</code> usando uma chamada recursiva para <code>insertSort</code> e, em seguida, inserimos o elemento <code>x</code> nessa lista, preservando a ordem de ajudar a acessar a fun√ß√£o de <code>insert</code> j√° implementada. <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Cumprimos o objetivo inicial e implementamos a classifica√ß√£o das listas no Arend.  Todo o c√≥digo Arend fornecido neste par√°grafo pode ser baixado em um arquivo a <a href="">partir daqui</a> . <br><br>  Pode-se perguntar como seria necess√°rio alterar a implementa√ß√£o da fun√ß√£o <code>insert</code> se, em vez das ordens <code>LinearOrder.Dec</code> estritas, <code>LinearOrder.Dec</code> ordens <code>LinearOrder.Dec</code> n√£o estritas?  Como lembramos, na defini√ß√£o da fun√ß√£o de totalidade, o uso da opera√ß√£o truncada <code>||</code>  foi bastante significativo, ou seja, essa defini√ß√£o n√£o √© equivalente a uma defini√ß√£o em que, em vez de <code>||</code>  usado por <code>Or</code> . <br><br>  A resposta a esta pergunta √© a seguinte: ainda √© poss√≠vel construir um an√°logo de <code>insert</code> para <code>TotalOrder</code> , no entanto, para isso, ter√≠amos que provar que o tipo da fun√ß√£o de <code>insert</code> √© uma declara√ß√£o (isso nos permitiria na defini√ß√£o de <code>insert</code> corresponder √† amostra de acordo com a declara√ß√£o de <code>totality xy</code> ). <br><br>  Em outras palavras, ter√≠amos que provar que existe apenas uma lista ordenada at√© a igualdade, que √© o resultado da inser√ß√£o do elemento <code>y</code> na lista ordenada <code>xs</code> .  √â f√°cil perceber que esse √© um fato verdadeiro, mas sua prova formal n√£o √© mais t√£o trivial.  Deixamos a verifica√ß√£o desse fato como um exerc√≠cio para o leitor interessado. <br><br><h2>  3. Observa√ß√µes finais </h2><br>  Nesta introdu√ß√£o, nos familiarizamos com as principais constru√ß√µes da linguagem Arend e tamb√©m aprendemos como usar o mecanismo de classe.  Conseguimos implementar o algoritmo mais simples, juntamente com a prova de sua especifica√ß√£o.  Assim, mostramos que o Arend √© bastante adequado para resolver problemas "cotidianos", como, por exemplo, verifica√ß√£o de programas. <br><br>  Mencionamos longe de todos os recursos do Arend.  Por exemplo, dissemos quase nada sobre <i>tipos com condi√ß√µes</i> que permitem ‚Äúcolar‚Äù v√°rios construtores de tipos com alguns valores de par√¢metros especiais para esses construtores.  Por exemplo, uma implementa√ß√£o do tipo inteiro no Arend √© fornecida usando tipos com condi√ß√µes da seguinte maneira: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Essa defini√ß√£o diz que n√∫meros inteiros consistem em duas c√≥pias do tipo de n√∫meros naturais, nos quais s√£o identificados zeros "positivos" e "negativos".  Essa defini√ß√£o √© muito mais conveniente do que a defini√ß√£o da biblioteca Coq padr√£o, onde a "c√≥pia negativa" dos n√∫meros naturais deve ser "deslocada em um" para que essas c√≥pias n√£o se cruzem (√© muito mais conveniente quando a nota√ß√£o <code>neg 1</code> significa o n√∫mero -1, n√£o -2) . <br><br>  N√£o dissemos nada sobre o algoritmo para derivar n√≠veis predicativos e homot√≥picos nas classes e suas inst√¢ncias.  Tamb√©m dificilmente mencionamos o tipo de intervalo <code>I</code> , embora ele desempenhe um papel fundamental na teoria de tipos com intervalos, que s√£o a base l√≥gica de Arend.  Para entender como esse tipo √© importante, basta mencionar que, no tipo Arend, a igualdade √© definida pelo conceito de intervalo.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470632/">https://habr.com/ru/post/pt470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470616/index.html">Uma nova solu√ß√£o para o paradoxo de Fermi (por que estamos sozinhos no universo)</a></li>
<li><a href="../pt470618/index.html">Modelagem tem√°tica de not√≠cias usando an√°lise fatorial</a></li>
<li><a href="../pt470620/index.html">Infraestrutura como c√≥digo: como superar problemas com o XP</a></li>
<li><a href="../pt470622/index.html">Vis√£o geral dos m√©todos de sele√ß√£o de recursos</a></li>
<li><a href="../pt470628/index.html">Constru√ß√£o naval de simulador de nave espacial</a></li>
<li><a href="../pt470634/index.html">Identifique comunidades cruzadas no Instagram para identificar os interesses dos usu√°rios</a></li>
<li><a href="../pt470638/index.html">M√©todos quase-newtonianos ou quando existem muitas segundas derivadas para Athos</a></li>
<li><a href="../pt470640/index.html">Pesquisando o Elasticsizing</a></li>
<li><a href="../pt470642/index.html">Conhe√ßa Yandex.Station Mini. Grande hist√≥ria de um pequeno dispositivo</a></li>
<li><a href="../pt470644/index.html">Por que os blogs corporativos √†s vezes azedam: algumas observa√ß√µes e dicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>