<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈚️ 🙋🏼 🍘 Editor logika visual untuk Unity3d. Bagian 1 🙀 🕵️ 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Halo para pembaca, dalam artikel hari ini saya ingin membahas fenomena dalam pengembangan aplikasi di Unity3d sebagai pengembangan visua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Editor logika visual untuk Unity3d. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448190/"><h2>  Pendahuluan </h2><br>  Halo para pembaca, dalam artikel hari ini saya ingin membahas fenomena dalam pengembangan aplikasi di <b>Unity3d</b> sebagai pengembangan visual atau, lebih tepatnya, pengembangan menggunakan representasi visual dari kode dan logika.  Dan, sebelum melanjutkan, saya ingin mengklarifikasi segera, ini bukan tentang pemrograman visual, dari kata "mutlak", tidak ada variasi <b>Cetak Biru</b> di dunia Persatuan dan tidak ada generasi kode C #.  Jadi apa yang dimaksud dengan editor logika visual?  Jika Anda tertarik dengan jawaban untuk pertanyaan ini, selamat datang di bawah kucing. <br><br>  Artikel dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Editor Logika Visual Bagian 2</a> <br><a name="habracut"></a><br><h2>  Apa itu editor logika visual </h2><br>  Sangat sering, dan beberapa berpendapat bahwa selalu, selama pengembangan, programmer menulis banyak kode berbeda yang melakukan banyak hal berbeda, dari yang sistem ke mekanik permainan.  Kode ini, jika programmernya "nyata", biasanya dibuat bersatu dan terisolasi sehingga dapat digunakan kembali (dalam Unity, kode ini adalah komponen, mereka juga pewaris <b>MonoBehavior</b> ).  Tidak sulit membayangkan bahwa ada banyak kode seperti itu, terutama jika ini bukan proyek pertama.  Sekarang bayangkan kita memulai proyek baru dan kita perlu membuat banyak prototipe yang cepat dan berbeda, dan tim pemrogram terbatas, dan keseluruhannya sibuk dengan proyek atau proyek utama.  Desainer game marah, mereka perlu menguji, memeriksa, produsen berlarian di sekitar manajer, mencoba mendapatkan programmer sendiri, uang terbatas, waktu hampir habis, dll. <br><br>  Sisi lain dari koin, kami (programmer) menulis banyak kode dalam bentuk komponen, mereka menggantungkan daftar besar pada objek yang berbeda di tempat kejadian.  Dan jadi kami memperluas tim, kami merekrut seorang programmer baru, ia membuka panggung untuk menyelesaikannya dan tenggelam dalam banyak pertanyaan: siapa yang menyebabkan siapa, dalam urutan apa, komponen mana yang terhubung dengan mana dan bagaimana, dll. Anda cukup mengatakan: - “Dan dokumentasi? "  Ada dokumentasi (meskipun sama sekali bukan fakta), tetapi di sini adalah tentang ambang batas bagi orang-orang baru yang bergabung dengan tim serendah mungkin, dan waktu untuk proses ini sesingkat mungkin. <br><br>  Bagaimana cara mengatasi situasi yang dijelaskan di atas?  Jawaban dalam judul artikel adalah Editor Logika Visual.  Apa ini  Ini adalah lingkungan yang memungkinkan Anda untuk beroperasi secara visual pada berbagai komponen logika dan mengkonfigurasi hubungan mereka (dalam versi "lunak"), serta memanipulasi objek adegan secara tidak langsung dari tempat kejadian.  Jika Anda menggambarkannya dalam bentuk yang sangat sederhana, maka seperti di masa kanak-kanak untuk mengumpulkan desain yang berbeda dari kubus (hanya dalam kasus kami, kubus tidak terhubung erat, melepas bagian bawah, desain kami tidak akan jatuh). <br><br>  Jadi, kami menemukan definisi, tetapi apa yang akhirnya memberi kami pada hal ini? <br><br><ul><li>  Anda dapat merakit desain universal yang dapat digunakan kembali dalam proyek, yang mengurangi rutinitas selanjutnya.  Bayangkan semacam bidang murni, yang merupakan proyek kami, kami hanya mengambil konstruksi rakitan dari game lain, meletakkannya di lapangan dan hanya itu. </li><li>  Anda dapat membuat database "kubus" terisolasi (mekanik, logika, fungsional) dari mana orang yang bukan programmer dapat membangun konstruksi sendiri. </li><li>  Dimungkinkan untuk mengganti desain dengan cepat dengan yang lain, sehingga mengubah perilaku logika. </li><li>  Anda dapat menggunakan konstruksi dalam mode ditangguhkan, misalnya, jika NPC tidak ada di dunia sekarang, maka tidak ada logika yang terkait dengannya akan ada di "bidang" kami. </li><li>  Karena kubus kami tidak terhubung oleh hubungan yang kaku, kami dapat mematikannya dan hidup seperti yang kami inginkan dan menerapkan percabangan kondisional dan percabangan tanpa syarat yang rumit. </li></ul><br>  Nah, apakah itu terdengar cukup bagus?  Tapi apa kenyataannya?  Jika Anda membuka <b>Toko Aset</b> dan melihat bagian <b>Visual Scripting</b> , Anda dapat melihat, pada prinsipnya, sejumlah besar plugin yang berbeda.  Kebanyakan dari mereka adalah variasi pada tema Cetak Biru dari Mesin Unreal, yaitu, pada dasarnya, pembuatan kode.  Praktis tidak ada sistem yang sesuai dengan konsep editor logika visual.  Arti terdekat adalah: <br><br><ol><li>  <b>Playmaker</b>  Ya itu adalah plugin FSM, tetapi meskipun demikian, ini memungkinkan Anda untuk menulis Tindakan Anda sendiri.  Ini tidak begitu nyaman dari sudut pandang antarmuka, tetapi untuk hal-hal tertentu itu sangat bagus.  Blizzard tidak sia-sia digunakan di Hearthstone. </li><li>  <b>Desainer Perilaku / MoonBehavior</b> , dll.  plugin pohon negara.  Itu lebih dekat dengan apa yang dijelaskan di atas, tetapi ada banyak batasan, setelah semua, pohon negara bukan logika lengkap pada komponen. </li><li>  <b>ICode</b>  Ini adalah analog dari playmaker, yaitu, pada kenyataannya, juga mesin negara. </li></ol><br>  Apakah ada jalan keluar yang Anda tanyakan, pembaca yang budiman?  Saya hanya menemukan satu, tulis sistem saya, yang saya lakukan, tetapi jalan menuju itu cukup panjang dan berduri. <br><br><h2>  Jalan </h2><br>  Gagasan untuk mengembangkan plugin untuk editor logika visual untuk <b>Unity3D</b> muncul sejak lama.  Pada awalnya hanya pikiran yang, jika demikian, itu akan keren.  Pikiran-pikiran ini muncul dalam proses mengerjakan sebuah proyek di mana ada banyak permainan serupa, lebih dari 20 buah yang perlu dilakukan dengan sangat, sangat cepat.  Implementasi pertama sangat buruk dalam hal antarmuka, meskipun, tentu saja, memungkinkan kami untuk berhasil mengembangkan seluruh rangkaian game pada kecepatan yang diberikan. <br><br>  Untuk proyek selanjutnya, diputuskan untuk membuat editor visual yang lengkap, tetapi sebagai hasil dari sedikit pengalaman, implementasi tidak berhasil, semuanya sangat lambat, jumlah koneksi, dll. Hal-hal berubah skala sehingga tidak mungkin untuk mencari tahu apa dan di mana (lihat tangkapan layar dan jangan takut). <br><br><img src="https://habrastorage.org/webt/kj/gm/bk/kjgmbkaf2uoytuksxl1x2cevbmc.png" alt="gambar"><br><br>  Setelah itu, gagasan itu ditunda untuk beberapa waktu.  Proyek-proyek berikut sudah saya lakukan pada kode murni, tetapi gagasan itu masih melayang di kepala saya.  Lambat laun, dengan mempertimbangkan kesalahan masa lalu, visi dan daftar persyaratan final (seperti yang tampak bagi saya) terbentuk.  Dan pada tahun 2017, setelah selesainya proyek freelance berikutnya, saya memutuskan bahwa saya mampu menghabiskan 6-7 bulan bekerja pada plugin ini dan mencoba untuk meletakkannya di <b>Asset Store</b> (masih terletak dan disebut <b>Panthea VS</b> ).  Dari sudut pandang pengalaman bekerja pada proyek yang sedemikian kompleks, semuanya sangat keren, sisi keuangannya sangat menyedihkan, masih bisa memprogram dan bisa menjual adalah dua hal yang berbeda.  Itu adalah November 2017, setelah itu saya kehilangan motivasi sedikit, bercerai, mengubah kota saya, benar-benar mengubah hidup saya, dan agar tidak jatuh ke samoyedisme saya memutuskan untuk melihat sudut pandang yang berbeda pada topik editor logika visual.  Hasilnya adalah <b>uViLEd</b> , yang saya putuskan untuk diposkan secara gratis.  Karena saya menandatangani kontrak penuh waktu, saya harus mengerjakannya pada akhir pekan dan hari libur dan saya membutuhkan semua 2018 dan awal 2019.  <b>uViLEd</b> adalah pemikiran besar <b>Panthea VS</b> , sebuah refactoring lengkap dari kode untuk kompiler Roslyn (C # 7+), jadi semuanya bekerja hanya dari versi Unity3d 2018.3. <br><br>  <b>Catatan</b> : <b>Panthea VS</b> meluncurkan beberapa proyek (Android dan iOS, khususnya, Lev's Truck and cars), pada prinsipnya, pengalaman menggunakannya berhasil, tetapi saat itu muncul bahwa adalah satu hal untuk menulis editor, hal lain adalah belajar bagaimana menggunakannya dengan benar (tidak peduli betapa aneh kedengarannya) ) <br><br><h2>  uViLEd dan cara menggunakannya </h2><br><h3>  Pendahuluan </h3><br>  Jadi, apa yang terjadi pada akhirnya, pertama kita melihat gambar, dan kemudian melanjutkan (akan ada lebih banyak gambar). <br><br><img src="https://habrastorage.org/webt/ll/sk/g2/llskg2i3-e2niclqltvvh4csms4.png" alt="gambar"><br><br>  Apa yang didasarkan pada editor logika visual? <br><br><img src="https://habrastorage.org/webt/p0/pn/wn/p0pnwnewe_s-_vpu704ucuzaiso.png" alt="gambar"><br><br>  Di sini: <br><br><ul><li>  <b>Komponen</b> - ini adalah kode kami yang mengimplementasikan fungsional satu atau yang lain, pada kenyataannya, analog dari <b>MonoBehaviour</b> , hanya dalam kasus kami semua komponen diwarisi dari kelas <b>LogicComponent</b> , yang pada gilirannya adalah <b>ScriptableObject</b> . </li><li>  <b>Variabel</b> adalah <b>ScriptableObjects</b> khusus yang diizinkan untuk menyimpan data (apa saja, termasuk struktur dan kelas khusus, referensi ke objek pemandangan, cetakan dan aset).  Variabel diperlukan jika perlu untuk membuat data dibagi antara komponen, yaitu, setiap komponen dapat merujuk ke variabel dari tipe yang diinginkan, dan itu akan menjadi satu. </li><li>  <b>Hubungan</b> adalah deskripsi dalam bentuk visual dari komponen apa, bagaimana dan bagaimana urutan metode masing-masing.  Hubungan antara komponen ditentukan menggunakan dua bidang khusus jenis <b>INPUT_POINT</b> dan <b>OUTPUT_POINT</b> .  Tautan selalu dibentuk sebagai titik keluaran suatu komponen ke titik input komponen lainnya.  Koneksi ini tidak kaku, yaitu, mereka tidak terlihat oleh programmer dan mereka juga tidak ada dalam kode.  Mereka hadir, hanya di editor, dan kemudian ketika adegan dimulai, pengontrol logika itu sendiri memahami kode.  Bagaimana ini terjadi kita akan berbicara dalam artikel terpisah. </li></ul><br>  Segala sesuatu di kompartemen - komponen, variabel, dan hubungan - membentuk <b>logika</b> .  Secara umum, tidak ada yang super rumit, programmer menulis kode komponen dan variabel, dan desainer game atau programmer / scripter lain (atau yang sama) membentuk logika dengan menempatkan komponen-komponen ini di editor dan mengatur koneksi dan parameter. <br><br><h3>  Fitur utama uViLEd </h3><br><ul><li>  Menjalankan logika (satu set komponen, variabel, dan hubungan) dalam mode ditangguhkan, termasuk mulai dari sumber eksternal (hard disk atau server) </li><li>  Mengatur koneksi antar komponen (urutan panggilan, aktivasi dan penonaktifan) </li><li>  Integrasi komponen dan kode lainnya dengan mudah, termasuk keturunan MonoBehavior </li><li>  Mengganti penampilan komponen dalam editor (analog dengan CustomPropertyDrawer) </li><li>  Mengkonfigurasi pengaturan komponen melalui inspektur Unity3d </li><li>  Mudah menambahkan komponen ke logika melalui file skrip drag &amp; drop atau melalui direktori </li><li>  Mengelompokkan komponen dalam editor logika </li><li>  Mengatur tampilan komponen dalam editor (inversi, minimalisasi, aktivasi dan deaktivasi) </li><li>  Membuka editor kode komponen langsung dari editor logika </li><li>  Menampilkan data debugging langsung di editor logika selama startup di editor </li><li>  Penskalaan editor logika visual </li><li>  Jika tiba-tiba sejumlah besar komponen terkandung dalam logika, maka ada kemungkinan untuk mencari mereka dengan fokus saat memilih (ini berlaku untuk variabel) <br></li><li>  Langkah demi langkah debugging dalam mode peluncuran adegan di editor Unity3d dengan pelacakan semua data yang dikirim antara komponen dan nilai variabel </li><li>  Dukungan untuk metode MonoBehaviour dan pengaturan urutan panggilan mereka.  <b>Catatan</b> : di sini kami maksudkan bahwa secara default dalam SO tidak ada metode seperti Mulai, Perbarui, dll.  oleh karena itu, dukungan mereka telah ditambahkan ke komponen itu sendiri.  Pada saat yang sama, menggunakan atribut ExecuteOrder, Anda dapat mengonfigurasi urutan metode Mulai, Pembaruan, dan seterusnya. </li><li>  Dukungan untuk Coroutine, async / tunggu dan semua atribut Unity3d untuk inspektur, serta dukungan untuk CustomPropertyDrawer </li></ul><br><h3>  Bekerja dengan editor </h3><br>  Untuk mulai bekerja dengan editor, Anda harus membuka adegan, dan kemudian mulai editor itu sendiri. <br><br><img src="https://habrastorage.org/webt/17/w5/s3/17w5s38ymve2zxwovfycnluasjw.png" alt="gambar"><br><br>  Setelah memulai editor, kami menginisialisasi adegan (tombol pembaruan di editor), setelah itu akan memungkinkan untuk membuat atau menambahkan logika yang ada ke adegan. <br>  Setelah membuat logika (file yang akan menjelaskan komponen, parameternya, hubungan antara komponen, variabel, dan nilainya), Anda dapat mengisinya dengan makna.  Untuk menambahkan komponen atau variabel, cukup seret skrip yang sesuai ke area editor logika.  Opsi alternatif adalah menggunakan direktori yang dihasilkan secara otomatis menggunakan atribut <b>ComponentDefinition</b> . <br><br><img src="https://habrastorage.org/webt/ip/bh/oo/ipbhooqxvj2dkl7fu3ni7bgzhl0.png" alt="gambar"><br><br>  Setelah kami menambahkan beberapa komponen ke logika, mereka dapat dipindahkan, termasuk dalam kelompok atau digabungkan ke dalam kelompok visual. <br><br><img src="https://habrastorage.org/webt/8w/ph/h4/8wphh4i-jnvymggo5hrfqlc562g.png" alt="gambar"><br><br>  Mari kita pertimbangkan secara lebih rinci apa yang kita wakili komponen itu sendiri dalam editor visual. <br><br><img src="https://habrastorage.org/webt/fo/nd/gd/fondgdse7kf9r_71dlpjmm8in0u.png" alt="gambar"><br><br>  Di sini: <br><br><ul><li>  Tombol menu komponen, membuka menu tarik-turun yang dapat Anda gunakan: <br><ul><li>  Aktifkan atau nonaktifkan komponen </li><li>  Minimalkan komponen (ini juga dapat dilakukan dengan mengklik dua kali pada tajuk) </li><li>  Balikkan komponen (tukar input dan titik output) </li><li>  Sembunyikan atau tampilkan area opsi komponen </li><li>  Buka editor kode untuk komponen </li></ul></li><li>  Area parameter komponen adalah tempat di mana nilai-nilai parameter kunci komponen ditampilkan, komposisi yang tergantung pada programmer </li></ul><br>  Untuk mengonfigurasi parameter (bidang atau bidang publik dengan atribut SerializeField), Anda harus memilih komponen di editor logika dan membuka inspektur Unity3d. <br><br><img src="https://habrastorage.org/webt/iz/fx/ep/izfxeppsnvrwpakv2xocjgueo-m.png" alt="gambar"><br><br>  Di sini: <br><br><ul><li>  Di sudut kanan atas adalah tombol yang memungkinkan Anda untuk mengubah warna header, yang ditampilkan di editor logika </li><li>  <b>Nama</b> - bidang untuk mengatur nama instance komponen </li><li>  <b>Komentar</b> - bidang untuk mengatur komentar pada instance komponen; itu ditampilkan dalam editor logika ketika Anda mengarahkan kursor ke komponen </li><li>  <b>Parameter Komponen</b> - area di mana parameter komponen ditampilkan (bidang publik dan bidang ditandai dengan SerializeField) </li><li>  <b>Tautan Variabel</b> - area untuk mengatur referensi ke variabel (lebih banyak tentang mereka akan dibahas pada bagian bekerja dengan variabel). </li></ul><br>  Untuk mengelompokkan objek secara visual, Anda harus memilihnya, lalu tekan tombol kanan dan pilih item yang sesuai di menu.  Grup dapat diubah namanya, serta mengubah skema warnanya. <br><br><img src="https://habrastorage.org/webt/qk/z8/yx/qkz8yxb7mo5rq7zgfanosvd_lak.png" alt="gambar"><br><br>  Untuk skala representasi visual dari komponen menggunakan roda mouse, semuanya cukup sederhana. <br><br>  Dan hal terakhir yang ingin saya perhatikan adalah bekerja dengan koneksi antar komponen. <br>  Untuk membuat koneksi, perlu menghubungkan titik output dari satu komponen dengan titik input yang lain. <br><br><img src="https://habrastorage.org/webt/oj/xa/po/ojxapozb2kopugx2k-hq8r7aosk.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/kc/jg/r5/kcjgr55qxhg8mgt87c8v8yqli8a.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/nw/7b/sf/nw7bsf7vc7paqif6jhgx6fkxnr8.png" alt="gambar"><br><br>  Hubungan dibuat berdasarkan aturan pencocokan tipe yang dikirimkan dan diterima suatu titik.  Pengecualian dibuat untuk titik input yang tidak menerima data, setiap titik output dapat dihubungkan ke sana.  Ketika koneksi dibuat, sistem secara otomatis memeriksa jenis yang cocok dan menunjukkan apakah koneksi ini dapat dibuat atau tidak.  Titik input dan output diatur dalam kode komponen menggunakan kelas berikut: <br><br><pre><code class="cs hljs">INPUT_POINT OUTPUT_POINT INPUT_POINT&lt;T&gt; OUTPUT_POINT&lt;T&gt;</code> </pre> <br>  Dua kelas pertama digunakan untuk titik input dan output yang tidak menerima parameter, yang kedua, masing-masing, sebaliknya.  T bisa jenis apa saja. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> INPUT_POINT &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; InputFloatValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT_POINT&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OUTPUT_POINT &lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; OutputFloatValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OUTPUT_POINT&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;();</code> </pre><br>  Untuk memanggil rantai tautan, Anda harus menggunakan fungsi Execute. <br><br><pre> <code class="cs hljs">OutputFloatValue.Execute(<span class="hljs-number"><span class="hljs-number">5f</span></span>);</code> </pre> <br>  Untuk memproses panggilan seperti itu, perlu untuk mengatur handler untuk titik input dalam kode komponen (tentang di mana tepatnya kita akan berbicara sedikit kemudian). <br><br><pre> <code class="cs hljs">InputFloatValue.Handler = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> =&gt; Debug.Log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>);</code> </pre> <br>  Dan akhirnya, saya ingin menyebutkan poin penting tentang koneksi.  Jika ada beberapa tautan dari satu titik, maka dalam editor dimungkinkan untuk menyesuaikan urutan panggilan mereka. <br><br><h3>  Bekerja dengan variabel </h3><br>  Seperti disebutkan sebelumnya, variabel adalah objek khusus yang memungkinkan Anda untuk berbagi data antar komponen melalui tautan ke mereka.  Variabel, seperti komponen, dibuat oleh programmer. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ComponentDefinition(Name = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Float"</span></span></span><span class="hljs-meta">, Path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uViLEd Components/Base/Variable/Base"</span></span></span><span class="hljs-meta">, Tooltip = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Variable for a floating-point number"</span></span></span><span class="hljs-meta">, Color = VLEColor.Cyan)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VariableFloat</span></span> : <span class="hljs-title"><span class="hljs-title">Variable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">float</span></span>&gt; { }</code> </pre><br>  Seperti yang Anda lihat, kelas dasar untuk variabel adalah variabel kelas generik, di mana T adalah tipe data yang disertakan dalam variabel, T dapat berupa tipe apa pun yang dapat diserialisasi. <br><br>  Di editor, variabel ditampilkan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/gu/nr/7u/gunr7u-e2ilyib-1whqiepzokpm.png" alt="gambar"><br><br>  Untuk mengubah tampilan nilai variabel, cukup mendefinisikan kembali metode ToString di tipe T. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CustomData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Value01; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Value02; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value01, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value02</span></span></span><span class="hljs-function">)</span></span> { Value01= value01; Value02= value02; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); stringBuilder.AppendLine(<span class="hljs-string"><span class="hljs-string">"Value01 = {0}"</span></span>.Fmt(Value01)); stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">"Value02 = {0}"</span></span>.Fmt(Value02)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stringBuilder.ToString(); } }</code> </pre><br>  Dengan demikian, variabel jenis ini akan terlihat seperti: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VariableCustomData</span></span> : <span class="hljs-title"><span class="hljs-title">Variable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">CustomData</span></span>&gt; { }</code> </pre> <br>  Untuk menambahkan referensi ke variabel dalam komponen, Anda harus menggunakan kelas khusus. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> VARIABLE_LINK&lt;CustomData&gt; CustomVariableLink = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VARIABLE_LINK&lt;CustomData&gt;();</code> </pre> <br>  Setelah itu, tautan dapat diatur di inspektur, dan di menu tarik-turun hanya variabel dari tipe <b>CustomData yang</b> akan ditampilkan, yang sangat menyederhanakan bekerja dengannya. <br><br>  Untuk kenyamanan bekerja dengan variabel, ada metode khusus yang memungkinkan Anda untuk menentukan kapan suatu variabel telah mengubah nilainya atau ketika data apa pun telah diatur untuk itu. <br><br><pre> <code class="cs hljs">CustomVariableLink.AddSetEventHandler(CustomDataSet); CustomVariableLink.AddChangedEventHandler(CustomDataChanged);</code> </pre><br>  Harus diingat bahwa karya Changed oleh kondisi <b>Persamaan</b> , oleh karena itu, jika struktur dan kelas digunakan, metode ini harus didefinisikan ulang untuk memastikan operasi yang benar. <br><br><h3>  Bekerja dengan Objek Persatuan </h3><br>  Karena sifat sistem uViLEd, tautan langsung ke objek Unity tidak dapat digunakan di dalamnya, karena mereka tidak dapat dipulihkan saat memuat logika.  Untuk mengatasi masalah ini, shell <b>VLObject</b> khusus telah dibuat, yang memungkinkan Anda membuat tautan seperti itu, serta menyimpan dan memuatnya.  Di antara hal-hal lain, shell ini memiliki editor properti khusus yang memungkinkan Anda untuk mendapatkan komponen dari objek apa pun dalam adegan (lihat gambar di bawah) jika Anda ingin mengaksesnya.  Dengan <b>VLObject,</b> Anda dapat menyimpan tautan tidak hanya ke objek pemandangan dan komponennya, tetapi juga ke prefab dan file sumber daya, seperti tekstur, suara, dll. <br><br><img src="https://habrastorage.org/webt/3i/wl/d4/3iwld4qttgr3fjboody9ruyeeyi.png" alt="gambar"><br><br>  <b>Catatan</b> : jika logika yang ada digunakan di adegan lain, referensi ke objek akan hilang, termasuk referensi ke cetakan, karena adegan bertindak sebagai penyimpanan mereka.  Ini juga harus diperhitungkan jika Anda berencana untuk menggunakan logika sebagai templat, dalam hal ini, opsi terbaik adalah mentransfer tautan yang diperlukan dari luar (misalnya, dari logika yang dilampirkan ke adegan). <br><br>  Dimungkinkan juga untuk membatasi jenis objek Unity yang akan diinstal di <b>VLObject</b> .  Ini hanya mempengaruhi inspektur Persatuan dan digunakan untuk kenyamanan bekerja dengan mereka. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] [TypeConstraint(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Button))] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> VLObject _button;</code> </pre> <br><h3>  Membuat komponen logika </h3><br>  Untuk membuat komponen logika, seorang programmer hanya perlu menambahkan file skrip C # sederhana ke proyek (Anda juga dapat membuat komponen atau variabel segera melalui menu khusus di tab Project) dan ubah kode di dalamnya sebagai berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ComponentDefinition(Name = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MyComponent"</span></span></span><span class="hljs-meta">, Path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MyFolder/MySubfolder"</span></span></span><span class="hljs-meta">, Tooltip = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this my logic component"</span></span></span><span class="hljs-meta">, Color = VSEColor.Green)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogicComponent</span></span> : <span class="hljs-title"><span class="hljs-title">LogicComponent</span></span> { }</code> </pre><br>  Seperti yang disebutkan sebelumnya, <b>ComponentDefinition</b> adalah atribut yang memungkinkan Anda untuk secara otomatis membuat katalog komponen, di sini harus dicatat bahwa Warna (warna header) diatur dalam string sebagai format HEX. <br><br>  <b>LogicComponent</b> adalah kelas dasar dari semua komponen, yang pada gilirannya adalah turunan dari <b>ScripatableObject</b> . <br><br>  Berikut ini adalah contoh sederhana dari komponen yang melakukan percabangan dengan nilai yang masuk dari tipe bool: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IfBool</span></span> : <span class="hljs-title"><span class="hljs-title">LogicComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> INPUT_POINT&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ValueToBeChecked = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT_POINT&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OUTPUT_POINT True = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OUTPUT_POINT(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OUTPUT_POINT False = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OUTPUT_POINT(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ValueToBeChecked.Handler = ValueToBeCheckedHandler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValueToBeCheckedHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { True.Execute(); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { False.Execute(); } } }</code> </pre><br>  Jadi, seperti yang Anda lihat dari kode, kami menciptakan titik input komponen, yang mengambil nilai tipe bool dan dua titik keluaran yang dipanggil tergantung pada nilai apa yang kami dapatkan. <br><br>  Mungkin Anda sekarang memiliki pertanyaan, <b>Konstruktor</b> macam apa ini?  Saya jelaskan.  Secara default, <b>ScriptableObject</b> tidak mendukung metode seperti <b>Mulai</b> , <b>Pembaruan</b> , dll., Tetapi mendukung metode <b>Awake</b> , <b>OnEnable</b> , <b>OnDisable,</b> dan <b>OnDestroy</b> .  Jadi di sini adalah <b>Sedarlah</b> (seperti <b>OnEnable</b> ), dalam kasus <b>ScriptableObject</b> dibuat melalui metode <b>CreateInstance</b> selalu disebut, dan ini, pada kenyataannya, masalahnya.  Karena kenyataan bahwa objek dibuat dalam memori untuk serialisasi dalam mode editor, maka perlu untuk mengecualikan kode komponen dari bekerja pada saat ini, oleh karena itu analog <b>Sedar</b> ditambahkan sebagai metode <b>Konstruktor</b> , hal yang sama berlaku untuk metode <b>OnDisable</b> dan <b>OnDestroy</b> ketika menghapus objek dalam editor.  Jika Anda perlu memproses penghapusan komponen dengan benar (misalnya, saat membongkar adegan), maka Anda harus menggunakan antarmuka <b>IDisposable</b> . <br><br>  Secara umum, seperti yang Anda lihat, tidak ada yang sulit dalam membuat komponen.  Ini adalah kelas reguler, di mana ada kode yang Anda inginkan.  Dalam kasus tertentu, komponen mungkin tidak mengandung titik input dan output sama sekali, tetapi berkomunikasi menggunakan pesan global.  Ngomong-ngomong, untuk ini, di <b>uViLEd</b> ada kelas <b>GlobalEvent</b> - ini adalah sistem pesan berdasarkan tipe data (lebih lanjut tentang itu dapat ditemukan di artikel saya). <br><br>  Hal terakhir yang ingin saya sebutkan adalah kemampuan untuk mengkonfigurasi titik input dan output komponen tergantung pada parameter komponen. <br><br><img src="https://habrastorage.org/webt/om/xi/0e/omxi0ebaaiuixhln-gpqmkdqz5g.png" alt="gambar"><br><br>  Untuk melakukan ini, dalam kode komponen, cukup menerapkan satu atau kedua <b>antarmuka IInputPointParse</b> dan <b>IOutputPointParse</b> .  Di bawah ini adalah contoh dari kode kelas generik abstrak untuk komponen <b>Switch</b> cabang; titik output secara otomatis dibuat di sini, tergantung pada parameter <b>SwitchValues</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Kode Kelas SwitchAbstract</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SwitchAbstract</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">LogicComponent</span></span>, <span class="hljs-title"><span class="hljs-title">IOutputPointParse</span></span> { [Tooltip(<span class="hljs-string"><span class="hljs-string">"input point for transmitting value, which should be checked"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> INPUT_POINT&lt;T&gt; ValueToBeChecked = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> INPUT_POINT&lt;T&gt;(); [Tooltip(<span class="hljs-string"><span class="hljs-string">"set of values for branching"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;T&gt; SwitchValues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; outputPoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ValueToBeChecked.Handler = ValueToBeCheckedHandler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareEqual</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T first, T second</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.Equals(second); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValueString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputPontName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ToString(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!UnityEditor.EditorApplication.isPlaying) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (outputPoints.ContainsKey(outputPontName)) { outputPontName += " ({0})".Fmt(outputPoints.Count); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return outputPontName; } private void ValueToBeCheckedHandler(T checkedValue) { foreach (var value in SwitchValues) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (CompareEqual(checkedValue, value)) { ((OUTPUT_POINT)outputPoints[GetValueString(value)]).Execute(); return; } } } public IDictionary&lt;string, object&gt; GetOutputPoints() { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!UnityEditor.EditorApplication.isPlayingOrWillChangePlaymode) { outputPoints.Clear(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (outputPoints.Count == 0) { foreach (var value in SwitchValues) { outputPoints.Add(GetValueString(value), new OUTPUT_POINT()); } } return outputPoints; } }</span></span></code> </pre> <br></div></div><br><h3>  Debugging logika </h3><br>  UViLEd menyediakan beberapa mekanisme untuk debugging logic: <br><br><ol><li>  Kemampuan untuk menampilkan variabel internal dan nilainya dalam editor logika dalam mode peluncuran adegan.  Untuk melakukan ini, gunakan atribut <b>ViewInDebugMode</b> </li><li>  Kemampuan untuk melihat nilai variabel logika dalam mode peluncuran adegan </li><li>  Kemungkinan debugging langkah-demi-langkah dari panggilan antar komponen dan melihat data yang ditransfer di antara mereka </li></ol><br>  UViLEd memiliki mode khusus untuk item terakhir, yang menyala saat adegan dimulai. <br><br><img src="https://habrastorage.org/webt/vg/i2/rs/vgi2rsffppoc1zwyq4px7ojgmk0.png" alt="gambar"><br><br>  Mode ini, sayangnya, memiliki keterbatasan tertentu yang terkait dengan transisi antar adegan.  Dalam hal ini, data debug dari adegan sebelumnya dan logika akan hilang, dan dalam yang baru mereka akan mulai ditampilkan hanya dari saat logika diaktifkan di editor. <br><br><h2>  Kesimpulan </h2><br>  Dalam artikel ini saya mencoba memperkenalkan Anda secara singkat tentang pendekatan pengembangan yang saya gunakan dalam proyek saya saat ini.  Meskipun skeptisisme awal (termasuk saya), praktik menunjukkan secara signifikan kenyamanan penggunaannya, terutama ketika membuat prototipe.  Antara lain, karya desainer game telah sangat disederhanakan, mereka tidak masuk ke tempat kejadian, tidak menyodok objek untuk mengkonfigurasi proses permainan, logika terpisah dibuat untuk mereka dengan satu set data variabel dan komponen di mana mereka dapat dengan mudah mengkonfigurasi semuanya.  Juga keuntungan besar adalah kenyataan bahwa dalam proyek saya, seringkali kontennya diunduh dari luar.  Menggunakan editor logika visual, saya dapat memperbarui keseimbangan proses permainan tanpa memperbarui aplikasi utama, dalam beberapa kasus, logika itu sendiri dapat diubah. <br><br>  Bagi saya sendiri, saya memutuskan bahwa pendekatan pengembangan semacam itu adalah tempatnya, tentu saja itu tidak berlaku untuk proyek-proyek besar, tetapi dapat digunakan di sana untuk beberapa skrip gameplay untuk merevitalisasi dunia, dalam desain level, dll. proyek yang sedang berjalan (segmen anak-anak), sejauh ini, ia menunjukkan hasil yang bagus. <br><br>  Apa selanjutnya <br><br>  Ini adalah bagian pertama dari serangkaian artikel tentang editor visual logika uViLEd, maka akan ada bagian tentang: <br><br><ol><li>  <b>Inti dari sistem</b> : bagaimana logika dimuat, mengapa ScriptableObject dipilih, bagaimana API diatur, yang memungkinkan Anda melakukannya, dll., Kesulitan apa yang muncul dan bagaimana semuanya diselesaikan. </li><li>  <b>Editor</b> : bagaimana itu dikembangkan, bagaimana itu dibangun, masalah apa dan solusi apa, dll hal-hal, yang akan saya buat kembali sekarang. </li></ol><br>  Tulis di komentar jika Anda memiliki pertanyaan spesifik yang ingin Anda sampaikan di artikel selanjutnya. <br><br>  <b>PS</b> : Saya mencoba berbicara tentang poin-poin penting dari <b>uViLEd</b> , jika Anda memiliki keinginan, Anda dapat membiasakan diri dengan mengunduh plugin dari Asset Store, ada dokumentasi lengkap (meskipun dalam bahasa Inggris): panduan pengguna, panduan untuk programmer dan API. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Editor Logika Visual Bagian 2</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Editor logika visual UViLEd</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Perpesanan Global</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448190/">https://habr.com/ru/post/id448190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448180/index.html">Alat untuk wifi yang bagus. Ekahau Pro dan lainnya</a></li>
<li><a href="../id448182/index.html">Calon pengalaman dalam merekrut pengembang perangkat lunak. Bagian 1</a></li>
<li><a href="../id448184/index.html">Minggu Keamanan 16: Pencurian Identitas Digital</a></li>
<li><a href="../id448186/index.html">Dari pemodelan proses hingga merancang sistem otomatis (Bagian 2)</a></li>
<li><a href="../id448188/index.html">Kapsul waktu: HP iPaq h1940 "di luar kotak." Apa itu PDA untuk dari tahun 2000-an</a></li>
<li><a href="../id448192/index.html">Mengapa kita perlu dalam produksi AR dan VR</a></li>
<li><a href="../id448194/index.html">Calon pengalaman dalam merekrut pengembang perangkat lunak. Bagian 2</a></li>
<li><a href="../id448196/index.html">Masa depan (atau hadiah rahasia) mesin plasma atau bagaimana mencapai 27 max swing di atmosfer</a></li>
<li><a href="../id448198/index.html">Amankan transfer data antara dua aplikasi</a></li>
<li><a href="../id448202/index.html">Kami mengontrol generator atau perang melawan ADC di STM32F030</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>