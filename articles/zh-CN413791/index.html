<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍈 🎏 🤶 JS中的计算量子力学 🎾 🌂 😨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，我叫德米特里·卡洛夫斯基，我……待业。 因此，我有很多空闲时间来播放音乐，运动，创造力，语言，JS会议和计算机科学。 我将向您介绍半自动将长计算拆分为几毫秒的小量域的最新研究，这产生了一个微型库$mol_fiber 。 但首先，让我们概述我们将要解决的问题.. 





 这是HolyJS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS中的计算量子力学</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p>您好，我叫德米特里·卡洛夫斯基，我……待业。 因此，我有很多空闲时间来播放音乐，运动，创造力，语言，JS会议和计算机科学。 我将向您介绍半自动将长计算拆分为几毫秒的小量域的最新研究，这产生了一个微型库<code>$mol_fiber</code> 。 但首先，让我们概述我们将要解决的问题.. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="广达！"></p><br><p> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HolyJS 2018 Piter中</a>同名表演的文本版本。 您可以将<a href="">其作为文章阅读</a> ，也<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以在演示界面中将其打开</a> ，或者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">观看视频</a> 。 </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness"> 问题：响应速度慢 </h1><br><p> 如果我们希望每秒稳定60帧，那么只有16微秒的毫秒可以完成所有工作，包括浏览器在屏幕上显示结果的工作。 </p><br><p> 但是，如果我们花更长的时间怎么办？ 然后，用户将观察到滞后的界面，从而抑制了UX降级的动画等。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="低响应"></p><br><h1 id="issue-no-escape"> 问题：无法逃脱 </h1><br><p> 碰巧在执行计算时，结果对我们而言不再有意义。 例如，我们有一个虚拟滚动，用户主动拉动它，但是我们无法跟上它，也无法渲染实际区域，直到上一个渲染返回控件来处理用户事件。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="无法撤消"></p><br><p> 理想情况下，无论我们做多长时间，我们都应继续处理事件，并能够随时取消已经开始但尚未完成的工作。 </p><br><h1 id="im-fast-and-i-know-it"> 我很快，我知道 </h1><br><p> 但是，如果我们的工作不是一个，而是几个，而是一个流，该怎么办？ 想象一下，您驾驶着刚购买的黄莲花开车前往铁路道口。 当它是免费的时，您可以瞬间将其滑动。 但是.. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="酷车"></p><br><h1 id="issue-no-concurrency"> 问题：无并发 </h1><br><p> 当过境点被一公里的火车所占据时，您必须站起来等待十分钟，直到它过去为止。 不是因为您买了跑车，对吗？ </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="快速等待慢"></p><br><p> 如果将这列火车分成10列每列100米的火车，它们之间会有几分钟的路程，那将有多酷！ 那时您不会太迟。 </p><br><p> 那么，现在在JS世界中解决这些问题的解决方案是什么？ </p><br><h1 id="solution-workers"> 解决方案：工人 </h1><br><p> 想到的第一件事：让我们将所有复杂的计算放到单独的线程中吗？ 为此，我们为WebWorkers提供了一种机制。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="工人逻辑"></p><br><p>  UI流中的事件将传递给工作程序。 在那里进行处理，并且关于页面上的内容和更改方式的说明已经传回。 因此，我们从大量的计算层中保存了UI流，但是并非所有问题都以这种方式解决，此外还添加了新的问题。 </p><br><h1 id="workers-issues-deserialization"> 工人：问题：（De）序列化 </h1><br><p> 流之间的通信是通过发送序列化为字节流，传输到另一个流并在其中被解析为对象的消息而发生的。 这比在单个线程中直接调用方法要慢得多。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="（De）序列化"></p><br><h1 id="workers-issues-asynchronous-only"> 工人：问题：仅异步 </h1><br><p> 消息严格异步传输。 这意味着我要求您使用某些功能。 例如，您无法停止来自工作程序的ui事件的上升，因为到处理程序启动时，UI线程中的事件将已经完成其生命周期。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="消息浓度"></p><br><h1 id="workers-issues-limited-apis"> 工作者：问题：API受限 </h1><br><p> 以下API对我们的工作人员不可用。 </p><br><ul><li>  DOM，CSSOM </li><li> 帆布 </li><li> 地理位置 </li><li> 历史和位置 </li><li> 同步http请求 </li><li>  XMLHttpRequest.responseXML </li><li> 窗 </li></ul><br><h1 id="workers-issues-cant-cancel"> 工人：问题：无法取消 </h1><br><p> 再说一次，我们无法停止计算。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="别说了"></p><br><p> 是的，我们可以停止整个工作人员，但是这将停止其中的所有任务。 <br> 是的，您可以在单独的工作程序中运行每个任务，但这会占用大量资源。 </p><br><h1 id="solution-react-fiber"> 解决方案：反应纤维 </h1><br><p> 当然，很多人听说过FaceBook英勇地重写了React，将其中的所有计算分解为由特殊调度程序启动的一堆小功能。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="棘手的反应光纤逻辑"></p><br><p> 由于这是一个单独的大主题，因此我不会详细介绍其实现。 我将仅介绍一些功能，因此可能不适合您。 </p><br><h1 id="react-fiber-react-required"> 反应纤维：需要反应 </h1><br><p> 显然，如果您使用Angular，Vue或React以外的其他框架，那么React Fiber对您毫无用处。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="反应大家！"></p><br><h1 id="react-fiber-only-rendering">  React Fiber：仅渲染 </h1><br><p>  React-仅覆盖渲染层。 该应用程序的所有其他层均未进行任何量化。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="没那么快！"></p><br><p> 当您需要例如通过棘手的条件过滤大量数据时，React Fiber不会为您省钱。 </p><br><h1 id="react-fiber-quantization-is-disabled"> 反应光纤：禁用量化 </h1><br><p> 尽管声称支持量化，但默认情况下它仍处于关闭状态，因为它破坏了向后兼容性。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="营销陷阱"></p><br><p>  React中的量化仍然是实验性的事情。 小心点！ </p><br><h1 id="react-fiber-debug-is-pain">  React Fiber：调试很痛苦 </h1><br><p> 启用量化功能后，调用堆栈将不再与您的代码匹配，从而使调试变得非常复杂。 但是，我们将回到这个问题。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="所有调试的痛苦"></p><br><h1 id="solution-quantization"> 解决方案：量化 </h1><br><p> 让我们尝试概括化React Fiber方法，以摆脱上述缺点。 我们希望停留在一个流的框架内，但将长时间的计算分解为较小的量，在此之间，浏览器可以呈现已对页面进行的更改，我们将响应事件。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="火焰图"></p><br><p> 在上方，您看到了很长的计算，使整个世界停滞了100毫秒以上。 从下面开始-进行相同的计算，但细分为约16毫秒的时间片，平均每秒可产生60帧。 由于我们通常不知道计算会花费多少时间，因此我们无法手动将其提前分成16ms。 因此，我们需要某种运行时机制来衡量完成任务和超出量子范围所需的时间，这将暂停执行直到下一个动画帧。 让我们考虑一下我们在这里有什么机制可以实施这些暂停的任务。 </p><br><h1 id="concurrency-fibers--stackfull-coroutines"> 并发：纤维-Stackfull协程 </h1><br><p> 在像Go和D这样的语言中，有一个成语是“带有堆栈的协程”，它也是“纤维”或“纤维”。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p> 在代码示例中，您将看到<code>one</code>功能，该功能可以暂停当前光纤，但它本身具有完全同步的接口。  <code>two</code> ， <code>three</code>和<code>four</code>功能是常规同步功能，它们对光纤一无所知。 在其中，您可以充分使用javascript的所有功能。 最后，在最后一行，我们仅在单独的光纤中运行这<code>four</code>功能。 </p><br><p> 使用光纤非常方便，但是要支持它们，您需要运行时支持，而大多数JS解释器都没有。 但是，对于NodeJS，有一个本机<code>node-fibers</code>扩展添加了此支持。 不幸的是，任何浏览器都没有可用的浏览器。 </p><br><h1 id="concurrency-fsm--stackless-coroutines"> 并发：FSM-无堆栈协程 </h1><br><p> 在像C＃和现在的JS这样的语言中，都支持“无堆栈协程”或“异步函数”。 这些功能是一个状态机，对堆栈一无所知，因此您必须用特殊关键字“ async”标记它们，并在其中可以暂停它们的位置-“ await”。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p> 由于我们可能需要随时推迟计算，因此事实证明，几乎必须将应用程序中的所有功能都设为异步。 这不仅是代码的复杂性，而且会极大地影响性能。 此外，许多接受回调的API仍不支持异步回调。 一个引人注目的示例是任何数组的<code>reduce</code>方法。 </p><br><h1 id="concurrency-semi-fibers---restarts"> 并发：半光纤-重新启动 </h1><br><p> 让我们尝试使用类似于光纤的功能，仅使用任何现代浏览器中可用的功能。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p> 如您所见，中间函数对中断一无所知-这是常规JS。 只有<code>one</code>功能知道暂停的可能性。 要中止计算，她只是将<code>Promise</code>抛出为异常。 在最后一行，我们在单独的伪光纤中运行这<code>four</code>功能，该函数监视内部抛出的异常，如果<code>Promise</code>到达，则预订其<code>resolve</code> ，然后重新启动光纤。 </p><br><h1 id="figures"> 人物 </h1><br><p> 为了展示伪光纤的工作原理，我们将编写一个棘手的代码。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="典型执行图"></p><br><p> 假设这里的<code>step</code>函数将一些内容写入控制台，并在20ms内完成了一些其他工作。  <code>walk</code>功能调用两次，记录整个过程。 在中间，它将显示控制台中现在显示的内容。 右边是伪纤维树的状态。 </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber：没有量化 </h1><br><p> 让我们运行这段代码，看看会发生什么.. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="无需量化即可执行"></p><br><p> 到目前为止，一切都很简单明了。 当然，不包含伪光纤树。 一切都会好起来的，但是这段代码执行的时间超过40毫秒，这毫无价值。 </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber：首先缓存 </h1><br><p> 让我们将两个函数包装在一个特殊的包装器中，该包装器在伪光纤中运行它，然后看看会发生什么。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="填充缓存"></p><br><p> 这里值得关注的事实是，对于在<code>walk</code>光纤内部调用<code>one</code>功能的每个位置，都创建了单独的光纤。 第一个调用的结果被缓存，但是由于我们用尽了时间片，所以抛出了<code>Promise</code>而不是第二个。 </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber：缓存第二个 </h1><br><p> 丢在第一帧中， <code>Promise</code>将在下一帧中自动解决，这将导致<code>walk</code>光纤重新启动。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="缓存重用"></p><br><p> 如您所见，由于重新启动，我们再次向控制台返回了“开始”和“首先完成”，但是“第一次开始”不再存在，因为它位于光纤中，缓存已较早填充，因此其处理程序更多不叫。 当<code>walk</code>光纤的缓存被填满时，所有嵌入的光纤都将被破坏，因为执行将永远无法到达它们。 </p><br><p> 那么，为什么<code>first begin</code>打印一次，然后<code>first done</code>打印两次呢？ 都是关于幂等的。  <code>console.log</code>非幂等操作，您调用它的次数，如此多次，它将向控制台添加一个条目。 但是在另一根光纤中执行的光纤是幂等的，它仅在第一次调用时执行该句柄，并在随后的返回中立即从缓存中返回结果，而不会导致任何其他副作用。 </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber：等幂优先 </h1><br><p> 让我们将<code>console.log</code>包裹在光纤中，使其成为幂等，然后查看程序的行为.. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="填充指数等缓存"></p><br><p> 如您所见，现在在光纤树中，每个调用<code>log</code>函数的条目都有条目。 </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber：幂等第二 </h1><br><p> 在<code>walk</code>光纤的下一次重新启动时，对<code>log</code>函数的重复调用不再导致对真实<code>console.log</code>调用，但是一旦我们执行了具有空缓存的光纤的执行，就立即恢复对<code>console.log</code>的调用。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="重用幂等缓存"></p><br><p> 请注意，在控制台中，我们现在不会显示任何多余的内容-完全是同步代码中显示的内容，而无需任何光纤和量化。 </p><br><h1 id="mol_fiber-break">  $ mol_fiber：中断 </h1><br><p> 计算如何中断？ 在数量开始时，设定了最后期限。 在启动每根光纤之前，请检查是否已经到达。 如果到达，则<code>Promise</code>赶到，这将在下一帧中解决，并开始一个新的量子.. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber：截止日期 </h1><br><p> 量子的截止日期很容易设定。 当前时间增加了8毫秒。 为什么正好是8个，因为最多要准备16个镜头？ 事实是我们不预先知道浏览器将需要渲染多长时间，因此我们需要留出一些时间才能正常工作。 但是有时会发生浏览器不需要渲染任何东西的情况，然后使用8ms量子，我们可以在同一帧中插入另一个量子，这将使量子紧密压缩，同时将处理器停机时间降至最低。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p> 但是，如果我们每8ms抛出一个异常，那么在异常停止打开的情况下进行调试将变成一团糟。 我们需要某种机制来检测此调试器模式。 不幸的是，这只能间接地理解：一个人花了大约一秒钟的时间来了解是否继续执行。 这意味着，如果控件很长时间没有返回脚本，则调试器将停止运行，或者计算量很大。 要坐在两把椅子上，我们将经过的时间增加10％，但不超过100毫秒。 这不会严重影响FPS，但是由于量化，它会将调试器的停止频率降低了一个数量级。 </p><br><h1 id="debug-trycatch"> 调试：尝试/捕获 </h1><br><p> 既然我们在谈论调试，那么您认为调试器在代码的什么位置停止？ </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p> 通常，他需要在第一次引发异常的位置停止，但现实情况是，他仅在上次引发异常的位置停止，通常离异常发生​​的位置很远。 因此，为了不使调试复杂化，永远不要通过try-catch捕获异常。 但是即使没有异常处理，这也是不可能的。 </p><br><h1 id="debug-unhandled-events"> 调试：未处理的事件 </h1><br><p> 通常，运行时会提供针对每个未捕获的异常发生的全局事件。 </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p> 除了麻烦之外，该解决方案还具有以下缺点：所有异常都落在这里，并且很难从哪个光纤和光纤中了解该事件是否发生。 </p><br><h1 id="debug-promise"> 调试：承诺 </h1><br><p> 承诺是处理异常的最佳方法。 </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p> 传递给Promise的函数将立即被同步调用，但是不会捕获到异常，并且可以安全地在发生调试器的位置停止调试器。 再过一会儿，它已经异步地调用了错误处理程序，在错误处理程序中，我们确切地知道是哪根光纤导致了故障，而哪根故障了。 这正是$ mol_fiber中使用的机制。 </p><br><h1 id="stack-trace-react-fiber"> 堆叠痕迹：反应纤维 </h1><br><p> 让我们看一下在React Fiber中获得的堆栈跟踪。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="空的数值"></p><br><p> 如您所见，我们得到了很多直觉。 从这里的有用处来看，层次结构中只有异常的发生点和组件的名称更高。 不是很多 </p><br><h1 id="stack-trace-mol_fiber"> 堆栈跟踪：$ mol_fiber </h1><br><p> 在$ mol_fiber中，我们获得了更为有用的堆栈跟踪：没有胆量，只有应用程序代码中的特定点才导致异常。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="内容跟踪"></p><br><p> 这可以通过使用本机堆栈，promise和自动删除肠来实现。 如果您愿意，可以在控制台中扩展错误，如屏幕截图所示，并查看其内容，但是没有什么有趣的。 </p><br><h1 id="mol_fiber-handle">  $ mol_fiber：处理 </h1><br><p> 因此，为了打断量子，将抛出Promise。 </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 但是，正如您可能猜到的那样，Promise绝对可以是任何东西-对Fibre而言，一般而言，期望的内容并不重要：下一帧，数据加载完成或其他。 </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 光纤只订阅解决承诺并重新启动。 但是不需要手动抛出和捕获承诺，因为该程序包包含几个有用的包装器。 </p><br><h1 id="mol_fiber-functions">  $ mol_fiber：函数 </h1><br><p> 要将任何同步函数转换为幂等光纤，只需将其包装在<code>$mol_fiber_func</code> 。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p> 在这里，我们使<code>console.log</code>幂等，并且<code>main</code>教导我们在等待下载时进行中断。 </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber：错误处理 </h1><br><p> 但是，如果我们不想使用<code>try-catch</code>该如何应对异常？ 然后我们可以使用<code>$mol_fiber_catch</code>注册错误处理程序。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p> 如果我们返回的错误与错误有所不同，那将是当前光纤的结果。 在此示例中，如果无法从服务器下载配置，则默认情况下， <code>getConfig</code>函数将返回配置。 </p><br><h1 id="mol_fiber-methods">  $ mol_fiber：方法 </h1><br><p> 当然，您不仅可以包装函数，还可以使用装饰器包装方法。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p> 例如，在这里，我们从Google上传数据并将其上传到Yandex。 </p><br><h1 id="mol_fiber-promises">  $ mol_fiber：承诺 </h1><br><p> 要从服务器下载数据，只需采取异步功能即可，只要轻按一下就可以将其转换为同步功能。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p> 此实现对每个人都有好处，但是它不支持在破坏一棵纤维树时取消请求，因此我们需要使用更加混乱的<code>API</code> 。 </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber：取消请求 </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p> 传递给<code>async</code>包装器的函数仅被调用一次， <code>async</code>包装器被传递给它，您需要在其中包装回调。 因此，在这些回调中，您必须返回值或引发异常。 无论回调的结果如何，它也将是光纤的结果。 请注意，最后我们返回一个函数，以防光纤过早损坏。 </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber：取消响应 </h1><br><p> 在服务器端，当客户端中断时取消计算也很有用。 让我们在<code>midleware</code>上实现一个包装器，以创建一个将在其中运行原始<code>midleware</code>的光纤。     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="快速和慢速请求"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber —   ,         .  — ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links"> Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nin-jin.github.io/slides/fibers/</a> — this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mol.js.org/fiber</a> — $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> — $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">t.me/mam_mol</a> — lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="意见反馈"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    «». </p><br><p> <strong></strong> :      —       . 谢谢你 </p><br><p> <strong></strong> :    .    ,   .  ! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            — .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong> </strong> :    .      .    ,   mol_fiber  …   ,          30fps     60fps —   .              —    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413791/">https://habr.com/ru/post/zh-CN413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413779/index.html">Arduino上的计时器和多任务</a></li>
<li><a href="../zh-CN413781/index.html">广告猎犬如何在互联网上步履维艰</a></li>
<li><a href="../zh-CN413783/index.html">最大质量的恒星如何死亡：超新星，超新星或直接坍缩？</a></li>
<li><a href="../zh-CN413787/index.html">角度：ngx-translate。 使用Webpack改善基础架构</a></li>
<li><a href="../zh-CN413789/index.html">在佛罗里达州，由于忘记了密码，他们一年没有在FBI基地检查武器购买者</a></li>
<li><a href="../zh-CN413793/index.html">流行文化中的录音带：为什么过时的录音格式又被认为很流行</a></li>
<li><a href="../zh-CN413795/index.html">娱乐业为何转向IaaS：案例研究</a></li>
<li><a href="../zh-CN413797/index.html">EA在E3上介绍了C＆C的新部分。 看着它实在是痛苦的</a></li>
<li><a href="../zh-CN413799/index.html">Raspberry Pi神经网络蜜蜂计数</a></li>
<li><a href="../zh-CN413801/index.html">“ Roskosmos”提议重造激光大炮...光学望远镜</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>