<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïú üëõ üë©üèΩ‚Äçüç≥ Estamos construyendo el cuarto piso de plantillas C ++ en RESTinio. ¬øPor qu√© y c√≥mo? üé∏ üíä üíê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio es un proyecto relativamente peque√±o, que es un servidor HTTP as√≠ncrono integrado en aplicaciones C ++. Su rasgo caracter√≠stico es el uso gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos construyendo el cuarto piso de plantillas C ++ en RESTinio. ¬øPor qu√© y c√≥mo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456632/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RESTinio</a> es un proyecto relativamente peque√±o, que es un servidor HTTP as√≠ncrono integrado en aplicaciones C ++.  Su rasgo caracter√≠stico es el uso generalizado, podr√≠a decirse, el uso generalizado de plantillas C ++.  Tanto en implementaci√≥n como en API p√∫blica. </p><br><p>  Las plantillas C ++ en RESTinio se usan de manera tan activa que el primer art√≠culo que habl√≥ sobre RESTinio en Habr se llam√≥ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Plantillas C ++ de tres pisos en la implementaci√≥n de un servidor HTTP as√≠ncrono incrustado con rostro humano</a> ". </p><br><p>  Plantillas de tres pisos.  Y esto, en general, no era una forma de hablar. </p><br><p>  Y recientemente, una vez m√°s actualizamos RESTinio, y para agregar una nueva funcionalidad a la versi√≥n 0.5.1, tuvimos que aumentar a√∫n m√°s el "n√∫mero de pisos" de plantillas.  Entonces, en algunos lugares, las plantillas C ++ en RESTinio ya son de cuatro pisos. </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p>  Y si alguien se pregunta por qu√© necesit√°bamos esto y c√≥mo usamos las plantillas, qu√©dese con nosotros, habr√° algunos detalles debajo del corte.  Es poco probable que los gur√∫s inverterados de C ++ encuentren algo nuevo por s√≠ mismos, pero los apodos de C ++ menos avanzados podr√°n ver c√≥mo se usan las plantillas para insertar / eliminar piezas de funcionalidad.  Casi en la naturaleza. </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy">  Escucha del estado de la conexi√≥n </h1><br><p>  La caracter√≠stica principal para la que se cre√≥ la versi√≥n 0.5.1 es la capacidad de informar al usuario que el estado de la conexi√≥n al servidor HTTP ha cambiado.  Por ejemplo, el cliente "se cay√≥" y esto hizo innecesario procesar solicitudes de este cliente que todav√≠a est√°n esperando en la cola. </p><br><p>  Algunas veces nos preguntaron sobre esta caracter√≠stica y ahora nuestras manos llegaron a su implementaci√≥n.  Pero desde  Si no todos preguntaron acerca de esta caracter√≠stica, se pens√≥ que deber√≠a ser opcional: si alg√∫n usuario la necesita, deje que la incluya expl√≠citamente, y el resto no deber√≠a pagar nada por su existencia en RESTinio. </p><br><p>  Y dado que las caracter√≠sticas principales del servidor HTTP en RESTinio se establecen a trav√©s de "rasgos", se decidi√≥ habilitar / deshabilitar la escucha en el estado de las conexiones a trav√©s de las propiedades del servidor. </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy">  ¬øC√≥mo configura un usuario su propio oyente para el estado de conexi√≥n? </h2><br><p>  Para configurar su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escucha para el estado de las conexiones, el</a> usuario debe realizar tres pasos. </p><br><p>  Paso 1: defina su propia clase, que debe tener un m√©todo de cambio de estado no est√°tico de la siguiente forma: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p>  Por ejemplo, podr√≠a ser algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p>  Paso 2: dentro de las propiedades del servidor, debe definir un typedef llamado <code>connection_state_listener_t</code> , que debe hacer referencia al nombre del tipo creado en el paso 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p>  En consecuencia, estas propiedades deben usarse al iniciar el servidor HTTP: </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p>  Paso # 3: el usuario debe crear una instancia de su escucha y pasar este puntero a trav√©s de shared_ptr en los par√°metros del servidor: </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p>  Si el usuario no realiza una llamada al m√©todo <code>connection_state_listener</code> , se lanzar√° una excepci√≥n al iniciar el servidor HTTP: el norte no puede funcionar si el usuario desea utilizar el escucha de estado pero no especifica este escucha. </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t">  ¬øY si no establece connection_state_listener_t? </h3><br><p>  Si el usuario establece el nombre <code>connection_state_listener_t</code> en las propiedades del servidor, debe llamar al m√©todo <code>connection_state_listener</code> para establecer los par√°metros del servidor.  Pero si el usuario no especifica <code>connection_state_listener_t</code> ? </p><br><p>  En este caso, el nombre <code>connection_state_listener_t</code> seguir√° estando presente en las propiedades del servidor, pero este nombre apuntar√° al tipo especial <code>restinio::connection_state::noop_listener_t</code> . </p><br><p>  De hecho, sucede lo siguiente: en RESTinio, al definir rasgos regulares, se establece <code>connection_state_listener_t</code> .  Algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p>  Y cuando el usuario hereda de <code>restinio::default_traits_t</code> , la definici√≥n est√°ndar de <code>connection_state_listener_t</code> tambi√©n se hereda.  Pero si el nuevo nombre <code>connection_state_listener_t</code> define en la clase sucesora: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p>  entonces el nuevo nombre oculta la definici√≥n heredada de <code>connection_state_listener_t</code> .  Y si no hay una nueva definici√≥n, entonces la vieja definici√≥n permanece visible. </p><br><p>  Entonces, si el usuario no define su propio valor para <code>connection_state_listener_t</code> , RESTinio usar√° el valor predeterminado, <code>noop_listener_t</code> , que RESTinio procesa de manera especial.  Por ejemplo: </p><br><ul><li>  RESTinio no almacena shared_ptr en absoluto en este caso para <code>connection_state_listener_t</code> .  Y, en consecuencia, est√° prohibida una llamada al m√©todo <code>connection_state_listener</code> (dicha llamada dar√° lugar a un error en tiempo de compilaci√≥n); </li><li>  RESTinio no realiza ninguna llamada adicional relacionada con el cambio del estado de la conexi√≥n. </li></ul><br><p>  Y solo acerca de c√≥mo se logra todo esto y se discutir√° a continuaci√≥n. </p><br><h2 id="kak-eto-realizovano-v-restinio">  ¬øC√≥mo se implementa esto en RESTinio? </h2><br><p>  Entonces, en el c√≥digo RESTinio, debe verificar qu√© valor tiene la definici√≥n de <code>connection_state_listener_t</code> en las propiedades del servidor y, dependiendo de este valor: </p><br><ul><li>  para almacenar o no almacenar la instancia shared_ptr para un objeto de tipo <code>connecton_state_listener_t</code> ; </li><li>  permitir o prohibir llamadas a m√©todos <code>connection_state_listener</code> para establecer los par√°metros del servidor HTTP; </li><li>  verificar o no verificar la presencia de un puntero actual a un objeto de tipo <code>connection_state_listener_t</code> antes de iniciar la operaci√≥n del servidor HTTP; </li><li>  realizar o no realizar llamadas al m√©todo <code>state_changed</code> cuando <code>state_changed</code> el estado de la conexi√≥n con el cliente. </li></ul><br><p>  Tambi√©n se agrega a las condiciones de contorno que RESTinio todav√≠a est√° desarrollando como una biblioteca para C ++ 14, por lo tanto, no puede usar las capacidades de C ++ 17 en la implementaci√≥n (lo mismo si constexpr). </p><br><p>  Todo esto se implementa a trav√©s de trucos simples: clases de plantillas y sus especializaciones para el tipo <code>restinio::connection_state::noop_listener_t</code> .  Por ejemplo, as√≠ es como se realiza el almacenamiento shared_ptr para un objeto de tipo <code>connection_state_listener_t</code> en los par√°metros del servidor.  Primera parte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p>  Aqu√≠ se define una estructura de plantilla que tiene un contenido √∫til o no.  Solo para el tipo <code>noop_listener_t</code> , no tiene contenido √∫til. </p><br><p>  Y la segunda parte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p>  La clase que contiene los par√°metros para el servidor HTTP se hereda de <code>connection_state_listener_holder_t</code> .  Por lo tanto, los par√°metros del servidor muestran shared_ptr para un objeto de tipo <code>connection_state_listener_t</code> , o no lo hace. </p><br><p>  Debo decir que almacenar o no almacenar shared_ptr en los par√°metros son flores.  Pero las bayas desaparecieron al intentar hacer que los m√©todos destinados a trabajar con el escucha de estado en <code>basic_server_settings_t</code> est√©n disponibles solo si <code>connection_state_listener_t</code> es diferente de <code>noop_listener_t</code> . </p><br><p>  Idealmente, quer√≠a hacer que el compilador "no los vea" en absoluto.  Pero fui torturado para escribir condiciones para <code>std::enable_if</code> para ocultar estos m√©todos.  Por lo tanto, simplemente se limit√≥ a agregar static_asser: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p>  Hubo otro momento en el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lament√© que en C ++ si constexpr no es lo mismo que static en D.</a>  Y en general en C ++ 14 no hay nada similar :( </p><br><p>  Aqu√≠ tambi√©n puede ver la disponibilidad del m√©todo <code>ensure_valid_connection_state_listener</code> .  Se llama a este m√©todo en el constructor <code>http_server_t</code> para verificar que los par√°metros del servidor contienen todos los valores necesarios: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p>  Al mismo tiempo, dentro del <code>ensure_valid_connection_state_listener</code> m√©todo <code>ensure_valid_connection_state_listener</code> heredado de <code>connection_state_listener_holder_t</code> , que, debido a la especializaci√≥n <code>connection_state_listener_holder_t</code> , hace una comprobaci√≥n real o no hace nada. </p><br><p>  Se usaron trucos similares para llamar al estado actual <code>state_changed</code> si el usuario quer√≠a usar el escucha de estado o no llamar a nada de otra manera. </p><br><p>  Primero, necesitamos otra opci√≥n <code>state_listener_holder_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p>  A diferencia de <code>connection_state_listener_holder_t</code> , que se mostr√≥ anteriormente y que se us√≥ para almacenar el escucha de estado de conexi√≥n en los par√°metros de todo el servidor (es decir, en objetos del tipo <code>basic_server_settings_t</code> ), este <code>state_listener_holder_t</code> se usar√° para fines similares, pero no en los par√°metros de todo el servidor, sino de un servidor separado conexi√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p>  Hay dos caracter√≠sticas aqu√≠. </p><br><p>  Primero, inicializando <code>state_listener_holder_t</code> .  Es necesario o no.  Pero solo <code>state_listener_holder_t</code> sabe.  Por lo tanto, el constructor <code>connection_settings_t</code> simplemente "tira" del constructor <code>state_listener_holder_t</code> , como dicen, por si acaso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p>  Y el <code>state_listener_holder_t</code> constructor <code>state_listener_holder_t</code> realiza las acciones necesarias o no hace nada (en el √∫ltimo caso, el compilador m√°s o menos sensible no generar√° ning√∫n c√≥digo para inicializar <code>state_listener_holder_t</code> ). </p><br><p>  En segundo lugar, es el <code>state_listner_holder_t::call_state_listener</code> , que hace que la llamada <code>state_changed</code> al escucha de estado.  O no, si no hay escucha de estado.  Este <code>call_state_listener</code> en lugares donde RESTinio diagnostica un cambio en el estado de la conexi√≥n.  Por ejemplo, cuando se detecta que la conexi√≥n se ha cerrado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p>  Se pasa un <code>call_state_listener</code> a <code>call_state_listener</code> , desde el cual se <code>notice_t</code> un objeto <code>notice_t</code> con informaci√≥n de estado de conexi√≥n.  Si hay un oyente real, entonces se llamar√° a esta lambda, y el valor devuelto se pasar√° a <code>state_changed</code> . </p><br><p>  Sin embargo, si no hay escucha, <code>call_state_listener</code> estar√° vac√≠o y, en consecuencia, no se llamar√° a lambda.  De hecho, el compilador normal simplemente lanza todas las llamadas a un <code>call_state_listener</code> vac√≠o.  Y en este caso, en el c√≥digo generado no habr√° nada relacionado con el acceso al estado de conexi√≥n al oyente. </p><br><h1 id="esche-i-ip-blocker">  Tambi√©n bloqueador de IP </h1><br><p>  En RESTinio-0.5.1, adem√°s de la escucha del estado de la conexi√≥n, se agreg√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueador de IP</a> .  Es decir  el usuario puede especificar un objeto que RESTinio "extraer√°" para cada nueva conexi√≥n entrante.  Si el bloqueador de IP dice que puede trabajar con la conexi√≥n, RESTinio inicia el mantenimiento habitual de la nueva conexi√≥n (lee y analiza la solicitud, llama al manejador de solicitudes, controla los tiempos de espera, etc.).  Pero si el bloqueador de IP proh√≠be trabajar con la conexi√≥n, RESTinio cierra est√∫pidamente esta conexi√≥n y no hace nada m√°s con ella. </p><br><p>  Al igual que la escucha de estado, el bloqueador de IP es una caracter√≠stica opcional.  Para usar el bloqueador de IP, debe habilitarlo expl√≠citamente.  A trav√©s de las propiedades del servidor HTTP.  Al igual que con el oyente del estado de la conexi√≥n.  Y la implementaci√≥n del soporte del bloqueador de IP en RESTinio utiliza las mismas t√©cnicas que ya se han descrito anteriormente.  Por lo tanto, no nos detendremos en c√≥mo se usa el bloqueador de IP dentro de RESTinio.  En su lugar, considere un ejemplo en el que tanto el bloqueador de IP como el oyente de estado son el mismo objeto. </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker">  An√°lisis del ejemplo est√°ndar ip_blocker </h2><br><p>  En la versi√≥n 0.5.1, se incluye otro ejemplo en los ejemplos est√°ndar de RESTinio: <a href="">ip_blocker</a> .  Este ejemplo demuestra c√≥mo puede limitar el n√∫mero de conexiones simult√°neas al servidor desde una sola direcci√≥n IP. </p><br><p>  Esto requerir√° no solo un bloqueador de IP, que permitir√° o prohibir√° la aceptaci√≥n de conexiones.  Pero tambi√©n un oyente para el estado de la conexi√≥n.  Se necesita un oyente para rastrear los momentos de creaci√≥n y cierre de conexiones. </p><br><p>  Al mismo tiempo, tanto el bloqueador de IP como el oyente necesitar√°n el mismo conjunto de datos.  Por lo tanto, la soluci√≥n m√°s simple es hacer que el bloqueador de IP y el oyente sean el mismo objeto. </p><br><p>  No hay problema, podemos hacer esto f√°cilmente: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p>  Aqu√≠ no tenemos herencia de ninguna interfaz o anulaci√≥n de m√©todos virtuales heredados.  El √∫nico requisito para el oyente es la presencia del m√©todo <code>state_changed</code> .  Este requisito se cumple. </p><br><p>  Del mismo modo, con el √∫nico requisito para un bloqueador de IP: ¬øhay <code>inspect</code> m√©todo de <code>inspect</code> con la firma requerida?  Hay!  Entonces todo est√° bien. </p><br><p>  Luego queda determinar las propiedades correctas para el servidor HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p>  Despu√©s de eso, solo queda crear una instancia de <code>blocker_t</code> y pasarla en los par√°metros al servidor HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><h2 id="o-cnyh-shablonah">  Acerca de las plantillas de C ++ </h2><br><p>  En mi opini√≥n, las plantillas de C ++ son lo que se llaman armas demasiado grandes.  Es decir  caracter√≠stica tan poderosa que involuntariamente tiene que pensar c√≥mo y c√≥mo se justifica su uso.  Por lo tanto, la comunidad moderna de C ++ est√° dividida en varios campos de guerra. </p><br><p>  Los representantes de uno de ellos prefieren mantenerse alejados de las plantillas.  Como las plantillas son complejas, generan longitudes ilegibles de hojas de mensajes de error ilegibles, lo que aumenta significativamente el tiempo de compilaci√≥n.  Sin mencionar las leyendas urbanas sobre el c√≥digo hinchado y la reducci√≥n del rendimiento. </p><br><p>  Los representantes de otro campo (como yo) creen que las plantillas son uno de los aspectos m√°s poderosos de C ++.  Incluso es posible que las plantillas sean una de las pocas ventajas competitivas m√°s serias de C ++ en el mundo moderno.  Por lo tanto, en mi opini√≥n, el futuro de C ++ es precisamente las plantillas.  Y algunos de los inconvenientes actuales asociados con el uso generalizado de plantillas (como la compilaci√≥n larga y de uso intensivo de recursos o los mensajes de error no informativos) se eliminar√°n de una forma u otra con el tiempo. </p><br><p>  Por lo tanto, me parece personalmente que el enfoque elegido durante la implementaci√≥n de RESTinio, a saber, el uso generalizado de plantillas y la configuraci√≥n de las caracter√≠sticas de un servidor HTTP a trav√©s de las propiedades, todav√≠a vale la pena.  Gracias a esto, obtenemos una buena personalizaci√≥n para necesidades espec√≠ficas.  Y al mismo tiempo, en sentido literal, no pagamos por lo que no usamos. </p><br><p>  Sin embargo, por otro lado, parece que la programaci√≥n en plantillas C ++ sigue siendo irrazonablemente complicada.  Lo sientes especialmente cuando tienes que programar no constantemente, sino cuando cambias entre diferentes actividades.  Se distraer√° durante un par de semanas de la codificaci√≥n, luego volver√° y comenzar√° a ser abierta y espec√≠ficamente est√∫pido si es necesario, ocultar√° alg√∫n m√©todo usando SFINAE o comprobar√° la existencia de un m√©todo con una cierta firma en el objeto. </p><br><p>  Por lo tanto, es bueno que haya plantillas en C ++.  Ser√≠a a√∫n mejor si se llevaran a tal estado que incluso los principiantes como yo pudieran usar f√°cilmente las plantillas de C ++ sin tener que estudiar cppreference y stackoverflow cada 10-15 minutos. </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio">  Acerca del estado actual de RESTinio y la funcionalidad futura de RESTinio.  Y no solo RESTinio </h2><br><p>  En este momento, RESTinio se est√° desarrollando seg√∫n el principio de "cuando hay tiempo y hay un deseo".  Por ejemplo, en el oto√±o de 2018 y en el invierno de 2019, no tuvimos mucho tiempo para el desarrollo de RESTinio.  Respondieron las preguntas de los usuarios, hicieron cambios menores, pero para algo m√°s nuestros recursos no fueron suficientes. </p><br><p>  Pero a fines de la primavera de 2019, hubo tiempo para RESTinio, y primero hicimos RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">0.5.0</a> , y luego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">0.5.1</a> .  Al mismo tiempo, el suministro de nuestra lista de deseos y la de otros se agot√≥.  Es decir  lo que nosotros mismos quer√≠amos ver en RESTinio y lo que los usuarios nos contaron, ya est√° en RESTinio. </p><br><p>  Obviamente, RESTinio se puede llenar con mucho m√°s.  ¬øPero qu√© exactamente? </p><br><p>  Y aqu√≠ la respuesta es muy simple: solo lo que se nos pide que ingresemos a RESTinio.  Por lo tanto, si desea ver algo que necesita en RESTinio, t√≥mese el tiempo para contarnos al respecto (por ejemplo, a trav√©s de problemas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BitBucket</a> , ya sea a trav√©s del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupo de Google</a> o directamente en los comentarios aqu√≠ en Habr√©) .  No dir√°s nada, no recibir√°s nada;) </p><br><p>  En realidad, la misma situaci√≥n es con nuestros otros proyectos, en particular con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> .  Sus nuevas versiones se lanzar√°n al recibir la lista de deseos inteligible. </p><br><p>  Bueno, y finalmente, me gustar√≠a ofrecer a todos los que a√∫n no han probado RESTinio: pru√©belo <del>  gratis </del>  No duele.  De repente me gusta.  Y si no te gusta, comparte qu√© exactamente.  Esto nos ayudar√° a hacer que RESTinio sea a√∫n m√°s conveniente y funcional. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456632/">https://habr.com/ru/post/456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456616/index.html">3 millones de rublos para aquellos que pueden codificar</a></li>
<li><a href="../456618/index.html">Larabeer Mosc√∫ - 21 de junio</a></li>
<li><a href="../456622/index.html">C√≥mo crear un sistema operativo certificado seg√∫n la protecci√≥n de clase I</a></li>
<li><a href="../456624/index.html">Herramientas √∫tiles de Python</a></li>
<li><a href="../456630/index.html">Presentaci√≥n de Airflow para administrar Spark Jobs en ivi: esperanzas y muletas</a></li>
<li><a href="../456634/index.html">Recetas Nginx: CAS (Servicio de autorizaci√≥n central)</a></li>
<li><a href="../456638/index.html">Comparando el mismo proyecto en Rust, Haskell, C ++, Python, Scala y OCaml</a></li>
<li><a href="../456640/index.html">An√°lisis del concurso de inteligencia competitiva en PHDays 9</a></li>
<li><a href="../456642/index.html">La primera graduaci√≥n del programa de Maestr√≠a Corporativa de JetBrains y la Universidad ITMO</a></li>
<li><a href="../456644/index.html">En Kickstarter aparece una impresora 3D de pol√≠meros fotogr√°ficos 3D de bajo costo.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>