<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤯 👨‍👩‍👧‍👧 ⭕️ Arbeite mit Charakterstatus. Einheitsexperimente 🕳️ 🌌 👩🏻‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung eines Spiels auf Unity stieß ich auf eine interessante Aufgabe: Wie kann man eine erweiterbare Aktionszeit mit negativen oder posi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeite mit Charakterstatus. Einheitsexperimente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426305/">  Bei der Entwicklung eines Spiels auf Unity stieß ich auf eine interessante Aufgabe: Wie kann man eine erweiterbare Aktionszeit mit negativen oder positiven Auswirkungen auf einen Charakter gestalten? <br><br>  Kurz gesagt, ich habe einen Charakter, auf den bestimmte Effekte angewendet werden können, wie z. B. Schwächung, Verstärkung, Geschwindigkeitssteigerung, Geschwindigkeitsabnahme und andere.  Um den Spieler über den Effekt eines Effekts zu informieren, bietet das Spiel eine Statuszeile. <br><br>  Die ersten Versionen dieser Zeile enthielten abgedunkelte Symbole aller Status, und als der Effekt auftrat, leuchtete das gewünschte auf. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/c0/c0/yv/c0c0yvqqszx5rb-qf9hfnqzs91g.png" alt="Bild"><br><br>  Jeder Status hatte Corutin, das den Effekt nach einer bestimmten Zeit aufhob. <br>  Diese Entscheidung enthält ein ziemlich wichtiges Minus.  Wenn aufgrund bestimmter Ereignisse im Spiel derselbe Effekt nach einer kürzeren Zeit als die Dauer des vorherigen ähnlichen Effekts auf den Charakter angewendet wird, kann es zwei Versionen der Ereignisse geben. <br><br><ol><li>  Ganz falsch: Parallel zum ersten wird ein zweites Corutin gestartet.  Wenn der erste abgeschlossen ist, kehrt er zu seinen ursprünglichen Werten zurück, dh der Effekt wird entfernt, bevor die zweite Coroutine die Arbeit beendet hat. <br><br><img src="https://habrastorage.org/webt/hd/qg/li/hdqglidkfrr-s3yqfdhmhse0cpc.png" alt="Bild"><br></li><li>  Auch falsch, aber in einigen Fällen akzeptabel: Brechen Sie die erste Coroutine ab und führen Sie die zweite aus.  In diesem Fall entspricht die Dauer des Effekts der Dauer des ersten Effekts, bis die Coroutine aufgehoben wird, + der Dauer der zweiten Coroutine. <br><br><img src="https://habrastorage.org/webt/bk/tp/o5/bktpo5rj0vumc9ytgufzfdshpsi.png" alt="Bild"><br></li></ol><br>  Beide Methoden sind für meine Aufgabe nicht akzeptabel, da ich die Dauer des Effekts verlängern muss, damit ich die Summe der Dauer jedes Effekts erhalte, unabhängig davon, wie oft der Effekt angewendet wird. <br><br>  Wenn der Charakter auf die Stacheln tritt, ist sein Bein bedingt beschädigt und er kann sich nicht mit der gleichen Geschwindigkeit weiterbewegen.  Angenommen, die Geschwindigkeit nimmt um 5 Sekunden ab.  Wenn der Charakter nach 3 Sekunden auf andere Stacheln tritt, sollte die Geschwindigkeit um weitere 5 Sekunden verringert werden.  Das heißt, 3 Sekunden sind vergangen, 2 + 5 Sekunden von den neuen Spitzen übrig.  Die Dauer des Effekts sollte ab dem Moment des Angriffs auf die zweiten Stacheln weitere 7 Sekunden betragen (insgesamt 10). <br><br>  Und mit Hilfe von Coroutine habe ich keine Lösung für das Problem gefunden, da es unmöglich ist, die verbleibende Zeit bis zur Fertigstellung der Coroutine herauszufinden, um sie der neuen Coroutine hinzuzufügen. <br><br>  Die Lösung, die ich für dieses Problem gefunden habe, ist die Verwendung eines Wörterbuchs.  Der Vorteil gegenüber List besteht darin, dass das Wörterbuch einen Schlüssel und einen Wert hat, was bedeutet, dass ich über einen Schlüssel auf jeden Wert zugreifen kann.  Außerdem können Sie mit dieser Lösung die permanenten Statussymbole in der Zeile entfernen und die erforderlichen nach Bedarf einfügen und sie in der Reihenfolge, in der sie auftreten, an Positionen in der Zeile festlegen. <br><br><pre><code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; statusTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;();</code> </pre> <br>  Das Wörterbuch ist in diesem Fall vorteilhafter als die Verwendung der Warteschlange, da die Warteschlange nach den Prinzipien von First In First Out arbeitet, die Dauer der Effekte jedoch unterschiedlich ist. Dies bedeutet, dass der Status, der entfernt werden muss, möglicherweise nicht der erste in der Warteschlange ist. <br><br>  Dazu habe ich drei Methoden hinzugefügt. <br><br>  <b>Addstatus</b> <br><br>  Fügen Sie dem Wörterbuch den gewünschten Status hinzu. Wenn ein solcher Status bereits im Wörterbuch vorhanden ist, fügen Sie die Dauer hinzu.  Wenn es keinen Status gibt, berechnen wir die Endzeit und fügen sie dem Wörterbuch hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (statusTime.ContainsKey(status)) { statusTime[status] += duration; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> endTime = Time.timeSinceLevelLoad + duration; statusTime.Add(status, endTime); } }</code> </pre><br>  <b>RemoveStatus</b> <br><br>  Wir löschen den Status aus dem Wörterbuch und stellen die ursprünglichen Werte wieder her. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> status</span></span></span><span class="hljs-function">)</span></span> { statusTime.Remove(status); RestoreStats(status); }</code> </pre><br>  <b>Checkstatus</b> <br><br>  Wenn das Wörterbuch Status enthält, überprüfen wir, ob deren Zeit abgelaufen ist. <br><br>  Wenn abgelaufen, löschen Sie den Status aus dem Wörterbuch.  Da das Ändern des Wörterbuchs in der Schleife es unmöglich macht, die Werte des Wörterbuchs zu synchronisieren, werfen wir die Schlüssel des Wörterbuchs hier in eine reguläre Liste. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckStatuses</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (statusTime.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currTime = Time.timeSinceLevelLoad; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; statuses = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(statusTime.Keys);  <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> statuses) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currTime &gt; statusTime[stat]) { RemoveStatus(stat); } } } }</code> </pre><br>  Von den Pluspunkten ist dies offensichtlich eine erweiterbare Wirkungsdauer.  Das heißt, das Problem ist gelöst. <br>  Hier ist jedoch ein ziemlich signifikantes Minus vorhanden.  Die Überprüfung auf Status erfolgt unter Aktualisieren jedes Frames.  In meinem Spiel gibt es maximal 4 Spieler, was bedeutet, dass diese Methode jeden Frame 4 Mal parallel ausgeführt wird.  Bei 4 Zeichen ist dies meiner Meinung nach nicht kritisch, aber ich bin mir sicher, dass dies bei mehr Zeichen zu Leistungsproblemen führen kann.  Es ist auch erwähnenswert, dass die Methode geschützt wird, indem überprüft wird, ob Elemente im Wörterbuch vorhanden sind. Bei einem leeren Wörterbuch sollte die Last reduziert werden. <br><br>  Mit Blick auf die Zukunft (die für dieses Spiel noch völlig neblig ist) bin ich auch im Online-Modus von dieser Entscheidung überzeugt, da eine Überprüfung des Spielerstatus nur für den aktuellen lokalen Spieler und nicht für alle instanziierten Spieler erfolgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426305/">https://habr.com/ru/post/de426305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426295/index.html">Da sehe ich den perfekten Browser</a></li>
<li><a href="../de426297/index.html">Warum ich modernes Web nicht mag</a></li>
<li><a href="../de426299/index.html">[Designpsychologie] - Die Psychologie des Designs</a></li>
<li><a href="../de426301/index.html">Ist es so in Europa, wie sie darüber schreiben?</a></li>
<li><a href="../de426303/index.html">Eine kurze Tour durch die Highlights des Zend Frameworks</a></li>
<li><a href="../de426311/index.html">BLACK HAT USA Konferenz. Botnet von einer Million Browsern. Teil 2</a></li>
<li><a href="../de426313/index.html">Neues Microsoft Learn</a></li>
<li><a href="../de426315/index.html">Wie kann man mit dem unsichtbaren Internet Python-Freunde finden? Die Grundlagen der Entwicklung von I2P-Anwendungen in Python und Asyncio</a></li>
<li><a href="../de426317/index.html">1155 vs 2011. Einige alte Leute ziehen in die Schlacht</a></li>
<li><a href="../de426319/index.html">Testserver für das Entwicklungsteam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>