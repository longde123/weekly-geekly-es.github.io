<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ω üöò ü•ù Wann sollten keine STL-Algorithmen verwendet werden? Beispiel geben ü§í ü§ûüèΩ üåõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Genossen, guten Abend! Sie haben die erste Ausgabe des Buches " C ++ 17 STL. Standard Template Library " so k√ºhl von uns auseinander genommen und anal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wann sollten keine STL-Algorithmen verwendet werden? Beispiel geben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418469/"> Genossen, guten Abend!  Sie haben die erste Ausgabe des Buches " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ 17 STL. Standard Template Library</a> " so k√ºhl von uns auseinander genommen und analysieren die zweite weiter, dass wir uns schlie√ülich entschlossen haben, hier eine alternative Sichtweise vorzustellen.  Der Autor des heutigen Artikels ist Ivan ƒåukiƒá, dem auch das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Functional Programming in C ++</a> geh√∂rt, das f√ºr die Ver√∂ffentlichung im Manning Publishing House vorbereitet wird.  Wir bieten an, seine skeptischen Gedanken, seinen Code und seine Berechnungen zu bewerten <br><a name="habracut"></a><br>  <b>Pr√§ambel</b> <br><br>  Ich wollte diesen Beitrag "√úber die B√∂sartigkeit von STL-Algorithmen" nennen, um meine eigenen F√§higkeiten beim Provozieren von Klicks zu testen.  Aber dann entschied er, dass es besser sei, einen Artikel f√ºr die Zielgruppe zu schreiben und keinen solchen Beitrag zu schreiben, in dem diejenigen zusammenkommen w√ºrden, die √ºber meine ungeheuren Thesen streiten m√∂chten. <br><br>  Daher kann ich davon ausgehen, dass Sie sich f√ºr Algorithmen und deren Komplexit√§t interessieren und den perfektesten Code schreiben m√∂chten. <br><br>  <b>Algorithmen</b> <br><br>  In der modernen professionellen C ++ - Community wird h√§ufig empfohlen, Ihr Programm sicherer, schneller, ausdrucksvoller usw. zu machen.  - Verwenden Sie die Algorithmen aus der Standardbibliothek.  Ich versuche auch, diesen Rat in meinen B√ºchern, Reden, Seminaren bekannt zu machen ... wo immer es ein geeignetes Publikum gibt. <br><br>  Nat√ºrlich ist es absolut richtig, dass wir, wenn wir eine <code>for</code> Schleife schreiben wollen, um das vor uns liegende Problem zu l√∂sen, zuerst dar√ºber nachdenken m√ºssen, ob die vorhandenen Algorithmen der Standardbibliothek (oder des Boosts) daf√ºr geeignet sind, und nicht blind handeln. <br><br>  Wir m√ºssen noch wissen, wie diese Algorithmen implementiert sind, welche Anforderungen und Garantien mit ihnen verbunden sind, wie r√§umlich und zeitlich sie komplex sind. <br><br>  Wenn wir vor einer Aufgabe stehen, die genau den Anforderungen des STL-Algorithmus entspricht und direkt angewendet werden kann, ist dieser Algorithmus normalerweise die effektivste L√∂sung. <br><br>  Ein Problem kann auftreten, wenn wir die Daten auf irgendeine Weise vorbereiten m√ºssen, bevor wir den Algorithmus anwenden. <br><br>  <b>Schnittmenge von Mengen</b> <br><br>  Angenommen, wir schreiben ein Tool f√ºr C ++ - Entwickler, das Tipps zum Ersetzen der Standarderfassungsoptionen (√ºber <code>[=]</code> und <code>[&amp;]</code> ) in Lambda-Ausdr√ºcken gibt und explizit eine Liste der erfassten Variablen anzeigt. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition(begin(elements), end(elements), [=] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> element) { ^~~ -  -  ,   [threshold] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element &gt; threshold; });</code> </pre> <br>  Beim Parsen einer Datei ben√∂tigen wir eine Sammlung, in der Variablen aus dem aktuellen und dem benachbarten Bereich gespeichert werden.  Sobald wir auf einen Lambda-Ausdruck mit einer Standarderfassung sto√üen, m√ºssen wir sehen, welche Variablen dort verwendet werden. <br><br>  Als Ergebnis haben wir zwei Mengen: In einer gibt es Variablen aus den umgebenden Sichtbarkeitsbereichen und in der anderen Variablen, die im Hauptteil des Lambda-Ausdrucks verwendet werden. <br><br>  Die Liste der Erfassungsoptionen, die wir zum Ersetzen anbieten, sollte der Schnittpunkt dieser beiden Mengen sein (Lambda-Ausdr√ºcke k√∂nnen globale Variablen verwenden, die nicht erfasst werden m√ºssen, und nicht alle Variablen aus dem umgebenden Bereich werden im Lambda-Ausdruck verwendet). <br><br>  Und wenn wir eine Kreuzung ben√∂tigen, k√∂nnen wir den <code>std::set_intersection</code> . <br><br>  Dieser Algorithmus ist in seiner Einfachheit ziemlich sch√∂n.  Es akzeptiert zwei sortierte Sammlungen und f√ºhrt sie gleichzeitig von Anfang bis Ende aus: <br><br><ul><li>  Wenn das aktuelle Element in der ersten Sammlung dem aktuellen Element in der zweiten Sammlung entspricht, wird es zum Ergebnis hinzugef√ºgt, das der Algorithmus einfach zum n√§chsten Element in beiden Sammlungen verschiebt. </li><li>  Wenn der tats√§chliche Artikel in der ersten Sammlung kleiner als der tats√§chliche Artikel in der zweiten Sammlung ist, √ºberspringt der Algorithmus einfach den aktuellen Artikel in der ersten Sammlung. </li><li>  Wenn der tats√§chliche Artikel in der ersten Sammlung gr√∂√üer ist als der tats√§chliche Artikel in der zweiten Sammlung, √ºberspringt der Algorithmus einfach den aktuellen Artikel in der zweiten Sammlung. </li></ul><br>  Mindestens ein Element (aus der ersten oder zweiten Eingabesammlung) wird in jeder Iteration √ºbersprungen - daher ist die Komplexit√§t des Algorithmus linear - <code>O(m + n)</code> , wobei <code>m</code> die Anzahl der Elemente in der ersten Sammlung und <code>n</code> die Anzahl der Elemente in der zweiten Sammlung ist . <br><br>  Einfach und effektiv.  Solange die Eingabesammlungen sortiert sind. <br><br>  <b>Sortieren</b> <br><br>  Hier ist das Problem: Was ist, wenn die Sammlungen nicht vorsortiert sind? <br><br>  Im vorherigen Beispiel ist es ratsam, Variablen aus den umgebenden Sichtbarkeitsbereichen in einer stapelartigen Struktur zu speichern, in der der Parser einfach neue Elemente hinzuf√ºgen und einen neuen Bereich eingeben und die Variablen des aktuellen Bereichs l√∂schen kann, sobald er den Bereich verl√§sst. <br><br>  Daher werden Variablen nicht nach Namen sortiert, und wir k√∂nnen <code>std::set_intersection</code> nicht direkt f√ºr Operationen an ihnen verwenden.  Wenn Sie die Variablen im Hauptteil eines Lambda-Ausdrucks verfolgen, k√∂nnen wir sie h√∂chstwahrscheinlich nicht in sortierter Form speichern. <br><br>  Da <code>std::set_intersection</code> nur mit sortierten Sammlungen funktioniert, tritt in vielen Projekten dieses Prinzip auf: Zuerst sortieren wir die Sammlungen und rufen dann den <code>std::set_intersection</code> . <br><br>  Wenn wir vergessen, dass das Sortieren eines Variablenstapels in unserem Beispiel die gesamte Verwendung des von uns definierten Stapels vollst√§ndig abwertet, sieht der Schnittalgorithmus f√ºr unsortierte Sammlungen ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::set_intersection(first1, last1, first2, last2, dest); }</code> </pre> <br>  Was ist die Komplexit√§t dieses gesamten Algorithmus?  Das Sortieren dauert quasilinear, daher betr√§gt die Gesamtkomplexit√§t dieses Ansatzes <code>O(n log n + m log m + n + m)</code> . <br><br>  <b>Kleiner sortieren</b> <br><br>  Kann man auf Sortieren verzichten? <br><br>  Wenn beide Sammlungen nicht sortiert sind, m√ºssen wir die zweite Sammlung f√ºr jedes Element von der ersten umgehen, um zu entscheiden, ob es in die Ergebnismenge aufgenommen werden soll.  Obwohl dieser Ansatz in realen Projekten weit verbreitet ist, ist er noch schlimmer als der vorherige - seine Komplexit√§t ist <code>O(n * m)</code> . <br><br>  Anstatt alles in einer Reihe zu sortieren oder nichts zu sortieren, erinnere dich an Zen und w√§hle den dritten Pfad - wir sortieren nur eine Sammlung. <br><br>  Wenn nur eine Sammlung sortiert ist, k√∂nnen wir alle Werte der unsortierten nacheinander durchlaufen und f√ºr jeden Wert pr√ºfen, ob sie in der sortierten Sammlung enthalten sind.  Wenden Sie dazu eine bin√§re Suche an. <br><br>  In diesem Fall betr√§gt die zeitliche Komplexit√§t <code>O(n log n)</code> zum Sortieren der ersten Sammlung und <code>O (m log n)</code> zum Sortieren und √úberpr√ºfen.  Die Gesamtkomplexit√§t betr√§gt <code>O((n + m) log n)</code> . <br><br>  Wenn wir uns entscheiden w√ºrden, die zweite Sammlung und nicht die erste zu sortieren, w√§re die Komplexit√§t <code>O((n + m) log m)</code> . <br><br>  Um maximale Effizienz zu erzielen, sortieren wir immer die Sammlung, in der weniger Elemente vorhanden sind, so dass die endg√ºltige Komplexit√§t unseres Algorithmus besteht <br>  <code>((m + n) log (min(m, n))</code> . <br><br>  Die Implementierung sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_2(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_search(first1, last1, FWD(value)); }); }</code> </pre> <br>  In unserem Beispiel mit Erfassungslisten in Lambda-Ausdr√ºcken wird die Sammlung der im Lambda-Ausdruck vorhandenen Variablen normalerweise sortiert, da sie wahrscheinlich kleiner ist als die Sammlung aller Variablen aus allen umgebenden Bereichen. <br><br>  <b>Hashing</b> <br><br>  Die letzte Option besteht darin, <code>std::unordered_set</code> (eine Hash-basierte ungeordnete Set-Implementierung) aus einer kleineren Sammlung zu erstellen, anstatt sie zu sortieren.  In diesem Fall betr√§gt die durchschnittliche Komplexit√§t der Suchvorg√§nge <code>O(1)</code> , es <code>std::unordered_set</code> Zeit, bis <code>std::unordered_set</code> .  Die Geb√§udekomplexit√§t kann von <code>O(n)</code> bis <code>O(n*n)</code> reichen, und dies ist ein potenzielles Problem. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_3(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; test_set(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test_set.count(FWD(value)); }); }</code> </pre> <br>  Der Hashing-Ansatz gewinnt vollst√§ndig, wenn Sie die Schnittpunkte mehrerer S√§tze mit einem einzigen vordefinierten kleinen Satz berechnen m√ºssen.  Das hei√üt, wir haben die Menge <code>A</code> , die Mengen <code>B‚ÇÅ</code> , <code>B‚ÇÇ‚Ä¶</code> und wir wollen <code>A ‚à© B‚ÇÅ, A ‚à© B‚ÇÇ‚Ä¶</code> berechnen <code>A ‚à© B‚ÇÅ, A ‚à© B‚ÇÇ‚Ä¶</code> <br><br>  In diesem Fall k√∂nnen Sie die Komplexit√§t des Konstrukts <code>std::unordered_set</code> ignorieren, und die Komplexit√§t der Berechnung jedes Schnittpunkts ist linear - <code>O(m)</code> , wobei <code>m</code> die Anzahl der Elemente in der zweiten Sammlung ist. <br><br>  <b>Kontrolle</b> <br><br>  Nat√ºrlich ist es immer n√ºtzlich, die Komplexit√§t des Algorithmus zu √ºberpr√ºfen, aber in solchen F√§llen ist es auch ratsam, verschiedene Ans√§tze mithilfe von Pr√ºfpunkten zu √ºberpr√ºfen.  Besonders bei der Auswahl aus den letzten beiden Optionen, bei denen wir bin√§re Suchen und Hash-basierte Mengen vergleichen. <br>  Mein einfachster Test hat gezeigt, dass die erste Option, bei der Sie beide Sammlungen sortieren m√ºssen, immer die langsamste ist. <br><br>  Das Sortieren einer kleineren Sammlung √ºbertrifft <code>std::unordered_set</code> wenig, jedoch nicht besonders. <br><br>  Sowohl der zweite als auch der dritte Ansatz sind etwas schneller als der erste, wenn beide Sammlungen die gleiche Anzahl von Elementen aufweisen, und viel schneller (bis zu sechsmal), wenn die Anzahl der Elemente in einer Sammlung etwa 1000-mal h√∂her ist als in der zweiten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418469/">https://habr.com/ru/post/de418469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418457/index.html">Danke Beitrag: Tag des Systemadministrators</a></li>
<li><a href="../de418459/index.html">Entwicklung eines LVDS-Skalierers mit zwei DisplayPort-Schnittstellen</a></li>
<li><a href="../de418463/index.html">Arbeiten mit Daten in Angular</a></li>
<li><a href="../de418465/index.html">Entdeckung einer neuen Spectre-Angriffsoption mit der M√∂glichkeit, Daten √ºber das Netzwerk remote zu empfangen</a></li>
<li><a href="../de418467/index.html">Klassifizierung von Kampfkunstentwicklern</a></li>
<li><a href="../de418475/index.html">Windows 10 verwendet die Technologie des maschinellen Lernens, um festzustellen, ob ein Upgrade m√∂glich ist</a></li>
<li><a href="../de418477/index.html">DEFCON-Konferenz 23. Wie ich mein zweites Auge verloren habe oder weitere Untersuchungen zur Datenvernichtung. Teil 1</a></li>
<li><a href="../de418479/index.html">DEFCON-Konferenz 23. Wie ich mein zweites Auge verloren habe oder weitere Untersuchungen zur Datenvernichtung. Teil 2</a></li>
<li><a href="../de418481/index.html">Leben in Israel - Einige IT-bezogene Momente</a></li>
<li><a href="../de418483/index.html">So komprimieren Sie den Bootloader f√ºr STM8 auf eine Gr√∂√üe von 8 Byte im FLASH-Speicher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>