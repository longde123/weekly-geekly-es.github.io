<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽 🚘 🥝 Wann sollten keine STL-Algorithmen verwendet werden? Beispiel geben 🤒 🤞🏽 🌛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Genossen, guten Abend! Sie haben die erste Ausgabe des Buches " C ++ 17 STL. Standard Template Library " so kühl von uns auseinander genommen und anal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wann sollten keine STL-Algorithmen verwendet werden? Beispiel geben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418469/"> Genossen, guten Abend!  Sie haben die erste Ausgabe des Buches " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ 17 STL. Standard Template Library</a> " so kühl von uns auseinander genommen und analysieren die zweite weiter, dass wir uns schließlich entschlossen haben, hier eine alternative Sichtweise vorzustellen.  Der Autor des heutigen Artikels ist Ivan Čukić, dem auch das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Functional Programming in C ++</a> gehört, das für die Veröffentlichung im Manning Publishing House vorbereitet wird.  Wir bieten an, seine skeptischen Gedanken, seinen Code und seine Berechnungen zu bewerten <br><a name="habracut"></a><br>  <b>Präambel</b> <br><br>  Ich wollte diesen Beitrag "Über die Bösartigkeit von STL-Algorithmen" nennen, um meine eigenen Fähigkeiten beim Provozieren von Klicks zu testen.  Aber dann entschied er, dass es besser sei, einen Artikel für die Zielgruppe zu schreiben und keinen solchen Beitrag zu schreiben, in dem diejenigen zusammenkommen würden, die über meine ungeheuren Thesen streiten möchten. <br><br>  Daher kann ich davon ausgehen, dass Sie sich für Algorithmen und deren Komplexität interessieren und den perfektesten Code schreiben möchten. <br><br>  <b>Algorithmen</b> <br><br>  In der modernen professionellen C ++ - Community wird häufig empfohlen, Ihr Programm sicherer, schneller, ausdrucksvoller usw. zu machen.  - Verwenden Sie die Algorithmen aus der Standardbibliothek.  Ich versuche auch, diesen Rat in meinen Büchern, Reden, Seminaren bekannt zu machen ... wo immer es ein geeignetes Publikum gibt. <br><br>  Natürlich ist es absolut richtig, dass wir, wenn wir eine <code>for</code> Schleife schreiben wollen, um das vor uns liegende Problem zu lösen, zuerst darüber nachdenken müssen, ob die vorhandenen Algorithmen der Standardbibliothek (oder des Boosts) dafür geeignet sind, und nicht blind handeln. <br><br>  Wir müssen noch wissen, wie diese Algorithmen implementiert sind, welche Anforderungen und Garantien mit ihnen verbunden sind, wie räumlich und zeitlich sie komplex sind. <br><br>  Wenn wir vor einer Aufgabe stehen, die genau den Anforderungen des STL-Algorithmus entspricht und direkt angewendet werden kann, ist dieser Algorithmus normalerweise die effektivste Lösung. <br><br>  Ein Problem kann auftreten, wenn wir die Daten auf irgendeine Weise vorbereiten müssen, bevor wir den Algorithmus anwenden. <br><br>  <b>Schnittmenge von Mengen</b> <br><br>  Angenommen, wir schreiben ein Tool für C ++ - Entwickler, das Tipps zum Ersetzen der Standarderfassungsoptionen (über <code>[=]</code> und <code>[&amp;]</code> ) in Lambda-Ausdrücken gibt und explizit eine Liste der erfassten Variablen anzeigt. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition(begin(elements), end(elements), [=] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> element) { ^~~ -  -  ,   [threshold] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element &gt; threshold; });</code> </pre> <br>  Beim Parsen einer Datei benötigen wir eine Sammlung, in der Variablen aus dem aktuellen und dem benachbarten Bereich gespeichert werden.  Sobald wir auf einen Lambda-Ausdruck mit einer Standarderfassung stoßen, müssen wir sehen, welche Variablen dort verwendet werden. <br><br>  Als Ergebnis haben wir zwei Mengen: In einer gibt es Variablen aus den umgebenden Sichtbarkeitsbereichen und in der anderen Variablen, die im Hauptteil des Lambda-Ausdrucks verwendet werden. <br><br>  Die Liste der Erfassungsoptionen, die wir zum Ersetzen anbieten, sollte der Schnittpunkt dieser beiden Mengen sein (Lambda-Ausdrücke können globale Variablen verwenden, die nicht erfasst werden müssen, und nicht alle Variablen aus dem umgebenden Bereich werden im Lambda-Ausdruck verwendet). <br><br>  Und wenn wir eine Kreuzung benötigen, können wir den <code>std::set_intersection</code> . <br><br>  Dieser Algorithmus ist in seiner Einfachheit ziemlich schön.  Es akzeptiert zwei sortierte Sammlungen und führt sie gleichzeitig von Anfang bis Ende aus: <br><br><ul><li>  Wenn das aktuelle Element in der ersten Sammlung dem aktuellen Element in der zweiten Sammlung entspricht, wird es zum Ergebnis hinzugefügt, das der Algorithmus einfach zum nächsten Element in beiden Sammlungen verschiebt. </li><li>  Wenn der tatsächliche Artikel in der ersten Sammlung kleiner als der tatsächliche Artikel in der zweiten Sammlung ist, überspringt der Algorithmus einfach den aktuellen Artikel in der ersten Sammlung. </li><li>  Wenn der tatsächliche Artikel in der ersten Sammlung größer ist als der tatsächliche Artikel in der zweiten Sammlung, überspringt der Algorithmus einfach den aktuellen Artikel in der zweiten Sammlung. </li></ul><br>  Mindestens ein Element (aus der ersten oder zweiten Eingabesammlung) wird in jeder Iteration übersprungen - daher ist die Komplexität des Algorithmus linear - <code>O(m + n)</code> , wobei <code>m</code> die Anzahl der Elemente in der ersten Sammlung und <code>n</code> die Anzahl der Elemente in der zweiten Sammlung ist . <br><br>  Einfach und effektiv.  Solange die Eingabesammlungen sortiert sind. <br><br>  <b>Sortieren</b> <br><br>  Hier ist das Problem: Was ist, wenn die Sammlungen nicht vorsortiert sind? <br><br>  Im vorherigen Beispiel ist es ratsam, Variablen aus den umgebenden Sichtbarkeitsbereichen in einer stapelartigen Struktur zu speichern, in der der Parser einfach neue Elemente hinzufügen und einen neuen Bereich eingeben und die Variablen des aktuellen Bereichs löschen kann, sobald er den Bereich verlässt. <br><br>  Daher werden Variablen nicht nach Namen sortiert, und wir können <code>std::set_intersection</code> nicht direkt für Operationen an ihnen verwenden.  Wenn Sie die Variablen im Hauptteil eines Lambda-Ausdrucks verfolgen, können wir sie höchstwahrscheinlich nicht in sortierter Form speichern. <br><br>  Da <code>std::set_intersection</code> nur mit sortierten Sammlungen funktioniert, tritt in vielen Projekten dieses Prinzip auf: Zuerst sortieren wir die Sammlungen und rufen dann den <code>std::set_intersection</code> . <br><br>  Wenn wir vergessen, dass das Sortieren eines Variablenstapels in unserem Beispiel die gesamte Verwendung des von uns definierten Stapels vollständig abwertet, sieht der Schnittalgorithmus für unsortierte Sammlungen ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::set_intersection(first1, last1, first2, last2, dest); }</code> </pre> <br>  Was ist die Komplexität dieses gesamten Algorithmus?  Das Sortieren dauert quasilinear, daher beträgt die Gesamtkomplexität dieses Ansatzes <code>O(n log n + m log m + n + m)</code> . <br><br>  <b>Kleiner sortieren</b> <br><br>  Kann man auf Sortieren verzichten? <br><br>  Wenn beide Sammlungen nicht sortiert sind, müssen wir die zweite Sammlung für jedes Element von der ersten umgehen, um zu entscheiden, ob es in die Ergebnismenge aufgenommen werden soll.  Obwohl dieser Ansatz in realen Projekten weit verbreitet ist, ist er noch schlimmer als der vorherige - seine Komplexität ist <code>O(n * m)</code> . <br><br>  Anstatt alles in einer Reihe zu sortieren oder nichts zu sortieren, erinnere dich an Zen und wähle den dritten Pfad - wir sortieren nur eine Sammlung. <br><br>  Wenn nur eine Sammlung sortiert ist, können wir alle Werte der unsortierten nacheinander durchlaufen und für jeden Wert prüfen, ob sie in der sortierten Sammlung enthalten sind.  Wenden Sie dazu eine binäre Suche an. <br><br>  In diesem Fall beträgt die zeitliche Komplexität <code>O(n log n)</code> zum Sortieren der ersten Sammlung und <code>O (m log n)</code> zum Sortieren und Überprüfen.  Die Gesamtkomplexität beträgt <code>O((n + m) log n)</code> . <br><br>  Wenn wir uns entscheiden würden, die zweite Sammlung und nicht die erste zu sortieren, wäre die Komplexität <code>O((n + m) log m)</code> . <br><br>  Um maximale Effizienz zu erzielen, sortieren wir immer die Sammlung, in der weniger Elemente vorhanden sind, so dass die endgültige Komplexität unseres Algorithmus besteht <br>  <code>((m + n) log (min(m, n))</code> . <br><br>  Die Implementierung sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_2(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_search(first1, last1, FWD(value)); }); }</code> </pre> <br>  In unserem Beispiel mit Erfassungslisten in Lambda-Ausdrücken wird die Sammlung der im Lambda-Ausdruck vorhandenen Variablen normalerweise sortiert, da sie wahrscheinlich kleiner ist als die Sammlung aller Variablen aus allen umgebenden Bereichen. <br><br>  <b>Hashing</b> <br><br>  Die letzte Option besteht darin, <code>std::unordered_set</code> (eine Hash-basierte ungeordnete Set-Implementierung) aus einer kleineren Sammlung zu erstellen, anstatt sie zu sortieren.  In diesem Fall beträgt die durchschnittliche Komplexität der Suchvorgänge <code>O(1)</code> , es <code>std::unordered_set</code> Zeit, bis <code>std::unordered_set</code> .  Die Gebäudekomplexität kann von <code>O(n)</code> bis <code>O(n*n)</code> reichen, und dies ist ein potenzielles Problem. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_3(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; test_set(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test_set.count(FWD(value)); }); }</code> </pre> <br>  Der Hashing-Ansatz gewinnt vollständig, wenn Sie die Schnittpunkte mehrerer Sätze mit einem einzigen vordefinierten kleinen Satz berechnen müssen.  Das heißt, wir haben die Menge <code>A</code> , die Mengen <code>B₁</code> , <code>B₂…</code> und wir wollen <code>A ∩ B₁, A ∩ B₂…</code> berechnen <code>A ∩ B₁, A ∩ B₂…</code> <br><br>  In diesem Fall können Sie die Komplexität des Konstrukts <code>std::unordered_set</code> ignorieren, und die Komplexität der Berechnung jedes Schnittpunkts ist linear - <code>O(m)</code> , wobei <code>m</code> die Anzahl der Elemente in der zweiten Sammlung ist. <br><br>  <b>Kontrolle</b> <br><br>  Natürlich ist es immer nützlich, die Komplexität des Algorithmus zu überprüfen, aber in solchen Fällen ist es auch ratsam, verschiedene Ansätze mithilfe von Prüfpunkten zu überprüfen.  Besonders bei der Auswahl aus den letzten beiden Optionen, bei denen wir binäre Suchen und Hash-basierte Mengen vergleichen. <br>  Mein einfachster Test hat gezeigt, dass die erste Option, bei der Sie beide Sammlungen sortieren müssen, immer die langsamste ist. <br><br>  Das Sortieren einer kleineren Sammlung übertrifft <code>std::unordered_set</code> wenig, jedoch nicht besonders. <br><br>  Sowohl der zweite als auch der dritte Ansatz sind etwas schneller als der erste, wenn beide Sammlungen die gleiche Anzahl von Elementen aufweisen, und viel schneller (bis zu sechsmal), wenn die Anzahl der Elemente in einer Sammlung etwa 1000-mal höher ist als in der zweiten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418469/">https://habr.com/ru/post/de418469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418457/index.html">Danke Beitrag: Tag des Systemadministrators</a></li>
<li><a href="../de418459/index.html">Entwicklung eines LVDS-Skalierers mit zwei DisplayPort-Schnittstellen</a></li>
<li><a href="../de418463/index.html">Arbeiten mit Daten in Angular</a></li>
<li><a href="../de418465/index.html">Entdeckung einer neuen Spectre-Angriffsoption mit der Möglichkeit, Daten über das Netzwerk remote zu empfangen</a></li>
<li><a href="../de418467/index.html">Klassifizierung von Kampfkunstentwicklern</a></li>
<li><a href="../de418475/index.html">Windows 10 verwendet die Technologie des maschinellen Lernens, um festzustellen, ob ein Upgrade möglich ist</a></li>
<li><a href="../de418477/index.html">DEFCON-Konferenz 23. Wie ich mein zweites Auge verloren habe oder weitere Untersuchungen zur Datenvernichtung. Teil 1</a></li>
<li><a href="../de418479/index.html">DEFCON-Konferenz 23. Wie ich mein zweites Auge verloren habe oder weitere Untersuchungen zur Datenvernichtung. Teil 2</a></li>
<li><a href="../de418481/index.html">Leben in Israel - Einige IT-bezogene Momente</a></li>
<li><a href="../de418483/index.html">So komprimieren Sie den Bootloader für STM8 auf eine Größe von 8 Byte im FLASH-Speicher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>