<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üéÆ üéöÔ∏è Warum Skylake-Prozessoren manchmal zweimal langsamer laufen üë®‚Äçüëß‚Äçüëß ü¶ë üóúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wurde informiert, dass auf neuen Computern einige Regressionstests langsamer wurden. Eine h√§ufige Sache, es passiert. Falsche Konfiguration irgend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Skylake-Prozessoren manchmal zweimal langsamer laufen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415053/">  Ich wurde informiert, dass auf neuen Computern einige Regressionstests langsamer wurden.  Eine h√§ufige Sache, es passiert.  Falsche Konfiguration irgendwo in Windows oder nicht die optimalsten Werte im BIOS.  Diesmal konnten wir jedoch nicht die gleiche "niedergeschlagene" Einstellung finden.  Da die √Ñnderung signifikant ist: 9 vs. 19 Sekunden (auf der Karte ist Blau das alte Eisen und Orange das neue), musste ich tiefer graben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/6db/d57/4a96dbd573606b0a0aabc6a0874dd2fa.png"><br><a name="habracut"></a><br><h1>  Gleiches Betriebssystem, gleiche Hardware, anderer Prozessor: 2 mal langsamer </h1><br>  Der Leistungsabfall von 9,1 auf 19,6 Sekunden kann definitiv als signifikant bezeichnet werden.  Wir haben zus√§tzliche √úberpr√ºfungen mit einer √Ñnderung der Versionen der getesteten Programme, Windows- und BIOS-Einstellungen durchgef√ºhrt.  Aber nein, das Ergebnis hat sich nicht ge√§ndert.  Der einzige Unterschied trat nur bei verschiedenen Prozessoren auf.  Unten sehen Sie das Ergebnis der neuesten CPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/fc8/12e/6a2fc812e9f12ae4581b9ed3fd46c4b7.png"><br><br>  Und hier ist die, die zum Vergleich verwendet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/f8b/d4f/e81f8bd4f20ffe609673ef3db6dd414d.png"><br><br>  Xeon Gold l√§uft auf einer anderen Architektur namens Skylake, die seit Mitte 2017 neuen Intel-Prozessoren gemeinsam ist.  Wenn Sie die neueste Hardware kaufen, erhalten Sie einen Prozessor mit der Skylake-Architektur.  Das sind gute Autos, aber wie Tests gezeigt haben, sind Neuheit und Geschwindigkeit nicht dasselbe. <br><br>  Wenn nichts anderes hilft, m√ºssen Sie den Profiler f√ºr eingehende Recherchen verwenden.  Lassen Sie uns alte und neue Ger√§te testen und so etwas bekommen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b3/6a3/98e/3b36a398e5ee9ce0950c1d940f3de9c7.png"><br><br>  Die Registerkarte in Windows Performance Analyzer (WPA) zeigt in der Tabelle den Unterschied zwischen Trace 2 (11 s) und Trace 1 (19 s).  Ein negativer Unterschied in der Tabelle entspricht einem Anstieg des CPU-Verbrauchs in einem langsameren Test.  Wenn Sie sich die wichtigsten Unterschiede beim CPU-Verbrauch <i>ansehen,</i> sehen Sie <i>AwareLock :: Contention</i> , <i>JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel</i> und <i>ThreadNative.SpinWait</i> .  Alles deutet auf ein "Drehen" in der CPU hin [Drehen - ein zyklischer Versuch, eine Sperre zu erhalten, ca.  per.], wenn Threads um Blockierung k√§mpfen.  Dies ist jedoch eine falsche Marke, da das Spinnen nicht der Hauptgrund f√ºr den R√ºckgang der Produktivit√§t ist.  Die zunehmende Konkurrenz um Sperren bedeutet, dass sich etwas in unserer Software verlangsamt und die Sperre beibehalten hat, was zu einem erh√∂hten Durchdrehen der CPU f√ºhrte.  Ich habe die Sperrzeit und andere Schl√ºsselindikatoren wie die Festplattenleistung √ºberpr√ºft, aber ich konnte nichts Sinnvolles finden, das den Leistungsabfall erkl√§ren k√∂nnte.  Dies ist zwar nicht logisch, aber ich bin zur√ºckgekehrt, um die Belastung der CPU mit verschiedenen Methoden zu erh√∂hen. <br><br>  Es w√§re interessant, genau herauszufinden, wo der Prozessor stecken bleibt.  WPA verf√ºgt √ºber Spalten f√ºr Datei- und Zeilennummern, diese funktionieren jedoch nur mit privaten Zeichen, die wir nicht haben, da dies .NET Framework-Code ist.  Das n√§chstbeste, was wir tun k√∂nnen, ist, die DLL-Adresse abzurufen, unter der sich die Anweisung Image RVA befindet.  Wenn Sie diese DLL in den Debugger laden und tun <br><br> <code>u xxx.dll+ImageRVA</code> <br> <br>  dann sollten wir den Befehl sehen, der die meisten CPU-Zyklen brennt, da dies die einzige "hei√üe" Adresse ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/54e/e7b/9fe54ee7bfe194a0e6fec932148f730c.png"><br><br>  Wir werden diese Adresse mit verschiedenen Windbg-Methoden untersuchen: <br><br> <code>0:000&gt; u clr.dll+0x19566B-10 <br> clr!AwareLock::Contention+0x135: <br> 00007ff8`0535565b f00f4cc6 lock cmovl eax,esi <br> 00007ff8`0535565f 2bf0 sub esi,eax <br> 00007ff8`05355661 eb01 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664) <br> 00007ff8`05355663 cc int 3 <br> 00007ff8`05355664 83e801 sub eax,1 <br> 00007ff8`05355667 7405 je clr!AwareLock::Contention+0x144 (00007ff8`0535566e) <br> 00007ff8`05355669 f390 pause <br> 00007ff8`0535566b ebf7 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664)</code> <br> <br>  Und mit verschiedenen JIT-Methoden: <br><br> <code>0:000&gt; u clr.dll+0x2801-10 <br> clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x124: <br> 00007ff8`051c27f1 5e pop rsi <br> 00007ff8`051c27f2 c3 ret <br> 00007ff8`051c27f3 833d0679930001 cmp dword ptr [clr!g_SystemInfo+0x20 (00007ff8`05afa100)],1 <br> 00007ff8`051c27fa 7e1b jle clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x14a (00007ff8`051c2817) <br> 00007ff8`051c27fc 418bc2 mov eax,r10d <br> 00007ff8`051c27ff f390 pause <br> 00007ff8`051c2801 83e801 sub eax,1 <br> 00007ff8`051c2804 75f9 jne clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x132 (00007ff8`051c27ff)</code> <br> <br>  Jetzt haben wir eine Vorlage.  In einem Fall ist die Hot-Adresse eine Sprunganweisung und im anderen Fall eine Subtraktion.  Vor beiden hei√üen Anweisungen steht jedoch dieselbe allgemeine Pausenanweisung.  Verschiedene Methoden f√ºhren denselben Prozessorbefehl aus, was aus irgendeinem Grund sehr lange dauert.  Lassen Sie uns die Ausf√ºhrungsgeschwindigkeit der pause-Anweisung messen und pr√ºfen, ob wir richtig argumentieren. <br><br><h1>  Wenn das Problem dokumentiert ist, wird es zu einer Funktion. </h1><br><table cellpadding="2" width="400" border="1"><tbody><tr><td width="224">  <strong>CPU</strong> </td><td width="176">  <strong>Pause in Nanosekunden</strong> </td></tr><tr><td width="224">  Xeon E5 1620v3 3,5 GHz </td><td width="176">  4 </td></tr><tr><td width="224">  Xeon¬Æ Gold 6126 bei 2,60 GHz </td><td width="176">  43 </td></tr></tbody></table><br>  Das Anhalten in neuen Skylake-Prozessoren dauert eine Gr√∂√üenordnung l√§nger.  Nat√ºrlich kann alles schneller und manchmal etwas langsamer werden.  Aber <b>zehnmal</b> langsamer?  Es ist eher wie ein K√§fer.  Eine kleine Suche im Internet nach Pausenanweisungen f√ºhrt zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intels Handbuch</a> , in dem die Skylake-Mikroarchitektur und Pausenanweisungen ausdr√ºcklich erw√§hnt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ca/c9f/30c/8cac9f30cd834d8c47eeab6297dda445.png"><br><br>  Nein, das ist kein Fehler, das ist eine dokumentierte Funktion.  Es gibt sogar eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite,</a> auf der die Ausf√ºhrungszeit fast aller Prozessoranweisungen angegeben ist. <br><br><ul><li>  Sandbr√ºcke 11 </li><li>  Ivy Bridege 10 </li><li>  Haswell 9 </li><li>  Broadwell 9 </li><li>  SkylakeX 141 </li></ul><br>  Hier wird die Anzahl der Prozessorzyklen angegeben.  Um die tats√§chliche Zeit zu berechnen, m√ºssen Sie die Anzahl der Zyklen durch die Prozessorfrequenz (normalerweise in GHz) dividieren und die Zeit in Nanosekunden ermitteln. <br><br>  Dies bedeutet, dass Anwendungen mit hohem Multithreading in .NET auf der letzten Hardware viel langsamer arbeiten k√∂nnen.  Jemand hat dies bereits bemerkt und im August 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Fehler registriert</a> .  Das Problem wurde in .NET Core 2.1 und .NET Framework 4.8 Preview <a href="">behoben</a> . <br><br><blockquote>  Verbesserte Wartezeit in mehreren Synchronisationsprimitiven f√ºr eine bessere Leistung auf Intel Skylake und sp√§teren Mikroarchitekturen.  [495945, mscorlib.dll, Bug] </blockquote><br>  Da es jedoch noch ein Jahr vor der Ver√∂ffentlichung von .NET 4.8 gibt, habe ich darum gebeten, die Korrekturen zur√ºck zu portieren, damit .NET 4.7.2 auf neuen Prozessoren wieder zur normalen Geschwindigkeit zur√ºckkehrt.  Da sich in vielen Teilen von .NET gegenseitig ausschlie√üende Sperren (Spinlocks) existieren, sollten Sie die erh√∂hte CPU-Auslastung verfolgen, wenn Thread.SpinWait und andere Spinnmethoden funktionieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/a11/ec8/c35a11ec843bb50b6a4c96906fa705f1.png"><br><br>  Zum Beispiel verwendet Task.Result intern das Spinnen, sodass ich in anderen Tests eine signifikante Erh√∂hung der CPU-Auslastung und eine geringere Leistung erwarte. <br><br><h1>  Wie schlimm ist es </h1><br>  Ich habe mir den .NET Core-Code angesehen, wie lange sich der Prozessor weiter dreht, wenn die Sperre nicht aufgehoben wird, bevor WaitForSingleObject aufgerufen wurde, um den ‚Äûteuren‚Äú Kontextwechsel zu bezahlen.  Ein Kontextwechsel dauert etwa eine Mikrosekunde oder viel l√§nger, wenn viele Threads dasselbe Kernelobjekt erwarten. <br><br>  .NET-Sperren multiplizieren die maximale Drehdauer mit der Anzahl der Kerne, wenn wir den absoluten Fall annehmen, in dem der Thread auf jedem Kern dieselbe Sperre erwartet und der Dreh lange genug andauert, damit alle ein wenig arbeiten k√∂nnen, bevor sie f√ºr den Kernel-Aufruf bezahlen.  Das Drehen in .NET verwendet einen exponentiellen Alterungsalgorithmus, wenn es mit einem Zyklus von 50 Pausenaufrufen beginnt, wobei f√ºr jede Iteration die Anzahl der Drehungen verdreifacht wird, bis der n√§chste Drehz√§hler ihre maximale Dauer √ºberschreitet.  Ich habe die Gesamtdrehdauer pro Prozessor f√ºr verschiedene Prozessoren und eine unterschiedliche Anzahl von Kernen berechnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/238/63b/ef9/23863bef9c09567a160f8eb3a7c2d8e7.png"><br><br>  Unten finden Sie den vereinfachten Drehcode in .NET Locks: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how .NET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> spinning during <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> contention minus the <span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span> taking/SwitchToThread/Sleep calls /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="nCores"&gt;&lt;/param&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Spin(<span class="hljs-type"><span class="hljs-type">int</span></span> nCores) { const <span class="hljs-type"><span class="hljs-type">int</span></span> dwRepetitions = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwInitialDuration = <span class="hljs-number"><span class="hljs-number">0x32</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwBackOffFactor = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> dwMaximumDuration = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * nCores; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dwRepetitions; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> duration = dwInitialDuration; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; duration; k++) { Call_PAUSE(); } duration *= dwBackOffFactor; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (duration &lt; dwMaximumDuration); } }</code> </pre> <br>  Zuvor lag die Spinnzeit im Millisekundenintervall (19 ms f√ºr 24 Kerne), was im Vergleich zur erw√§hnten Kontextumschaltzeit, die um eine Gr√∂√üenordnung schneller ist, bereits viel ist.  Bei Skylake-Prozessoren explodiert die Gesamtspinnzeit f√ºr den Prozessor auf einem 24-Bit- oder 48-Core-Computer einfach bis zu 246 ms, einfach weil der Pausenbefehl um das 14-fache verlangsamt wurde.  Das ist tats√§chlich so?  Ich habe einen kleinen Tester geschrieben, um den Gesamtspinn der CPU zu √ºberpr√ºfen - und die berechneten Zahlen entsprechen den Erwartungen.  Hier sind 48 Threads auf einer 24-Kern-CPU, die auf eine Sperre warten, die ich Monitor.PulseAll genannt habe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/6ad/e20/2f96ade20f682b4e7efe8a65d760e87e.png"><br><br>  Nur ein Thread gewinnt das Rennen, aber 47 drehen sich weiter, bis sie ihre Herzfrequenz verlieren.  Dies ist ein experimenteller Beweis daf√ºr, dass wir wirklich ein Problem mit der CPU-Auslastung haben und sehr lange Drehungen real sind.  Dies untergr√§bt die Skalierbarkeit, da diese Zyklen anstelle der n√ºtzlichen Arbeit anderer Threads ablaufen, obwohl der Pausenbefehl einige der gemeinsam genutzten Ressourcen der CPU freigibt und f√ºr eine l√§ngere Zeit Schlaf bereitstellt.  Der Grund f√ºr das Drehen ist der Versuch, eine Sperre schneller zu erhalten, ohne auf den Kernel zuzugreifen.  In diesem Fall w√§re eine Erh√∂hung der CPU-Belastung nur nominal, hatte jedoch keinerlei Auswirkungen auf die Leistung, da die Kernel andere Aufgaben ausf√ºhren.  Die Tests zeigten jedoch einen Leistungsabfall bei Operationen mit fast einem Thread, bei denen ein Thread der Arbeitswarteschlange etwas hinzuf√ºgt, w√§hrend der Arbeitsthread ein Ergebnis erwartet und dann eine bestimmte Aufgabe mit dem Arbeitselement ausf√ºhrt. <br><br>  Der Grund ist am einfachsten im Diagramm zu zeigen.  Der gegnerische Spin tritt bei jedem Schritt mit einer Verdreifachung des Spinnens auf.  Nach jeder Runde wird die Sperre erneut √ºberpr√ºft, um festzustellen, ob der aktuelle Thread sie empfangen kann.  Obwohl das Spinnen versucht, ehrlich zu sein und von Zeit zu Zeit zu anderen Themen wechselt, um ihnen zu helfen, ihre Arbeit abzuschlie√üen.  Dies erh√∂ht die Wahrscheinlichkeit, dass die Sperre bei der n√§chsten Pr√ºfung aufgehoben wird.  Das Problem ist, dass eine √úberpr√ºfung auf einen Take nur am Ende einer vollst√§ndigen Spinrunde m√∂glich ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/def/1fd/decdef1fd8ee504f92375acf31eca87d.png"><br><br>  Wenn beispielsweise zu Beginn der f√ºnften Runde eine Sperre die Verf√ºgbarkeit signalisiert, k√∂nnen Sie diese erst am Ende der Runde ausf√ºhren.  Nachdem wir die Schleuderdauer der letzten Runde berechnet haben, k√∂nnen wir den schlimmsten Verz√∂gerungsfall f√ºr unseren Fluss absch√§tzen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/b07/173/610b0717341447bc0415e77efaa731c8.png"><br><br>  Viele Millisekunden warten, bis das Drehen endet.  Ist das ein echtes Problem? <br><br>  Ich habe eine einfache Testanwendung erstellt, die eine Warteschlange von Verbraucherherstellern implementiert, in der der Workflow jedes Arbeitselement 10 ms lang ausf√ºhrt und der Verbraucher eine Verz√∂gerung von 1 bis 9 ms vor dem n√§chsten Arbeitselement hat.  Dies reicht aus, um den Effekt zu sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/70c/b97/70170cb97d0ac98a07b9733664c304fb.png"><br><br>  Bei Verz√∂gerungen von 1-2 ms betr√§gt die Gesamtdauer 2,2-2,3 s, w√§hrend in anderen F√§llen die Arbeit bis zu 1,2 s schneller ist.  Dies zeigt, dass √ºberm√§√üiges Drehen der CPU nicht nur ein kosmetisches Problem in Anwendungen mit √úber-Threading ist.  Es schadet wirklich dem einfachen Threading des Produzenten-Konsumenten, das nur zwei Threads enth√§lt.  F√ºr den obigen Lauf sprechen die ETW-Daten f√ºr sich selbst: Es ist die Zunahme des Spinnens, die die beobachtete Verz√∂gerung verursacht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/325/01e/ae932501eb724b116bc0aceac8216ef5.png"><br><br>  Wenn Sie sich den Abschnitt mit ‚ÄûBremsen‚Äú genau ansehen, werden sich im roten Bereich 11 ms drehen, obwohl der Arbeiter (hellblau) seine Arbeit beendet und das Schloss vor langer Zeit gegeben hat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89d/a51/030/89da5103028ac3b3285fced21f18d8bf.png"><br><br>  Ein schneller nicht-degenerativer Fall sieht viel besser aus, hier wird nur 1 ms f√ºr das Drehen zum Blockieren aufgewendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/220/8a4/6ef2208a4ec2e433fc2f9c8da030adca.png"><br><br>  Ich habe die <i>Testanwendung SkylakeXPause verwendet</i> .  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zip-Archiv</a> enth√§lt Quellcode und Bin√§rdateien f√ºr .NET Core und .NET 4.5.  Zum Vergleich habe ich .NET 4.8 Preview mit Fixes und .NET Core 2.0 installiert, das immer noch das alte Verhalten implementiert.  Die Anwendung wurde f√ºr .NET Standard 2.0 und .NET 4.5 entwickelt und erzeugt sowohl exe als auch dll.  Jetzt k√∂nnen Sie das alte und das neue Spinnverhalten nebeneinander √ºberpr√ºfen, ohne etwas reparieren zu m√ºssen. Dies ist sehr praktisch. <br><br><pre> <code class="hljs pgsql">readonly <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _LockObject = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItems; <span class="hljs-type"><span class="hljs-type">int</span></span> CompletedWorkItems; Barrier SyncPoint; <span class="hljs-type"><span class="hljs-type">void</span></span> RunSlowTest() { const <span class="hljs-type"><span class="hljs-type">int</span></span> processingTimeinMs = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItemsToSend = <span class="hljs-number"><span class="hljs-number">100</span></span>; Console.WriteLine($"Worker thread works {processingTimeinMs} ms for {WorkItemsToSend} times"); // Test one sender one receiver thread <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> different timings <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the sender wakes up again // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> send the next <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> item // synchronize worker <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sender. Ensure that worker starts first <span class="hljs-type"><span class="hljs-type">double</span></span>[] sendDelayTimes = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sendDelay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sendDelayTimes) { SyncPoint = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Barrier(<span class="hljs-number"><span class="hljs-number">2</span></span>); // one sender one receiver var sw = Stopwatch.StartNew(); Parallel.Invoke(() =&gt; Sender(workItems: WorkItemsToSend, delayInMs: sendDelay), () =&gt; Worker(maxWorkItemsToWork: WorkItemsToSend, workItemProcessTimeInMs: processingTimeinMs)); sw.Stop(); Console.WriteLine($"Send Delay: {sendDelay:F1} ms Work completed in {sw.Elapsed.TotalSeconds:F3} s"); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> gap <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ETW data so we can differentiate the test runs } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Simulate a worker thread which consumes CPU which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> triggered <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the Sender thread /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Worker(<span class="hljs-type"><span class="hljs-type">int</span></span> maxWorkItemsToWork, <span class="hljs-type"><span class="hljs-type">double</span></span> workItemProcessTimeInMs) { SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CompletedWorkItems != maxWorkItemsToWork) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WorkItems == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Monitor.Wait(_LockObject); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WorkItems; i++) { CompletedWorkItems++; SimulateWork(workItemProcessTimeInMs); // consume CPU under this <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> } WorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the Worker thread under a <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wake up the worker thread n times /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Sender(<span class="hljs-type"><span class="hljs-type">int</span></span> workItems, <span class="hljs-type"><span class="hljs-type">double</span></span> delayInMs) { CompletedWorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> previous <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workItems; i++) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { WorkItems++; Monitor.PulseAll(_LockObject); } SimulateWork(delayInMs); } }</code> </pre> <br><h1>  Schlussfolgerungen </h1><br>  Dies ist kein .NET-Problem.  Alle Spinlock-Implementierungen, die die pause-Anweisung verwenden, sind betroffen.  Ich habe den Kern von Windows Server 2016 schnell √ºberpr√ºft, aber es gibt kein solches Problem an der Oberfl√§che.  Es scheint, dass Intel so freundlich war - und angedeutet hat, dass einige √Ñnderungen in der Herangehensweise an das Spinnen erforderlich sind. <br><br>  Ein Fehler f√ºr .NET Core wurde im August 2017 gemeldet, und im September 2017 wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Patch</a> und eine Version von .NET Core 2.0.3 ver√∂ffentlicht.  Der Link zeigt nicht nur die hervorragende Reaktion der .NET Core-Gruppe, sondern auch die Tatsache, dass das Problem vor einigen Tagen im Hauptzweig behoben wurde, sowie eine Diskussion √ºber zus√§tzliche Spinning-Optimierungen.  Leider bewegt sich Desktop .NET Framework nicht so schnell, aber angesichts der Vorschau von .NET Framework 4.8 haben wir zumindest konzeptionelle Beweise daf√ºr, dass die dortigen Fixes auch implementierbar sind.  Jetzt warte ich darauf, dass der Backport f√ºr .NET 4.7.2 .NET mit voller Geschwindigkeit und auf der letzten Hardware verwendet.  Dies ist der erste Fehler, den ich gefunden habe und der direkt mit Leistungs√§nderungen aufgrund eines CPU-Befehls zusammenh√§ngt.  ETW bleibt der Hauptprofiler in Windows.  Wenn ich k√∂nnte, w√ºrde ich Microsoft bitten, die ETW-Infrastruktur auf Linux zu portieren, da aktuelle Linux-Profiler immer noch Mist sind.  Sie haben k√ºrzlich interessante Kernelfunktionen hinzugef√ºgt, aber es gibt noch keine Analysetools wie WPA. <br><br>  Wenn Sie mit .NET Core 2.0 oder dem Desktop .NET Framework auf den neuesten Prozessoren arbeiten, die seit Mitte 2017 ver√∂ffentlicht wurden, sollten Sie bei Problemen mit Leistungseinbu√üen Ihre Anwendungen auf jeden Fall mit einem Profiler √ºberpr√ºfen - und auf .NET Core und hoffentlich bald auf aktualisieren .NET Desktop  Meine Testanwendung informiert Sie √ºber das Vorhandensein oder Fehlen eines Problems. <br><br> <code>D:\SkylakeXPause\bin\Release\netcoreapp2.0&gt;dotnet SkylakeXPause.dll -check <br> Did call pause 1,000,000 in 3.5990 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  oder <br><br> <code>D:\SkylakeXPause\SkylakeXPause\bin\Release\net45&gt;SkylakeXPause.exe -check <br> Did call pause 1,000,000 in 3.6195 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  Das Tool meldet ein Problem, wenn Sie an .NET Framework ohne das entsprechende Update und am Skylake-Prozessor arbeiten. <br><br>  Ich hoffe, Sie fanden die Untersuchung dieses Problems genauso spannend wie ich.  Um das Problem wirklich zu verstehen, m√ºssen Sie ein Mittel zur Reproduktion erstellen, mit dem Sie experimentieren und nach Einflussfaktoren suchen k√∂nnen.  Der Rest ist nur langweilige Arbeit, aber jetzt kann ich die Ursachen und Folgen eines zyklischen Versuchs, die CPU zu sperren, viel besser verstehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415053/">https://habr.com/ru/post/de415053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415043/index.html">Fliegender Roboter ver√§ndert seine Form in der Luft</a></li>
<li><a href="../de415045/index.html">Die Oracle-Lizenzierungsrichtlinie √ºbertr√§gt die Analyse auf Hadoop</a></li>
<li><a href="../de415047/index.html">Digitale Veranstaltungen in Moskau vom 25. Juni bis 1. Juli</a></li>
<li><a href="../de415049/index.html">Erstellen von Verwaltungsbefehlen in Django</a></li>
<li><a href="../de415051/index.html">Isometrie, Z-Indizes in Handyspielen und deren Optimierung</a></li>
<li><a href="../de415055/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 320 (18.-24. Juni 2018)</a></li>
<li><a href="../de415057/index.html">PHP Digest Nr. 133 (10. - 24. Juni 2018)</a></li>
<li><a href="../de415059/index.html">Geheimnisse der JavaScript-K√ºche: Gew√ºrze</a></li>
<li><a href="../de415061/index.html">Vom Frontend zum Backend</a></li>
<li><a href="../de415063/index.html">Blue Origin wird im n√§chsten Jahr Tickets an Weltraumtouristen verkaufen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>