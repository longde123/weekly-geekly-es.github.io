<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕒 👨🏻‍🎨 🐌 Masa depan WebAssembly sebagai "pohon keterampilan" 👩🏾‍🚒 👩🏼‍🤝‍👨🏾 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa orang entah bagaimana salah memahami WebAssembly. Ada yang percaya bahwa karena browser sudah mendukung WebAssembly (sejak 2017), maka semuan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masa depan WebAssembly sebagai "pohon keterampilan"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Beberapa orang entah bagaimana salah memahami WebAssembly.  Ada yang percaya bahwa karena browser sudah mendukung WebAssembly (sejak 2017), maka semuanya sudah siap.  Bahkan belum tutup, hanya MVP (produk yang layak minimal) yang siap.  Saya bisa menebak dari mana akar kesalahan ini tumbuh: setelah rilis MVP, pengembangnya berjanji untuk mempertahankan kompatibilitas di tingkat "kode apa pun yang ditulis sekarang <b>akan</b> bekerja di masa depan".  Tetapi ini tidak berarti bahwa pengembangan WebAssembly selesai, tidak sama sekali!  Banyak fitur sedang dikembangkan saat ini dan direncanakan untuk pengembangan dalam waktu dekat.  Dan ketika mereka diimplementasikan, semuanya akan berubah sangat banyak. <br><br>  Anda dapat mencoba membayangkan semua fitur ini dalam bentuk pohon keterampilan dalam beberapa permainan.  Kami memiliki beberapa "dasar" (fitur yang sudah diterapkan) dan seluruh pohon dengan banyak cabang dan daun yang akan terbuka seiring waktu, memberi kami semakin banyak kekuatan. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="gambar"></a> <br>  Mari kita lihat apa yang sudah kita miliki sekarang dan apa yang masih harus kita temukan. <br>  ( <b>Di bawah potongan banyak gambar, lalu lintas</b> ) <br><a name="habracut"></a><br><h2>  Minimum Viable Product (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="gambar"><br>  Pada awal sejarah WebAssembly adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> , yang memungkinkan untuk mengkompilasi kode C ++ ke dalam kode JavaScript.  Ini memungkinkan kami untuk mentransfer sejumlah besar pustaka C ++ ke dunia web, yang tanpanya tidak mungkin menjalankan kode tingkat lebih tinggi.  Kode JS yang dihasilkan jauh dari ideal dan bekerja lambat (dibandingkan dengan versi aslinya).  Tapi tetap saja, insinyur Mozilla menemukan beberapa cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk membuatnya</a> lebih cepat.  Yang utama adalah alokasi subset dari bahasa yang dapat dilakukan pada kecepatan yang sebanding dengan kecepatan eksekusi kode asli.  Subset ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asm.js.</a> <br><br>  Pengembang browser lain memperhatikan dan menghargai kecepatan asm.js, semua browser utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendapatkan</a> dukungannya.  Tapi ini tidak mengakhiri cerita.  Itu baru permulaan.  Masih ada ruang untuk bekerja lebih cepat.  Tapi mereka sudah melampaui Javascript.  Ternyata kode asli (misalnya, dalam C ++) harus dikompilasi bukan dalam Javascript, tetapi dalam sesuatu yang lain.  Menjadi sesuatu yang baru, dibuat khusus sebagai alternatif cepat untuk JS.  Dan begitu WebAssembly muncul. <br><br>  Apa yang termasuk dalam versi pertama WebAssembly?  Apa yang cukup untuk mendapatkan gelar bangga "produk minimum yang layak"? <br><br><h3>  Skill: platform kompiler target </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="gambar"><br><br>  Programmer yang bekerja di WebAssembly mengerti bahwa tugas mereka bukan hanya mendukung C atau C ++.  Tugasnya adalah memberikan kesempatan untuk mengkompilasi kode dalam bahasa apa pun di WebAssembly.  Itu harus seperti "assembler", yang harus dieksekusi di browser, sama seperti kode mesin dari aplikasi desktop dieksekusi, misalnya, pada platform x86.  Tetapi bahasa baru ini seharusnya tidak bergantung pada platform tertentu, tujuannya haruslah platform abstrak dari tingkat yang lebih tinggi, implementasi spesifik yang sudah tergantung pada set instruksi yang digunakan pada perangkat keras ini. <br><br><h3>  Keahlian: eksekusi kode cepat </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="gambar"><br><br>  Semuanya harus bekerja dengan cepat.  Kalau tidak, mengapa repot-repot dengan seluruh cerita ini?  Pada akhirnya, pengguna harus dapat menjalankan aplikasi yang benar-benar “berat”, dapat memainkan game top di browser, dll. <br><br><h3>  Keterampilan: Kekompakan </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="gambar"><br><br>  Penting tidak hanya kecepatan eksekusi kode, tetapi juga kecepatan pemuatannya.  Pengguna terbiasa dengan aplikasi desktop yang diluncurkan dengan sangat cepat (karena mereka diinstal secara lokal dan memiliki semua sumber daya yang diperlukan).  Aplikasi web juga berjalan relatif cepat karena tidak memuat begitu banyak sumber daya sekaligus.  Dan ini menimbulkan tantangan baru bagi kami: jika kami ingin membuat jenis aplikasi web baru dengan basis kode sebesar "desktop" klasik, tetapi dapat diunduh dari Internet, kode harus sekompak mungkin. <br><br><h3>  Keterampilan: akses memori </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="gambar"><br><br>  Aplikasi baru kami juga perlu bekerja dengan memori dengan cara yang sedikit berbeda dari kode JavaScript.  Perlu akses langsung ke blok memori.  Ini disebabkan oleh kekhasan bahasa C dan C ++, di mana ada pointer.  Pointer adalah, secara kasar, variabel yang berisi alamat dalam memori.  Aplikasi dapat membaca data di alamat ini, mengubahnya, dan bahkan menggunakan aritmatika ke penunjuk untuk "berjalan" di memori maju dari alamat yang ditentukan.  Sejumlah besar kode C / C ++ menggunakan pointer untuk meningkatkan efisiensi kerjanya, membuat platform target untuk kode tersebut tidak mungkin tanpa dukungan pointer. <br><br>  Tetapi kami tidak dapat membiarkan sepotong kode yang diunduh dari Internet memiliki akses langsung ke memori proses kami - ini terlalu berbahaya.  Kita harus menciptakan lingkungan yang, di satu sisi, akan memungkinkan kode asli yang dikompilasi di WebAssembly percaya bahwa ia memiliki akses memori langsung, tetapi di sisi lain, itu akan secara ketat membatasi area di mana ia diizinkan untuk memanipulasi data. <br><br>  Untuk ini, WebAssembly menggunakan "model memori linier."  Ini diimplementasikan menggunakan TypedArrays - sesuatu seperti array dalam JavaScript, tetapi hanya berisi sekumpulan byte dalam memori.  Saat Anda ingin meletakkan sesuatu di dalamnya, Anda menggunakan akses ke elemen dengan indeks (yang bisa menjadi alamat dalam memori).  Dengan demikian, array ini "berpura-pura" menjadi blok memori untuk kode C ++. <br><br><h3>  Prestasi baru! </h3><br>  Jadi, dengan semua hal di atas, orang pada akhirnya akan dapat menjalankan aplikasi desktop di browser dengan kinerja yang hampir sama seolah-olah itu asli.  Itu tentang set fitur ini dan disebut "minimum viable product" (MVP). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="gambar"><br><br>  Pada titik ini, beberapa aplikasi memang sudah bisa dibangun di bawah WebAssembly dan menghasilkan uang di browser.  Tapi masih ada jalan panjang di depan. <br><br><h2>  Aplikasi desktop kelas berat </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="gambar"><br><br>  Langkah penting berikutnya adalah kemampuan untuk meluncurkan aplikasi desktop yang sangat besar.  Bisakah Anda bayangkan versi lengkap Photoshop berjalan di browser?  Dan Anda tidak menginstalnya, cukup buka tautan - dan sekarang Anda memiliki kekuatan 100% dari produk ini, dengan kecepatan asli, versi terbaru dengan semua pembaruan dan perbaikan, di perangkat apa pun. <br><br>  Dan kita tidak jauh dari ini - contoh sudah mulai muncul.  Misalnya, AutoCAD.  Dan juga Adobe Lightroom.  Tapi mari kita jujur ​​- tidak semuanya siap dalam implementasi WebAssembly saat ini untuk meluncurkan aplikasi yang benar-benar besar.  Kemacetan diselidiki dan diperbaiki di sini pada saat ini ketika Anda membaca artikel ini. <br><br><h3>  Keahlian: multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="gambar"><br><br>  Jelas, kita perlu multithreading.  Komputer modern memiliki banyak inti.  Kita harus bisa menggunakannya. <br><br><h3>  Keterampilan: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="gambar"><br><br>  Selain multithreading, ada teknologi lain yang memungkinkan implementasi pemrosesan data paralel yang lebih efisien.  Ini adalah SIMD: diproses dengan instruksi tunggal dari beberapa blok data sekaligus.  Aspek penting yang diperlukan untuk WebAssembly yang sangat cepat. <br><br><h3>  Keterampilan: pengalamatan 64-bit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="gambar"><br><br>  Fitur penting lainnya dari arsitektur perangkat keras modern, yang belum tersedia di WebAssembly, adalah dukungan untuk memori 64-bit.  Ini sederhana: dengan alamat 32-bit Anda hanya dapat menggunakan memori 4 GB (yang sangat kecil untuk program besar), tetapi dengan alamat 64-bit sudah mencapai 16 exabytes (ini banyak untuk perangkat lunak modern).  Tentu saja, tidak hanya maksimum teoretis yang penting, tetapi juga yang praktis (berapa banyak memori yang diberikan OS kepada Anda).  Tetapi pada sebagian besar perangkat modern sudah ada 4 atau lebih GB RAM dan jumlah ini akan meningkat. <br><br><h3>  Keterampilan: Kompilasi Aliran </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="gambar"><br><br>  Kita tidak hanya perlu menjalankan aplikasi dengan cepat.  Kita juga perlu mengurangi interval waktu antara awal unduhannya melalui jaringan dan permulaannya.  Kompilasi aliran memungkinkan Anda untuk mulai memproses file WebAssembly sebelum akhirnya diunduh.  Kami meninjau instruksi ketika mereka mengunduh melalui jaringan.  Dengan demikian, pemuatan dan kompilasi berjalan paralel.  Dalam kode Firefox, kami dapat mencapai kecepatan kompilasi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih tinggi dari kecepatan unduhan</a> - yaitu, waktu pemrosesan beberapa kode N byte ternyata kurang dari waktu unduhan kode ini melalui jaringan.  Pengembang browser lain juga sedang mengerjakan kompilasi aliran. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="gambar"><br><br>  Suatu hal yang berkaitan dengan kompilasi streaming adalah penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua kompiler</a> .  Salah satunya (dijelaskan di atas) bekerja dengan cepat dan memungkinkan Anda untuk segera meluncurkan kode yang diunduh.  Namun, ia tidak melakukan semua optimasi yang dimungkinkan secara teoritis, karena ia membutuhkan lebih banyak waktu.  Optimalisasi tersebut dilakukan oleh kompiler lain yang bekerja di latar belakang.  Segera setelah dia menyelesaikan pekerjaannya, satu versi di memori menggantikan yang lain dan kemudian bekerja sebagai gantinya. <br><br>  Jadi kami mendapatkan aplikasi cepat dan pengoperasian yang efektif. <br><br><h3>  Keterampilan: Caching </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="gambar"><br><br>  Jika kita pernah mengunduh dan mengkompilasi beberapa kode WebAssembly oleh kompiler yang mengoptimalkan, maka tidak masuk akal untuk melakukan hal yang sama ketika memuat kode ini di tab lain (atau waktu berikutnya browser dibuka, asalkan aplikasi tetap tidak berubah).  Kode yang dikompilasi dapat (dan harus) di-cache dan kemudian digunakan dari cache. <br><br><h3>  Keahlian: peningkatan lainnya </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="gambar"><br><br>  Sekarang ada banyak diskusi tentang apa perbaikan lain yang mungkin dan pada apa upaya pengembang harus fokus.  Sesuatu pasti akan direalisasikan, sesuatu yang tidak segera, sesuatu tidak akan terjadi sama sekali.  Saya, dengan izin Anda, akan mendefinisikan semua poin ini di kelas umum "perbaikan lain", dan apa yang akan masuk ke dalamnya kita akan mengerti dengan waktu. <br><br><h3>  Di mana kita sekarang? </h3><br>  Di suatu tempat di sekitar sini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="gambar"><br><br><h4>  Multithreading </h4><br>  Untuk multithreading, kami memiliki rencana yang hampir siap, tetapi salah satu bagian kunci ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SharedArrayBuffers</a> ) terpaksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dinonaktifkan</a> pada awal tahun ini.  Ini akan segera dihidupkan kembali dan kita dapat melanjutkan. <br><br><h4>  SIMD </h4><br>  <a href="">Dikembangkan secara</a> aktif sekarang. <br><br><h4>  Pengalamatan 64-bit </h4><br>  Untuk <a href="">wasm-64</a> , kami memiliki ide yang cukup jelas tentang bagaimana segala sesuatu harus bekerja.  Kami didasarkan pada pendekatan arsitektur x86 dan ARM. <br><br><h4>  Kompilasi aliran </h4><br>  Di Firefox, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditambahkan</a> kembali pada tahun 2017, browser lain sedang mengerjakannya. <br><br><h4>  Menggunakan dua kompiler </h4><br>  Di Firefox, ini ditambahkan kembali pada 2017, dan pada browser lain pada 2018. <br><br><h4>  Caching HTTP implisit </h4><br>  Di Firefox, pengembangannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hampir selesai</a> , akan ada rilis segera. <br><br><h4>  Perbaikan lainnya </h4><br>  Ada diskusi <br><br>  Seperti yang Anda lihat, sebagian besar item masih dalam pengembangan aktif.  Namun demikian, kita sudah dapat melihat aplikasi berjalan di WebAssembly hari ini, karena kemampuan saat ini sudah cukup untuk seseorang.  Segera setelah semua fitur di atas siap, kami akan membuka "pencapaian baru" dan bahkan lebih banyak aplikasi baru akan menerima dukungan WebAssembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="gambar"><br><br><h2>  Interaksi Javascript </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="gambar"></a> <br><br>  WebAssembly dibuat tidak hanya sebagai platform untuk game dan aplikasi berat.  Ini dapat digunakan untuk pengembangan web biasa.  Kami menyadari bahwa saat ini ada aplikasi web yang sangat besar yang ditulis dalam Javascript dan sedikit yang memutuskan untuk mengambil dan sepenuhnya menulis ulang ke WebAssembly.  Poin penting di sini adalah bahwa ini tidak perlu.  Kemungkinan besar, sebagian besar aplikasi ini bekerja dengan sangat baik dan hanya di beberapa kemacetan, mungkin, ada kurangnya kinerja dalam perhitungan, atau bandwidth pemrosesan data, atau kurangnya fungsionalitas karena kurangnya versi JS dari beberapa perpustakaan.  Kami ingin memberi pengembang kesempatan untuk menulis ulang hanya kemacetan ini di WebAssembly, meninggalkan sisa kode di JS yang sudah dikenal.  Dan itu sudah mungkin.  Misalnya, dengan menulis ulang parser Gutenberg ke Rust dan membangunnya di bawah WebAssebly, kami berhasil mencapai peningkatan produktivitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">86 kali lipat</a> . <br><br>  Tetapi untuk menjadikan latihan seperti ini massa dan nyaman, kita perlu menerapkan sesuatu yang lain. <br><br><h3>  Keterampilan: panggilan cepat antara JS dan WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="gambar"><br><br>  Memanggil WebAssembly dari JS harus bekerja sangat cepat.  Dengan menambahkan modul WebAssembly kecil, programmer seharusnya tidak merasakan kehilangan kinerja, bahkan jika modul ini disebut sangat sering.  Ini tidak terjadi di MVP (karena tujuan MVP bukan untuk memaksimalkan kinerja panggilan seperti itu).  Masalah ini belum diperbaiki.  Di Firefox, kami telah memastikan bahwa beberapa panggilan JS -&gt; WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah lebih cepat daripada panggilan JS -&gt; JS non - inline</a> .  Pengembang browser lain juga sedang mengerjakan tugas ini. <br><br><h3>  Keahlian: pertukaran data cepat </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="gambar"><br><br>  Tugas ini terhubung dengan yang sebelumnya: penting tidak hanya untuk cepat memanggil kode WebAssembly dari JS, tetapi juga untuk dengan cepat mentransfer data di antara mereka.  Ada beberapa masalah dengan ini.  Misalnya, fakta bahwa WebAssembly hanya memahami angka.  Tidak ada objek di dalamnya, tetapi di JS mereka.  Ternyata kita membutuhkan semacam lapisan terjemahan.  Sudah ada, tetapi masih belum cukup produktif. <br><br><h3>  Keahlian: Integrasi dengan Modul ES </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="gambar"><br><br>  Sekarang, menggunakan modul WebAssembly seperti memanggil API khusus yang akan mengembalikan modul kepada Anda untuk digunakan.  Tetapi ini berarti bahwa modul WebAssembly tidak benar-benar bagian dari grafik modul JS dari aplikasi web.  Agar semua fungsi tersedia untuk modul-ES (seperti ekspor dan impor), modul WebAssembly harus dapat diintegrasikan dengan modul-ES. <br><br><h3>  Keterampilan: Integrasi dalam Pembangunan </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="gambar"><br><br>  Mampu mengimpor dan mengekspor tidak berarti menjadi modul yang berfungsi penuh.  Kita membutuhkan tempat di mana modul WebAssembly dapat didistribusikan.  Apa yang akan menjadi analog dari npm untuk WebAssembly?  Hmm ... bagaimana dengan npm itu sendiri?  Dan apa yang akan menjadi analog dari webpack atau Parcel untuk WebAssembly?  Hmm ... bagaimana dengan webpack dan Parcel? <br><br>  Modul WebAssembly tidak boleh berbeda dari modul biasa, yang berarti bahwa modul tersebut dapat didistribusikan melalui infrastruktur yang sama.  Tetapi kita membutuhkan alat untuk mengintegrasikannya ke dalam infrastruktur ini. <br><br><h3>  Keterampilan: Kompatibilitas Mundur </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="gambar"><br><br>  Ada hal penting lain yang harus kami sediakan.  Semuanya akan berfungsi dengan baik bahkan di versi browser yang lebih lama.  Bahkan mereka yang tidak tahu tentang WebAssembly.  Kami harus menjamin bahwa setelah kami menulis kode untuk WebAssembly, pengembang tidak perlu menulis versi kedua dari kode yang sama dalam Javascript hanya karena situs tersebut juga harus terbuka di IE11. <br><br><h3>  Di mana kita sekarang? </h3><br>  Di suatu tempat di sini: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="gambar"><br><br><h4>  Pintasan antara JS dan WebAssembly </h4><br>  Sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterapkan</a> di Firefox, pekerjaan sedang berlangsung di browser lain. <br><br><h4>  Pertukaran data cepat </h4><br>  Ada beberapa saran.  Misalnya, perluas sistem tipe di WebAssembly dengan referensi ke objek JS.  Ini mungkin, tetapi akan mengharuskan penulisan kode tambahan (misalnya, untuk memanggil metode JS), yang tidak bekerja terlalu cepat.  Untuk mengatasi masalah ini, pada gilirannya, ada beberapa saran. <br><br>  Ada aspek lain yang terkait dengan pertukaran data.  Ini tentang melacak berapa lama data dapat disimpan dalam memori.  Jika Anda memiliki data di memori yang harus diakses oleh kode JS, maka Anda harus membiarkannya di sana hingga kode JS membacanya.  Tetapi jika Anda meninggalkan mereka di sana selamanya, maka kita akan mendapatkan kebocoran memori.  Bagaimana mengetahui bahwa data sudah dapat dihapus (kode JS sudah membacanya)?  Hari ini, tanggung jawab ini ada di tangan programmer - semuanya dirilis secara manual.  Setelah kode JS selesai membaca data, itu harus memanggil sesuatu seperti fungsi "bebas".  Tetapi pendekatan ini sudah ketinggalan zaman dan sering menyebabkan kesalahan.  Untuk mengatasi masalah ini, kami memperkenalkan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WeakRef</a> di Javascript.  Ini memungkinkan untuk membaca data di sisi kode JS, dan ketika pemulung bekerja, perlu untuk menghapus memori dengan benar dalam modul WebAssembly. <br><br>  Semua ini masih dalam pengembangan.  Sementara itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, alat-alat telah dibuat</a> di ekosistem Rust yang mengotomatiskan penulisan kode semacam itu untuk Anda, menggantikan bagian-bagian yang belum diimplementasikan dengan implementasinya sendiri.  Salah satu alat ini patut mendapat perhatian khusus.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasm-bindgen</a> .  Ketika ia mengetahui bahwa kode Rust Anda mencoba untuk mendapatkan atau mengembalikan objek JS atau objek DOM, secara otomatis membuat lapisan JS yang akan dapat berinteraksi dengan kode Rust Anda.  Dan lapisan ini juga dapat berinteraksi dengan modul WebAssembly yang ditulis dalam bahasa lain, sehingga tidak hanya programmer Rust yang dapat menggunakan alat ini. <br><br><h4>  Integrasi dengan Modul ES </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rencana</a> kerja di bidang ini telah ada selama beberapa waktu.  Kami secara aktif mengerjakannya bersama dengan pengembang peramban lain. <br><br><h4>  Integrasi Pengembangan </h4><br>  Sudah, ada alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasm-pack</a> di ekosistem Rust yang memungkinkan Anda secara otomatis mengemas semua yang Anda butuhkan untuk rilis di npm.  Dan ada orang yang menggunakan alat ini untuk membuat modul mereka. <br><br><h4>  Kompatibilitas mundur </h4><br>  Untuk kompatibilitas mundur, kami memiliki alat wasm2js.  Ini memungkinkan Anda untuk mengubah file wasm menjadi file JS yang setara.  Kode Javascript ini tidak akan cepat, tetapi akan berfungsi pada browser apa pun (termasuk yang tidak mendukung WebAssembly). <br><br>  Seperti yang Anda lihat, kami sangat dekat untuk menerima "pencapaian" ini.  Dan begitu kita melakukan ini, jalan menuju dua lagi akan terbuka. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="gambar"></a> <br><br><h2>  Kerangka kerja JS dan bahasa yang dikompilasi JS </h2><br>  Yang pertama adalah kemampuan untuk menulis ulang kerangka JS kelas berat populer di WebAssebly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="gambar"><br><br>  Yang kedua adalah mengaktifkan bahasa pemrograman yang dikompilasi dalam Javascript untuk menggantikannya dengan WebAssembly.  Kita berbicara tentang bahasa seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="gambar"><br><br>  Untuk kedua tugas ini, WebAssembly harus mendukung sejumlah fitur tingkat tinggi baru. <br><br><h3>  Keterampilan: Pengumpul Sampah </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="gambar"><br><br>  Kami membutuhkan integrasi dengan pengumpul sampah berbasis browser untuk sejumlah alasan.  Pertama, mari kita ingat tugas menulis ulang kerangka JS (atau bagian dari mereka).  Mungkin diperlukan. ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm —     Javascript,        .   WebAssembly      —          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="gambar"><br><br>    . ,  ,  Rust,   .    — .            —    .       WebAssembly     . <br><br>  ,    Javascript.          — -           - .   WebAssembly-  JS-,     —      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="gambar"><br><br>   ,    JS-,    .         Javascript-.         WebAssembly. <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="gambar"><br><br>       ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ".       ,        —              .         ,        WebAssembly. <br><br><h3>   ? </h3><br> -  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="gambar"><br><br><h4>   </h4><br>  Untuk mengimplementasikan pengumpulan sampah, pekerjaan saat ini sedang berlangsung dalam dua arah: ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Objek yang Diketik</a> untuk JS dan, pada kenyataannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengumpul sampah untuk WebAssembly</a> .  Objek yang Diketik memungkinkan Anda untuk menggambarkan struktur objek yang jelas.  Sudah ada visi tentang bagaimana ini harus bekerja, dan itu akan dibahas pada pertemuan TC39 mendatang.  Dengan demikian, GC untuk WebAssembly akan dapat mengakses struktur di atas untuk keperluannya sendiri.  Pekerjaan sudah berjalan pada implementasinya. <br><br>  Segera setelah kedua bagian selesai, kita akan mendapatkan sistem dari interaksi JS dan WebAssembly, mampu memahami di semua tingkatan apa objek terdiri dan secara efektif menggunakan data internalnya.  Kami sudah memiliki prototipe yang berfungsi.  Namun, prototipe tidak dapat diambil dan dirilis - kita harus meluangkan waktu untuk standardisasi dan revisi.  Kami berharap itu akan mencapai rilis di suatu tempat di tahun 2019. <br><br><h4>  Penanganan pengecualian </h4><br>  Pekerjaan <a href="">pengecualian</a> saat <a href="">ini</a> sedang dalam penelitian dan pengembangan.  Kami mempertimbangkan berbagai proposal, mencoba mengimplementasikannya, dan melihat seberapa efektif kerjanya. <br><br><h4>  Debugging </h4><br>  Untuk debugging, sudah ada beberapa dukungan di alat pengembang Firefox.  Namun yang ideal masih jauh.  Kami ingin menunjukkan kepada pengembang kode sumber dan posisi saat ini di dalamnya, dan bukan hanya instruksi assembler.  Kita harus mengembangkan dan mengimplementasikan dukungan untuk file simbol, yang akan memungkinkan kita untuk mengkorelasikan setiap instruksi kode dengan baris sumber.  Saat ini, <a href="">pekerjaan sedang dilakukan</a> pada spesifikasi mekanisme ini. <br><br><h4>  Buntut panggilan </h4><br>  <a href="">Ada pekerjaan yang sedang berjalan</a> . <br><br>  Ketika semua hal di atas selesai, kita dapat mengasumsikan bahwa kita telah mencapai pencapaian "kerangka kerja JS dan bahasa yang dikompilasi ke dalam JS" <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="gambar"></a> <br><br>  Jadi, itu adalah rencana untuk mendapatkan "prestasi" di browser.  Bagaimana dengan apa yang terjadi di luar browser? <br><br><h2>  Keluar dari browser </h2><br>  Mungkin Anda malu dengan kombinasi kata "di luar browser."  Apakah kita benar-benar memiliki sesuatu selain peramban ketika kita berbicara tentang web?  Namun "web" yang kita miliki tepat dengan nama "WebAssembly".  Namun pada kenyataannya, HTML, CSS dan JavaScript hanyalah puncak gunung es. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="gambar"><br><br>  Ya, mereka paling terlihat, karena merekalah yang membentuk antarmuka pengguna.  Tetapi ada bagian lain yang sangat penting dari web - koneksi itu.  Koneksi segalanya dengan segalanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="gambar"><br><br>  Saya dapat menautkan ke halaman Anda sekarang.  Saya tidak membutuhkan izin Anda atau orang lain.  Saya hanya membuat tautan ini, menambahkannya ke situs saya.  Siapa pun dapat mengikutinya dan konten Anda akan ditampilkan, kode yang Anda tulis akan diluncurkan.  Kesederhanaan dalam menciptakan koneksi dan transisi melalui mereka telah menciptakan Internet kita sebagaimana adanya.  Sekarang kami memiliki jejaring sosial dan situs lain yang, pada dasarnya, memperluas konsep "tautan" dengan kemampuan untuk merapat apa pun: orang, perangkat, bisnis, dll. <br><br>  Tetapi dengan semua tautan dan tautan ini, ada dua masalah. <br><br>  Pertama, apa yang harus dilakukan tautan?  Jika Anda pergi ke suatu tempat dan situs menawarkan beberapa kode yang harus dijalankan di browser Anda, kode ini harus lintas platform.  Ini harus dikompilasi menjadi sesuatu dan berjalan di poppy, di Windows, di android.  Di mana-mana.  Portabilitas kode yang dapat diunduh adalah bagian penting dari konsep konektivitas web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="gambar"><br><br>  Tetapi mengunduh dan menjalankan kode saja tidak cukup.  Anda perlu memahami bahwa kami tidak tahu apa-apa tentang kode ini.  Kami tidak cukup percaya padanya untuk memberikan kontrol penuh atas komputer pengguna.  Bagaimana jika itu kode berbahaya?  Dia bisa melakukan sesuatu yang buruk.  Dan di sini kita membutuhkan semacam model keamanan.  Kita membutuhkan kotak pasir di mana kita dapat menempatkan kode yang tidak dikenal, memberikannya beberapa alat yang dikontrol untuk bekerja, tetapi menghapus semua yang penting dan tidak aman darinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="gambar"><br><br>  Jadi, ada dua aspek dari konsep "komunikasi": portabilitas dan keamanan.  Kami tahu bahwa kami pasti dapat menjalankan kode itu dan tentu saja itu tidak akan membahayakan kami.  Mengapa saya bersikeras pada konsep-konsep ini dan bagaimana pandangan hal-hal ini berbeda dari pandangan web sebagai kombinasi dari HTML, CSS dan Javascript?  Karena pendekatan ini secara mendasar mengubah pandangan tentang apa itu WebAssembly. <br><br>  Di satu sisi, kita dapat menganggap WebAssembly sebagai "alat lain yang tersedia di peramban modern."  Begitulah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="gambar"><br><br>  Tetapi portabilitas dan keamanan eksekusi kode membuka pintu lain bagi kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="gambar"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="gambar"><br><br>  Bagaimana WebAssembly membantu Node?  Membawa portabilitas. <br><br>  Node memberikan tingkat portabilitas yang cukup tinggi dengan menggunakan Javascript.  Tetapi masih ada banyak kasus di mana kinerja kode JS tidak cukup atau hanya kode JS yang tepat belum ditulis, tetapi ada versi asli itu.  Dan kemudian Node menggunakan modul asli.  Mereka ditulis dalam bahasa seperti C dan perlu dikompilasi untuk platform spesifik Node Anda berjalan. <br><br>  Modul asli dapat dikompilasi selama instalasi, atau Anda dapat langsung siap untuk salah satu platform yang populer.  Kedua pendekatan itu mungkin, tetapi ini hanya pilihan dua kejahatan: baik sakit kepala tambahan untuk pengguna, atau penulis modul. <br><br>  Jika Anda membayangkan bahwa modul-modul ini akan ada di WebAssembly, maka mereka tidak perlu dikompilasi sama sekali.  Portabilitas memungkinkan Anda untuk menjalankannya di platform apa pun, segera, seperti kode Javascript.  Tetapi mereka akan bekerja dengan kinerja versi asli. <br><br>  Dan di sini kebahagiaan datang ke dunia Node dalam bentuk portabilitas penuh dari segala sesuatu dan di mana-mana.  Anda dapat mem-port aplikasi Node dari Linux ke Windows - dan semuanya akan terus berfungsi tanpa kompilasi ulang.  Tetapi pada saat yang sama, modul WebAssembly tidak memiliki akses ke sumber daya sistem (ia bekerja di kotak pasirnya).  Tetapi modul Node asli (dan bahkan non-asli) tidak berfungsi di kotak pasir, mereka memiliki akses ke segalanya - ini adalah ideologi Node.  Dengan demikian, agar modul WebAssembly mendapatkan fitur yang sama, diperlukan lapisan tambahan akses ke sumber daya OS.  Sesuatu seperti fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSIX-</a> (mereka tidak perlu, mereka hanya diberikan sebagai contoh dari antarmuka akses sumber daya yang relatif stabil dan cukup). <br><br><h3>  Keterampilan: antarmuka portabel </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="gambar"><br><br>  Jadi, apa yang dibutuhkan pengembang Node untuk menggunakan modul WebAssembly?  Beberapa jenis antarmuka untuk mengakses fungsinya.  Akan lebih baik untuk membakukannya.  Nah, agar Node tidak hanya bisa memanggil fungsi-fungsi ini, tetapi juga siapa saja secara umum.  Jika Anda ingin menggunakan modul WebAssembly di aplikasi Anda, kami telah terhubung dan menggunakannya.  Sesuatu seperti "POSIX untuk WebAssembly".  PWSIX (antarmuka sistem WebAssembly portabel)? <br><br><h3>  Di mana kita sekarang? </h3><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumen</a> yang menjelaskan mekanisme untuk menyediakan jalur ke modul dengan namanya.  Ini kemungkinan akan digunakan oleh kedua browser dan Node (mereka akan dapat memberikan jalur yang berbeda).  Meskipun tidak ada pengembangan aktif, tetapi ada banyak diskusi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="gambar"><br><br>  Kemungkinan besar itu akan diimplementasikan dalam beberapa bentuk.  Ini bagus karena membuka sejumlah kemungkinan bagi kita. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="gambar"></a> <br><br><h2>  CDN, Serverless, dan Edge Computing </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="gambar"><br><br>  Contohnya adalah hal-hal seperti CDN, Serverless, Edge Computing.  Kasus ketika Anda meletakkan kode Anda di server orang lain, yang menjaga ketersediaannya untuk klien.  Mengapa Anda membutuhkan WebAssembly di sini?  Baru-baru ini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang</a> bagus tentang topik ini.  Singkatnya, mungkin perlu menjalankan kode dari sumber yang berbeda (tidak saling percaya) dalam satu proses.  Kode ini perlu diisolasi satu sama lain dan dari OS.  Solusi seperti mesin virtual JS (SpiderMonkey atau V8) entah bagaimana berfungsi, tetapi tidak memberikan kinerja dan skalabilitas yang diinginkan.  Dan WebAssembly - memberi. <br><br>  Apa yang dibutuhkan untuk membuat ini bekerja? <br><br><h3>  Keahlian: runtime </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="gambar"><br><br>  Kami memerlukan lingkungan runtime dan beberapa perusahaan membuat sendiri.  Kami sudah memiliki kompiler WebAssembly (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cranelift</a> ) - mereka cepat dan efisien memori.  Tetapi kode yang dihasilkan olehnya tidak dapat hidup dalam ruang hampa - ia perlu mengandalkan sesuatu, entah bagaimana berinteraksi dengan lingkungan.  Sekarang beberapa perusahaan, seperti Fastly, menulis lingkungan runtime ini sendiri.  Tetapi ini bukan pendekatan yang sangat bagus - lagipula, banyak perusahaan akan membutuhkannya dan mereka akan melakukan pekerjaan yang sama, lagi dan lagi.  Kita bisa melakukannya sekali, menambah standar - dan menyelamatkan semua sumber daya orang. <br><br><h3>  Di mana kita sekarang? </h3><br>  Di suatu tempat di sini: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="gambar"><br><br>  Belum ada standar runtime.  Yang tidak mencegah beberapa runtimes independen yang sudah digunakan dalam proyek nyata dari yang ada dan berfungsi.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAVM</a> dan wasmjit. <br><br>  Kami juga berencana untuk merilis runtime yang dibangun di atas Cranelift, itu akan disebut wasmtime.  Dan segera setelah kami memiliki sesuatu yang terstandarisasi dan berfungsi, ini adalah kesempatan terbuka untuk mengembangkan sejumlah hal, seperti, misalnya ... <br><br><h2>  Utilitas baris perintah portabel </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="gambar"><br><br>  WebAssembly dapat digunakan tidak hanya di browser, tetapi juga di sistem operasi tradisional.  Kami tidak akan berbicara tentang kernel (meskipun ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemberani</a> yang melambai juga), tetapi kode WebAssembly mungkin bekerja dalam mode pengguna.  Dan ini memungkinkan untuk membuat utilitas baris perintah yang, setelah dibangun, akan bekerja dijamin sama untuk OS apa pun. <br><br><h2>  Internet hal </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="gambar"><br><br>  Yang dimaksud dengan "Internet of things" biasanya adalah perangkat berdaya rendah (seperti perangkat sensor / controller yang dapat dipakai atau beragam di "rumah pintar").  Keterbatasan pada sumber daya prosesor yang tersedia dan RAM secara negatif mempengaruhi kemampuan untuk menjalankan kode JS di sana, tetapi WebAssembly adalah masalah yang sama sekali berbeda.  Mengoptimalkan kompiler seperti Cranelift dan runtime seperti wasmtime akan bersinar dalam kondisi seperti itu, karena mereka hanya ditulis untuk tugas hemat sumber daya.  Dalam kasus yang benar-benar ekstrem, WebAssembly bahkan memungkinkan untuk mengkompilasi modul Anda ke dalam biner asli platform target.  Sekali lagi, portabilitas - ada banyak semua perangkat IOT hari ini dan mereka dibangun pada platform yang berbeda.  Dengan WebAssembly, Anda tidak perlu khawatir tentang hal ini - kode yang dikembangkan akan berjalan di mana-mana. <br><br><h2>  Kesimpulan </h2><br>  Mari kita mundur sedikit dan melihat “pohon keterampilan” kita lagi. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="gambar"></a> <br><br>  Saya memulai artikel ini dengan fakta bahwa beberapa orang tidak mengerti mengapa WebAssembly belum selesai.  Seperti yang Anda sekarang bisa mengerti - jalannya baru saja dimulai.  Ya, MVP sudah membuka beberapa kemungkinan.  Kami sudah dapat mengkompilasi sesuatu di WebAssembly dan menjalankannya di browser.  Tetapi masih ada banyak pekerjaan di depan - mendukung semua yang Anda butuhkan untuk aplikasi berat dan bahasa tingkat tinggi, menggantikan kerangka kerja JS dan semua hal ini "di luar browser" yang saya bicarakan.  Ketika semua ini siap, kita akan melihat web baru.  Performa tinggi, lebih besar, lebih portabel.  Tidak akan ada lagi jenis perangkat lunak yang tidak dapat ditulis untuk dieksekusi di browser: game, blockchain, Internet hal, utilitas baris perintah - semuanya akan dimulai. <br><br>  WebAssembly belum selesai.  Dia baru saja mulai. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428347/">https://habr.com/ru/post/id428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428337/index.html">Menghibur JavaScript: Tanpa kurung kurawal</a></li>
<li><a href="../id428339/index.html">Jangan Otomatiskan: Tip Bisnis Buruk</a></li>
<li><a href="../id428341/index.html">Qsan RAID EE Technology</a></li>
<li><a href="../id428343/index.html">Teka-teki yang menarik di C</a></li>
<li><a href="../id428345/index.html">Mencakup persyaratan dengan kasing. Realitas SuperJob</a></li>
<li><a href="../id428351/index.html">Saya melihat Anda: pembelajaran mesin dan jaringan saraf tiruan dalam studi visi Drosophila</a></li>
<li><a href="../id428355/index.html">Mekanika Gamifikasi: Peringkat</a></li>
<li><a href="../id428363/index.html">Membangun jetpack / hoverboard: sistem penyelamatan</a></li>
<li><a href="../id428365/index.html">Kisah tentang bagaimana penagihan Google berubah, atau bagaimana menghindari biaya yang tidak perlu</a></li>
<li><a href="../id428367/index.html">Kami membuat modem sonar terkecil di dunia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>