<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’¹ ğŸ« ğŸ“¼ Guide SQL: comment mieux Ã©crire des requÃªtes (partie 1) ğŸ‘ğŸ½ ğŸ¤³ğŸ¼ ğŸ‘‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En savoir plus sur les antipatterns, les plans d'exÃ©cution, la complexitÃ© temporelle, le rÃ©glage des requÃªtes et l'optimisation SQL 
 Le langage de re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide SQL: comment mieux Ã©crire des requÃªtes (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  En savoir plus sur les antipatterns, les plans d'exÃ©cution, la complexitÃ© temporelle, le rÃ©glage des requÃªtes et l'optimisation SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Le langage de requÃªte structurÃ© (SQL) est une compÃ©tence indispensable dans l'industrie informatique et, d'une maniÃ¨re gÃ©nÃ©rale, l'apprentissage de cette compÃ©tence est relativement simple.  Cependant, la plupart des gens oublient que SQL ne consiste pas seulement Ã  Ã©crire des requÃªtes, c'est juste la premiÃ¨re Ã©tape sur la route.  Garantir les performances des requÃªtes ou faire correspondre le contexte dans lequel vous travaillez est une tout autre chose. <br><br>  C'est pourquoi ce guide SQL vous fournira un petit aperÃ§u de certaines des Ã©tapes que vous pouvez suivre pour Ã©valuer votre requÃªte: <br><br><ul><li>  Tout d'abord, vous commencerez par un bref aperÃ§u de l'importance de l'apprentissage SQL pour travailler dans le domaine de la science des donnÃ©es; </li><li>  Ensuite, vous apprendrez d'abord comment traiter et exÃ©cuter des requÃªtes SQL afin de comprendre l'importance de crÃ©er des requÃªtes de qualitÃ©.  Plus prÃ©cisÃ©ment, vous verrez que la demande est analysÃ©e, rÃ©Ã©crite, optimisÃ©e et finalement Ã©valuÃ©e. </li><li>  Dans cet esprit, vous irez non seulement Ã  quelques antipatterns de requÃªtes que les dÃ©butants font lors de l'Ã©criture de requÃªtes, mais vous en apprendrez Ã©galement plus sur les alternatives et les solutions Ã  ces erreurs possibles;  De plus, vous en apprendrez davantage sur l'approche de requÃªte basÃ©e sur un ensemble. </li><li>  Vous verrez Ã©galement que ces antipatterns dÃ©coulent de problÃ¨mes de performances et qu'en plus de l'approche Â«manuelleÂ» pour amÃ©liorer les requÃªtes SQL, vous pouvez analyser vos requÃªtes de maniÃ¨re plus structurÃ©e et approfondie, en utilisant d'autres outils qui vous aident Ã  voir le plan de requÃªte;  Et </li><li>  Vous apprendrez briÃ¨vement la complexitÃ© du temps et la notation O, pour avoir une idÃ©e de la complexitÃ© du plan d'exÃ©cution Ã  temps avant d'exÃ©cuter la demande; </li><li>  Vous apprendrez briÃ¨vement comment optimiser votre requÃªte. </li></ul><a name="habracut"></a><br><h2>  Pourquoi devriez-vous apprendre SQL Ã  travailler avec des donnÃ©es? </h2><br>  SQL est loin d'Ãªtre mort: c'est l'une des compÃ©tences les plus recherchÃ©es que vous trouverez dans les descriptions de travail de l'industrie du traitement et de l'analyse des donnÃ©es, que vous postuliez pour l'analyse de donnÃ©es, l'ingÃ©nieur de donnÃ©es, le spÃ©cialiste des donnÃ©es ou tout autre rÃ´le.  Cela est confirmÃ© par 70% des rÃ©pondants Ã  l'enquÃªte sur les salaires O 'Reilly Data Science pour 2016, qui indiquent qu'ils utilisent SQL dans leur contexte professionnel.  De plus, dans cette enquÃªte, SQL se dÃ©marque des langages de programmation R (57%) et Python (54%). <br><br>  Vous obtenez l'image: SQL est une compÃ©tence nÃ©cessaire lorsque vous travaillez Ã  trouver un emploi dans l'industrie informatique. <br><br>  Pas mal pour un langage qui a Ã©tÃ© dÃ©veloppÃ© au dÃ©but des annÃ©es 1970, non? <br><br>  Mais pourquoi est-il si souvent utilisÃ©?  Et pourquoi n'est-il pas mort malgrÃ© le fait qu'il existe depuis si longtemps? <br><br>  Il existe plusieurs raisons: l'une des premiÃ¨res raisons pourrait Ãªtre que les entreprises stockent principalement des donnÃ©es dans des systÃ¨mes de gestion de bases de donnÃ©es relationnelles (RDBMS) ou dans des systÃ¨mes de gestion de flux de donnÃ©es relationnelles (RDSMS), et SQL est requis pour accÃ©der Ã  ces donnÃ©es.  SQL est une <i>lingua franca de</i> donnÃ©es: il permet d'interagir avec presque n'importe quelle base de donnÃ©es ou mÃªme de crÃ©er la vÃ´tre localement! <br><br>  Si cela ne suffit toujours pas, gardez Ã  l'esprit qu'il existe de nombreuses implÃ©mentations SQL qui sont incompatibles entre les fournisseurs et ne sont pas nÃ©cessairement conformes aux normes.  Par consÃ©quent, la connaissance du SQL standard est une exigence pour vous de trouver votre chemin dans l'industrie (informatique). <br><br>  De plus, il est sÃ»r de dire que de nouvelles technologies ont Ã©galement rejoint SQL, comme Hive, une interface de langage de requÃªte de type SQL pour interroger et gÃ©rer de grands ensembles de donnÃ©es, ou Spark SQL, qui peut Ãªtre utilisÃ© pour exÃ©cuter des requÃªtes SQL.  Encore une fois, le SQL que vous y trouverez sera diffÃ©rent du standard que vous pourriez apprendre, mais la courbe d'apprentissage sera beaucoup plus simple. <br><br>  Si vous voulez faire une comparaison, considÃ©rez-la comme l'apprentissage de l'algÃ¨bre linÃ©aire: aprÃ¨s avoir mis tous ces efforts dans ce sujet, vous savez que vous pouvez Ã©galement l'utiliser pour maÃ®triser l'apprentissage automatique! <br><br>  En bref, c'est pourquoi vous devriez apprendre ce langage de requÃªte: <br><br><ul><li>  Il est assez facile Ã  apprendre, mÃªme pour les dÃ©butants.  La courbe d'apprentissage est assez simple et progressive, vous Ã©crirez donc des requÃªtes dÃ¨s que possible. </li><li>  Il suit le principe Â«apprendre une fois, utiliser partoutÂ», c'est donc un excellent investissement de votre temps! </li><li>  C'est un excellent ajout aux langages de programmation;  Dans certains cas, l'Ã©criture d'une requÃªte est mÃªme prÃ©fÃ©rable Ã  l'Ã©criture de code, car elle est plus efficace! </li><li>  ... </li></ul><br>  Qu'attendez-vous encore?  :) <br><br><h2>  Traitement SQL et exÃ©cution de requÃªtes </h2><br>  Pour amÃ©liorer les performances de votre requÃªte SQL, vous devez d'abord savoir ce qui se passe Ã  l'intÃ©rieur lorsque vous cliquez sur un raccourci pour exÃ©cuter la requÃªte. <br><br>  Tout d'abord, la demande est analysÃ©e dans un arbre d'analyse;  La demande est analysÃ©e pour vÃ©rifier sa conformitÃ© aux exigences syntaxiques et sÃ©mantiques.  L'analyseur crÃ©e une reprÃ©sentation interne de la demande d'entrÃ©e.  Cette sortie est ensuite transfÃ©rÃ©e vers le mÃ©canisme de rÃ©Ã©criture. <br><br>  Ensuite, l'optimiseur doit trouver l'exÃ©cution ou le plan de requÃªte optimal pour la requÃªte donnÃ©e.  Le plan d'exÃ©cution dÃ©termine avec prÃ©cision quel algorithme est utilisÃ© pour chaque opÃ©ration et comment les opÃ©rations sont coordonnÃ©es. <br><br>  Pour trouver le plan d'exÃ©cution le plus optimal, l'optimiseur rÃ©pertorie tous les plans d'implÃ©mentation possibles, dÃ©termine la qualitÃ© ou le coÃ»t de chaque plan, reÃ§oit des informations sur l'Ã©tat actuel de la base de donnÃ©es, puis sÃ©lectionne les meilleurs d'entre eux comme plan d'implÃ©mentation final.  Les optimiseurs de requÃªte pouvant Ãªtre imparfaits, les utilisateurs et les administrateurs de base de donnÃ©es doivent parfois examiner et rÃ©gler manuellement les plans crÃ©Ã©s par l'optimiseur pour amÃ©liorer les performances. <br><br>  Maintenant, vous vous demandez probablement ce qui est considÃ©rÃ© comme un Â«bon plan de requÃªteÂ». <br><br>  Comme vous l'avez dÃ©jÃ  lu, la qualitÃ© du coÃ»t d'un plan joue un rÃ´le important.  Plus prÃ©cisÃ©ment, des Ã©lÃ©ments tels que le nombre d'E / S disque requis pour Ã©valuer le plan, le coÃ»t du processeur du plan et le temps de rÃ©ponse total que le client de base de donnÃ©es peut observer, et le temps d'exÃ©cution total, sont importants.  C'est lÃ  que le concept de complexitÃ© temporelle se pose.  Vous en apprendrez plus Ã  ce sujet plus tard. <br><br>  Ensuite, le plan de requÃªte sÃ©lectionnÃ© est exÃ©cutÃ©, Ã©valuÃ© par le mÃ©canisme d'exÃ©cution du systÃ¨me et les rÃ©sultats de la requÃªte sont renvoyÃ©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Ã‰criture de requÃªtes SQL </h2><br>  Il peut ne pas Ãªtre devenu clair Ã  partir de la section prÃ©cÃ©dente que le principe de Garbage In, Garbage Out (GIGO) se manifeste naturellement dans le processus de traitement et d'exÃ©cution d'une requÃªte: celui qui formule la requÃªte possÃ¨de Ã©galement des clÃ©s pour les performances de vos requÃªtes SQL.  Si l'optimiseur reÃ§oit une requÃªte mal formulÃ©e, il peut en faire autant ... <br><br>  Cela signifie que vous pouvez faire certaines choses lors de la rÃ©daction d'une demande.  Comme vous l'avez dÃ©jÃ  vu dans l'introduction, la responsabilitÃ© ici est double: il ne s'agit pas seulement d'Ã©crire des requÃªtes qui rÃ©pondent Ã  une certaine norme, mais aussi de collecter des idÃ©es sur les endroits oÃ¹ les problÃ¨mes de performances peuvent Ãªtre masquÃ©s dans votre requÃªte. <br><br>  Un point de dÃ©part idÃ©al est de penser Ã  des Â«endroitsÂ» dans vos requÃªtes oÃ¹ des problÃ¨mes peuvent survenir.  Et, en gÃ©nÃ©ral, il existe quatre mots clÃ©s dans lesquels les nouveaux arrivants peuvent s'attendre Ã  des problÃ¨mes de performances: <br><br><ul><li> Condition <code>WHERE</code> ; </li><li>  Tous les mots clÃ©s <code>INNER JOIN</code> ou <code>LEFT JOIN</code> ;  Et aussi </li><li>  <code>HAVING</code> Ã©tat; </li></ul><br>  Bien sÃ»r, cette approche est simple et naÃ¯ve, mais, pour un dÃ©butant, ces points sont d'excellents pointeurs, et il est sÃ»r de dire que lorsque vous commencez, des erreurs se produisent Ã  ces endroits et, curieusement, oÃ¹ il est Ã©galement difficile de les remarquer. <br><br>  Cependant, vous devez Ã©galement comprendre que la performance doit devenir significative.  Cependant, le simple fait de dire que ces phrases et mots clÃ©s sont mauvais n'est pas ce dont vous avez besoin lorsque vous pensez aux performances SQL.  Avoir une <code>WHERE</code> ou <code>HAVING</code> dans une requÃªte ne signifie pas nÃ©cessairement que c'est une mauvaise requÃªte ... <br><br>  Consultez la section suivante pour en savoir plus sur les antipatterns et les approches alternatives pour crÃ©er votre requÃªte.  Ces trucs et astuces sont destinÃ©s Ã  servir de guide.  Comment et si vous avez vraiment besoin de rÃ©Ã©crire votre demande dÃ©pend, entre autres choses, de la quantitÃ© de donnÃ©es, de la base de donnÃ©es et du nombre de fois que vous devez terminer la demande.  Cela dÃ©pend complÃ¨tement du but de votre demande et avoir une connaissance prÃ©alable de la base de donnÃ©es avec laquelle vous travaillerez est crucial! <br><br><h3>  1. RÃ©cupÃ©rez uniquement les donnÃ©es nÃ©cessaires </h3><br>  La conclusion Â«plus il y a de donnÃ©es, mieux c'estÂ» - ne doit pas Ãªtre suivie lors de l'Ã©criture de SQL: vous risquez non seulement de vous perdre en obtenant plus de donnÃ©es que vous n'en avez rÃ©ellement besoin, mais Ã©galement les performances peuvent souffrir car votre requÃªte reÃ§oit trop de donnÃ©es. <br><br>  C'est pourquoi, en rÃ¨gle gÃ©nÃ©rale, vous devez faire attention Ã  l' <code>SELECT</code> , Ã  la <code>SELECT</code> <code>DISTINCT</code> et Ã  l'instruction <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  La premiÃ¨re chose que vous pouvez dÃ©jÃ  vÃ©rifier lorsque vous Ã©crivez une requÃªte est de savoir si l' <code>SELECT</code> aussi compacte que possible.  L'objectif ici devrait Ãªtre de supprimer les colonnes inutiles de <code>SELECT</code> .  De cette faÃ§on, vous vous forcez Ã  ne rÃ©cupÃ©rer que les donnÃ©es correspondant Ã  votre requÃªte. <br><br>  Si vous avez corrÃ©lÃ© des sous-requÃªtes avec <code>EXISTS</code> , vous devez essayer d'utiliser une constante dans l' <code>SELECT</code> cette sous-requÃªte au lieu de choisir la valeur de la colonne rÃ©elle.  Ceci est particuliÃ¨rement pratique lorsque vous ne vÃ©rifiez que l'existence. <br><br>  <b>N'oubliez pas</b> qu'une sous-requÃªte corrÃ©lÃ©e est une sous-requÃªte qui utilise les valeurs d'une requÃªte externe.  Et notez que mÃªme si <code>NULL</code> peut fonctionner comme une Â«constanteÂ» dans ce contexte, c'est trÃ¨s dÃ©routant! <br><br>  ConsidÃ©rez l'exemple suivant pour comprendre ce que signifie l'utilisation d'une constante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Astuce: il est</b> utile de savoir qu'avoir une sous-requÃªte corrÃ©lÃ©e n'est pas toujours une bonne idÃ©e.  Vous pouvez toujours envisager de vous en dÃ©barrasser, par exemple, en les rÃ©Ã©crivant Ã  l'aide de <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  OpÃ©ration <code>DISTINCT</code> </h4><br>  L' <code>SELECT DISTINCT</code> utilisÃ©e pour renvoyer uniquement des valeurs diffÃ©rentes.  <code>DISTINCT</code> est un point Ã  Ã©viter si possible.  Comme dans d'autres exemples, le temps d'exÃ©cution augmente uniquement lorsque cette phrase est ajoutÃ©e Ã  la demande.  Par consÃ©quent, il est toujours utile de dÃ©terminer si vous avez vraiment besoin de cette opÃ©ration <code>DISTINCT</code> pour obtenir les rÃ©sultats que vous souhaitez obtenir. <br><br><h4>  <code>LIKE</code> </h4><br>  Lors de l'utilisation de l'opÃ©rateur <code>LIKE</code> dans une requÃªte, l'index n'est pas utilisÃ© si le modÃ¨le commence par <code>%</code> ou <code>_</code> .  Cela empÃªchera la base de donnÃ©es d'utiliser l'index (s'il en existe un).  Bien sÃ»r, d'un autre point de vue, on peut Ã©galement affirmer que ce type de demande laisse potentiellement la possibilitÃ© d'obtenir trop d'enregistrements qui ne rÃ©pondent pas nÃ©cessairement Ã  l'objet de la demande. <br><br>  Encore une fois, connaÃ®tre les donnÃ©es stockÃ©es dans la base de donnÃ©es peut vous aider Ã  formuler un modÃ¨le qui filtrera correctement toutes les donnÃ©es pour trouver uniquement les lignes qui sont vraiment importantes pour votre requÃªte. <br><br><h3>  2. Limitez vos rÃ©sultats </h3><br>  Si vous ne pouvez pas Ã©viter de filtrer votre <code>SELECT</code> , vous pouvez limiter vos rÃ©sultats d'autres maniÃ¨res.  C'est lÃ  qu'interviennent des approches telles que la <code>LIMIT</code> et les conversions de types de donnÃ©es. <br><br><h4>  <code>ROWNUM</code> <code>TOP</code> , <code>LIMIT</code> et <code>ROWNUM</code> </h4><br>  Vous pouvez ajouter des instructions <code>LIMIT</code> ou <code>TOP</code> aux requÃªtes pour spÃ©cifier le nombre maximal de lignes pour l'ensemble de rÃ©sultats.  Voici quelques exemples: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Notez que vous pouvez Ã©ventuellement spÃ©cifier <code>PERCENT</code> , par exemple, si vous modifiez la premiÃ¨re ligne de requÃªte avec <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Vous pouvez Ã©galement ajouter la <code>ROWNUM</code> Ã©quivalente Ã  l'utilisation de <code>LIMIT</code> dans la requÃªte: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Conversions de types de donnÃ©es </h4><br>  Les plus efficaces doivent toujours Ãªtre utilisÃ©s, c'est-Ã -dire  les plus petits types de donnÃ©es.  Il y a toujours un risque lorsque vous fournissez un type de donnÃ©es Ã©norme, tandis qu'un plus petit sera plus suffisant. <br><br>  Cependant, lors de l'ajout d'une conversion de type de donnÃ©es Ã  la requÃªte, seul le temps d'exÃ©cution augmente. <br><br>  Une alternative consiste Ã  Ã©viter autant que possible la conversion des types de donnÃ©es.  Veuillez Ã©galement noter qu'il n'est pas toujours possible de supprimer ou d'ignorer la conversion du type de donnÃ©es des requÃªtes, mais vous devez toujours vous efforcer de les inclure et vÃ©rifier l'effet de l'ajout avant d'exÃ©cuter la requÃªte. <br><br><h3>  3. Ne compliquez pas les requÃªtes qu'elles ne devraient l'Ãªtre </h3><br>  Les conversions de types de donnÃ©es vous amÃ¨nent au point suivant: vous ne devez pas trop concevoir vos requÃªtes.  Essayez de les rendre simples et efficaces.  Cela peut sembler trop simple ou stupide mÃªme pour Ãªtre un indice, principalement parce que les demandes peuvent Ãªtre complexes. <br><br>  Cependant, dans les exemples mentionnÃ©s dans les sections suivantes, vous verrez que vous pouvez facilement commencer Ã  rendre les requÃªtes simples plus complexes qu'elles ne devraient l'Ãªtre. <br><br><h4>  OpÃ©rateur <code>OR</code> </h4><br>  Lorsque vous utilisez l'opÃ©rateur <code>OR</code> dans votre requÃªte, vous n'utilisez probablement pas d'index. <br><br>  N'oubliez pas qu'un index est une structure de donnÃ©es qui amÃ©liore la vitesse de recherche des donnÃ©es dans une table de base de donnÃ©es, mais il est coÃ»teux: des enregistrements supplÃ©mentaires seront nÃ©cessaires et un espace de stockage supplÃ©mentaire sera nÃ©cessaire pour maintenir la structure des donnÃ©es d'index.  Les index sont utilisÃ©s pour rechercher ou rechercher rapidement des donnÃ©es sans avoir Ã  rechercher chaque ligne de la base de donnÃ©es Ã  chaque accÃ¨s Ã  la table de base de donnÃ©es.  Les index peuvent Ãªtre crÃ©Ã©s en utilisant une ou plusieurs colonnes dans une table de base de donnÃ©es. <br><br>  Si vous n'utilisez pas d'index inclus dans la base de donnÃ©es, l'exÃ©cution de votre requÃªte prendra inÃ©vitablement plus de temps.  C'est pourquoi il est prÃ©fÃ©rable de rechercher des alternatives Ã  l'utilisation de l'opÃ©rateur <code>OR</code> dans votre requÃªte; <br><br>  ConsidÃ©rez la requÃªte suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  L'opÃ©rateur peut Ãªtre remplacÃ© par: <br><br>  Condition avec <code>IN</code> ;  ou <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Deux <code>SELECT</code> avec <code>UNION</code> . <br><br>  <b>Astuce:</b> ici, vous devez faire attention Ã  ne pas utiliser l'opÃ©ration <code>UNION</code> inutile, car vous consultez plusieurs fois la mÃªme table.  En mÃªme temps, vous devez comprendre que lorsque vous utilisez <code>UNION</code> dans votre requÃªte, le temps d'exÃ©cution augmente.  Alternatives Ã  l'opÃ©ration <code>UNION</code> : reformulez la requÃªte afin que toutes les conditions soient placÃ©es dans une seule <code>SELECT</code> , ou utilisez <code>OUTER JOIN</code> au lieu d' <code>UNION</code> . <br><br>  <b>Astuce:</b> Gardez Ã  l'esprit que mÃªme si <code>OR</code> - et les autres opÃ©rateurs qui seront mentionnÃ©s dans les sections suivantes - n'utilisent probablement pas d'index, la recherche d'index n'est pas toujours prÃ©fÃ©rable! <br><br><h4>  <code>NOT</code> opÃ©rateur </h4><br>  Lorsque votre requÃªte contient un opÃ©rateur <code>NOT</code> , il est probable que l'index n'est pas utilisÃ©, comme avec l'opÃ©rateur <code>OR</code> .  Cela ralentira inÃ©vitablement votre demande.  Si vous ne savez pas ce que cela signifie ici, considÃ©rez la requÃªte suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Cette requÃªte s'exÃ©cutera certainement plus lentement que vous ne le pensez, principalement parce qu'elle est formulÃ©e beaucoup plus compliquÃ©e qu'elle ne peut l'Ãªtre: dans des cas comme celui-ci, il est prÃ©fÃ©rable de chercher une alternative.  Pensez Ã  remplacer <code>NOT</code> des opÃ©rateurs de comparaison tels que <code>&gt;</code> , <code>&lt;&gt;</code> ou <code>!&gt;</code> ;  L'exemple ci-dessus peut en fait Ãªtre rÃ©Ã©crit et ressembler Ã  ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Ã‡a a dÃ©jÃ  l'air mieux, non? <br><br><h4>  <code>AND</code> opÃ©rateur </h4><br>  L'opÃ©rateur <code>AND</code> est un autre opÃ©rateur qui n'utilise pas d'index et qui peut ralentir une requÃªte s'il est utilisÃ© de maniÃ¨re trop complexe et inefficace, comme dans l'exemple suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Il est prÃ©fÃ©rable de rÃ©Ã©crire cette requÃªte Ã  l'aide de l'instruction <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> et <code>ALL</code> opÃ©rateurs </h4><br>  De plus, les opÃ©rateurs <code>ANY</code> et <code>ALL</code> sont ceux avec lesquels vous devez faire attention, car si vous les incluez dans vos requÃªtes, l'index ne sera pas utilisÃ©.  Des fonctions d'agrÃ©gation alternatives telles que <code>MIN</code> ou <code>MAX</code> sont utiles ici. <br><br>  Conseil: dans les cas oÃ¹ vous utilisez les alternatives proposÃ©es, vous devez savoir que toutes les fonctions d'agrÃ©gation, telles que <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> sur plusieurs lignes, peuvent entraÃ®ner une longue requÃªte.  Dans de tels cas, vous pouvez essayer de minimiser le nombre de lignes Ã  traiter ou Ã  prÃ©-calculer ces valeurs.  Encore une fois, vous voyez qu'il est important de connaÃ®tre votre environnement, le but de votre demande, ... Lorsque vous dÃ©cidez quelle demande utiliser! <br><br><h4>  Isoler les colonnes dans des conditions </h4><br>  De plus, dans les cas oÃ¹ une colonne est utilisÃ©e dans un calcul ou dans une fonction scalaire, l'index n'est pas utilisÃ©.  Une solution possible serait de simplement sÃ©lectionner une colonne spÃ©cifique afin qu'elle ne fasse plus partie du calcul ou de la fonction.  Prenons l'exemple suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Ã‡a a l'air drÃ´le, hein?  Au lieu de cela, essayez de rÃ©viser le calcul et de rÃ©Ã©crire la requÃªte comme ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Manque de force brute </h3><br>  Cette derniÃ¨re astuce signifie que vous ne devriez pas essayer de limiter trop la demande, car cela peut affecter ses performances.  Cela est particuliÃ¨rement vrai pour les jointures et pour la clause HAVING. <br><br><h4>  Ordre des tables dans les jointures </h4><br>  Lors de la jonction de deux tables, il peut Ãªtre important de considÃ©rer l'ordre des tables dans la jointure.  Si vous voyez qu'une table est considÃ©rablement plus grande que l'autre, vous devrez peut-Ãªtre rÃ©Ã©crire la requÃªte afin que la plus grande table soit placÃ©e en dernier dans la jointure. <br><br><h4>  Conditions de connexion excessives </h4><br>  Si vous ajoutez trop de conditions aux connexions SQL, vous devez choisir un chemin spÃ©cifique.  Cependant, il se peut que ce chemin ne soit pas toujours plus efficace. <br><br><h4>  <code>HAVING</code> condition </h4><br>  La <code>HAVING</code> Ã©tÃ© ajoutÃ©e Ã  l'origine Ã  SQL car le mot clÃ© <code>WHERE</code> n'a pas pu Ãªtre utilisÃ© avec des fonctions d'agrÃ©gation.  <code>HAVING</code> gÃ©nÃ©ralement utilisÃ© avec la <code>GROUP BY</code> pour restreindre les groupes de lignes renvoyÃ©es Ã  celles qui remplissent certaines conditions.  Cependant, si cette condition est utilisÃ©e dans la requÃªte, l'index n'est pas utilisÃ©, ce qui, comme vous le savez dÃ©jÃ , peut conduire au fait que la requÃªte ne fonctionne pas si bien. <br><br>  Si vous recherchez une alternative, essayez d'utiliser la <code>WHERE</code> . <br><br>  Tenez compte des requÃªtes suivantes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  La premiÃ¨re requÃªte utilise la <code>WHERE</code> pour limiter le nombre de lignes qui doivent Ãªtre rÃ©sumÃ©es, tandis que la deuxiÃ¨me requÃªte additionne toutes les lignes de la table, puis utilise <code>HAVING</code> pour supprimer les montants calculÃ©s.  Dans de tels cas, l'option de <code>WHERE</code> est clairement meilleure car vous ne gaspillez pas de ressources. <br><br>  On peut voir qu'il ne s'agit pas de limiter l'ensemble de rÃ©sultats, mais de limiter le nombre intermÃ©diaire d'enregistrements dans la requÃªte. <br><br>  Il convient de noter que la diffÃ©rence entre les deux conditions est que la <code>WHERE</code> introduit une condition pour les lignes individuelles, tandis que la <code>HAVING</code> introduit une condition pour les agrÃ©gations ou les rÃ©sultats de sÃ©lection, oÃ¹ un rÃ©sultat, tel que <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... Ã©tait crÃ©Ã© Ã  partir de plusieurs lignes. <br><br>  Vous voyez, l'Ã©valuation de la qualitÃ©, l'Ã©criture et la rÃ©Ã©criture des demandes ne sont pas une tÃ¢che facile, Ã©tant donnÃ© qu'elles doivent Ãªtre aussi productives que possible;  La prÃ©vention des contre-modÃ¨les et la considÃ©ration d'options alternatives feront Ã©galement partie de la responsabilitÃ© lors de l'Ã©criture de requÃªtes devant Ãªtre effectuÃ©es sur des bases de donnÃ©es dans un environnement professionnel. <br><br>  Cette liste n'Ã©tait qu'un petit aperÃ§u de quelques antipatterns et astuces qui, je l'espÃ¨re, aideront les dÃ©butants;  Si vous voulez avoir une idÃ©e de ce que les dÃ©veloppeurs plus Ã¢gÃ©s considÃ¨rent comme les anti-patterns les plus courants, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette discussion</a> . <br><br><h2>  Approches basÃ©es sur des ensembles ou procÃ©durales pour Ã©crire des requÃªtes </h2><br>  Les antipatterns susmentionnÃ©s impliquent qu'ils se rÃ©sument en fait Ã  une diffÃ©rence dans les approches basÃ©es sur des ensembles et procÃ©durales pour construire vos requÃªtes. <br><br>  L'approche procÃ©durale des requÃªtes est une approche trÃ¨s similaire Ã  la programmation: vous dites au systÃ¨me quoi faire et comment le faire. <br><br>  Un exemple de ceci est les conditions excessives dans les connexions ou les cas oÃ¹ vous <code>HAVING</code> conditions <code>HAVING</code> , comme dans les exemples ci-dessus, dans lesquels vous interrogez une base de donnÃ©es en exÃ©cutant une fonction puis en appelant une autre fonction, ou vous utilisez une logique qui contient des conditions, des boucles, des fonctions dÃ©finies par l'utilisateur ( UDF), curseurs, ... pour obtenir le rÃ©sultat final.  Avec cette approche, vous demanderez souvent un sous-ensemble de donnÃ©es, puis un autre sous-ensemble de donnÃ©es, etc. <br><br>  Sans surprise, cette approche est souvent appelÃ©e une requÃªte Â«Ã©tape par Ã©tapeÂ» ou Â«ligne par ligneÂ». <br><br>  Une autre approche est une approche basÃ©e sur un ensemble, oÃ¹ vous indiquez simplement quoi faire.  Votre rÃ´le consiste Ã  spÃ©cifier les conditions ou exigences pour l'ensemble de rÃ©sultats que vous souhaitez recevoir de la requÃªte.  Vous laissez la faÃ§on dont vos donnÃ©es sont rÃ©cupÃ©rÃ©es aux mÃ©canismes internes qui dÃ©terminent la mise en Å“uvre de la requÃªte: vous laissez le moteur de base de donnÃ©es dÃ©terminer les meilleurs algorithmes ou logique de traitement pour exÃ©cuter votre requÃªte. <br><br>  Ã‰tant donnÃ© que SQL est basÃ© sur un ensemble, il n'est pas surprenant que cette approche soit plus efficace que procÃ©durale, et cela explique Ã©galement pourquoi, dans certains cas, SQL peut s'exÃ©cuter plus rapidement que le code. <br><br>  <b>Le conseil est une</b> approche basÃ©e sur un ensemble d'interrogations. C'est aussi celle que la plupart des grands employeurs de l'industrie des technologies de l'information vous demanderont de maÃ®triser!  Il est souvent nÃ©cessaire de basculer entre ces deux types d'approches. <br><br>  <b>Veuillez noter</b> que si vous avez besoin d'une demande procÃ©durale, vous devriez envisager de la rÃ©Ã©crire ou de la refactoriser. <br><br>  La partie suivante couvrira l'optimisation du plan et des requÃªtes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465547/">https://habr.com/ru/post/fr465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465535/index.html">Qui implÃ©mente IPv6 et ce qui entrave son dÃ©veloppement</a></li>
<li><a href="../fr465537/index.html">Yandex: une maison intelligente pour adultes</a></li>
<li><a href="../fr465539/index.html">766 km - un nouveau record d'autonomie pour LoRaWAN</a></li>
<li><a href="../fr465541/index.html">De l'entreprise Ã  la PME: nous partageons notre expÃ©rience dans l'adaptation de solutions d'entreprise pour les petites et moyennes entreprises avec la monÃ©tisation en utilisant le modÃ¨le SaaS</a></li>
<li><a href="../fr465545/index.html">De diffÃ©rents cÃ´tÃ©s de l'Ã‰tat: comment Facebook a Ã©tÃ© frit au CongrÃ¨s amÃ©ricain, tandis que Telegram se battait avec le FSB</a></li>
<li><a href="../fr465551/index.html">RÃ©sumÃ© des Ã©vÃ©nements informatiques de septembre (premiÃ¨re partie)</a></li>
<li><a href="../fr465553/index.html">Langage de programmation Ãœ. Introduction, motivation pour crÃ©er, objectifs</a></li>
<li><a href="../fr465555/index.html">12 compÃ©tences gÃ©nÃ©rales qui rendent les chefs de projet informatiques imparables</a></li>
<li><a href="../fr465557/index.html">DÃ©lais de dÃ©veloppement de produits</a></li>
<li><a href="../fr465561/index.html">Ce que j'ai appris d'un grand programmeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>