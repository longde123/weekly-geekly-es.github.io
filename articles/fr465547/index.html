<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💹 🏫 📼 Guide SQL: comment mieux écrire des requêtes (partie 1) 👏🏽 🤳🏼 👋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En savoir plus sur les antipatterns, les plans d'exécution, la complexité temporelle, le réglage des requêtes et l'optimisation SQL 
 Le langage de re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide SQL: comment mieux écrire des requêtes (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  En savoir plus sur les antipatterns, les plans d'exécution, la complexité temporelle, le réglage des requêtes et l'optimisation SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Le langage de requête structuré (SQL) est une compétence indispensable dans l'industrie informatique et, d'une manière générale, l'apprentissage de cette compétence est relativement simple.  Cependant, la plupart des gens oublient que SQL ne consiste pas seulement à écrire des requêtes, c'est juste la première étape sur la route.  Garantir les performances des requêtes ou faire correspondre le contexte dans lequel vous travaillez est une tout autre chose. <br><br>  C'est pourquoi ce guide SQL vous fournira un petit aperçu de certaines des étapes que vous pouvez suivre pour évaluer votre requête: <br><br><ul><li>  Tout d'abord, vous commencerez par un bref aperçu de l'importance de l'apprentissage SQL pour travailler dans le domaine de la science des données; </li><li>  Ensuite, vous apprendrez d'abord comment traiter et exécuter des requêtes SQL afin de comprendre l'importance de créer des requêtes de qualité.  Plus précisément, vous verrez que la demande est analysée, réécrite, optimisée et finalement évaluée. </li><li>  Dans cet esprit, vous irez non seulement à quelques antipatterns de requêtes que les débutants font lors de l'écriture de requêtes, mais vous en apprendrez également plus sur les alternatives et les solutions à ces erreurs possibles;  De plus, vous en apprendrez davantage sur l'approche de requête basée sur un ensemble. </li><li>  Vous verrez également que ces antipatterns découlent de problèmes de performances et qu'en plus de l'approche «manuelle» pour améliorer les requêtes SQL, vous pouvez analyser vos requêtes de manière plus structurée et approfondie, en utilisant d'autres outils qui vous aident à voir le plan de requête;  Et </li><li>  Vous apprendrez brièvement la complexité du temps et la notation O, pour avoir une idée de la complexité du plan d'exécution à temps avant d'exécuter la demande; </li><li>  Vous apprendrez brièvement comment optimiser votre requête. </li></ul><a name="habracut"></a><br><h2>  Pourquoi devriez-vous apprendre SQL à travailler avec des données? </h2><br>  SQL est loin d'être mort: c'est l'une des compétences les plus recherchées que vous trouverez dans les descriptions de travail de l'industrie du traitement et de l'analyse des données, que vous postuliez pour l'analyse de données, l'ingénieur de données, le spécialiste des données ou tout autre rôle.  Cela est confirmé par 70% des répondants à l'enquête sur les salaires O 'Reilly Data Science pour 2016, qui indiquent qu'ils utilisent SQL dans leur contexte professionnel.  De plus, dans cette enquête, SQL se démarque des langages de programmation R (57%) et Python (54%). <br><br>  Vous obtenez l'image: SQL est une compétence nécessaire lorsque vous travaillez à trouver un emploi dans l'industrie informatique. <br><br>  Pas mal pour un langage qui a été développé au début des années 1970, non? <br><br>  Mais pourquoi est-il si souvent utilisé?  Et pourquoi n'est-il pas mort malgré le fait qu'il existe depuis si longtemps? <br><br>  Il existe plusieurs raisons: l'une des premières raisons pourrait être que les entreprises stockent principalement des données dans des systèmes de gestion de bases de données relationnelles (RDBMS) ou dans des systèmes de gestion de flux de données relationnelles (RDSMS), et SQL est requis pour accéder à ces données.  SQL est une <i>lingua franca de</i> données: il permet d'interagir avec presque n'importe quelle base de données ou même de créer la vôtre localement! <br><br>  Si cela ne suffit toujours pas, gardez à l'esprit qu'il existe de nombreuses implémentations SQL qui sont incompatibles entre les fournisseurs et ne sont pas nécessairement conformes aux normes.  Par conséquent, la connaissance du SQL standard est une exigence pour vous de trouver votre chemin dans l'industrie (informatique). <br><br>  De plus, il est sûr de dire que de nouvelles technologies ont également rejoint SQL, comme Hive, une interface de langage de requête de type SQL pour interroger et gérer de grands ensembles de données, ou Spark SQL, qui peut être utilisé pour exécuter des requêtes SQL.  Encore une fois, le SQL que vous y trouverez sera différent du standard que vous pourriez apprendre, mais la courbe d'apprentissage sera beaucoup plus simple. <br><br>  Si vous voulez faire une comparaison, considérez-la comme l'apprentissage de l'algèbre linéaire: après avoir mis tous ces efforts dans ce sujet, vous savez que vous pouvez également l'utiliser pour maîtriser l'apprentissage automatique! <br><br>  En bref, c'est pourquoi vous devriez apprendre ce langage de requête: <br><br><ul><li>  Il est assez facile à apprendre, même pour les débutants.  La courbe d'apprentissage est assez simple et progressive, vous écrirez donc des requêtes dès que possible. </li><li>  Il suit le principe «apprendre une fois, utiliser partout», c'est donc un excellent investissement de votre temps! </li><li>  C'est un excellent ajout aux langages de programmation;  Dans certains cas, l'écriture d'une requête est même préférable à l'écriture de code, car elle est plus efficace! </li><li>  ... </li></ul><br>  Qu'attendez-vous encore?  :) <br><br><h2>  Traitement SQL et exécution de requêtes </h2><br>  Pour améliorer les performances de votre requête SQL, vous devez d'abord savoir ce qui se passe à l'intérieur lorsque vous cliquez sur un raccourci pour exécuter la requête. <br><br>  Tout d'abord, la demande est analysée dans un arbre d'analyse;  La demande est analysée pour vérifier sa conformité aux exigences syntaxiques et sémantiques.  L'analyseur crée une représentation interne de la demande d'entrée.  Cette sortie est ensuite transférée vers le mécanisme de réécriture. <br><br>  Ensuite, l'optimiseur doit trouver l'exécution ou le plan de requête optimal pour la requête donnée.  Le plan d'exécution détermine avec précision quel algorithme est utilisé pour chaque opération et comment les opérations sont coordonnées. <br><br>  Pour trouver le plan d'exécution le plus optimal, l'optimiseur répertorie tous les plans d'implémentation possibles, détermine la qualité ou le coût de chaque plan, reçoit des informations sur l'état actuel de la base de données, puis sélectionne les meilleurs d'entre eux comme plan d'implémentation final.  Les optimiseurs de requête pouvant être imparfaits, les utilisateurs et les administrateurs de base de données doivent parfois examiner et régler manuellement les plans créés par l'optimiseur pour améliorer les performances. <br><br>  Maintenant, vous vous demandez probablement ce qui est considéré comme un «bon plan de requête». <br><br>  Comme vous l'avez déjà lu, la qualité du coût d'un plan joue un rôle important.  Plus précisément, des éléments tels que le nombre d'E / S disque requis pour évaluer le plan, le coût du processeur du plan et le temps de réponse total que le client de base de données peut observer, et le temps d'exécution total, sont importants.  C'est là que le concept de complexité temporelle se pose.  Vous en apprendrez plus à ce sujet plus tard. <br><br>  Ensuite, le plan de requête sélectionné est exécuté, évalué par le mécanisme d'exécution du système et les résultats de la requête sont renvoyés. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Écriture de requêtes SQL </h2><br>  Il peut ne pas être devenu clair à partir de la section précédente que le principe de Garbage In, Garbage Out (GIGO) se manifeste naturellement dans le processus de traitement et d'exécution d'une requête: celui qui formule la requête possède également des clés pour les performances de vos requêtes SQL.  Si l'optimiseur reçoit une requête mal formulée, il peut en faire autant ... <br><br>  Cela signifie que vous pouvez faire certaines choses lors de la rédaction d'une demande.  Comme vous l'avez déjà vu dans l'introduction, la responsabilité ici est double: il ne s'agit pas seulement d'écrire des requêtes qui répondent à une certaine norme, mais aussi de collecter des idées sur les endroits où les problèmes de performances peuvent être masqués dans votre requête. <br><br>  Un point de départ idéal est de penser à des «endroits» dans vos requêtes où des problèmes peuvent survenir.  Et, en général, il existe quatre mots clés dans lesquels les nouveaux arrivants peuvent s'attendre à des problèmes de performances: <br><br><ul><li> Condition <code>WHERE</code> ; </li><li>  Tous les mots clés <code>INNER JOIN</code> ou <code>LEFT JOIN</code> ;  Et aussi </li><li>  <code>HAVING</code> état; </li></ul><br>  Bien sûr, cette approche est simple et naïve, mais, pour un débutant, ces points sont d'excellents pointeurs, et il est sûr de dire que lorsque vous commencez, des erreurs se produisent à ces endroits et, curieusement, où il est également difficile de les remarquer. <br><br>  Cependant, vous devez également comprendre que la performance doit devenir significative.  Cependant, le simple fait de dire que ces phrases et mots clés sont mauvais n'est pas ce dont vous avez besoin lorsque vous pensez aux performances SQL.  Avoir une <code>WHERE</code> ou <code>HAVING</code> dans une requête ne signifie pas nécessairement que c'est une mauvaise requête ... <br><br>  Consultez la section suivante pour en savoir plus sur les antipatterns et les approches alternatives pour créer votre requête.  Ces trucs et astuces sont destinés à servir de guide.  Comment et si vous avez vraiment besoin de réécrire votre demande dépend, entre autres choses, de la quantité de données, de la base de données et du nombre de fois que vous devez terminer la demande.  Cela dépend complètement du but de votre demande et avoir une connaissance préalable de la base de données avec laquelle vous travaillerez est crucial! <br><br><h3>  1. Récupérez uniquement les données nécessaires </h3><br>  La conclusion «plus il y a de données, mieux c'est» - ne doit pas être suivie lors de l'écriture de SQL: vous risquez non seulement de vous perdre en obtenant plus de données que vous n'en avez réellement besoin, mais également les performances peuvent souffrir car votre requête reçoit trop de données. <br><br>  C'est pourquoi, en règle générale, vous devez faire attention à l' <code>SELECT</code> , à la <code>SELECT</code> <code>DISTINCT</code> et à l'instruction <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  La première chose que vous pouvez déjà vérifier lorsque vous écrivez une requête est de savoir si l' <code>SELECT</code> aussi compacte que possible.  L'objectif ici devrait être de supprimer les colonnes inutiles de <code>SELECT</code> .  De cette façon, vous vous forcez à ne récupérer que les données correspondant à votre requête. <br><br>  Si vous avez corrélé des sous-requêtes avec <code>EXISTS</code> , vous devez essayer d'utiliser une constante dans l' <code>SELECT</code> cette sous-requête au lieu de choisir la valeur de la colonne réelle.  Ceci est particulièrement pratique lorsque vous ne vérifiez que l'existence. <br><br>  <b>N'oubliez pas</b> qu'une sous-requête corrélée est une sous-requête qui utilise les valeurs d'une requête externe.  Et notez que même si <code>NULL</code> peut fonctionner comme une «constante» dans ce contexte, c'est très déroutant! <br><br>  Considérez l'exemple suivant pour comprendre ce que signifie l'utilisation d'une constante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Astuce: il est</b> utile de savoir qu'avoir une sous-requête corrélée n'est pas toujours une bonne idée.  Vous pouvez toujours envisager de vous en débarrasser, par exemple, en les réécrivant à l'aide de <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Opération <code>DISTINCT</code> </h4><br>  L' <code>SELECT DISTINCT</code> utilisée pour renvoyer uniquement des valeurs différentes.  <code>DISTINCT</code> est un point à éviter si possible.  Comme dans d'autres exemples, le temps d'exécution augmente uniquement lorsque cette phrase est ajoutée à la demande.  Par conséquent, il est toujours utile de déterminer si vous avez vraiment besoin de cette opération <code>DISTINCT</code> pour obtenir les résultats que vous souhaitez obtenir. <br><br><h4>  <code>LIKE</code> </h4><br>  Lors de l'utilisation de l'opérateur <code>LIKE</code> dans une requête, l'index n'est pas utilisé si le modèle commence par <code>%</code> ou <code>_</code> .  Cela empêchera la base de données d'utiliser l'index (s'il en existe un).  Bien sûr, d'un autre point de vue, on peut également affirmer que ce type de demande laisse potentiellement la possibilité d'obtenir trop d'enregistrements qui ne répondent pas nécessairement à l'objet de la demande. <br><br>  Encore une fois, connaître les données stockées dans la base de données peut vous aider à formuler un modèle qui filtrera correctement toutes les données pour trouver uniquement les lignes qui sont vraiment importantes pour votre requête. <br><br><h3>  2. Limitez vos résultats </h3><br>  Si vous ne pouvez pas éviter de filtrer votre <code>SELECT</code> , vous pouvez limiter vos résultats d'autres manières.  C'est là qu'interviennent des approches telles que la <code>LIMIT</code> et les conversions de types de données. <br><br><h4>  <code>ROWNUM</code> <code>TOP</code> , <code>LIMIT</code> et <code>ROWNUM</code> </h4><br>  Vous pouvez ajouter des instructions <code>LIMIT</code> ou <code>TOP</code> aux requêtes pour spécifier le nombre maximal de lignes pour l'ensemble de résultats.  Voici quelques exemples: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Notez que vous pouvez éventuellement spécifier <code>PERCENT</code> , par exemple, si vous modifiez la première ligne de requête avec <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Vous pouvez également ajouter la <code>ROWNUM</code> équivalente à l'utilisation de <code>LIMIT</code> dans la requête: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Conversions de types de données </h4><br>  Les plus efficaces doivent toujours être utilisés, c'est-à-dire  les plus petits types de données.  Il y a toujours un risque lorsque vous fournissez un type de données énorme, tandis qu'un plus petit sera plus suffisant. <br><br>  Cependant, lors de l'ajout d'une conversion de type de données à la requête, seul le temps d'exécution augmente. <br><br>  Une alternative consiste à éviter autant que possible la conversion des types de données.  Veuillez également noter qu'il n'est pas toujours possible de supprimer ou d'ignorer la conversion du type de données des requêtes, mais vous devez toujours vous efforcer de les inclure et vérifier l'effet de l'ajout avant d'exécuter la requête. <br><br><h3>  3. Ne compliquez pas les requêtes qu'elles ne devraient l'être </h3><br>  Les conversions de types de données vous amènent au point suivant: vous ne devez pas trop concevoir vos requêtes.  Essayez de les rendre simples et efficaces.  Cela peut sembler trop simple ou stupide même pour être un indice, principalement parce que les demandes peuvent être complexes. <br><br>  Cependant, dans les exemples mentionnés dans les sections suivantes, vous verrez que vous pouvez facilement commencer à rendre les requêtes simples plus complexes qu'elles ne devraient l'être. <br><br><h4>  Opérateur <code>OR</code> </h4><br>  Lorsque vous utilisez l'opérateur <code>OR</code> dans votre requête, vous n'utilisez probablement pas d'index. <br><br>  N'oubliez pas qu'un index est une structure de données qui améliore la vitesse de recherche des données dans une table de base de données, mais il est coûteux: des enregistrements supplémentaires seront nécessaires et un espace de stockage supplémentaire sera nécessaire pour maintenir la structure des données d'index.  Les index sont utilisés pour rechercher ou rechercher rapidement des données sans avoir à rechercher chaque ligne de la base de données à chaque accès à la table de base de données.  Les index peuvent être créés en utilisant une ou plusieurs colonnes dans une table de base de données. <br><br>  Si vous n'utilisez pas d'index inclus dans la base de données, l'exécution de votre requête prendra inévitablement plus de temps.  C'est pourquoi il est préférable de rechercher des alternatives à l'utilisation de l'opérateur <code>OR</code> dans votre requête; <br><br>  Considérez la requête suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  L'opérateur peut être remplacé par: <br><br>  Condition avec <code>IN</code> ;  ou <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Deux <code>SELECT</code> avec <code>UNION</code> . <br><br>  <b>Astuce:</b> ici, vous devez faire attention à ne pas utiliser l'opération <code>UNION</code> inutile, car vous consultez plusieurs fois la même table.  En même temps, vous devez comprendre que lorsque vous utilisez <code>UNION</code> dans votre requête, le temps d'exécution augmente.  Alternatives à l'opération <code>UNION</code> : reformulez la requête afin que toutes les conditions soient placées dans une seule <code>SELECT</code> , ou utilisez <code>OUTER JOIN</code> au lieu d' <code>UNION</code> . <br><br>  <b>Astuce:</b> Gardez à l'esprit que même si <code>OR</code> - et les autres opérateurs qui seront mentionnés dans les sections suivantes - n'utilisent probablement pas d'index, la recherche d'index n'est pas toujours préférable! <br><br><h4>  <code>NOT</code> opérateur </h4><br>  Lorsque votre requête contient un opérateur <code>NOT</code> , il est probable que l'index n'est pas utilisé, comme avec l'opérateur <code>OR</code> .  Cela ralentira inévitablement votre demande.  Si vous ne savez pas ce que cela signifie ici, considérez la requête suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Cette requête s'exécutera certainement plus lentement que vous ne le pensez, principalement parce qu'elle est formulée beaucoup plus compliquée qu'elle ne peut l'être: dans des cas comme celui-ci, il est préférable de chercher une alternative.  Pensez à remplacer <code>NOT</code> des opérateurs de comparaison tels que <code>&gt;</code> , <code>&lt;&gt;</code> ou <code>!&gt;</code> ;  L'exemple ci-dessus peut en fait être réécrit et ressembler à ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Ça a déjà l'air mieux, non? <br><br><h4>  <code>AND</code> opérateur </h4><br>  L'opérateur <code>AND</code> est un autre opérateur qui n'utilise pas d'index et qui peut ralentir une requête s'il est utilisé de manière trop complexe et inefficace, comme dans l'exemple suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Il est préférable de réécrire cette requête à l'aide de l'instruction <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> et <code>ALL</code> opérateurs </h4><br>  De plus, les opérateurs <code>ANY</code> et <code>ALL</code> sont ceux avec lesquels vous devez faire attention, car si vous les incluez dans vos requêtes, l'index ne sera pas utilisé.  Des fonctions d'agrégation alternatives telles que <code>MIN</code> ou <code>MAX</code> sont utiles ici. <br><br>  Conseil: dans les cas où vous utilisez les alternatives proposées, vous devez savoir que toutes les fonctions d'agrégation, telles que <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> sur plusieurs lignes, peuvent entraîner une longue requête.  Dans de tels cas, vous pouvez essayer de minimiser le nombre de lignes à traiter ou à pré-calculer ces valeurs.  Encore une fois, vous voyez qu'il est important de connaître votre environnement, le but de votre demande, ... Lorsque vous décidez quelle demande utiliser! <br><br><h4>  Isoler les colonnes dans des conditions </h4><br>  De plus, dans les cas où une colonne est utilisée dans un calcul ou dans une fonction scalaire, l'index n'est pas utilisé.  Une solution possible serait de simplement sélectionner une colonne spécifique afin qu'elle ne fasse plus partie du calcul ou de la fonction.  Prenons l'exemple suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Ça a l'air drôle, hein?  Au lieu de cela, essayez de réviser le calcul et de réécrire la requête comme ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Manque de force brute </h3><br>  Cette dernière astuce signifie que vous ne devriez pas essayer de limiter trop la demande, car cela peut affecter ses performances.  Cela est particulièrement vrai pour les jointures et pour la clause HAVING. <br><br><h4>  Ordre des tables dans les jointures </h4><br>  Lors de la jonction de deux tables, il peut être important de considérer l'ordre des tables dans la jointure.  Si vous voyez qu'une table est considérablement plus grande que l'autre, vous devrez peut-être réécrire la requête afin que la plus grande table soit placée en dernier dans la jointure. <br><br><h4>  Conditions de connexion excessives </h4><br>  Si vous ajoutez trop de conditions aux connexions SQL, vous devez choisir un chemin spécifique.  Cependant, il se peut que ce chemin ne soit pas toujours plus efficace. <br><br><h4>  <code>HAVING</code> condition </h4><br>  La <code>HAVING</code> été ajoutée à l'origine à SQL car le mot clé <code>WHERE</code> n'a pas pu être utilisé avec des fonctions d'agrégation.  <code>HAVING</code> généralement utilisé avec la <code>GROUP BY</code> pour restreindre les groupes de lignes renvoyées à celles qui remplissent certaines conditions.  Cependant, si cette condition est utilisée dans la requête, l'index n'est pas utilisé, ce qui, comme vous le savez déjà, peut conduire au fait que la requête ne fonctionne pas si bien. <br><br>  Si vous recherchez une alternative, essayez d'utiliser la <code>WHERE</code> . <br><br>  Tenez compte des requêtes suivantes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  La première requête utilise la <code>WHERE</code> pour limiter le nombre de lignes qui doivent être résumées, tandis que la deuxième requête additionne toutes les lignes de la table, puis utilise <code>HAVING</code> pour supprimer les montants calculés.  Dans de tels cas, l'option de <code>WHERE</code> est clairement meilleure car vous ne gaspillez pas de ressources. <br><br>  On peut voir qu'il ne s'agit pas de limiter l'ensemble de résultats, mais de limiter le nombre intermédiaire d'enregistrements dans la requête. <br><br>  Il convient de noter que la différence entre les deux conditions est que la <code>WHERE</code> introduit une condition pour les lignes individuelles, tandis que la <code>HAVING</code> introduit une condition pour les agrégations ou les résultats de sélection, où un résultat, tel que <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... était créé à partir de plusieurs lignes. <br><br>  Vous voyez, l'évaluation de la qualité, l'écriture et la réécriture des demandes ne sont pas une tâche facile, étant donné qu'elles doivent être aussi productives que possible;  La prévention des contre-modèles et la considération d'options alternatives feront également partie de la responsabilité lors de l'écriture de requêtes devant être effectuées sur des bases de données dans un environnement professionnel. <br><br>  Cette liste n'était qu'un petit aperçu de quelques antipatterns et astuces qui, je l'espère, aideront les débutants;  Si vous voulez avoir une idée de ce que les développeurs plus âgés considèrent comme les anti-patterns les plus courants, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette discussion</a> . <br><br><h2>  Approches basées sur des ensembles ou procédurales pour écrire des requêtes </h2><br>  Les antipatterns susmentionnés impliquent qu'ils se résument en fait à une différence dans les approches basées sur des ensembles et procédurales pour construire vos requêtes. <br><br>  L'approche procédurale des requêtes est une approche très similaire à la programmation: vous dites au système quoi faire et comment le faire. <br><br>  Un exemple de ceci est les conditions excessives dans les connexions ou les cas où vous <code>HAVING</code> conditions <code>HAVING</code> , comme dans les exemples ci-dessus, dans lesquels vous interrogez une base de données en exécutant une fonction puis en appelant une autre fonction, ou vous utilisez une logique qui contient des conditions, des boucles, des fonctions définies par l'utilisateur ( UDF), curseurs, ... pour obtenir le résultat final.  Avec cette approche, vous demanderez souvent un sous-ensemble de données, puis un autre sous-ensemble de données, etc. <br><br>  Sans surprise, cette approche est souvent appelée une requête «étape par étape» ou «ligne par ligne». <br><br>  Une autre approche est une approche basée sur un ensemble, où vous indiquez simplement quoi faire.  Votre rôle consiste à spécifier les conditions ou exigences pour l'ensemble de résultats que vous souhaitez recevoir de la requête.  Vous laissez la façon dont vos données sont récupérées aux mécanismes internes qui déterminent la mise en œuvre de la requête: vous laissez le moteur de base de données déterminer les meilleurs algorithmes ou logique de traitement pour exécuter votre requête. <br><br>  Étant donné que SQL est basé sur un ensemble, il n'est pas surprenant que cette approche soit plus efficace que procédurale, et cela explique également pourquoi, dans certains cas, SQL peut s'exécuter plus rapidement que le code. <br><br>  <b>Le conseil est une</b> approche basée sur un ensemble d'interrogations. C'est aussi celle que la plupart des grands employeurs de l'industrie des technologies de l'information vous demanderont de maîtriser!  Il est souvent nécessaire de basculer entre ces deux types d'approches. <br><br>  <b>Veuillez noter</b> que si vous avez besoin d'une demande procédurale, vous devriez envisager de la réécrire ou de la refactoriser. <br><br>  La partie suivante couvrira l'optimisation du plan et des requêtes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465547/">https://habr.com/ru/post/fr465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465535/index.html">Qui implémente IPv6 et ce qui entrave son développement</a></li>
<li><a href="../fr465537/index.html">Yandex: une maison intelligente pour adultes</a></li>
<li><a href="../fr465539/index.html">766 km - un nouveau record d'autonomie pour LoRaWAN</a></li>
<li><a href="../fr465541/index.html">De l'entreprise à la PME: nous partageons notre expérience dans l'adaptation de solutions d'entreprise pour les petites et moyennes entreprises avec la monétisation en utilisant le modèle SaaS</a></li>
<li><a href="../fr465545/index.html">De différents côtés de l'État: comment Facebook a été frit au Congrès américain, tandis que Telegram se battait avec le FSB</a></li>
<li><a href="../fr465551/index.html">Résumé des événements informatiques de septembre (première partie)</a></li>
<li><a href="../fr465553/index.html">Langage de programmation Ü. Introduction, motivation pour créer, objectifs</a></li>
<li><a href="../fr465555/index.html">12 compétences générales qui rendent les chefs de projet informatiques imparables</a></li>
<li><a href="../fr465557/index.html">Délais de développement de produits</a></li>
<li><a href="../fr465561/index.html">Ce que j'ai appris d'un grand programmeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>