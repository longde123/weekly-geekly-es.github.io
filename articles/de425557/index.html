<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌯 🍒 ✡️ MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 1 🤴🏻 🦗 👨‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425557/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: „Woher kommen Sicherheitssysteme?“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: „Chancen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: „Native Client Sandbox“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 8: „Netzwerksicherheitsmodell“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 9: „Sicherheit von Webanwendungen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 10: „Symbolische Ausführung“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Guten Morgen allerseits, ich bin Armando Solar-Lesam und heute werde ich einen Vortrag über symbolische Leistung halten.  Wer unter den hier Anwesenden kennt diesen Begriff oder hat schon einmal davon gehört?  Ich möchte nur eine Vorstellung von unserem Publikum bekommen.  Also fangen wir an.  Ich habe meinen Laptop mehrmals fallen lassen, daher dauert das Laden sehr lange. <br><br><img src="https://habrastorage.org/webt/t1/d0/ik/t1d0ikzwlt1dcgcg-1ifxfv-z3w.jpeg"><br><br>  Die symbolische Ausführung ist das Arbeitstier der modernen Programmanalyse.  Dies ist eine der Methoden, die aus der Forschung hervorgegangen sind und dann in vielen Anwendungen eingesetzt wurden.  Zum Beispiel gibt es heute bei Microsoft ein System namens SAGE, das mit vielen wichtigen Microsoft-Programmen zusammenarbeitet, die von Power Point bis Windows selbst reichen, um Sicherheitsprobleme und Schwachstellen wirklich zu finden. <br><br>  Es gibt viele akademische Projekte, die einen großen Einfluss auf die reale Welt hatten, z. B. das Erkennen wichtiger Fehler in Open Source-Software mithilfe symbolischer Ausführung.  Das Schöne an der symbolischen Ausführung als Technik ist, dass Sie sich im Vergleich zum Testen vorstellen können, wie sich Ihr Programm mit einem möglicherweise endlosen Satz möglicher Eingabedaten verhält.  Dies ermöglicht es uns, Arrays von Eingabedaten zu untersuchen, die völlig unpraktisch und unpraktisch wären, um sie beispielsweise durch zufällige Tests zu untersuchen, selbst wenn es eine sehr große Anzahl von Testern gibt.  Andererseits hat es im Vergleich zu herkömmlichen Methoden der statischen Analyse den folgenden Vorteil.  Bei der Untersuchung eines Problems kann die symbolische Ausführung Eingabe und Ablaufverfolgung erstellen, einen Ausführungspfad, der in einem realen Programm ausgeführt werden kann und dieses Programm basierend auf dieser Eingabe ausführt.  Danach können wir den eigentlichen Fehler identifizieren und ihn mithilfe traditioneller Debugging-Mechanismen beheben.  Dies ist besonders wertvoll, wenn Sie sich in einer industriellen Entwicklungsumgebung befinden, in der Sie wahrscheinlich nicht die Zeit haben, sich um jedes kleine Problem in Ihrem Code zu kümmern. <br><br>  Zum Beispiel möchten Sie wirklich in der Lage sein, zwischen echten Problemen und falsch positiven Ergebnissen zu unterscheiden.  Wie funktioniert das? <br><br>  Um wirklich zu verstehen, wie dies funktioniert, ist es hilfreich, mit der normalen Ausführung zu beginnen.  Wenn wir die symbolische Ausführung als eine Verallgemeinerung der traditionellen, einfachen Ausführung betrachten, ist es sinnvoll zu wissen, wie sie aussieht.  Daher werde ich dieses sehr einfache Programm als Illustration für viele Dinge verwenden, über die wir heute sprechen werden. <br><br><img src="https://habrastorage.org/webt/1-/rv/gy/1-rvgymnpffellnl2jnb55j790i.jpeg"><br><br>  Hier haben wir einen Auszug aus einem sehr einfachen Code aus mehreren Zweigen und die Aussage, dass dies eine falsche Aussage ist, wenn unter bestimmten Bedingungen der Wert t &lt;x ist.  Wir wollen herausfinden, ob diese Aussage jemals erhoben werden kann.  Das ist möglich?  Gibt es Eingaben, die dazu führen, dass diese Anweisung fehlschlägt? <br><br>  Eines der Dinge, die ich tun kann, ist, die Ausführung dieses Programms anhand bestimmter Werte von Eingabedaten als Beispiel zu überprüfen.  Angenommen, wir verwenden Eingaben, für die X = 4 und Y = 4. Der Wert von T ist Null, wie zu Beginn des Programms angekündigt. <br><br>  Bevor wir zur normalen Ausführung kommen, wollen wir herausfinden, worauf es hier ankommt.  Wir müssen eine Vorstellung vom Stand des Programms haben, oder?  Unabhängig davon, ob wir eine normale Ausführung oder eine symbolische Ausführung durchführen, müssen wir eine Möglichkeit haben, den Status des Programms zu charakterisieren.  In diesem Fall ist es ein so einfaches Programm, dass es den Heap nicht verwendet, den Stapel nicht verwendet und es hier keine Funktionsaufrufe gibt. <br><br>  Somit kann der Zustand vollständig durch diese drei Variablen charakterisiert werden, zusammen mit dem Wissen, wo ich mich im Programm befinde.  Wenn ich also die Ausführung von 4, 4 und 0 beginne und zum Ende des Zweigs komme, überprüfe ich den Ausdruck: 4 ist größer als 4?  Offensichtlich nicht. <br>  Jetzt werde ich das Programm bei T = Y ausführen, dh T ist nicht mehr 0, sondern hat den Wert 4. Dies ist der aktuelle Status meines Programms, und jetzt kann ich diesen Zweig auswerten. <br><br><img src="https://habrastorage.org/webt/xw/j1/pb/xwj1pbkpvyvv3vc_b3urir5ob-g.jpeg"><br><br>  Stimmt es, dass T &lt;X ist?  Nein.  Wir sind der Kugel ausgewichen, die Aussage false hat nicht funktioniert.  Es gab keine Probleme bei dieser privaten Ausführung. <br><br>  Dies sagt jedoch nichts über eine andere Ausführung aus.  Wir wissen, dass mit den Werten X = 4 und Y = 4 das Programm nicht fehlschlägt.  Dies sagt jedoch nichts darüber aus, was passieren wird, wenn die Eingabewerte 2 und 1 sind. <br><br><img src="https://habrastorage.org/webt/8w/lv/vf/8wlvvfh7n43vvl2jaajhjd2opcy.jpeg"><br><br>  Mit diesen Eingabewerten geht die Ausführung anders.  Diesmal sehen wir, dass T = X ist, und nach dem Ausführen dieser Zeile nimmt T einen Wert gleich 2 an. Gibt es Probleme bei dieser Ausführung?  Wird es bei einer solchen Eingabe einen Assertionsfehler geben? <br><br>  Nun, mal sehen.  Wenn also T 2 und X 2 ist, dann ist T nicht weniger als X. Es scheint, dass wir der Kugel erneut ausgewichen sind.  Richtig?  Hier haben wir also zwei spezifische Eingabewerte, bei denen das Programm fehlerfrei arbeitet.  Tatsächlich sagt es uns jedoch nichts über andere Eingabewerte aus. <br><br>  Die Idee der symbolischen Ausführung ist also, dass wir über die Ausführung eines Programms mit einem Satz von Eingabedaten hinausgehen möchten.  Wir möchten in der Lage sein, tatsächlich über das Verhalten des Programms zu sprechen, wenn ein sehr großer Datensatz verwendet wird, in einigen Fällen eine unendliche Anzahl möglicher Eingabewerte.  Die Hauptidee davon ist wie folgt. <br><br><img src="https://habrastorage.org/webt/wn/k5/fs/wnk5fs-evom1hqqeh8vnpppxezk.jpeg"><br><br>  Für ein Programm wie dieses wird sein Zustand durch den Wert dieser drei verschiedenen Variablen bestimmt: X, Y und T und durch das Wissen, wo ich mich gerade im Programm befinde.  Aber jetzt werde ich anstelle der spezifischen Werte für X und Y einen symbolischen Wert haben, nur eine Variable.  Eine Variable, mit der ich diesen Wert benennen kann, den der Benutzer als Eingabe verwendet.  Dies bedeutet, dass der Status meines Programms nicht mehr dadurch gekennzeichnet ist, dass Variablennamen bestimmten Werten zugeordnet werden.  Dies ist nun eine Zuordnung von Variablennamen zu diesen symbolischen Werten. <br><br>  Der symbolische Wert kann als Formel betrachtet werden.  In diesem Fall ist die Formel für X gleich X und die Formel für Y ist einfach Y, und für T ist sie tatsächlich gleich 0. Wir wissen, dass es für jeden Eingabewert keine Rolle spielt, was Sie tun.  Der Wert von T nach der ersten Anweisung ist 0. <br><br>  Dort wird es jetzt interessant.  Wir sind zu diesem Zweig gekommen, der besagt, dass wir in eine Richtung gehen, wenn X größer als Y ist.  Wenn X kleiner oder gleich Y ist, gehen wir in die andere Richtung. <br><br>  Wissen wir etwas über X und Y?  Was wissen wir über sie?  Zumindest kennen wir ihren Typ, wir wissen, dass sie von min int bis max int variieren werden, aber das ist alles, was wir über sie wissen.  Es stellt sich heraus, dass die Informationen, die wir über sie wissen, nicht ausreichen, um zu sagen, in welche Richtung dieser Zweig gehen kann.  Sie kann in jede Richtung gehen <br>  Es gibt viele Dinge, die wir tun können, aber was können wir im Moment tun?  Versuchen Sie, die wildesten Vermutungen anzustellen. <br><br><img src="https://habrastorage.org/webt/eu/a9/c-/eua9c-jo64thlkjghlaj3e9x6rs.jpeg"><br><br>  <b>Zielgruppe:</b> Wir können die Ausführung des Programms in beiden Zweigen verfolgen. <br><br>  <b>Professor:</b> Ja, wir können die Fortschritte in beiden Bereichen verfolgen.  Wirf eine Münze und wähle je nachdem, wie sie fällt, den einen oder anderen Zweig. <br><br>  Wenn wir also beiden Zweigen folgen wollen, müssen wir zuerst dem einen und dann dem anderen folgen, oder?  Angenommen, wir beginnen mit diesem Zweig - T = X.  Wir wissen, dass T an diesem Ort die gleiche Bedeutung wie X hat. Wir wissen nicht, was dieser Wert ist, aber wir haben einen Namen dafür - dies ist das Skript X. <br><br><img src="https://habrastorage.org/webt/2l/zy/mx/2lzymxorfsurzuz_bjon1hr4kdi.jpeg"><br><br>  Wenn wir den entgegengesetzten Zweig nehmen, was wird dann passieren?  Der Wert von T wird gleich etwas anderem sein, oder?  In diesem Zweig ist der Wert von T der symbolische Wert von Y. <br><br><img src="https://habrastorage.org/webt/q9/e6/fw/q9e6fwx1kg2llxhp3ci7rfzvwym.jpeg"><br><br>  Was bedeutet dieser T-Wert, wenn wir an diesem Punkt im Programm angelangt sind?  Vielleicht ist es X, vielleicht ist es Y. Wir wissen nicht genau, was dieser Wert ist, aber warum geben wir ihm keinen Namen?  Nennen Sie es t <sub>0</sub> .  Und was wissen wir über t <sub>0</sub> ?  In welchen Fällen ist t <sub>0</sub> gleich X? <br><br>  Im Wesentlichen wissen wir, dass wenn X größer als Y ist, die Variable gleich X ist und wenn X kleiner oder gleich Y ist, dann ist die Variable gleich Y. Daher haben wir einen Wert, den wir definiert haben, nennen wir ihn t <sub>0</sub> , und er hat diese logische Eigenschaften. <br><br><img src="https://habrastorage.org/webt/6l/ux/93/6lux93kqkmnz63fjddelibxu3ma.jpeg"><br><br>  An diesem Punkt im Programm haben wir also einen Namen für den Wert von T, dies ist t <sub>0</sub> .  Was haben wir hier gemacht?  Wir haben beide Zweige der if-Anweisung genommen und dann den symbolischen Wert berechnet, um zu sehen, unter welchen Bedingungen ein Zweig des Programms ausgeführt wird und unter welchen der andere. <br>  Nun kommt es zu dem Punkt, dass wir fragen sollten, ob T kleiner als X sein kann. Jetzt ist der Wert von T t <sub>0</sub> , und wir wollen wissen, ob es möglich ist, dass t <sub>0</sub> kleiner als X ist?  Erinnern Sie sich an den ersten Zweig, den wir untersucht haben - wir haben eine Frage zu X und Y gestellt und wussten nichts über sie, außer dass sie vom Typ int waren. <br><br>  Aber mit t <sub>0</sub> wissen wir wirklich viel darüber.  Wir wissen, dass es in einigen Fällen gleich X und in einigen Fällen gleich Y sein wird. Jetzt gibt es uns eine Reihe von Gleichungen, die wir lösen können.  Wir können also sagen, ob es möglich ist, dass t <sub>0</sub> kleiner als X ist, wenn wir wissen, dass t <sub>0</sub> alle diese Bedingungen erfüllt?  Wir können dies also als Einschränkung ausdrücken und zeigen, ob es möglich ist, dass t <sub>0</sub> kleiner als X ist. Und wenn X größer als Y ist, dann ist t <sub>0</sub> gleich X, und wenn X kleiner als oder gleich Y ist, bedeutet dies, dass t <sub>0</sub> = ist Y. Y. <br><br><img src="https://habrastorage.org/webt/kw/go/1p/kwgo1pvhy86moreg7j9vnwlybsi.jpeg"><br><br>  Wir haben also eine Gleichung.  Wenn es eine Lösung gibt, wenn es möglich ist, den Wert von t <sub>0</sub> , den Wert von X und den Wert von Y zu finden, die diese Gleichung erfüllen, dann erkennen wir diese Werte, und wenn wir sie in das Programm eingeben, dann geht es bei Ausführung entlang dieses Zweigs, wenn t &lt;x und " wird explodieren “, wenn es in die Behauptung falsch fällt. <br><br>  Was haben wir hier gemacht?  Wir haben das Programm ausgeführt, aber anstatt Variablennamen bestimmten Werten zuzuordnen, haben wir diesen Variablennamen symbolische Werte gegeben.  Tatsächlich gaben sie ihnen andere Variablennamen.  In diesem Fall sind unsere anderen Variablennamen Skript X, Skript Y, t <sub>0</sub> , und außerdem haben wir eine Reihe von Gleichungen, die zeigen, wie diese Werte zusammenhängen.  Wir haben eine Gleichung, die uns sagt, wie t <sub>0</sub> in diesem Fall mit X und Y zusammenhängt. <br><br>  Die Lösung dieser Gleichung ermöglicht es uns, die Frage zu beantworten, ob dieser Zweig ausgeführt werden kann oder nicht.  Schauen Sie sich die Gleichung an - ist es möglich, diesen Zweig zu nehmen oder nicht?  Es scheint nicht so, weil wir nach Fällen suchen, in denen t <sub>0</sub> kleiner als X ist, aber wenn in der ersten Bedingung t <sub>0</sub> = X ist, dann ist der Ausdruck t <sub>0</sub> &lt;X nicht wahr. <br><br>  Dies bedeutet also, dass wenn X&gt; Y ist, dies nicht passieren kann, weil t <sub>0</sub> = X ist und es nicht gleichzeitig gleich oder kleiner als X sein kann. <br><br>  Aber was passiert, wenn t <sub>0</sub> = Y ist?  Kann t <sub>0</sub> in diesem Fall kleiner als X sein? <br><br>  Nein, das kann es definitiv nicht, weil wir wissen, dass X &lt;Y ist. Wenn also t <sub>0</sub> kleiner als X ist, dann ist es auch kleiner als Y. Aber wir wissen, dass in diesem Fall t <sub>0</sub> = Y. Und daher wieder kann diese Bedingung nicht erfüllt werden.  Hier haben wir also eine Gleichung, die keine Lösung hat, und es spielt keine Rolle, welche Werte Sie in diese Gleichung aufnehmen. <br><br>  Sie können es nicht lösen, und dies sagt uns, dass unabhängig davon, welche Eingabe X und Y wir an das Programm übergeben, es nicht den Zweig hinuntergeht, wenn t &lt;x ist. <br><br>  Beachten Sie nun, dass ich bei der Erstellung dieses Arguments hier im Grunde auf Ihre Intuition über Ganzzahlen, über mathematische Ganzzahlen hingewiesen habe.  In der Praxis wissen wir, dass sich Maschinen-Ints nicht genau wie mathematische Ints verhalten.  Es gibt Fälle, in denen die Gesetze für mathematische ganzzahlige Datentypen nicht auf programmatische Ints anwendbar sind. <br><br>  Daher müssen wir beim Lösen dieser Gleichungen sehr vorsichtig sein, da wir uns daran erinnern müssen, dass dies nicht die ganzen Zahlen sind, über die uns in der Grundschule berichtet wurde.  Dies sind die 32-Bit-Ganzzahlen, die von der Maschine verwendet werden.  Und es gibt viele Fälle von Fehlern, die aufgetreten sind, weil Programmierer über ihren Code in mathematischen Ganzzahlen nachgedacht haben und nicht erkannt haben, dass es Dinge wie Überläufe gibt, die ein anderes Programmverhalten für die mathematische Eingabe verursachen können. <br><br>  Eine andere Sache, die ich hier beschrieben habe, ist ein rein intuitives Argument.  Ich werde Sie durch den Prozess führen und zeigen, wie man es manuell macht, aber dies ist keineswegs ein Algorithmus.  Das Schöne an dieser Idee der symbolischen Ausführung ist jedoch, dass sie in einen Algorithmus codiert werden kann.  Und Sie können es mechanisch lösen, was es Ihnen ermöglicht, dies nicht nur für ein 10-Zeilen-Programm, sondern für Millionen von Programmen zu tun.  Auf diese Weise können wir dieselbe intuitive Argumentation verwenden, die wir in diesem Fall verwendet haben, und darüber sprechen, was passiert, wenn wir dieses Programm mit unterschiedlichen Eingabewerten ausführen.  Diese Überlegungen können skaliert und auf sehr große Programme ausgedehnt werden. <br><br><img src="https://habrastorage.org/webt/b0/of/jr/b0ofjrqh-vesxglsfrxpikk8yb0.jpeg"><br><br>  <b>Zielgruppe:</b> Was ist, wenn das Programm die Eingabe eines bestimmten Variablentyps nicht unterstützt? <br><br>  <b>Professor:</b> Das ist eine sehr gute Frage!  Angenommen, wir haben das gleiche Programm, aber anstelle von t = x haben wir t = (x-1).  Dann können wir uns intuitiv vorstellen, dass dieses Programm jetzt „explodieren“ kann, oder? <br><br><img src="https://habrastorage.org/webt/_k/sk/9v/_ksk9vik_mk_xno9mkjqkvoli3k.jpeg"><br><br>  Denn wenn das Programm so läuft, ist t wirklich kleiner als x.  Was wird mit einem solchen Programm passieren?  Wie wird unser symbolischer Zustand aussehen?  Was ist t <sub>0,</sub> wenn x größer als y ist?  Wir korrigieren die Linien in unseren Gleichungen gemäß einem anderen Wert, wenn t = (x-1).  Jetzt kann das Programm fehlschlagen, und Sie gehen zum Entwickler und sagen ihm: "Hey, diese Funktion kann explodieren, wenn x größer als y ist"! <br><br>  Der Entwickler sieht sich das an und sagt: „Oh, ich habe vergessen, es Ihnen zu sagen - tatsächlich wird diese Funktion niemals mit Parametern aufgerufen, bei denen x größer als y ist.  "Ich habe es nur aus historischen Gründen geschrieben, also mach dir keine Sorgen, ich würde mich nicht daran erinnern, wenn du es mir nicht gesagt hättest." <br><br>  Angenommen, wir gehen davon aus, dass x kleiner oder gleich y ist. <br><br><img src="https://habrastorage.org/webt/il/iu/un/iliuunmfbjyqdw1dxw7ugemm0go.jpeg"><br><br>  Dies ist eine Voraussetzung oder Vereinbarung für unsere Funktion.  Die Funktion verspricht, etwas zu tun, aber nur, wenn der Wert diese Annahme erfüllt.  Wenn es jedoch nicht zufrieden ist, heißt es in der Funktion: "Es ist mir egal, was passiert.  Ich verspreche, dass es nur dann keinen Fehler geben wird, wenn diese Annahme erfüllt ist. " <br><br>  Wie codieren wir diese Einschränkung, wenn wir die Gleichungen lösen?  Im Wesentlichen haben wir eine Reihe von Einschränkungen, die uns sagen, ob dieser Zweig machbar ist.  Zusätzlich zu den Einschränkungen müssen wir auch sicherstellen, dass die Voraussetzung oder Annahme erfüllt ist. <br><br>  Die Frage ist, kann ich x und y finden, die all diese Einschränkungen erfüllen und gleichzeitig die erforderlichen Eigenschaften besitzen?  Sie können sehen, dass diese Einschränkung X ≤ Y die Differenz zwischen dem Fall darstellt, in dem diese Einschränkung erfüllt ist, und dem Fall, in dem sie nicht erfüllt ist. <br><br>  Dies ist ein sehr wichtiges Thema bei der Arbeit mit Analysen, insbesondere wenn Sie dies gleichzeitig auf der Ebene einzelner Funktionen tun möchten.  Es ist ratsam zu wissen, was der Programmierer beim Schreiben dieser Funktion im Sinn hatte.  Wenn Sie keine Ahnung von diesen Annahmen haben, denken Sie möglicherweise, dass das Programm fehlschlägt. <br><br>  Wie geht das mechanisch?  Dieses Problem hat zwei Aspekte.  Aspekt Nummer eins - wie sind Sie auf diese Formeln gekommen? <br><br>  In diesem Fall ist intuitiv klar, wie wir zu diesen Formeln gekommen sind. Wir haben sie einfach manuell zusammengestellt.  Aber wie werden diese Formeln mechanisch erstellt? <br><br>  Und der zweite Aspekt - wie lösen Sie diese Formeln, nachdem Sie sie haben?  Ist es möglich, diese Formeln zu lösen, die beschreiben, ob Ihr Programm abstürzt oder nicht? <br>  Beginnen wir mit der zweiten Frage.  Wir können unser Problem mit diesen Formeln reduzieren, die ganzzahliges Denken und Bitvektoren enthalten.  Beim Erstellen von Programmen kümmern Sie sich um Arrays, Funktionen und erhalten dadurch riesige Formeln.  Ist es möglich, sie mechanisch zu lösen? <br><br><img src="https://habrastorage.org/webt/fb/wg/mp/fbwgmprqfh03wmz73pz3s5cfrv0.jpeg"><br><br>  Die vielen Technologien, über die wir heute sprechen, sind praktische Werkzeuge im Zusammenhang mit den enormen Fortschritten bei der Entwicklung von Lösern für logische Fragen.  Insbesondere gibt es eine sehr wichtige Klasse von Lösern, die als SMT oder "Lösbarkeitslöser modularer Theorien" bezeichnet wird.  SMT-Löser ist die Lösbarkeit logischer Formeln unter Berücksichtigung der ihnen zugrunde liegenden Theorien. <br><br>  Viele Leute behaupten, dass dieser Name nicht besonders gut ist, aber er wurde als der am häufigsten verwendete festgelegt. <br><br>  SMT-Solver ist ein Algorithmus, aufgrund dessen diese logische Formel am Ausgang Ihnen eine von zwei Optionen bietet: Entweder erfüllt er seinen Zweck oder er erfüllt nicht.   ,        ,     . <br><br>         .   ,    SMT,  NP- ,      «»  «». <br>     ,           NP- ?     -,    ?   ,    SMT –       : «  ». <br><br><img src="https://habrastorage.org/webt/wp/se/q9/wpseq9oqvluas4nkjsstzagwpva.jpeg"><br><br>         , ,        ,    ,   : «  ».      ,           ,        . <br><br> 27:30  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> MIT «  ».  10: « »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s bis Dezember kostenlos,</b> wenn Sie für einen Zeitraum von sechs Monaten bezahlen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> bestellen. <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425557/">https://habr.com/ru/post/de425557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425547/index.html">Qt: Zeichnung basierend auf Vektorgrafiken</a></li>
<li><a href="../de425549/index.html">Supermicro-Aktien stürzen bei der Untersuchung des Einsatzes chinesischer Spionagechips ab</a></li>
<li><a href="../de425551/index.html">Wer sollte Geld aus dem Verkauf eines von AI geschaffenen Kunstwerks erhalten?</a></li>
<li><a href="../de425553/index.html">Was der Graf von Monte Cristo über Cybersicherheit sagen kann</a></li>
<li><a href="../de425555/index.html">Charles Nutter über dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425559/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 3</a></li>
<li><a href="../de425561/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 2</a></li>
<li><a href="../de425563/index.html">Kalifornien verbietet den Verkauf von IoT-Geräten mit oder ohne einfache Passwörter</a></li>
<li><a href="../de425565/index.html">Schnelle Festkomma-Mathematik für Finanzanwendungen in Java</a></li>
<li><a href="../de425569/index.html">PCB-Funktionstests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>