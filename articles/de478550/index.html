<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüç≥ üç¥ üöº Wie verwalte ich eine Uhr? Analyse der Front-End-Strecke der zweiten Programmiermeisterschaft üñäÔ∏è üèº üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein neuer Habrapost in einer Reihe von Analysen der j√ºngsten Meisterschaft. Qualifikationsteilnehmer, die sich f√ºr den Frontend-Bereich entschieden ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie verwalte ich eine Uhr? Analyse der Front-End-Strecke der zweiten Programmiermeisterschaft</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478550/"><img src="https://habrastorage.org/webt/4e/n2/ks/4en2ksorc6zfdwcwfcvsceozmxg.jpeg" width="300" align="right">  Ein neuer Habrapost in einer Reihe von Analysen der j√ºngsten Meisterschaft.  Qualifikationsteilnehmer, die sich f√ºr den Frontend-Bereich entschieden hatten, mussten mehrere Aufgaben unterschiedlichster Komplexit√§t l√∂sen: Die erste (nach unseren Erwartungen) dauerte 20 Minuten, die letzte etwa eine Stunde.  Wir haben eine breite Palette von Entwicklerf√§higkeiten f√ºr Benutzeroberfl√§chen getestet, einschlie√ülich der F√§higkeit, ein ungew√∂hnliches Fachgebiet zu verstehen. <br><br><h2>  A. Vernichte es </h2>  <sup><i>Autoren: Maxim Sysoev, Konstantin Petryaev</i></sup> <br><br>  Die erste Aufgabe ist das Aufw√§rmen.  Jeder Teilnehmer hat eine von vier Optionen f√ºr die Aufgabe, die einander √§hnlich sind.  Wir schlugen nicht nur eine Textbedingung vor, sondern auch eine ‚Äûschlechte‚Äú rekursive L√∂sung.  Es war notwendig, den Code zu wiederholen (einen gierigen Algorithmus zu schreiben, der die schnellste L√∂sung hervorbrachte), Rekursion und verschiedene Unsinn wie unn√∂tige Operationen und Berechnungen zu entfernen. <br><br><h4>  Zustand </h4><br>  Sie haben einen Job in einem Labor f√ºr die Untersuchung von Antimaterie, wo sie verschiedene Experimente durchf√ºhren.  Ihre Abteilung untersucht die Prozesse, die beim Kombinieren von Materie und Antimaterie auftreten.  Sie m√ºssen eine Reihe von Experimenten mit einer bestimmten Anzahl von Molek√ºlen durchf√ºhren. <br><a name="habracut"></a><br>  Die benachbarte Abteilung hat einen Apparat entwickelt, der Materie f√ºr kurze Zeit in Antimaterie verwandelt.  Es wird Ihnen bei der Durchf√ºhrung von Experimenten n√ºtzlich sein, bei denen der folgende Algorithmus verwendet wird: <br><br>  - Wir finden 2 der schwersten Molek√ºle. <br>  - Wir verwandeln einen in Antimaterie. <br>  - Kombiniere sie.  Dar√ºber hinaus werden sie vernichtet, wenn das Gewicht gleich ist.  Wenn das Gewicht unterschiedlich ist, erhalten wir ein neues Molek√ºl, dessen Gewicht gleich dem Gewichtsunterschied der beiden vorherigen ist.  Das resultierende Molek√ºl selbst ist Materie. <br>  - Wenn noch ein Molek√ºl √ºbrig ist, m√ºssen Sie dessen Gewicht herausfinden.  Wenn es viele Molek√ºle gibt, kehren wir zu Schritt 1 zur√ºck. <br><br>  Sie m√ºssen das Molek√ºl herausfinden, dessen Gewicht am Ende des Experiments verbleibt. Dieses Wissen wird von Wissenschaftlern einer anderen Abteilung ben√∂tigt. <br><br>  Der vorherige Entwickler skizzierte den Code, der an diesen Berechnungen beteiligt war, aber der Code kann die Berechnungen nicht beenden, wenn das Experiment mit einer gro√üen Anzahl von Molek√ºlen durchgef√ºhrt wird.  Sie m√ºssen den Code verfeinern, damit er in angemessener Zeit funktioniert. <br><br>  <b>Code, der an Sie vererbt wurde</b> <br><br>  Als Eingabe erhalten Sie ein Array mit Molekulargewichten.  Als Ausgabe m√ºssen Sie eine Zahl zur√ºckgeben, die das Gewicht des letzten Molek√ºls angibt.  Wenn keine Molek√ºle mehr vorhanden sind, muss 0 zur√ºckgegeben werden. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights, i = weights.length - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cur = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = (weights[i] === weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i] - weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findLatestWeight(weights, i - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Beispiel und Notizen</b> <div class="spoiler_text"><h4>  Beispiel </h4><br>  Eintritt: [2,7,4,1,8,1] <br>  Ausgang: 1 <br><br>  Wir nehmen Molek√ºle mit einem Gewicht von 7 und 8, verwandeln 7 in ein Antimolek√ºl und kollidieren mit einem Molek√ºl mit Gewicht 8. Es bleibt ein Molek√ºl mit Gewicht 1. Das Gewicht der verbleibenden Stahlmolek√ºle [2,4,1,1,1].  Wir nehmen Molek√ºle mit einem Gewicht von 2 und 4, verwandeln 2 in ein Antimolek√ºl und kollidieren mit einem Molek√ºl mit Gewicht 4. Es bleibt ein Molek√ºl mit Gewicht 2. Das Gewicht der verbleibenden Stahlmolek√ºle [2,1,1,1].  Wir nehmen Molek√ºle mit einem Gewicht von 2 und 1, verwandeln 1 in ein Antimolek√ºl und kollidieren mit einem Molek√ºl mit Gewicht 2. Es bleibt ein Molek√ºl mit Gewicht 1. Das Gewicht der verbleibenden Stahlmolek√ºle [1,1,1].  Wir nehmen Molek√ºle mit einem Gewicht von 1 und 1, machen aus einem ein Antimolek√ºl und kollidieren mit dem zweiten.  Sie werden vernichtet.  Das Gewicht der verbleibenden Molek√ºle [1].  Ein Molek√ºl √ºbrig.  Das Ergebnis ist 1. <br><br><h4>  Hinweise </h4><br>  Stellen Sie als L√∂sung eine Datei bereit, die die korrigierte Version der Funktion findLatestWeight exportiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLatestWeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } module.exports = findLatestWeight;</span></span></code> </pre> <br>  Die L√∂sung wird in Node.js 12 ausgef√ºhrt. <br></div></div><br><h4>  L√∂sung </h4><br>  Die bereitgestellte "schlechte" L√∂sung hat mehrere Probleme gleichzeitig.  Der erste ist die Rekursion.  Wie in der Bedingung angegeben, verarbeiten wir gro√üe Anordnungen von Zahlen, wodurch eine rekursive L√∂sung sofort beseitigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; i--; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Die Erweiterung der Rekursion ist hier recht einfach, es tritt jedoch ein weiteres Problem auf: Es wird st√§ndig neu sortiert (von klein nach gro√ü) und mit dem Ende des Arrays gearbeitet.  Als Ergebnis erhalten wir eine Abnahme des vorletzten Elements im Array.  Aber danach schneiden wir das Array nicht zu und wenn ein Array von einer Million Elementen an die Funktion √ºbergeben wurde, werden wir es bis zum Ende neu sortieren. <br><br>  Eine M√∂glichkeit, dieses Problem zu l√∂sen, besteht darin, das Array st√§ndig zu trimmen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; weights.length = i; <span class="hljs-comment"><span class="hljs-comment">// &lt;---   i--; } while (true); }</span></span></code> </pre> <br>  Nicht schlecht, aber wir m√ºssen auch das Sortieren loswerden, was an sich eine teure Operation ist.  Im Gro√üen und Ganzen werden wir uns zu jeder Zeit f√ºr die 2 gr√∂√üten Mitglieder des Arrays interessieren.  Das hei√üt, es ist eine Suche nach zwei H√∂hen, die ganz einfach in einem Durchgang durchgef√ºhrt wird.  Der Einfachheit halber f√ºhren wir eine solche Suche in einer separaten Funktion durch. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maximumTwo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1 = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2 = arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1I = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2I = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) { max2 = arr[i]; max2I = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { max1 = arr[i]; max1I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max2) { max2 = arr[i]; max2I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max2, max1, max2I, max1I]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max1, max2, max1I, max2I]; };</code> </pre> <br>  Und wir √§ndern die Suchfunktion wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weights.length &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [x, y, xI, yI] = maximumTwo(weights); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } weights[xI] = <span class="hljs-number"><span class="hljs-number">0</span></span>; weights[yI] = y - x; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); };</code> </pre> <br>  Daher werden wir immer das kleinere der beiden Elemente auf Null setzen und das gr√∂√üere in den Unterschied zwischen ihnen umwandeln.  Wir haben die Sortierung aufgegeben und stattdessen einen linearen Durchgang erhalten. <br><br>  Von den bekannten Fehlern nahmen die Teilnehmer das maximale Element, multiplizierten es mit ‚Äì1 und addierten es zum zweitgr√∂√üten Stein.  Das Ergebnis ist eine negative Zahl, die dann in der Ist-Berechnung verwendet wurde.  Dar√ºber hinaus hat die Aufgabe eine mentale Falle, die damit verbunden ist, dass Sie versuchen k√∂nnen, Steine ‚Äã‚Äãmit einem einzigartigen Gewicht zu belassen und die Differenz daraus zu berechnen.  Dieser Ansatz liefert jedoch nicht das richtige Ergebnis. <br><br><h2>  B. BEM </h2>  <sup><i>Autoren: Eugene Mishchenko, Vladimir Grinenko <a href="https://habr.com/ru/users/tadatuta/" class="user_link">tadatuta</a></i></sup> <br><br><h4>  Zustand </h4><br>  Layout Alexander ist an vielen Projekten mit der BEM-Methodik beteiligt.  Er hat sogar ein praktisches Plugin f√ºr seine Lieblings-IDE erstellt, mit dem er Klassennamen in einer Kurznotation schreiben und vollst√§ndig bereitstellen kann.  Das Problem ist jedoch, dass f√ºr jedes Projekt unterschiedliche Trennzeichen zwischen Block, Element und Modifikator (block__mod__val - elem, block - mod - val ___ elem) festgelegt werden und jedes Mal, wenn er dies manuell in seinem Plugin bearbeiten muss.  Helfen Sie Alexander, ein Modul zu schreiben, das das Trennzeichen f√ºr Entit√§ten basierend auf der Klasse bestimmt.  Die Regel f√ºr Trennzeichen ist eine beliebige Anzahl von Zeichen (keine Buchstaben).  Beispiele f√ºr m√∂gliche Notationen (Modifikatoren f√ºr einen Block in den Eingabedaten k√∂nnen ohne Wert sein): <br><br><pre> <code class="javascript hljs">block_mod__elem <span class="hljs-comment"><span class="hljs-comment">// ,     block_mod_mod__elem block__elem_mod_mod</span></span></code> </pre><br>  Erl√§uterungen: <br>  - Klassen in Projekten werden nur in Kleinbuchstaben geschrieben. <br>  - Ein String mit einer g√ºltigen CSS-Klasse wird dem Eingang des Moduls zugef√ºhrt. <br><br>  Das Modul sollte eine Antwort des Formulars zur√ºckgeben: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">mod</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    elem: "__", //    }</span></span></code> </pre> <br>  Das Modul muss als commonJS-Modul ausgegeben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br><h4>  L√∂sung </h4><br>  Die zweite Aufgabe dauerte ungef√§hr 20 Minuten.  Mit ihrer Hilfe wollten wir das Wissen √ºber regul√§re Ausdr√ºcke unter den Teilnehmern testen. <br><br>  Aus der Bedingung erfahren wir, dass eine Zeichenfolge, die eine g√ºltige CSS-Klasse mit zus√§tzlichen Einschr√§nkungen enth√§lt, zur Eingabe in die Funktion kommt, in der Buchstabenfolgen durch beliebige Folgen von Nichtbuchstaben getrennt sind.  Unsere Aufgabe ist es, Separatoren zu finden und deren Semantik zu verstehen. <br><br>  Der erste Teil des Klassennamens ist immer der Name des Blocks.  Dies ist eine Folge von einem oder mehreren Buchstaben.  Wir schreiben den entsprechenden regul√§ren Ausdruck: [az] +. <br><br>  F√ºr die Suche nach den √ºbrigen Teilen werden √§hnliche Ausdr√ºcke ben√∂tigt: der Name des Modifikators und sein Wert oder der Name des Elements mit dem entsprechenden Modifikator und Wert. <br><br>  Um nach Trennzeichen zu suchen, ben√∂tigen wir Nicht-Buchstabenfolgen, der Ausdruck: [^ az] + ist geeignet. <br><br>  Stellen Sie es zusammen und definieren Sie die Gruppen, deren Werte wir verwenden werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>);</code> </pre> <br>  Jetzt m√ºssen Sie sicherstellen, dass wir die Semantik der gefundenen Gruppen korrekt definiert haben.  Sie k√∂nnen die Tatsache nutzen, dass sich nur ein Modifikator zweimal treffen kann. <br><br>  Wir werden eine Funktion schreiben, die die urspr√ºngliche Zeichenfolge und das gefundene Trennzeichen verwendet, um die Anzahl der Vorkommen zu berechnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length;</code> </pre> <br>  Wenn sich herausstellt, dass das Trennzeichenelement zweimal vorkommt und einmal modifiziert, ist das Gegenteil der Fall.  Die endg√ºltige Entscheidung: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substringCount(str, elem) === <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; substringCount(str, mod) === <span class="hljs-number"><span class="hljs-number">1</span></span>) { [mod, elem] = [elem, mod]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { mod, elem }; }</code> </pre> <br><h2>  C. Klonfabrik </h2>  <sup><i>Autoren: Dmitry <a href="https://habr.com/ru/users/dima117/" class="user_link">Andriyanov dima117</a> , Alexey Gusev</i></sup> <br><br><h4>  Zustand </h4><br>  Au√üerhalb des Fensters ist 2319.  Unternehmen klonen erfolgreiche Mitarbeiter, um komplexe Aufgaben zu erledigen. <br><br>  Bei der Herstellung von Klonen entschieden sie sich, neue ‚ÄûProdukte‚Äú mit einem Barcode-Tattoo auf der Schulter zu kennzeichnen, um die Klone voneinander zu unterscheiden. <br><br>  Helfen Sie dem Fabrikpersonal, eine Funktion zu schreiben, mit der ein Barcode mit Informationen zum Klon erstellt wird. <br><br>  <b>Clone-Informationsformat</b> <br><br>  Informationen zum Klon werden wie folgt gespeichert: <br><br><pre> <code class="javascript hljs">type CloneInfo = { <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî  'male'  'female' */</span></span> sex: string; <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî      *    ,  10  */</span></span> id: string; <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî      *     ( 0  26 ) */</span></span> name: string; }</code> </pre> <br>  <b>Barcode-Rendering-Algorithmus</b> <br><br>  Die in der Klonfabrik verwendeten Barcodes sehen folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/jl/jj/dc/jljjdcawcmcsrmsgyyi9bk19oii.png" width="400"><br><br>  Der Barcode hat eine feste Gr√∂√üe - 148 x 156 Pixel.  Rund um den Umfang des Barcodes befinden sich schwarze und wei√üe Rahmen mit jeweils 3 Pixeln.  Innerhalb der Rahmen befindet sich der Barcode-Inhalt, bestehend aus 18 Zeilen mit 17 schwarzen oder wei√üen Quadraten pro Zeile.  Die Gr√∂√üe jedes Quadrats betr√§gt 8 x 8 Pixel. <br><br>  Wei√üe Quadrate im Inhalt codieren 0, schwarz - 1. <br><br>  <b>Algorithmus zur Erzeugung von Barcode-Inhalten</b> <br><br>  Am Schnittpunkt der ersten Zeile und der ersten Inhaltsspalte wird ein Quadrat gezeichnet, das das Geschlecht des Klons codiert.  Der Wert von weiblich wird durch null (wei√ü) und m√§nnlich durch eins (schwarz) codiert. <br><br>  Ferner wird aus den Feldern id und name eine Zeile der Form &lt;id&gt; &lt;name&gt; gebildet.  Das Namensfeld wird mit Leerzeichen am Ende von bis zu 26 Zeichen aufgef√ºllt. <br><br>  Die resultierende Zeichenfolge wird in ein Byte-Array konvertiert. Jedem Zeichen der Zeichenfolge wird der entsprechende ASCII-Code zugewiesen (eine Zahl von 0 bis 255). <br><br>  Dann wird jedes Element des resultierenden Arrays in eine Bin√§rnotation (acht Zeichen 0 oder 1) √ºbersetzt und durch eine Folge von acht Quadraten (0 - wei√ües Viertel, 1 - schwarzes Quadrat) codiert.  Quadrate werden nacheinander und zeilenweise in den Barcode-Inhalt gezeichnet. <br><br>  Die letzte Inhaltszeile enth√§lt Steuerinformationen. <br><br>  <b>Z√§hlalgorithmus f√ºr Steuerinformationen</b> <br><br>  Jedes Quadrat in der Kontrollinformationszeile bestimmt die Parit√§t der Summe der Inhaltswerte in der entsprechenden Spalte.  Wenn die Summe aus Nullen und Einsen in der Spalte gerade ist, wird in den Steuerinformationen ein wei√ües Quadrat gezeichnet, andernfalls ein schwarzes Quadrat. <br><br><div class="spoiler">  <b class="spoiler_title">L√∂sungsformat und Beispiele</b> <div class="spoiler_text">  <b>L√∂sungsformat</b> <br><br>  Die geladene L√∂sung sollte die renderBarcode-Funktion enthalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       element * @param cloneInfo {CloneInfo} ‚Äî    * @param element {HTMLDivElement} ‚Äî div    * 148x156 ,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderBarcode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cloneInfo, element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }&lt;/source lang="javascript"&gt;      Google Chrome 77. &lt;h4&gt; 1&lt;/h4&gt;   : &lt;source lang="javascript"&gt;{ "sex": "male", "id": "c5j818dyo5", "name": "Oleg Vladimirovich" }</span></span></code> </pre> <br>  Barcode: <br><br><img src="https://habrastorage.org/webt/zm/pi/iz/zmpiiztvwzeo77-xswxzdrfhshs.png"><br><br><h4>  Beispiel 2 </h4><br>  Informationen zum Klonen: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"sex"</span></span>: <span class="hljs-string"><span class="hljs-string">"female"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"0owrgqqwfw"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Dazdraperma Petrovna"</span></span> }</code> </pre> <br>  Barcode: <br><br><img src="https://habrastorage.org/webt/9e/yk/vo/9eykvoqjupololm76rjmle7030k.png"></div></div><br><h4>  L√∂sung </h4><br>  Es war notwendig, die Bin√§rdarstellung der Daten korrekt zu bilden, die Pr√ºfsumme daf√ºr zu berechnen und diese Daten in das Layout zu zeichnen.  Versuchen wir dies so einfach und Stirn wie m√∂glich zu machen - ohne Code-Optimierungen. <br><br>  Beginnen wir mit der bin√§ren Darstellung.  Deklarieren Sie zun√§chst die Hilfsfunktionen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ASCII- function charToByte(char) { return char.charCodeAt(0); } //      0  1 (      ) function byteToString(byte) { return byte.toString(2).padStart(8, '0'); }</span></span></code> </pre> <br>  Wir bilden aus den Quelldaten einen String bestehend aus Nullen und Einsen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataString = (cloneInfo.sex === <span class="hljs-string"><span class="hljs-string">'female'</span></span> ? <span class="hljs-string"><span class="hljs-string">'0'</span></span> : <span class="hljs-string"><span class="hljs-string">'1'</span></span>) + cloneInfo.id.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>) + cloneInfo.name.padEnd(<span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Dann schreiben Sie das Layout und die Stile f√ºr unseren Barcode: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ¬´¬ª . //  ,      DOM API   innerHTML,     . //     ,      ,      ¬´¬ª. //         ‚Äî   ,        . const contentElId = 'content-' + Math.random(); element.style.display = 'flex'; element.innerHTML = ` &lt;style&gt; .barcode { border: 3px solid black; box-sizing: border-box; } .content { margin-top: 3px; margin-left: 3px; width: 136px; height: 144px; display: flex; flex-wrap: wrap; } .content__bit { width: 8px; height: 8px; } .content__bit_one { background: black; } &lt;/style&gt; &lt;div class="content" id="${contentElId}"&gt;&lt;/div&gt; `; const contentDiv = document.getElementById(contentElId); element.className += ' barcode';</span></span></code> </pre> <br>  Rendern von Bin√§rdaten im Layout: <br><br><pre> <code class="javascript hljs">dataString .split(<span class="hljs-string"><span class="hljs-string">''</span></span>) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bit</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bitDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); bitDiv.className = <span class="hljs-string"><span class="hljs-string">'content__bit content__bit_'</span></span> + (bit === <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? <span class="hljs-string"><span class="hljs-string">'zero'</span></span> : <span class="hljs-string"><span class="hljs-string">'one'</span></span>); contentDiv.appendChild(bitDiv); });</code> </pre> <br>  Es bleibt die Pr√ºfsumme zu berechnen und anzuzeigen.  Das kann so gemacht werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">17</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   let sum = 0; for (let j = i; j &lt; 17 ** 2; j += 17) { sum += parseInt(dataString[j], 2); } const check = 0; const bitDiv = document.createElement('div'); //       bitDiv.className = 'content__bit content__bit_' + (sum % 2 === 0 ? 'zero' : 'one'); contentDiv.appendChild(bitDiv); }</span></span></code> </pre> <br><h2>  D. Automatisieren Sie es </h2>  <sup><i>Autoren: Vladimir Rusov, Dmitry Kanatnikov</i></sup> <br><br>  In jeder der Qualifizierungsoptionen gab es eine Aufgabe, bei der eine HTML-Seite mit einer Tabelle oder Liste als Eingabe vorgeschlagen wurde.  Die Aufgaben dieser Reihe hatten eine andere Legende, aber alle beruhten darauf, dass Sie die Seite in ein Format bringen m√ºssen, das Markdown √§hnelt.  Wir werden die L√∂sung f√ºr eines der Probleme analysieren. <br><br><h4>  Zustand </h4><br>  Auf dem Landesportal f√ºr die Erbringung von Dienstleistungen haben sie es erm√∂glicht, einen Antrag auf Unterlagen vollautomatisch einzureichen, dazu m√ºssen Sie lediglich eine Tabelle mit personenbezogenen Daten ausf√ºllen. <br><br>  Diese Daten werden dann zur √úberpr√ºfung an mehrere Beh√∂rden weitergeleitet, darunter das Innenministerium.  Nach dem Teststart stellte sich heraus, dass das Innenministerium Daten im Markdown-Format akzeptiert und die staatlichen Dienste das HTML-Format verwenden.  Hilf mir, ein Skript f√ºr die Migration eines Formats in ein anderes zu schreiben, damit die Jungs so schnell wie m√∂glich anfangen. <br><br>  Sie m√ºssen eine Funktion schreiben, die eine HTML-Tabelle als Eingabe verwendet und in ein Markdown-√§hnliches Markup konvertiert. <br><br>  Senden Sie als L√∂sung f√ºr diese Aufgabe die JS-Datei, in der die L√∂sungsfunktion deklariert ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Eingabe- / Ausgabeformat und Notizen</b> <div class="spoiler_text"><h4>  Eingabeformat </h4><br>  Die HTML-Tabelle wird als String geliefert: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"right"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Command <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Description <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Is implemented <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git status<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>List all new or modified files<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Yes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git diff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Show file differences that haven't been staged<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>No<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Die Tabelle kann colgroup-, thead- und tbody-Tags in einer festen Reihenfolge enthalten.  Alle diese Tags sind optional, aber mindestens Thead oder Tbody wird immer vorhanden sein. <br><br>  - colgroup enth√§lt col-Tags, die das optionale align-Attribut mit einem von drei Werten haben k√∂nnen (left | center | right) <br>  - Thead und Tbody enthalten 1 oder mehr tr <br>  - tr enth√§lt wiederum sowohl td als auch th <br>  - Die Tabelle enth√§lt immer mindestens eine Zeile.  - Die Zeile enth√§lt immer mindestens eine Zelle.  - In der Zelle ist immer mindestens ein Nicht-Leerzeichensymbol vorhanden. <br>  - Die Anzahl der th / td-Elemente in Zeilen stimmt immer mit der Anzahl der col-Elemente in colgroup √ºberein, wenn colgroup vorhanden ist. <br>  - Leerzeichen und Zeilenumbr√ºche im Quell-HTML k√∂nnen √ºberall dort vorkommen, wo die G√ºltigkeit von HTML nicht verletzt wird. <br><br><h4>  Ausgabeformat </h4><br>  Die Ausgabe sollte eine Zeile mit Markdown-Markup sein: <br><br> <code>| Command | Description | **Is implemented** | <br> | ---: | :--- | :---: | <br> | **git status** | List all new or modified files | **Yes** | <br> | **git diff** | Show file differences that haven't been staged | No |</code> <br> <br>  - Die erste Zeile in einer Tabelle sollte im Markdown-Markup immer in eine Kopfzeile umgewandelt werden. <br>  - Alle anderen Zeilen gehen zum Hauptteil der Tabelle. <br>  - Das Header-Trennzeichen wird immer angezeigt. <br>  - Der Inhalt von td wird unver√§ndert eingef√ºgt, der Inhalt in ** Fettdruck **. <br>  - Zwischen dem Inhalt der Zelle im Markdown-Markup und den Zellentrennzeichen (|) befindet sich immer ein Leerzeichen. <br>  - Leerzeichen an den R√§ndern des Inhalts der Tags td und th sollten entfernt werden. <br>  - Zeilenumbr√ºche im Zelleninhalt m√ºssen gel√∂scht werden. <br>  - Es muss mehr als ein Leerzeichen hintereinander im Inhalt der Zellen durch ein Leerzeichen ersetzt werden. <br>  - F√ºr die Ausrichtung in den Zellen der Spalten der Markdown-Tabelle ist die Formatierung des Header-Trennzeichens verantwortlich: <br><br>  |  : --- |  bedeutet linksb√ºndig <br>  |  : ---: |  bedeutet Mittenausrichtung <br>  |  ---: |  bedeutet richtige Ausrichtung <br><br>  Wenn im col-Tag kein Ausrichtungsattribut angegeben ist, sollte die Ausrichtung auf der linken Seite festgelegt werden. <br><br><h4>  Hinweise </h4><br>  - F√ºr den Zeilenumbruch m√ºssen Sie das Zeichen \ n verwenden. <br>  - Die L√∂sung wird in einer Browserumgebung <b>(Chrome 78)</b> mit Zugriff auf Dokument- und Fensterobjekte getestet. <br>  - Sie k√∂nnen Syntax bis einschlie√ülich <b>es2018 verwenden</b> . </div></div><br><h4>  L√∂sung </h4><br>  Das Problem wird durch einfaches Durchlaufen des DOM-Baums der Tabelle gel√∂st.  Die Unterst√ºtzung f√ºr den DOM-Baum wird auf Browserebene implementiert und ist ein wesentlicher Bestandteil davon, sodass es keine Probleme gibt.  Um das Problem zu l√∂sen, reicht es aus, den DOM-Baum von HTML in Markdown-Markup zu √ºbersetzen. <br><br>  Wenn Sie sich die Beispiele angesehen haben, k√∂nnen Sie feststellen, dass die Konvertierung recht einfach ist.  Nachfolgend finden Sie den Code, der den Hauptteil der L√∂sungsfunktion (Eingabe) darstellt. <br><br>  Zuerst m√ºssen wir den String von HTML in den DOM-Baum konvertieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = input; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = div.firstChild;</code> </pre> <br>  Nachdem wir einen DOM-Baum erhalten haben, k√∂nnen wir ihn einfach durchgehen und Daten von verschiedenen DOM-Knoten verarbeiten.  Dazu reicht es aus, die Reihenfolge der untergeordneten Elemente verschiedener DOM-Elemente rekursiv zu umgehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processors = { <span class="hljs-string"><span class="hljs-string">'colgroup'</span></span>: processColgroup, <span class="hljs-string"><span class="hljs-string">'thead'</span></span>: processThead, <span class="hljs-string"><span class="hljs-string">'tbody'</span></span>: processTbody, }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> table.children) { processors[child.tagName.toLowerCase()](child); }</code> </pre> <br>  Anhand der Tags colgroup und col m√∂chten wir die Ausrichtung der Tabellenspalten kennen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignments = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultAlign = <span class="hljs-string"><span class="hljs-string">'left'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processColgroup = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colgroup</span></span></span><span class="hljs-function">) =&gt;</span></span> { alignments.push(...Array(...colgroup.children).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">col</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col.align || defaultAlign; })); };</code> </pre> <br>  In den Tags Thead, Tbody und TR interessieren wir uns nur f√ºr Kinder: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rows = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processThead = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">thead</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...thead.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTbody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tbody</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...tbody.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTr = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...tr.children).map(processCell); };</code> </pre> <br>  Es ist wichtig, nicht zu vergessen, dass td und th laut Konvention unterschiedlich formatiert sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processCell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tag = cell.tagName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = clearString(cell.innerHTML); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'td'</span></span>: content, <span class="hljs-string"><span class="hljs-string">'th'</span></span>: <span class="hljs-string"><span class="hljs-string">`**</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${content}</span></span></span><span class="hljs-string">**`</span></span>, }[tag]; };</code> </pre> <br>  Um mit dem Testinhalt des DOM zu arbeiten, m√ºssen Sie die in der Bedingung beschriebenen Anforderungen erf√ºllen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearLineBreaks = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\r?\n|\r/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearSpaces = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearString = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> clearSpaces(clearLineBreaks(str)).trim();</code> </pre> <br>  Nachdem wir den DOM-Baum umrundet hatten, wurde der Gro√üteil unserer Tabelle in das Zeilenarray geschrieben: <br><br> <code>[ <br> ["Command","Description","**Is implemented**"], <br> ["**git status**","List all new or modified files","**Yes**"], <br> ["**git diff**","Show file differences that haven't been staged","No"] <br> ]</code> <br> <br>  Die Informationen zur Spaltenausrichtung befanden sich im Alignments-Array: <br><br> <code>["right","left","center"]</code> <br> <br>  Beachten Sie, dass die Informationen zur Spaltenausrichtung m√∂glicherweise nicht in der Eingabe enthalten sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updateAlignments = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alignments.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; alignments.push(...rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> defaultAlign)); }; updateAlignments();</code> </pre> <br>  Ausrichtungen in endg√ºltige Form umwandeln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignmentsContents = alignments.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">align</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'left'</span></span>: <span class="hljs-string"><span class="hljs-string">' :--- '</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>: <span class="hljs-string"><span class="hljs-string">' :---: '</span></span>, <span class="hljs-string"><span class="hljs-string">'right'</span></span>: <span class="hljs-string"><span class="hljs-string">' ---: '</span></span> }[align]; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delimiter = <span class="hljs-string"><span class="hljs-string">`|</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${alignmentsContents.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">|`</span></span>;</code> </pre> <br>  Beispiel f√ºr einen Begrenzerwert: <br><br> <code>"| ---: | :--- | :---: |"</code> <br> <br>  Der letzte Schritt wird die Bildung einer Markdown-Zeile sein, die alle aus dem HTML gelesenen Daten enth√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lineEnd = <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; rows.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) markdown += lineEnd; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mdRow = <span class="hljs-string"><span class="hljs-string">`| </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${row.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">' | '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> |`</span></span>; markdown += mdRow; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) { markdown += lineEnd; markdown += delimiter; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> markdown;</code> </pre> <br>  Das R√ºckgabekonstrukt bedeutet, dass der gesamte obige Code der Hauptteil der L√∂sungsfunktion (Eingabe) war.  Als Ergebnis dieser Funktion erhalten wir den gew√ºnschten Markdown-Tabellencode, der in der Beispielausgabe der Taskbedingung gezeigt wird. <br><br><h2>  E. Pandemievirus </h2>  <sup><i>Autoren: Andrey Mokrousov, Ivan Petukhov</i></sup> <br><br>  Die Weltgesundheitsorganisation hat einen Bericht √ºber Anzeichen einer bevorstehenden Pandemie eines neuen Virus ver√∂ffentlicht, das Front-End-Entwickler bedroht.  Es ist bekannt, dass sich der Virus erst manifestiert, wenn der Host den JS-Code sieht, der einen Ausdruck enth√§lt.  Sobald die infizierte Person diesen Ausdruck gesehen hat, verliert sie ihre F√§higkeit, Code in JS zu schreiben, und beginnt, spontan Code in Fortran zu schreiben. <br><br>  In dem Bericht wird erw√§hnt, dass der Virus aktiviert wird, indem das erste Argument der Funktion verwendet wird, das vom Argument an den Zyn-Funktionsaufruf √ºbergeben wird. Eine infizierte Person kann also keinen Ausdruck wie Zyn (function (a, b, c) {console.log (a)}) anzeigen. <br><br>  Um nicht versehentlich das gesamte Front-End zu verlieren, hat AST &amp; Co entschieden, zu √ºberpr√ºfen, ob der Code den obigen Ausdruck enth√§lt.  Helfen Sie den Ingenieuren des Unternehmens, einen solchen Scheck auszustellen. <br><br>  √úber den Code von AST &amp; Co wissen wir, dass: <br><br>  - es ist in ES3 geschrieben, <br>  - Der Zugriff auf die Eigenschaften eines Objekts ist sowohl √ºber einen Punkt als auch √ºber eckige Klammern (ab und a ['b']) m√∂glich. <br>  - Ein Teil des Ausdrucks kann in einer Variablen gespeichert werden, er wird jedoch niemals vom Parameter (a (x) - verboten) an die Funktion √ºbergeben. <br>  - Es gibt keine Funktionen, die einen Teil des gew√ºnschten Ausdrucks zur√ºckgeben. <br> ‚Äî      ,    , <br> ‚Äî             (a[x], x ‚Äî ), <br> ‚Äî         , . .      var a = x; a = y;  var a = b = 1. <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><h4>   </h4><br>       CommonJS-,   ,       (ast)  . <br><br>      ast-,       callback-,    Zyn      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ ... return [...]; }</code> </pre> <br><h4>  Hinweise </h4><br>         . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ). * * @param {object} ast  ast. * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]       . * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]       . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,   . * * @param {object} astNode ast-. * @param {Scope} currentScope   . * @return {Scope}      astNode. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">astNode, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//      . return currentScope; } //      . const newScope = new Scope(ast, currentScope); ast.params.forEach(param =&gt; { //     . newScope.add(param.name); }); if (isFunctionDeclaration) { //       . currentScope.add(ast.id.name); } else { //  -    . newScope.add(ast.id.name); } return newScope; } /** *    ast. * * @param {object} astNode  ast-. * @param {Scope} scope     ast-. */ function _inner(astNode, scope) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,  . */ _inner(node, scope); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast-. return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //   . _inner(astNode[key], innerScope); }); onNodeLeave(astNode, scope); } } } /** *   . * * @class Scope (name) * @param {object} astNode ast-,    . * @param {object} parentScope   . */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Set(); } Scope.prototype = { /** *      . * * @param {string} name  . */ add(name) { this._vars.add(name); }, /** *       . * * @param {string} name  . * @return {boolean}          . */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } };</span></span></code> </pre> </div></div><br><h4>  L√∂sung </h4><br>    . <br><br><blockquote> ‚Äî    ES3 </blockquote> ,          . ,       . <br><br><blockquote> ‚Äî        ,     (ab  a['b']) </blockquote>       Zyn,   Z['y'].n, Zy['n']  Z['y']['n']. <br><br><blockquote>       ,        (a(x) ‚Äî ) </blockquote>         ,         . ,     : var x = Zy; xn(...). <br><br><blockquote> ‚Äî  ,     , <br> ‚Äî      ,    , <br> ‚Äî         , ..      var a = x; a = y;  var a = b = 1. </blockquote>   (       )  ,        - . <br><br><blockquote> ‚Äî     ,        (a[x], x ‚Äî ) </blockquote>          ,    : var x = 'y'; Z[x].n(...). <br><br> C    : <br> 1.   ,     ,     . <br> 2.   ,     . <br><br> ,     ,         ‚Äî          .        2. <br><br> <b> </b> <br><br>     :   Zyn(function(a, b, c){...}),  ‚Äî     . <br><br>    FunctionExpression ‚Äî      CallExpression,   callee ‚Äî MemberExpression.   property ‚Äî n,  object (  MemberExpression  object  property   y) ‚Äî Z. <br><br>        ,      ‚Äî  ‚Äî  .     ‚Äî  Identifier    ,      MemberExpression  ObjectLiteral    (xa  var x = {a: ...} ). <br><br><pre> <code class="javascript hljs">+++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-120</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">59</span></span> @@ Scope.prototype = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.has(name) || <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.isDefined(name</span></span></span><span class="hljs-function">)); } }; + +</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args = node.arguments; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length !== <span class="hljs-number"><span class="hljs-number">1</span></span> || + args[<span class="hljs-number"><span class="hljs-number">0</span></span>].type !== <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + object = callee.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + property = object.property; + object = object.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || + object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + checkFunction(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); + }); + + <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArg = ast.params[<span class="hljs-number"><span class="hljs-number">0</span></span>]; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!firstArg) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + traverse(ast.body, (node, scope) =&gt; { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.name === firstArg.name) { + result.push(node); + } + }); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; +};</code> </pre> <br>    traverse ,       ,      MemberExpression  ObjectProperty. : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> * @param {object} astNode  ast- * @param {Scope} scope     ast- *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - function _inner(astNode, scope) { + function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /</span></span></span></span><span class="hljs-function"><span class="hljs-params">*    . *  , ,   *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - _inner(node, scope); + _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { - onNodeEnter(astNode, scope); + onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { @@ -80,10 +80,10 @@ function traverse( keys.forEach(key =&gt; { /</span></span></span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/    - _inner(astNode[key], innerScope); + _inner(astNode[key], innerScope, astNode); }); - onNodeLeave(astNode, scope); + onNodeLeave(astNode, scope, parent); } } } @@ -164,10 +164,22 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope) =&gt; { + traverse(ast.body, (node, scope, parent) =&gt; { if (node.type !== 'Identifier') { return; } + if (!parent) { + return; + } + if (parent.type === 'MemberExpression' &amp;&amp; + parent.computed === false &amp;&amp; + parent.property === node) { + return; + } + if (parent.type === 'ObjectProperty' &amp;&amp; + parent.key === node) { + return; + } if (node.name === firstArg.name) { result.push(node); }</span></span></span></span></span></span></code> </pre> </div></div><br>         .   getPropName: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-121</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span> @@ Scope.prototype = { } }; +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; + } + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; + } +} + <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; @@ <span class="hljs-number"><span class="hljs-number">-137</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> +<span class="hljs-number"><span class="hljs-number">149</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), object = callee.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = object.property; + property = getPropName(object); object = object.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> ||</code> </pre> </div></div><br>      :        .        .     1. <br><br> <b> Scope</b> <br><br>    Scope       .  ,   ,        traverse: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span> @@ +<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); + +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { + scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); +} <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ). @@ -13,7 +22,7 @@ function traverse( onNodeEnter = (node, scope) =&gt; {}, onNodeLeave = (node, scope) =&gt; {} ) { - const rootScope = new Scope(ast); + const rootScope = getScopeFor(ast); _inner(ast, rootScope); @@ -36,19 +45,19 @@ function traverse( } //      . - const newScope = new Scope(ast, currentScope); + const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //     . - newScope.add(param.name); + newScope.add(param.name, param); }); if (isFunctionDeclaration) { //       . - currentScope.add(ast.id.name); + currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -    . - newScope.add(ast.id.name); + newScope.add(ast.id.name, ast); } return newScope; @@ -98,7 +107,7 @@ function traverse( function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; - this._vars = new Set(); + this._vars = new Map(); } Scope.prototype = { @@ -107,8 +116,24 @@ Scope.prototype = { * * @param {string} name   */</span></span> - add(name) { - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.add(name); + add(name, value) { + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.set(name, { + value: value, + scope: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + }); + }, + resolve(node) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + } + value = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.resolve(node</span></span></span><span class="hljs-function">)); + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; + } }, /** *       . @@ -136,6 +161,12 @@ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'VariableDeclarator'</span></span>) { + scope.add(node.id.name, node.init); + } + }); + traverse(ast, (node, scope) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> Scope</b> <br><br>      .        ,     Scope    . ,   Scope   ,        : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-146</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">146</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ Scope.prototype = { } }; -<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(prop); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + prop = resolved.value; + } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; } @@ <span class="hljs-number"><span class="hljs-number">-177</span></span>,<span class="hljs-number"><span class="hljs-number">22</span></span> +<span class="hljs-number"><span class="hljs-number">181</span></span>,<span class="hljs-number"><span class="hljs-number">43</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(callee); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + callee = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee, scope), object = callee.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = getPropName(object); + property = getPropName(object, scope); object = object.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> </b> <br><br>        :       .    : <br><br> ‚Äî  ,  Z ‚Äî     ,   - . <br> ‚Äî  ,         ,        . <br> ‚Äî       ,       var a = 'x', b = a. <br><br>    ,   . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-128</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span> @@ Scope.prototype = { } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent) { + value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent.resolve(node); + } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { + <span class="hljs-comment"><span class="hljs-comment">//   scope,  node ‚Äî + //   . + this.add(node.name, node); + return this.resolve(node); + } + } + if (!value) { + return; + } + if (value.value.type === 'Identifier' &amp;&amp; + value.value !== node) { + return value.scope.resolve(value.value) || value; } - value = (this._parent &amp;&amp; this._parent.resolve(node)); return value; } }, @@ -165,12 +178,15 @@ function getPropName(node, scope) { module.exports = function (ast) { var result = []; + traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); + let rootScope = getScopeFor(ast); + traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; @@ -213,9 +229,10 @@ module.exports = function (ast) { } resolved = scope.resolve(object); + let zScope; if (resolved) { object = resolved.value; - scope = resolved.scope; + zScope = resolved.scope; } if (object.type !== 'Identifier' || @@ -223,6 +240,10 @@ module.exports = function (ast) { return; } + if (zScope &amp;&amp; zScope !== rootScope) { + return; + } + checkFunction(args[0]); }); @@ -232,7 +253,10 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope, parent) =&gt; { + traverse(ast, (node, scope, parent) =&gt; { + if (parent === ast) { + return; + } if (node.type !== 'Identifier') { return; } @@ -248,7 +272,9 @@ module.exports = function (ast) { parent.key === node) { return; } - if (node.name === firstArg.name) { + + let resolved = scope.resolve(node); + if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } });</span></span></code> </pre> </div></div><br>   : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); } <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *  callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ) * * @param {object} ast  ast * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]        * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]        */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = getScopeFor(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,    * * @param {object} ast ast- * @param {Scope} currentScope    * @return {Scope}      astNode */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//       return currentScope; } //       const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //      newScope.add(param.name, param); }); if (isFunctionDeclaration) { //        currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -     newScope.add(ast.id.name, ast); } return newScope; } /** *    ast * * @param {object} astNode  ast- * @param {Scope} scope     ast- */ function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,   */ _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast- return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //    _inner(astNode[key], innerScope, astNode); }); onNodeLeave(astNode, scope, parent); } } } /** *    * * @class Scope (name) * @param {object} astNode ast-,     * @param {object} parentScope    */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Map(); } Scope.prototype = { /** *       * * @param {string} name   */ add(name, value) { this._vars.set(name, { value: value, scope: this }); }, resolve(node) { if (!node) { return node; } if (node.type === 'Identifier') { let value = this._vars.get(node.name); if (!value) { if (this._parent) { value = this._parent.resolve(node); } else { //   scope,  node - //    this.add(node.name, node); return this.resolve(node); } } if (!value) { return; } if (value.value.type === 'Identifier' &amp;&amp; value.value !== node) { return value.scope.resolve(value.value) || value; } return value; } }, /** *       . * * @param {string} name   * @return {boolean}           */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } }; function getPropName(node, scope) { let prop = node.property; if (!node.computed) { return prop.name; } let resolved = scope.resolve(prop); if (resolved) { prop = resolved.value; } if (prop.type === 'StringLiteral') { return prop.value; } } module.exports = function (ast) { var result = []; traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); let rootScope = getScopeFor(ast); traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; } let args = node.arguments; if (args.length !== 1 || args[0].type !== 'FunctionExpression') { return; } let callee = node.callee; let resolved = scope.resolve(callee); if (resolved) { callee = resolved.value; scope = resolved.scope; } if (callee.type !== 'MemberExpression') { return; } let property = getPropName(callee, scope), object = callee.object; if (property !== 'n') { return; } resolved = scope.resolve(object); if (resolved) { object = resolved.value; scope = resolved.scope; } if (object.type !== 'MemberExpression') { return; } property = getPropName(object, scope); object = object.object; if (property !== 'y') { return; } resolved = scope.resolve(object); let zScope; if (resolved) { object = resolved.value; zScope = resolved.scope; } if (object.type !== 'Identifier' || object.name !== 'Z') { return; } if (zScope &amp;&amp; zScope !== rootScope) { return; } checkFunction(args[0]); }); function checkFunction(ast) { let firstArg = ast.params[0]; if (!firstArg) { return; } traverse(ast, (node, scope, parent) =&gt; { if (parent === ast) { return; } if (node.type !== 'Identifier') { return; } if (!parent) { return; } if (parent.type === 'MemberExpression' &amp;&amp; parent.computed === false &amp;&amp; parent.property === node) { return; } if (parent.type === 'ObjectProperty' &amp;&amp; parent.key === node) { return; } let resolved = scope.resolve(node); if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } }); } return result; };</span></span></code> </pre> </div></div><br><h2> F.  Framework- </h2> <sup><i>:  ,   <a href="https://habr.com/ru/users/collapsus/" class="user_link">collapsus</a></i></sup> <br><br>                  API.          ‚Äî   ,    .         . <br><br><h4>  Zustand </h4><br>     ‚Äî        .    .       ,         .     ! <br><br>         .     ,       .    ,         ,   ,    (       ).  ,        ,         0 (0 , 0 , 0 ). <br><br> ,    ,       .      JavaScript  JS-   Framework. <br><br>     : ,   .            ( ,    ).      ()   .             (  ). <br><br>         0.       ,    ( time)     . <br><br> <b>   </b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_DEGREES = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_FACTOR = <span class="hljs-number"><span class="hljs-number">1</span></span> / Framework.SPEED * ONE_SECOND_DEGREES; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Framework</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"seconds"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"red"</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"minutes"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"hours"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buttons.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Button(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, () =&gt; { alert(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick = <span class="hljs-number"><span class="hljs-number">0</span></span>; } onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick++; arrow.rotateFactor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick % <span class="hljs-number"><span class="hljs-number">10</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : ONE_SECOND_FACTOR; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"before: "</span></span> + arrow.pos); } onAfterTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"after: "</span></span> + arrow.pos); } }</code> </pre> <br>     : <br> ‚Äî  ‚Äî  ,   , <br> ‚Äî      , <br> ‚Äî  ,    ;     (100 )        ;   ,      . <br><br><h4>  L√∂sung </h4><br> ,      -,   ¬´   ¬ª,      .    ,    ,      ,           . <br><br>       : ,   .       . ,       ,           . <br><br>         : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre> <br>       //      . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-comment"><span class="hljs-comment">//    const ts = Math.floor(ticks / TPS); //   const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; }</span></span></code> </pre> <br>   ,          ‚Äî     rotateFactor.      getRotateFactor,     ,       ,    .     : <br> 1.   , <br> 2.  . <br><br>         .    . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-comment"><span class="hljs-comment">//        if (forward) { //      angle &lt; 0 &amp;&amp; (angle += 360); //        0  360 ( 360   0),    } else { //         Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } return angle / Framework.SPEED; }</span></span></code> </pre> <br>     ,    MAX_SPEED    .      getRotateFactor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forward) { angle &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (angle += <span class="hljs-number"><span class="hljs-number">360</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(angle) &gt; <span class="hljs-number"><span class="hljs-number">180</span></span> &amp;&amp; (angle -= <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sign(angle) * <span class="hljs-number"><span class="hljs-number">360</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = angle / Framework.SPEED; <span class="hljs-comment"><span class="hljs-comment">//      ,    return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; }</span></span></code> </pre> <br>       : <br><br><pre> <code class="javascript hljs">buttonAHandler() { <span class="hljs-comment"><span class="hljs-comment">//     this.pos = (this.pos + 1) % this.planets.length; //      this.forward = false; }</span></span></code> </pre> <br>  ,     : <br><br><pre> <code class="javascript hljs">onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [sec, min, hour] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> time = ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ticks; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> planet = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.planets[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos]; <span class="hljs-comment"><span class="hljs-comment">//        const target = getTarget(time, planet); //      sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); //       ,       !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); }</span></span></code> </pre> <br>   : <br><br><div class="spoiler">  <b class="spoiler_title">√ñffnen</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ts = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(ticks / TPS); <span class="hljs-comment"><span class="hljs-comment">// total seconds const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; } function getRotateFactor(pos, target, forward = true) { let angle = target - pos; if (forward) { angle &lt; 0 &amp;&amp; (angle += 360); } else { Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } const factor = angle / Framework.SPEED; return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; } class MyClock extends Clock { // planets -   // [ { h: 4, m: 20, s: 10 }, ... ] constructor({ planets, time }) { super(); this.arrows.push(new Arrow('seconds', { color: 'red' })); this.arrows.push(new Arrow('minutes', { weight: 3, length: 80 })); this.arrows.push(new Arrow('hours', { weight: 3, length: 60 })); this.buttons.push(new Button('Switch', this.buttonAHandler.bind(this))); this.planets = planets; this.ticks = time * TPS; this.pos = 0; this.forward = false; } onBeforeTick() { const [sec, min, hour] = this.arrows; const time = ++this.ticks; const planet = this.planets[this.pos]; const target = getTarget(time, planet); sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); } buttonAHandler() { this.pos = (this.pos + 1) % this.planets.length; this.forward = false; } }</span></span></code> </pre> </div></div><br> <b></b> <br><br>   .              .  ,  ,     ,             . <br><br>    :   ,  ,  ,   ,      (,   ,      ). <br><br>  <b>Fazit</b> <br><br>    .           .     ‚Äî ,      .         . <br><br>   ,      .      ,     (   )  18 . <br><br><hr><br> : <br><br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/477452/"> ML-  </a> <br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/460139/"> -  </a> <br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/430560/"> -    </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478550/">https://habr.com/ru/post/de478550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478538/index.html">So √ºberpr√ºfen Sie Ihren Reisepass auf G√ºltigkeit</a></li>
<li><a href="../de478540/index.html">Vorbereitungen f√ºr das zehnte Forum ‚ÄûPositive Hack Days 10: Getting Started‚Äú</a></li>
<li><a href="../de478542/index.html">FigmaGen: Style Automation in der iOS App</a></li>
<li><a href="../de478544/index.html">Vue Storefront: Verzeichnis aus Magento 2 importieren</a></li>
<li><a href="../de478546/index.html">Websockets Erfahrung in Entwicklung und Betrieb. Wir modifizieren den Kunden</a></li>
<li><a href="../de478552/index.html">Zweites Applet, Schlie√üen und transparente Schaltfl√§chen in Verarbeitung 3</a></li>
<li><a href="../de478554/index.html">Webinar "SRE - Hype oder die Zukunft?" 12. Dezember um 11:00 Uhr</a></li>
<li><a href="../de478560/index.html">Sind kostenlose Instant Messenger anonym?</a></li>
<li><a href="../de478564/index.html">Wie wir bei TsIAN Terabytes an Protokollen gez√§hmt haben</a></li>
<li><a href="../de478566/index.html">iOS Netzwerk, wenn die Anwendung nicht ausgef√ºhrt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>