<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👗 🧘🏽 📃 Sistem Media untuk Toyota Prius (Restayl) 👨‍👨‍👧‍👦 💮 🆑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel (pengantar) pertama dalam seri tentang bagaimana saya akan memperbaiki sistem media mobil. Proyek itu sendiri sedang dalam proses, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem Media untuk Toyota Prius (Restayl)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411617/"><img src="https://habrastorage.org/webt/pw/a0/k_/pwa0k_aaxeguedncth7a5fdkm70.jpeg"><br><br>  Ini adalah artikel (pengantar) pertama dalam seri tentang bagaimana saya akan memperbaiki sistem media mobil.  Proyek itu sendiri sedang dalam proses, tidak ada waktu, seperti orang lain, oleh karena itu, pembaca yang budiman, harap bersabar, karena saya sering tidak berjanji untuk memusatkan artikel. <br><br>  Semuanya dimulai dengan fakta bahwa saya memiliki Prius. <br><br>  Dan hal pertama yang menarik perhatian saya adalah masalah dengan memperbarui navigasi.  Berikut ini sangat sedikit, tetapi di beberapa tempat diperlukan fitur perangkat yang disebut "Tampilan Multifungsi" (pada orang umum - kepala).  Dan ini bertentangan dengan latar belakang sejumlah besar radio China dengan Android, dan banyak fasilitas lainnya.  Tetapi pemasangan mereka di tempat biasa menyiratkan tidak adanya "roti" seperti diagram distribusi energi dan kontrol iklim. <br><br>  Gagasan itu lahir untuk menghubungkan radio Android dengan mobil lebih erat dari yang disarankan saudara-saudara Tiongkok.  Tentang ini dan artikelnya. <br><a name="habracut"></a><br><h3>  Situasi awal </h3><br>  Jadi  Di papan ada sekitar layar 7 inci dengan layar sentuh resistif, terhubung ke elektronik lainnya dengan saluran TX + dan TX-.  Dan sudah ada 3 pasang dari kepala. Di sirkuit, keajaiban ini bernama AVC-LAN, dan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ml/uo/le/mluolei1uqdz85xpjdh43hxjyvk.png"><br><br><h2>  Bagian 1: Melihat sekeliling </h2><br>  Seperti yang Anda lihat, head berada di celah jaringan, antara router dan rantai radio, amplifier (saya memilikinya secara terpisah), dan saluran terpisah harus dihubungkan ke unit navigasi.  Di tempat lain, unit parkir mobil menggantung, tidak disebutkan dalam skema saya.  Baiklah, ya ... Saya memutuskan untuk menunda kedekatan dengannya sampai waktu yang lebih baik.  Selain itu, parkir lebih merupakan fungsi permainan daripada kebutuhan nyata. <br><br>  Setelah menghapus semua yang tidak perlu, kami mendapatkan kira-kira diagram blok perangkat berikut: <br><br><img src="https://habrastorage.org/webt/qb/az/gl/qbazglszcggkjhudk80w91l9tdg.png"><br><br><h3>  Refleksi </h3><br>  Ada ide untuk hanya mengganti unit navigasi dengan sesuatu yang android, tetapi mati ketika saya mengerti lebih dalam bagaimana mereka berkomunikasi dengan kepala.  Selain AVC-LAN, modul-modul ini juga dihubungkan oleh jalur GVIF (Gigabit Video InterFace), dan wajah yang sama dari produsen konverter ini dapat secara tidak sengaja retak jika saya juga membeli konverter sinyal video di GVIF dengan harga lebih dari $ 100. mungkin sulit, tapi .. "- terdengar di kepalaku pada motif lagu yang terkenal, dan aku tidak suka keputusannya. <br><br>  Ada solusi di jaringan dengan pemasangan radio Cina, bukan penerima radio.  Ini tidak cocok untuk saya karena kedua tampilan tersebut adalah redundansi yang tidak masuk akal.  IMHO. <br><br><h2>  Solusi </h2><br>  Solusi berikut telah lahir: ganti seluruh kepala, dan selesaikan radio android, berteman dengan Prius, di mana: <br><br><ol><li>  Desain USB &lt;-&gt; Konverter perangkat keras AVC-LAN </li><li>  Kembangkan firmware untuknya sehingga terhubung seperti USB-HID. </li><li>  Buatlah komposit sehingga salah satu fungsi terdeteksi seperti keyboard perangkat keras normal (untuk menggunakannya sebagai kontrol asli dari tombol-tombol pada panel) </li><li>  Kembangkan aplikasi Android dengan fungsi yang mirip dengan (atau lebih unggul) asli, Priusovsky </li><li>  Sejajarkan kamera belakang </li><li>  Memecahkan masalah di bagian mekanik (pemasangan di tempat biasa) </li></ol><br>  Dalam prosesnya, perlu untuk mengembangkan aplikasi lain untuk android - sniffer biasa, sehingga lebih mudah untuk membalikkan paket pada AVC-LAN.  Pada saat dan latihan yang sama. <br><br>  Seharusnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/_x/7j/f2/_x7jf2mr_9mp0ow3yxwds8yuhuc.png"><br><br>  Sebagai dasar perangkat keras, diputuskan untuk menggunakan papan pelatihan di SM32F103: <br><br><img src="https://habrastorage.org/webt/oo/u8/1y/oou81yrznrr2hcnayb2emjfb_lw.jpeg"><br><br>  Dipesan dengan AliExpress seharga $ 2.05. <br><br><div class="spoiler">  <b class="spoiler_title">Atau cari - spoiler</b> <div class="spoiler_text">  Mungkin lot sudah dihapus oleh penjual, jadi saya berikan string ajaib untuk mencari di Ali: <br>  STM32F103C8T6 ARM STM32 Modul Papan Pengembangan Sistem Minimum <br></div></div><br>  Apa yang saya sukai dari dia: <br><br><ul><li>  Modul perangkat keras USB (Perangkat) di papan prosesor </li><li>  Tumpukan USB yang memadai dari produsen (tidak seperti Freescale-ovsky, jangan diingat pada malam hari). </li><li>  Port GPIO gratis yang dapat digunakan untuk menghubungkan tombol biasa di sisi monitor.  Mungkin ini akan menyembunyikan tombol perangkat keras radio di bawah panel.  Saya tidak tahu dia akan jadi apa </li><li>  Dan di atasnya Anda dapat menggantung konverter AVC-LAN ke level logis </li></ul><br>  Saya akan menjelaskan lebih lanjut dalam urutan implementasi, yang karena, pertama-tama, untuk pengetahuan pribadi saya.  Yaitu  Saya mencoba untuk menyadari tempat-tempat di mana mereka tidak pada awalnya, pada akhirnya meninggalkan apa yang seharusnya terjadi. <br><br>  Bagaimanapun, beberapa artikel direncanakan di hub yang berbeda.  Proyek ini ternyata menjadi FullStack - dari koneksi perangkat keras ke aplikasi android. <br><br><h2>  Bagian 2: USB, HID, deskriptor, dan semua untuk mendapatkan prototipe pilot </h2><br>  Langkah pertama saya ingin mendapatkan banyak perangkat dan telepon, dan agar perangkat dapat mentransfer paket ke telepon, dan itu - untuk menampilkannya di aplikasi. <br>  Seperti yang dikatakan Gagarin: Ayo pergi! <br><br><h3>  Perangkat USB HID Composite pada STM32 </h3><br>  Apa yang saya putuskan untuk lakukan adalah mengadaptasi contoh ST dari tugas-tugas saya dan mendapatkan perangkat USB yang dikenali oleh tuan rumah sebagai bagian dari keyboard dan “sesuatu yang lain” - Perangkat RAW HID.  Yang pertama, seperti yang sudah saya katakan, ditujukan untuk kontrol Android asli, yang kedua - untuk pertukaran langsung paket AVC-LAN dengan program pada perangkat. <br><br>  Berdasarkan STM's CubeMX, dan setelah membaca banyak artikel tentang cara mengimplementasikan custom HID, saya menemukan satu hal yang tidak menyenangkan di jaringan: masalah membuat perangkat komposit praktis tidak ada atau sangat langka. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber nanti</b> <div class="spoiler_text">  Saya belum mengunggah kode sumber, karena fakta bahwa proyek sekarang sedang dilaksanakan dalam mode pelatihan eksperimental.  Jika proyek berhasil diselesaikan, pastikan untuk menyeret mereka ke Github dan mengedit artikel dengan tautan ke mereka. <br>  Dalam bentuk di mana mereka berada, tidak masuk akal untuk mengunggah - ada cukup banyak kekacauan di Internet tanpa saya. <br></div></div><br><h4>  USB, Komposit, HID </h4><br>  Hanya beberapa kata tentang hal ini.  Diasumsikan bahwa Anda kurang lebih akrab dengan standar USB.  Jika tidak, lebih baik membiasakan diri Anda dan bereksperimen dengan contoh-contoh dari CubeMX. <br><br>  Jadi kita punya: <br><br>  Contoh penerapan STM USB stack dan mouse.  Di sana kami telah mengkonfigurasi beberapa deskriptor dan titik akhir fungsional.  Ini merupakan tambahan untuk 0x00 dan 0x80 untuk mengendalikan seluruh perangkat. <br><br>  Untuk mengimplementasikan proyek saya, saya membutuhkan titik akhir keyboard menjadi dua arah (saya tidak tahu mengapa - ini berguna) dan beberapa titik akhir lainnya yang akan digunakan untuk bertukar data dengan fungsi kedua - RAW.  Tambahkan mereka. <br><br>  Kami membuat titik dua arah dengan menambahkan titik OUT ke deskriptor: <br><br><div class="spoiler">  <b class="spoiler_title">Deskriptor konfigurasi.</b> <div class="spoiler_text">  Saat mengedit deskriptor, perhatikan indeks dan ukuran. <br>  (2c5cf968121f0d8fa43a6755c09e15ef3a317791): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPOUT_ADDR, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPOUT_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL,</code> </pre> <br></div></div><br>  Dan tambahkan beberapa poin lagi: <br><br><div class="spoiler">  <b class="spoiler_title">Deskriptor konfigurasi</b> <div class="spoiler_text">  (bc2bd583c98715e106fcb3ab07b266bc9221be36): <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* 59 */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPIN_ADDR2, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPIN_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL, <span class="hljs-comment"><span class="hljs-comment">/*bInterval: Polling Interval (10 ms)*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 66 */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength: Endpoint Descriptor size*/</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType:*/</span></span> HID_EPOUT_ADDR2, <span class="hljs-comment"><span class="hljs-comment">/*bEndpointAddress: Endpoint Address (IN)*/</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bmAttributes: Interrupt endpoint*/</span></span> HID_EPOUT_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*wMaxPacketSize: 4 Byte max */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, HID_FS_BINTERVAL, <span class="hljs-comment"><span class="hljs-comment">/*bInterval: Polling Interval (10 ms)*/</span></span></code> </pre><br></div></div><br>  Itu adalah deskriptor konfigurasi.  Sekarang tuan rumah akan yakin bahwa kita memiliki semacam perangkat HID komposit, dan Anda dapat mengirim data ke semua titik ini.  Tapi ini tidak benar. <br>  Untuk mewujudkannya: <br><br>  1. Pengontrol kami memiliki bagian memori yang dialokasikan secara khusus yang dilengkapi dengan modul CAN dan USB.  Karena modul USB terlibat secara independen dalam proses penerimaan / pengiriman paket data, Anda perlu mengatur buffer dalam memori ini untuk setiap titik akhir individu: <br><br><div class="spoiler">  <b class="spoiler_title">USBD_LL_Init dalam file usbd_conf.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x00</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x18</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x80</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x58</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPOUT_ADDR , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPIN_ADDR , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x140</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPOUT_ADDR2 , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x180</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , HID_EPIN_ADDR2 , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x1B0</span></span>);</code> </pre><br></div></div><br>  Alamat penyangga bersifat arbitrer, jika saja mereka tidak akan tumpang tindih. <br><br>  Untuk beberapa alasan, tumpukan ST ditulis dengan harapan bahwa perangkat tidak akan memiliki lebih dari satu titik akhir dua arah, jadi kami akan sedikit memodifikasi tumpukan: <br><br><h4>  Transfer </h4><br>  Ubah nama prosedur USBD_HID_SendReport menjadi USBD_HID_SendReportEP, tambahkan satu parameter lagi - angka titik akhir.  Kami meninggalkan prosedur dengan nama lama untuk kompatibilitas ke belakang, tetapi dalam tubuh kami memanggil USBD_HID_SendReportEP dengan konstanta dalam bentuk titik akhir.  Solusinya masih bukan yang paling estetis, tetapi akan berhasil untuk percobaan, dan bahkan jika tetap, itu tidak akan mengganggu proyek tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">usbd_hid.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_HID_SendReportEP (USBD_HandleTypeDef *pdev, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ep, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *report, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len) { ... ,   USBD_HID_SendReport } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_HID_SendReport (USBD_HandleTypeDef *pdev, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *report, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_HID_SendReportEP(pdev,HID_EPIN_ADDR,report,len); }</code> </pre><br></div></div><br>  Sekarang semuanya siap untuk mengirim data, tetap saja pada waktu yang tepat untuk memanggil fungsi ini. <br><br><h4>  Finalisasi </h4><br>  Demi pesanan, kami mencari proyek dan memanggil USBD_LL_CloseEP lagi, tetapi untuk titik akhir yang baru dibuat. <br><br><h4>  Penerimaan </h4><br>  Agar titik akhir disetel secara moral agar berfungsi, Anda perlu menghubungi USBD_LL_PrepareReceive untuk mereka.  Saya sarankan pembaca untuk pergi mencari proyek untuk baris ini, dan menyesuaikan panggilan ini dengan kebutuhan Anda. <br><br>  Saya mendapatkan cumi-cumi jelek ini dalam kode saya: <br><br><div class="spoiler">  <b class="spoiler_title">usbd_core.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs">USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR+(epnum&amp;<span class="hljs-number"><span class="hljs-number">0x7F</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span> , hhid-&gt;Report_buf, USBD_HID_OUTREPORT_BUF_SIZE);</code> </pre><br></div></div><br>  Yaitu  Saya melanjutkan dari fakta bahwa jumlah titik akhir berturut-turut.  Ini buruk, IMHO.  Jangan lakukan itu.  Namun, jangan suka ST juga. <br><br>  Yang tersisa adalah pergi ke file usbd_hid.c, dan secara khusus ke fungsi USBD_HID_DataOut, dan pastikan bahwa panggilan ke penangan data yang diterima cocok dengan ide pribadi Anda tentang yang indah.  Saya tidak berhasil juga, jadi kode dan uraiannya akan panjang dan tidak bisa dipahami.  Lebih mudah melakukannya sendiri. <br><br><h4>  Laporkan </h4><br>  Semuanya, di tempat ini kami mendapat perangkat komposit yang mampu bertukar data melalui dua titik dua arah.  Pada langkah terakhir, kami "tutup mulut" keingintahuan pengemudi HID, menggambarkan deskriptor laporan seperti itu: <br><br><pre> <code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> HID_ReportDesc2[<span class="hljs-number"><span class="hljs-number">33</span></span>] __ALIGN_END = { <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE_PAGE (Vendor Defined Page 1) 0x09, 0x01, // USAGE (Vendor Usage 1) 0xa1, 0x01, // COLLECTION (Application) 0x85, 0x01, // REPORT_ID (1) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x26, 0xff, 0x00, // LOGICAL_MAXIMUM (255) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x1f, // REPORT_COUNT (31) 0x09, 0x00, // USAGE (Undefined) 0x81, 0x00, // INPUT (Data,Ary,Abs) 0x85, 0x02, // REPORT_ID (2) 0x09, 0x01, // USAGE (Vendor Usage 1) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x1f, // REPORT_COUNT (31) 0x91, 0x00, // OUTPUT (Data,Ary,Abs) 0xc0 // END_COLLECTION };</span></span></code> </pre><br>  Laporan ini memberi tahu driver HID: akan ada sekitar 31 byte data.  Tidak perlu mencari tahu apa itu - berikan saja pada program yang membuka perangkat ini.  Dalam laporan fisik, byte nol akan sama dengan indeks laporan (REPORT_ID (2)).  Dengan demikian, total 32 byte akan datang. <br><br>  Dan masukkan data tentang hal itu di usbd-hid.c, fungsi USBD_HID_Setup.: <br><br><div class="spoiler">  <b class="spoiler_title">usbd-hid.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (req-&gt;bRequest) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_DESCRIPTOR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;wValue &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> == HID_REPORT_DESC) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> !!!   ,     req-&gt;wIndex !!! THIDDescPtrLen * rep = (req-&gt;wIndex==1)?&amp;HID_ReportDesc:&amp;HID_ReportDesc2; len = MIN(rep-&gt;len , req-&gt;wLength); pbuf = rep-&gt;ptr; }</span></span></code> </pre></div></div><br><h3>  Lebih lanjut dalam program ini: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perakitan konverter level logika AVC-LAN, dan koneksi ke board.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis lapisan fisik AVC-LAN, bentuk gelombang nyata.</a> </li><li>  Memproses antarmuka di tingkat pengontrol dan mengirim paket dengan laporan </li><li>  Antarmuka ujung ke ujung dan rekayasa terbalik Prius.  Package Sniffer (atau aplikasi Android pertama saya) </li></ol><br><h4>  PS </h4><br><ul><li>  Saya memutuskan untuk menulis artikel karena saya dipaksa (hampir), meyakinkan bahwa ini harus dibagikan.  Bahkan jika saya tidak menyelesaikan proyek, beberapa informasi terbaru dapat membantu seseorang bahkan dengan cara "mentah". </li><li>  Kritik terhadap proyek ini disambut baik  Saya sendiri belum sepenuhnya membayangkan bahwa itu akan berhasil. </li><li>  Kritik terhadap artikel, desain, presentasi - terutama, karena  Ini adalah artikel pertama untuk sumber tersebut.  Dengan kelanjutan karya ini, saya ingin mengekspresikan pikiran saya dalam bentuk yang biasa dan dapat dicerna untuk pembaca </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id411617/">https://habr.com/ru/post/id411617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id411603/index.html">Bagaimana Nike 3D Mencetak Sepatu Lari Unik untuk Pelari Elite</a></li>
<li><a href="../id411605/index.html">"THIS_". Bagaimana kantor perusahaan IT Kuzbass diatur</a></li>
<li><a href="../id411609/index.html">5 foto NASA yang mengubah dunia</a></li>
<li><a href="../id411611/index.html">Hukum Musim Semi-Ozerov - dari kata-kata hingga perbuatan</a></li>
<li><a href="../id411613/index.html">Clash of the Titans: membandingkan pembaca andalan PocketBook 740 dan Amazon Kindle Oasis 2017</a></li>
<li><a href="../id411621/index.html">SpaceX akan membangun Big Fucking Rocket di Los Angeles</a></li>
<li><a href="../id411623/index.html">Para ilmuwan telah menciptakan enzim yang memecah plastik</a></li>
<li><a href="../id411625/index.html">Radio-86RK pada ESP-01S</a></li>
<li><a href="../id411629/index.html">Bagaimana kami memulihkan jadwal bus antarkota</a></li>
<li><a href="../id411631/index.html">Telegram di Rusia mungkin diblokir karena rencana Durov untuk meluncurkan mata uang kripto sendiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>