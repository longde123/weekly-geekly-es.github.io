<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💛 🕋 🤾🏼 Menentukan jenis anjing: siklus pengembangan penuh, dari jaringan saraf dengan Python ke aplikasi di Google Play 🍸 🏟️ 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kemajuan di bidang jaringan saraf pada umumnya dan pengenalan pola pada khususnya telah mengarah pada fakta bahwa mungkin tampak seolah-olah membuat a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menentukan jenis anjing: siklus pengembangan penuh, dari jaringan saraf dengan Python ke aplikasi di Google Play</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448316/">  Kemajuan di bidang jaringan saraf pada umumnya dan pengenalan pola pada khususnya telah mengarah pada fakta bahwa mungkin tampak seolah-olah membuat aplikasi jaringan saraf untuk bekerja dengan gambar adalah tugas rutin.  Dalam arti tertentu, itu adalah - jika Anda menemukan ide yang berkaitan dengan pengenalan pola, jangan ragu bahwa seseorang sudah menulis sesuatu seperti itu.  Yang Anda butuhkan hanyalah menemukan bagian kode yang sesuai di Google dan "kompilasi" dari penulis. <br><br>  Namun, masih ada banyak detail yang membuat tugas ini tidak begitu sulit dipecahkan seperti ... membosankan, menurut saya.  Butuh terlalu banyak waktu, terutama jika Anda seorang pemula yang membutuhkan kepemimpinan, selangkah demi selangkah, proyek yang dilakukan tepat di depan mata Anda, dan selesai dari awal hingga selesai.  Tanpa biasa dalam kasus seperti itu, "lewati bagian yang jelas ini" alasan. <br><br>  Dalam artikel ini, kami akan mempertimbangkan tugas membuat Dog Breed Identifier: kami akan membuat dan melatih jaringan saraf, dan kemudian port ke Java untuk Android dan mempublikasikannya di Google Play. <br><br>  Jika Anda ingin melihat hasil akhirnya, ini dia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi NeuroDog</a> di Google Play. <br><br>  Situs web dengan robotika saya (sedang berlangsung): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">robotics.snowcron.com</a> . <br>  Situs web dengan program itu sendiri, termasuk panduan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pengguna NeuroDog</a> . <br><br>  Dan di sini adalah tangkapan layar program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/b91/457/186b914572170b01446ed1d722bce200.png" alt="gambar"><br><br><a name="habracut"></a><br><br><h3>  Pernyataan masalah </h3><br><br>  Kami akan menggunakan Keras: perpustakaan Google untuk bekerja dengan jaringan saraf.  Ini adalah perpustakaan tingkat tinggi, yang berarti lebih mudah digunakan dibandingkan dengan alternatif yang saya tahu.  Jika ada - ada banyak buku teks tentang Keras di jaringan, berkualitas tinggi. <br><br>  Kami akan menggunakan CNN - Convolutional Neural Networks.  CNN (dan lebih banyak konfigurasi lanjutan berdasarkan pada mereka) adalah standar de facto dalam pengenalan gambar.  Pada saat yang sama, melatih jaringan seperti itu tidak selalu mudah: Anda harus memilih struktur jaringan yang tepat, parameter pelatihan (semua tingkat pembelajaran, momentum, L1 dan L2, dll.).  Tugas ini membutuhkan sumber daya komputasi yang signifikan, dan karenanya, untuk menyelesaikannya hanya dengan melalui SEMUA parameter akan gagal. <br><br>  Ini adalah salah satu dari beberapa alasan mengapa dalam kebanyakan kasus mereka menggunakan apa yang disebut “pengetahuan transfer”, alih-alih apa yang disebut pendekatan “vanila”.  Transfer Knowlege menggunakan jaringan saraf yang dilatih oleh seseorang sebelum kita (misalnya, Google) dan biasanya untuk tugas yang serupa, tetapi masih berbeda.  Kami mengambil layer awal darinya, mengganti layer terakhir dengan classifier kita sendiri - dan itu berfungsi, dan itu berfungsi dengan baik. <br><br>  Pada awalnya, hasil seperti itu mungkin mengejutkan: bagaimana kita mengambil jaringan Google yang terlatih untuk membedakan kucing dari kursi, dan ia mengenali jenis anjing untuk kita?  Untuk memahami bagaimana ini terjadi, Anda perlu memahami prinsip-prinsip dasar karya Deep Neural Networks, termasuk yang digunakan untuk pengenalan pola. <br><br>  Kami “memberi makan” jaringan gambar (array angka, yaitu) sebagai input.  Lapisan pertama menganalisis gambar untuk pola-pola sederhana, seperti "garis horizontal", "busur", dll.  Lapisan berikutnya menerima pola-pola ini sebagai input, dan menghasilkan pola orde kedua, seperti "bulu", "sudut mata" ... Pada akhirnya, kita mendapatkan teka-teki dari mana kita dapat merekonstruksi anjing: wol, dua mata, dan tangan manusia bergigi. <br><br>  Semua hal di atas dilakukan dengan bantuan lapisan pra-terlatih yang kami peroleh (misalnya, dari Google).  Selanjutnya, kami menambahkan layer kami, dan mengajar mereka untuk mengekstrak informasi breed dari pola ini.  Kedengarannya logis. <br><br>  Sebagai rangkuman, dalam artikel ini kita akan membuat "vanilla" CNN dan beberapa varian "transfer learning" dari berbagai jenis jaringan.  Adapun "vanilla": Saya akan membuatnya, tetapi saya tidak berencana untuk mengkonfigurasinya dengan memilih parameter, karena jauh lebih mudah untuk melatih dan mengonfigurasi jaringan "pra-terlatih". <br><br>  Karena kami berencana untuk mengajarkan jaringan saraf kami untuk mengenali ras anjing, kami harus “menunjukkan” sampel dari berbagai ras.  Untungnya, ada satu set foto yang dibuat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> untuk tugas yang sama ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya ada di sini</a> ). <br><br>  Kemudian saya berencana untuk port yang terbaik dari jaringan yang diterima untuk android.  Porting jaringan Kerasov ke android relatif sederhana, diformalkan dengan baik dan kami akan melakukan semua langkah yang diperlukan, sehingga tidak akan sulit untuk mereproduksi bagian ini. <br><br>  Kemudian kami akan menerbitkan semua ini di Google Play.  Secara alami, Google akan menolak, jadi trik tambahan akan digunakan.  Misalnya, ukuran aplikasi kita (karena jaringan saraf besar) akan lebih besar daripada ukuran yang diizinkan dari APK Android yang diterima oleh Google Play: kita harus menggunakan bundel.  Selain itu, Google tidak akan menampilkan aplikasi kami di hasil pencarian, ini dapat diperbaiki dengan mendaftarkan tag pencarian di aplikasi, atau hanya menunggu ... satu atau dua minggu. <br><br>  Sebagai hasilnya, kami mendapatkan aplikasi "komersial" yang berfungsi penuh (dalam tanda kutip, sebagaimana dinyatakan gratis) untuk android dan menggunakan jaringan saraf. <br><br><h3>  Lingkungan pengembangan </h3><br><br>  Anda dapat memprogram untuk Keras secara berbeda, tergantung pada OS yang Anda gunakan (disarankan Ubuntu), ada atau tidak adanya kartu video, dan sebagainya.  Tidak ada yang buruk dalam pengembangan di komputer lokal (dan, karenanya, konfigurasinya), kecuali bahwa ini bukan cara termudah. <br><br>  Pertama, menginstal dan mengonfigurasi sejumlah besar alat dan pustaka membutuhkan waktu, dan kemudian ketika versi baru dirilis, Anda harus menghabiskan waktu lagi.  Kedua, jaringan saraf membutuhkan daya komputasi yang besar untuk pelatihan.  Anda dapat mempercepat (10 kali atau lebih) proses ini jika Anda menggunakan GPU ... pada saat menulis artikel ini, GPU teratas yang paling cocok untuk pekerjaan ini adalah $ 2.000 - $ 7.000.  Dan ya, mereka juga perlu dikonfigurasi. <br><br>  Jadi kita akan pergi ke arah lain.  Faktanya adalah bahwa Google memungkinkan landak miskin seperti kita untuk menggunakan GPU dari cluster mereka - gratis, untuk perhitungan yang berkaitan dengan jaringan saraf, itu juga menyediakan lingkungan yang sepenuhnya dikonfigurasi, bersama-sama, ini disebut Google Colab.  Layanan ini memberi Anda akses ke Jupiter Notebook dengan python, Keras dan sejumlah besar perpustakaan lain sudah dikonfigurasi.  Yang harus Anda lakukan adalah mendapatkan akun Google (dapatkan akun Gmail dan ini akan memberi Anda akses ke yang lainnya). <br><br>  Saat ini, Colab dapat disewa di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi mengetahui Google, ini dapat berubah setiap saat.  Hanya google Google Colab. <br><br>  Masalah yang jelas dengan menggunakan Colab adalah itu adalah layanan WEB.  Bagaimana kita mengakses data kita?  Simpan jaringan saraf setelah pelatihan, misalnya, mengunduh data khusus untuk tugas kita dan seterusnya? <br><br>  Ada beberapa (pada saat penulisan artikel ini - tiga) cara yang berbeda, kami menggunakan yang menurut saya paling nyaman - kami menggunakan Google Drive. <br><br>  Google Drive adalah penyimpanan data berbasis cloud yang berfungsi seperti hard drive biasa, dan dapat dipetakan di Google Colab (lihat kode di bawah).  Setelah itu, Anda dapat bekerja dengannya seperti halnya Anda bekerja dengan file pada disk lokal.  Misalnya, untuk mengakses foto-foto anjing untuk melatih jaringan saraf kita, kita perlu mengunggahnya ke Google Drive, itu saja. <br><br><h2>  Membuat dan melatih jaringan saraf </h2><br><br>  Di bawah ini saya berikan kode dengan Python, blok demi blok (dari Notebook Jupiter).  Anda dapat menyalin kode ini ke dalam Notebook Jupiter Anda dan menjalankannya, blok demi blok, juga, karena blok dapat dieksekusi secara independen (tentu saja, variabel yang ditentukan dalam blok awal mungkin diperlukan di bagian akhir, tetapi ini adalah ketergantungan yang jelas). <br><br><h3>  Inisialisasi </h3><br><br>  Pertama-tama, mari kita pasang Google Drive.  Hanya dua baris.  Kode ini harus dieksekusi hanya sekali dalam sesi Colab (katakanlah, setiap 6 jam sekali).  Jika Anda menyebutnya kedua kalinya saat sesi masih "hidup", itu akan dilewati karena drive sudah terpasang. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.colab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> drive drive.mount(<span class="hljs-string"><span class="hljs-string">'/content/drive/'</span></span>)</code> </pre> <br><br>  Pada awal pertama, Anda akan diminta untuk mengkonfirmasi niat Anda, tidak ada yang rumit.  Begini tampilannya: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Go to this URL <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a browser: ... &gt;&gt;&gt; Enter your authorization code: &gt;&gt;&gt; ·········· &gt;&gt;&gt; Mounted at /content/drive/</code> </pre><br><br>  Bagian <i>termasuk</i> sepenuhnya standar;  mungkin beberapa file yang disertakan tidak diperlukan, well ... maaf.  Juga, karena saya akan menguji jaringan saraf yang berbeda, Anda harus berkomentar / menghapus komentar beberapa modul yang disertakan untuk jenis jaringan saraf tertentu: misalnya, untuk menggunakan InceptionV3 NN, batalkan komentar pada inklusi InceptionV3, dan komentar, misalnya, ResNet50.  Atau tidak: semua yang berubah dari ini adalah ukuran memori yang digunakan, dan itu tidak terlalu kuat. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tqdm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tqdm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> warnings <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> backend <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> K <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> regularizers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sequential <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dense, Dropout, Activation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flatten, Conv2D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MaxPooling2D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BatchNormalization, Input <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dropout, GlobalAveragePooling2D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.callbacks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Callback, EarlyStopping <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.callbacks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReduceLROnPlateau <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.callbacks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ModelCheckpoint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.vgg16 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preprocess_input <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageDataGenerator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> load_model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.resnet50 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ResNet50 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.resnet50 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preprocess_input <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.resnet50 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode_predictions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> inception_v3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.inception_v3 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> InceptionV3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.inception_v3 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preprocess_input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> inception_v3_preprocessor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.mobilenetv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MobileNetV2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.applications.nasnet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NASNetMobile</code> </pre><br><br>  Di Google Drive, kami membuat folder untuk file kami.  Baris kedua menampilkan isinya: <br><br><pre> <code class="python hljs">working_path = <span class="hljs-string"><span class="hljs-string">"/content/drive/My Drive/DeepDogBreed/data/"</span></span> !ls <span class="hljs-string"><span class="hljs-string">"/content/drive/My Drive/DeepDogBreed/data"</span></span> &gt;&gt;&gt; all_images labels.csv models test train valid</code> </pre><br><br>  Seperti yang Anda lihat, foto-foto anjing (disalin dari dataset Stanford (lihat di atas) di Google Drive) pertama kali disimpan di folder <i>all_images</i> .  Nantinya, kami akan menyalinnya ke direktori <i>kereta, valid,</i> dan <i>uji</i> .  Kami akan menyimpan model yang terlatih dalam folder <i>model</i> .  Adapun file labels.csv, ini adalah bagian dari dataset dengan foto, ini berisi daftar korespondensi nama gambar dan trah anjing. <br><br>  Ada banyak tes yang dapat Anda jalankan untuk memahami apa sebenarnya yang kami dapatkan untuk penggunaan sementara dari Google.  Sebagai contoh: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Is GPU Working? import tensorflow as tf tf.test.gpu_device_name() &gt;&gt;&gt; '/device:GPU:0'</span></span></code> </pre><br><br>  Seperti yang Anda lihat, GPU benar-benar terhubung, dan jika tidak, Anda perlu menemukan dan mengaktifkan opsi ini di pengaturan Notebook Jupiter. <br><br>  Selanjutnya, kita perlu mendeklarasikan beberapa konstanta, seperti ukuran gambar, dll.  Kami akan menggunakan gambar dengan ukuran 256x256 piksel, ini adalah gambar yang cukup besar agar tidak kehilangan detail, dan cukup kecil sehingga semuanya pas di memori.  Namun, perlu diketahui bahwa beberapa jenis jaringan saraf yang akan kita gunakan mengharapkan gambar 224x224 piksel.  Dalam kasus seperti itu, kami berkomentar 256 dan menghapus komentar 224. <br><br>  Pendekatan yang sama (komentar satu - batalkan komentar) akan diterapkan pada nama model yang kita simpan, hanya karena kita tidak ingin menimpa file yang mungkin masih berguna. <br><pre> <code class="python hljs">warnings.filterwarnings(<span class="hljs-string"><span class="hljs-string">"ignore"</span></span>) os.environ[<span class="hljs-string"><span class="hljs-string">'TF_CPP_MIN_LOG_LEVEL'</span></span>] = <span class="hljs-string"><span class="hljs-string">'2'</span></span> np.random.seed(<span class="hljs-number"><span class="hljs-number">7</span></span>) start = dt.datetime.now() BATCH_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span> EPOCHS = <span class="hljs-number"><span class="hljs-number">15</span></span> TESTING_SPLIT=<span class="hljs-number"><span class="hljs-number">0.3</span></span> <span class="hljs-comment"><span class="hljs-comment"># 70/30 % NUM_CLASSES = 120 IMAGE_SIZE = 256 #strModelFileName = "models/ResNet50.h5" # strModelFileName = "models/InceptionV3.h5" strModelFileName = "models/InceptionV3_Sgd.h5" #IMAGE_SIZE = 224 #strModelFileName = "models/MobileNetV2.h5" #IMAGE_SIZE = 224 #strModelFileName = "models/NASNetMobileSgd.h5"</span></span></code> </pre><br><br><h3>  Pemuatan data </h3><br><br>  Pertama-tama, mari kita <i>unggah</i> file <i>labels.csv</i> dan <i>pisahkan</i> ke bagian pelatihan dan validasi.  Perhatikan bahwa belum ada bagian pengujian, karena saya akan menipu untuk mendapatkan lebih banyak data pelatihan. <br><br><pre> <code class="python hljs">labels = pd.read_csv(working_path + <span class="hljs-string"><span class="hljs-string">'labels.csv'</span></span>) print(labels.head()) train_ids, valid_ids = train_test_split(labels, test_size = TESTING_SPLIT) print(len(train_ids), <span class="hljs-string"><span class="hljs-string">'train ids'</span></span>, len(valid_ids), <span class="hljs-string"><span class="hljs-string">'validation ids'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Total'</span></span>, len(labels), <span class="hljs-string"><span class="hljs-string">'testing images'</span></span>) &gt;&gt;&gt; id breed &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>bec180eb18c7604dcecc8fe0dba07 boston_bull &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">001513</span></span>dfcb2ffafc82cccf4d8bbaba97 dingo &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">001</span></span>cdf01b096e06d78e9e5112d419397 pekinese &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">00214</span></span>f311d5d2247d5dfe4fe24b2303d bluetick &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0021</span></span>f9ceb3235effd7fcde7f7538ed62 golden_retriever &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">7155</span></span> train ids <span class="hljs-number"><span class="hljs-number">3067</span></span> validation ids &gt;&gt;&gt; Total <span class="hljs-number"><span class="hljs-number">10222</span></span> testing images</code> </pre><br><br>  Selanjutnya, salin file gambar ke folder pelatihan / validasi / pengujian, sesuai dengan nama file.  Fungsi berikut menyalin file yang namanya kami transfer ke folder yang ditentukan. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyFileSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strDirFrom, strDirTo, arrFileNames)</span></span></span><span class="hljs-function">:</span></span> arrBreeds = np.asarray(arrFileNames[<span class="hljs-string"><span class="hljs-string">'breed'</span></span>]) arrFileNames = np.asarray(arrFileNames[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(strDirTo): os.makedirs(strDirTo) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tqdm(range(len(arrFileNames))): strFileNameFrom = strDirFrom + arrFileNames[i] + <span class="hljs-string"><span class="hljs-string">".jpg"</span></span> strFileNameTo = strDirTo + arrBreeds[i] + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + arrFileNames[i] + <span class="hljs-string"><span class="hljs-string">".jpg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(strDirTo + arrBreeds[i] + <span class="hljs-string"><span class="hljs-string">"/"</span></span>): os.makedirs(strDirTo + arrBreeds[i] + <span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># As a new breed dir is created, copy 1st file # to "test" under name of that breed if not os.path.exists(working_path + "test/"): os.makedirs(working_path + "test/") strFileNameTo = working_path + "test/" + arrBreeds[i] + ".jpg" shutil.copy(strFileNameFrom, strFileNameTo) shutil.copy(strFileNameFrom, strFileNameTo)</span></span></code> </pre><br><br>  Seperti yang Anda lihat, kami hanya menyalin satu file untuk setiap trah anjing sebagai <i>tes</i> .  Juga, saat menyalin, kami membuat subfolder, satu untuk setiap trah.  Oleh karena itu, foto-foto disalin ke subfolder oleh breed. <br><br>  Ini dilakukan karena Keras dapat bekerja dengan direktori dengan struktur yang sama, memuat file gambar sesuai kebutuhan, dan tidak sekaligus, yang menghemat memori.  Mengunggah semua 15.000 gambar sekaligus adalah ide yang buruk. <br><br>  Kami harus memanggil fungsi ini hanya sekali, karena ini menyalin gambar - dan tidak lagi diperlukan.  Karenanya, untuk penggunaan di masa mendatang, kita harus mengomentarinya: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Move the data in subfolders so we can # use the Keras ImageDataGenerator. # This way we can also later use Keras # Data augmentation features. # --- Uncomment once, to copy files --- #copyFileSet(working_path + "all_images/", # working_path + "train/", train_ids) #copyFileSet(working_path + "all_images/", # working_path + "valid/", valid_ids)</span></span></code> </pre><br><br>  Dapatkan daftar trah anjing: <br><br><pre> <code class="python hljs">breeds = np.unique(labels[<span class="hljs-string"><span class="hljs-string">'breed'</span></span>]) map_characters = {} <span class="hljs-comment"><span class="hljs-comment">#{0:'none'} for i in range(len(breeds)): map_characters[i] = breeds[i] print("&lt;item&gt;" + breeds[i] + "&lt;/item&gt;") &gt;&gt;&gt; &lt;item&gt;affenpinscher&lt;/item&gt; &gt;&gt;&gt; &lt;item&gt;afghan_hound&lt;/item&gt; &gt;&gt;&gt; &lt;item&gt;african_hunting_dog&lt;/item&gt; &gt;&gt;&gt; &lt;item&gt;airedale&lt;/item&gt; &gt;&gt;&gt; &lt;item&gt;american_staffordshire_terrier&lt;/item&gt; &gt;&gt;&gt; &lt;item&gt;appenzeller&lt;/item&gt;</span></span></code> </pre><br><br><h3>  Pemrosesan gambar </h3><br><br>  Kita akan menggunakan fitur pustaka Keras yang disebut ImageDataGenerators.  ImageDataGenerator dapat memproses gambar, skala, memutar, dan sebagainya.  Itu juga dapat menerima fungsi <i>pemrosesan</i> yang dapat memproses gambar tambahan. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img)</span></span></span><span class="hljs-function">:</span></span> img = cv2.resize(img, (IMAGE_SIZE, IMAGE_SIZE), interpolation = cv2.INTER_AREA) <span class="hljs-comment"><span class="hljs-comment"># or use ImageDataGenerator( rescale=1./255... img_1 = image.img_to_array(img) img_1 = cv2.resize(img_1, (IMAGE_SIZE, IMAGE_SIZE), interpolation = cv2.INTER_AREA) img_1 = np.expand_dims(img_1, axis=0) / 255. #img = cv2.blur(img,(5,5)) return img_1[0]</span></span></code> </pre><br><br>  Perhatikan kode berikut: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># or use ImageDataGenerator( rescale=1./255...</span></span></code> </pre><br><br>  Kita dapat menormalkan (sub-data di bawah rentang 0-1 alih-alih yang asli 0-255) di ImageDataGenerator itu sendiri.  Lalu mengapa kita membutuhkan preprosesor?  Sebagai contoh, pertimbangkan panggilan kabur (dikomentari, saya tidak menggunakannya): ini adalah manipulasi gambar khusus yang sama yang dapat arbitrer.  Apa pun yang kontras dengan HDR. <br><br>  Kami akan menggunakan dua ImageDataGenerators yang berbeda, satu untuk pelatihan dan satu untuk validasi.  Perbedaannya adalah bahwa untuk pelatihan kita perlu belokan dan penskalaan untuk meningkatkan "variasi" data, tetapi untuk validasi, kita tidak membutuhkannya, setidaknya tidak dalam tugas ini. <br><br><pre> <code class="python hljs">train_datagen = ImageDataGenerator( preprocessing_function=preprocess, <span class="hljs-comment"><span class="hljs-comment">#rescale=1./255, # done in preprocess() # randomly rotate images (degrees, 0 to 30) rotation_range=30, # randomly shift images horizontally # (fraction of total width) width_shift_range=0.3, height_shift_range=0.3, # randomly flip images horizontal_flip=True, ,vertical_flip=False, zoom_range=0.3) val_datagen = ImageDataGenerator( preprocessing_function=preprocess) train_gen = train_datagen.flow_from_directory( working_path + "train/", batch_size=BATCH_SIZE, target_size=(IMAGE_SIZE, IMAGE_SIZE), shuffle=True, class_mode="categorical") val_gen = val_datagen.flow_from_directory( working_path + "valid/", batch_size=BATCH_SIZE, target_size=(IMAGE_SIZE, IMAGE_SIZE), shuffle=True, class_mode="categorical")</span></span></code> </pre><br><br><h3>  Menciptakan jaringan saraf </h3><br><br>  Seperti yang telah disebutkan, kita akan membuat beberapa jenis jaringan saraf.  Setiap kali kita memanggil fungsi lain untuk dibuat, sertakan file lain dan kadang-kadang menentukan ukuran gambar yang berbeda.  Jadi, untuk beralih di antara berbagai jenis jaringan saraf, kita harus mengomentari / menghapus komentar kode yang sesuai. <br><br>  Pertama-tama, buat CNN "vanilla".  Itu tidak berfungsi dengan baik, karena saya memutuskan untuk tidak membuang waktu men-debug-nya, tetapi setidaknya itu memberikan dasar yang dapat dikembangkan jika ada keinginan (biasanya ini adalah ide yang buruk, karena jaringan pra-terlatih memberikan hasil terbaik). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModelVanilla</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model = Sequential() <span class="hljs-comment"><span class="hljs-comment"># Note the (7, 7) here. This is one of technics # used to reduce memory use by the NN: we scan # the image in a larger steps. # Also note regularizers.l2: this technic is # used to prevent overfitting. The "0.001" here # is an empirical value and can be optimized. model.add(Conv2D(16, (7, 7), padding='same', use_bias=False, input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3), kernel_regularizer=regularizers.l2(0.001))) # Note the use of a standard CNN building blocks: # Conv2D - BatchNormalization - Activation # MaxPooling2D - Dropout # The last two are used to avoid overfitting, also, # MaxPooling2D reduces memory use. model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), padding='same')) model.add(Dropout(0.5)) model.add(Conv2D(16, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(1, 1), padding='same')) model.add(Dropout(0.5)) model.add(Conv2D(32, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(Dropout(0.5)) model.add(Conv2D(32, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(1, 1), padding='same')) model.add(Dropout(0.5)) model.add(Conv2D(64, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(Dropout(0.5)) model.add(Conv2D(64, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(1, 1), padding='same')) model.add(Dropout(0.5)) model.add(Conv2D(128, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(Dropout(0.5)) model.add(Conv2D(128, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(1, 1), padding='same')) model.add(Dropout(0.5)) model.add(Conv2D(256, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(Dropout(0.5)) model.add(Conv2D(256, (3, 3), padding='same', use_bias=False, kernel_regularizer=regularizers.l2(0.01))) model.add(BatchNormalization(axis=3, scale=False)) model.add(Activation("relu")) model.add(MaxPooling2D(pool_size=(2, 2), strides=(1, 1), padding='same')) model.add(Dropout(0.5)) # This is the end on "convolutional" part of CNN. # Now we need to transform multidementional # data into one-dim. array for a fully-connected # classifier: model.add(Flatten()) # And two layers of classifier itself (plus an # Activation layer in between): model.add(Dense(NUM_CLASSES, activation='softmax', kernel_regularizer=regularizers.l2(0.01))) model.add(Activation("relu")) model.add(Dense(NUM_CLASSES, activation='softmax', kernel_regularizer=regularizers.l2(0.01))) # We need to compile the resulting network. # Note that there are few parameters we can # try here: the best performing one is uncommented, # the rest is commented out for your reference. #model.compile(optimizer='rmsprop', # loss='categorical_crossentropy', # metrics=['accuracy']) #model.compile( # optimizer=keras.optimizers.RMSprop(lr=0.0005), # loss='categorical_crossentropy', # metrics=['accuracy']) model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy']) #model.compile(optimizer='adadelta', # loss='categorical_crossentropy', # metrics=['accuracy']) #opt = keras.optimizers.Adadelta(lr=1.0, # rho=0.95, epsilon=0.01, decay=0.01) #model.compile(optimizer=opt, # loss='categorical_crossentropy', # metrics=['accuracy']) #opt = keras.optimizers.RMSprop(lr=0.0005, # rho=0.9, epsilon=None, decay=0.0001) #model.compile(optimizer=opt, # loss='categorical_crossentropy', # metrics=['accuracy']) # model.summary() return(model)</span></span></code> </pre><br><br>  Saat kami membuat jaringan menggunakan <i>pembelajaran transfer</i> , prosedurnya berubah: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModelMobileNetV2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># First, create the NN and load pre-trained # weights for it ('imagenet') # Note that we are not loading last layers of # the network (include_top=False), as we are # going to add layers of our own: base_model = MobileNetV2(weights='imagenet', include_top=False, pooling='avg', input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3)) # Then attach our layers at the end. These are # to build "classifier" that makes sense of # the patterns previous layers provide: x = base_model.output x = Dense(512)(x) x = Activation('relu')(x) x = Dropout(0.5)(x) predictions = Dense(NUM_CLASSES, activation='softmax')(x) # Create a model model = Model(inputs=base_model.input, outputs=predictions) # We need to make sure that pre-trained # layers are not changed when we train # our classifier: # Either this: #model.layers[0].trainable = False # or that: for layer in base_model.layers: layer.trainable = False # As always, there are different possible # settings, I tried few and chose the best: # model.compile(optimizer='adam', # loss='categorical_crossentropy', # metrics=['accuracy']) model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy']) #model.summary() return(model)</span></span></code> </pre><br><br>  Membuat jenis jaringan lain mengikuti pola yang sama: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModelResNet50</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> base_model = ResNet50(weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>, include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, pooling=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>, input_shape=(IMAGE_SIZE, IMAGE_SIZE, <span class="hljs-number"><span class="hljs-number">3</span></span>)) x = base_model.output x = Dense(<span class="hljs-number"><span class="hljs-number">512</span></span>)(x) x = Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)(x) predictions = Dense(NUM_CLASSES, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(x) model = Model(inputs=base_model.input, outputs=predictions) <span class="hljs-comment"><span class="hljs-comment">#model.layers[0].trainable = False # model.compile(loss='categorical_crossentropy', # optimizer='adam', metrics=['accuracy']) model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy']) #model.summary() return(model)</span></span></code> </pre><br><br>  Peringatan: pemenang!  NN ini menunjukkan hasil terbaik: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModelInceptionV3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># model.layers[0].trainable = False # model.compile(optimizer='sgd', # loss='categorical_crossentropy', # metrics=['accuracy']) base_model = InceptionV3(weights = 'imagenet', include_top = False, input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3)) x = base_model.output x = GlobalAveragePooling2D()(x) x = Dense(512, activation='relu')(x) predictions = Dense(NUM_CLASSES, activation='softmax')(x) model = Model(inputs = base_model.input, outputs = predictions) for layer in base_model.layers: layer.trainable = False # model.compile(optimizer='adam', # loss='categorical_crossentropy', # metrics=['accuracy']) model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy']) #model.summary() return(model)</span></span></code> </pre><br><br>  Satu lagi: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModelNASNetMobile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># model.layers[0].trainable = False # model.compile(optimizer='sgd', # loss='categorical_crossentropy', # metrics=['accuracy']) base_model = NASNetMobile(weights = 'imagenet', include_top = False, input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3)) x = base_model.output x = GlobalAveragePooling2D()(x) x = Dense(512, activation='relu')(x) predictions = Dense(NUM_CLASSES, activation='softmax')(x) model = Model(inputs = base_model.input, outputs = predictions) for layer in base_model.layers: layer.trainable = False # model.compile(optimizer='adam', # loss='categorical_crossentropy', # metrics=['accuracy']) model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy']) #model.summary() return(model)</span></span></code> </pre><br><br>  Berbagai jenis jaringan saraf dapat digunakan untuk tugas yang berbeda.  Jadi, selain persyaratan untuk akurasi prediksi, ukuran juga penting (NN seluler 5 kali lebih kecil dari Inception) dan kecepatan (jika kita membutuhkan pemrosesan streaming video secara real-time, maka akurasi harus dikorbankan). <br><br><h3>  Pelatihan jaringan saraf </h3><br><br>  Pertama-tama, kami <i>bereksperimen</i> , jadi kami harus dapat menghapus jaringan saraf yang telah kami simpan, tetapi tidak lagi digunakan.  Fungsi berikut menghapus NN jika ada: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Make sure that previous "best network" is deleted. def deleteSavedNet(best_weights_filepath): if(os.path.isfile(best_weights_filepath)): os.remove(best_weights_filepath) print("deleteSavedNet():File removed") else: print("deleteSavedNet():No file to remove")</span></span></code> </pre><br><br>  Cara kita membuat dan menghapus jaringan saraf cukup sederhana dan mudah.  Pertama, hapus.  Saat memanggil <i>delete</i> (hanya), harus diingat bahwa Jupiter Notebook memiliki fungsi "run selection", pilih hanya apa yang ingin Anda gunakan, dan jalankan. <br><br>  Kemudian kita membuat jaringan saraf jika file-nya tidak ada, atau memanggil <i>beban</i> jika ada: tentu saja, kita tidak bisa memanggil "delete" dan kemudian mengharapkan NN ada, jadi untuk menggunakan jaringan saraf yang disimpan, jangan panggil <i>delete</i> . <br><br>  Dengan kata lain, kita dapat membuat NN baru, atau menggunakan NN yang sudah ada, tergantung pada situasinya dan pada apa yang sedang kita eksperimenkan.  Skenario sederhana: kami melatih jaringan saraf, lalu pergi berlibur.  Mereka kembali, dan Google memakukan sesi, jadi kita perlu memuat yang disimpan sebelumnya: komentar "hapus" dan hapus komentar "muat". <br><br><pre> <code class="python hljs">deleteSavedNet(working_path + strModelFileName) <span class="hljs-comment"><span class="hljs-comment">#if not os.path.exists(working_path + "models"): # os.makedirs(working_path + "models") # #if not os.path.exists(working_path + # strModelFileName): # model = createModelResNet50() model = createModelInceptionV3() # model = createModelMobileNetV2() # model = createModelNASNetMobile() #else: # model = load_model(working_path + strModelFileName)</span></span></code> </pre><br><br>  <b>Pos pemeriksaan</b> adalah elemen yang sangat penting dari program kami.  Kita dapat membuat berbagai fungsi yang harus dipanggil di akhir setiap era pelatihan, dan meneruskannya ke pos pemeriksaan.  Misalnya, Anda dapat menyimpan jaringan saraf <i>jika</i> itu menunjukkan hasil yang lebih baik daripada yang sudah disimpan. <br><br><pre> <code class="python hljs">checkpoint = ModelCheckpoint(working_path + strModelFileName, monitor=<span class="hljs-string"><span class="hljs-string">'val_acc'</span></span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span></span>, save_best_only=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode=<span class="hljs-string"><span class="hljs-string">'auto'</span></span>, save_weights_only=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) callbacks_list = [ checkpoint ]</code> </pre><br><br>  Akhirnya, kami mengajarkan jaringan saraf pada set pelatihan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Calculate sizes of training and validation sets STEP_SIZE_TRAIN=train_gen.n//train_gen.batch_size STEP_SIZE_VALID=val_gen.n//val_gen.batch_size # Set to False if we are experimenting with # some other part of code, use history that # was calculated before (and is still in # memory bDoTraining = True if bDoTraining == True: # model.fit_generator does the actual training # Note the use of generators and callbacks # that were defined earlier history = model.fit_generator(generator=train_gen, steps_per_epoch=STEP_SIZE_TRAIN, validation_data=val_gen, validation_steps=STEP_SIZE_VALID, epochs=EPOCHS, callbacks=callbacks_list) # --- After fitting, load the best model # This is important as otherwise we'll # have the LAST model loaded, not necessarily # the best one. model.load_weights(working_path + strModelFileName) # --- Presentation part # summarize history for accuracy plt.plot(history.history['acc']) plt.plot(history.history['val_acc']) plt.title('model accuracy') plt.ylabel('accuracy') plt.xlabel('epoch') plt.legend(['acc', 'val_acc'], loc='upper left') plt.show() # summarize history for loss plt.plot(history.history['loss']) plt.plot(history.history['val_loss']) plt.title('model loss') plt.ylabel('loss') plt.xlabel('epoch') plt.legend(['loss', 'val_loss'], loc='upper left') plt.show() # As grid optimization of NN would take too long, # I did just few tests with different parameters. # Below I keep results, commented out, in the same # code. As you can see, Inception shows the best # results: # Inception: # adam: val_acc 0.79393 # sgd: val_acc 0.80892 # Mobile: # adam: val_acc 0.65290 # sgd: Epoch 00015: val_acc improved from 0.67584 to 0.68469 # sgd-30 epochs: 0.68 # NASNetMobile, adam: val_acc did not improve from 0.78335 # NASNetMobile, sgd: 0.8</span></span></code> </pre><br><br>  Grafik untuk akurasi dan kehilangan untuk yang terbaik dari konfigurasi adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/97d/9cc/f0e97d9ccdc8f8ed9e44ddba02cf1f8d.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/612/e09/8b0/612e098b088979768d1cc66c2f6972bc.png"><br><br>  Seperti yang Anda lihat, jaringan saraf sedang belajar, dan tidak buruk. <br><br><h3>  Pengujian jaringan saraf </h3><br><br>  Setelah pelatihan selesai, kita harus menguji hasilnya;  untuk ini, NN menyajikan gambar-gambar yang belum pernah dilihatnya - foto-foto yang kami salin ke dalam folder pengujian - satu untuk setiap jenis anjing. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># --- Test j = 0 # Final cycle performs testing on the entire # testing set. for file_name in os.listdir( working_path + "test/"): img = image.load_img(working_path + "test/" + file_name); img_1 = image.img_to_array(img) img_1 = cv2.resize(img_1, (IMAGE_SIZE, IMAGE_SIZE), interpolation = cv2.INTER_AREA) img_1 = np.expand_dims(img_1, axis=0) / 255. y_pred = model.predict_on_batch(img_1) # get 5 best predictions y_pred_ids = y_pred[0].argsort()[-5:][::-1] print(file_name) for i in range(len(y_pred_ids)): print("\n\t" + map_characters[y_pred_ids[i]] + " (" + str(y_pred[0][y_pred_ids[i]]) + ")") print("--------------------\n") j = j + 1</span></span></code> </pre><br><br><h3>  Ekspor jaringan saraf ke aplikasi Java </h3><br><br>  Pertama-tama, kita perlu mengatur pemuatan jaringan saraf dari disk.  Alasannya jelas: ekspor terjadi di blok kode lain, jadi kemungkinan besar kita akan memulai ekspor secara terpisah - ketika jaringan saraf dibawa ke keadaan optimal.  Artinya, segera sebelum ekspor, dalam menjalankan program yang sama, kami tidak akan melatih jaringan.  Jika Anda menggunakan kode yang ditunjukkan di sini, maka tidak ada perbedaan, jaringan optimal telah dipilih untuk Anda.  Tetapi jika Anda mempelajari sesuatu dari Anda sendiri, maka untuk melatih segala sesuatu yang baru sebelum menabung adalah buang-buang waktu, jika sebelumnya Anda menyimpan semuanya. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Test: load and run model = load_model(working_path + strModelFileName)</span></span></code> </pre><br><br>  Untuk alasan yang sama - jangan melompati kode - saya menyertakan file yang diperlukan untuk ekspor di sini.  Tidak ada yang mengganggu Anda untuk memindahkan mereka ke awal program jika selera kecantikan Anda mengharuskannya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> load_model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf</code> </pre><br><br>  Pengujian kecil setelah memuat jaringan saraf, hanya untuk memastikan semuanya dimuat - berfungsi: <br><br><pre> <code class="python hljs">img = image.load_img(working_path + <span class="hljs-string"><span class="hljs-string">"test/affenpinscher.jpg"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#basset.jpg") img_1 = image.img_to_array(img) img_1 = cv2.resize(img_1, (IMAGE_SIZE, IMAGE_SIZE), interpolation = cv2.INTER_AREA) img_1 = np.expand_dims(img_1, axis=0) / 255. y_pred = model.predict(img_1) Y_pred_classes = np.argmax(y_pred,axis = 1) # print(y_pred) fig, ax = plt.subplots() ax.imshow(img) ax.axis('off') ax.set_title(map_characters[Y_pred_classes[0]]) plt.show()</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/05c/032/846/05c03284674e4337a2e5a3ba617634dd.png" alt="gambar"><br><br>  Selanjutnya, kita perlu mendapatkan nama-nama lapisan input dan output dari jaringan (baik ini atau fungsi pembuatan, kita harus secara eksplisit "memberi nama" lapisan, yang tidak kita lakukan). <br><br><pre> <code class="python hljs">model.summary() &gt;&gt;&gt; Layer (type) &gt;&gt;&gt; ====================== &gt;&gt;&gt; input_7 (InputLayer) &gt;&gt;&gt; ______________________ &gt;&gt;&gt; conv2d_283 (Conv2D) &gt;&gt;&gt; ______________________ &gt;&gt;&gt; ... &gt;&gt;&gt; dense_14 (Dense) &gt;&gt;&gt; ====================== &gt;&gt;&gt; Total params: <span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">913</span></span>,<span class="hljs-number"><span class="hljs-number">432</span></span> &gt;&gt;&gt; Trainable params: <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">110</span></span>,<span class="hljs-number"><span class="hljs-number">648</span></span> &gt;&gt;&gt; Non-trainable params: <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">802</span></span>,<span class="hljs-number"><span class="hljs-number">784</span></span></code> </pre><br><br>  Kami akan menggunakan nama-nama lapisan input dan output nanti ketika kami mengimpor jaringan saraf ke aplikasi Java. <br><br>  Kode lain berkeliaran di jaringan untuk mendapatkan data ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_graph_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> g = tf.GraphDef() g.ParseFromString(open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read()) print() print(filename) print(<span class="hljs-string"><span class="hljs-string">"=======================INPUT==================="</span></span>) print([n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> g.node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n.name.find(<span class="hljs-string"><span class="hljs-string">'input'</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>]) print(<span class="hljs-string"><span class="hljs-string">"=======================OUTPUT=================="</span></span>) print([n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> g.node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n.name.find(<span class="hljs-string"><span class="hljs-string">'output'</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>]) print(<span class="hljs-string"><span class="hljs-string">"===================KERAS_LEARNING=============="</span></span>) print([n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> g.node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n.name.find(<span class="hljs-string"><span class="hljs-string">'keras_learning_phase'</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>]) print(<span class="hljs-string"><span class="hljs-string">"==============================================="</span></span>) print() <span class="hljs-comment"><span class="hljs-comment">#def get_script_path(): # return os.path.dirname(os.path.realpath(sys.argv[0]))</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi saya tidak menyukainya dan saya tidak merekomendasikannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode berikut akan mengekspor Keras Neural Network ke </font><font style="vertical-align: inherit;">format </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan kami tangkap dari Android.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keras_to_tensorflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(keras_model, output_dir, model_name,out_prefix=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"output_"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, log_tensorboard=True)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.exists(output_dir) == <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: os.mkdir(output_dir) out_nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(keras_model.outputs)): out_nodes.append(out_prefix + str(i + <span class="hljs-number"><span class="hljs-number">1</span></span>)) tf.identity(keras_model.output[i], out_prefix + str(i + <span class="hljs-number"><span class="hljs-number">1</span></span>)) sess = K.get_session() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.python.framework <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> graph_util <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.python.framework graph_io init_graph = sess.graph.as_graph_def() main_graph = graph_util.convert_variables_to_constants( sess, init_graph, out_nodes) graph_io.write_graph(main_graph, output_dir, name=model_name, as_text=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> log_tensorboard: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.python.tools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> import_pb_to_tensorboard import_pb_to_tensorboard.import_to_tensorboard( os.path.join(output_dir, model_name), output_dir)</code> </pre><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memanggil fungsi-fungsi ini untuk mengekspor jaringan saraf: </font></font><br><br></p><pre> <code class="python hljs">model = load_model(working_path + strModelFileName) keras_to_tensorflow(model, output_dir=working_path + strModelFileName, model_name=working_path + <span class="hljs-string"><span class="hljs-string">"models/dogs.pb"</span></span>) print_graph_nodes(working_path + <span class="hljs-string"><span class="hljs-string">"models/dogs.pb"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baris terakhir mencetak struktur jaringan saraf yang dihasilkan. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat aplikasi Android menggunakan jaringan saraf </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekspor jaringan saraf di Android diformalkan dengan baik dan seharusnya tidak menyebabkan kesulitan. </font><font style="vertical-align: inherit;">Ada, seperti biasa, beberapa cara, kami menggunakan yang paling (pada saat penulisan) populer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, kami menggunakan Android Studio untuk membuat proyek baru. </font><font style="vertical-align: inherit;">Kami akan “berhemat” karena tugas kami bukan tutorial android. </font><font style="vertical-align: inherit;">Jadi aplikasi hanya akan berisi satu aktivitas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b3/76e/997/6b376e997b34f45359c46923f6613d60.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, kami menambahkan folder "aset" dan menyalin jaringan saraf kami ke dalamnya (yang sebelumnya kami ekspor).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> File Gradle </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam file ini, Anda perlu membuat beberapa perubahan. </font><font style="vertical-align: inherit;">Pertama-tama, kita perlu mengimpor perpustakaan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tensorflow-android</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini digunakan untuk bekerja dengan Tensorflow (dan, karenanya, Keras) dari Jawa: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a16/091/fab/a16091fab2166f834827812611142d26.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu lagi penghalang yang tidak terlihat: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versionCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versionName</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saat aplikasi berubah, Anda harus mengunggah versi baru di Google Play. </font><font style="vertical-align: inherit;">Tanpa mengubah versi di gdadle (misalnya, 1 -&gt; 2 -&gt; 3 ...) Anda tidak dapat melakukan ini, Google akan memberikan kesalahan "versi ini sudah ada."</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terwujud </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, aplikasi kita akan “berat” - 100 Mb Neural Network akan dengan mudah masuk ke dalam memori ponsel modern, tetapi membuka contoh terpisah untuk setiap foto yang “dibagikan” dari Facebook jelas merupakan ide yang buruk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami melarang untuk membuat lebih dari satu contoh aplikasi kami:</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".MainActivity"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:launchMode</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"singleTask"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menambahkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">android: launchMode = "singleTask"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke MainActivity, kami memberi tahu Android untuk membuka (mengaktifkan) salinan aplikasi yang ada, alih-alih membuat instance lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maka kita perlu memasukkan aplikasi kita dalam daftar, yang ditampilkan oleh sistem ketika seseorang “membagikan” gambar:</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Send action required to display activity in share list --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.SEND"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Make activity default to launch --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Mime type ie what can be shared with this activity only image and text --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:mimeType</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image/*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terakhir, kita perlu meminta fitur dan izin yang akan digunakan aplikasi kita: </font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-feature</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.hardware.camera"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:required</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.WRITE_EXTERNAL_STORAGE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.READ_PHONE_STATE"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:node</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"remove"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda terbiasa dengan pemrograman untuk Android, bagian ini seharusnya tidak menimbulkan pertanyaan. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aplikasi tata letak. </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan membuat dua tata letak, satu untuk potret dan satu untuk lanskap. </font><font style="vertical-align: inherit;">Seperti inilah tampilan </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portrait</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang akan kami tambahkan: bidang besar (tampilan) untuk menampilkan gambar, daftar iklan yang mengganggu (ditampilkan ketika tombol dengan tulang ditekan), tombol Bantuan, tombol untuk mengunduh gambar dari File / Galeri dan mengambil dari kamera, dan akhirnya (awalnya tersembunyi) tombol "Proses" untuk pemrosesan gambar. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/882/81f/f7188281ff581965c20c7e818cb0fd77.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivitas itu sendiri berisi semua logika menampilkan dan menyembunyikan, serta mengaktifkan / menonaktifkan tombol, tergantung pada keadaan aplikasi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mainaktivitas </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktivitas ini mewarisi (meluas) Aktivitas Android standar: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan kode yang bertanggung jawab untuk pengoperasian jaringan saraf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, jaringan saraf menerima Bitmap. </font><font style="vertical-align: inherit;">Awalnya, ini adalah Bitmap besar (ukuran sewenang-wenang) dari kamera atau dari file (m_bitmap), kemudian kami mengubahnya, mengarah ke 256x256 piksel standar (m_bitmapForNn). </font><font style="vertical-align: inherit;">Kami juga menyimpan ukuran bitmap (256) dalam sebuah konstanta:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Bitmap m_bitmap = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Bitmap m_bitmapForNn = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_nImageSize = <span class="hljs-number"><span class="hljs-number">256</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita harus memberi tahu jaringan saraf nama dari lapisan input dan output; </font><font style="vertical-align: inherit;">kami menerimanya lebih awal (lihat daftar), tetapi perlu diingat bahwa dalam kasus Anda mereka mungkin berbeda:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String INPUT_NAME = <span class="hljs-string"><span class="hljs-string">"input_7_1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String OUTPUT_NAME = <span class="hljs-string"><span class="hljs-string">"output_1"</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kami mendeklarasikan variabel untuk memegang objek TensofFlow. </font><font style="vertical-align: inherit;">Juga, kami menyimpan path ke file jaringan saraf (yang terletak pada aset):</font></font><br><br><p></p><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">private TensorFlowInferenceInterface tf;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
private String MODEL_PATH = </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	"file: ///android_asset/dogs.pb";</font></font><font></font>
</pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menyimpan trah anjing dalam daftar, sehingga nanti akan ditampilkan kepada pengguna, bukan indeks array: </font></font><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String[] m_arrBreedsArray;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, kami mengunduh Bitmap. </font><font style="vertical-align: inherit;">Namun, jaringan saraf mengharapkan array nilai RGB, dan outputnya adalah array probabilitas yang berkembang biak ini adalah apa yang ditunjukkan pada gambar. </font><font style="vertical-align: inherit;">Oleh karena itu, kita perlu menambahkan dua array lagi (perhatikan bahwa 120 adalah jumlah ras anjing yang ada dalam data pelatihan kami):</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] m_arrPrediction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">120</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] m_arrInput = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unduh perpustakaan inferensi tensorflow: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"tensorflow_inference"</span></span>); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena operasi jaringan saraf membutuhkan waktu, kita perlu menjalankannya di utas terpisah, jika tidak ada kemungkinan bahwa kita akan menerima pesan sistem "aplikasi tidak merespons", belum lagi pengguna yang tidak puas. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredictionTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPreExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPreExecute(); } <span class="hljs-comment"><span class="hljs-comment">// --- @Override protected Void doInBackground(Void... params) { try { # We get RGB values packed in integers # from the Bitmap, then break those # integers into individual triplets m_arrInput = new float[ m_nImageSize * m_nImageSize * 3]; int[] intValues = new int[ m_nImageSize * m_nImageSize]; m_bitmapForNn.getPixels(intValues, 0, m_nImageSize, 0, 0, m_nImageSize, m_nImageSize); for (int i = 0; i &lt; intValues.length; i++) { int val = intValues[i]; m_arrInput[i * 3 + 0] = ((val &gt;&gt; 16) &amp; 0xFF) / 255f; m_arrInput[i * 3 + 1] = ((val &gt;&gt; 8) &amp; 0xFF) / 255f; m_arrInput[i * 3 + 2] = (val &amp; 0xFF) / 255f; } // --- tf = new TensorFlowInferenceInterface( getAssets(), MODEL_PATH); //Pass input into the tensorflow tf.feed(INPUT_NAME, m_arrInput, 1, m_nImageSize, m_nImageSize, 3); //compute predictions tf.run(new String[]{OUTPUT_NAME}, false); //copy output into PREDICTIONS array tf.fetch(OUTPUT_NAME, m_arrPrediction); } catch (Exception e) { e.getMessage(); } return null; } // --- @Override protected void onPostExecute(Void result) { super.onPostExecute(result); // --- enableControls(true); // --- tf = null; m_arrInput = null; # strResult contains 5 lines of text # with most probable dog breeds and # their probabilities m_strResult = ""; # What we do below is sorting the array # by probabilities (using map) # and getting in reverse order) the # first five entries TreeMap&lt;Float, Integer&gt; map = new TreeMap&lt;Float, Integer&gt;( Collections.reverseOrder()); for(int i = 0; i &lt; m_arrPrediction.length; i++) map.put(m_arrPrediction[i], i); int i = 0; for (TreeMap.Entry&lt;Float, Integer&gt; pair : map.entrySet()) { float key = pair.getKey(); int idx = pair.getValue(); String strBreed = m_arrBreedsArray[idx]; m_strResult += strBreed + ": " + String.format("%.6f", key) + "\n"; i++; if (i &gt; 5) break; } m_txtViewBreed.setVisibility(View.VISIBLE); m_txtViewBreed.setText(m_strResult); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di onCreate () dari MainActivity, kita perlu menambahkan onClickListener untuk tombol "Proses": </font></font><br><br><pre> <code class="java hljs">m_btn_process.setOnClickListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View.OnClickListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v)</span></span></span><span class="hljs-function"> </span></span>{ processImage(); } });</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini processImage () hanya memanggil utas yang kami jelaskan di atas: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enableControls(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- PredictionTask prediction_task = new PredictionTask(); prediction_task.execute(); } catch (Exception e) { e.printStackTrace(); } }</span></span></code> </pre><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catatan tambahan </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak berencana untuk membahas rincian pemrograman UI untuk Android, karena ini tentu saja tidak berlaku untuk tugas porting jaringan saraf. </font><font style="vertical-align: inherit;">Namun, satu hal masih layak disebut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami mencegah pembuatan instance tambahan dari aplikasi kami, kami juga melanggar urutan normal pembuatan dan penghapusan aktivitas (aliran kontrol): jika Anda "berbagi" gambar dari Facebook, dan kemudian membagikan yang lain, maka aplikasi tidak akan memulai ulang. </font><font style="vertical-align: inherit;">Ini berarti bahwa cara "tradisional" untuk menangkap data yang ditransfer di onCreate tidak akan cukup, karena onCreate tidak akan dipanggil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut cara mengatasi masalah ini: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Di onCreate di MainActivity, panggil fungsi onSharedIntent:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); .... onSharedIntent(); ....</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami juga menambahkan handler untuk onNewIntent: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNewIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onNewIntent(intent); setIntent(intent); onSharedIntent(); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah fungsi onSharedIntent itu sendiri: </font></font><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSharedIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Intent receivedIntent = getIntent(); String receivedAction = receivedIntent.getAction(); String receivedType = receivedIntent.getType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receivedAction.equals(Intent.ACTION_SEND)) { <span class="hljs-comment"><span class="hljs-comment">// If mime type is equal to image if (receivedType.startsWith("image/")) { m_txtViewBreed.setText(""); m_strResult = ""; Uri receivedUri = receivedIntent.getParcelableExtra( Intent.EXTRA_STREAM); if (receivedUri != null) { try { Bitmap bitmap = MediaStore.Images.Media.getBitmap( this.getContentResolver(), receivedUri); if(bitmap != null) { m_bitmap = bitmap; m_picView.setImageBitmap(m_bitmap); storeBitmap(); enableControls(true); } } catch (Exception e) { e.printStackTrace(); } } } } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kami memproses data yang ditransfer di onCreate (jika aplikasi tidak ada dalam memori) atau di onNewIntent (jika diluncurkan sebelumnya). </font></font><br><br><br><br><br>  Semoga beruntung<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyukai artikel ini, silakan “suka” dengan semua cara yang mungkin, ada juga tombol “sosial” di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448316/">https://habr.com/ru/post/id448316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448300/index.html">Konferensi mailto: CLOUD - tentang awan dan sekitarnya</a></li>
<li><a href="../id448302/index.html">Kerentanan dalam filter AdBlock dan uBlock memungkinkan kode arbitrer untuk dieksekusi di sisi pengguna</a></li>
<li><a href="../id448304/index.html">Buku "Vue.js beraksi"</a></li>
<li><a href="../id448308/index.html">Intisari Ilmu Data (April 2019)</a></li>
<li><a href="../id448310/index.html">Menulis bot telegram dengan python menggunakan perpustakaan telebot bagian 1</a></li>
<li><a href="../id448320/index.html">Mengapa silikon dan mengapa CMOS?</a></li>
<li><a href="../id448322/index.html">C ++ Rusia 2019: siaran gratis aula pertama dan sedikit tentang apa yang akan ada di konferensi</a></li>
<li><a href="../id448324/index.html">Buat planet planet prosedural</a></li>
<li><a href="../id448326/index.html">Lihat melalui. Bagaimana cara mempelajari subjek tanpa melanggarnya?</a></li>
<li><a href="../id448328/index.html">Di Moskow akan ditampilkan printer yang mencetak organ dan jaringan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>