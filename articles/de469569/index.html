<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª ü§ì üêã Arend - HoTT-basierte abh√§ngige Typensprache (Teil 1) üöü ‚òÇÔ∏è üîã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag werden wir √ºber die neu ver√∂ffentlichte JetBrains-Sprache mit Arend-abh√§ngigen Typen sprechen (die Sprache ist nach Gating Rent bena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - HoTT-basierte abh√§ngige Typensprache (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"> In diesem Beitrag werden wir √ºber die neu ver√∂ffentlichte JetBrains-Sprache mit Arend-abh√§ngigen Typen sprechen (die Sprache ist nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gating Rent benannt</a> ).  Diese Sprache wurde in den letzten Jahren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JetBrains Research</a> entwickelt.  Obwohl die Repositories vor einem Jahr auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/JetBrains</a> √∂ffentlich zug√§nglich gemacht wurden, erfolgte die vollst√§ndige Ver√∂ffentlichung von Arend erst im Juli dieses Jahres. <br><br>  Wir werden versuchen herauszufinden, wie sich Arend von bestehenden Systemen der formalisierten Mathematik unterscheidet, die auf abh√§ngigen Typen basieren, und welche Funktionen den Benutzern jetzt zur Verf√ºgung stehen.  Wir gehen davon aus, dass der Leser dieses Artikels im Allgemeinen mit abh√§ngigen Typen vertraut ist und mindestens eine der auf abh√§ngigen Typen basierenden Sprachen geh√∂rt hat: Agda, Idris, Coq oder Lean.  Wir erwarten jedoch nicht, dass der Leser abh√§ngige Typen auf fortgeschrittenem Niveau hat. <br><br>  Der Einfachheit und Konkretheit halber wird unsere Geschichte √ºber Arend- und Homotopietypen von der Implementierung des einfachsten Listensortieralgorithmus auf Arend begleitet - selbst bei diesem Beispiel k√∂nnen Sie den Unterschied zwischen Arend und Agda und Coq sp√ºren.  Es gibt bereits eine Reihe von Artikeln √ºber Habr√©, die sich mit abh√§ngigen Typen befassen.  Angenommen, √ºber die Implementierung von Sortierlisten mit der QuickSort-Methode auf Agda gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es einen solchen Artikel</a> .  Wir werden einen einfacheren Algorithmus zum Sortieren von Inserts implementieren.  In diesem Fall konzentrieren wir uns auf die Konstruktionen der Arend-Sprache und nicht auf den Sortieralgorithmus selbst. <br><a name="habracut"></a><br>  Der Hauptunterschied zwischen Arend und anderen Sprachen mit abh√§ngigen Typen ist also die logische Theorie, auf der es basiert.  Arend verwendet als solches die k√ºrzlich entdeckte Homotopietypentheorie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HoTT</a> ) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V. Voevodsky</a> .  Insbesondere basiert Arend auf einer Variation von HoTT, die als "Typentheorie mit Abstand" bezeichnet wird.  Es sei daran erinnert, dass Coq auf der sogenannten Berechnung induktiver Konstruktionen (Berechnung induktiver Konstruktionen) basiert, w√§hrend Agda und Idris auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Martin-L√∂f-Intensionstheorie der Typen</a> basieren.  Die Tatsache, dass Arend auf HoTT basiert, beeinflusst seine syntaktischen Konstruktionen und die Funktionsweise des Typpr√ºfungsalgorithmus (Typcheker) erheblich.  Wir werden diese Funktionen in diesem Artikel diskutieren. <br><br>  Versuchen wir kurz den Zustand der Sprachinfrastruktur zu beschreiben.  F√ºr Arend gibt es ein Plugin f√ºr IntelliJ IDEA, das direkt aus dem Repository der IDEA-Plugins installiert werden kann.  Im Prinzip reicht die Installation des Plugins aus, um vollst√§ndig mit Arend zu arbeiten. Sie m√ºssen dennoch nichts herunterladen und installieren.  Zus√§tzlich zur Typpr√ºfung bietet das Arend-Plugin Funktionen, die IDEA-Benutzern vertraut sind: Hervorheben und Ausrichten des Codes, verschiedene Refactorings und Tipps.  Es besteht auch die M√∂glichkeit, die Konsolenversion von Arend zu verwenden.  Eine detailliertere Beschreibung des Installationsvorgangs finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Die Codebeispiele in diesem Artikel basieren auf der Arend-Standardbibliothek. Wir empfehlen daher, den Quellcode aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> herunterzuladen.  Nach dem Herunterladen muss das Quellverzeichnis mit dem Befehl Projekt importieren als IDEA-Projekt importiert werden.  Bei Arend wurden bereits einige Abschnitte der Homotopietypentheorie und der Ringtheorie formalisiert.  Zum Beispiel gibt es in der Standardbibliothek eine Implementierung des Rings der rationalen Zahlen Q zusammen mit Beweisen aller erforderlichen ring-theoretischen Eigenschaften. <br><br>  Eine ausf√ºhrliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprachdokumentation</a> , in der viele der in diesem Artikel behandelten Punkte ausf√ºhrlicher erl√§utert werden, ist ebenfalls gemeinfrei.  Sie k√∂nnen Arend-Entwicklern im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> direkt Fragen stellen. <br><br><h2>  1. √úbersicht √ºber HoTT / Arend </h2><br>  Die Homotopietypentheorie (oder kurz HoTT) ist eine Art von Intensionstyptheorie, die sich von der klassischen Martin-L√∂f-Typentheorie (MLTT, auf der Agda basiert) und der Berechnung induktiver Konstruktionen (CIC, auf der Coq basiert) darin unterscheidet Anweisungen und Mengen enthalten die sogenannten Typen einer h√∂heren Homotopieebene. <br><br>  In diesem Artikel setzen wir uns nicht das Ziel, die Grundlagen von HoTT im Detail zu erkl√§ren - f√ºr eine detaillierte Darstellung dieser Theorie w√§re es notwendig, das gesamte Buch erneut zu erz√§hlen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Beitrag</a> ).  Wir stellen nur fest, dass eine Theorie, die auf der Axiomatik von HoTT basiert, in gewissem Sinne viel eleganter und interessanter ist als die klassische Martin-L√∂f-Typentheorie.  So werden in HoTT eine Reihe von Axiomen, die zuvor zus√§tzlich postuliert werden mussten (z. B. funktionale Extensionalit√§t), als Theoreme bewiesen.  Dar√ºber hinaus kann man in HoTT intern mehrdimensionale Homotopiekugeln definieren und sogar einige ihrer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homotopiegruppen z√§hlen</a> . <br><br>  Diese Aspekte von HoTT sind jedoch in erster Linie f√ºr Mathematiker interessant, und der Zweck dieses Artikels besteht darin, zu erkl√§ren, wie sich das HoTT-basierte Arend im Vergleich zu Agda / MLTT und Coq / CIC g√ºnstig verh√§lt, indem beispielsweise Programmiererentit√§ten so einfach und vertraut wie geordnete Listen dargestellt werden.  Wenn Sie diesen Artikel lesen, reicht es aus, HoTT als eine Art Intensivtyp-Theorie mit einer weiter entwickelten Axiomatik zu behandeln, die die Arbeit mit Universen und Gleichheiten erleichtert. <br><br><h2>  1.1 Abh√§ngige Typen, Curry-Howard-Korrespondenz, Universen </h2><br>  Denken Sie daran, dass sich Sprachen mit abh√§ngigen Typen von normalen funktionalen Programmiersprachen dadurch unterscheiden, dass es zus√§tzlich zu den √ºblichen Datentypen wie Listen oder nat√ºrlichen Zahlen Typen gibt, die vom Parameterwert abh√§ngen.  Die einfachsten Beispiele f√ºr solche Typen sind Vektoren einer gegebenen L√§nge n oder ausgeglichene B√§ume einer gegebenen Tiefe d.  Einige weitere Beispiele f√ºr solche Typen werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> erw√§hnt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br><br>  Denken Sie daran, dass die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curry-Howard-Korrespondenz es</a> erlaubt, Aussagen der Logik als abh√§ngige Typen zu interpretieren.  Die Hauptidee dieser Entsprechung ist, dass ein leerer Typ einer falschen Aussage entspricht und aufgef√ºllte Typen einer wahren Aussage entsprechen.  Typelemente k√∂nnen als Beweise f√ºr die entsprechende logische Aussage angesehen werden.  Beispielsweise kann jedes Element wie Ganzzahlen als Beweis daf√ºr angesehen werden, dass Ganzzahlen vorhanden sind (dh der Typ der Ganzzahlen wird ausgef√ºllt). <br><br>  Unterschiedliche nat√ºrliche Konstruktionen √ºber Typen entsprechen unterschiedlichen logischen Verkn√ºpfungen: <br><br><ul><li>  <i>Das Produkt der Typen A √ó B</i> wird manchmal als Typ des Paares Paar A B bezeichnet. Da dieser Typ genau dann ausgef√ºllt wird, wenn beide Typen A und B ausgef√ºllt sind, entspricht diese Konstruktion dem logischen ‚Äûund‚Äú. </li><li>  <i>Die Summe der Typen A + B.</i> In Haskell wird dieser Typ entweder A B genannt. Da dieser Typ genau dann ausgef√ºllt wird, wenn einer der Typen A oder B ausgef√ºllt ist, entspricht diese Konstruktion einem logischen ‚Äûoder‚Äú. <br></li><li>  <i>Funktionstyp A ‚Üí B.</i>  Jede Funktion dieses Typs wandelt Elemente von A in Elemente von B um. Somit existiert eine solche Funktion genau dann, wenn die Existenz eines Elements vom Typ A die Existenz eines Elements vom Typ B impliziert. Daher entspricht diese Konstruktion der Implikation. <br></li></ul><br>  Nehmen wir nun an, wir erhalten einen bestimmten Typ A und eine Familie von Typen B, die durch ein Element a vom Typ A parametrisiert sind. Geben wir Beispiele f√ºr komplexere Konstruktionen √ºber abh√§ngige Typen. <br><br><ul><li>  <i>Abh√§ngiger Funktionstyp</i> <b>Œ†</b> (a: A) (B a).  Dieser Typ stimmt mit dem √ºblichen Funktionstyp A ‚Üí B √ºberein, wenn B unabh√§ngig von A ist. Eine Funktion vom Typ <b>Œ†</b> (a: A) (B a) wandelt jedes Element a vom Typ A in ein Element vom Typ B a um.  Eine solche Funktion existiert also genau dann, wenn <i>f√ºr a</i> : A ein Element B a existiert.  Daher entspricht diese Konstruktion dem universellen Quantifizierer ‚àÄ.  F√ºr den abh√§ngigen Funktionstyp verwendet Arend die Syntax <code><b>\Pi</b> (x : A) -&gt; B a</code> , und der Begriff, der diesen Typ bewohnt, kann mit dem Lambda-Ausdruck <code><b>\lam</b> (a : A) =&gt; f a.</code> konstruiert werden <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li>  <i>Die Art der abh√§ngigen Paare ist <b>Œ£</b> (a: A) (B a).</i>  Dieser Typ stimmt mit den √ºblichen Typen von A √ó B-Paaren √ºberein, wenn B unabh√§ngig von A ist. Der Typ <b>Œ£</b> (a: A) (B a) wird genau dann gef√ºllt, wenn ein Element a: A und ein Element vom Typ B a vorhanden sind.  Somit entspricht dieser Typ dem Existenzquantifizierer <code>‚àÉ</code> .  Der Typ der abh√§ngigen Paare in Arend wird mit <code>\Sigma (a : A) (B a)</code> , und die Begriffe, die ihn bewohnen, werden unter Verwendung des Konstruktors des <i>(abh√§ngigen)</i> Paares <code>(a, b)</code> konstruiert. <br></li><li>  <i>Der Typ der Gleichheit ist</i> a = a ', wobei a und a' zwei Elemente eines Typs A sind. Ein solcher Typ wird gef√ºllt, wenn a und a 'gleich sind, und ist ansonsten leer.  Offensichtlich ist dieser Typ ein Analogon des Gleichheitspr√§dikats in der Logik. </li></ul><br>  An dieser Stelle verweisen wir den Leser auf Quellen, in denen die Curry-Howard-Korrespondenz ausf√ºhrlicher besprochen wird (siehe beispielsweise einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurs von Vorlesungen</a> oder Artikeln <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br>  Alle in der Typentheorie ber√ºcksichtigten Ausdr√ºcke m√ºssen einen Typ haben.  Da Ausdr√ºcke, die Typen bezeichnen, im Rahmen dieser Theorie ebenfalls ber√ºcksichtigt werden, muss ihnen auch ein bestimmter Typ zugewiesen werden.  Die Frage ist, was f√ºr ein Typ sollte es sein? <br><br>  Die erste naive Entscheidung, die mir in den Sinn kommt, besteht darin, allen Typen einen formalen Typ <code>\Type</code> zuzuweisen, der als <i>Universum bezeichnet wird</i> (er wird so genannt, weil er im Allgemeinen alle Typen enth√§lt).  Wenn wir dieses Universum verwenden, erhalten die oben genannten Summenkonstruktionen und Typprodukte die Signatur <code>\Type ‚Üí \Type ‚Üí \Type</code> , und komplexere Konstruktionen des abh√§ngigen Produkts und die abh√§ngige Summe erhalten die Signatur <code><b>Œ†</b> (A : \Type) ‚Üí ((A ‚Üí \Type) ‚Üí \Type)</code> . <br><br>  An dieser Stelle stellt sich die Frage, welchen Typ das <code>\Type</code> Universum selbst haben soll.  Ein naiver Versuch zu sagen, dass der Typ des Universums <code>\Type</code> per Definition <code>\Type</code> selbst ist, f√ºhrt zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Girard-Paradoxon.</a> Betrachten Sie also anstelle eines einzelnen Universums <code>\Type</code> eine unendliche <i>Hierarchie von Universen</i> , d. H.  Die verschachtelte Kette von Universen <code>\Type 1 &lt; \Type 2 &lt; ‚Ä¶</code> , deren Ebenen durch nat√ºrliche Zahlen nummeriert sind, und der Typ des Universums <code>\Type i</code> ist per Definition das Universum <code>\Type (i+1)</code> .  F√ºr die oben genannten Typkonstruktionen m√ºssen auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">komplexere Signaturen</a> eingef√ºhrt werden. <br><br>  Daher werden Universen in der Typentheorie ben√∂tigt, damit jeder Ausdruck einen bestimmten Typ hat.  In einigen Varianten der Typentheorie werden Universen f√ºr einen anderen Zweck verwendet: zur Unterscheidung zwischen Arten von Typen.  Wir haben bereits gesehen, dass Mengen und Anweisungen Sonderf√§lle von Typen sind.  Dies zeigt, dass es m√∂glicherweise sinnvoll ist, ein separates Prop-Universum f√ºr Anweisungen und eine separate Hierarchie von Set- <sub>i-</sub> Universen f√ºr Sets in die Theorie einzuf√ºhren.  Dies ist genau der Ansatz, der in Calculus of Inductive Constructions verwendet wird, der Theorie, auf der das Coq-System basiert. <br><br><h2>  1.2 Beispiele f√ºr einfachste induktive Typen und rekursive Funktionen </h2><br>  Betrachten Sie die Definitionen der einfachsten induktiven Datentypen in Arend: Boolescher Typ, nat√ºrlicher Zahlentyp und polymorphe Listen.  Arend verwendet das Schl√ºsselwort <code>\data</code> , um neue induktive Typen einzuf√ºhren. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  Wie Sie den obigen Beispielen entnehmen k√∂nnen, m√ºssen Sie nach dem Schl√ºsselwort <code>\data</code> den Namen des induktiven Typs und eine Liste seiner Konstruktoren angeben.  Gleichzeitig k√∂nnen der Datentyp und die Konstruktoren einige Parameter haben.  Angenommen, im obigen Beispiel hat der <code>List</code> einen Parameter <code>A</code>  Der <code>nil</code> hat keine Parameter, und der Konstruktor: -: hat zwei Parameter (von denen einer vom Typ <code>A</code> und der andere vom Typ <code>List A</code> ).  Das Universum <code>\Set</code> besteht aus Typen, die Mengen sind (die Definition der Mengen wird im n√§chsten Abschnitt angegeben).  Mit <code>\infixr</code> k√∂nnen Sie die Infix-Notation f√ºr den Konstruktor verwenden: -: und teilt dem Arend-Parser au√üerdem mit, dass der Operator: -: eine <code>\infixr</code> Operation mit Priorit√§t 5 ist. <br><br>  In Arend beginnen alle Schl√ºsselw√∂rter mit einem Backslash-Zeichen ("\"), einer von LaTeX inspirierten Implementierung.  Beachten Sie nur, dass die lexikalischen Regeln in Arend sehr liberal sind: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> und sogar <code>n:Nat</code> - all diese Literale sind Beispiele f√ºr g√ºltige Bezeichner in Arend.  Das letzte Beispiel zeigt, wie wichtig es f√ºr den Arend-Benutzer ist <i>, Leerzeichen zwischen Bezeichnern und Doppelpunktzeichen einzuf√ºgen</i> .  Beachten Sie, dass in Arend-Bezeichnern keine Unicode-Zeichen verwendet werden d√ºrfen (insbesondere k√∂nnen Sie kein Kyrillisch verwenden). <br><br>  Arend verwendet das Schl√ºsselwort <code>\func</code> , um Funktionen zu definieren.  Die Syntax dieser Konstruktion lautet wie folgt: Nach dem Schl√ºsselwort <code>\func</code> m√ºssen Sie den Namen der Funktion, ihre Parameter und den Typ des R√ºckgabewerts angeben.  Das letzte Element bei der Definition einer Funktion ist ihr K√∂rper. <br><br>  Wenn es m√∂glich ist, den Ausdruck, in dem die angegebene Funktion berechnet werden soll, explizit anzugeben, wird zur Angabe des Funktionsk√∂rpers das Token =&gt; verwendet.  Betrachten Sie zum Beispiel die Definition einer Typnegationsfunktion. <br><br><pre> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  Der R√ºckgabetyp einer Funktion muss nicht immer explizit angegeben werden.  Im obigen Beispiel k√∂nnte Arend unabh√§ngig auf den Typ <code>Not</code> , und wir k√∂nnten den Ausdruck ": <code>\Type</code> " nach den Klammern weglassen. <br><br>  Wie in den meisten formalisierten Mathematiksystemen muss der Benutzer keine explizite Vorhersageebene f√ºr das <code>\Type</code> Universum angeben, und Definitionen, in denen Universen ohne explizite Angabe einer Vorhersageebene verwendet werden, werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">polymorph angesehen</a> . <br><br>  Versuchen wir nun, eine Funktion zu definieren, die die L√§nge der Liste berechnet.  Eine solche Funktion ist durch Mustervergleich leicht zu identifizieren.  Arend verwendet hierf√ºr das Schl√ºsselwort <code>\elim</code> .  Danach m√ºssen Sie die Variablen angeben, mit denen der Vergleich durchgef√ºhrt wird (wenn es mehr als eine solche Variable gibt, sollten sie mit einem Komma geschrieben werden).  Wenn der Vergleich f√ºr alle expliziten Parameter durchgef√ºhrt wird, kann <code>\elim</code> zusammen mit den Variablen weggelassen werden.  Das Folgende ist ein Block von Vergleichspunkten, die durch einen vertikalen Balken "|" voneinander getrennt sind.  Jedes Element in diesem Block ist ein Ausdruck der Form <code>¬´,    ¬ª =&gt; ¬´¬ª</code> . <br><br><pre> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  Im obigen Beispiel ist Parameter A der L√§ngenfunktion von geschweiften Klammern umgeben.  Diese Klammern in Arend werden verwendet, um implizite Argumente zu bezeichnen, d.h.  Argumente, die der Benutzer beim Aufrufen einer Funktion oder beim Verwenden eines Typs weglassen kann.  Beachten Sie, dass Sie in Arend die Infix-Notation nicht verwenden k√∂nnen, um Konstruktoren beim Abgleich mit einem Muster zu bestimmen. Daher wird im Beispielbeispiel die Pr√§fixnotation verwendet. <br><br>  Wie in Coq / Agda m√ºssen in Arend alle Funktionen garantiert abgeschlossen sein (d. H. In Arend ist eine Terminierungspr√ºfung vorhanden).  Bei der Definition der L√§ngenfunktion ist diese Pr√ºfung erfolgreich, da ein rekursiver Aufruf das erste explizite Argument streng reduziert.  Wenn eine solche Reduzierung nicht auftreten w√ºrde, w√ºrde Arend eine Fehlermeldung ausgeben. <br><br><pre> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  Arend erm√∂glicht zirkul√§re Abh√§ngigkeiten und gegenseitig rekursive Funktionen, f√ºr die auch Abschlusspr√ºfungen durchgef√ºhrt werden.  Der Algorithmus dieser Pr√ºfung basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von</a> A. Abel.  Darin finden Sie eine detailliertere Beschreibung der Bedingungen, die gegenseitig rekursive Funktionen erf√ºllen m√ºssen. <br><br><h2>  1.3 Wie unterscheiden sich Mengen von Aussagen? </h2><br>  Wir haben zuvor geschrieben, dass Beispiele f√ºr Typen Mengen und Anweisungen sind.  Dar√ºber hinaus haben wir die Schl√ºsselw√∂rter <code>\Type</code> und <code>\Set</code> , um Universen in Arend zu bezeichnen.  In diesem Abschnitt werden wir versuchen, detaillierter zu erkl√§ren, wie sich Aussagen in Bezug auf Variet√§ten der Intensit√§tstypentheorie (MLTT, CIC, HoTT) von Mengen unterscheiden, und gleichzeitig zu erkl√§ren, woraus die Bedeutung der Schl√ºsselw√∂rter <code>\Prop</code> , <code>\Set</code> und <code>\Type</code> in Arend besteht. <br><br>  Denken Sie daran, dass es in der klassischen Martin-L√∂f-Theorie keine Trennung von Typen in Mengen und Aussagen gibt.  Insbesondere gibt es theoretisch nur ein kumulatives Universum (das entweder mit Set in Agda oder Type in Idris oder Sort in Lean bezeichnet wird).  Dieser Ansatz ist der einfachste, aber es gibt Situationen, in denen sich seine M√§ngel manifestieren.  Angenommen, wir versuchen, den Typ "geordnete Liste" als abh√§ngiges Paar zu implementieren, das aus einer Liste und einem Nachweis seiner Reihenfolge besteht.  Es stellt sich heraus, dass es dann im Rahmen des ‚Äûreinen‚Äú MLTT nicht m√∂glich sein wird, die Gleichheit geordneter Listen zu beweisen, die aus identischen Elementen bestehen, die sich gleichzeitig in Begriffen der Ordnungsnachweise unterscheiden.  Eine solche Gleichheit w√§re sehr nat√ºrlich und w√ºnschenswert, so dass die Unm√∂glichkeit, sie zu beweisen, als theoretischer Fehler in der MLTT angesehen werden kann. <br><br>  In Agda wird dieses Problem teilweise mit Hilfe von sogenannten Annotationen der Immaterialit√§t gel√∂st (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> , in der das Listenbeispiel ausf√ºhrlicher besprochen wird).  Diese Annotationen sind jedoch weder ein Konstrukt aus der MLTT-Theorie noch vollwertige Konstrukte f√ºr Typen (es ist unm√∂glich, sie mit einer Typanmerkung zu markieren, die im Funktionsargument nicht verwendet wird). <br><br>  In CIC, basierend auf CIC, sind zwei verschiedene Universen ineinander verschachtelt: <code>Prop</code> (das Universum der Aussagen) und <code>Set</code> (das Universum der Mengen), die in die umfassende Hierarchie der <code>Type</code> eingetaucht sind.  Der Hauptunterschied zwischen <code>Prop</code> und <code>Set</code> besteht darin, dass es eine Reihe von Einschr√§nkungen f√ºr Variablen gibt, deren Typ zu <code>Prop</code> in Coq geh√∂rt.  Zum Beispiel k√∂nnen sie nicht f√ºr Berechnungen verwendet werden, und ein Vergleich mit der Stichprobe f√ºr sie ist nur innerhalb der Beweise anderer Aussagen m√∂glich.  Auf der anderen Seite sind alle Elemente des Typs, die zum <code>Prop</code> Universum geh√∂ren, im Axiom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unwichtiger</a> Beweise gleich, siehe die Aussage in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coq.Logic.ProofIrrelevance</a> .  Mit diesem Axiom k√∂nnten wir leicht die Gleichheit der oben genannten geordneten Listen beweisen. <br><br>  Betrachten Sie abschlie√üend den Arend / HoTT-Ansatz f√ºr Aussagen und Universen.  Der Hauptunterschied besteht darin, dass HoTT auf das Axiom unwichtiger Beweise verzichtet.  Das hei√üt, es gibt in HoTT kein spezielles Axiom, das postuliert, dass alle Elemente von Anweisungen gleich sind.  In HoTT ist ein Typ <i>per Definition</i> eine Aussage, wenn nachgewiesen werden kann, dass alle seine Elemente einander gleich sind.  Wir k√∂nnen ein Pr√§dikat f√ºr Typen definieren, das wahr ist, wenn der Typ eine Anweisung ist: <br><br><pre> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Es stellt sich die Frage: Welche Typen erf√ºllen dieses Pr√§dikat, dh sind Aussagen?  Es ist leicht zu √ºberpr√ºfen, ob dies f√ºr leere und Singleton-Typen gilt.  F√ºr Typen, bei denen mindestens zwei verschiedene Elemente vorhanden sind, gilt dies nicht mehr. <br><br>  Nat√ºrlich m√∂chten wir, dass alle notwendigen logischen Verkn√ºpfungen √ºber die Anweisungen definiert werden.  In Abschnitt 1.1 haben wir bereits diskutiert, wie sie mit typentheoretischen Konstruktionen bestimmt werden k√∂nnen.  Es gibt jedoch das folgende Problem: Nicht alle von uns eingegebenen <code>isProp</code> behalten die <code>isProp</code> Eigenschaft bei.  Konstruktionen des Produktprodukts und des (abh√§ngigen) Funktionstyps behalten diese Eigenschaft bei, w√§hrend die Konstruktionen der Summe von Typen und abh√§ngigen Paaren dies nicht tun.  Daher k√∂nnen wir die Disjunktion und den Quantifizierer der Existenz nicht verwenden. <br><br>  Dieses Problem kann mit Hilfe einer neuen Konstruktion gel√∂st werden, die zu HoTT hinzugef√ºgt wird, der sogenannten <i>Satzk√ºrzung</i> .  Mit diesem Design k√∂nnen Sie jeden Typ in eine Anweisung verwandeln.  Es kann als formale Operation betrachtet werden, bei der alle Begriffe, die in diesem Typ vorkommen, gleich sind.  Diese Operation √§hnelt den Annotationen der Immaterialit√§t von Agda, ist jedoch im Gegensatz zu ihnen eine vollwertige Operation f√ºr Typen mit der Signatur <code>\Type -&gt; \Prop</code> . <br><br>  Das letzte wichtige Beispiel f√ºr Aussagen ist die Gleichheit zweier Elemente eines Typs.  Es stellt sich heraus, dass im allgemeinen Fall die Art der Gleichheit <code>a = a'</code> keine Aussage sein muss.  Die Typen, f√ºr die es einer ist, werden Mengen genannt: <br><br><pre> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  Alle Typen, die in gew√∂hnlichen Programmiersprachen vorkommen, erf√ºllen dieses Pr√§dikat, dh Gleichheit auf ihnen ist eine Aussage.  Dies gilt beispielsweise f√ºr nat√ºrliche Zahlen, Ganzzahlen, Produkte von Mengen, Summen von Mengen, Funktionen √ºber Mengen, Listen von Mengen und andere induktive Datentypen, die aus Mengen aufgebaut sind.  Das hei√üt, wenn wir nur an solchen bekannten Konstruktionen interessiert sind, k√∂nnen wir nicht an beliebige Typen denken, die dieses Pr√§dikat nicht erf√ºllen.  Alle in Coq gefundenen Typen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mengen</a> . <br><br>  Typen, die keine Mengen sind, werden n√ºtzlich, wenn Sie sich mit der Homotopietypentheorie befassen m√∂chten.  Im Moment verweisen wir den Leser einfach auf das Standardbibliotheksmodul, das die Definition einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n-dimensionalen Kugel enth√§lt</a> , ein Beispiel f√ºr einen Typ, der keine Menge ist. <br><br>  Arend hat spezielle Universen <code>\Prop</code> und <code>\Set</code> , die aus Anweisungen bzw. Mengen bestehen.  Wenn wir bereits wissen, dass Typ A im Universum <code>\Prop</code> (oder <code>\Set</code> ) enthalten ist, kann der Beweis der entsprechenden <code>isProp</code> (oder <code>isSet</code> ) <code>isSet</code> in Arend mithilfe des im <a href="">Vorspiel integrierten</a> <code>Path.inProp</code> Axioms erhalten werden (wir geben ein Beispiel f√ºr die Verwendung dieses Axioms) in Abschnitt 2.3). <br><br><pre> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Wir haben bereits festgestellt, dass nicht alle nat√ºrlichen Konstrukte auf Typen die <code>isProp</code> Eigenschaft beibehalten.  Beispielsweise erf√ºllen induktive Datentypen mit zwei oder mehr Konstruktoren dies nie.  Wie oben erw√§hnt, k√∂nnen wir das <i>Satzk√ºrzungskonstrukt</i> verwenden, das jeden Typ in eine Anweisung verwandelt. <br>  In der Arend-Bibliothek hei√üt die Standardimplementierung der <code>Logic.TruncP</code> .  Wir k√∂nnten einen Typ von logischem "oder" in Arend so definieren, dass die Summe der Typen abgeschnitten wird: <br><br><pre> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/"</code> </pre> <br>  In Arend gibt es eine andere, einfachere und bequemere M√∂glichkeit, einen propositionell abgeschnittenen induktiven Typ zu definieren.  F√ºgen Sie dazu einfach das Schl√ºsselwort <code>\truncated</code> bevor Sie den Datentyp definieren.  Beispielsweise wird die Definition eines logischen "oder" in der Arend-Standardbibliothek wie folgt angegeben. <br><br><pre> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  Weitere Arbeiten mit propositionell abgeschnittenen Typen √§hneln denen von Typen, die dem <code>Prop</code> Universum in Coq zugeordnet sind.  Beispielsweise ist der Mustervergleich einer Variablen, deren Typ eine Anweisung ist, nur in einer Situation zul√§ssig, in der der Typ des zu definierenden Ausdrucks selbst eine Anweisung ist.  Somit ist es immer einfach, die Funktion <code>Or-to-||</code> zu definieren  durch Vergleich mit der Stichprobe, aber die Umkehrfunktion dazu, nur wenn der Typ A <code>`Or`</code> B eine Aussage ist (was selten genug ist, zum Beispiel wenn Typ <code>A</code> und <code>B</code> beide Aussagen sind und sich gegenseitig ausschlie√üen). <br><br><pre> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  Denken Sie auch daran, dass die Besonderheit des Mechanismus der Universen in Coq darin besteht, dass, wenn dem <code>Prop</code> Universum eine Definition zugewiesen wurde, diese in keiner Weise f√ºr die Berechnung verwendet werden kann.  Aus diesem Grund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empfehlen die</a> Coq-Entwickler selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht die</a> Verwendung von Satzkonstruktionen, sondern empfehlen, diese nach M√∂glichkeit durch Analoga aus dem Universum der Mengen zu ersetzen.  Der Mechanismus von Arend-Universen hat diesen Nachteil nicht, dh in bestimmten Situationen ist es m√∂glich, Aussagen in Berechnungen zu verwenden.  Wir werden ein Beispiel f√ºr eine solche Situation geben, wenn wir die Implementierung des Listensortierungsalgorithmus diskutieren. <br><br><h2>  1.4 Klassen in Arend </h2><br>  Da unser Ziel darin besteht, den einfachsten Sortieralgorithmus zu implementieren, erscheint es sinnvoll, sich mit der Implementierung der in der Arend-Standardbibliothek verf√ºgbaren geordneten Mengen vertraut zu machen. <br><br>  In Arend werden Klassen verwendet, um Operationen und Axiome zu kapseln, die mathematische Strukturen definieren, und um die Beziehungen zwischen diesen Strukturen mithilfe der Vererbung hervorzuheben.  Klassen sind auch Namespaces, in denen es zweckm√§√üig ist, Konstruktionen und Theorien zu platzieren, deren Bedeutung angemessen ist. <br><br>  Die Basisklasse, von der alle Auftragsklassen in Arend geerbt werden, ist die <code>BaseSet</code> Klasse, die keine anderen <code>BaseSet</code> als die Bezeichnung <code>E</code> f√ºr den <code>BaseSet</code> enth√§lt (d. H. Den Satz, f√ºr den <code>BaseSet</code> Nachkommenklassen bereits verschiedene Operationen einf√ºhren).  Betrachten Sie die Definition dieser Klasse aus der Standard-Arend-Bibliothek. <br><br><pre> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  In der obigen Definition wird Tr√§ger <code>E</code> als Klassenparameter deklariert.  Man kann sich fragen, gibt es einen Unterschied in der obigen Definition von <code>BaseSet</code> von der folgenden Definition, in der Tr√§ger E als Klassenfeld definiert ist? <br><br><pre> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  Eine etwas unerwartete Antwort ist, dass es in Arend <i>keinen Unterschied</i> zwischen den beiden Definitionen gibt, da jeder Klassenparameter (auch implizit) in Arend tats√§chlich sein Feld ist.  Daher k√∂nnte man f√ºr beide <code>BaseSet</code> Implementierungen den Ausdruck <code>xE</code> um auf das Feld E zuzugreifen. <code>BaseSet</code> immer noch einen Unterschied zwischen den obigen Varianten der <code>BaseSet</code> Definition, aber es ist subtiler, wir werden ihn im n√§chsten Abschnitt genauer untersuchen, wenn wir Klasseninstanzen diskutieren ( Klasseninstanzen). <br><br>  Das Sortieren einer Liste ist nur dann sinnvoll, wenn f√ºr den Objekttyp in der Liste eine lineare Reihenfolge angegeben ist. Daher betrachten wir zun√§chst die Definitionen einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">streng teilweise geordneten Menge</a> und einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linear geordneten Menge.</a> <br><br><pre> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  Aus Sicht der Typentheorie k√∂nnen Klassen in Arend als Analoga von Sigma-Typen mit einer bequemeren Syntax f√ºr Projektionen und Konstruktoren betrachtet werden.  ,  Arend-    -,       . <br><br>     ,     <i></i> .     ,      . ,  StrictPoset  <code>&lt;-irreflexive</code>  <code>&lt;-transitive</code>  ,   <code>E</code>  <code>&lt;</code> ‚Äî .     ,     (,  ,    )    ,       . <br><br>        ,   ,    .   ,   Arend  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,  ,      .  ,       . ,     ,        ,     ,      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  : <br><br><pre> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br>  <code>Dec</code>     ,  <code>Dec E</code>     ,  <code>E</code> ,      <code>E</code> ,   <code>E</code> . <br><br><pre> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br> , ,  <code>Dec</code> (  decidable)   <code>Order.LinearOrder</code> .  Dec    , ,  ,     <code>trichotomy</code> , ,      <code>E</code> ,    &lt;.  , <code>Dec</code>      Comparable  Java. <br><br><pre> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br>   <code>Dec</code>         <code>Dec</code> ,    ,   ,  ,            .     <code>Dec</code>    ,     . <br><br>       ,          <code>Dec</code> (        ).  <code>Dec</code> ,   Arend    ( <code>Dec</code>     <code>LinearOrder,</code>  <code>DecSet</code> ),  ,     (diamond inheritance). <br><br>       :                ,     (    ,       ). <br><br>    <code>Dec</code>   <code>Order.LinearOrder</code>   IDEA    (      [Ctrl]+[H]),   ,    . <br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br>              Arend (    IDEA    <code>BaseSet</code> ).   ,      . <br><br><h2> 1.5  ,  ,     . </h2><br>        <code>StrictPoset</code>     Nat.  Arend       ,     .       -,  ,    ,   - (   ),           . <br><br>         :   .             . <br><br><pre> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br>       <code>\func</code>   <code>\lemma</code> .      ,       ,        ,     .      ,   <code>\lemma</code>  ,        <code>\Prop</code> . <br><br>    <code>x'&lt;y'</code> ‚Äî    -,    <code>x' &lt; y'</code> .         - (.. ,       ,     ). <br><br>      (instance)  <code>StrictPoset</code> .  Arend       .           <code>\new</code>   .      ¬´  ¬ª. <br><br><pre> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  <code>StrictPoset { ‚Ä¶ }</code>       <code>\new</code> :       - <code>StrictPoset</code> .   -    , ,    ,        <code>\new</code>  .   <code>\new C { ‚Ä¶ }</code>   <code>C { ‚Ä¶ }</code> .       C,      C. ,    ,  <code>NatOrder</code>    <code>StrictPoset</code> . <br><br>    ,         .  ,       <code>StrictPoset Nat</code>      <code>StrictPoset { | E =&gt; Nat }</code> . ,        <code>NatOrder</code>  <code>StrictPoset</code> ,           (     ). <br><br>      <code>NatOrder</code>      <code>\cowith</code>    (          - ). <br><br><pre> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br> , ,          <code>\instance.</code> <br><br><pre> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  Arend     ,     Haskell.   <code>NatOrder</code>    <code>\instance</code>    <code>\cowith</code>      ,           <code>StrictPoset</code> (    ). <br><br> ,    <code>BaseSet</code>    - E     (   ),      ,         E   .      . <br><br>  ,         Arend      .   Arend  ,            ,       (  ,  ¬´ <i> </i> ¬ª         <code>\classifying \field</code> ,    Arend      ).      : <br><br><ul><li> Arend                . ,  <code>X</code>   <code>StrictPoset</code> ,   <code>List X</code>         <code>List XE</code> . <br></li><li> Arend          . </li></ul><br>  ,    . ,         <code>\instance</code>    <code>StrictPoset</code>    ,     <code>Nat</code>    <code>Int</code> (   <code>NatOrder</code>  <code>IntOrder</code> ). <br><br> ,      <code>x &lt; y</code>      ,  x, y   ,    ,  x, y   .    Arend  ,     <code>NatOrder.&lt;</code> ,    ‚Äî <code>IntOrder.&lt;</code> . <br><br>    ,     . Arend ,   &lt;    <code>StrictPoset</code> ,       E. , Arend      <code>x&lt;y</code>          <code>StrictPoset</code> (  ),     E   .    ,    <code>&lt;</code>     . <br><br> ,                     Arend.        ,     <code>\use \coerce</code>  <i> </i>  .  Arend      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ‚Äî   ,   ,       .       -  ,    <code>\where</code> . <br><br>       .  <code>fromNat</code>         . <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br>    <code>\use \coerce</code>  <code>\func</code>   ,          .     ,         ,      (,     ,        ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469569/">https://habr.com/ru/post/de469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469551/index.html">VDS mit Grafikkarte - wir wissen viel √ºber Perversionen</a></li>
<li><a href="../de469555/index.html">Ausstrahlung: Moscow Kubernetes Meetup # 6</a></li>
<li><a href="../de469557/index.html">Generische Recycler-Ansicht oder wie man keinen Boilerplate-Code schreibt</a></li>
<li><a href="../de469561/index.html">Berechnung der ganzzahligen Quadratwurzel</a></li>
<li><a href="../de469567/index.html">Hintergrund: Details zum iPhone 11, 11 Pro und zur neuen Apple Watch nach zweiw√∂chigem Test</a></li>
<li><a href="../de469573/index.html">Linux Piter 2019: Was erwartet die G√§ste f√ºr eine gro√üe Linux-Konferenz und warum sollte sie nicht verpasst werden?</a></li>
<li><a href="../de469575/index.html">So programmieren Sie den Schlafmodus neu: 30 Tage jeden Morgen strahlte mir ein hellgr√ºnes Licht in die Augen</a></li>
<li><a href="../de469577/index.html">Festplattenforensik, Speicherforensik und Protokollforensik. Volatilit√§tsrahmen und Autopsie. Probleml√∂sung mit r0ot-mi. Teil 1</a></li>
<li><a href="../de469581/index.html">Picabu-Effektanalyse</a></li>
<li><a href="../de469583/index.html">OpenVPN und Active Directory (Kerberos ohne Benutzerzertifikate)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>