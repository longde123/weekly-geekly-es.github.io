<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 📬 👩‍👧‍👦 Métodos de sobrecarga ou ponte proibidos em Java ❤️ 🐣 👶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maioria das minhas entrevistas em posições técnicas tem uma tarefa na qual o candidato precisa implementar 2 interfaces muito semelhantes na mesma c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Métodos de sobrecarga ou ponte proibidos em Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/426419/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/hs/hb/ihhshbtkwuq00zlpb7envgpgkk0.jpeg"></div><br><p>  A maioria das minhas entrevistas em posições técnicas tem uma tarefa na qual o candidato precisa implementar 2 interfaces muito semelhantes na mesma classe: </p><br><p>  <em>Implemente as duas interfaces em uma classe, se possível.</em>  <em>Explique por que isso é possível ou não.</em> </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithPrimitiveInt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithInteger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer i)</span></span></span></span>; }</code> </pre> <br><p>  <em>De um tradutor:</em> este artigo não incentiva você a fazer as mesmas perguntas em uma entrevista.  Mas se você quiser estar totalmente preparado quando essa pergunta for feita, seja bem-vindo ao gato. </p><a name="habracut"></a><br><p>  Às vezes, os candidatos que não têm muita certeza da resposta, preferem resolver esse problema com a seguinte condição (posteriormente, em qualquer caso, peço que você o resolva): </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; }</code> </pre> <br><p>  De fato, a segunda tarefa parece muito mais simples, e a maioria dos candidatos responde que é impossível incluir os dois métodos na mesma classe, porque as assinaturas <code>Sm(int)</code> e <code>Vm(int)</code> mesmas, enquanto o tipo do valor de retorno é diferente.  E isso é absolutamente verdade. </p><br><p>  No entanto, às vezes faço outra pergunta relacionada a este tópico: </p><br><p>  <em>Você acha que faz sentido permitir a implementação de métodos com a mesma assinatura, mas com tipos diferentes na mesma classe?</em>  <em>Por exemplo, em alguma linguagem hipotética baseada na JVM, ou pelo menos no nível da JVM?</em> </p><br><p>  Esta é uma pergunta cuja resposta é ambígua.  Mas, apesar de não esperar uma resposta, a resposta correta existe.  Uma pessoa que lida com a API de reflexão, manipula o bytecode ou está familiarizada com a especificação da JVM pode respondê-la. </p><br><h2 id="signatura-metoda-java-i-deskriptor-metoda-jvm">  Assinatura do método Java e identificador do método JVM </h2><br><p>  A assinatura do método Java (ou seja, o nome do método e os tipos de parâmetros) é usada apenas pelo compilador Java no momento da compilação.  Por sua vez, a JVM separa os métodos na classe usando um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nome de método não qualificado</a> (ou seja, apenas um nome de método) e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificador de método</a> , ou seja, uma lista de parâmetros do descritor e um descritor de retorno. </p><br><p>  Por exemplo, se quisermos chamar o método <code>String m(int i)</code> diretamente na classe <code>foo.Bar</code> , o seguinte bytecode será necessário: </p><br><pre> <code class="hljs julia">INVOKEVIRTUAL foo/Bar.m (<span class="hljs-literal"><span class="hljs-literal">I</span></span>)Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>;</code> </pre> <br><p>  e para void <code>m(int i)</code> seguinte: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> foo/Bar.m (I)V</code> </pre> <br><p>  Portanto, a JVM é bastante confortável com as <code>String m(int i)</code> e <code>void m(int i)</code> da mesma classe.  Tudo o que é necessário é gerar o bytecode correspondente. </p><br><h2 id="kung-fu-s-bayt-kodom">  Kung fu com bytecode </h2><br><p>  Temos interfaces S e V, agora criaremos uma classe SV que inclui as duas interfaces.  Em Java, se fosse permitido, deveria ficar assim: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SV</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"void m(int i)"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"String m(int i)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br><p>  Para gerar o bytecode, usamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca Objectweb ASM</a> , uma biblioteca de nível inferior o suficiente para ter uma idéia da JVM do bytecode. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código fonte completo é</a> carregado no GitHub, aqui darei e explicarei apenas os fragmentos mais importantes. </p><br><pre> <code class="java hljs">ClassWriter cw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(ClassWriter.COMPUTE_FRAMES); <span class="hljs-comment"><span class="hljs-comment">// package edio.java.experiments // public class SV implements S, V cw.visit(V1_7, ACC_PUBLIC, "edio/java/experiments/SV", null, "java/lang/Object", new String[]{ "edio/java/experiments/S", "edio/java/experiments/V" }); // constructor MethodVisitor constructor = cw.visitMethod(ACC_PUBLIC, "&lt;init&gt;", "()V", null, null); constructor.visitCode(); constructor.visitVarInsn(Opcodes.ALOAD, 0); constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "&lt;init&gt;", "()V"); constructor.visitInsn(Opcodes.RETURN); constructor.visitMaxs(1, 1); constructor.visitEnd(); // public String m(int i) MethodVisitor mString = cw.visitMethod(ACC_PUBLIC, "m", "(I)Ljava/lang/String;", null, null); mString.visitCode(); mString.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mString.visitLdcInsn("String"); mString.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mString.visitInsn(Opcodes.ACONST_NULL); mString.visitInsn(Opcodes.ARETURN); mString.visitMaxs(2, 2); mString.visitEnd(); // public void m(int i) MethodVisitor mVoid = cw.visitMethod(ACC_PUBLIC, "m", "(I)V", null, null); mVoid.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mVoid.visitLdcInsn("void"); mVoid.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mVoid.visitInsn(Opcodes.RETURN); mVoid.visitMaxs(2, 2); mVoid.visitEnd(); cw.visitEnd();</span></span></code> </pre> <br><p>  Vamos começar criando um <code>ClassWriter</code> para gerar bytecode. </p><br><p>  Agora vamos declarar uma classe que inclui as interfaces S e V. </p><br><p>  Embora nosso código pseudo-java de referência para SV não tenha construtores, ainda precisamos gerar código para ele.  Se não descrevermos construtores em Java, o compilador gera implicitamente um construtor vazio. </p><br><p>  No corpo dos métodos, começamos obtendo o campo <code>System.out</code> do tipo <code>java.io.PrintStream</code> e adicionando-o à pilha de operandos.  Em seguida, carregamos a constante ( <code>String</code> ou <code>void</code> ) na pilha e chamamos o comando <code>println</code> na variável resultante com uma constante de string como argumento. </p><br><p>  Finalmente, para a <code>String m(int i)</code> adicionamos a constante do tipo de referência com o valor <code>null</code> à pilha e usamos a <code>return</code> tipo correspondente, ou <code>ARETURN</code> , <code>ARETURN</code> , para retornar o valor ao iniciador da chamada do método.  Para <code>void m(int i)</code> você precisa usar <code>RETURN</code> apenas para retornar ao iniciador da chamada do método sem retornar um valor.  Para garantir que o bytecode esteja correto (o que eu faço constantemente, corrigindo erros muitas vezes), escrevemos a classe gerada no disco. </p><br><pre> <code class="java hljs">Files.write(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"/tmp/SV.class"</span></span>).toPath(), cw.toByteArray());</code> </pre> <br><p>  e use <code>jad</code> (descompilador Java) para converter o bytecode de volta no código-fonte Java: </p><br><pre> <code class="java hljs">$ jad -p /tmp/SV.class The <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">version</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> 51.0 (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">only</span></span></span><span class="hljs-class"> 45.3, 46.0 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">and</span></span></span><span class="hljs-class"> 47.0 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">are</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">supported</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decompiled</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">.5.8</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Copyright</span></span></span><span class="hljs-class"> 2001 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pavel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kouznetsov</span></span></span><span class="hljs-class">. // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">home</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">www</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geocities</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kpdus</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jad</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decompiler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">packimports</span></span></span><span class="hljs-class">(3) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edio</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">experiments</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintStream; <span class="hljs-comment"><span class="hljs-comment">// Referenced classes of package edio.java.experiments: // S, V public class SV implements S, V { public SV() { } public String m(int i) { System.out.println("String"); return null; } public void m(int i) { System.out.println("void"); } }</span></span></code> </pre> <br><p>  Nada mal na minha opinião. </p><br><h2 id="ispolzovanie-sgenerirovannogo-klassa">  Usando a classe gerada </h2><br><p>  A descompilação bem-sucedida do <code>jad</code> basicamente não garante nada para nós.  O utilitário <code>jad</code> alerta apenas para problemas comuns no código de bytes, do tamanho do quadro às incompatibilidades de variáveis ​​locais ou declarações de retorno ausentes. </p><br><p>  Para usar a classe gerada em tempo de execução, precisamos carregá-la de alguma forma na JVM e instancia-la. </p><br><p>  Vamos implementar nosso próprio <code>AsmClassLoader</code> .  Este é apenas um invólucro útil para <code>ClassLoader.defineClass</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmClassLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassLoader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defineAsmClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, ClassWriter classWriter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = classWriter.toByteArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defineClass(name, bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.length); } }</code> </pre> <br><p>  Agora use este carregador de classes e instancie a classe: </p><br><pre> <code class="java hljs">ClassWriter cw = SVGenerator.generateClass(); AsmClassLoader classLoader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsmClassLoader(); Class&lt;?&gt; generatedClazz = classLoader.defineAsmClass(SVGenerator.SV_FQCN, cw); Object o = generatedClazz.newInstance();</code> </pre> <br><p>  Como nossa classe é gerada em tempo de execução, não podemos usá-la no código fonte.  Mas podemos converter esse tipo para interfaces implementadas.  Uma chamada sem reflexão pode ser feita assim: </p><br><pre> <code class="java hljs">((S)o).m(<span class="hljs-number"><span class="hljs-number">1</span></span>); ((V)o).m(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Ao executar o código, obtemos a seguinte saída: </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span></code> </pre> <br><p>  Para alguns, essa conclusão pode parecer inesperada: nos referimos ao mesmo método (do ponto de vista Java) na classe, mas os resultados diferem dependendo da interface para a qual trouxemos o objeto.  Impressionante, certo? </p><br><p>  Tudo ficará claro se levarmos em conta o bytecode subjacente.  Para nossa chamada, o compilador gera uma instrução INVOKEINTERFACE, e o identificador do método não vem da classe, mas da interface. </p><br><p>  Assim, a primeira chamada que recebemos: </p><br><pre> <code class="hljs lisp">INVOKEINTERFACE edio/java/experiments/Sm (<span class="hljs-name"><span class="hljs-name">I</span></span>)Ljava/lang/String<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  e no segundo: </p><br><pre> <code class="hljs lisp">INVOKEINTERFACE edio/java/experiments/Vm (<span class="hljs-name"><span class="hljs-name">I</span></span>)V</code> </pre> <br><p>  O objeto no qual fizemos a chamada pode ser obtido da pilha.  Este é o poder do polimorfismo inerente ao Java. </p><br><h2 id="imya-emu---bridge-metod">  O nome dele é o método bridge </h2><br><p>  Alguém perguntará: "Então, qual é o sentido de tudo isso? Será que algum dia será útil?" </p><br><p>  O ponto é que usamos a mesma coisa (implicitamente) ao escrever código Java regular.  Por exemplo, tipos de retorno covariantes, genéricos e acesso a campos particulares de classes internas são implementados usando a mesma <em>mágica do</em> bytecode. </p><br><p>  Dê uma olhada nesta interface: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Number </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  e sua implementação com o retorno do tipo covariante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerZero</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><p>  Agora vamos pensar sobre este código: </p><br><pre> <code class="java hljs">IntegerZero iz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntegerZero(); iz.getZero(); ZeroProvider zp = iz; zp.getZero();</code> </pre> <br><p>  Para <code>iz.getZero()</code> , o compilador de chamadas gerará <code>INVOKEVIRTUAL</code> com o <code>()Ljava/lang/Integer;</code> descritor <code>()Ljava/lang/Integer;</code>  , enquanto que para <code>zp.getZero()</code> ele gerará INVOKEINTERFACE com o descritor de método <code>()Ljava/lang/Number;</code>  .  Já sabemos que a JVM despacha uma chamada de objeto usando o descritor de nome e método.  Como os descritores são diferentes, essas 2 chamadas não podem ser roteadas para o mesmo método em uma instância <code>IntegerZero</code> . </p><br><p>  De fato, o compilador gera um método adicional que atua como uma ponte entre o método real especificado na classe e o método usado ao chamar pela interface.  Portanto, o nome é o método da ponte.  Se isso fosse possível em Java, o código final ficaria assim: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerZero</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// This is a synthetic bridge method, which is present only in bytecode. // Java compiler wouldn't permit it. public Number getZero() { return this.getZero(); } }</span></span></code> </pre> <br><h2 id="posleslovie">  Posfácio </h2><br><p>  A linguagem de programação Java e a máquina virtual Java não são a mesma coisa: embora tenham uma palavra comum no nome e Java seja a linguagem principal da JVM, seus recursos e limitações estão longe de ser sempre os mesmos.  Conhecer a JVM ajuda a entender melhor Java ou qualquer outra linguagem baseada em JVM, mas, por outro lado, conhecer Java e seu histórico ajuda a entender certas decisões no design da JVM. </p><br><h3 id="ot-perevodchika">  Do tradutor </h3><br><p>  Os problemas de compatibilidade, mais cedo ou mais tarde, começam a preocupar qualquer desenvolvedor.  O artigo original abordou a questão importante do comportamento implícito do compilador Java e o efeito de sua mágica nos aplicativos, que nós, como desenvolvedores da estrutura da Plataforma CUBA, nos preocupamos bastante, isso afeta diretamente a compatibilidade das bibliotecas.  Mais recentemente, falamos sobre compatibilidade em aplicativos da vida real no JUG em Ecaterimburgo no relatório “APIs não mudam no cruzamento - como criar uma API estável”, o vídeo da reunião pode ser encontrado aqui. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JLGh08KXN08" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426419/">https://habr.com/ru/post/pt426419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426409/index.html">O hacker Alexei, que protege os roteadores MikroTik sem a permissão dos proprietários, tornou-se famoso</a></li>
<li><a href="../pt426411/index.html">Desenvolvendo Classes de Descritores C ++ / CLI</a></li>
<li><a href="../pt426413/index.html">Princípios do SOLID que todo desenvolvedor deve conhecer</a></li>
<li><a href="../pt426415/index.html">Fintech-digest: controle de digitalização pelo Banco Central, salário de criptomoeda, cartão Mir em forma de pulseiras e chaveiros</a></li>
<li><a href="../pt426417/index.html">Pavel 2.0: consultor reptilóide em JS, node.js com soquetes e telefonia</a></li>
<li><a href="../pt426421/index.html">EHCI humanamente em russo</a></li>
<li><a href="../pt426423/index.html">mmWave em smartphones: como a Qualcomm tornou possível o impossível</a></li>
<li><a href="../pt426425/index.html">Toda a verdade sobre o RTOS. Artigo 14. Seções de memória: introdução e serviços básicos</a></li>
<li><a href="../pt426427/index.html">Coisas úteis para "coisas": uma pequena seleção com preços baixos</a></li>
<li><a href="../pt426429/index.html">Instalando o FreeSWITCH 1.8 no Debian 9 (Raspbian Stretch, a imagem básica do sistema Smart Home do MajorDoMo no Rasbperri Pi)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>