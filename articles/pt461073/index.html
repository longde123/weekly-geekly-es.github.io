<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐊 🧔 🚣🏼 Conectamos mapas on-line ao navegador no smartphone. Parte 3 - OverpassTurbo 🍝 🧦 🦈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transformamos o script criado anteriormente em uma API para visualizar um mapa interativo no site OverpassTurbo.eu por meio do aplicativo de navegação...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectamos mapas on-line ao navegador no smartphone. Parte 3 - OverpassTurbo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461073/"><p>  Transformamos o script criado anteriormente em uma API para visualizar um mapa interativo no site OverpassTurbo.eu por meio do aplicativo de navegação do smartphone. </p><a name="habracut"></a><br><p>  Conteúdo: </p><br><p>  1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdução.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de varredura padrão</a> <br>  2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continuação.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escrevendo um rasterizador simples para mapas vetoriais</a> <br>  3 - Um caso especial.  Conectamos o cartão OverpassTurbo </p><br><h3 id="chto-takoe-overpassturbo">  O que é o OverpassTurbo? </h3><br><p> Então  Existe um banco de dados de mapas como o OpenStreetMaps.  Ele contém tudo: os mares, os contornos dos continentes, montanhas, florestas, estradas, edifícios, playgrounds e até lombas.  Cada objeto tem um nome, coordenadas e propriedades.  Por exemplo, a estrada possui o material de revestimento, o prédio possui o número de pisos e assim por diante. </p><br><p>  Então aqui.  A maioria dos cartões apresentados hoje na Internet é gerada com base nesse banco de dados específico.  Mas e se todos esses cartões prontos não forem adequados para nós?  Você pode fazer o seu próprio!  Bem, ou pelo menos complementar o existente, o que é muito mais fácil. </p><br><p>  Isto é o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">OverpassTurbo.eu</a> está fazendo.  É um IDE online.  Usando-o, você pode consultar o banco de dados OSM.  Clicamos no botão <strong>Iniciar</strong> , a solicitação vai para o banco de dados e, após algum tempo, os dados retornam para nós.  O OverpassTurbo visualiza esses dados na forma de marcadores de vetor e linhas localizadas na parte superior da camada de plano de fundo - um mapa do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">OpenSteerMap.org</a> . </p><br><p>  Como um exemplo do que você pode fazer com o OverpassTurbo, quero mostrar o script que eu mais gosto.  Foi escrito por um usuário sob o apelido Erelen.  Então: esse script desenha no mapa várias fontes de água potável e seu nome.  Na minha opinião, é muito útil e muito claro.  Para ver como esse script funciona, basta seguir o link e clicar em <strong>Iniciar</strong> .  (Se o site apresentar um erro, acesse a VPN e tente novamente) </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://overpass-turbo.eu/s/z95</a> </p><br><p><img src="https://habrastorage.org/webt/64/fa/g4/64fag4skex-vyoy75agsaqvt0_w.png"></p><br><p>  Ou aqui está um script que eu já fiz para minhas próprias necessidades.  Com ele, você pode facilmente encontrar boas rotas de corrida em parques desconhecidos.  Para fazer isso, o script destaca caminhos de cascalho bem iluminados: é o mais conveniente percorrer esses caminhos, para o meu gosto.  O asfalto está marcado em branco.  Caminhos de terra comuns em preto.  Mas todos os caminhos com a etiqueta “difícil de alcançar” ou “baixa qualidade de revestimento” serão marcados com uma linha tracejada discreta: para tropeçar com menos frequência, tento evitá-los.  Em geral, o mapa é feito para que você possa simplesmente obter instruções nas linhas mais impressionantes.  E para que, no final, essa rota seja bem-sucedida. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">http://overpass-turbo.eu/s/KXU</a> </p><br><p><img src="https://habrastorage.org/webt/gi/8n/pa/gi8npad8i2az-pu8q2x2gb7xziw.png"></p><br><p>  De fato, com esta ferramenta você pode complementar o mapa com os dados que desejar.  E notei que isso é muito, muito emocionante.  Mas este artigo não é sobre isso.  Se você estiver interessado neste tópico, poderá se familiarizar com os conceitos básicos do Overpass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> . </p><br><p>  Mas antes de passar para o código, vamos primeiro dar uma olhada no resultado final que devemos obter. </p><br><h3 id="instrukciya-dlya-polzovateley-kak-polzovatsya-nashim-api">  Instruções para usuários: como usar nossa API </h3><br><p>  Então  Suponha que você já tenha um script pronto para o OverpassTurbo, cujos resultados você deseja ver no seu smartphone.  E não no navegador, mas no navegador.  Para fazer isso, traga seu script para o seguinte formato. </p><br><pre><code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[bbox:{{bbox}}]</span></span>; ( //     <span class="hljs-selector-tag"><span class="hljs-selector-tag">node</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[amenity=waste_basket]</span></span>; ); <span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span>;&gt;;<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">skel</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">qt</span></span>;</code> </pre> <br><p>  Em particular, estamos interessados ​​na primeira linha: nosso aplicativo a substituirá. </p><br><p>  Depois disso, clique no botão <strong>Compartilhar</strong> .  Certifique-se de desmarcar a <strong>caixa Ativar estado do mapa exibido</strong> . </p><br><p><img src="https://habrastorage.org/webt/vi/75/ug/vi75ughpyooqulnwtesjmeftlwk.png"></p><br><p>  Depois disso, copie o link.  Por exemplo, supomos que seu link copiado tenha esta aparência: </p><br><p> <code>http://overpass-turbo.eu/s/KEy</code> </p> <br><p>  Agora veja nossa API </p><br><p> <code>https://anygis.herokuapp.com/mapshoter/overpass/{x}/{y}/{z}/{crossZoom}?script={script}</code> </p> <br><p>  Com <strong>{x}, {y}</strong> e <strong>{z},</strong> tudo parece estar claro: essas são as coordenadas do bloco desejado. </p><br><p>  No lugar de <strong>{script},</strong> você precisa substituir o <strong>ID do</strong> seu script.  No nosso exemplo, <strong>s / Key</strong> . </p><br><p>  Mas o que é <strong>{crossZoom}</strong> ?  Suponha que você tenha 15. Então, se você solicitar um bloco com um zoom menor que 15, o servidor não fará uma solicitação lenta ao OverpassTurbo, mas simplesmente o redirecionará para o mapa com uma camada de plano de fundo vazia do OpenStreetMaps (que será carregada quase instantaneamente).  Essa abordagem é necessária para que, se necessário, você possa mover o mapa, rolar rapidamente para o local de interesse, aumentar o zoom e aguardar.  Aguarde até OverpassTurbo gerar um mapa com os resultados. </p><br><p>  Espero que o princípio básico seja claro.  Agora veja o URL completo para a nossa solicitação.  Acho que agora não será difícil usar nossa API: basta substituir <strong>s / KEy</strong> pelo <strong>ID do</strong> seu script. </p><br><p> <code>https://anygis.herokuapp.com/mapshoter/overpass/{x}/{y}/{z}/15?script=s/KEy</code> </p> <br><p>  E, enquanto isso, veremos como implementar esse aplicativo. </p><br><h3 id="scenariy-3--poisk-s-pomoschyu-url-i-kesha-brauzera">  Cenário 3 - Pesquise usando o URL e o cache do navegador </h3><br><p>  Então  Vamos começar com o arquivo <strong>router.js</strong> .  Vamos fazer com que nosso método aceite parâmetros <strong>crossZoom</strong> e <strong>script</strong> .  E então nós os passamos para o trabalhador.  Também adicionamos uma opção que interrompe o script e redireciona o usuário para outro site se o zoom solicitado for muito baixo. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { StaticPool } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'node-worker-threads-pool'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-string"><span class="hljs-string">"./worker.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workersPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticPool({ <span class="hljs-attr"><span class="hljs-attr">size</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">task</span></span>: worker, <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: <span class="hljs-string"><span class="hljs-string">"no"</span></span> }) <span class="hljs-comment"><span class="hljs-comment">//     app.get( '/:x/:y/:z/:crossZoom', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z const crossZoom = req.params.crossZoom const scriptName = req.query.script //     if ( Number( z ) &lt; Number( crossZoom ) ) { res.redirect( `http://tile.openstreetmap.org/${z}/${x}/${y}.png` ) } //      const screenshot = await workersPool.exec( { x, y, z, scriptName } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre><br><p>  O arquivo <strong>worker.js</strong> não mudou muito.  Apenas encaminhe as novas variáveis ​​ainda mais. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browser = <span class="hljs-string"><span class="hljs-string">"empty"</span></span> parentPort.on( <span class="hljs-string"><span class="hljs-string">"message"</span></span>, ( params ) =&gt; { doMyAsyncCode( params ) .then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> result </span></span></span><span class="hljs-function">) =&gt;</span></span> { parentPort.postMessage( result ) }) }) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMyAsyncCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> params </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> prepareEnviroment() <span class="hljs-comment"><span class="hljs-comment">//   const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, params.scriptName, browser ) return screenshot } async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Agora vamos <strong>dar uma</strong> olhada no <strong>mapshoter.js</strong> .  Primeiro, veja o código: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, scriptName, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const runButtonSelector = '#navs &gt; div &gt; div.buttons &gt; div:nth-child(1) &gt; a:nth-child(1)' const codeEditorSelector = '#editor &gt; div.CodeMirror.CodeMirror-wrap &gt; div:nth-child(1) &gt; textarea' //          const coordinates = geoTools.getAllCoordinates( x, y, z ) const bBox = `[bbox:${coordinates.bBox.latMin}, ${coordinates.bBox.lonMin}, ${coordinates.bBox.latMax}, ${coordinates.bBox.lonMax}];` const centerCoordinates = `${coordinates.center.lat};${coordinates.center.lon};${z}` //      const browser = await browserLink const page = await browser.newPage() await page.setViewport( { width: 850, height: 450 } ) //  ,   : //      await page.waitFor( randomInt( 0, 500 ) ) //        URL var pageUrl = `http://overpass-turbo.eu/?C=${centerCoordinates}` await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //       URL pageUrl = 'http://overpass-turbo.eu/' + scriptName await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //      await page.focus( codeEditorSelector ) //        , //     await page.keyboard.type( bBox + ' //' ) // ,  -IDE   await page.waitFor( 100 ) //     - await page.click( runButtonSelector ) // ,      . //     . await page.waitForFunction(() =&gt; !document.querySelector('body &gt; div.modal &gt; div &gt; ul &gt; li:nth-child(1)'), {polling: 'mutation'}); await page.waitFor( 1000 ) //    const cropOptions = { fullPage: false, clip: { x: 489, y: 123, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await page.close() return screenshot } //       function randomInt( low, high ) { return Math.floor( Math.random() * ( high - low ) + low ) } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Para começar, neste script, por uma questão de variedade, trabalharemos com seletores de elementos comuns (que não são <strong>XPath</strong> ).  Como encontrá-los foi descrito em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . </p><br><p>  Em seguida, obtemos as coordenadas.  Somente desta vez, além das coordenadas centrais, também são necessárias as coordenadas das bordas do <strong>bloco</strong> ( <strong>bBox</strong> ). </p><br><p>  Em seguida, inicie o navegador.  Tudo é típico aqui.  Mas antes de passar para carregar a página, deixe o script aguardar um período aleatório de 0 a 500 ms.  Para que não recebamos muitas solicitações idênticas ao mesmo tempo e não sejam banidos. </p><br><p>  Depois disso, vamos ao site na URL à qual as coordenadas do centro do bloco são adicionadas.  Como resultado, o local desejado está no centro do mapa. </p><br><p>  Depois disso, vá para outro URL.  Desta vez com o <strong>ID do</strong> nosso script.  Como resultado, nosso script aparecerá no texto do editor de código. </p><br><p>  (Observe que, se no menu <strong>Compartilhar</strong> ao copiar o URL do nosso script, não desmarcarmos a caixa de seleção <strong>Salvar estado</strong> do mapa, o mapa mudará. E não precisamos disso. </p><br><p>  E agora vou responder razoavelmente à pergunta: por que vamos ao URL duas vezes, ou seja, gastamos duas vezes no carregamento deste site?  Eu respondo.  Porque, em primeiro lugar, não consegui encontrar como combinar o carregamento de scripts e a transição para as coordenadas especificadas em uma solicitação de URL.  Segundo, porque, por alguma razão, o Puppeteer imprime o texto com extrema lentidão e trabalha com os elementos de interface deste site.  Um minuto e meio pode ser impresso!  Assim, a ideia de inserir as coordenadas no campo de pesquisa e, em seguida, clicar nos botões de zoom, como fizemos no artigo anterior, foi decidido recusar.  Como resultado, clicar duas vezes no link resultou muito mais rápido do que fazer tudo isso.  Talvez isso seja um bug e seja corrigido mais cedo ou mais tarde, mas por enquanto estamos trabalhando com o que é. </p><br><p>  Infelizmente, você não poderá deixar completamente a entrada de texto.  Teremos que substituir a primeira linha na janela do editor de código.  No momento, ela relata que é necessário baixar informações do banco de dados para todo o território que está atualmente na tela. </p><br><pre> <code class="javascript hljs">[bbox:{{bbox}}];</code> </pre> <br><p>  Vamos substituí-lo pelas coordenadas das bordas do bloco.  Isso é para não perder muito tempo baixando do banco de dados.  Portanto, o script imprime na primeira linha algo como este texto: </p><br><pre> <code class="javascript hljs">[bbox:<span class="hljs-number"><span class="hljs-number">55.6279</span></span>, <span class="hljs-number"><span class="hljs-number">37.5622</span></span>, <span class="hljs-number"><span class="hljs-number">55.6341</span></span>, <span class="hljs-number"><span class="hljs-number">37.5732</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br><p>  E para não precisar apagar a linha original (muitas vezes pressionando <strong>Excluir</strong> para isso), basta comentar.  Assim, reduziremos o máximo possível o tempo gasto na inserção de texto e o tempo de carregamento do banco de dados.  Como resultado, a primeira linha ficará assim: </p><br><pre> <code class="javascript hljs">[bbox:<span class="hljs-number"><span class="hljs-number">55.6279</span></span>, <span class="hljs-number"><span class="hljs-number">37.5622</span></span>, <span class="hljs-number"><span class="hljs-number">55.6341</span></span>, <span class="hljs-number"><span class="hljs-number">37.5732</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//[bbox:{{bbox}}];</span></span></code> </pre> <br><p>  Depois disso, nosso script precisa clicar no botão <strong>Iniciar</strong> , esperar um pouco, tirar uma captura de tela do mapa e enviá-la ao usuário.  E tudo: a tarefa está concluída! </p><br><p>  Se você quiser ver um exemplo do script resultante, poderá clicar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">neste link</a> . </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>  Bem, como não é difícil supor, esta versão do script funcionará ainda mais lentamente que as anteriores.  Afinal, agora o site gasta tempo com uma solicitação de um banco de dados de terceiros.  E, por si só, não funciona muito rápido.  No entanto, esse método torna extremamente fácil (embora lento) obter um cartão exclusivo e personalizado.  Além disso, com base nos dados mais recentes.  E isso, às vezes, pode ser muito útil.  Portanto, vale a pena ter esse método em mente. </p><br><p>  E isso é tudo.  Só para lembrar, no meu site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">AnyGIS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">há um</a> arquivo de predefinições prontas para os navegadores Locus, OsmAnd e GuruMaps.  Existem mapas rasterizados e mapas vetoriais "rasterizados", para visualização em que o aplicativo descrito nestes artigos é usado.  Venha e use. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461073/">https://habr.com/ru/post/pt461073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461061/index.html">Ligas de magnésio, limites duplos e segregação</a></li>
<li><a href="../pt461063/index.html">Interação de R com bancos de dados no exemplo do Microsoft SQL Server e outros DBMS</a></li>
<li><a href="../pt461067/index.html">As 65 principais perguntas sobre SQL das entrevistas de emprego para as quais você deve estar preparado em 2019. Parte I</a></li>
<li><a href="../pt461069/index.html">Câmeras IP externas Nobelic: testes, tecnologias e recursos dos sistemas de vigilância por vídeo Ivideon</a></li>
<li><a href="../pt461071/index.html">Otimização de consultas ao banco de dados no exemplo de serviço B2B para construtores</a></li>
<li><a href="../pt461075/index.html">Inteligência de negócios. Objetos de TI, componentes, ferramentas</a></li>
<li><a href="../pt461077/index.html">Como são cozidos os pentesters? Teste de entrada para estagiários de segurança digital</a></li>
<li><a href="../pt461079/index.html">Cidade sem engarrafamentos</a></li>
<li><a href="../pt461081/index.html">O dia em que Dodo parou. Script assíncrono</a></li>
<li><a href="../pt461083/index.html">Software de gravação com a funcionalidade dos utilitários cliente-servidor Windows, parte 02</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>