<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèæ üë©‚Äç‚ù§Ô∏è‚Äçüë© üõ¢Ô∏è Introducci√≥n al aprendizaje autom√°tico üçô ‚õ≥Ô∏è üåí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El curso completo en ruso se puede encontrar en este enlace . 
 El curso de ingl√©s original est√° disponible en este enlace . 



 Nuevas conferencias ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n al aprendizaje autom√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  El curso completo en ruso se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este enlace</a> . <br>  El curso de ingl√©s original est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este enlace</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Nuevas conferencias est√°n programadas cada 2-3 d√≠as.</i> <br><br><h2>  Entrevista con Sebastian Trun, CEO de Udacity </h2><br>  "Hola de nuevo, soy Paige y t√∫ eres mi invitado hoy, Sebasti√°n". <br>  - Hola, soy Sebastian! <br>  - ... un hombre que tiene una carrera incre√≠ble, ¬°que logr√≥ hacer muchas cosas incre√≠bles!  Usted es cofundador de Udacity, fund√≥ Google X, es profesor en Stanford.  Has estado haciendo una investigaci√≥n incre√≠ble y un aprendizaje profundo a lo largo de tu carrera.  ¬øQu√© le trajo la mayor satisfacci√≥n y en cu√°les de las √°reas recibi√≥ m√°s recompensas por el trabajo realizado? <br>  - Francamente, ¬°me encanta estar en Silicon Valley!  Me gusta estar al lado de personas que son mucho m√°s inteligentes que yo, y siempre he considerado la tecnolog√≠a como una herramienta que cambia las reglas del juego de varias maneras, desde educaci√≥n hasta log√≠stica, atenci√≥n m√©dica, etc.  Todo esto cambia muy r√°pido, y existe un deseo incre√≠ble de participar en estos cambios, de observarlos.  Miras a tu alrededor y entiendes que la mayor√≠a de lo que ves a tu alrededor no funciona como deber√≠a, ¬°siempre puedes inventar algo nuevo! <br>  - Bueno, esta es una visi√≥n muy optimista de la tecnolog√≠a.  ¬øCu√°l fue el mayor eureka a lo largo de tu carrera? <br>  - ¬°Se√±or, hab√≠a tantos!  Recuerdo uno de los d√≠as en que Larry Page me llam√≥ y me sugiri√≥ crear autos piloto autom√°tico que pudieran conducir por todas las calles de California.  En ese momento me consideraban un experto, me clasificaban entre ellos y era la misma persona que dec√≠a "no, esto no se puede hacer".  Despu√©s de eso, Larry me convenci√≥ de que, en principio, es posible hacer esto, solo tienes que comenzar y probar.  Y lo hicimos!  Este fue el momento en que me di cuenta de que incluso los expertos est√°n equivocados y diciendo "no" somos 100% pesimistas.  Creo que deber√≠amos estar m√°s abiertos a lo nuevo. <br>  "O, por ejemplo, si Larry Page te llama y te dice:" Oye, haz algo genial como Google X ", ¬°y obtienes algo genial! <br>  - S√≠, eso es seguro, no hay necesidad de quejarse!  Quiero decir, todo esto es un proceso que pasa por muchas discusiones sobre el camino a la implementaci√≥n.  Tengo mucha suerte de trabajar y estoy orgulloso de ello, en Google X y en otros proyectos. <br>  - Impresionante!  Entonces, este curso se trata de trabajar con TensorFlow.  ¬øTiene experiencia en el uso de TensorFlow o tal vez est√° familiarizado (escuchado) con √©l? <br>  - si!  ¬°Literalmente amo TensorFlow, por supuesto!  En mi propio laboratorio, lo usamos a menudo y mucho, uno de los trabajos m√°s importantes basado en TensorFlow se lanz√≥ hace unos dos a√±os.  Aprendimos que iPhone y Android pueden ser m√°s efectivos para detectar el c√°ncer de piel que los mejores dermat√≥logos del mundo.  Publicamos nuestra investigaci√≥n en Nature y esto cre√≥ una especie de conmoci√≥n en la medicina. <br>  - Eso suena incre√≠ble!  ¬°As√≠ que conoces y amas TensorFlow, que es genial en s√≠ mismo!  ¬øYa has trabajado con TensorFlow 2.0? <br>  - No, lamentablemente a√∫n no he tenido tiempo. <br>  - ¬°Ser√° simplemente incre√≠ble!  Todos los estudiantes en este curso trabajar√°n con esta versi√≥n. <br>  - Los envidio!  ¬°Definitivamente lo intentar√©! <br>  - Genial!  En nuestro curso hay muchos estudiantes que en su vida nunca se han dedicado al aprendizaje autom√°tico, por la palabra "completamente".  Para ellos, el campo puede ser nuevo, quiz√°s para alguien que la programaci√≥n en s√≠ sea nueva.  ¬øQu√© consejo tienes para ellos? <br>  - Me gustar√≠a que permanecieran abiertos - a nuevas ideas, t√©cnicas, soluciones, posiciones.  El aprendizaje autom√°tico es en realidad m√°s f√°cil que la programaci√≥n.  En el proceso de programaci√≥n, debe tener en cuenta cada caso en los datos de origen, adaptar la l√≥gica del programa y las reglas para ello.  En este mismo momento, usando TensorFlow y el aprendizaje autom√°tico, esencialmente entrena a la computadora usando ejemplos, permitiendo que la computadora encuentre las reglas por s√≠ misma. <br>  - ¬°Esto es incre√≠blemente interesante!  ¬°No puedo esperar para contarles a los estudiantes en este curso un poco m√°s sobre el aprendizaje autom√°tico!  Sebastian, ¬°gracias por tomarte el tiempo de venir hoy! <br>  - gracias!  Mantente en contacto! <br><br><h2>  ¬øQu√© es el aprendizaje autom√°tico? </h2><br>  Entonces, comencemos con la siguiente tarea: valores de entrada y salida dados. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Cuando tiene el valor 0 como valor de entrada, luego 32 como valor de salida Cuando tiene 8 como valor de entrada, luego 46.4 como valor de salida.  Cuando tiene 15 como valor de entrada, luego 59 como valor de salida, y as√≠ sucesivamente. <br><br>  Eche un vistazo m√°s de cerca a estos valores y perm√≠tame hacerle una pregunta.  ¬øPuedes determinar cu√°l ser√° la salida si obtenemos 38 en la entrada? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Si respondiste 100.4, ¬°ten√≠as raz√≥n! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Entonces, ¬øc√≥mo podr√≠amos resolver este problema?  Si observa de cerca los valores, puede ver que est√°n relacionados por la expresi√≥n: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Donde C - grados Celsius (valores de entrada), F - Fahrenheit (valores de salida). <br><br>  Lo que acaba de hacer su cerebro: compar√≥ valores de entrada y valores de salida y encontr√≥ un modelo com√∫n (conexi√≥n, dependencia) entre ellos: esto es lo que hace el aprendizaje autom√°tico. <br><br>  Seg√∫n los valores de entrada y salida, los algoritmos de aprendizaje autom√°tico encontrar√°n un algoritmo adecuado para convertir los valores de entrada en valores de salida.  Esto se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Veamos un ejemplo.  Imagine que queremos desarrollar un programa que convierta grados Celsius a grados Fahrenheit usando la f√≥rmula <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  La soluci√≥n, cuando se aborda desde el punto de vista del desarrollo de software tradicional, se puede implementar en cualquier lenguaje de programaci√≥n utilizando la funci√≥n: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Entonces, ¬øqu√© tenemos?  La funci√≥n toma un valor de entrada de C, luego calcula el valor de salida de F usando un algoritmo expl√≠cito y luego devuelve el valor calculado. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Por otro lado, en el enfoque de aprendizaje autom√°tico, solo tenemos valores de entrada y salida, pero no el algoritmo en s√≠: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  El enfoque de aprendizaje autom√°tico se basa en el uso de redes neuronales para encontrar la relaci√≥n entre los valores de entrada y salida. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Puede pensar en las redes neuronales como una pila de capas, cada una de las cuales consiste en matem√°ticas (f√≥rmulas) previamente conocidas y variables internas.  El valor de entrada ingresa a la red neuronal y pasa a trav√©s de una pila de capas de neuronas.  Al pasar por las capas, el valor de entrada se convierte de acuerdo con las matem√°ticas (f√≥rmulas dadas) y los valores de las variables internas de las capas, produciendo un valor de salida. <br><br>  Para que la red neuronal pueda aprender y determinar la relaci√≥n correcta entre los valores de entrada y salida, necesitamos entrenarla, entrenar. <br><br>  Entrenamos la red neuronal a trav√©s de intentos repetidos de unir los valores de entrada con los de salida. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  En el proceso de entrenamiento, el ‚Äúajuste‚Äù (selecci√≥n) de los valores de las variables internas en las capas de la red neuronal ocurre hasta que la red aprende a generar los valores de salida correspondientes a los valores de entrada correspondientes. <br><br>  Como veremos m√°s adelante, para entrenar una red neuronal y permitirle seleccionar los valores m√°s adecuados de variables internas, se realizan miles o decenas de miles de iteraciones (entrenamientos). <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Como una versi√≥n simplificada de la comprensi√≥n del aprendizaje autom√°tico, puede imaginar los algoritmos de aprendizaje autom√°tico como funciones que seleccionan los valores de las variables internas para que los valores de entrada correctos correspondan a los valores de salida correctos. <br><br>  Existen muchos tipos de arquitecturas de redes neuronales.  Sin embargo, no importa qu√© arquitectura elija, las matem√°ticas internas (qu√© c√°lculos se realizan y en qu√© orden) permanecer√°n sin cambios durante el entrenamiento.  En lugar de cambiar las matem√°ticas, las variables internas (pesos y compensaciones) cambian durante el entrenamiento. <br><br>  Por ejemplo, en la tarea de convertir de grados Celsius a Fahrenheit, el modelo comienza multiplicando el valor de entrada por un cierto n√∫mero (peso) y agregando otro valor (desplazamiento).  El entrenamiento modelo consiste en encontrar valores adecuados para estas variables, sin cambiar las operaciones realizadas de multiplicaci√≥n y suma. <br><br>  ¬°Pero una cosa genial para pensar!  Si resolvi√≥ el problema de convertir grados Celsius a Fahrenheit, que se indica en el video y en el texto a continuaci√≥n, probablemente lo resolvi√≥ porque ten√≠a alguna experiencia o conocimiento previo sobre c√≥mo realizar este tipo de conversi√≥n de grados Celsius a Fahrenheit.  Por ejemplo, es posible que sepa que 0 grados Celsius corresponden a 32 grados Fahrenheit.  Por otro lado, los sistemas basados ‚Äã‚Äãen el aprendizaje autom√°tico no tienen conocimientos previos de respaldo para resolver el problema.  Aprenden a resolver estos problemas no bas√°ndose en conocimientos previos y en su ausencia total. <br><br>  Suficiente charla: ¬°pase a la parte pr√°ctica de la conferencia! <br><br><h2>  CoLab: convierta grados Celsius a grados Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La versi√≥n rusa del c√≥digo fuente de CoLab</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n en ingl√©s del c√≥digo fuente de CoLab</a> . <br><br><h2>  Lo b√°sico: aprender el primer modelo </h2><br>  ¬°Bienvenido a CoLab, donde formaremos nuestro primer modelo de aprendizaje autom√°tico! <br><br>  Intentaremos mantener la simplicidad del material presentado e introducir solo los conceptos b√°sicos necesarios para el trabajo.  CoLabs posteriores contendr√°n t√©cnicas m√°s avanzadas. <br><br>  La tarea que resolveremos es la conversi√≥n de grados Celsius a grados Fahrenheit.  La f√≥rmula de conversi√≥n es la siguiente: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><mi>e</mi><mi>s</mi><mn>1.8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="19.493ex" height="2.419ex" viewBox="0 -780.1 8393 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-76" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-65" x="3053" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-63" x="3520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-65" x="3953" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMATHI-73" x="4420" y="0"></use><g transform="translate(4889,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-38" x="779" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-2B" x="6391" y="0"></use><g transform="translate(7392,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjom-3GG9JA_Gqzxa9-idXwCUg23Q#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><mi>e</mi><mi>s</mi><mn>1.8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ veces 1.8 + 32 </script></p><br><br>  Por supuesto, ser√≠a m√°s f√°cil escribir una funci√≥n de conversi√≥n en Python o cualquier otro lenguaje de programaci√≥n que realizar√≠a c√°lculos directos, pero en este caso no ser√≠a aprendizaje autom√°tico :) <br><br>  En cambio, introducimos en la entrada de TensorFlow nuestros grados de entrada disponibles en grados Celsius (0, 8, 15, 22, 38) y sus grados Fahrenheit correspondientes (32, 46, 59, 72, 100).  Luego entrenaremos el modelo de tal manera que corresponda aproximadamente a la f√≥rmula anterior. <br><br><h3>  Dependencias de importaci√≥n </h3><br>  Lo primero que importamos es <code>TensorFlow</code> .  Aqu√≠ y en lo siguiente lo llamamos abreviadamente <code>tf</code> .  Tambi√©n configuramos el nivel de registro, solo errores. <br><br>  A continuaci√≥n, importe <code>NumPy</code> como <code>np</code> .  <code>Numpy</code> nos ayuda a presentar nuestros datos como listados de alto rendimiento. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Preparaci√≥n de datos de entrenamiento </h3><br>  Como vimos anteriormente, la t√©cnica de aprendizaje autom√°tico con el profesor se basa en la b√∫squeda de un algoritmo para convertir los datos de entrada en salida.  Dado que la tarea de este CoLab es crear un modelo que pueda producir el resultado de convertir grados Celsius a grados Fahrenheit, crearemos dos listas: <code>celsius_q</code> y <code>fahrenheit_a</code> , que usaremos al entrenar nuestro modelo. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Algunos t√©rminos de aprendizaje autom√°tico: <br><br><ul><li>  <b>La propiedad</b> es el valor o valores de entrada de nuestro modelo.  En este caso, el valor unitario es grados Celsius. </li><li>  <b>Las etiquetas</b> son los valores de salida que predice nuestro modelo.  En este caso, el valor unitario es grados Fahrenheit. </li><li>  <b>Un ejemplo</b> es un par de valores de entrada-salida utilizados para el entrenamiento.  En este caso, este es un par de valores de <code>celsius_q</code> y <code>fahrenheit_a</code> bajo un cierto √≠ndice, por ejemplo, (22,72). </li></ul><br><h2>  Crear un modelo </h2><br>  Luego creamos un modelo.  Utilizaremos el modelo m√°s simplificado: el modelo de una red totalmente conectada (red <code>Dense</code> ).  Dado que la tarea es bastante trivial, la red tambi√©n consistir√° en una sola capa con una sola neurona. <br><br><h4>  Construyendo una red </h4><br>  <code>tf.keras.layers.Dense</code> la capa <code>l0</code> ( <b>l</b> ayer y cero) y la crearemos inicializando <code>tf.keras.layers.Dense</code> con los siguientes par√°metros: <br><br><ul><li>  <code>input_shape=[1]</code> : este par√°metro determina la dimensi√≥n del par√°metro de entrada: un valor √∫nico.  Matriz 1 √ó 1 con un solo valor.  Dado que esta es la primera (y √∫nica) capa, la dimensi√≥n de los datos de entrada corresponde a la dimensi√≥n de todo el modelo.  El √∫nico valor es un valor de coma flotante que representa grados Celsius. </li><li>  <code>units=1</code> : este par√°metro determina el n√∫mero de neuronas en la capa.  El n√∫mero de neuronas determina cu√°ntas variables de capa interna se utilizar√°n para entrenar en la b√∫squeda de una soluci√≥n al problema.  Como esta es la √∫ltima capa, su dimensi√≥n es igual a la dimensi√≥n del resultado, el valor de salida del modelo, un √∫nico n√∫mero de punto flotante que representa grados Fahrenheit.  (En una red multicapa, el tama√±o y la forma de la capa <code>input_shape</code> deben coincidir con el tama√±o y la forma de la siguiente capa). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Convertir capas a modelo </h4><br>  Una vez que se definen las capas, deben convertirse en un modelo.  <code>Sequential</code> modelo <code>Sequential</code> toma como argumentos la lista de capas en el orden en que deben aplicarse, desde el valor de entrada hasta el valor de salida. <br><br>  Nuestro modelo tiene una sola capa: <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Nota</b> <br>  Muy a menudo, encontrar√° la definici√≥n de capas directamente en la funci√≥n del modelo, en lugar de su descripci√≥n preliminar y uso posterior: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Compilamos un modelo con una funci√≥n de p√©rdida y optimizaci√≥n. </h3><br>  Antes de entrenar, el modelo debe ser compilado (ensamblado).  Al compilar para la capacitaci√≥n, necesita: <br><br><ul><li>  <b>funci√≥n de p√©rdida</b> : una forma de medir qu√© tan lejos est√° el valor predicho del valor de salida deseado (una diferencia medible se llama "p√©rdida"). </li><li>  <b>Funci√≥n de optimizaci√≥n</b> : una forma de ajustar las variables internas para reducir las p√©rdidas. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  La funci√≥n de p√©rdida y la funci√≥n de optimizaci√≥n se utilizan durante el entrenamiento del modelo ( <code>model.fit(...)</code> mencionado a continuaci√≥n) para realizar c√°lculos iniciales en cada punto y luego optimizar los valores. <br><br>  La acci√≥n de calcular las p√©rdidas actuales y la mejora posterior de estos valores en el modelo es exactamente lo que es el entrenamiento (una iteraci√≥n). <br><br>  Durante el entrenamiento, la funci√≥n de optimizaci√≥n se utiliza para calcular los ajustes a los valores de las variables internas.  El objetivo es ajustar los valores de las variables internas de tal manera en el modelo (y esto, de hecho, es una funci√≥n matem√°tica) para que reflejen lo m√°s fielmente posible la expresi√≥n existente para convertir grados Celsius a grados Fahrenheit. <br><br>  TensorFlow utiliza an√°lisis num√©rico para realizar este tipo de operaciones de optimizaci√≥n, y toda esta complejidad est√° oculta a nuestros ojos, por lo que no entraremos en detalles en este curso. <br><br>  Lo que es √∫til saber sobre estas opciones: <br><br>  La funci√≥n de p√©rdida (error est√°ndar) y la funci√≥n de optimizaci√≥n (Adam) utilizadas en este ejemplo son est√°ndar para estos modelos simples, pero hay muchos otros disponibles adem√°s de ellos.  En esta etapa, no nos importa c√≥mo funcionan estas funciones. <br><br>  Lo que debe prestar atenci√≥n es la funci√≥n de optimizaci√≥n y el par√°metro es el coeficiente de <code>learning rate</code> , que en nuestro ejemplo es <code>0.1</code> .  Este es el tama√±o de paso utilizado al ajustar los valores internos de las variables.  Si el valor es demasiado peque√±o, se necesitar√°n demasiadas iteraciones de entrenamiento para entrenar el modelo.  Demasiado: la precisi√≥n cae.  Encontrar un buen valor para el coeficiente de tasa de aprendizaje requiere un poco de prueba y error; generalmente se encuentra en el rango de <code>0.01</code> (por defecto) a <code>0.1</code> . <br><br><h4>  Nosotros entrenamos el modelo </h4><br>  El entrenamiento del modelo se lleva a cabo por m√©todo de <code>fit</code> . <br><br>  Durante el entrenamiento, el modelo recibe grados Celsius en la entrada, realiza transformaciones utilizando los valores de las variables internas (llamadas "pesos") y devuelve valores que deben corresponder a grados Fahrenheit.  Como los valores iniciales de los pesos se establecen arbitrariamente, los valores resultantes estar√°n lejos de los valores correctos.  La diferencia entre el resultado deseado y el real se calcula utilizando la funci√≥n de p√©rdida, y la funci√≥n de optimizaci√≥n determina c√≥mo se deben ajustar los pesos. <br><br>  Este ciclo de c√°lculos, comparaciones y ajustes se controla dentro del m√©todo de <code>fit</code> .  El primer argumento es el valor de entrada, el segundo argumento es el valor de salida deseado.  El argumento de las <code>epochs</code> determina cu√°ntas veces se debe completar este ciclo de entrenamiento.  El argumento <code>verbose</code> controla el nivel de registro. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  En los siguientes videos, profundizaremos en los detalles de c√≥mo funciona todo esto y c√≥mo exactamente las capas completamente conectadas (capas <code>Dense</code> ) "debajo del cap√≥". <br><br><h4>  Mostrar estad√≠sticas de entrenamiento </h4><br>  El m√©todo de <code>fit</code> devuelve un objeto que contiene informaci√≥n sobre los cambios en las p√©rdidas con cada iteraci√≥n posterior.  Podemos usar este objeto para construir un programa de p√©rdidas apropiado.  La p√©rdida alta significa que los grados Fahrenheit predichos por el modelo est√°n lejos de los valores verdaderos en la matriz <code>fahrenheit_a</code> . <br><br>  Para la visualizaci√≥n, usaremos <code>Matplotlib</code> .  Como puede ver, nuestro modelo mejora muy r√°pidamente al principio, y luego llega a una mejora estable y lenta hasta que los resultados se vuelven "casi" perfectos al final del entrenamiento. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Usamos el modelo para las predicciones. </h4><br>  Ahora tenemos un modelo que ha sido entrenado en los valores de entrada <code>celsius_q</code> y valores de salida <code>fahrenheit_a</code> para determinar la relaci√≥n entre ellos.  Podemos usar el m√©todo de predicci√≥n para calcular los grados Fahrenheit por los cuales previamente no conoc√≠amos los grados Celsius correspondientes. <br><br>  Por ejemplo, ¬øcu√°nto es 100.0 grados Celsius Fahrenheit?  Intenta adivinar antes de ejecutar el siguiente c√≥digo. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Conclusi√≥n <br><br> <code>[[211.29639]] <br></code> <br><br>  La respuesta correcta es 100 √ó 1.8 + 32 = 212, ¬°as√≠ que nuestro modelo funcion√≥ bastante bien! <br><br>  <b>Revisar</b> <br><br><ul><li>  Creamos un modelo usando la capa <code>Dense</code> . </li><li>  La entrenamos con 3.500 ejemplos (7 pares de valores, 500 iteraciones de entrenamiento) </li></ul><br>  Nuestro modelo ajust√≥ los valores de las variables internas (pesos) en la capa <code>Dense</code> de tal manera que devolviera los valores correctos de grados Fahrenheit a un valor de entrada arbitrario de grados Celsius. <br><br><h3>  Nos fijamos en los pesos </h3><br>  Vamos a mostrar los valores de las variables internas de la capa <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  El valor de la primera variable est√° cerca de ~ 1.8, y el segundo de ~ 32.  Estos valores (1.8 y 32) son valores directos en la f√≥rmula para convertir grados Celsius a grados Fahrenheit. <br><br>  ¬°Esto est√° realmente muy cerca de los valores reales en la f√≥rmula!  Consideraremos este punto con m√°s detalle en los videos posteriores, donde mostraremos c√≥mo funciona la capa <code>Dense</code> , pero por ahora solo necesita saber que una neurona con una sola entrada y salida contiene matem√°ticas simples: <code>y = mx + b</code> (como una ecuaci√≥n directo), que no es m√°s que nuestra f√≥rmula para convertir grados Celsius a grados Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Dado que las representaciones son las mismas, los valores de las variables internas del modelo deben converger a los presentados en la f√≥rmula real, que sucedi√≥ al final. <br><br>  Con la presencia de neuronas adicionales, valores de entrada y valores de salida adicionales, la f√≥rmula se vuelve un poco m√°s complicada, pero la esencia sigue siendo la misma. <br><br><h4>  Un poco de experimentaci√≥n </h4><br>  Por diversi√≥n!  ¬øQu√© sucede si creamos m√°s capas <code>Dense</code> con m√°s neuronas, que a su vez contendr√°n m√°s variables internas? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Como habr√°s notado, el modelo actual tambi√©n es capaz de predecir bastante bien los grados correspondientes de Fahrenheit.  Sin embargo, si observamos los valores de las variables internas (pesos) de las neuronas por capas, entonces no veremos ning√∫n valor similar a 1.8 y 32.  La complejidad adicional del modelo oculta la forma "simple" de convertir grados Celsius a grados Fahrenheit. <br><br>  Mant√©ngase conectado y en la siguiente parte veremos c√≥mo funcionan las capas densas "debajo del cap√≥". <br><br><h3>  Resumen breve </h3><br>  Felicidades  Acabas de entrenar a tu primer modelo.  En la pr√°ctica, vimos c√≥mo, mediante los valores de entrada y salida, el modelo aprendi√≥ a multiplicar el valor de entrada por 1.8 y agregarle 32 para obtener el resultado correcto. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Esto fue realmente impresionante, considerando cu√°ntas l√≠neas de c√≥digo necesit√°bamos escribir: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  El ejemplo anterior es un plan general para todos los programas de aprendizaje autom√°tico.  Utilizar√° construcciones similares para crear y entrenar redes neuronales y para resolver problemas posteriores. <br><br><h3>  Proceso de entrenamiento </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de capacitaci√≥n (que tiene lugar en el m√©todo </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) consiste en una secuencia muy simple de acciones, cuyo resultado deben ser los valores de las variables internas que dan los resultados lo m√°s cerca posible del original. </font><font style="vertical-align: inherit;">El proceso de optimizaci√≥n mediante el cual se logran tales resultados, llamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descenso de gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , utiliza el an√°lisis num√©rico para encontrar los valores m√°s adecuados para las variables internas del modelo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para participar en el aprendizaje autom√°tico, usted, en principio, no necesita comprender estos detalles. Pero para aquellos que todav√≠a est√°n interesados ‚Äã‚Äãen aprender m√°s: el descenso de gradiente a trav√©s de iteraciones cambia un poco los valores de los par√°metros, "jal√°ndolos" en la direcci√≥n correcta, hasta obtener los mejores resultados. En este caso, "mejores resultados" (mejores valores) significan que cualquier cambio posterior en el par√°metro solo empeorar√° el resultado del modelo. Una funci√≥n que mide qu√© tan bueno o malo es el modelo en cada iteraci√≥n se denomina "funci√≥n de p√©rdida", y el objetivo de cada "atracci√≥n" (ajuste de valores internos) es reducir el valor de la funci√≥n de p√©rdida.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de entrenamiento comienza con el bloque de "distribuci√≥n directa", en el que los par√°metros de entrada van a la entrada de la red neuronal, siguen las neuronas ocultas y luego van al fin de semana. Luego, el modelo aplica transformaciones internas en los valores de entrada y variables internas para predecir la respuesta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro ejemplo, el valor de entrada es la temperatura en grados Celsius y el modelo predijo el valor correspondiente en grados Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como se predice el valor, se calcula la diferencia entre el valor predicho y el correcto. La diferencia se llama "p√©rdida" y es una forma de medici√≥n de qu√© tan bien funcion√≥ el modelo. El valor de p√©rdida se calcula mediante la funci√≥n de p√©rdida, que determinamos mediante uno de los argumentos al llamar al m√©todo </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de calcular el valor de p√©rdida, las variables internas (pesos y desplazamientos) de todas las capas de la red neuronal se ajustan para minimizar el valor de p√©rdida con el fin de aproximar el valor de salida al valor de referencia inicial correcto. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este proceso de optimizaci√≥n se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descenso de gradiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se utiliza un algoritmo de optimizaci√≥n espec√≠fico para calcular un nuevo valor para cada variable interna cuando se llama al m√©todo </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En el ejemplo anterior, utilizamos un algoritmo de optimizaci√≥n </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No es necesario comprender los principios del proceso de capacitaci√≥n para este curso, sin embargo, si tiene curiosidad, puede encontrar m√°s informaci√≥n sobre el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso acelerado de Google</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(La traducci√≥n y la parte pr√°ctica de todo el curso se establecen en los planes de publicaci√≥n del autor). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, ya deber√≠a estar familiarizado con los siguientes t√©rminos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propiedad</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valor de entrada de nuestro modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pares de entrada + salida;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiquetas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : valores de salida del modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una colecci√≥n de nodos unidos dentro de una red neuronal;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : representaci√≥n de su red neuronal;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denso y totalmente conectado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cada nodo en una capa est√° conectado a cada nodo de la capa anterior.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos y compensaciones</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : variables internas del modelo;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P√©rdida</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la diferencia entre el valor de salida deseado y el valor de salida real del modelo;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  ¬´¬ª       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propagaci√≥n inversa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : calcular los valores de las variables internas de acuerdo con un algoritmo de optimizaci√≥n que comienza desde la capa de salida y hacia la capa de entrada a trav√©s de todas las capas intermedias.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Capas sensoriales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, creamos un modelo que convierte grados Celsius a grados Fahrenheit, utilizando una red neuronal simple para encontrar la relaci√≥n entre grados Celsius y grados Fahrenheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestra red consta de una sola capa totalmente conectada. </font><font style="vertical-align: inherit;">Pero, ¬øqu√© es una capa totalmente conectada? </font><font style="vertical-align: inherit;">Para resolver esto, creemos una red neuronal m√°s compleja con 3 par√°metros de entrada, una capa oculta con dos neuronas y una capa de salida con una sola neurona.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuerde que una red neuronal se puede imaginar como un conjunto de capas, cada una de las cuales consiste en nodos llamados neuronas. Las neuronas en cada nivel se pueden conectar a las neuronas de cada capa posterior. El tipo de capas en las que cada neurona de una capa est√° conectada entre s√≠ a la neurona de la siguiente capa se denomina capa completamente conectada (completamente conectada) o densa (capa </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, cuando usamos capas completamente conectadas </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informamos que las neuronas de esta capa deben estar conectadas a todas las neuronas de la capa anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear la red neuronal anterior, las siguientes expresiones son suficientes para nosotros:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, descubrimos qu√© son las neuronas y c√≥mo est√°n relacionadas. Pero, ¬øc√≥mo funcionan realmente las capas completamente conectadas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comprender lo que realmente est√° sucediendo all√≠ y lo que est√°n haciendo, debemos mirar "bajo el cap√≥" y desarmar las matem√°ticas internas de las neuronas. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que nuestro modelo recibe tres par√°metros </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- las neuronas de nuestra red. ¬øRecuerdas que dijimos que una neurona tiene variables internas? Por lo tanto, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son la neurona variables m√°s interna, tambi√©n conocido como el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peso</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el desplazamiento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Son los valores de estas variables los que se ajustan en el proceso de aprendizaje para obtener los resultados m√°s precisos de comparar los valores de entrada con la salida. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que definitivamente debes tener en cuenta es que las </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matem√°ticas internas de la neurona se mantienen sin cambios</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En otras palabras, durante el proceso de entrenamiento, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambian los </font><font style="vertical-align: inherit;">pesos y los desplazamientos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando comienzas a aprender el aprendizaje autom√°tico, puede parecer extra√±o: el hecho de que realmente funciona, ¬°pero as√≠ es como funciona el aprendizaje autom√°tico! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos a nuestro ejemplo de convertir grados Celsius a grados Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con una sola neurona, tenemos solo un peso y un desplazamiento. ¬øSabes que? Esto es exactamente lo que parece la f√≥rmula para convertir grados Celsius a grados Fahrenheit. Si sustituimos el </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y en lugar de </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ¬°obtenemos el modelo de transformaci√≥n final! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si volvemos a los resultados de nuestro modelo desde la parte pr√°ctica, prestaremos atenci√≥n al hecho de que los indicadores de peso y desplazamiento fueron "calibrados" de tal manera que corresponden aproximadamente a los valores de la f√≥rmula.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos a prop√≥sito un ejemplo pr√°ctico para mostrar claramente la comparaci√≥n exacta entre pesos y compensaciones. Al poner en pr√°ctica el aprendizaje autom√°tico, nunca podemos comparar los valores de las variables con el algoritmo de destino de esta manera, como en el ejemplo anterior. ¬øC√≥mo podemos hacer esto? ¬°De ninguna manera, porque ni siquiera conocemos el algoritmo objetivo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al resolver los problemas del aprendizaje autom√°tico, probamos varias arquitecturas de redes neuronales con diferentes n√∫meros de neuronas en ellas: por ensayo y error encontramos las arquitecturas y modelos m√°s precisos y esperamos que resuelvan el problema en el proceso de aprendizaje. En la siguiente parte pr√°ctica, podremos estudiar ejemplos espec√≠ficos de este enfoque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mant√©ngase en contacto, porque ahora comienza la diversi√≥n!</font></font><br><br><h3>  Resumen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta lecci√≥n aprendimos enfoques b√°sicos en el aprendizaje autom√°tico y aprendimos c√≥mo funcionan las capas completamente conectadas (capas </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Entren√≥ a su primer modelo para convertir grados Celsius a grados Fahrenheit. </font><font style="vertical-align: inherit;">Tambi√©n aprendi√≥ los t√©rminos b√°sicos utilizados en el aprendizaje autom√°tico, como propiedades, ejemplos, etiquetas. </font><font style="vertical-align: inherit;">Usted, entre otras cosas, escribi√≥ las principales l√≠neas de c√≥digo en Python, que son la columna vertebral de cualquier algoritmo de aprendizaje autom√°tico. </font><font style="vertical-align: inherit;">Viste que en unas pocas l√≠neas de c√≥digo puedes crear, entrenar y solicitar una predicci√≥n de una red neuronal usando </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... y un llamado a la acci√≥n est√°ndar: reg√≠strese, ponga un plus y comparta :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi√≥n en video del art√≠culo.</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegram: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453558/">https://habr.com/ru/post/453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453542/index.html">El robot de cuatro patas pudo remolcar un avi√≥n que pesaba 3.3 toneladas</a></li>
<li><a href="../453544/index.html">Decodificador de siete segmentos que usa salidas directas e inversas de un contador BCD</a></li>
<li><a href="../453546/index.html">Necesita un teclado peque√±o: h√°galo usted mismo</a></li>
<li><a href="../453548/index.html">Revivimos el frenado Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../453554/index.html">C√≥mo ha cambiado Starlink de SpaceX</a></li>
<li><a href="../453562/index.html">Eventos digitales en Mosc√∫ del 27 de mayo al 2 de junio</a></li>
<li><a href="../453564/index.html">Make it True: desarrollo de un juego de l√≥gica en Unity</a></li>
<li><a href="../453566/index.html">Restaurar la leyenda: un llamado para el intercambio de datos abiertos que pueden ayudar en la restauraci√≥n de Notre Dame</a></li>
<li><a href="../453568/index.html">Reconstrucci√≥n de un icono: una llamada para compartir datos abiertos para ayudar a restaurar Notre-Dame</a></li>
<li><a href="../453570/index.html">Microsoft Edge para macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>