<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèª üëäüèª üëÜüèª Pourtant, C est un langage de bas niveau üë®üèæ‚Äçüåæ üëã üë®‚Äçüë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours de la derni√®re d√©cennie, depuis l'av√®nement du langage C, de nombreux langages de programmation int√©ressants ont √©t√© cr√©√©s. Certains d'entre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourtant, C est un langage de bas niveau</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/465429/"><p><img src="https://habrastorage.org/webt/0w/1l/ey/0w1leycdhljvvpoqezgzueoho8a.jpeg"></p><br><p>  Au cours de la derni√®re d√©cennie, depuis l'av√®nement du langage C, de nombreux langages de programmation int√©ressants ont √©t√© cr√©√©s.  Certains d'entre eux sont encore utilis√©s, d'autres ont influenc√© la prochaine g√©n√©ration de langues, la popularit√© du troisi√®me s'est ternie.  Pendant ce temps, archa√Øque, controvers√©, primitif, rendu dans les pires traditions de sa g√©n√©ration de langages C (et de ses h√©ritiers) plus vivant que tous les √™tres vivants. </p><br><p>  Criticism C est un genre √©pistolaire classique pour notre industrie.  Cela semble plus fort, puis plus silencieux, mais ces derniers temps, il a litt√©ralement √©t√© magnifique.  Un exemple est une traduction de l'article de David Ciswell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´C n'est pas un langage de bas niveau¬ª,</a> publi√© sur notre blog il y a quelque temps.  On peut dire diff√©rentes choses sur C, il y a vraiment beaucoup d'erreurs d√©sagr√©ables dans la conception du langage, mais refuser C au "bas niveau" c'est trop! </p><br><p>  Afin de ne pas tol√©rer une telle injustice, j'ai pris courage et essay√© de d√©cider ce qu'√©tait un langage de programmation de bas niveau et quelles pratiques ils en voulaient, apr√®s quoi je suis pass√© en revue les arguments des critiques C.C'est ainsi que cet article s'est av√©r√©. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arguments de critique C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Langage de programmation de bas niveau</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il ne s'agit pas seulement de PDP-11</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation des compilateurs et du langage de bas niveau</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Standard comme un bien absolu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Architectures alternatives - informatique sp√©ciale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C vivra</a> </li></ul><br><h1 id="argumenty-kritikov-c">  Arguments de critique C </h1><br><p>  Voici certains des arguments des critiques de C, y compris ceux √©num√©r√©s dans un article de David Chiznell: </p><br><ol><li>  La machine abstraite du langage C est trop similaire √† l'architecture obsol√®te du PDP-11, qui a depuis longtemps cess√© de correspondre au dispositif des processeurs modernes populaires. </li><li> L'inad√©quation entre une machine abstraite et le dispositif de machines r√©elles complique le d√©veloppement de l'optimisation des compilateurs de langage. </li><li>  L'incompl√©tude et la complexit√© de la norme de langage entra√Ænent des √©carts dans les impl√©mentations standard. </li><li>  La domination des langages de type C ne permet pas d'explorer d'autres architectures de processeur. </li></ol><br><p>  D√©terminons d'abord les exigences pour un langage de bas niveau, apr√®s quoi nous revenons aux arguments donn√©s. </p><br><h1 id="yazyk-programmirovaniya-nizkogo-urovnya">  Langage de programmation de bas niveau </h1><br><p>  Il n'y a pas de d√©finition universellement accept√©e d'une langue de bas niveau.  Mais avant de discuter de questions controvers√©es, il est souhaitable d'avoir au moins quelques exigences initiales pour l'objet du diff√©rend. </p><br><p>  Personne ne pr√©tendra que le langage d'assemblage est au niveau le plus bas.  Mais sur chaque plate-forme, il est unique, donc le code dans un tel langage ne peut pas √™tre portable.  M√™me sur une plate-forme r√©trocompatible, vous devrez peut-√™tre utiliser de nouvelles instructions. </p><br><p>  D'ici suit la premi√®re exigence pour un langage de bas niveau: il doit conserver <em>les fonctionnalit√©s communes aux plates-formes populaires</em> .  Autrement dit, le compilateur doit √™tre portable.  La portabilit√© du compilateur simplifie le d√©veloppement de compilateurs de langage pour les nouvelles plates-formes, et la vari√©t√© des plates-formes prises en charge par les compilateurs √©limine la n√©cessit√© pour les d√©veloppeurs de r√©√©crire les programmes d'application pour chaque nouvelle machine. </p><br><p>  La premi√®re exigence est en contradiction avec les souhaits des d√©veloppeurs de programmes sp√©ciaux: langages de programmation, pilotes, syst√®mes d'exploitation et bases de donn√©es hautes performances.  Les programmeurs qui √©crivent ces programmes souhaitent pouvoir optimiser manuellement, travailler directement avec la m√©moire, etc.  En un mot, un langage de bas niveau <em>devrait permettre de travailler avec les d√©tails de l'impl√©mentation de la plateforme</em> . </p><br><p>  Trouver un √©quilibre entre ces deux exigences - identifier les aspects communs aux plateformes et acc√©der √† autant de d√©tails que possible - est une raison fondamentale de la difficult√© de d√©velopper un langage de bas niveau. </p><br><p>  Notez que les abstractions de haut niveau ne sont pas si importantes pour un tel langage - il est plus important pour lui de servir de contrat entre la plateforme, le compilateur et le d√©veloppeur.  Et s'il y a un contrat, il faut alors un <em>langage ind√©pendant de la norme de mise en ≈ìuvre particuli√®re</em> . </p><br><p>  Notre premi√®re exigence - les fonctionnalit√©s communes aux plates-formes cibles - est exprim√©e dans une machine √† langage abstrait, nous allons donc commencer la discussion avec C. </p><br><h1 id="delo-ne-tolko-v-pdp-11">  Il ne s'agit pas seulement de PDP-11 </h1><br><p>  La plate-forme dans laquelle le langage C est apparu est PDP-11.  Il est bas√© sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture von Neumann</a> traditionnelle, dans laquelle les programmes sont ex√©cut√©s s√©quentiellement par le processeur central, et la m√©moire est une bande plate, o√π les donn√©es et les programmes sont stock√©s.  Une telle architecture est facilement impl√©ment√©e dans le mat√©riel et, au fil du temps, tous les ordinateurs √† usage g√©n√©ral ont commenc√© √† l'utiliser. </p><br><p>  Les am√©liorations modernes apport√©es √† l'architecture de von Neumann visent √† √©liminer son principal goulot d'√©tranglement - les retards dans l'√©change de donn√©es entre le processeur et la m√©moire (anglais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">von Neuman bottleneck</a> ).  La diff√©rence de m√©moire et de performances du processeur a conduit √† l'apparition de sous-syst√®mes de mise en cache des processeurs (√† un niveau et plus tard √† plusieurs niveaux). </p><br><p>  Mais m√™me les caches de nos jours ne suffisent pas.  Les processeurs modernes sont devenus superscalaires.  Les retards lorsque les instructions re√ßoivent des donn√©es de la m√©moire sont partiellement compens√©s par l'ex√©cution extraordinaire ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parall√©lisme au niveau</a> des instructions) des instructions, coupl√©e au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©dicteur de branchement</a> . </p><br><p>  La machine abstraite s√©quentielle C (et de nombreux autres langages) imite le travail non pas sp√©cifiquement de PDP-11, mais de tout ordinateur dispos√© selon le principe de l'architecture de von Neumann.  Il comprend des architectures construites autour de processeurs √† un seul c≈ìur: ordinateur de bureau et serveur x86, ARM mobile, issus de la sc√®ne de Sun / Oracle SPARC et IBM POWER. </p><br><p>  Au fil du temps, plusieurs c≈ìurs de traitement ont commenc√© √† √™tre int√©gr√©s dans un seul processeur, ce qui a rendu n√©cessaire de maintenir la coh√©rence des caches de chaque c≈ìur et a n√©cessit√© des protocoles d'interaction internucl√©aire.  L'architecture de Von Neumann a ainsi √©t√© adapt√©e √† plusieurs c≈ìurs. </p><br><p>  La version originale de la machine abstraite C √©tait s√©quentielle, ne refl√©tant pas la pr√©sence de threads d'ex√©cution de programme interagissant √† travers la m√©moire.  L'apparition du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de m√©moire</a> dans la norme a √©largi les capacit√©s de la machine abstraite en parall√®le. </p><br><p>  Ainsi, l'affirmation selon laquelle la machine C abstraite a longtemps √©t√© incompatible avec la structure des processeurs modernes ne concerne pas tant un langage sp√©cifique, mais des ordinateurs qui utilisent l'architecture von Neumann, y compris en ex√©cution parall√®le. </p><br><p>  Mais en tant que praticien, je tiens √† noter ce qui suit: nous pouvons supposer que l'approche Fonneimann est obsol√®te, nous pouvons supposer qu'elle est pertinente, mais cela n'annule pas le fait que les architectures polyvalentes populaires d'aujourd'hui utilisent des d√©riv√©s des approches traditionnelles. </p><br><p>  Le mode de r√©alisation standardis√© et portable de l'architecture von Neumann - la machine C abstraite - est commod√©ment impl√©ment√© sur toutes les principales plates-formes et jouit donc √† juste titre de sa popularit√© en tant qu'assembleur portable. </p><br><h1 id="optimiziruyuschie-kompilyatory-i-yazyk-nizkogo-urovnya">  Optimisation des compilateurs et du langage de bas niveau </h1><br><p>  Notre deuxi√®me exigence pour un langage de bas niveau est l'acc√®s aux d√©tails d'impl√©mentation de bas niveau de chacune des plateformes populaires.  Dans le cas de C, il s'agit d'un travail direct avec de la m√©moire et des objets en tant que tableau d'octets, la possibilit√© de travailler directement avec des adresses d'octets et une arithm√©tique de pointeur avanc√©e. </p><br><p>  Les critiques de C soulignent que la norme linguistique donne trop de garanties concernant, par exemple, l'emplacement des champs individuels dans les structures et les associations.  Avec des pointeurs et des m√©canismes primitifs de boucles, cela complique le travail de l'optimiseur. </p><br><p>  En effet, une approche plus d√©clarative permettrait au compilateur de r√©soudre ind√©pendamment les probl√®mes d'alignement des donn√©es en m√©moire ou l'ordre optimal des champs dans les structures;  et les cycles de niveau sup√©rieur offrent la libert√© dont vous avez besoin lors de la vectorisation. </p><br><p>  La position des d√©veloppeurs C dans ce cas est la suivante: un langage de bas niveau devrait lui permettre de fonctionner √† un niveau suffisamment bas pour que le programmeur puisse r√©soudre ind√©pendamment les probl√®mes d'optimisation.  En C, il est possible de travailler comme un compilateur, en choisissant, par exemple, des instructions SIMD et en pla√ßant correctement les donn√©es en m√©moire. </p><br><p>  En d'autres termes, notre exigence d'acc√®s aux d√©tails d'impl√©mentation de chaque plateforme entre en conflit avec les souhaits des d√©veloppeurs d'optimiser les compilateurs pr√©cis√©ment en raison de la pr√©sence d'outils de bas niveau. </p><br><p>  Fait int√©ressant, Chiznell dans un article intitul√© ¬´C n'est pas un langage de bas niveau¬ª affirme paradoxalement que C est <em>trop</em> bas, ce qui indique l'absence d'outils de haut niveau.  Mais les praticiens ont pr√©cis√©ment besoin d'outils de bas niveau, sinon le langage ne peut pas √™tre utilis√© pour d√©velopper des syst√®mes d'exploitation et d'autres programmes de bas niveau, c'est-√†-dire qu'il ne satisfera pas la seconde de nos exigences. </p><br><p>  En me distrayant de la description des probl√®mes d'optimisation √† savoir C, je tiens √† noter qu'√† l'heure actuelle, aucun effort n'est moins investi dans l'optimisation des compilateurs de langages de haut niveau (les m√™mes C # et Java) que dans GCC ou Clang.  Les langages fonctionnels ont √©galement suffisamment de compilateurs efficaces: MLTon, OCaml et autres.  Mais les d√©veloppeurs du m√™me OCaml peuvent encore se targuer de performances au mieux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† la moiti√© de la vitesse du code C</a> ... </p><br><h1 id="standart-kak-bezuslovnoe-blago">  Standard comme un bien absolu </h1><br><p>  Dans son article, Chiznell cite les r√©sultats d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enqu√™te</a> men√©e en 2015: de nombreux programmeurs ont fait des erreurs en r√©solvant les probl√®mes de compr√©hension des normes C. </p><br><p>  Je suppose que l'un des lecteurs avait affaire √† la norme C. J'ai une version papier de C99, 900 pages de publicit√©s. Ce n'est pas une sp√©cification laconique avec un volume de moins de 100 pages et pas un ML standard l√©ch√© de 300. Plaisir du travail personne n'obtient la norme C: ni d√©veloppeurs de compilateurs, ni d√©veloppeurs de documents, ni programmeurs. </p><br><p>  Mais il faut comprendre que la norme C a √©t√© d√©velopp√©e apr√®s coup, apr√®s l'apparition de nombreux dialectes compatibles ¬´presque √† peine plac√©s¬ª.  Les auteurs de l'ANSI C ont fait un excellent travail en r√©sumant les impl√©mentations existantes et en les couvrant avec d'innombrables ¬´b√©quilles¬ª de non orthogonalit√© dans la conception du langage. </p><br><p>  Il peut sembler √©trange que quelqu'un se soit engag√© √† mettre en ≈ìuvre un tel document.  Mais C a √©t√© impl√©ment√© par de nombreux compilateurs.  Je ne raconterai pas les contes des autres sur le zoo du monde UNIX de la fin des ann√©es 80, d'autant plus qu'√† cette √©poque je ne le consid√©rais pas avec beaucoup de confiance et seulement jusqu'√† cinq ans.  Mais, √©videmment, tout le monde dans l'industrie avait vraiment besoin d'une norme. </p><br><p>  La grande chose est qu'elle existe et est impl√©ment√©e par au moins trois grands compilateurs et de nombreux compilateurs plus petits, qui ensemble prennent en charge des centaines de plates-formes.  Aucune des langues concurrentes C, revendiquant la couronne du roi des langues de bas niveau, ne peut se targuer d'une telle diversit√© et polyvalence. </p><br><p>  En fait, la norme C actuelle n'est pas si mauvaise.  Un programmeur plus ou moins exp√©riment√© est capable de d√©velopper un compilateur C non optimisant dans un d√©lai raisonnable, ce qui est confirm√© par l'existence de nombreuses impl√©mentations semi-amateurs (les m√™mes TCC, LCC et 8cc). </p><br><p>  Avoir une norme g√©n√©ralement accept√©e signifie que C satisfait la derni√®re de nos exigences pour un langage de bas niveau: ce langage est construit sur une sp√©cification, pas une impl√©mentation sp√©cifique. </p><br><h1 id="alternativnye-arhitektury---udel-specialnyh-vychisleniy">  Architectures alternatives - informatique sp√©ciale </h1><br><p>  Mais Lifewell cite un autre argument, revenant au dispositif des processeurs polyvalents modernes qui impl√©mentent les options d'architecture von Neumann.  Il affirme qu'il est logique de changer les principes du processeur central.  Encore une fois, cette critique n'est pas sp√©cifique au C, mais au mod√®le le plus √©l√©mentaire de programmation imp√©rative. </p><br><p>  En effet, il existe de nombreuses alternatives √† l'approche traditionnelle avec ex√©cution s√©quentielle de programmes: mod√®les SIMD dans le style GPU, mod√®les dans le style d'une machine Erlang abstraite, et autres.  Mais chacune de ces approches a une applicabilit√© limit√©e lorsqu'elle est utilis√©e dans un processeur central. </p><br><p>  Les GPU, par exemple, multiplient remarquablement les matrices dans les jeux et l'apprentissage automatique, mais ils sont difficiles √† utiliser pour le lancer de rayons.  En d'autres termes, ce mod√®le convient aux acc√©l√©rateurs sp√©cialis√©s, mais ne fonctionne pas pour les processeurs √† usage g√©n√©ral. </p><br><p>  Erlang fonctionne tr√®s bien dans un cluster, mais il est difficile de faire un tri rapide efficace ou une table de hachage rapide.  Le mod√®le des acteurs ind√©pendants est mieux utilis√© √† un niveau sup√©rieur, dans un grand cluster, o√π chaque n≈ìud est toujours la m√™me machine haute performance avec un processeur traditionnel. </p><br><p>  Pendant ce temps, les processeurs modernes compatibles x86 ont longtemps inclus des ensembles d'instructions vectorielles similaires au GPU dans leur objectif et leurs principes de fonctionnement, mais pr√©servant le circuit g√©n√©ral du processeur dans le style von Neumann dans son ensemble.  Je ne doute pas que des approches assez g√©n√©rales de l'informatique seront incluses dans les processeurs populaires. </p><br><p>  Il existe une telle opinion faisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autorit√©</a> : l'avenir r√©side dans les acc√©l√©rateurs programmables sp√©cialis√©s.  Sous des morceaux de fer aussi extraordinaires, il est vraiment logique de d√©velopper des langages avec une s√©mantique particuli√®re.  Mais un ordinateur polyvalent √©tait et reste similaire au tr√®s PDP-11, pour lequel les langages imp√©ratifs de type C sont si bien adapt√©s. </p><br><h1 id="s-budet-zhit">  C vivra </h1><br><p>  Il y a une contradiction fondamentale dans l'article de Chiznell.  Il √©crit que pour assurer la vitesse des programmes C, les processeurs imitent la machine C abstraite (et le PDP-11 oubli√© depuis longtemps), apr√®s quoi il souligne les limites d'une telle machine.  Mais je ne comprends pas pourquoi cela signifie que "C n'est pas un langage de bas niveau". </p><br><p>  En g√©n√©ral, il ne s'agit pas des d√©fauts de C en tant que langage, mais de la critique des architectures communes de style von Neumann et du mod√®le de programmation qui en d√©coule.  Mais jusqu'√† pr√©sent, il ne semble pas que l'industrie soit pr√™te √† abandonner l'architecture famili√®re (du moins pas dans les processeurs √† usage g√©n√©ral). </p><br><p>  Malgr√© la disponibilit√© de nombreux processeurs sp√©cialis√©s tels que les GPU et les TPU, l'architecture von Neumann est actuellement sous contr√¥le et l'industrie a besoin d'un langage lui permettant de fonctionner au plus bas niveau possible dans le cadre de l'architecture la plus populaire.  Un assez simple, port√© sur des dizaines de plates-formes et un langage de programmation standardis√© est C (et sa famille imm√©diate). </p><br><p>  Pour autant, C a suffisamment de d√©fauts: une biblioth√®que archa√Øque de fonctions, un standard complexe et incoh√©rent, et des erreurs de conception grossi√®res.  Mais, apparemment, les cr√©ateurs de la langue ont quand m√™me fait quelque chose de bien. </p><br><p>  D'une mani√®re ou d'une autre, nous avons toujours besoin d'un langage de bas niveau, et il a √©t√© sp√©cialement con√ßu pour les ordinateurs Fonneimann populaires.  Et que C soit obsol√®te, mais apparemment, tout successeur devra toujours s'appuyer sur les m√™mes principes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465429/">https://habr.com/ru/post/fr465429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465417/index.html">Plugins de volume de stockage Kubernetes: Flexvolume vers CSI</a></li>
<li><a href="../fr465419/index.html">Demain √† l'Universit√© ITMO: le processus √©ducatif, les concours et l'√©ducation √† l'√©tranger - une s√©lection d'√©v√©nements √† venir</a></li>
<li><a href="../fr465423/index.html">Fabrication et industrie intelligentes 4.0: trois grandes tendances technologiques</a></li>
<li><a href="../fr465425/index.html">Vepp - le nouveau panneau de contr√¥le du serveur et du site Web d'ISPsystem</a></li>
<li><a href="../fr465427/index.html">Analyse du framework RPC Apache Dubbo par l'analyseur de code statique PVS-Studio</a></li>
<li><a href="../fr465431/index.html">Analyse du code source RPC du framework Apache Dubbo avec l'analyseur statique PVS-Studio</a></li>
<li><a href="../fr465433/index.html">Robots de travail - homme heureux</a></li>
<li><a href="../fr465435/index.html">Quelle distribution est pr√©f√©rable d'utiliser pour votre syst√®me embarqu√©?</a></li>
<li><a href="../fr465437/index.html">Pourquoi j'ai refus√© de travailler dans AWS</a></li>
<li><a href="../fr465441/index.html">LuaVela: impl√©mentation de Lua 5.1 bas√©e sur LuaJIT 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>