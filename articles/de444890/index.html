<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèø üí∂ ü§∂ Dutzende Tricks mit der Linux-Shell, die Ihre Zeit sparen k√∂nnten ‚úäüèº üç° üò∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Zun√§chst k√∂nnen Sie diesen Artikel hier auf Russisch lesen. 
 Eines Abends, als ich das Regieren von regul√§ren Ausdr√ºcken von Jeffrey Friedl las, wu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dutzende Tricks mit der Linux-Shell, die Ihre Zeit sparen k√∂nnten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>Zun√§chst k√∂nnen Sie diesen Artikel hier auf Russisch lesen.</i> </li></ul><br>  Eines Abends, als ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regieren von regul√§ren Ausdr√ºcken von Jeffrey Friedl</a> las, wurde mir klar, dass selbst wenn Sie √ºber alle Unterlagen und viel Erfahrung verf√ºgen, es viele Tricks geben kann, die von verschiedenen Menschen entwickelt und f√ºr sich selbst eingesperrt wurden.  Alle Menschen sind unterschiedlich.  Und Techniken, die f√ºr bestimmte Menschen offensichtlich sind, sind f√ºr andere m√∂glicherweise nicht offensichtlich und sehen f√ºr die dritte Person wie eine seltsame Magie aus.  √úbrigens habe ich hier bereits einige solcher Momente beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(auf Russisch)</a> . <br><br>  F√ºr den Administrator oder den Benutzer ist die Befehlszeile nicht nur ein Tool, das alles kann, sondern auch ein hochgradig angepasstes Tool, das f√ºr immer entwickelt werden kann.  K√ºrzlich gab es einen √ºbersetzten Artikel √ºber einige n√ºtzliche Tricks in CLI.  Ich habe jedoch das Gef√ºhl, dass der √úbersetzer nicht gen√ºgend Erfahrung mit CLI hat und die beschriebenen Tricks nicht befolgt hat, sodass viele wichtige Dinge √ºbersehen oder missverstanden werden k√∂nnen. <br><br>  Unter dem Strich - ein Dutzend Tricks in der Linux-Shell aus meiner pers√∂nlichen Erfahrung. <br><a name="habracut"></a><br>  Hinweis: Alle Skripte und Beispiele im Artikel wurden so weit wie m√∂glich speziell vereinfacht. Vielleicht finden Sie mehrere Tricks v√∂llig nutzlos - vielleicht ist dies der Grund.  Aber teilen Sie auf jeden Fall Ihre Meinung in den Kommentaren! <br><br><h4>  1. Teilen Sie die Zeichenfolge mit variablen Erweiterungen </h4><br>  Menschen verwenden oft <b>geschnitten</b> oder sogar <b>awk</b> , um einen Teil der Schnur nach Muster oder mit Trennzeichen zu subtrahieren. <br>  Au√üerdem verwenden viele Leute eine Teilzeichenfolgen-Bash-Operation mit $ {VARIABLE: start_position: length}, die sehr schnell funktioniert. <br><br>  Bash bietet jedoch eine leistungsstarke M√∂glichkeit zum Bearbeiten von Textzeichenfolgen mit #, ##,% und %% - es werden <i>Bash-Variablenerweiterungen genannt</i> . <br>  Mit dieser Syntax k√∂nnen Sie das Notwendige nach Muster schneiden, ohne externe Befehle ausf√ºhren zu m√ºssen, sodass es sehr schnell funktioniert. <br><br>  Das folgende Beispiel zeigt, wie die dritte Spalte (Shell) aus der Zeichenfolge abgerufen wird, in der durch Doppelpunkt "Benutzername: Homedir: Shell" getrennte Werte mit <b>cut</b> oder mit variablen Erweiterungen getrennt werden (wir verwenden die <u>*:</u> Maske und den Befehl ##, was bedeutet: cut alle Zeichen links bis zum letzten gefundenen Doppelpunkt): <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br>  Die zweite Option startet den untergeordneten Prozess ( <b>Ausschneiden</b> ) nicht und verwendet √ºberhaupt keine Pipes, was viel schneller funktionieren sollte.  Und wenn Sie das Bash-Subsystem in Fenstern verwenden, in denen sich die Rohre kaum bewegen, ist der Geschwindigkeitsunterschied <u>erheblich</u> . <br><br>  Sehen wir uns ein Beispiel f√ºr Ubuntu an - f√ºhren Sie unseren Befehl 1000 Mal in einer Schleife aus <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnisse</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br>  Der Unterschied ist mehrere Dutzend Mal! <br><br>  Das obige Beispiel ist nat√ºrlich zu k√ºnstlich.  Im realen Beispiel arbeiten wir nicht mit einer statischen Zeichenfolge, wir m√∂chten eine reale Datei lesen.  Und f√ºr den Befehl ' <b>cut</b> ' leiten wir einfach / etc / passwd dorthin um.  Im Fall von ## m√ºssen wir eine Schleife erstellen und die Datei mit dem internen Befehl ' <b>read</b> ' <b>lesen</b> .  Wer wird diesen Fall gewinnen? <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre>  Keine Kommentare =) </div></div><br>  Noch ein paar Beispiele: <br><br>  Extrahieren Sie den Wert nach dem gleichen Zeichen: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br>  Text in runden Klammern extrahieren: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Bash Autocompletion mit Tab </h4><br>  Das Bash-Completion-Paket ist Teil fast jeder Linux-Distribution.  Sie k√∂nnen es in /etc/bash.bashrc oder /etc/profile.d/bash_completion.sh aktivieren, aber normalerweise ist es bereits standardm√§√üig aktiviert.  Im Allgemeinen ist die automatische Vervollst√§ndigung einer der ersten praktischen Momente auf der Linux-Shell, die ein Neuling zuerst trifft. <br><br>  Aber die Tatsache, dass nicht jeder alle Bash-Completion-Funktionen nutzt und meiner Meinung nach v√∂llig vergebens ist.  Zum Beispiel wei√ü nicht jeder, dass die automatische Vervollst√§ndigung nicht nur mit Dateinamen funktioniert, sondern auch mit Aliasnamen, Variablennamen, Funktionsnamen und f√ºr einige Befehle sogar mit Argumenten.  Wenn Sie sich mit Autocomplete-Skripten befassen, bei denen es sich tats√§chlich um Shell-Skripte handelt, k√∂nnen Sie sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autocomplete</a> f√ºr Ihre eigene Anwendung oder Ihr eigenes Skript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzuf√ºgen</a> . <br>  Aber kommen wir zur√ºck zu den Aliasnamen. <br><br>  Sie m√ºssen keine PATH-Variable bearbeiten oder Dateien im angegebenen Verzeichnis erstellen, um einen Alias ‚Äã‚Äãauszuf√ºhren.  Sie m√ºssen sie nur zum Profil oder zum Startskript hinzuf√ºgen und von jedem Ort aus ausf√ºhren. <br><br>  Normalerweise verwenden wir Kleinbuchstaben f√ºr Dateien und Verzeichnisse in * nix, daher kann es sehr bequem sein, Aliase in Gro√übuchstaben zu erstellen. In diesem Fall wird die Bash-Vervollst√§ndigung Ihren Befehl fast mit einem einzigen Buchstaben <s>erraten</s> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3. Bash Autocompletion mit Tab - Teil 2 </h4><br>  In komplizierteren F√§llen m√∂chten Sie wahrscheinlich Ihre pers√∂nlichen Skripte in $ HOME / bin ablegen. <br>  Aber wir haben Funktionen in Bash. <br><br>  Funktionen erfordern keinen Pfad oder separate Dateien.  Und (Aufmerksamkeits-) Bash-Vervollst√§ndigung funktioniert auch mit Funktionen. <br><br>  Erstellen wir die Funktion LastLogin in <b>.profile</b> (vergessen Sie nicht, .profile neu zu laden): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>(Eigentlich ist es nicht wichtig, was diese Funktion tut, es ist nur ein Beispielskript, das wir in das separate Skript oder sogar in den Alias ‚Äã‚Äãeinf√ºgen k√∂nnen, aber die Funktion k√∂nnte besser sein)</i> . <br><br>  In der Konsole (bitte beachten Sie, dass der Funktionsname einen Gro√übuchstaben enth√§lt, um die Bash-Vervollst√§ndigung zu beschleunigen): <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1.  Sensible Daten </h4><br>  Wenn Sie vor einem Befehl in der Konsole Leerzeichen einf√ºgen, wird dieser nicht im Befehlsverlauf angezeigt. Wenn Sie also ein einfaches Textkennwort in den Befehl eingeben m√ºssen, ist dies eine gute M√∂glichkeit, diese Funktion zu verwenden. Schauen Sie sich das folgende Beispiel an und geben Sie <i>"Hallo" ein 2 "</i> wird nicht in der Geschichte angezeigt: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Es ist optional</b> <div class="spoiler_text">  Es ist normalerweise standardm√§√üig aktiviert, aber Sie k√∂nnen dieses Verhalten in der folgenden Variablen konfigurieren: <br><br>  export HISTCONTROL = ignoreboth </div></div><br><br><h4>  4.2.  Sensible Daten in Befehlszeilenargumenten </h4><br>  Sie m√∂chten einige Shell-Skripte in git speichern, um sie f√ºr mehrere Server freizugeben, oder sie sind m√∂glicherweise Teil des Anwendungsstart-Skripts.  Und Sie m√∂chten, dass dieses Skript eine Verbindung zur Datenbank herstellt oder andere Aktionen ausf√ºhrt, f√ºr die Anmeldeinformationen erforderlich sind. <br><br>  Nat√ºrlich ist es eine schlechte Idee, Anmeldeinformationen im Skript selbst zu speichern, da git nicht sicher ist. <br><br>  Normalerweise k√∂nnen Sie Variablen verwenden, die bereits in den Zielumgebungen definiert wurden, und Ihr Skript enth√§lt nicht die Kennw√∂rter selbst. <br><br>  Sie k√∂nnen beispielsweise in jeder Umgebung ein kleines Skript mit 700 Berechtigungen erstellen und es mit dem <b>Quellbefehl</b> aus dem Hauptskript aufrufen: <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br>  Aber es ist nicht sicher. <br><br>  Wenn sich jemand anderes bei Ihrem Host anmelden kann, kann er einfach den Befehl <b>ps</b> ausf√ºhren und Ihren sqlplus-Prozess mit den gesamten Befehlszeilenargumenten einschlie√ülich Kennw√∂rtern anzeigen.  Daher sollten sichere Tools normalerweise in der Lage sein, Kennw√∂rter / Schl√ºssel / vertrauliche Daten direkt aus Dateien zu lesen. <br><br>  Zum Beispiel - Secure <b>SSH hat</b> einfach keine Optionen, um ein Passwort in der Kommandozeile anzugeben.  Er kann jedoch den SSH-Schl√ºssel aus der Datei lesen (und Sie k√∂nnen sichere Berechtigungen f√ºr die SSH-Schl√ºsseldatei festlegen). <br><br>  Und nicht sichere wget haben eine Option "--password", mit der Sie ein Passwort in der Kommandozeile eingeben k√∂nnen.  Und w√§hrend wget ausgef√ºhrt wird, kann jeder den Befehl ps ausf√ºhren und das von Ihnen angegebene Passwort anzeigen. <br><br>  Wenn Sie viele vertrauliche Daten haben und diese √ºber Git steuern m√∂chten, ist die einzige M√∂glichkeit die Verschl√ºsselung.  Sie geben also in jede Zielumgebung nur das Hauptkennwort und alle anderen Daten ein, die Sie verschl√ºsseln und an git senden k√∂nnen.  √úber die openssl-CLI-Schnittstelle k√∂nnen Sie √ºber die Befehlszeile mit verschl√ºsselten Daten arbeiten.  Hier ist ein Beispiel zum Ver- und Entschl√ºsseln √ºber die Befehlszeile: <br><br>  Die Datei secret.key enth√§lt den Hauptschl√ºssel - eine einzelne Zeile: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br>  Verwenden wir aes-256-cbc, um eine Zeichenfolge zu verschl√ºsseln: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br>  Sie k√∂nnen diese verschl√ºsselte Zeichenfolge in jede in git oder an einem anderen Ort gespeicherte Konfigurationsdatei einf√ºgen - ohne secret.key ist es fast unm√∂glich, sie zu entschl√ºsseln. <br>  Um den gleichen Befehl zu entschl√ºsseln, ersetzen Sie einfach -e durch -d: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. Der Befehl grep </h4><br>  Alle sollten den Befehl grep kennen.  Und sei freundlich mit regul√§ren Ausdr√ºcken.  Und oft kann man so etwas schreiben wie: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br>  Oder sogar so: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br>  Aber vergessen Sie nicht, dass grep viele wunderbare M√∂glichkeiten hat.  Beispiel: -v, das Ihre Suche zur√ºcksetzt und alle Nachrichten au√üer "info" anzeigt: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br>  Zus√§tzliches Zeug: <br><br>  Option -P ist sehr n√ºtzlich, da grep standardm√§√üig einen ziemlich veralteten "grundlegenden regul√§ren Ausdruck:" verwendet und -P PCRE aktiviert, das nicht einmal etwas √ºber Gruppierung wei√ü. <br>  -i ignoriert den Fall. <br>  --line-buffered parses line sofort, anstatt darauf zu warten, den Standard-4k-Puffer zu erreichen (n√ºtzlich f√ºr tail -f | grep). <br><br>  Wenn Sie den regul√§ren Ausdruck gut kennen, k√∂nnen Sie mit --only-matching / -o wirklich gro√üartige Dinge mit dem Schneiden von Text tun.  Vergleichen Sie einfach die n√§chsten beiden Befehle, um die Shell von myuser zu extrahieren: <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br>  Der zweite Befehl sieht kompilierter aus, f√ºhrt jedoch nur <b>grep</b> anstelle von <b>grep</b> und <b>cut aus</b> , sodass die Ausf√ºhrung weniger Zeit in Anspruch nimmt. <br><br><h4>  6. So reduzieren Sie die Gr√∂√üe der Protokolldatei </h4><br>  Wenn Sie in * nix die Protokolldatei l√∂schen, die derzeit von einer Anwendung verwendet wird, k√∂nnen Sie nicht nur alle Protokolle entfernen, sondern auch verhindern, dass die Anwendung bis zum Neustart neue Protokolle schreibt. <br><br>  Da der Dateideskriptor nicht den Dateinamen, sondern die iNode-Struktur √∂ffnet und die Anwendung weiterhin in den Dateideskriptor in die Datei schreibt, die keinen Verzeichniseintrag hat, wird diese Datei automatisch gel√∂scht, nachdem die Anwendung vom Dateisystem gestoppt wurde ( <i>Ihre Anwendung kann dies) √ñffnen und schlie√üen Sie die Protokolldatei jedes Mal, wenn Sie etwas schreiben m√∂chten, um ein solches Problem zu vermeiden, dies beeintr√§chtigt jedoch die Leistung</i> . <br><br>  So l√∂schen Sie die Protokolldatei, ohne sie zu l√∂schen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br>  Oder wir k√∂nnen den Befehl k√ºrzen verwenden: <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br>  Erw√§hnen Sie, dass dieser Befehl zum Abschneiden den Rest der Datei l√∂scht, sodass Sie die neuesten Protokollereignisse verlieren.  √úberpr√ºfen Sie ein weiteres Beispiel zum Speichern der letzten 1000 Zeilen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PS Unter Linux haben wir Standard Service Rotatelog.</i>  <i>Sie k√∂nnen Ihre Protokolle zum automatischen Abschneiden / Drehen hinzuf√ºgen oder vorhandene Protokollbibliotheken verwenden, die dies f√ºr Sie tun k√∂nnen (wie log4j in Java).</i> <br><br><h4>  7. <b>Watch</b> passt auf dich auf! </h4><br>  Es gibt eine Situation, in der Sie darauf warten, dass ein Ereignis beendet wird.  Zum Beispiel, w√§hrend sich ein anderer Benutzer bei der Shell anmeldet (Sie f√ºhren <b>den</b> Befehl <b>who</b> kontinuierlich aus), oder jemand die Datei mit scp oder ftp auf Ihren Computer kopieren sollte und Sie auf den Abschluss warten (ls Dutzende Male wiederholen). <br><br>  In solchen F√§llen k√∂nnen Sie verwenden <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br>  Standardm√§√üig wird alle 2 Sekunden mit Vorab-L√∂schen des Bildschirms ausgef√ºhrt, bis Strg + C gedr√ºckt wird.  Sie k√∂nnen konfigurieren, wie oft ausgef√ºhrt werden soll. <br><br>  Dies ist sehr n√ºtzlich, wenn Sie Live-Protokolle anzeigen m√∂chten. <br><br><h4>  8. Bash-Sequenz </h4><br>  Es gibt ein sehr n√ºtzliches Konstrukt zum Erstellen von Bereichen.  Zum Beispiel statt so etwas: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Sie k√∂nnen Folgendes schreiben: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Sie k√∂nnen auch den Befehl <b>seq verwenden</b> , um formatierte Bereiche zu generieren.  Zum Beispiel k√∂nnen wir <b>seq verwenden</b> , um Werte zu erstellen, die automatisch durch die Breite angepasst werden (00, 01 anstelle von 0, 1): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br>  Ein weiteres Beispiel mit Befehlssubstitution - Dateien umbenennen.  Um den Dateinamen ohne Erweiterung zu erhalten, verwenden wir den Befehl ' <b>basename</b> ': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Auch noch k√ºrzer mit '%': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PS Zum Umbenennen der Dateien k√∂nnen Sie das Tool " <b>Umbenennen</b> " verwenden, das viele Optionen bietet. <br><br>  Ein weiteres Beispiel: Erstellen Sie eine Struktur f√ºr ein neues Java-Projekt: <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9. Schwanz, mehrere Dateien, mehrere Benutzer ... </h4><br>  Ich habe <b>Multitail</b> erw√§hnt, um Dateien zu lesen und mehrere Live-Protokolle <b>anzusehen</b> .  Es wird jedoch nicht standardm√§√üig bereitgestellt, und Berechtigungen zum Installieren von Objekten sind nicht immer verf√ºgbar. <br><br>  Aber Standardschwanz kann es auch: <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br>  Erinnern wir uns auch an Benutzer, die 'tail -f'-Aliase verwenden, um Anwendungsprotokolle zu √ºberwachen. <br>  Mehrere Benutzer k√∂nnen Protokolldateien gleichzeitig mit 'tail -f' anzeigen.  Einige von ihnen sind mit ihren Sitzungen nicht sehr genau.  Sie k√∂nnten aus irgendeinem Grund 'tail -f' im Hintergrund lassen und es vergessen. <br><br>  Wenn die Anwendung neu gestartet wurde, gibt es diese 'tail-f'-Prozesse, die beobachten, dass nicht vorhandene Protokolldateien mehrere Tage oder sogar Monate h√§ngen bleiben k√∂nnen. <br><br>  Normalerweise ist es kein gro√ües Problem, aber nicht ordentlich. <br><br>  Falls Sie zum √úberwachen des Protokolls einen Alias ‚Äã‚Äãverwenden, k√∂nnen Sie diesen Alias ‚Äã‚Äãmit der Option --pid √§ndern: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br>  In diesem Fall werden alle <b>Endpunkte</b> automatisch beendet, wenn die Zielanwendung neu gestartet wird. <br><br><h4>  10. Erstellen Sie eine Datei mit der angegebenen Gr√∂√üe </h4><br>  <b>dd</b> war eines der beliebtesten Tools f√ºr die Arbeit mit Block- und Bin√§rdaten.  Beispiel: Eine mit Null gef√ºllte 1-MB-Datei wird erstellt: <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br>  Aber ich empfehle die Verwendung von <b>Fallocate</b> : <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br>  Auf Dateisystemen, die die Zuweisungsfunktion unterst√ºtzen (xfs, ext4, Btrfs ...), wird <b>fallocate</b> im Gegensatz zum dd-Tool sofort ausgef√ºhrt.  Zuweisen bedeutet au√üerdem, dass Bl√∂cke tats√§chlich zugewiesen werden und keine Ersatzdatei erstellt wird. <br><br><h4>  11. xargs </h4><br>  Viele Leute kennen den beliebten Befehl <b>xargs</b> .  Aber nicht alle verwenden zwei der folgenden Optionen, die Ihr Skript erheblich verbessern k√∂nnten. <br><br>  Erstens: Sie k√∂nnen eine sehr lange Liste von zu verarbeitenden Argumenten erhalten, die die Befehlszeilenl√§nge √ºberschreiten kann (standardm√§√üig ~ 4 kb). <br><br>  Sie k√∂nnen die Ausf√ºhrung jedoch mit der Option -n einschr√§nken, sodass <b>xargs</b> den Befehl mehrmals ausf√ºhrt und jeweils eine bestimmte Anzahl von Argumenten sendet: <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br>  Gehen Sie voran.  Das Verarbeiten einer langen Liste kann viel Zeit in Anspruch nehmen, da sie in einem einzelnen Thread ausgef√ºhrt wird.  Wenn wir jedoch mehrere Kerne haben, k√∂nnen wir <b>xargs anweisen</b> , parallel zu laufen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  Im obigen Beispiel <b>weisen</b> wir <b>xargs</b> an, die Liste in 3 Threads zu verarbeiten.  Jeder Thread akzeptiert und verarbeitet 2 Argumente pro Ausf√ºhrung.  Wenn Sie nicht wissen, wie viele Kerne Sie haben, k√∂nnen Sie dies mit " <b>nproc</b> " optimieren: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12. schlafen?  w√§hrend?  lesen! </h4><br>  Einige Zeit m√ºssen Sie einige Sekunden warten.  Oder warten Sie auf Benutzereingaben mit read: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br>  Sie k√∂nnen dem Lesebefehl jedoch einfach eine Timeout-Option hinzuf√ºgen, und Ihr Skript wird f√ºr eine bestimmte Anzahl von Sekunden angehalten. Bei einer interaktiven Ausf√ºhrung kann der Benutzer das Warten jedoch problemlos √ºberspringen. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br>  Sie k√∂nnen also einfach den Schlafbefehl vergessen. <br><br>  Ich vermute, dass nicht alle meine Tricks interessant aussehen, aber es schien mir, dass ein Dutzend eine gute Zahl zum Ausf√ºllen sind. <br><br>  An dieser Stelle verabschiede ich mich und bin dankbar f√ºr die Teilnahme an der Umfrage. <br><br>  Nat√ºrlich kannst du das oben Genannte diskutieren und deine coolen Tricks in den Kommentaren teilen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444890/">https://habr.com/ru/post/de444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444880/index.html">Eine Multi-Welt-Interpretation der Quantenmechanik</a></li>
<li><a href="../de444882/index.html">Banken begannen, freiberufliche Konten zu sperren</a></li>
<li><a href="../de444884/index.html">Groovy verlie√ü C√©dric Champeau</a></li>
<li><a href="../de444886/index.html">Reverse Engineering-Anwendungen nach Verschleierung</a></li>
<li><a href="../de444888/index.html">Englisch und IT: Englische Eule auf einem russischen Globus?</a></li>
<li><a href="../de444892/index.html">US-Betr√ºger verdiente Millionen von Dollar als Microsoft Tech Support</a></li>
<li><a href="../de444894/index.html">Zabbix 4.2 ver√∂ffentlicht</a></li>
<li><a href="../de444896/index.html">Recycling von Festplatten als elektronischer M√ºll - Teill√∂sung von iNEMI</a></li>
<li><a href="../de444898/index.html">So w√§hlen Sie ein Breitbandmodem f√ºr ein unbemanntes Luftfahrzeug (UAV) oder eine Robotik</a></li>
<li><a href="../de444900/index.html">Formularvalidierung in Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>