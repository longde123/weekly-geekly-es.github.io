<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏼 🧝🏼 👨🏼 RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi 🔟 〽️ 🕓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, kami memeriksa pengelompokan RabbitMQ untuk toleransi kesalahan dan ketersediaan tinggi. Sekarang mari kita menggali lebih d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/474984/"><img src="https://habrastorage.org/webt/rc/zb/n7/rczbn7bwtp8b5day0whi_wace2e.jpeg"><br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami memeriksa pengelompokan RabbitMQ untuk toleransi kesalahan dan ketersediaan tinggi.  Sekarang mari kita menggali lebih dalam ke Apache Kafka. <br><br>  Di sini, unit replikasi adalah partisi.  Setiap topik memiliki satu atau lebih bagian.  Setiap bagian memiliki pemimpin dengan atau tanpa pengikut.  Saat membuat topik, jumlah partisi dan tingkat replikasi ditunjukkan.  Nilai yang biasa adalah 3, yang berarti tiga komentar: satu pemimpin dan dua pengikut. <br><a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ly/hd/ml/lyhdmlstwyv-tf_-ts54gife3cw.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Empat bagian didistribusikan di antara tiga broker</font></i> <br><br>  Semua permintaan baca dan tulis pergi ke pemimpin.  Pengikut secara berkala mengirim permintaan kepada pemimpin untuk menerima pesan terbaru.  Konsumen tidak pernah beralih ke pengikut, yang terakhir hanya ada untuk redundansi dan toleransi kesalahan. <br><br><img src="https://habrastorage.org/webt/sb/fc/v0/sbfcv0j3mosfzvrb7qktoexl_lg.png"><br><br><h1>  Bagian gagal </h1><br>  Ketika broker jatuh, pemimpin beberapa bagian sering gagal.  Di masing-masing dari mereka, pengikut dari simpul lain menjadi pemimpin.  Sebenarnya, ini tidak selalu terjadi, karena faktor sinkronisasi juga mempengaruhi: apakah ada pengikut yang disinkronkan, dan jika tidak, apakah transisi ke replika yang tidak disinkronkan diperbolehkan.  Tetapi untuk sekarang, jangan menyulitkannya. <br><br>  Broker 3 meninggalkan jaringan - dan untuk bagian 2 pemimpin baru pada broker 2 dipilih. <br><br><img src="https://habrastorage.org/webt/im/ct/r0/imctr0qotjsjg4_jx3g6p5otk9u.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. Broker 3 meninggal dan pengikutnya di broker 2 terpilih sebagai pemimpin baru pada bagian 2</font></i> <br><br>  Kemudian broker 1 pergi dan bagian 1 juga kehilangan pemimpinnya, yang perannya menjadi broker 2. <br><br><img src="https://habrastorage.org/webt/rg/fo/zp/rgfozpk7b_t1odoxso1mvihmccu.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. Hanya ada satu broker yang tersisa.</font></i>  <i><font color="gray">Semua pemimpin berada pada broker redundansi nol yang sama.</font></i> <br><br>  Ketika broker 1 kembali ke jaringan, ia menambahkan empat pengikut, memberikan redundansi pada setiap bagian.  Tetapi semua pemimpin masih tetap pada broker 2. <br><br><img src="https://habrastorage.org/webt/mh/lj/2s/mhlj2sn5r6rcjodqnl22450bjn8.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">4. Pemimpin tetap di broker 2</font></i> <br><br>  Ketika broker 3 naik, kami kembali ke tiga replika per bagian.  Tetapi semua pemimpin masih di broker 2. <br><br><img src="https://habrastorage.org/webt/3u/tb/op/3utbopk0awdg8rg62natyoxqg9o.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">5. Penempatan pemimpin yang tidak seimbang setelah pemulihan broker 1 dan 3</font></i> <br><br>  Kafka memiliki alat untuk menyeimbangkan pemimpin yang lebih baik daripada RabbitMQ.  Di sana Anda harus menggunakan plug-in atau skrip pihak ketiga yang mengubah kebijakan untuk memigrasi node utama dengan mengurangi redundansi selama migrasi.  Selain itu, untuk antrian besar harus memasang dengan tidak dapat diaksesnya selama sinkronisasi. <br><br>  Kafka memiliki konsep "isyarat pilihan" untuk peran kepemimpinan.  Ketika bagian topik dibuat, Kafka mencoba untuk mendistribusikan pemimpin secara merata di seluruh simpul dan menandai pemimpin pertama ini sebagai yang disukai.  Seiring waktu, karena server reboot, kegagalan, dan kegagalan konektivitas, pemimpin mungkin berakhir pada node lain, seperti dalam kasus ekstrim yang dijelaskan di atas. <br><br>  Untuk memperbaikinya, Kafka menawarkan dua opsi: <br><br><ul><li>  Opsi <i>auto.leader.rebalance.enable = true</i> memungkinkan node controller untuk secara otomatis menugaskan kembali pemimpin ke replika yang disukai dan dengan demikian mengembalikan distribusi yang seragam. <br></li><li>  Administrator dapat menjalankan skrip <i>kafka-preferred-replica-election.sh</i> untuk ditugaskan kembali secara manual. </li></ul><br><br><img src="https://habrastorage.org/webt/qt/2l/th/qt2lth99rb1fhzq8g4r93uoxh6k.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">6. Replika setelah penyeimbangan ulang</font></i> <br><br>  Itu adalah versi kegagalan yang disederhanakan, tetapi kenyataannya lebih kompleks, meskipun tidak ada yang terlalu rumit di sini.  Semuanya bermuara pada replika yang disinkronkan (In-Sync Replicas, ISR). <br><br><h1>  Replika Tersinkronisasi (ISR) </h1><br>  ISR adalah sekumpulan replika partisi yang dianggap “disinkronkan” (in-sync).  Ada seorang pemimpin, tetapi mungkin tidak ada pengikut.  Seorang pengikut dianggap tersinkronisasi jika ia membuat salinan yang tepat dari semua pesan pemimpin sebelum berakhirnya interval <i>replica.lag.time.max.ms</i> . <br><br>  Pengikut dihapus dari set ISR jika: <br><br><ul><li>  tidak mengajukan permintaan pengambilan sampel untuk interval <i>replica.lag.time.max.ms</i> (dianggap mati) <br></li><li>  tidak punya waktu untuk memperbarui untuk <i>replica.lag.time.max.ms</i> interval (dianggap lambat) </li></ul><br>  Pengikut melakukan pengambilan permintaan dalam interval <i>replica.fetch.wait.max.ms</i> , yang secara default adalah 500 ms. <br><br>  Untuk menjelaskan dengan jelas tujuan ISR, Anda perlu melihat konfirmasi dari produsen (produsen) dan beberapa skenario kegagalan.  Produsen dapat memilih kapan broker mengirim konfirmasi: <br><br><ul><li>  acks = 0, konfirmasi tidak terkirim <br></li><li>  acks = 1, konfirmasi dikirim setelah pemimpin menulis pesan ke log lokalnya <br></li><li>  acks = all, konfirmasi dikirim setelah semua replika di ISR ​​telah menulis pesan ke log lokal </li></ul><br>  Dalam terminologi Kafka, jika ISR telah menyimpan pesan, itu "berkomitmen".  Acks = all adalah opsi paling aman, tetapi juga penundaan tambahan.  Mari kita lihat dua contoh kegagalan dan bagaimana opsi 'acks' berbeda berinteraksi dengan konsep ISR. <br><br><h3>  Acks = 1 dan ISR </h3><br>  Dalam contoh ini, kita akan melihat bahwa jika pemimpin tidak menunggu setiap pesan dari semua pengikut disimpan, maka jika pemimpin gagal, data dapat hilang.  Pergi ke pengikut yang tidak disinkronkan dapat diaktifkan atau dinonaktifkan dengan menetapkan <i>unclean.leader.election.enable</i> . <br><br>  Dalam contoh ini, pabrikan diatur ke acks = 1.  Bagian ini didistribusikan di ketiga broker.  Broker 3 di belakang, disinkronkan dengan pemimpin delapan detik yang lalu dan sekarang di belakang oleh 7456 pesan.  Broker 1 hanya satu detik di belakang.  Produser kami mengirim pesan dan dengan cepat menerima ack kembali, tanpa biaya overhead untuk pengikut yang lambat atau mati yang tidak diharapkan oleh pemimpin. <br><br><img src="https://habrastorage.org/webt/ej/bh/g7/ejbhg7svgcphrhpdtzbwuw--wg4.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">7. ISR dengan tiga replika</font></i> <br><br>  Broker 2 gagal, dan pabrikan menerima kesalahan koneksi.  Setelah transisi kepemimpinan ke broker 1, kami kehilangan 123 pesan.  Pengikut di broker 1 adalah bagian dari ISR, tetapi tidak sepenuhnya melakukan sinkronisasi dengan pemimpin ketika dia jatuh. <br><br><img src="https://habrastorage.org/webt/6y/th/y9/6ythy9olfa5zr2wyqtfqcrq8u5e.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">8. Setelah gagal, pesan hilang</font></i> <br><br>  Dalam konfigurasi <i>bootstrap.servers</i> , pabrikan mencantumkan beberapa pialang, dan ia dapat menanyakan pialang lain yang menjadi pemimpin baru bagian tersebut.  Dia kemudian membangun koneksi dengan broker 1 dan terus mengirim pesan. <br><br><img src="https://habrastorage.org/webt/br/o6/jr/bro6jrn5nt-a0wzvg_yt0csmdgg.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">9. Mengirim pesan dilanjutkan setelah istirahat singkat</font></i> <br><br>  Broker 3 tertinggal lebih jauh.  Itu membuat mengambil permintaan, tetapi tidak dapat menyinkronkan.  Ini mungkin karena koneksi jaringan yang lambat antara broker, masalah penyimpanan, dll. Itu dihapus dari ISR.  Sekarang ISR terdiri dari satu replika - pemimpin!  Pabrikan terus mengirim pesan dan menerima konfirmasi. <br><br><img src="https://habrastorage.org/webt/b2/qj/aj/b2qjaj5g_yx2wfb-jdkalxr9074.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">10. Pengikut pada broker 3 dihapus dari ISR</font></i> <br><br>  Pialang 1 jatuh, dan peran pemimpin beralih ke pialang 3 dengan hilangnya 15286 pesan!  Pabrikan menerima pesan kesalahan koneksi.  Pergi ke pemimpin di luar ISR hanya dimungkinkan karena pengaturan <i>unclean.leader.election.enable = true</i> .  Jika disetel ke <i>false</i> , maka transisi tidak akan terjadi, dan semua permintaan baca dan tulis akan ditolak.  Dalam hal ini, kami sedang menunggu kembalinya broker 1 dengan data yang tidak tersentuh dalam replika, yang akan kembali memimpin. <br><br><img src="https://habrastorage.org/webt/rr/n1/-n/rrn1-nekmhjtro9pxeueciytb50.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">11. Broker 1 tetes.</font></i>  <i><font color="gray">Jika kegagalan terjadi, sejumlah besar pesan hilang</font></i> <br><br>  Pabrikan menjalin hubungan dengan broker terakhir dan melihat bahwa ia sekarang adalah pemimpin bagian.  Dia mulai mengirim pesan ke broker 3. <br><br><img src="https://habrastorage.org/webt/qj/qq/go/qjqqgoevfafcmcxtidd_bvjw9wi.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">12. Setelah istirahat singkat, pesan dikirim lagi ke bagian 0</font></i> <br><br>  Kami melihat bahwa selain gangguan singkat untuk membuat koneksi baru dan mencari pemimpin baru, pabrikan terus-menerus mengirim pesan.  Konfigurasi ini menyediakan aksesibilitas melalui konsistensi (keamanan data).  Kafka kehilangan ribuan pesan, tetapi terus menerima entri baru. <br><br><h3>  Acks = all dan ISR </h3><br>  Mari kita ulangi skenario ini lagi, tetapi dengan <i>acks = all</i> .  Menunda broker 3 rata-rata empat detik.  Pabrikan mengirim pesan dengan <i>acks = all</i> , dan sekarang tidak menerima respons cepat.  Pemimpin menunggu hingga semua pesan di ISR ​​menyimpan pesan. <br><br><img src="https://habrastorage.org/webt/3c/6j/a5/3c6ja5msoncfx1s-xbyjpmujtdo.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">13. ISR dengan tiga replika.</font></i>  <i><font color="gray">Salah satunya lambat, menyebabkan penundaan dalam perekaman</font></i> <br><br>  Setelah empat detik penundaan tambahan, broker 2 mengirimkan ack.  Semua replika sekarang sepenuhnya diperbarui. <br><br><img src="https://habrastorage.org/webt/ol/eg/y6/olegy6unibvup0tlza6cbd4gqic.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">14. Semua replika menyimpan pesan dan ack dikirim</font></i> <br><br>  Broker 3 sekarang bahkan lebih jauh di belakang dan sedang dihapus dari ISR.  Penundaan berkurang secara signifikan karena tidak ada replika lambat yang tersisa di ISR.  Broker 2 sekarang menunggu hanya untuk broker 1, dan ia memiliki jeda rata-rata 500 ms. <br><br><img src="https://habrastorage.org/webt/ub/0e/7j/ub0e7jm1siaa9dvcmxyldti1ify.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">15. Replika pada broker 3 dihapus dari ISR</font></i> <br><br>  Kemudian broker 2 jatuh, dan kepemimpinan berpindah ke broker 1 tanpa kehilangan pesan. <br><br><img src="https://habrastorage.org/webt/a7/ts/8m/a7ts8mywsvuowiof5jp6f6eszlq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">16. Pialang 2 jatuh</font></i> <br><br>  Pabrikan menemukan pemimpin baru dan mulai mengiriminya pesan.  Penundaan masih berkurang, karena sekarang ISR terdiri dari satu replika!  Oleh karena itu, opsi <i>acks = all</i> tidak menambahkan redundansi. <br><br><img src="https://habrastorage.org/webt/-z/i_/od/-zi_odb0nc-nf0xe1tsxmzlr-uq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">17. Replika pada broker 1 memimpin tanpa kehilangan pesan</font></i> <br><br>  Kemudian broker 1 jatuh, dan kepemimpinan beralih ke broker 3 dengan hilangnya 14.238 pesan! <br><br><img src="https://habrastorage.org/webt/sr/x5/1m/srx51mjemyxnksoewy6n91_lgqy.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">18. Pialang 1 meninggal, dan transisi kepemimpinan dengan pengaturan yang tidak bersih menyebabkan hilangnya data yang luas</font></i> <br><br>  Kami tidak dapat mengatur opsi <i>unclean.leader.election.enable</i> menjadi <i>true</i> .  Secara default, ini <i>salah</i> .  Pengaturan <i>acks = all</i> dengan <i>unclean.leader.election.enable = true</i> menyediakan aksesibilitas dengan beberapa keamanan data tambahan.  Tapi, seperti yang Anda lihat, kita masih bisa kehilangan pesan. <br><br>  Tetapi bagaimana jika kita ingin meningkatkan keamanan data?  Anda dapat mengatur <i>unclean.leader.election.enable = false</i> , tetapi ini tidak selalu melindungi kami dari kehilangan data.  Jika pemimpin jatuh dan mengambil data bersamanya, maka pesannya masih hilang, ditambah aksesibilitasnya hilang sampai administrator memulihkan situasi. <br><br>  Lebih baik untuk menjamin redundansi semua pesan, dan sebaliknya menolak untuk merekam.  Kemudian, setidaknya dari sudut pandang broker, kehilangan data hanya mungkin terjadi dengan dua kegagalan simultan atau lebih. <br><br><h3>  Acks = all, min.insync.replicas, dan ISR </h3><br>  Dengan <i>konfigurasi</i> topik <i>min.insync.replicas,</i> kami meningkatkan keamanan data.  Mari kita kembali ke bagian terakhir dari skenario terakhir, tetapi kali ini dengan <i>min.insync.replicas = 2</i> . <br><br>  Jadi, broker 2 memiliki pemimpin replika, dan pengikut broker 3 dihapus dari ISR. <br><br><img src="https://habrastorage.org/webt/5g/ij/ls/5gijlstkvqxo4ojr6wfxxwn719m.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">19. ISR dari dua replika</font></i> <br><br>  Broker 2 jatuh, dan kepemimpinan berpindah ke broker 1 tanpa kehilangan pesan.  Tetapi sekarang ISR hanya terdiri dari satu replika.  Ini tidak sesuai dengan jumlah minimum untuk menerima catatan, dan karena itu broker menanggapi upaya untuk merekam dengan kesalahan <i>NotEnoughReplicas</i> . <br><br><img src="https://habrastorage.org/webt/ng/p5/fj/ngp5fjym6nvykpohj8brnl8bvxc.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">20. Jumlah ISR adalah satu lebih rendah dari yang ditentukan dalam min.insync.replicas</font></i> <br><br>  Konfigurasi ini mengorbankan ketersediaan untuk konsistensi.  Sebelum mengkonfirmasi suatu pesan, kami menjamin bahwa pesan itu direkam pada setidaknya dua replika.  Ini memberi produsen lebih percaya diri.  Di sini, kehilangan pesan hanya dimungkinkan jika dua replika secara bersamaan gagal dalam interval pendek, sampai pesan direplikasi ke pengikut tambahan, yang tidak mungkin.  Tetapi jika Anda seorang superparanoid, maka Anda dapat mengatur rasio replikasi menjadi 5, dan <i>min.insync.replicas</i> menjadi 3. Kemudian tiga broker sekaligus harus jatuh pada waktu yang sama untuk kehilangan catatan!  Tentu saja, untuk keandalan seperti itu Anda akan membayar penundaan tambahan. <br><br><h1>  Ketika aksesibilitas diperlukan untuk keamanan data </h1><br>  Seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halnya RabbitMQ</a> , terkadang aksesibilitas diperlukan untuk keamanan data.  Anda perlu memikirkan ini: <br><br><ul><li>  Bisakah penerbit hanya mengembalikan kesalahan, dan layanan yang lebih tinggi atau pengguna mencoba lagi nanti? <br></li><li>  Bisakah penerbit menyimpan pesan secara lokal atau dalam database untuk mencoba lagi nanti? </li></ul><br>  Jika jawabannya tidak, maka mengoptimalkan aksesibilitas akan meningkatkan keamanan data.  Anda akan kehilangan lebih sedikit data jika Anda memilih ketersediaan alih-alih membuang rekaman.  Dengan demikian, semuanya bermuara pada menemukan keseimbangan, dan keputusan tergantung pada situasi spesifik. <br><br><h1>  Arti ISR </h1><br>  Suite ISR memungkinkan Anda untuk memilih keseimbangan optimal antara keamanan data dan latensi.  Misalnya, untuk memastikan bahwa sebagian besar replika dapat diakses jika terjadi kegagalan, meminimalkan dampak mati atau lambat dalam hal penundaan. <br><br>  Kami sendiri memilih nilai <i>replica.lag.time.max.ms</i> sesuai dengan kebutuhan kami.  Intinya, parameter ini berarti penundaan apa yang siap kami terima dengan <i>acks = all</i> .  Nilai default adalah sepuluh detik.  Jika ini terlalu lama untuk Anda, Anda bisa menguranginya.  Maka frekuensi perubahan dalam ISR akan meningkat, karena pengikut akan lebih sering dihapus dan ditambahkan. <br><br>  RabbitMQ hanyalah kumpulan cermin yang perlu direplikasi.  Mirror lambat memperkenalkan penundaan tambahan, dan respons dari mirror mati dapat diharapkan sebelum berakhirnya paket yang memeriksa ketersediaan setiap node (net tick).  ISR adalah cara yang menarik untuk menghindari masalah ini dengan latensi yang meningkat.  Tetapi kita berisiko kehilangan redundansi, karena ISR hanya dapat direduksi menjadi seorang pemimpin.  Untuk menghindari risiko ini, gunakan pengaturan <i>min.insync.replicas</i> . <br><br><h1>  Jaminan Konektivitas Pelanggan </h1><br>  Dalam pengaturan <i>bootstrap.servers</i> dari pabrikan dan konsumen, Anda dapat menentukan beberapa broker untuk menghubungkan klien.  Idenya adalah bahwa ketika Anda memutuskan satu node, ada beberapa node cadangan yang dengannya klien dapat membuka koneksi.  Ini tidak harus pemimpin bagian, tetapi hanya batu loncatan untuk bootstrap.  Klien dapat bertanya pada mereka di simpul mana pemimpin bagian baca / tulis berada. <br><br>  Di RabbitMQ, klien dapat terhubung ke host mana pun, dan routing internal mengirimkan permintaan jika diperlukan.  Ini artinya Anda dapat memasang penyeimbang beban di depan RabbitMQ.  Kafka mengharuskan klien untuk terhubung ke host yang menampung pemimpin dari partisi yang sesuai.  Dalam situasi ini, penyeimbang beban tidak memberikan.  Daftar <i>bootstrap.servers</i> sangat penting sehingga klien dapat mengakses node yang benar dan menemukannya setelah crash. <br><br><h1>  Arsitektur Konsensus Kafka </h1><br>  Sejauh ini, kami belum mempertimbangkan bagaimana cluster mengetahui tentang jatuhnya broker dan bagaimana pemimpin baru dipilih.  Untuk memahami bagaimana Kafka bekerja dengan partisi jaringan, Anda harus terlebih dahulu memahami arsitektur konsensus. <br><br>  Setiap cluster Kafka digunakan dengan cluster Zookeeper - ini adalah layanan konsensus terdistribusi yang memungkinkan sistem untuk mencapai konsensus di beberapa negara tertentu dengan prioritas konsistensi daripada ketersediaan.  Persetujuan operasi baca dan tulis membutuhkan persetujuan dari sebagian besar node Zookeeper. <br><br>  Zookeeper menyimpan status kluster: <br><br><ul><li>  Daftar topik, bagian, konfigurasi, replika pemimpin saat ini, replika pilihan. <br></li><li>  Anggota cluster.  Setiap broker masuk ke dalam cluster Zookeeper.  Jika dia tidak menerima ping untuk jangka waktu tertentu, maka Zookeeper menulis broker tidak dapat diakses. <br></li><li>  Pilihan node primer dan sekunder untuk controller. </li></ul><br>  Node controller adalah salah satu broker Kafka yang bertanggung jawab untuk memilih pemimpin replika.  Zookeeper mengirimkan pemberitahuan kepada pengontrol tentang perubahan keanggotaan dan perubahan topik, dan pengontrol harus bertindak sesuai dengan perubahan ini. <br><br>  Misalnya, ambil topik baru dengan sepuluh bagian dan koefisien replikasi 3. Pengontrol harus memilih pemimpin dari setiap bagian, mencoba untuk mendistribusikan pemimpin secara optimal di antara broker. <br><br>  Untuk setiap bagian, pengontrol: <br><br><ul><li>  memperbarui informasi dalam Zookeeper tentang ISR dan pemimpinnya; <br></li><li>  mengirimkan perintah LeaderAndISRCommand kepada setiap broker yang memposting replika bagian ini, memberi tahu broker tentang ISR dan pemimpinnya. </li></ul><br>  Ketika broker dengan seorang pemimpin jatuh, Zookeeper mengirimkan pemberitahuan ke controller, dan dia memilih pemimpin baru.  Sekali lagi, controller pertama memperbarui Zookeeper, dan kemudian mengirimkan perintah ke masing-masing broker, memberi tahu mereka tentang perubahan dalam kepemimpinan. <br><br>  Setiap pemimpin bertanggung jawab untuk merekrut ISR.  <i>Pengaturan replica.lag.time.max.ms</i> menentukan siapa yang akan pergi ke sana.  Ketika ISR berubah, pemimpin memberikan informasi baru kepada Zookeeper. <br><br>  Zookeeper selalu mendapat informasi tentang perubahan apa pun, sehingga jika terjadi kegagalan, manajemen lancar pindah ke pemimpin baru. <br><br><img src="https://habrastorage.org/webt/yi/1v/in/yi1vinwmeg4exdiautqohweg8rq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">21. Konsensus Kafka</font></i> <br><br><h1>  Protokol replikasi </h1><br>  Memahami detail replikasi membantu Anda lebih memahami potensi skenario kehilangan data. <br><br><h3>  Permintaan Sampel, Log End Offset (LEO) dan Highwater Mark (HW) </h3><br>  Kami telah mempertimbangkan bahwa pengikut secara berkala mengirim permintaan pengambilan kepada pemimpin.  Interval default adalah 500 ms.  Ini berbeda dari RabbitMQ di bahwa di RabbitMQ, replikasi dimulai bukan oleh cermin antrian, tetapi oleh penyihir.  Master mendorong perubahan ke mirror. <br><br>  Pemimpin dan semua pengikut mempertahankan label Log End Offset (LEO) dan Highwater (HW).  Tanda LEO menyimpan offset pesan terakhir di replika lokal, dan HW menyimpan offset komitmen terakhir.  Ingat bahwa untuk status komit, pesan harus disimpan di semua replika ISR.  Ini berarti bahwa LEO biasanya sedikit di depan HW. <br><br>  Ketika seorang pemimpin menerima pesan, ia menyimpannya secara lokal.  Pengikut membuat permintaan pengambilan, melewati LEO-nya.  Pemimpin kemudian mengirim paket pesan yang dimulai dengan LEO ini, dan juga mentransmisikan HW saat ini.  Ketika pemimpin menerima informasi bahwa semua replika telah menyimpan pesan pada offset yang diberikan, ia memindahkan tanda HW.  Hanya pemimpin yang bisa memindahkan HW, sehingga semua pengikut akan tahu nilai saat ini dalam tanggapan terhadap permintaan mereka.  Ini berarti bahwa pengikut dapat tertinggal di belakang pemimpin dalam pelaporan dan pengetahuan tentang HW.  Konsumen hanya menerima pesan hingga HW saat ini. <br><br>  Perhatikan bahwa "bertahan" berarti ditulis ke memori, bukan ke disk.  Untuk kinerja, Kafka menyinkronkan ke disk pada interval yang ditentukan.  RabbitMQ juga memiliki interval seperti itu, tetapi akan mengirimkan konfirmasi kepada penerbit hanya setelah master dan semua mirror menulis pesan ke disk.  Pengembang Kafka untuk alasan kinerja memutuskan untuk mengirim ack segera setelah pesan tersebut ditulis ke memori.  Kafka bergantung pada kenyataan bahwa redundansi mengkompensasi risiko penyimpanan jangka pendek dari pesan yang dikonfirmasi hanya dalam memori. <br><br><h1>  Kegagalan Pemimpin </h1><br>  Ketika seorang pemimpin jatuh, Zookeeper memberitahu controller, dan dia memilih replika pemimpin baru.  Pemimpin baru menetapkan tanda HW baru sesuai dengan LEO-nya.  Kemudian pengikut menerima informasi tentang pemimpin baru.  Bergantung pada versi Kafka, pengikut akan memilih satu dari dua skenario: <br><br><ol><li>  Memotong log lokal ke HW yang terkenal dan mengirim pesan ke pemimpin baru setelah tanda ini. <br></li><li>   ,   HW     ,       .       ,    . </li></ol><br>        : <br><br><ul><li>    ,     ISR,   Zookeeper,     .    ISR,    «»,          .  ,        . Kafka ,     .  ,   ,         HW      .    ,   <i>acks=all</i>    . <br></li><li>     .      ,        .  ,       ,  ,   ,    ,        . </li></ul><br><h3>  c  </h3><br>        ,     :          HW (  ).  , RabbitMQ       .        .    ,             «    ».            .       . <br><br> Kafka —   ,       ,   RabbitMQ,        .      .  Kafka —      ,        .            .    Kafka      HW  (   )   ,     .    ,    ,       ,     LEO. <br><br>        ISR     .      ,    ,  ,         ISR.          . <br><br><h1>   </h1><br>  Kafka  ,   RabbitMQ,      ,     .  Kafka    ,      . <br><br>      : <br><br><ul><li>  1.    ,     Zookeeper. <br></li><li>  2.      ,     Zookeeper. <br></li><li>  3.   ,    Zookeeper. <br></li><li>  4.   ,    Zookeeper. <br></li><li>  5.        Kafka,   Zookeeper. <br></li><li>  6.        Kafka,   Zookeeper. <br></li><li>  7.   Kafka     Kafka. <br></li><li>  8.  Kafka   Zookeeper. </li></ul><br>      . <br><br><h3>  1.    ,     Zookeeper </h3><br><img src="https://habrastorage.org/webt/je/cd/f1/jecdf1kc9y8gc8ej5sfmuelo30a.png"><br> <i><font color="gray">. 22.  1. ISR   </font></i> <br><br>     3   1  2,    Zookeeper.  3       .    <i>replica.lag.time.max.ms</i>    ISR      .    ,         ISR,   . Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/ir/tq/ir/irtqir6cr8whigmvfqo1t-bbsso.png"><br> <i><font color="gray">. 23.  1.    ISR,            replica.lag.time.max.ms</font></i> <br><br>     (split-brain)   ,   RabbitMQ.    . <br><br><h3>  2.      ,     Zookeeper </h3><br><img src="https://habrastorage.org/webt/ri/fy/q6/rifyq652am8lmbhlgpfvfq-pjnm.png"><br> <i><font color="gray">. 24.  2.    </font></i> <br><br>       ,      Zookeeper.     , ISR ,       ,        .  ,    .        ,    . Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/hj/8g/-1/hj8g-1veu8rkisccp7t6c9bxq7k.png"><br> <i><font color="gray">. 25.  2. ISR    </font></i> <br><br><h3>  3.   ,    Zookeeper </h3><br>    Zookeeper,      .           ISR. Zookeeper        ,     ,     . <br><br><img src="https://habrastorage.org/webt/cv/tb/gj/cvtbgjgw7ub1w8dmii46aql3bhc.png"><br> <i><font color="gray">. 26.  3.       </font></i> <br><br><h3>  4.   ,    Zookeeper </h3><br><img src="https://habrastorage.org/webt/zw/k4/8o/zwk48obscffldqgdhpyl0dvvipc.png"><br> <i><font color="gray">. 27.  4.    </font></i> <br><br>    Zookeeper,      . <br><br><img src="https://habrastorage.org/webt/eh/s1/hx/ehs1hxu4sako2udflhmhhbqhtsu.png"><br> <i><font color="gray">. 28.  4.    Zookeeper</font></i> <br><br>    Zookeeper        .      .      ,           <i>acks=1</i> .        ,         ISR   .        Zookeeper,     ,         . <br><br>  <i>acks=all</i>   ,    ISR   ,      .        ISR,          - . <br><br>            .    ,   ,     ,       HW,        ,    .         .     ,    .     ,        ,    . <br><br><img src="https://habrastorage.org/webt/pt/z_/pn/ptz_pnhoyrwvw4v-l9re3ffjzcg.png"><br> <i><font color="gray">. 29.  4.    1     </font></i> <br><br><h3>  5.        Kafka,   Zookeeper </h3><br>        Kafka,   Zookeeper.     ISR,    ,    . <br><br><img src="https://habrastorage.org/webt/ik/aj/a1/ikaja1i4z3fnodbcmam8sp2jbjc.png"><br> <i><font color="gray">. 30.  5.     ISR</font></i> <br><br><h3>  6.        Kafka,   Zookeeper </h3><br><img src="https://habrastorage.org/webt/cz/5h/2m/cz5h2mnqelpalxozp-jv4yv23rc.png"><br> <i><font color="gray">. 31.  6.    </font></i> <br><br>      ,   Zookeeper.          <i>acks=1</i> . <br><br><img src="https://habrastorage.org/webt/pj/pi/vj/pjpivjf1bsnvowntmkjqxdzipfe.png"><br> <i><font color="gray">. 32.  6.      Kafka  Zookeeper</font></i> <br><br>      <i>replica.lag.time.max.ms</i> ,    ISR   ,     ,     Zookeeper,     . <br><br>  , Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/g8/rg/wo/g8rgwol3elzkz8dwxojtclogyns.png"><br> <i><font color="gray">. 33.  6.  </font></i> <br><br>         ,      .    60    .            . <br><br><img src="https://habrastorage.org/webt/zu/zl/dh/zuzldhf62qbynz_voxil-25roxe.png"><br> <i><font color="gray">. 34.  6.     </font></i> <br><br>     ,       .    ,    Zookeeper ,     .      HW           . <br><br><img src="https://habrastorage.org/webt/zj/5e/vd/zj5evdyqhphl9uupogfvbjx7zjk.png"><br> <i><font color="gray">. 35.  6.        </font></i> <br><br>           ,    <i>acks=1</i>  <i>min.insync.replicas</i>  1.        ,    ,     ,     ,         —    ,   .       ,    <i>acks=1</i> . <br><br>     ,       ,    ISR   .    -  .   ,      ,  <i>acks=all</i> ,    ISR    .       .      — <i>min.insync.replicas = 2</i> . <br><br><h3>  7.   Kafka     Kafka </h3><br>  ,      Kafka          .         ,    6.             . <br><br><h3>  8.  Kafka   Zookeeper </h3><br>    Zookeeper         Kafka.       ,       Zookeeper,         .    ,  ,     ,     Kafka. <br><br><h3>    </h3><br>  ,         ,     ,    . , ,     ,      . <br><br>  -      Zookeeper,        <i>acks=1</i> .    Zookeeper       .     <i>acks=all</i> . <br><br>  <i>min.insync.replicas</i>        ,         ,    6. <br><br><h1>     </h1><br>   ,      Kafka: <br><br><ul><li>   ,      <i>acks=1</i> <br></li><li>   (unclean)  ,       ISR,   <i>acks=all</i> <br></li><li>    Zookeeper,      <i>acks=1</i> <br></li><li>   ,     ISR   .    ,  <i>acks=all</i> .      ,  <i>min.insync.replicas=1</i> . <br></li><li>     .     ,       .        . </li></ul><br>     ,   ,      .    —   <i>acks=all</i>  <i>min.insync.replicas</i>  1. <br><br><h1>    RabbitMQ  Kafka </h1><br>              .   RabbitMQ   .        ,   .           RabbitMQ.       ,    .       .    ,         ( )       . <br><br>  Kafka   .          .    .  ,    .    ,     ,           . , -  ,       .     ,      . <br><br> RabbitMQ  Kafka         .    , RabbitMQ              .        : <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fsync setiap beberapa ratus milidetik </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mirror dapat dideteksi hanya setelah masa pak paket yang memeriksa ketersediaan setiap node (centang net). </font><font style="vertical-align: inherit;">Jika cermin melambat atau jatuh, ini menambah penundaan.</font></font></li></ul><br>  Kafka bergantung pada kenyataan bahwa jika pesan disimpan di beberapa node, Anda dapat mengkonfirmasi pesan segera setelah mereka ada di memori.  Karena itu, ada risiko kehilangan pesan dalam jenis apa pun (bahkan <i>acks = all</i> , <i>min.insync.replies = 2</i> ) jika terjadi kegagalan secara bersamaan. <br><br>  Secara keseluruhan, Kafka menunjukkan kinerja yang lebih baik dan pada awalnya dirancang untuk cluster.  Jumlah pengikut dapat ditingkatkan menjadi 11, jika perlu untuk keandalan.  Faktor replikasi 5 dan jumlah minimum replika dalam keadaan tersinkronisasi <i>min.insync.replicas = 3</i> akan membuat kehilangan pesan peristiwa yang sangat jarang.  Jika infrastruktur Anda mampu memberikan tingkat replikasi dan tingkat redundansi seperti itu, maka Anda dapat memilih opsi ini. <br><br>  Pengelompokan RabbitMQ baik untuk antrian kecil.  Tetapi bahkan antrian kecil dapat tumbuh dengan cepat dengan lalu lintas tinggi.  Setelah antrian menjadi besar, Anda harus membuat pilihan sulit antara ketersediaan dan keandalan.  Pengelompokan RabbitMQ paling cocok untuk situasi non-tipikal di mana keuntungan dari fleksibilitas RabbitMQ lebih besar daripada kerugian dari pengelompokan itu. <br><br>  Salah satu penangkal kerentanan besar antrian RabbitMQ adalah memecahnya menjadi banyak yang lebih kecil.  Jika Anda tidak memerlukan pemesanan penuh seluruh antrian, tetapi hanya pesan yang relevan (misalnya, pesan dari klien tertentu), atau tidak sama sekali, maka opsi ini dapat diterima: lihat proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rebalanser</a> saya untuk memisahkan antrian (proyek masih pada tahap awal). <br><br>  Akhirnya, jangan lupa tentang sejumlah bug dalam mekanisme clustering dan replikasi dari RabbitMQ dan Kafka.  Seiring waktu, sistem menjadi lebih matang dan stabil, tetapi tidak ada satu pesan pun yang akan 100% terlindungi dari kehilangan!  Selain itu, kecelakaan skala besar terjadi di pusat data! <br><br>  Jika saya melewatkan sesuatu, membuat kesalahan atau Anda tidak setuju dengan tesis ini, jangan ragu untuk menulis komentar atau hubungi saya. <br><br>  Orang sering bertanya kepada saya: "Apa yang harus dipilih, Kafka atau RabbitMQ?", "Platform mana yang lebih baik?".  Yang benar adalah bahwa itu benar-benar tergantung pada situasi Anda, pengalaman saat ini, dll. Saya tidak berani mengungkapkan pendapat saya, karena akan terlalu banyak penyederhanaan untuk merekomendasikan satu platform untuk semua kasus penggunaan dan batasan yang mungkin.  Saya menulis serangkaian artikel ini sehingga Anda dapat membentuk pendapat Anda sendiri. <br><br>  Saya ingin mengatakan bahwa kedua sistem adalah pemimpin di bidang ini.  Mungkin saya sedikit bias, karena dari pengalaman proyek saya, saya lebih cenderung menghargai hal-hal seperti pemesanan pesan yang terjamin dan keandalan. <br><br>  Saya melihat teknologi lain yang tidak memiliki keandalan ini dan pemesanan yang terjamin, kemudian lihat RabbitMQ dan Kafka - dan saya mengerti nilai luar biasa dari kedua sistem ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474984/">https://habr.com/ru/post/id474984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474968/index.html">RxDart untuk ... proyek terkecil</a></li>
<li><a href="../id474970/index.html">Bagaimana cara menulis kontrak pintar dengan Python pada Ontologi? Bagian 5: API Asli</a></li>
<li><a href="../id474976/index.html">Kota Berperahu: Bagaimana Venesia Ada Tanpa Mobil</a></li>
<li><a href="../id474978/index.html">IBM Watson Visual Recognition: Pengakuan Objek Sekarang Tersedia di IBM Cloud</a></li>
<li><a href="../id474982/index.html">Tutorial JavaFX: FXML dan SceneBuilder</a></li>
<li><a href="../id474988/index.html">Selamat Datang di Mitap: Karier di Ilmu Data untuk Pemula</a></li>
<li><a href="../id474990/index.html">Praktik keras: cara membuat jaringan Wi-Fi di taman kota</a></li>
<li><a href="../id474992/index.html">Analisis baterai laptop rusak. Catatan Pengendara Motor Listrik</a></li>
<li><a href="../id474994/index.html">Cara memotong monolit ke dalam layanan dan mempertahankan kinerja cache dalam memori tanpa kehilangan konsistensi</a></li>
<li><a href="../id474996/index.html">Intisari acara TI pada bulan November (bagian dua)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>