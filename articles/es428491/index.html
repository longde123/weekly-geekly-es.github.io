<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üèπ üë∞üèæ Optimizaci√≥n proactiva del rendimiento de la base de datos Oracle üï° üîÆ ü§Ωüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lo primero que encontramos cuando hablamos de optimizaci√≥n proactiva es que no se sabe qu√© necesita ser optimizado. "Haz eso, no s√© qu√©". 



- No hay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n proactiva del rendimiento de la base de datos Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  Lo primero que encontramos cuando hablamos de optimizaci√≥n proactiva es que no se sabe qu√© necesita ser optimizado.  "Haz eso, no s√© qu√©". <br><br><ul><li>  No hay un algoritmo cl√°sico. </li><li>  El problema a√∫n no ha surgido (desconocido), y uno solo puede adivinar d√≥nde podr√≠a estar. </li><li>  Necesitamos encontrar algunos puntos d√©biles potenciales en el sistema. </li><li>  Intente optimizar el rendimiento de la consulta en estos lugares. </li></ul><br><h3>  Los objetivos principales de la optimizaci√≥n proactiva <br></h3><br>  Las tareas principales de la optimizaci√≥n proactiva difieren de las tareas de optimizaci√≥n reactiva y son las siguientes: <br><br><ul><li>  deshacerse de los cuellos de botella en la base de datos; </li><li>  disminuci√≥n en el consumo de recursos de la base de datos. </li></ul><br>  El √∫ltimo momento es el m√°s fundamental.  En el caso de la optimizaci√≥n reactiva, no tenemos la tarea de reducir el consumo de recursos en su conjunto, sino solo la tarea de llevar el tiempo de respuesta de la funcionalidad a l√≠mites aceptables. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Si trabaja con servidores de batalla, tiene una buena idea de lo que significan los incidentes de rendimiento.  Debe dejar todo y resolver r√°pidamente el problema.  RNKO Payment Center LLC trabaja con muchos agentes y es muy importante que tengan el menor n√∫mero de problemas posible.  Alexander Makarov en HighLoad ++ Siberia cont√≥ lo que se hizo para reducir significativamente el n√∫mero de incidentes de rendimiento.  La optimizaci√≥n proactiva vino al rescate.  Y por qu√© y c√≥mo se produce en un servidor de combate, lea a continuaci√≥n. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>Acerca del orador:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">AL_IG_Makarov</a> ), Administrador principal del Centro de pagos RNCO de Oracle Database, LLC.  A pesar de la posici√≥n, hay muy poca administraci√≥n como tal, las tareas principales est√°n relacionadas con el mantenimiento del complejo y su desarrollo, en particular, para resolver problemas de rendimiento. <br><br><h1>  ¬øEs la optimizaci√≥n en una base de datos de combate proactiva? <br></h1><br>  Primero, trataremos los t√©rminos a los que este informe se refiere como "optimizaci√≥n proactiva del rendimiento".  A veces puede cumplir con el punto de vista de que la optimizaci√≥n proactiva es cuando el an√°lisis de las √°reas problem√°ticas se lleva a cabo antes de que se inicie la aplicaci√≥n.  Por ejemplo, descubrimos que algunas consultas no funcionan de manera √≥ptima, ya que no hay suficiente √≠ndice o la consulta utiliza un algoritmo ineficiente, y este trabajo se realiza en servidores de prueba. <br><br>  Sin embargo, nosotros en RNCO hicimos este proyecto <strong>en servidores de batalla</strong> .  Muchas veces escuch√©: ‚Äú¬øC√≥mo es eso?  Lo haces en un servidor de combate, ¬°eso significa que no es una optimizaci√≥n proactiva del rendimiento!  Aqu√≠ necesitamos recordar el enfoque que se cultiva en ITIL.  Desde el punto de vista de ITIL, tenemos: <br><br><ul><li>  los incidentes de rendimiento son lo que ya sucedi√≥; </li><li>  Las medidas que tomamos para evitar que ocurran incidentes de rendimiento. </li></ul><br>  En este sentido, nuestras acciones son proactivas.  A pesar del hecho de que estamos resolviendo el problema en un servidor de combate, el problema en s√≠ a√∫n no ha surgido: el incidente no ocurri√≥, no corrimos y no intentamos resolver este problema en poco tiempo. <br><br>  Entonces, en este informe, la proactividad se entiende como <strong>proactividad en el sentido de ITIL</strong> , resolvemos el problema antes de que ocurra un incidente de rendimiento. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Punto de referencia <br></h1><br>  El "Centro de pagos" de RNKO sirve 2 sistemas grandes: <br><br><ul><li>  RBS-Retail Bank; </li><li>  CFT Bank. </li></ul><br>  La naturaleza de la carga en estos sistemas es mixta (DSS + OLTP): hay algo que funciona muy r√°pidamente, hay informes, hay cargas medias. <br><br>  Nos enfrentamos al hecho de que no muy a menudo, pero con cierta frecuencia, se produjeron incidentes de rendimiento.  Quienes trabajan con servidores de batalla imaginan lo que es.  Esto significa que debe abandonar todo y resolver r√°pidamente el problema, porque en este momento el cliente no puede recibir el servicio, algo no funciona o funciona muy lentamente. <br><br>  Dado que muchos agentes y clientes est√°n vinculados a nuestra organizaci√≥n, esto es muy importante para nosotros.  Si no podemos resolver r√°pidamente los incidentes de rendimiento, nuestros clientes sufrir√°n de una forma u otra.  Por ejemplo, no podr√°n reponer una tarjeta o hacer una transferencia.  Por lo tanto, nos preguntamos qu√© se podr√≠a hacer para eliminar incluso estos incidentes de rendimiento poco frecuentes.  Para trabajar en un modo cuando necesita soltar todo y resolver un problema, esto no es del todo correcto.  Usamos sprints y elaboramos un plan de trabajo de sprint.  La presencia de incidentes de rendimiento tambi√©n es una desviaci√≥n del plan de trabajo. <br><br>  ¬°Algo debe hacerse con esto! <br><br><h1>  Enfoques de optimizaci√≥n <br></h1><br>  Pensamos y llegamos a comprender la tecnolog√≠a de optimizaci√≥n proactiva.  Pero antes de hablar sobre la optimizaci√≥n proactiva, debo decir algunas palabras sobre la optimizaci√≥n reactiva cl√°sica. <br><br><h2>  Optimizaci√≥n reactiva <br></h2><br>  El escenario es simple, hay un servidor de combate en el que sucedi√≥ algo: lanzaron un informe, los clientes reciben declaraciones, en este momento hay actividad continua en la base de datos, y de repente alguien decidi√≥ actualizar alg√∫n tipo de directorio voluminoso.  El sistema comienza a ralentizarse.  En este momento, el cliente llega y dice: "No puedo hacer esto o aquello". Necesitamos encontrar una raz√≥n por la que no pueda hacer esto. <br><br>  <strong>Algoritmo de acci√≥n cl√°sico:</strong> <br><br><ol><li>  Reproduce el problema. </li><li>  Localice el lugar del problema. </li><li>  Optimizar el lugar del problema. </li></ol><br>  Dentro del marco del enfoque reactivo, la tarea principal no es tanto encontrar la causa ra√≠z en s√≠ misma y eliminarla, sino hacer que el sistema funcione normalmente.  La eliminaci√≥n de la causa ra√≠z puede tratarse m√°s adelante.  Lo principal es restaurar r√°pidamente el servidor para que el cliente pueda recibir el servicio. <br><br><h3>  Los principales objetivos de la optimizaci√≥n reactiva. <br></h3><br>  En la optimizaci√≥n reactiva, se pueden distinguir dos objetivos principales: <br><br>  1. <strong>Disminuci√≥n del tiempo de respuesta</strong> . <br><br>  Una acci√≥n, por ejemplo, recibir un informe, extracto, transacci√≥n, debe realizarse durante un tiempo programado.  Es necesario asegurarse de que el tiempo de recepci√≥n del servicio vuelva a los l√≠mites aceptables para el cliente.  Tal vez el servicio funciona un poco m√°s lento de lo habitual, pero para el cliente esto es aceptable.  Luego creemos que el incidente de rendimiento ha sido eliminado y comenzamos a trabajar en la causa ra√≠z. <br><br>  2. <strong>Un aumento en el n√∫mero de objetos procesados ‚Äã‚Äãpor unidad de tiempo durante el procesamiento por lotes</strong> . <br><br>  Cuando el procesamiento por lotes de transacciones est√° en progreso, es necesario reducir el tiempo de procesamiento de un objeto de un lote. <br><br>  <strong>Ventajas de un enfoque reactivo:</strong> <br><br>  ‚óè <em>Una variedad de herramientas y t√©cnicas</em> es la principal ventaja de un enfoque reactivo. <br><br>  Usando herramientas de monitoreo, podemos entender cu√°l es el problema directamente: no hay suficiente CPU, subprocesos, memoria o el sistema de disco se ha deslizado o los registros se est√°n procesando lentamente.  Existen muchas herramientas y t√©cnicas para estudiar el problema de rendimiento actual en la base de datos Oracle. <br><br>  ‚óè <em>El tiempo de respuesta deseado</em> es otra ventaja. <br><br>  En el proceso de dicho trabajo, llevamos la situaci√≥n a un tiempo de respuesta aceptable, es decir, no intentamos reducirla al valor m√≠nimo, pero alcanzamos un cierto valor y despu√©s de esta acci√≥n terminamos, porque creemos que hemos alcanzado l√≠mites aceptables. <br><br>  <strong>Contras del enfoque reactivo:</strong> <br><br><ul><li>  <em>Los incidentes de rendimiento permanecen</em> : este es el mayor inconveniente del enfoque reactivo, porque no siempre podemos llegar a la causa ra√≠z.  Ella podr√≠a quedarse en alg√∫n lugar alejado y acostarse en alg√∫n lugar m√°s profundo, a pesar del hecho de que logramos un rendimiento aceptable. </li></ul><br>  ¬øY c√≥mo lidiar con incidentes de rendimiento si a√∫n no han sucedido?  Tratemos de formular c√≥mo se puede llevar a cabo una optimizaci√≥n proactiva para evitar tales situaciones. <br><br><h2>  Optimizaci√≥n proactiva <br></h2><br>  Lo primero que encontramos es que no se sabe qu√© debe optimizarse.  "Haz eso, no s√© qu√©". <br><br><ul><li>  No hay un algoritmo cl√°sico. </li><li>  El problema a√∫n no ha surgido (desconocido), y uno solo puede adivinar d√≥nde podr√≠a estar. </li><li>  Necesitamos encontrar algunos puntos d√©biles potenciales en el sistema. </li><li>  Intente optimizar el rendimiento de la consulta en estos lugares. </li></ul><br><h3>  Los objetivos principales de la optimizaci√≥n proactiva <br></h3><br>  Las tareas principales de la optimizaci√≥n proactiva difieren de las tareas de optimizaci√≥n reactiva y son las siguientes: <br><br><ul><li>  deshacerse de los cuellos de botella en la base de datos; </li><li>  disminuci√≥n en el consumo de recursos de la base de datos. </li></ul><br>  El √∫ltimo momento es el m√°s fundamental.  En el caso de la optimizaci√≥n reactiva, no tenemos la tarea de reducir el consumo de recursos en su conjunto, sino solo la tarea de llevar el tiempo de respuesta de la funcionalidad a l√≠mites aceptables. <br><br><h3>  ¬øC√≥mo encontrar cuellos de botella en la base de datos? <br></h3><br>  Cuando comenzamos a pensar en este problema, surgen muchas subtareas inmediatamente.  Es necesario realizar: <br><br><ul><li>  Prueba de CPU </li><li>  prueba de carga en lecturas / registros; </li><li>  pruebas de estr√©s por el n√∫mero de sesiones activas; </li><li>  prueba de carga en ... etc. </li></ul><br>  Si intentamos simular estos problemas en un complejo de prueba, podemos encontrar el hecho de que el problema que surgi√≥ en el servidor de prueba no tiene nada que ver con el de combate.  Hay muchas razones para esto, comenzando por el hecho de que los servidores de prueba suelen ser m√°s d√©biles.  Es bueno si es posible hacer que el servidor de prueba sea una copia exacta del combate, pero esto no garantiza que la carga se reproduzca de la misma manera, porque necesita reproducir con precisi√≥n la actividad del usuario y muchos m√°s factores diferentes que afectan la carga final.  Si intentas simular esta situaci√≥n, entonces, en general, nadie garantiza que suceder√° exactamente lo mismo que suceder√° en el servidor de batalla. <br><br>  Si en un caso el problema surgi√≥ debido a la llegada de un nuevo registro, en el otro podr√≠a surgir porque el usuario lanz√≥ un gran informe haciendo una gran selecci√≥n, por lo que el espacio de tabla temporal se llen√≥ y Como resultado, el sistema comenz√≥ a disminuir.  Es decir, los motivos pueden ser diferentes y no siempre es posible predecirlos.  Por <strong>lo</strong> tanto, <strong>abandonamos los intentos de buscar cuellos de botella en los servidores de prueba</strong> casi desde el principio.  Solo confiamos en el servidor de combate y lo que estaba sucediendo en √©l. <br><br>  ¬øQu√© hacer en este caso?  Tratemos de entender qu√© recursos es m√°s probable que falten en primer lugar. <br><br><h3>  Disminuci√≥n del consumo de recursos de la base de datos <br></h3><br>  En funci√≥n de los complejos industriales que tenemos a nuestra disposici√≥n, la <strong>falta de recursos m√°s frecuente se observa en las lecturas de disco y las CPU</strong> .  Por lo tanto, en primer lugar, buscaremos debilidades precisamente en estas √°reas. <br><br>  La segunda pregunta importante: ¬øc√≥mo buscar algo? <br>  La pregunta es muy no trivial.  Utilizamos Oracle Enterprise Edition con la opci√≥n de Paquete de diagn√≥stico y para nosotros encontramos una herramienta de este tipo: <b>informes AWR</b> (en otras ediciones de Oracle puede usar <b>informes STATSPACK</b> ).  En PostgreSQL hay un an√°logo - pgstatspack, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_profile de</a> Andrey Zubkov.  El √∫ltimo producto, seg√∫n tengo entendido, apareci√≥ y comenz√≥ a desarrollarse solo el a√±o pasado.  Para MySQL, no pude encontrar herramientas similares, pero no soy un experto en MySQL. <br><br>  El enfoque en s√≠ no est√° vinculado a ning√∫n tipo particular de base de datos.  Si es posible obtener informaci√≥n sobre la carga del sistema de alg√∫n informe, entonces, utilizando la t√©cnica de la que hablar√© ahora, puede realizar un trabajo de optimizaci√≥n proactiva <strong>en cualquier base</strong> . <br><br><h3>  <strong>Optimizaci√≥n de las 5 operaciones principales</strong> <br></h3><br>  La tecnolog√≠a de optimizaci√≥n proactiva que hemos desarrollado y estamos utilizando en el Centro de pagos RNCO consta de cuatro etapas. <br><br>  <strong>Etapa 1. Recibimos el informe de AWR para el mayor per√≠odo posible.</strong> <br><br>  Se necesita el mayor tiempo posible para promediar la carga en diferentes d√≠as de la semana, ya que a veces es muy diferente.  Por ejemplo, los registros de la semana pasada llegan al RBS-Retail Bank el martes, comienzan a procesarse, y durante todo el d√≠a tenemos una carga que est√° por encima del promedio entre 2 y 3 veces.  En otros d√≠as, la carga es menor. <br><br>  Si sabe que el sistema tiene algunos detalles espec√≠ficos: en algunos d√≠as la carga es mayor, en algunos d√≠as, menos, entonces necesita recibir informes para estos per√≠odos por separado y trabajar con ellos por separado si queremos optimizar intervalos de tiempo espec√≠ficos .  Si necesita optimizar la situaci√≥n general del servidor, puede obtener un gran informe del mes y ver qu√© consumen realmente los recursos del servidor. <br><br>  A veces se presentan situaciones muy inesperadas.  Por ejemplo, en el caso de CFT Bank, una solicitud que verifica la cola del servidor de informes puede estar en el top 10.  Adem√°s, esta solicitud es oficial y no ejecuta ninguna l√≥gica de negocios, sino que solo verifica si hay un informe de ejecuci√≥n o no. <br><br>  <strong>Etapa 2. Buscamos secciones:</strong> <br><br><ul><li>  SQL ordenado por tiempo transcurrido: consultas SQL ordenadas por tiempo de ejecuci√≥n; </li><li>  SQL ordenado por tiempo de CPU - para uso de CPU; </li><li>  SQL ordenado por Gets - por lecturas l√≥gicas; </li><li>  SQL ordenado por lecturas - para lecturas f√≠sicas. </li></ul><br>  Las secciones restantes de SQL ordenadas por se estudian seg√∫n sea necesario. <br><br>  <strong>Etapa 3. Determinamos las operaciones principales y las solicitudes que dependen de ellas.</strong> <br><br>  El informe de AWR tiene secciones separadas donde, seg√∫n la versi√≥n de Oracle, se muestran 15 o m√°s consultas principales en cada una de estas secciones.  Pero estas consultas de Oracle en el informe de AWR muestran un desastre. <br>  Por ejemplo, hay una operaci√≥n principal, dentro de ella puede haber 3 consultas principales.  Oracle en el informe de AWR mostrar√° tanto la operaci√≥n principal como todas estas 3 consultas.  Por lo tanto, debe hacer un an√°lisis de esta lista y ver a qu√© operaciones se refieren las solicitudes espec√≠ficas, agruparlas. <br><br>  <strong>Etapa 4. Optimizamos las 5 principales operaciones.</strong> <br><br>  Despu√©s de dicha agrupaci√≥n, el resultado es una lista de operaciones de las que puede seleccionar las m√°s dif√≠ciles.  Estamos limitados a 5 operaciones (no solicitudes, es decir, operaciones).  Si el sistema es m√°s complejo, puede tomar m√°s. <br><br><h3>  Errores comunes de dise√±o de consultas <br></h3><br>  Durante la aplicaci√≥n de esta t√©cnica, hemos compilado una peque√±a lista de errores de dise√±o t√≠picos.  Algunos errores son tan simples que parece que no pueden serlo. <br><br>  ‚óè <strong>Falta de √≠ndice ‚Üí Escaneo completo</strong> <br>  Hay casos muy incidentales, por ejemplo, con la ausencia de un √≠ndice en el esquema de combate.  Tuvimos un ejemplo concreto en el que una consulta durante mucho tiempo funcion√≥ r√°pidamente sin un √≠ndice.  Pero hubo un escaneo completo, y a medida que el tama√±o de la tabla creci√≥ gradualmente, la consulta comenz√≥ a funcionar m√°s lentamente, y de un trimestre a otro tard√≥ un poco m√°s.  Al final, le prestamos atenci√≥n y result√≥ que el √≠ndice no est√° all√≠. <br><br>  ‚óè <strong>Amplia selecci√≥n ‚Üí Escaneo completo</strong> <br>  El segundo error com√∫n es una muestra de datos de gran tama√±o: el caso cl√°sico de una exploraci√≥n completa.  Todo el mundo sabe que un an√°lisis completo solo debe usarse cuando est√© realmente justificado.  A veces hay momentos en que se produce un an√°lisis completo en el que podr√≠a prescindir de √©l, por ejemplo, si transfiere las condiciones de filtrado del c√≥digo pl / sql a la consulta. <br><br>  ‚óè <strong>√çndice ineficaz ‚Üí ESCANEO DE RANGO DE √çNDICE largo</strong> <br>  Tal vez este sea incluso el error m√°s com√∫n, por lo que por alguna raz√≥n dicen muy poco: el llamado √≠ndice ineficiente (exploraci√≥n de √≠ndice larga, exploraci√≥n de RANGO DE √çNDICE larga).  Por ejemplo, tenemos una tabla para registros.  En la solicitud, tratamos de encontrar todos los registros de este agente y, en √∫ltima instancia, agregamos alg√∫n tipo de condici√≥n de filtrado, por ejemplo, durante un per√≠odo determinado, o con un n√∫mero espec√≠fico o un cliente espec√≠fico.  En tales situaciones, el √≠ndice generalmente se crea solo en el campo "agente" por razones de universalidad de uso.  El resultado es la siguiente imagen: en el primer a√±o de trabajo, por ejemplo, el agente ten√≠a 100 entradas en esta tabla, el pr√≥ximo a√±o ya 1,000, en otro a√±o puede haber 10,000 entradas.  Con el tiempo, estos registros se convierten en 100,000. Obviamente, la solicitud comienza a funcionar lentamente, porque en la solicitud debe agregar no solo el identificador del agente en s√≠, sino tambi√©n alg√∫n filtro adicional, en este caso por fecha.  De lo contrario, resultar√° que el tama√±o de la muestra aumentar√° de a√±o en a√±o, a medida que aumenta el n√∫mero de registros para este agente.  Este problema debe abordarse a nivel de √≠ndice.  Si hay demasiados datos, entonces ya deber√≠amos pensar en la direcci√≥n de la partici√≥n. <br><br>  ‚óè <strong>Ramas de c√≥digo de distribuci√≥n innecesarias</strong> <br>  Este tambi√©n es un caso curioso, pero, sin embargo, sucede.  Observamos las consultas principales, y vemos algunas consultas extra√±as all√≠.  Acudimos a los desarrolladores y les decimos: "Encontramos algunas solicitudes, resolvamos y veamos qu√© se puede hacer al respecto".  El desarrollador piensa, luego llega un momento y dice: ‚ÄúEsta rama de c√≥digo no deber√≠a estar en su sistema.  No utilizas esta funcionalidad ".  Luego, el desarrollador recomienda que active alguna configuraci√≥n especial para evitar esta secci√≥n del c√≥digo. <br><br><h3>  Estudios de caso <br></h3><br>  Ahora me gustar√≠a considerar dos ejemplos de nuestra pr√°ctica real.  Cuando tratamos las principales consultas, por supuesto, primero pensamos en el hecho de que deber√≠a haber algo mega pesado, no trivial, con operaciones complejas.  De hecho, este no es siempre el caso.  A veces hay casos en que las consultas muy simples caen en las operaciones principales. <br><br><h4>  Ejemplo 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  En este ejemplo, una consulta consta de solo dos tablas, y estas no son tablas pesadas, solo unos pocos millones de registros.  Parecer√≠a m√°s f√°cil?  Sin embargo, la solicitud lleg√≥ a la cima. <br><br>  Tratemos de descubrir qu√© le pasa. <br><br>  A continuaci√≥n se muestra una imagen de Enterprise Manager Cloud Control: datos sobre las estad√≠sticas de esta solicitud (Oracle tiene una herramienta de este tipo).  Se puede ver que hay una carga regular en esta solicitud (gr√°fico superior).  El n√∫mero 1 en el lateral indica que, en promedio, no se est√° ejecutando m√°s de una sesi√≥n.  El diagrama verde muestra que la <strong>solicitud usa solo la CPU</strong> , lo cual es doblemente interesante. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Tratemos de descubrir qu√© est√° pasando aqu√≠. <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Arriba hay una tabla con estad√≠sticas a pedido.  Casi 700 mil lanzamientos, esto no sorprender√° a nadie.  Pero el intervalo de tiempo desde el primer tiempo de carga el 15 de diciembre hasta el √∫ltimo tiempo de carga el 22 de diciembre (ver la imagen anterior) es de una semana.  Si cuenta el n√∫mero de inicios por segundo, resulta que la <strong>consulta se ejecuta en promedio cada segundo</strong> . <br><br>  Nosotros miramos m√°s all√°.  El tiempo de ejecuci√≥n de la consulta es de 0,93 segundos, es decir.  menos de un segundo, eso es genial.  Podemos alegrarnos: la solicitud no es pesada.  Sin embargo, lleg√≥ a la cima, lo que significa que consume muchos recursos.  ¬øD√≥nde consume muchos recursos? <br><br>  La tabla tiene una l√≠nea para lecturas l√≥gicas.  Vemos que para un lanzamiento necesita casi 8 mil bloques (generalmente 1 bloque es 8 KB).  Resulta que la solicitud, que funciona una vez por segundo, carga aproximadamente 64 MB de datos de la memoria.  Algo est√° mal aqu√≠, debemos entenderlo. <br><br>  Veamos el plan: hay un escaneo completo.  Bueno, sigamos adelante. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  En la tabla rnko_dep_reestr_in_oper, solo hay 5 millones de filas y su longitud promedio es de 150 bytes.  Pero result√≥ que no hay suficiente √≠ndice para el campo que se est√° conectando: ¬°la subconsulta est√° conectada a la solicitud a trav√©s del campo ean_rnko, para el que no hay √≠ndice! <br><br>  Adem√°s, incluso si aparece, de hecho, la situaci√≥n no ser√° muy buena.  Se producir√° esa exploraci√≥n de √≠ndice larga (exploraci√≥n de RANGO DE √çNDICE larga).  ean_rnko es el identificador interno del agente.  Se acumular√°n registros de agentes, y cada a√±o aumentar√° la cantidad de datos que seleccionar√° esta solicitud, y la solicitud se ralentizar√°. <br><br>  <strong>Soluci√≥n:</strong> cree un √≠ndice para los campos ean_rnko y date_reg, solicite a los desarrolladores que limiten la profundidad de escaneo por fecha en esta solicitud.  Entonces, al menos en cierta medida, puede garantizar que el rendimiento de la consulta se mantendr√° aproximadamente en los mismos l√≠mites, ya que el tama√±o de la muestra se limitar√° a un intervalo de tiempo fijo y no ser√° necesario leer toda la tabla.  Este es un punto muy importante, mira lo que pas√≥. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Despu√©s de la optimizaci√≥n, el tiempo de operaci√≥n se convirti√≥ en menos de una cent√©sima de segundo (fue 0.93), el n√∫mero de bloques se convirti√≥ en un promedio de 8.5 - 1000 veces menos que antes. <br><br><h4>  Ejemplo 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Comenc√© la historia diciendo que generalmente se espera algo complicado en la parte superior de la consulta.  Arriba hay un ejemplo de una consulta "compleja" que va a una tabla (!), Y tambi√©n entr√≥ en las consultas principales :) ¬°Hay un √≠ndice en el campo ID_PROCESSING! <br>  Hay 3 condiciones IS NULL en esta consulta y, como sabemos, dichas condiciones no est√°n indexadas (no puede usar el √≠ndice en este caso).  Adem√°s, solo hay dos condiciones del tipo de igualdad (por ID_PROCESSING y STATUS). <br><br>  Probablemente, el desarrollador que mirar√≠a esta consulta, en primer lugar, sugerir√≠a hacer un √≠ndice en ID_PROCESSING y STATUS.  Pero dada la cantidad de datos que se elegir√°n (habr√° muchos), esta soluci√≥n no funciona. <br><br>  Sin embargo, la solicitud consume muchos recursos, lo que significa que hay que hacer algo para que funcione m√°s r√°pido.  Intentemos descubrir las razones. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  Las estad√≠sticas anteriores son para 1 d√≠a, a partir del cual se puede ver que la solicitud se inicia cada 5 minutos.  El principal consumo de recursos es la CPU y la lectura del disco.  A continuaci√≥n, en el gr√°fico con estad√≠sticas del n√∫mero de inicios de consultas, se puede ver que todo est√° en orden, el n√∫mero de inicios casi no cambia con el tiempo, una situaci√≥n bastante estable. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  Y si mira m√°s all√°, puede ver que el tiempo de consulta a veces var√≠a bastante, varias veces, lo que ya es significativo. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Vamos a resolverlo a continuaci√≥n. <br><br>  Oracle Enterprise Manager tiene una utilidad de monitoreo de SQL.  Con esta utilidad puede ver en tiempo real el consumo de recursos a pedido. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Informe anterior para solicitud problem√°tica.  En primer lugar, deber√≠amos estar interesados ‚Äã‚Äãen el hecho de que el ESCANEO DE RANGO DE √çNDICE (l√≠nea inferior) en la columna Filas reales muestra 17 millones de l√≠neas.  Probablemente vale la pena considerarlo. <br><br>  Si observamos m√°s a fondo el plan de implementaci√≥n, resulta que despu√©s del siguiente elemento del plan, de estos 17 millones de l√≠neas, solo quedan 1705. La pregunta es, ¬øpor qu√© se eligieron 17 millones?  Alrededor del 0.01% permaneci√≥ en la muestra final, es decir <strong>, obviamente ineficiente, se realiz√≥ un trabajo innecesario</strong> .  Adem√°s, este trabajo se realiza cada 5 minutos.  ¬°Aqu√≠ est√° el problema!  Por lo tanto, esta solicitud lleg√≥ a las principales consultas. <br><br>  Intentemos resolver este problema no trivial.  El √≠ndice que se pide en primer lugar es ineficiente, por lo que debe encontrar algo complicado y vencer las condiciones IS NULL. <br><br><h4>  Nuevo √≠ndice <br></h4><br>  Consultamos con los desarrolladores, pensamos y llegamos a esta decisi√≥n: hicimos un √≠ndice funcional en el que hay una columna ID_PROCESSING, que ten√≠a la condici√≥n de igualdad en la solicitud, e incluimos todos los dem√°s campos como argumentos de esta funci√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Esta funci√≥n es de tipo determinista, es decir, en el mismo conjunto de par√°metros siempre da la misma respuesta.  Nos aseguramos de que esta funci√≥n siempre devolviera un valor, en este caso "U".  Cuando se cumplen todas estas condiciones, se emite "U", cuando no se cumple: NULL.  Tal √≠ndice funcional hace posible filtrar efectivamente los datos. <br><br>  La aplicaci√≥n de este √≠ndice condujo al siguiente resultado: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Aqu√≠, una columna es una instant√°nea, se realizan cada media hora de la base de datos.  Hemos logrado nuestro objetivo y este √≠ndice ha sido realmente efectivo.  Veamos las caracter√≠sticas cuantitativas: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Estad√≠sticas de solicitud promedio <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Antes</strong> <br><br></td><td width="110">  <strong>DESPU√âS</strong> <br><br></td></tr><tr><td width="174">  Tiempo transcurrido, seg. <br><br></td><td width="124">  143,21 <br><br></td><td width="110">  60,7 <br><br></td></tr><tr><td width="174">  Tiempo de CPU, seg. <br><br></td><td width="124">  33,23 <br><br></td><td width="110">  45,38 <br><br></td></tr><tr><td width="174">  Buffer Gets Block <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Bloque de lecturas de disco <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br>  El tiempo de operaci√≥n disminuy√≥ en 2.5 veces, y el consumo de recursos (Buffer Gets) - en aproximadamente 4. El n√∫mero de bloques de datos le√≠dos del disco disminuy√≥ significativamente. <br><br><h3>  Resultados de optimizaci√≥n proactiva <br></h3><br>  Hemos recibido: <br><br><ul><li>  reduciendo la carga en la base de datos; </li><li>  mejorando la estabilidad de la base de datos; </li><li>  Una reducci√≥n significativa en el n√∫mero de incidentes de rendimiento del software. </li></ul><br>  <strong>Los incidentes de rendimiento disminuyeron 10 veces</strong> .  Esta es una cantidad subjetiva, antes de que ocurrieran los incidentes en el complejo RBS-Retail Bank 1-2 veces al mes, pero ahora pr√°cticamente nos hemos olvidado de ellos. <br><br>  Esto plantea la pregunta: ¬øqu√© pasa con los incidentes de rendimiento del software?  ¬øNo tratamos con ellos directamente? <br><br>  De vuelta al √∫ltimo horario.  Si recuerdas, hubo un escaneo completo, fue necesario para almacenar una gran cantidad de bloques en la memoria.  Como la solicitud se ejecut√≥ regularmente, todos estos bloques se almacenaron en el cach√© de Oracle.  Resulta que si en este momento se produce una alta carga en la base de datos, por ejemplo, alguien comienza a usar la memoria de forma activa, necesitar√° un cach√© para almacenar bloques de datos.  Por lo tanto, parte de los datos de nuestra solicitud se eliminar√°n, lo que significa que tendremos que hacer lecturas f√≠sicas.  Si realiza lecturas f√≠sicas, el tiempo de ejecuci√≥n de la consulta aumentar√° enormemente de inmediato. <br><br>  La lectura l√≥gica funciona con la memoria, ocurre r√°pidamente y cualquier acceso al disco es lento (si observa la hora, milisegundos).  Si tiene suerte, y existen estos datos en la memoria cach√© del sistema operativo o en la memoria cach√© de la matriz, a√∫n ser√°n decenas de microsegundos.  Leer desde el cach√© de Oracle es mucho m√°s r√°pido. <br><br>  Cuando nos deshicimos de la exploraci√≥n completa, desapareci√≥ la necesidad de almacenar una cantidad tan grande de bloques en el cach√© (Buffer Cache).  Cuando hay escasez de estos recursos, la solicitud es m√°s o menos estable.  Ya no hay picos tan grandes que estaban con el √≠ndice anterior. <br><br>  <strong>Resumen de optimizaci√≥n proactiva:</strong> <br><br><ul><li>  La optimizaci√≥n de la consulta inicial debe llevarse a cabo en servidores de prueba, para ver c√≥mo funcionan las consultas y su l√≥gica de negocios, para no hacer nada superfluo.  Estas obras permanecen. </li><li>  Pero peri√≥dicamente, una vez cada pocos meses, tiene sentido eliminar informes del servidor a plena carga, hacer una b√∫squeda de las principales consultas y operaciones en la base de datos y optimizarlas. </li></ul><br>  <strong>Existen muchas herramientas para obtener estad√≠sticas en una base de datos Oracle:</strong> <br><br><ul><li>  Informe de AWR (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (Detalles de SQL); </li><li>  Informe activo de detalles de SQL (DBMS_PERF.report_sql); </li><li>  Monitoreo SQL (pesta√±a en EMCC); </li><li>  Informe de supervisi√≥n de SQL (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Algunas de estas herramientas funcionan en la consola, es decir, no est√°n vinculadas al Enterprise Manager. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplos de herramientas de Oracle para recopilar estad√≠sticas</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  El gr√°fico superior muestra cu√°ntas sesiones funcionan con esta solicitud. </li><li>  El bloque izquierdo muestra desde d√≥nde se inicia esta solicitud, en qu√© m√≥dulos se encuentra. </li><li>  Abajo a la izquierda: informaci√≥n sobre el uso del grupo compartido. </li><li>  A la derecha, el diagrama muestra los eventos de espera que est√°n en el sistema.  En este caso, es solo la CPU. </li><li>  Abajo a la derecha, lo m√°s interesante, una placa con caracter√≠sticas de calidad que son m√°s importantes al analizar problemas de rendimiento. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring muestra c√≥mo se ve todo en tiempo real (donde el engranaje verde gira, la consulta est√° funcionando ahora). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Arriba est√° el contenido interno del informe de supervisi√≥n de SQL.  Muestra en tiempo real qu√© l√≠nea de consulta ejecuta y cu√°ntas l√≠neas lee (columna Filas reales).  En este caso, INDEX RANGE SCAN ya ha contado 5 millones. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  La herramienta de texto Informe de supervisi√≥n de SQL, en la que hay informaci√≥n (no toda). <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonificaci√≥n: los</strong> especialistas del "Centro de pagos" de RNCO y CFT estaban bien preparados para la conferencia en Novosibirsk, hicieron algunos informes √∫tiles y tambi√©n organizaron una verdadera radio de salida.  Durante dos d√≠as, expertos, oradores y organizadores lograron visitar la radio CFT.  Puede regresar al verano siberiano incluyendo entradas, aqu√≠ est√°n los enlaces a los bloques: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes: pros y contras</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ciencia de datos y aprendizaje autom√°tico</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOps</a> . <br><br><blockquote>  En HighLoad ++ en Mosc√∫, que ya es el 8 y 9 de noviembre, habr√° cosas a√∫n m√°s interesantes.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa</a> incluye informes sobre todos los aspectos del trabajo en proyectos altamente cargados, clases magistrales, reuniones y eventos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">socios</a> que compartir√°n consejos de expertos y encontrar√°n algo para sorprender.  Aseg√∫rese de escribir sobre lo m√°s interesante y notif√≠quelo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n</a> , ¬°con√©ctese! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428491/">https://habr.com/ru/post/es428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428477/index.html">Para quienes eligen un firewall</a></li>
<li><a href="../es428481/index.html">Contratos digitales: una gu√≠a r√°pida para NO abogados</a></li>
<li><a href="../es428485/index.html">La mayor√≠a de las personas molestas son publicidad irrelevante y el uso de gadgets en p√∫blico.</a></li>
<li><a href="../es428487/index.html">Por qu√© Ruby on Rails es bueno y c√≥mo acelera el desarrollo</a></li>
<li><a href="../es428489/index.html">Delgadez y grosor de los iconos. Sketch Pro, funciones de renderizado y un juego con grosor de l√≠nea</a></li>
<li><a href="../es428493/index.html">Git subrepo</a></li>
<li><a href="../es428495/index.html">Como hice un simulador de f√∫tbol durante 13 a√±os</a></li>
<li><a href="../es428497/index.html">Atenuador inal√°mbrico personalizado Noolite SUF-1-300</a></li>
<li><a href="../es428499/index.html">Espeluznantes gigantes azules pueden revelar los secretos de la evoluci√≥n de las estrellas</a></li>
<li><a href="../es428501/index.html">DartUP: la primera conferencia en ruso sobre Dart y Flutter el 1 de diciembre en San Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>