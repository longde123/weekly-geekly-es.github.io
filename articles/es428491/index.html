<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💀 🏹 👰🏾 Optimización proactiva del rendimiento de la base de datos Oracle 🕡 🔮 🤽🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lo primero que encontramos cuando hablamos de optimización proactiva es que no se sabe qué necesita ser optimizado. "Haz eso, no sé qué". 



- No hay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimización proactiva del rendimiento de la base de datos Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  Lo primero que encontramos cuando hablamos de optimización proactiva es que no se sabe qué necesita ser optimizado.  "Haz eso, no sé qué". <br><br><ul><li>  No hay un algoritmo clásico. </li><li>  El problema aún no ha surgido (desconocido), y uno solo puede adivinar dónde podría estar. </li><li>  Necesitamos encontrar algunos puntos débiles potenciales en el sistema. </li><li>  Intente optimizar el rendimiento de la consulta en estos lugares. </li></ul><br><h3>  Los objetivos principales de la optimización proactiva <br></h3><br>  Las tareas principales de la optimización proactiva difieren de las tareas de optimización reactiva y son las siguientes: <br><br><ul><li>  deshacerse de los cuellos de botella en la base de datos; </li><li>  disminución en el consumo de recursos de la base de datos. </li></ul><br>  El último momento es el más fundamental.  En el caso de la optimización reactiva, no tenemos la tarea de reducir el consumo de recursos en su conjunto, sino solo la tarea de llevar el tiempo de respuesta de la funcionalidad a límites aceptables. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Si trabaja con servidores de batalla, tiene una buena idea de lo que significan los incidentes de rendimiento.  Debe dejar todo y resolver rápidamente el problema.  RNKO Payment Center LLC trabaja con muchos agentes y es muy importante que tengan el menor número de problemas posible.  Alexander Makarov en HighLoad ++ Siberia contó lo que se hizo para reducir significativamente el número de incidentes de rendimiento.  La optimización proactiva vino al rescate.  Y por qué y cómo se produce en un servidor de combate, lea a continuación. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>Acerca del orador:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">AL_IG_Makarov</a> ), Administrador principal del Centro de pagos RNCO de Oracle Database, LLC.  A pesar de la posición, hay muy poca administración como tal, las tareas principales están relacionadas con el mantenimiento del complejo y su desarrollo, en particular, para resolver problemas de rendimiento. <br><br><h1>  ¿Es la optimización en una base de datos de combate proactiva? <br></h1><br>  Primero, trataremos los términos a los que este informe se refiere como "optimización proactiva del rendimiento".  A veces puede cumplir con el punto de vista de que la optimización proactiva es cuando el análisis de las áreas problemáticas se lleva a cabo antes de que se inicie la aplicación.  Por ejemplo, descubrimos que algunas consultas no funcionan de manera óptima, ya que no hay suficiente índice o la consulta utiliza un algoritmo ineficiente, y este trabajo se realiza en servidores de prueba. <br><br>  Sin embargo, nosotros en RNCO hicimos este proyecto <strong>en servidores de batalla</strong> .  Muchas veces escuché: “¿Cómo es eso?  Lo haces en un servidor de combate, ¡eso significa que no es una optimización proactiva del rendimiento!  Aquí necesitamos recordar el enfoque que se cultiva en ITIL.  Desde el punto de vista de ITIL, tenemos: <br><br><ul><li>  los incidentes de rendimiento son lo que ya sucedió; </li><li>  Las medidas que tomamos para evitar que ocurran incidentes de rendimiento. </li></ul><br>  En este sentido, nuestras acciones son proactivas.  A pesar del hecho de que estamos resolviendo el problema en un servidor de combate, el problema en sí aún no ha surgido: el incidente no ocurrió, no corrimos y no intentamos resolver este problema en poco tiempo. <br><br>  Entonces, en este informe, la proactividad se entiende como <strong>proactividad en el sentido de ITIL</strong> , resolvemos el problema antes de que ocurra un incidente de rendimiento. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Punto de referencia <br></h1><br>  El "Centro de pagos" de RNKO sirve 2 sistemas grandes: <br><br><ul><li>  RBS-Retail Bank; </li><li>  CFT Bank. </li></ul><br>  La naturaleza de la carga en estos sistemas es mixta (DSS + OLTP): hay algo que funciona muy rápidamente, hay informes, hay cargas medias. <br><br>  Nos enfrentamos al hecho de que no muy a menudo, pero con cierta frecuencia, se produjeron incidentes de rendimiento.  Quienes trabajan con servidores de batalla imaginan lo que es.  Esto significa que debe abandonar todo y resolver rápidamente el problema, porque en este momento el cliente no puede recibir el servicio, algo no funciona o funciona muy lentamente. <br><br>  Dado que muchos agentes y clientes están vinculados a nuestra organización, esto es muy importante para nosotros.  Si no podemos resolver rápidamente los incidentes de rendimiento, nuestros clientes sufrirán de una forma u otra.  Por ejemplo, no podrán reponer una tarjeta o hacer una transferencia.  Por lo tanto, nos preguntamos qué se podría hacer para eliminar incluso estos incidentes de rendimiento poco frecuentes.  Para trabajar en un modo cuando necesita soltar todo y resolver un problema, esto no es del todo correcto.  Usamos sprints y elaboramos un plan de trabajo de sprint.  La presencia de incidentes de rendimiento también es una desviación del plan de trabajo. <br><br>  ¡Algo debe hacerse con esto! <br><br><h1>  Enfoques de optimización <br></h1><br>  Pensamos y llegamos a comprender la tecnología de optimización proactiva.  Pero antes de hablar sobre la optimización proactiva, debo decir algunas palabras sobre la optimización reactiva clásica. <br><br><h2>  Optimización reactiva <br></h2><br>  El escenario es simple, hay un servidor de combate en el que sucedió algo: lanzaron un informe, los clientes reciben declaraciones, en este momento hay actividad continua en la base de datos, y de repente alguien decidió actualizar algún tipo de directorio voluminoso.  El sistema comienza a ralentizarse.  En este momento, el cliente llega y dice: "No puedo hacer esto o aquello". Necesitamos encontrar una razón por la que no pueda hacer esto. <br><br>  <strong>Algoritmo de acción clásico:</strong> <br><br><ol><li>  Reproduce el problema. </li><li>  Localice el lugar del problema. </li><li>  Optimizar el lugar del problema. </li></ol><br>  Dentro del marco del enfoque reactivo, la tarea principal no es tanto encontrar la causa raíz en sí misma y eliminarla, sino hacer que el sistema funcione normalmente.  La eliminación de la causa raíz puede tratarse más adelante.  Lo principal es restaurar rápidamente el servidor para que el cliente pueda recibir el servicio. <br><br><h3>  Los principales objetivos de la optimización reactiva. <br></h3><br>  En la optimización reactiva, se pueden distinguir dos objetivos principales: <br><br>  1. <strong>Disminución del tiempo de respuesta</strong> . <br><br>  Una acción, por ejemplo, recibir un informe, extracto, transacción, debe realizarse durante un tiempo programado.  Es necesario asegurarse de que el tiempo de recepción del servicio vuelva a los límites aceptables para el cliente.  Tal vez el servicio funciona un poco más lento de lo habitual, pero para el cliente esto es aceptable.  Luego creemos que el incidente de rendimiento ha sido eliminado y comenzamos a trabajar en la causa raíz. <br><br>  2. <strong>Un aumento en el número de objetos procesados ​​por unidad de tiempo durante el procesamiento por lotes</strong> . <br><br>  Cuando el procesamiento por lotes de transacciones está en progreso, es necesario reducir el tiempo de procesamiento de un objeto de un lote. <br><br>  <strong>Ventajas de un enfoque reactivo:</strong> <br><br>  ● <em>Una variedad de herramientas y técnicas</em> es la principal ventaja de un enfoque reactivo. <br><br>  Usando herramientas de monitoreo, podemos entender cuál es el problema directamente: no hay suficiente CPU, subprocesos, memoria o el sistema de disco se ha deslizado o los registros se están procesando lentamente.  Existen muchas herramientas y técnicas para estudiar el problema de rendimiento actual en la base de datos Oracle. <br><br>  ● <em>El tiempo de respuesta deseado</em> es otra ventaja. <br><br>  En el proceso de dicho trabajo, llevamos la situación a un tiempo de respuesta aceptable, es decir, no intentamos reducirla al valor mínimo, pero alcanzamos un cierto valor y después de esta acción terminamos, porque creemos que hemos alcanzado límites aceptables. <br><br>  <strong>Contras del enfoque reactivo:</strong> <br><br><ul><li>  <em>Los incidentes de rendimiento permanecen</em> : este es el mayor inconveniente del enfoque reactivo, porque no siempre podemos llegar a la causa raíz.  Ella podría quedarse en algún lugar alejado y acostarse en algún lugar más profundo, a pesar del hecho de que logramos un rendimiento aceptable. </li></ul><br>  ¿Y cómo lidiar con incidentes de rendimiento si aún no han sucedido?  Tratemos de formular cómo se puede llevar a cabo una optimización proactiva para evitar tales situaciones. <br><br><h2>  Optimización proactiva <br></h2><br>  Lo primero que encontramos es que no se sabe qué debe optimizarse.  "Haz eso, no sé qué". <br><br><ul><li>  No hay un algoritmo clásico. </li><li>  El problema aún no ha surgido (desconocido), y uno solo puede adivinar dónde podría estar. </li><li>  Necesitamos encontrar algunos puntos débiles potenciales en el sistema. </li><li>  Intente optimizar el rendimiento de la consulta en estos lugares. </li></ul><br><h3>  Los objetivos principales de la optimización proactiva <br></h3><br>  Las tareas principales de la optimización proactiva difieren de las tareas de optimización reactiva y son las siguientes: <br><br><ul><li>  deshacerse de los cuellos de botella en la base de datos; </li><li>  disminución en el consumo de recursos de la base de datos. </li></ul><br>  El último momento es el más fundamental.  En el caso de la optimización reactiva, no tenemos la tarea de reducir el consumo de recursos en su conjunto, sino solo la tarea de llevar el tiempo de respuesta de la funcionalidad a límites aceptables. <br><br><h3>  ¿Cómo encontrar cuellos de botella en la base de datos? <br></h3><br>  Cuando comenzamos a pensar en este problema, surgen muchas subtareas inmediatamente.  Es necesario realizar: <br><br><ul><li>  Prueba de CPU </li><li>  prueba de carga en lecturas / registros; </li><li>  pruebas de estrés por el número de sesiones activas; </li><li>  prueba de carga en ... etc. </li></ul><br>  Si intentamos simular estos problemas en un complejo de prueba, podemos encontrar el hecho de que el problema que surgió en el servidor de prueba no tiene nada que ver con el de combate.  Hay muchas razones para esto, comenzando por el hecho de que los servidores de prueba suelen ser más débiles.  Es bueno si es posible hacer que el servidor de prueba sea una copia exacta del combate, pero esto no garantiza que la carga se reproduzca de la misma manera, porque necesita reproducir con precisión la actividad del usuario y muchos más factores diferentes que afectan la carga final.  Si intentas simular esta situación, entonces, en general, nadie garantiza que sucederá exactamente lo mismo que sucederá en el servidor de batalla. <br><br>  Si en un caso el problema surgió debido a la llegada de un nuevo registro, en el otro podría surgir porque el usuario lanzó un gran informe haciendo una gran selección, por lo que el espacio de tabla temporal se llenó y Como resultado, el sistema comenzó a disminuir.  Es decir, los motivos pueden ser diferentes y no siempre es posible predecirlos.  Por <strong>lo</strong> tanto, <strong>abandonamos los intentos de buscar cuellos de botella en los servidores de prueba</strong> casi desde el principio.  Solo confiamos en el servidor de combate y lo que estaba sucediendo en él. <br><br>  ¿Qué hacer en este caso?  Tratemos de entender qué recursos es más probable que falten en primer lugar. <br><br><h3>  Disminución del consumo de recursos de la base de datos <br></h3><br>  En función de los complejos industriales que tenemos a nuestra disposición, la <strong>falta de recursos más frecuente se observa en las lecturas de disco y las CPU</strong> .  Por lo tanto, en primer lugar, buscaremos debilidades precisamente en estas áreas. <br><br>  La segunda pregunta importante: ¿cómo buscar algo? <br>  La pregunta es muy no trivial.  Utilizamos Oracle Enterprise Edition con la opción de Paquete de diagnóstico y para nosotros encontramos una herramienta de este tipo: <b>informes AWR</b> (en otras ediciones de Oracle puede usar <b>informes STATSPACK</b> ).  En PostgreSQL hay un análogo - pgstatspack, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_profile de</a> Andrey Zubkov.  El último producto, según tengo entendido, apareció y comenzó a desarrollarse solo el año pasado.  Para MySQL, no pude encontrar herramientas similares, pero no soy un experto en MySQL. <br><br>  El enfoque en sí no está vinculado a ningún tipo particular de base de datos.  Si es posible obtener información sobre la carga del sistema de algún informe, entonces, utilizando la técnica de la que hablaré ahora, puede realizar un trabajo de optimización proactiva <strong>en cualquier base</strong> . <br><br><h3>  <strong>Optimización de las 5 operaciones principales</strong> <br></h3><br>  La tecnología de optimización proactiva que hemos desarrollado y estamos utilizando en el Centro de pagos RNCO consta de cuatro etapas. <br><br>  <strong>Etapa 1. Recibimos el informe de AWR para el mayor período posible.</strong> <br><br>  Se necesita el mayor tiempo posible para promediar la carga en diferentes días de la semana, ya que a veces es muy diferente.  Por ejemplo, los registros de la semana pasada llegan al RBS-Retail Bank el martes, comienzan a procesarse, y durante todo el día tenemos una carga que está por encima del promedio entre 2 y 3 veces.  En otros días, la carga es menor. <br><br>  Si sabe que el sistema tiene algunos detalles específicos: en algunos días la carga es mayor, en algunos días, menos, entonces necesita recibir informes para estos períodos por separado y trabajar con ellos por separado si queremos optimizar intervalos de tiempo específicos .  Si necesita optimizar la situación general del servidor, puede obtener un gran informe del mes y ver qué consumen realmente los recursos del servidor. <br><br>  A veces se presentan situaciones muy inesperadas.  Por ejemplo, en el caso de CFT Bank, una solicitud que verifica la cola del servidor de informes puede estar en el top 10.  Además, esta solicitud es oficial y no ejecuta ninguna lógica de negocios, sino que solo verifica si hay un informe de ejecución o no. <br><br>  <strong>Etapa 2. Buscamos secciones:</strong> <br><br><ul><li>  SQL ordenado por tiempo transcurrido: consultas SQL ordenadas por tiempo de ejecución; </li><li>  SQL ordenado por tiempo de CPU - para uso de CPU; </li><li>  SQL ordenado por Gets - por lecturas lógicas; </li><li>  SQL ordenado por lecturas - para lecturas físicas. </li></ul><br>  Las secciones restantes de SQL ordenadas por se estudian según sea necesario. <br><br>  <strong>Etapa 3. Determinamos las operaciones principales y las solicitudes que dependen de ellas.</strong> <br><br>  El informe de AWR tiene secciones separadas donde, según la versión de Oracle, se muestran 15 o más consultas principales en cada una de estas secciones.  Pero estas consultas de Oracle en el informe de AWR muestran un desastre. <br>  Por ejemplo, hay una operación principal, dentro de ella puede haber 3 consultas principales.  Oracle en el informe de AWR mostrará tanto la operación principal como todas estas 3 consultas.  Por lo tanto, debe hacer un análisis de esta lista y ver a qué operaciones se refieren las solicitudes específicas, agruparlas. <br><br>  <strong>Etapa 4. Optimizamos las 5 principales operaciones.</strong> <br><br>  Después de dicha agrupación, el resultado es una lista de operaciones de las que puede seleccionar las más difíciles.  Estamos limitados a 5 operaciones (no solicitudes, es decir, operaciones).  Si el sistema es más complejo, puede tomar más. <br><br><h3>  Errores comunes de diseño de consultas <br></h3><br>  Durante la aplicación de esta técnica, hemos compilado una pequeña lista de errores de diseño típicos.  Algunos errores son tan simples que parece que no pueden serlo. <br><br>  ● <strong>Falta de índice → Escaneo completo</strong> <br>  Hay casos muy incidentales, por ejemplo, con la ausencia de un índice en el esquema de combate.  Tuvimos un ejemplo concreto en el que una consulta durante mucho tiempo funcionó rápidamente sin un índice.  Pero hubo un escaneo completo, y a medida que el tamaño de la tabla creció gradualmente, la consulta comenzó a funcionar más lentamente, y de un trimestre a otro tardó un poco más.  Al final, le prestamos atención y resultó que el índice no está allí. <br><br>  ● <strong>Amplia selección → Escaneo completo</strong> <br>  El segundo error común es una muestra de datos de gran tamaño: el caso clásico de una exploración completa.  Todo el mundo sabe que un análisis completo solo debe usarse cuando esté realmente justificado.  A veces hay momentos en que se produce un análisis completo en el que podría prescindir de él, por ejemplo, si transfiere las condiciones de filtrado del código pl / sql a la consulta. <br><br>  ● <strong>Índice ineficaz → ESCANEO DE RANGO DE ÍNDICE largo</strong> <br>  Tal vez este sea incluso el error más común, por lo que por alguna razón dicen muy poco: el llamado índice ineficiente (exploración de índice larga, exploración de RANGO DE ÍNDICE larga).  Por ejemplo, tenemos una tabla para registros.  En la solicitud, tratamos de encontrar todos los registros de este agente y, en última instancia, agregamos algún tipo de condición de filtrado, por ejemplo, durante un período determinado, o con un número específico o un cliente específico.  En tales situaciones, el índice generalmente se crea solo en el campo "agente" por razones de universalidad de uso.  El resultado es la siguiente imagen: en el primer año de trabajo, por ejemplo, el agente tenía 100 entradas en esta tabla, el próximo año ya 1,000, en otro año puede haber 10,000 entradas.  Con el tiempo, estos registros se convierten en 100,000. Obviamente, la solicitud comienza a funcionar lentamente, porque en la solicitud debe agregar no solo el identificador del agente en sí, sino también algún filtro adicional, en este caso por fecha.  De lo contrario, resultará que el tamaño de la muestra aumentará de año en año, a medida que aumenta el número de registros para este agente.  Este problema debe abordarse a nivel de índice.  Si hay demasiados datos, entonces ya deberíamos pensar en la dirección de la partición. <br><br>  ● <strong>Ramas de código de distribución innecesarias</strong> <br>  Este también es un caso curioso, pero, sin embargo, sucede.  Observamos las consultas principales, y vemos algunas consultas extrañas allí.  Acudimos a los desarrolladores y les decimos: "Encontramos algunas solicitudes, resolvamos y veamos qué se puede hacer al respecto".  El desarrollador piensa, luego llega un momento y dice: “Esta rama de código no debería estar en su sistema.  No utilizas esta funcionalidad ".  Luego, el desarrollador recomienda que active alguna configuración especial para evitar esta sección del código. <br><br><h3>  Estudios de caso <br></h3><br>  Ahora me gustaría considerar dos ejemplos de nuestra práctica real.  Cuando tratamos las principales consultas, por supuesto, primero pensamos en el hecho de que debería haber algo mega pesado, no trivial, con operaciones complejas.  De hecho, este no es siempre el caso.  A veces hay casos en que las consultas muy simples caen en las operaciones principales. <br><br><h4>  Ejemplo 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  En este ejemplo, una consulta consta de solo dos tablas, y estas no son tablas pesadas, solo unos pocos millones de registros.  Parecería más fácil?  Sin embargo, la solicitud llegó a la cima. <br><br>  Tratemos de descubrir qué le pasa. <br><br>  A continuación se muestra una imagen de Enterprise Manager Cloud Control: datos sobre las estadísticas de esta solicitud (Oracle tiene una herramienta de este tipo).  Se puede ver que hay una carga regular en esta solicitud (gráfico superior).  El número 1 en el lateral indica que, en promedio, no se está ejecutando más de una sesión.  El diagrama verde muestra que la <strong>solicitud usa solo la CPU</strong> , lo cual es doblemente interesante. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Tratemos de descubrir qué está pasando aquí. <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Arriba hay una tabla con estadísticas a pedido.  Casi 700 mil lanzamientos, esto no sorprenderá a nadie.  Pero el intervalo de tiempo desde el primer tiempo de carga el 15 de diciembre hasta el último tiempo de carga el 22 de diciembre (ver la imagen anterior) es de una semana.  Si cuenta el número de inicios por segundo, resulta que la <strong>consulta se ejecuta en promedio cada segundo</strong> . <br><br>  Nosotros miramos más allá.  El tiempo de ejecución de la consulta es de 0,93 segundos, es decir.  menos de un segundo, eso es genial.  Podemos alegrarnos: la solicitud no es pesada.  Sin embargo, llegó a la cima, lo que significa que consume muchos recursos.  ¿Dónde consume muchos recursos? <br><br>  La tabla tiene una línea para lecturas lógicas.  Vemos que para un lanzamiento necesita casi 8 mil bloques (generalmente 1 bloque es 8 KB).  Resulta que la solicitud, que funciona una vez por segundo, carga aproximadamente 64 MB de datos de la memoria.  Algo está mal aquí, debemos entenderlo. <br><br>  Veamos el plan: hay un escaneo completo.  Bueno, sigamos adelante. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  En la tabla rnko_dep_reestr_in_oper, solo hay 5 millones de filas y su longitud promedio es de 150 bytes.  Pero resultó que no hay suficiente índice para el campo que se está conectando: ¡la subconsulta está conectada a la solicitud a través del campo ean_rnko, para el que no hay índice! <br><br>  Además, incluso si aparece, de hecho, la situación no será muy buena.  Se producirá esa exploración de índice larga (exploración de RANGO DE ÍNDICE larga).  ean_rnko es el identificador interno del agente.  Se acumularán registros de agentes, y cada año aumentará la cantidad de datos que seleccionará esta solicitud, y la solicitud se ralentizará. <br><br>  <strong>Solución:</strong> cree un índice para los campos ean_rnko y date_reg, solicite a los desarrolladores que limiten la profundidad de escaneo por fecha en esta solicitud.  Entonces, al menos en cierta medida, puede garantizar que el rendimiento de la consulta se mantendrá aproximadamente en los mismos límites, ya que el tamaño de la muestra se limitará a un intervalo de tiempo fijo y no será necesario leer toda la tabla.  Este es un punto muy importante, mira lo que pasó. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Después de la optimización, el tiempo de operación se convirtió en menos de una centésima de segundo (fue 0.93), el número de bloques se convirtió en un promedio de 8.5 - 1000 veces menos que antes. <br><br><h4>  Ejemplo 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Comencé la historia diciendo que generalmente se espera algo complicado en la parte superior de la consulta.  Arriba hay un ejemplo de una consulta "compleja" que va a una tabla (!), Y también entró en las consultas principales :) ¡Hay un índice en el campo ID_PROCESSING! <br>  Hay 3 condiciones IS NULL en esta consulta y, como sabemos, dichas condiciones no están indexadas (no puede usar el índice en este caso).  Además, solo hay dos condiciones del tipo de igualdad (por ID_PROCESSING y STATUS). <br><br>  Probablemente, el desarrollador que miraría esta consulta, en primer lugar, sugeriría hacer un índice en ID_PROCESSING y STATUS.  Pero dada la cantidad de datos que se elegirán (habrá muchos), esta solución no funciona. <br><br>  Sin embargo, la solicitud consume muchos recursos, lo que significa que hay que hacer algo para que funcione más rápido.  Intentemos descubrir las razones. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  Las estadísticas anteriores son para 1 día, a partir del cual se puede ver que la solicitud se inicia cada 5 minutos.  El principal consumo de recursos es la CPU y la lectura del disco.  A continuación, en el gráfico con estadísticas del número de inicios de consultas, se puede ver que todo está en orden, el número de inicios casi no cambia con el tiempo, una situación bastante estable. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  Y si mira más allá, puede ver que el tiempo de consulta a veces varía bastante, varias veces, lo que ya es significativo. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Vamos a resolverlo a continuación. <br><br>  Oracle Enterprise Manager tiene una utilidad de monitoreo de SQL.  Con esta utilidad puede ver en tiempo real el consumo de recursos a pedido. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Informe anterior para solicitud problemática.  En primer lugar, deberíamos estar interesados ​​en el hecho de que el ESCANEO DE RANGO DE ÍNDICE (línea inferior) en la columna Filas reales muestra 17 millones de líneas.  Probablemente vale la pena considerarlo. <br><br>  Si observamos más a fondo el plan de implementación, resulta que después del siguiente elemento del plan, de estos 17 millones de líneas, solo quedan 1705. La pregunta es, ¿por qué se eligieron 17 millones?  Alrededor del 0.01% permaneció en la muestra final, es decir <strong>, obviamente ineficiente, se realizó un trabajo innecesario</strong> .  Además, este trabajo se realiza cada 5 minutos.  ¡Aquí está el problema!  Por lo tanto, esta solicitud llegó a las principales consultas. <br><br>  Intentemos resolver este problema no trivial.  El índice que se pide en primer lugar es ineficiente, por lo que debe encontrar algo complicado y vencer las condiciones IS NULL. <br><br><h4>  Nuevo índice <br></h4><br>  Consultamos con los desarrolladores, pensamos y llegamos a esta decisión: hicimos un índice funcional en el que hay una columna ID_PROCESSING, que tenía la condición de igualdad en la solicitud, e incluimos todos los demás campos como argumentos de esta función: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Esta función es de tipo determinista, es decir, en el mismo conjunto de parámetros siempre da la misma respuesta.  Nos aseguramos de que esta función siempre devolviera un valor, en este caso "U".  Cuando se cumplen todas estas condiciones, se emite "U", cuando no se cumple: NULL.  Tal índice funcional hace posible filtrar efectivamente los datos. <br><br>  La aplicación de este índice condujo al siguiente resultado: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Aquí, una columna es una instantánea, se realizan cada media hora de la base de datos.  Hemos logrado nuestro objetivo y este índice ha sido realmente efectivo.  Veamos las características cuantitativas: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Estadísticas de solicitud promedio <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Antes</strong> <br><br></td><td width="110">  <strong>DESPUÉS</strong> <br><br></td></tr><tr><td width="174">  Tiempo transcurrido, seg. <br><br></td><td width="124">  143,21 <br><br></td><td width="110">  60,7 <br><br></td></tr><tr><td width="174">  Tiempo de CPU, seg. <br><br></td><td width="124">  33,23 <br><br></td><td width="110">  45,38 <br><br></td></tr><tr><td width="174">  Buffer Gets Block <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Bloque de lecturas de disco <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br>  El tiempo de operación disminuyó en 2.5 veces, y el consumo de recursos (Buffer Gets) - en aproximadamente 4. El número de bloques de datos leídos del disco disminuyó significativamente. <br><br><h3>  Resultados de optimización proactiva <br></h3><br>  Hemos recibido: <br><br><ul><li>  reduciendo la carga en la base de datos; </li><li>  mejorando la estabilidad de la base de datos; </li><li>  Una reducción significativa en el número de incidentes de rendimiento del software. </li></ul><br>  <strong>Los incidentes de rendimiento disminuyeron 10 veces</strong> .  Esta es una cantidad subjetiva, antes de que ocurrieran los incidentes en el complejo RBS-Retail Bank 1-2 veces al mes, pero ahora prácticamente nos hemos olvidado de ellos. <br><br>  Esto plantea la pregunta: ¿qué pasa con los incidentes de rendimiento del software?  ¿No tratamos con ellos directamente? <br><br>  De vuelta al último horario.  Si recuerdas, hubo un escaneo completo, fue necesario para almacenar una gran cantidad de bloques en la memoria.  Como la solicitud se ejecutó regularmente, todos estos bloques se almacenaron en el caché de Oracle.  Resulta que si en este momento se produce una alta carga en la base de datos, por ejemplo, alguien comienza a usar la memoria de forma activa, necesitará un caché para almacenar bloques de datos.  Por lo tanto, parte de los datos de nuestra solicitud se eliminarán, lo que significa que tendremos que hacer lecturas físicas.  Si realiza lecturas físicas, el tiempo de ejecución de la consulta aumentará enormemente de inmediato. <br><br>  La lectura lógica funciona con la memoria, ocurre rápidamente y cualquier acceso al disco es lento (si observa la hora, milisegundos).  Si tiene suerte, y existen estos datos en la memoria caché del sistema operativo o en la memoria caché de la matriz, aún serán decenas de microsegundos.  Leer desde el caché de Oracle es mucho más rápido. <br><br>  Cuando nos deshicimos de la exploración completa, desapareció la necesidad de almacenar una cantidad tan grande de bloques en el caché (Buffer Cache).  Cuando hay escasez de estos recursos, la solicitud es más o menos estable.  Ya no hay picos tan grandes que estaban con el índice anterior. <br><br>  <strong>Resumen de optimización proactiva:</strong> <br><br><ul><li>  La optimización de la consulta inicial debe llevarse a cabo en servidores de prueba, para ver cómo funcionan las consultas y su lógica de negocios, para no hacer nada superfluo.  Estas obras permanecen. </li><li>  Pero periódicamente, una vez cada pocos meses, tiene sentido eliminar informes del servidor a plena carga, hacer una búsqueda de las principales consultas y operaciones en la base de datos y optimizarlas. </li></ul><br>  <strong>Existen muchas herramientas para obtener estadísticas en una base de datos Oracle:</strong> <br><br><ul><li>  Informe de AWR (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (Detalles de SQL); </li><li>  Informe activo de detalles de SQL (DBMS_PERF.report_sql); </li><li>  Monitoreo SQL (pestaña en EMCC); </li><li>  Informe de supervisión de SQL (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Algunas de estas herramientas funcionan en la consola, es decir, no están vinculadas al Enterprise Manager. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplos de herramientas de Oracle para recopilar estadísticas</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  El gráfico superior muestra cuántas sesiones funcionan con esta solicitud. </li><li>  El bloque izquierdo muestra desde dónde se inicia esta solicitud, en qué módulos se encuentra. </li><li>  Abajo a la izquierda: información sobre el uso del grupo compartido. </li><li>  A la derecha, el diagrama muestra los eventos de espera que están en el sistema.  En este caso, es solo la CPU. </li><li>  Abajo a la derecha, lo más interesante, una placa con características de calidad que son más importantes al analizar problemas de rendimiento. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring muestra cómo se ve todo en tiempo real (donde el engranaje verde gira, la consulta está funcionando ahora). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Arriba está el contenido interno del informe de supervisión de SQL.  Muestra en tiempo real qué línea de consulta ejecuta y cuántas líneas lee (columna Filas reales).  En este caso, INDEX RANGE SCAN ya ha contado 5 millones. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  La herramienta de texto Informe de supervisión de SQL, en la que hay información (no toda). <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonificación: los</strong> especialistas del "Centro de pagos" de RNCO y CFT estaban bien preparados para la conferencia en Novosibirsk, hicieron algunos informes útiles y también organizaron una verdadera radio de salida.  Durante dos días, expertos, oradores y organizadores lograron visitar la radio CFT.  Puede regresar al verano siberiano incluyendo entradas, aquí están los enlaces a los bloques: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes: pros y contras</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ciencia de datos y aprendizaje automático</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOps</a> . <br><br><blockquote>  En HighLoad ++ en Moscú, que ya es el 8 y 9 de noviembre, habrá cosas aún más interesantes.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa</a> incluye informes sobre todos los aspectos del trabajo en proyectos altamente cargados, clases magistrales, reuniones y eventos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">socios</a> que compartirán consejos de expertos y encontrarán algo para sorprender.  Asegúrese de escribir sobre lo más interesante y notifíquelo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boletín</a> , ¡conéctese! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428491/">https://habr.com/ru/post/es428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428477/index.html">Para quienes eligen un firewall</a></li>
<li><a href="../es428481/index.html">Contratos digitales: una guía rápida para NO abogados</a></li>
<li><a href="../es428485/index.html">La mayoría de las personas molestas son publicidad irrelevante y el uso de gadgets en público.</a></li>
<li><a href="../es428487/index.html">Por qué Ruby on Rails es bueno y cómo acelera el desarrollo</a></li>
<li><a href="../es428489/index.html">Delgadez y grosor de los iconos. Sketch Pro, funciones de renderizado y un juego con grosor de línea</a></li>
<li><a href="../es428493/index.html">Git subrepo</a></li>
<li><a href="../es428495/index.html">Como hice un simulador de fútbol durante 13 años</a></li>
<li><a href="../es428497/index.html">Atenuador inalámbrico personalizado Noolite SUF-1-300</a></li>
<li><a href="../es428499/index.html">Espeluznantes gigantes azules pueden revelar los secretos de la evolución de las estrellas</a></li>
<li><a href="../es428501/index.html">DartUP: la primera conferencia en ruso sobre Dart y Flutter el 1 de diciembre en San Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>