<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍👨 🤚🏽 👆🏼 Tablas hash en Go. Detalles de implementación ✌🏾 🤞🏻 🛂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Discutiremos la implementación del mapa en un lenguaje sin genéricos, consideraremos qué es una tabla hash, cómo está organizada en Go, cuáles son los...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tablas hash en Go. Detalles de implementación</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="imagen" width="400" height="400"></div><br><br>  Discutiremos la implementación del mapa en un lenguaje sin genéricos, consideraremos qué es una tabla hash, cómo está organizada en Go, cuáles son los pros y los contras de esta implementación, y a qué debe prestar atención al usar esta estructura. <br><br>  Detalles debajo del corte. <br><a name="habracut"></a><br><hr><br>  Atencion  Si ya está familiarizado con las tablas hash en Go, le aconsejo que omita los conceptos básicos y vaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , de lo contrario, existe el riesgo de cansarse del momento más interesante. <br><br><h4>  ¿Qué es una tabla hash? </h4><br>  Para empezar, te recordaré qué es una tabla hash.  Esta es una estructura de datos que le permite almacenar pares clave-valor y, como regla, poseer funciones: <br><br><ul><li>  Mapeo: <code>map(key) → value</code> <br></li><li>  Inserts: <code>insert(map, key, value)</code> <br></li><li>  Eliminaciones: <code>delete(map, key)</code> <br></li><li>  Búsqueda: <code>lookup(key) → value</code> <br></li></ul><br><h4>  Tabla hash en idioma go </h4><br>  Una tabla hash en el idioma go está representada por la palabra clave del mapa y puede declararse de una de las siguientes maneras (más sobre ellas más adelante): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Las operaciones principales se realizan de la siguiente manera: <br><br><ul><li>  Insertar: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Remoción: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  Búsqueda: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  o <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Ir alrededor de una mesa en ir </h4><br>  Considere el siguiente programa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Lanzamiento 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Ejecución 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Como puede ver, la salida varía de una ejecución a otra.  Y todo porque el mapa en Go no está ordenado, es decir, no está ordenado.  Esto significa que no necesita confiar en el orden cuando va de un lado a otro.  La razón se puede encontrar en el código fuente del lenguaje de tiempo de ejecución: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  La ubicación de búsqueda se determina <b>al azar</b> , ¡recuerda esto!  Se rumorea que los desarrolladores de tiempo de ejecución están obligando a los usuarios a no confiar en el orden. <br><br><h4>  Ir a la tabla de búsqueda </h4><br>  Veamos nuevamente un fragmento de código.  Supongamos que queremos crear pares "número" - "número por 10": <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Lanzamos: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Y vemos que cuando intentamos obtener el valor de dos (que olvidamos poner) obtuvimos 0. Encontramos líneas que explican este comportamiento en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> : “Un intento de obtener un valor de mapa con una clave que no está presente en el mapa devolverá el valor cero para el tipo de las entradas en el mapa ", pero traducido al ruso, esto significa que cuando intentamos obtener el valor del mapa, pero no está allí, obtenemos un" valor de tipo cero ", que en el caso del número 0. Qué hacer, si queremos distinguir entre casos 0 y ausencia 2?  Para hacer esto, se nos ocurrió una forma especial de "asignación múltiple": una forma en la que, en lugar del valor único habitual, el mapa devuelve un par: el valor en sí y otro booleano que responde a la pregunta de si la clave solicitada está presente en el mapa o no " <br><br>  Correctamente, el fragmento de código anterior se verá así: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Y al inicio obtenemos: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Crea una tabla en Go. </h4><br>  Supongamos que queremos contar el número de apariciones de cada palabra en una cadena, comenzar un diccionario para esto y revisarlo. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  ¿Ves una <s>trampa de Gopher</s> ?  - Y lo es! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="imagen" width="200" height="400"></div><br>  Cuando intentamos iniciar un programa de este tipo, nos da pánico y aparece el mensaje "asignación a entrada en mapa nulo".  Y todo porque el mapa es un tipo de referencia y no es suficiente para declarar una variable, debe inicializarlo: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Un poco más abajo, quedará claro por qué esto funciona de esta manera.  Al principio, ya se presentaron 4 formas de crear un mapa, dos de las cuales examinamos: esta declaración como variable y creación a través de make.  También puede crear utilizando el diseño " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Literales compuestos</a> " <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  y si lo desea, incluso inicializar inmediatamente con valores, este método también es válido.  En cuanto a la creación usando new, en mi opinión, no tiene sentido, porque esta función asigna memoria para una variable y le devuelve un puntero con un valor cero del tipo, que en el caso del mapa será nulo (obtenemos el mismo resultado que en var, más precisamente un puntero a él). <br><a name="GoMap"></a><br><h4>  ¿Cómo se pasa el mapa a una función? </h4><br>  Supongamos que tenemos una función que intenta cambiar el número que se le pasó.  Veamos qué sucede antes y después de la llamada: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Un ejemplo, creo, es bastante obvio, pero aún incluye la conclusión: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Como probablemente haya adivinado, la función n vino por valor, no por referencia, por lo que la variable original no ha cambiado. <br><br>  Hagamos un truco de mapa similar: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Y he aquí y he aquí: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  El valor ha cambiado.  "Bueno, ¿Mapa pasa por referencia?", Preguntas.  <b>No</b>  No hay enlaces en Go.  Es imposible crear 2 variables con 1 dirección, como en C ++ por ejemplo.  Pero luego puede crear 2 variables que apuntan a la misma dirección (pero estos son punteros y están en Ir). <br><br>  Supongamos que tenemos una función fn que inicializa el mapa m.  En la función principal, simplemente declaramos una variable, la enviamos a inicializar y observamos lo que sucedió después. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Conclusión <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Entonces, la variable m se pasó <b>por valor</b> , por lo tanto, como en el caso de pasar un int regular a la función, no cambió (la copia local del valor en fn cambió).  Entonces, ¿por qué cambia el valor en sí mismo?  Para responder a esta pregunta, considere el código del lenguaje en tiempo de ejecución: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go es solo un puntero a la estructura hmap.  Esta es la respuesta a la pregunta de por qué, a pesar del hecho de que el mapa se pasa a la función por valor, los valores en sí mismos cambian: todo se trata del puntero.  La estructura hmap también contiene lo siguiente: la cantidad de elementos, la cantidad de “cubos” (presentados como un logaritmo para acelerar los cálculos), semilla para aleatorizar hashes (para que sea más difícil de agregar, intente recoger claves para que haya colisiones continuas), todo tipo de campos de servicio y lo más importante, un puntero a los depósitos donde se almacenan los valores.  Miremos la imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="imagen"><br><br>  La imagen muestra una imagen esquemática de la estructura en la memoria: hay un encabezado hmap, cuyo puntero es un mapa en Go (se crea cuando se declara con var, pero no se inicializa, lo que hace que el programa se bloquee al intentar insertarlo).  El campo de cubos es un depósito de pares clave-valor, hay varios cubos de este tipo, cada uno contiene 8 pares.  Primero en el "cubo" son las ranuras para bits de hash adicionales (e0..e7 se llama e - porque <i>los</i> bits de hash <i>adicionales</i> ).  A continuación se muestran primero las claves y los valores como una lista de todas las claves, luego una lista de todos los valores. <br><br>  De acuerdo con el hash de la función, se determina en qué “cubeta” ponemos el valor, dentro de cada “cubeta” puede haber hasta 8 colisiones, al final de cada “cubeta” hay un puntero a una adicional, si la anterior se desborda. <br><br><h4>  ¿Cómo crece el mapa? </h4><br>  En el código fuente puedes encontrar la línea: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  es decir, si hay un promedio de más de 6.5 elementos en cada segmento, se produce un aumento en la matriz de segmentos.  Al mismo tiempo, la matriz se asigna 2 veces más, y los datos antiguos se copian en pequeñas porciones cada inserción o eliminación, para no crear demoras muy grandes.  Por lo tanto, todas las operaciones serán un poco más lentas en el proceso de evacuación de datos (al buscar, también tenemos que buscar en dos lugares).  Después de una evacuación exitosa, comienzan a utilizarse nuevos datos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="imagen" width="300" height="300"></div><br><h4>  Tomando la dirección del elemento del mapa. </h4><br>  Otro punto interesante: al comienzo del uso del lenguaje que quería hacer así: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Pero Go dice: "no se puede tomar la dirección de m [1]".  La explicación de por qué es imposible tomar la dirección del valor radica en el procedimiento de evacuación de datos.  Imagine que tomamos la dirección del valor, y luego el mapa creció, se asignó nueva memoria, se evacuaron los datos, se eliminaron los antiguos, el puntero se volvió incorrecto, por lo que tales operaciones están prohibidas. <br><br><h4>  ¿Cómo se implementa el mapa sin genéricos? </h4><br>  Ni una interfaz vacía, ni la generación de código tienen nada que ver con eso; todo es reemplazarlo en tiempo de compilación.  Considere en qué se convierten las funciones familiares de Go: <br><br><pre> <code class="plaintext hljs">v := m["k"] → func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] → func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 → func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") → func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Vemos que hay funciones de mapaccess para accesos, para escribir y eliminar mapassign y mapdelete, respectivamente.  Todas las operaciones usan un puntero inseguro, que no le importa a qué tipo apunta, y la información sobre cada valor se describe mediante un <b>descriptor de tipo</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType almacena los descriptores (_type) de la clave y el valor.  Para un descriptor de tipo, se definen las operaciones (typeAlg) de comparación, tomar un hash, tamaño, etc., por lo que siempre sabemos cómo producirlas. <br><br>  Un poco más sobre cómo funciona.  Cuando escribimos v = m [k] (tratando de obtener el valor de v de la clave k), el compilador genera algo como lo siguiente: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Es decir, tomamos un puntero a una clave, la estructura mapType, desde la cual descubrimos qué descriptores de la clave y el valor, el puntero a hmap (es decir, map) y lo pasamos todo a mapaccess1, que devolverá un puntero al valor.  Lanzamos el puntero al tipo deseado, desreferenciamos y obtenemos el valor. <br><br>  Ahora veamos el código de búsqueda del tiempo de ejecución (que está ligeramente adaptado para la lectura): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  La función busca la clave en el mapa y devuelve un puntero al valor correspondiente, los argumentos ya nos son familiares: esto es mapType, que almacena descriptores de los tipos y valores de clave, se asigna a sí mismo (mapHeader) y un puntero a la memoria que almacena la clave.  Devolvemos un puntero a la memoria que almacena el valor. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  A continuación, verificamos si el puntero al encabezado del mapa no es nulo, si hay 0 elementos allí y devolvemos un valor nulo, si es así. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Calculamos el hash de la clave (sabemos cómo calcular una clave dada a partir de un descriptor de tipo).  Luego tratamos de entender a qué "cubeta" debe ir y ver (el resto de la división entre el número de "cubetas", los cálculos se aceleran ligeramente).  Luego calculamos el hash adicional (tomamos los 8 bits más significativos del hash) y determinamos la posición del “cubo” en la memoria (aritmética de direcciones). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  La búsqueda, si nos fijamos, no es tan complicada: pasamos por las cadenas de "cubos", pasando al siguiente, si no lo encuentra.  La búsqueda en el "depósito" comienza con una comparación rápida del hash adicional (es por eso que estos e0 ... e7 al comienzo de cada uno son un hash "mini" del par para una comparación rápida).  Si no coincide, vaya más allá, si lo hace, entonces verificamos con más cuidado: determinamos dónde se encuentra la clave sospechosa de ser buscada en la memoria, comparamos si es igual a lo que se solicitó.  Si es igual, determine la posición del valor en la memoria y regrese.  Como puedes ver, nada sobrenatural. <br><br><h4>  Conclusión </h4><br>  Use mapas, pero sepa y entienda cómo funcionan.  Puede evitar el rastrillo si comprende algunas de las sutilezas: por qué no puede tomar la dirección del valor, por qué todo cae durante la declaración sin inicialización, por qué es mejor asignar memoria por adelantado si se conoce el número de elementos (evitaremos las evacuaciones) y mucho más. <br><br><hr><br>  Referencias <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Ir mapas en acción", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cómo el tiempo de ejecución go implementa mapas de manera eficiente", Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Entendiendo el tipo en ir", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación del mapa interior, Keith Randall</a> <br>  <a href="">código fuente del mapa, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones de golang</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ir efectivo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gopher imágenes</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457728/">https://habr.com/ru/post/457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457714/index.html">Stack Overflow en inglés: Community Kill Guide</a></li>
<li><a href="../457718/index.html">HyperCard, el enlace perdido en la evolución de la web</a></li>
<li><a href="../457720/index.html">Autodesk Maya: características útiles y básicas para trabajar con modelos 3D</a></li>
<li><a href="../457722/index.html">SQL: Problema de asistencia de tiempo: Debriefing</a></li>
<li><a href="../457724/index.html">OpenCV en STM32F7-Discovery</a></li>
<li><a href="../457730/index.html">En la oficina hay una ilusión de control: no está en el control remoto. Conversación con Devhab</a></li>
<li><a href="../457734/index.html">Comienza la revolución del código abierto en Italia</a></li>
<li><a href="../457736/index.html">"Las herramientas no son tan importantes como la capacidad de pensar sobre los sistemas que crean". Gran entrevista con Martin Kleppman</a></li>
<li><a href="../457738/index.html">Cómo implementamos SD-Access y por qué era necesario</a></li>
<li><a href="../457742/index.html">Autoescalado horizontal de hogares Kubernetes y Prometheus para alta disponibilidad y disponibilidad de infraestructura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>