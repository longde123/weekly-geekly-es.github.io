<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüë® ü§öüèΩ üëÜüèº Tablas hash en Go. Detalles de implementaci√≥n ‚úåüèæ ü§ûüèª üõÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Discutiremos la implementaci√≥n del mapa en un lenguaje sin gen√©ricos, consideraremos qu√© es una tabla hash, c√≥mo est√° organizada en Go, cu√°les son los...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tablas hash en Go. Detalles de implementaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="imagen" width="400" height="400"></div><br><br>  Discutiremos la implementaci√≥n del mapa en un lenguaje sin gen√©ricos, consideraremos qu√© es una tabla hash, c√≥mo est√° organizada en Go, cu√°les son los pros y los contras de esta implementaci√≥n, y a qu√© debe prestar atenci√≥n al usar esta estructura. <br><br>  Detalles debajo del corte. <br><a name="habracut"></a><br><hr><br>  Atencion  Si ya est√° familiarizado con las tablas hash en Go, le aconsejo que omita los conceptos b√°sicos y vaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , de lo contrario, existe el riesgo de cansarse del momento m√°s interesante. <br><br><h4>  ¬øQu√© es una tabla hash? </h4><br>  Para empezar, te recordar√© qu√© es una tabla hash.  Esta es una estructura de datos que le permite almacenar pares clave-valor y, como regla, poseer funciones: <br><br><ul><li>  Mapeo: <code>map(key) ‚Üí value</code> <br></li><li>  Inserts: <code>insert(map, key, value)</code> <br></li><li>  Eliminaciones: <code>delete(map, key)</code> <br></li><li>  B√∫squeda: <code>lookup(key) ‚Üí value</code> <br></li></ul><br><h4>  Tabla hash en idioma go </h4><br>  Una tabla hash en el idioma go est√° representada por la palabra clave del mapa y puede declararse de una de las siguientes maneras (m√°s sobre ellas m√°s adelante): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Las operaciones principales se realizan de la siguiente manera: <br><br><ul><li>  Insertar: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Remoci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  B√∫squeda: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  o <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Ir alrededor de una mesa en ir </h4><br>  Considere el siguiente programa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Lanzamiento 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Ejecuci√≥n 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Como puede ver, la salida var√≠a de una ejecuci√≥n a otra.  Y todo porque el mapa en Go no est√° ordenado, es decir, no est√° ordenado.  Esto significa que no necesita confiar en el orden cuando va de un lado a otro.  La raz√≥n se puede encontrar en el c√≥digo fuente del lenguaje de tiempo de ejecuci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  La ubicaci√≥n de b√∫squeda se determina <b>al azar</b> , ¬°recuerda esto!  Se rumorea que los desarrolladores de tiempo de ejecuci√≥n est√°n obligando a los usuarios a no confiar en el orden. <br><br><h4>  Ir a la tabla de b√∫squeda </h4><br>  Veamos nuevamente un fragmento de c√≥digo.  Supongamos que queremos crear pares "n√∫mero" - "n√∫mero por 10": <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Lanzamos: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Y vemos que cuando intentamos obtener el valor de dos (que olvidamos poner) obtuvimos 0. Encontramos l√≠neas que explican este comportamiento en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> : ‚ÄúUn intento de obtener un valor de mapa con una clave que no est√° presente en el mapa devolver√° el valor cero para el tipo de las entradas en el mapa ", pero traducido al ruso, esto significa que cuando intentamos obtener el valor del mapa, pero no est√° all√≠, obtenemos un" valor de tipo cero ", que en el caso del n√∫mero 0. Qu√© hacer, si queremos distinguir entre casos 0 y ausencia 2?  Para hacer esto, se nos ocurri√≥ una forma especial de "asignaci√≥n m√∫ltiple": una forma en la que, en lugar del valor √∫nico habitual, el mapa devuelve un par: el valor en s√≠ y otro booleano que responde a la pregunta de si la clave solicitada est√° presente en el mapa o no " <br><br>  Correctamente, el fragmento de c√≥digo anterior se ver√° as√≠: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Y al inicio obtenemos: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Crea una tabla en Go. </h4><br>  Supongamos que queremos contar el n√∫mero de apariciones de cada palabra en una cadena, comenzar un diccionario para esto y revisarlo. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  ¬øVes una <s>trampa de Gopher</s> ?  - Y lo es! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="imagen" width="200" height="400"></div><br>  Cuando intentamos iniciar un programa de este tipo, nos da p√°nico y aparece el mensaje "asignaci√≥n a entrada en mapa nulo".  Y todo porque el mapa es un tipo de referencia y no es suficiente para declarar una variable, debe inicializarlo: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Un poco m√°s abajo, quedar√° claro por qu√© esto funciona de esta manera.  Al principio, ya se presentaron 4 formas de crear un mapa, dos de las cuales examinamos: esta declaraci√≥n como variable y creaci√≥n a trav√©s de make.  Tambi√©n puede crear utilizando el dise√±o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Literales compuestos</a> " <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  y si lo desea, incluso inicializar inmediatamente con valores, este m√©todo tambi√©n es v√°lido.  En cuanto a la creaci√≥n usando new, en mi opini√≥n, no tiene sentido, porque esta funci√≥n asigna memoria para una variable y le devuelve un puntero con un valor cero del tipo, que en el caso del mapa ser√° nulo (obtenemos el mismo resultado que en var, m√°s precisamente un puntero a √©l). <br><a name="GoMap"></a><br><h4>  ¬øC√≥mo se pasa el mapa a una funci√≥n? </h4><br>  Supongamos que tenemos una funci√≥n que intenta cambiar el n√∫mero que se le pas√≥.  Veamos qu√© sucede antes y despu√©s de la llamada: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Un ejemplo, creo, es bastante obvio, pero a√∫n incluye la conclusi√≥n: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Como probablemente haya adivinado, la funci√≥n n vino por valor, no por referencia, por lo que la variable original no ha cambiado. <br><br>  Hagamos un truco de mapa similar: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Y he aqu√≠ y he aqu√≠: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  El valor ha cambiado.  "Bueno, ¬øMapa pasa por referencia?", Preguntas.  <b>No</b>  No hay enlaces en Go.  Es imposible crear 2 variables con 1 direcci√≥n, como en C ++ por ejemplo.  Pero luego puede crear 2 variables que apuntan a la misma direcci√≥n (pero estos son punteros y est√°n en Ir). <br><br>  Supongamos que tenemos una funci√≥n fn que inicializa el mapa m.  En la funci√≥n principal, simplemente declaramos una variable, la enviamos a inicializar y observamos lo que sucedi√≥ despu√©s. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Conclusi√≥n <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Entonces, la variable m se pas√≥ <b>por valor</b> , por lo tanto, como en el caso de pasar un int regular a la funci√≥n, no cambi√≥ (la copia local del valor en fn cambi√≥).  Entonces, ¬øpor qu√© cambia el valor en s√≠ mismo?  Para responder a esta pregunta, considere el c√≥digo del lenguaje en tiempo de ejecuci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go es solo un puntero a la estructura hmap.  Esta es la respuesta a la pregunta de por qu√©, a pesar del hecho de que el mapa se pasa a la funci√≥n por valor, los valores en s√≠ mismos cambian: todo se trata del puntero.  La estructura hmap tambi√©n contiene lo siguiente: la cantidad de elementos, la cantidad de ‚Äúcubos‚Äù (presentados como un logaritmo para acelerar los c√°lculos), semilla para aleatorizar hashes (para que sea m√°s dif√≠cil de agregar, intente recoger claves para que haya colisiones continuas), todo tipo de campos de servicio y lo m√°s importante, un puntero a los dep√≥sitos donde se almacenan los valores.  Miremos la imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="imagen"><br><br>  La imagen muestra una imagen esquem√°tica de la estructura en la memoria: hay un encabezado hmap, cuyo puntero es un mapa en Go (se crea cuando se declara con var, pero no se inicializa, lo que hace que el programa se bloquee al intentar insertarlo).  El campo de cubos es un dep√≥sito de pares clave-valor, hay varios cubos de este tipo, cada uno contiene 8 pares.  Primero en el "cubo" son las ranuras para bits de hash adicionales (e0..e7 se llama e - porque <i>los</i> bits de hash <i>adicionales</i> ).  A continuaci√≥n se muestran primero las claves y los valores como una lista de todas las claves, luego una lista de todos los valores. <br><br>  De acuerdo con el hash de la funci√≥n, se determina en qu√© ‚Äúcubeta‚Äù ponemos el valor, dentro de cada ‚Äúcubeta‚Äù puede haber hasta 8 colisiones, al final de cada ‚Äúcubeta‚Äù hay un puntero a una adicional, si la anterior se desborda. <br><br><h4>  ¬øC√≥mo crece el mapa? </h4><br>  En el c√≥digo fuente puedes encontrar la l√≠nea: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  es decir, si hay un promedio de m√°s de 6.5 elementos en cada segmento, se produce un aumento en la matriz de segmentos.  Al mismo tiempo, la matriz se asigna 2 veces m√°s, y los datos antiguos se copian en peque√±as porciones cada inserci√≥n o eliminaci√≥n, para no crear demoras muy grandes.  Por lo tanto, todas las operaciones ser√°n un poco m√°s lentas en el proceso de evacuaci√≥n de datos (al buscar, tambi√©n tenemos que buscar en dos lugares).  Despu√©s de una evacuaci√≥n exitosa, comienzan a utilizarse nuevos datos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="imagen" width="300" height="300"></div><br><h4>  Tomando la direcci√≥n del elemento del mapa. </h4><br>  Otro punto interesante: al comienzo del uso del lenguaje que quer√≠a hacer as√≠: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Pero Go dice: "no se puede tomar la direcci√≥n de m [1]".  La explicaci√≥n de por qu√© es imposible tomar la direcci√≥n del valor radica en el procedimiento de evacuaci√≥n de datos.  Imagine que tomamos la direcci√≥n del valor, y luego el mapa creci√≥, se asign√≥ nueva memoria, se evacuaron los datos, se eliminaron los antiguos, el puntero se volvi√≥ incorrecto, por lo que tales operaciones est√°n prohibidas. <br><br><h4>  ¬øC√≥mo se implementa el mapa sin gen√©ricos? </h4><br>  Ni una interfaz vac√≠a, ni la generaci√≥n de c√≥digo tienen nada que ver con eso; todo es reemplazarlo en tiempo de compilaci√≥n.  Considere en qu√© se convierten las funciones familiares de Go: <br><br><pre> <code class="plaintext hljs">v := m["k"] ‚Üí func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] ‚Üí func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 ‚Üí func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") ‚Üí func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Vemos que hay funciones de mapaccess para accesos, para escribir y eliminar mapassign y mapdelete, respectivamente.  Todas las operaciones usan un puntero inseguro, que no le importa a qu√© tipo apunta, y la informaci√≥n sobre cada valor se describe mediante un <b>descriptor de tipo</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType almacena los descriptores (_type) de la clave y el valor.  Para un descriptor de tipo, se definen las operaciones (typeAlg) de comparaci√≥n, tomar un hash, tama√±o, etc., por lo que siempre sabemos c√≥mo producirlas. <br><br>  Un poco m√°s sobre c√≥mo funciona.  Cuando escribimos v = m [k] (tratando de obtener el valor de v de la clave k), el compilador genera algo como lo siguiente: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Es decir, tomamos un puntero a una clave, la estructura mapType, desde la cual descubrimos qu√© descriptores de la clave y el valor, el puntero a hmap (es decir, map) y lo pasamos todo a mapaccess1, que devolver√° un puntero al valor.  Lanzamos el puntero al tipo deseado, desreferenciamos y obtenemos el valor. <br><br>  Ahora veamos el c√≥digo de b√∫squeda del tiempo de ejecuci√≥n (que est√° ligeramente adaptado para la lectura): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  La funci√≥n busca la clave en el mapa y devuelve un puntero al valor correspondiente, los argumentos ya nos son familiares: esto es mapType, que almacena descriptores de los tipos y valores de clave, se asigna a s√≠ mismo (mapHeader) y un puntero a la memoria que almacena la clave.  Devolvemos un puntero a la memoria que almacena el valor. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  A continuaci√≥n, verificamos si el puntero al encabezado del mapa no es nulo, si hay 0 elementos all√≠ y devolvemos un valor nulo, si es as√≠. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Calculamos el hash de la clave (sabemos c√≥mo calcular una clave dada a partir de un descriptor de tipo).  Luego tratamos de entender a qu√© "cubeta" debe ir y ver (el resto de la divisi√≥n entre el n√∫mero de "cubetas", los c√°lculos se aceleran ligeramente).  Luego calculamos el hash adicional (tomamos los 8 bits m√°s significativos del hash) y determinamos la posici√≥n del ‚Äúcubo‚Äù en la memoria (aritm√©tica de direcciones). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  La b√∫squeda, si nos fijamos, no es tan complicada: pasamos por las cadenas de "cubos", pasando al siguiente, si no lo encuentra.  La b√∫squeda en el "dep√≥sito" comienza con una comparaci√≥n r√°pida del hash adicional (es por eso que estos e0 ... e7 al comienzo de cada uno son un hash "mini" del par para una comparaci√≥n r√°pida).  Si no coincide, vaya m√°s all√°, si lo hace, entonces verificamos con m√°s cuidado: determinamos d√≥nde se encuentra la clave sospechosa de ser buscada en la memoria, comparamos si es igual a lo que se solicit√≥.  Si es igual, determine la posici√≥n del valor en la memoria y regrese.  Como puedes ver, nada sobrenatural. <br><br><h4>  Conclusi√≥n </h4><br>  Use mapas, pero sepa y entienda c√≥mo funcionan.  Puede evitar el rastrillo si comprende algunas de las sutilezas: por qu√© no puede tomar la direcci√≥n del valor, por qu√© todo cae durante la declaraci√≥n sin inicializaci√≥n, por qu√© es mejor asignar memoria por adelantado si se conoce el n√∫mero de elementos (evitaremos las evacuaciones) y mucho m√°s. <br><br><hr><br>  Referencias <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Ir mapas en acci√≥n", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C√≥mo el tiempo de ejecuci√≥n go implementa mapas de manera eficiente", Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Entendiendo el tipo en ir", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n del mapa interior, Keith Randall</a> <br>  <a href="">c√≥digo fuente del mapa, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones de golang</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ir efectivo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gopher im√°genes</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457728/">https://habr.com/ru/post/457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457714/index.html">Stack Overflow en ingl√©s: Community Kill Guide</a></li>
<li><a href="../457718/index.html">HyperCard, el enlace perdido en la evoluci√≥n de la web</a></li>
<li><a href="../457720/index.html">Autodesk Maya: caracter√≠sticas √∫tiles y b√°sicas para trabajar con modelos 3D</a></li>
<li><a href="../457722/index.html">SQL: Problema de asistencia de tiempo: Debriefing</a></li>
<li><a href="../457724/index.html">OpenCV en STM32F7-Discovery</a></li>
<li><a href="../457730/index.html">En la oficina hay una ilusi√≥n de control: no est√° en el control remoto. Conversaci√≥n con Devhab</a></li>
<li><a href="../457734/index.html">Comienza la revoluci√≥n del c√≥digo abierto en Italia</a></li>
<li><a href="../457736/index.html">"Las herramientas no son tan importantes como la capacidad de pensar sobre los sistemas que crean". Gran entrevista con Martin Kleppman</a></li>
<li><a href="../457738/index.html">C√≥mo implementamos SD-Access y por qu√© era necesario</a></li>
<li><a href="../457742/index.html">Autoescalado horizontal de hogares Kubernetes y Prometheus para alta disponibilidad y disponibilidad de infraestructura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>