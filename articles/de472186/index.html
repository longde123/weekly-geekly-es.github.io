<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏽 🤟🏼 😿 Open-Closed-Prinzip 🌇 🏏 🔻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Hier ist eine Übersetzung eines Artikels von Robert Martin über das Open-Closed-Prinzip , den er im Januar 1996 veröffentlichte. Der Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Open-Closed-Prinzip</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Hallo Habr!  Hier ist eine Übersetzung eines Artikels von Robert Martin über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20060822033314/">Open-Closed-Prinzip</a> , den er im Januar 1996 veröffentlichte.  Der Artikel ist, gelinde gesagt, nicht der neueste.  Aber in RuNet werden Onkel Bobs Artikel über SOLID nur in abgeschnittener Form nacherzählt, sodass ich dachte, dass eine vollständige Übersetzung nicht überflüssig wäre. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Ich habe mich entschlossen, mit dem Buchstaben O zu beginnen, da das Prinzip der Offenheitsschließung tatsächlich von zentraler Bedeutung ist.  Unter anderem gibt es viele wichtige Feinheiten, die es wert sind, beachtet zu werden: </p><br><ul><li>  Kein Programm kann zu 100% "geschlossen" werden. </li><li>  Objektorientierte Programmierung (OOP) arbeitet nicht mit physischen Objekten der realen Welt, sondern mit Konzepten - zum Beispiel dem Konzept der "Ordnung". <a name="habracut"></a></li></ul><br><p>  Dies ist der erste Artikel in meiner Spalte " <em>Engineer Notes"</em> für <em>den C ++ - Bericht</em> .  Die in dieser Spalte veröffentlichten Artikel konzentrieren sich auf die Verwendung von C ++ und OOP und gehen auf die Schwierigkeiten bei der Softwareentwicklung ein.  Ich werde versuchen, die Materialien für praktizierende Ingenieure pragmatisch und nützlich zu machen.  Zur Dokumentation des objektorientierten Designs in diesen Artikeln werde ich die Buch-Notation verwenden. </p><br><p>  Mit der objektorientierten Programmierung sind viele Heuristiken verbunden.  Beispiel: "Alle Mitgliedsvariablen müssen privat sein" oder "Globale Variablen sollten vermieden werden" oder "Typbestimmung zur Laufzeit ist gefährlich".  Was ist der Grund für solche Heuristiken?  Warum sind sie wahr?  Sind sie <em>immer</em> wahr?  In dieser Spalte wird das diesen Heuristiken zugrunde liegende Entwurfsprinzip untersucht - das Prinzip des Offenheitsverschlusses. <br>  Ivar Jacobson sagte: „Alle Systeme ändern sich während des Lebenszyklus.  Dies muss beim Entwurf eines Systems berücksichtigt werden, für das mehr als eine Version erwartet wird. “  Wie können wir ein System so gestalten, dass es angesichts von Veränderungen stabil ist und mehr als eine Version erwartet wird?  Bertrand Meyer erzählte uns davon bereits 1988, als das mittlerweile berühmte Prinzip der Offenheit und Nähe formuliert wurde: </p><br><p>  <strong>Programmentitäten (Klassen, Module, Funktionen usw.) müssen zur Erweiterung geöffnet und für Änderungen geschlossen sein.</strong> </p><br><p>  Wenn eine Änderung im Programm eine Kaskade von Änderungen in den abhängigen Modulen zur Folge hat, zeigt das Programm unerwünschte Anzeichen eines „schlechten“ Designs an. </p><br><p>  Das Programm wird zerbrechlich, unflexibel, unvorhersehbar und unbenutzt.  Das Prinzip der Offenheit und Nähe löst diese Probleme auf sehr einfache Weise.  Er sagt, dass es notwendig ist, Module zu entwerfen, die sich nie <em>ändern</em> .  Wenn sich die Anforderungen ändern, müssen Sie das Verhalten solcher Module erweitern, indem Sie neuen Code hinzufügen, anstatt den alten, bereits funktionierenden Code zu ändern. </p><br><h1>  Beschreibung </h1><br><p>  Module, die das Prinzip der Offenheit und Nähe erfüllen, weisen zwei Hauptmerkmale auf: </p><br><ol><li>  <strong>Zur Erweiterung öffnen.</strong>  Dies bedeutet, dass das Verhalten des Moduls erweitert werden kann.  Das heißt, wir können dem Modul ein neues Verhalten hinzufügen, das den sich ändernden Anforderungen für die Anwendung entspricht oder den Anforderungen neuer Anwendungen entspricht. </li><li> <strong>Wegen Änderung geschlossen.</strong>  Der Quellcode eines solchen Moduls ist unantastbar.  Niemand hat das Recht, Änderungen daran vorzunehmen. </li></ol><br><p>  Es scheint, dass diese beiden Zeichen nicht zusammenpassen.  Die Standardmethode zum Erweitern des Verhaltens eines Moduls besteht darin, Änderungen daran vorzunehmen.  Ein Modul, das nicht geändert werden kann, wird normalerweise als Modul mit festem Verhalten betrachtet.  Wie können diese beiden entgegengesetzten Bedingungen erfüllt werden? </p><br><h1>  Der Schlüssel zur Lösung ist die Abstraktion. </h1><br><p>  In C ++ ist es unter Verwendung der Prinzipien des objektorientierten Entwurfs möglich, feste Abstraktionen zu erstellen, die eine unbegrenzte Anzahl möglicher Verhaltensweisen darstellen können. </p><br><p>  Abstraktionen sind abstrakte Basisklassen, und eine unbegrenzte Anzahl möglicher Verhaltensweisen wird durch alle möglichen Nachfolgeklassen dargestellt.  Ein Modul kann die Abstraktion manipulieren.  Ein solches Modul ist wegen Änderungen geschlossen, da es von einer festen Abstraktion abhängt.  Das Verhalten des Moduls kann auch erweitert werden, indem neue Nachkommen der Abstraktion erstellt werden. </p><br><p> Das folgende Diagramm zeigt eine einfache Entwurfsoption, die dem Prinzip der Offenheit und Nähe nicht entspricht.  Beide Klassen, <code>Client</code> und <code>Server</code> , sind nicht abstrakt.  Es gibt keine Garantie dafür, dass Funktionen, die Mitglieder der <code>Server</code> sind, virtuell sind.  Die <code>Client</code> Klasse verwendet die <code>Server</code> Klasse.  Wenn das <code>Client</code> Klassenobjekt ein anderes Serverobjekt verwenden soll, müssen wir die <code>Client</code> Klasse so ändern, dass sie auf die neue Serverklasse verweist. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="Bild"><br>  <em>Geschlossener Client</em> </p><br><p>  Das folgende Diagramm zeigt die entsprechende Gestaltungsmöglichkeit, die dem Prinzip der Offenheit-Nähe entspricht.  In diesem Fall ist die <code>AbstractServer</code> Klasse eine abstrakte Klasse, deren Elementfunktionen virtuell sind.  Die <code>Client</code> Klasse verwendet die Abstraktion.  Objekte der <code>Client</code> Klasse verwenden jedoch Objekte der <code>Server</code> Nachfolgerklasse.  Wenn Objekte der <code>Client</code> Klasse eine andere Serverklasse verwenden sollen, führen wir einen neuen Nachkommen der <code>AbstractServer</code> Klasse ein.  Die <code>Client</code> Klasse bleibt unverändert. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="Bild"><br>  <em>Client öffnen</em> </p><br><h1>  <code>Shape</code> abstrakt </h1><br><p>  Stellen Sie sich eine Anwendung vor, die Kreise und Quadrate in einer Standard-GUI zeichnen soll.  Kreise und Quadrate müssen in einer bestimmten Reihenfolge gezeichnet werden.  In der entsprechenden Reihenfolge wird eine Liste von Kreisen und Quadraten erstellt. Das Programm sollte diese Liste in der Reihenfolge durchgehen und jeden Kreis oder jedes Quadrat zeichnen. </p><br><p>  In C könnten wir mit prozeduralen Programmiertechniken, die nicht dem Open-Close-Prinzip entsprechen, dieses Problem lösen, wie in Listing 1 gezeigt. Hier sehen wir viele Datenstrukturen mit demselben ersten Element.  Dieses Element ist ein Typcode, der die Datenstruktur als Kreis oder Quadrat identifiziert.  Die <code>DrawAllShapes</code> Funktion durchläuft ein Array von Zeigern auf diese Datenstrukturen, erkennt den Typcode und ruft dann die entsprechende Funktion ( <code>DrawCircle</code> oder <code>DrawSquare</code> ) auf. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  Die <code>DrawAllShapes</code> Funktion <code>DrawAllShapes</code> nicht das Prinzip des Offenheitsschlusses, da sie nicht aus neuen Formen geschlossen werden kann.  Wenn ich diese Funktion um die Möglichkeit erweitern möchte, Formen aus einer Liste mit Dreiecken zu zeichnen, muss ich die Funktion ändern.  Tatsächlich muss ich die Funktion für jeden neuen Formtyp ändern, den ich zeichnen muss. </p><br><p>  Natürlich ist dieses Programm nur ein Beispiel.  Im wirklichen Leben würde der <code>switch</code> aus der <code>DrawAllShapes</code> Funktion in verschiedenen Funktionen in der gesamten Anwendung immer wieder wiederholt, und jeder würde etwas anderes tun.  Das Hinzufügen neuer Formen zu einer solchen Anwendung bedeutet, alle Stellen zu finden, an denen solche <code>switch</code> (oder <code>if/else</code> Ketten) verwendet werden, und jeder von ihnen eine neue Form hinzuzufügen.  Darüber hinaus ist es sehr unwahrscheinlich, dass alle <code>switch</code> und <code>if/else</code> Ketten so gut strukturiert sind wie in <code>DrawAllShapes</code> .  Es ist viel wahrscheinlicher, dass Prädikate angeben, <code>if</code> mit logischen Operatoren kombiniert werden oder <code>if</code> <code>case</code> von <code>switch</code> so kombiniert werden, dass eine bestimmte Stelle im Code „vereinfacht“ wird.  Daher kann das Problem, alle Stellen zu finden und zu verstehen, an denen Sie eine neue Figur hinzufügen müssen, nicht trivial sein. </p><br><p>  In Listing 2 werde ich Code zeigen, der eine Quadrat- / Kreislösung demonstriert, die dem Prinzip des Offenheitsschlusses entspricht.  Eine abstrakte <code>Shape</code> wird eingeführt.  Diese abstrakte Klasse enthält eine reine virtuelle <code>Draw</code> .  Die Klassen <code>Circle</code> und <code>Square</code> sind Nachkommen der <code>Shape</code> Klasse. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Beachten Sie, dass wir nur einen neuen Nachkommen der <code>Shape</code> Klasse hinzufügen müssen, wenn wir das Verhalten der <code>DrawAllShapes</code> Funktion in Listing 2 erweitern möchten, um eine neue Art von Form zu zeichnen.  Die <code>DrawAllShapes</code> Funktion muss nicht <code>DrawAllShapes</code> werden.  Daher erfüllt <code>DrawAllShapes</code> das Prinzip der Offenheit und Nähe.  Sein Verhalten kann erweitert werden, ohne die Funktion selbst zu ändern. </p><br><p>  In der realen Welt würde die <code>Shape</code> Klasse viele andere Methoden enthalten.  Das Hinzufügen einer neuen Form zur Anwendung ist jedoch immer noch sehr einfach, da Sie lediglich einen neuen Erben eingeben und diese Funktionen implementieren müssen.  Sie müssen nicht die gesamte Anwendung nach Orten durchsuchen, an denen Änderungen erforderlich sind. </p><br><p>  Daher werden Programme, die dem Prinzip der Offenheit und Nähe entsprechen, durch Hinzufügen neuen Codes und nicht durch Ändern des vorhandenen Codes geändert. Sie kaskadieren keine Änderungen, die für Programme charakteristisch sind, die diesem Prinzip nicht entsprechen. </p><br><h1>  Closed-Entry-Strategie </h1><br><p>  Offensichtlich kann kein Programm zu 100% geschlossen werden.  Was passiert beispielsweise mit der Funktion <code>DrawAllShapes</code> in Listing 2, wenn wir entscheiden, dass zuerst Kreise und dann Quadrate gezeichnet werden sollen?  Die <code>DrawAllShapes</code> Funktion <code>DrawAllShapes</code> bei dieser Art von Änderung nicht geschlossen.  Im Allgemeinen spielt es keine Rolle, wie "geschlossen" das Modul ist, es gibt immer eine Art von Änderung, von der es nicht geschlossen wird. </p><br><p>  Da die Schließung nicht vollständig sein kann, muss sie strategisch eingeführt werden.  Das heißt, der Designer muss die Arten von Änderungen auswählen, aus denen das Programm geschlossen wird.  Dies erfordert einige Erfahrung.  Ein erfahrener Entwickler kennt Benutzer und Branche gut genug, um die Wahrscheinlichkeit verschiedener Änderungen zu berechnen.  Er stellt dann sicher, dass das Prinzip der Offenheit und Nähe für die wahrscheinlichsten Änderungen eingehalten wird. </p><br><h2>  Verwendung der Abstraktion, um zusätzliche Nähe zu erreichen </h2><br><p>  Wie können wir die <code>DrawAllShapes</code> Funktion aufgrund von Änderungen in der Zeichnungsreihenfolge schließen?  Denken Sie daran, dass der Abschluss auf Abstraktion basiert.  Um <code>DrawAllShapes</code> von der Bestellung <code>DrawAllShapes</code> , benötigen wir daher eine Art „Ordnungsabstraktion“.  Ein oben dargestellter Sonderfall der Bestellung ist das Zeichnen von Figuren eines Typs vor Figuren eines anderen Typs. </p><br><p>  Die Bestellrichtlinie impliziert, dass Sie mit zwei Objekten festlegen können, welches zuerst gezeichnet werden soll.  Daher können wir eine Methode für die <code>Shape</code> Klasse mit dem Namen <code>Precedes</code> , die ein anderes <code>Shape</code> Objekt als Argument verwendet und den Booleschen Wert <code>true</code> zurückgibt <code>true</code> wenn das <code>Shape</code> Objekt, das diese Nachricht empfangen hat, vor dem <code>Shape</code> Objekt sortiert werden muss als Argument übergeben. </p><br><p>  In C ++ kann diese Funktion als Überladung des Operators "&lt;" dargestellt werden.  Listing 3 zeigt die <code>Shape</code> Klasse mit Sortiermethoden. </p><br><p>  Nachdem wir nun die Möglichkeit haben, die Reihenfolge der Objekte der <code>Shape</code> Klasse zu bestimmen, können wir sie sortieren und dann zeichnen.  Listing 4 zeigt den entsprechenden C ++ - Code.  Es verwendet die Klassen <code>Set</code> , <code>OrderedSet</code> und <code>Iterator</code> aus der Kategorie <code>Components</code> die in meinem Buch entwickelt wurden (Entwerfen objektorientierter C ++ - Anwendungen mit der Booch-Methode, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Daher haben wir die Reihenfolge der Objekte der <code>Shape</code> Klasse implementiert und sie in der entsprechenden Reihenfolge gezeichnet.  Aber wir haben immer noch keine Implementierung der Abstraktion der Ordnung.  Offensichtlich muss jedes <code>Shape</code> Objekt die <code>Precedes</code> Methode überschreiben, um die Reihenfolge zu bestimmen.  Wie kann das funktionieren?  Welcher Code muss in <code>Circle::Precedes</code> werden, damit Kreise zu Quadraten gezeichnet werden?  Achten Sie auf Listing 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Es ist klar, dass diese Funktion nicht dem Prinzip der Offenheit-Nähe entspricht.  Es gibt keine Möglichkeit, es vor den neuen Nachkommen der <code>Shape</code> Klasse zu schließen.  Jedes Mal, wenn ein neuer Nachkomme der <code>Shape</code> Klasse angezeigt wird, muss diese Funktion geändert werden. </p><br><h2>  Verwenden eines datengesteuerten Ansatzes zum Schließen </h2><br><p>  Die Nähe der Erben der <code>Shape</code> Klasse kann mithilfe eines tabellarischen Ansatzes erreicht werden, der nicht zu Änderungen in jeder geerbten Klasse führt.  Ein Beispiel für diesen Ansatz ist in Listing 6 dargestellt. </p><br><p>  Mit diesem Ansatz haben wir die <code>DrawAllShapes</code> Funktion erfolgreich <code>DrawAllShapes</code> von Änderungen in Bezug auf die Reihenfolge und jedem Nachkommen der <code>Shape</code> Klasse geschlossen - aufgrund der Einführung eines neuen Nachkommen oder aufgrund einer Änderung der Ordnungsrichtlinie für Objekte der <code>Shape</code> Klasse in Abhängigkeit von ihrem Typ (z. B. Objekte der <code>Squares</code> Klasse) zuerst gezeichnet werden). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  Das einzige Element, das nicht daran gehindert wird, die Reihenfolge der Zeichnungsformen zu ändern, ist eine Tabelle.  Die Tabelle kann in einem separaten Modul platziert werden, das von allen anderen Modulen getrennt ist. Daher wirken sich die Änderungen nicht auf andere Module aus. </p><br><h2>  Weitere Schließung </h2><br><p>  Dies ist nicht das Ende der Geschichte.  Wir haben die Hierarchie der <code>Shape</code> Klasse und der <code>DrawAllShapes</code> Funktion geschlossen, um die Ordnungsrichtlinie basierend auf dem <code>DrawAllShapes</code> ändern.  Die Nachkommen der <code>Shape</code> Klasse werden jedoch nicht von Ordnungsrichtlinien ausgeschlossen, die keinen Formtypen zugeordnet sind.  Es scheint, dass wir das Zeichnen von Formen nach einer übergeordneten Struktur anordnen müssen.  Eine vollständige Untersuchung solcher Probleme würde den Rahmen dieses Artikels sprengen.  Ein interessierter Leser könnte jedoch darüber nachdenken, wie dieses Problem mithilfe der abstrakten <code>OrderedObject</code> Klasse <code>OrderedShape</code> , die in der <code>OrderedShape</code> Klasse enthalten ist, die von den <code>OrderedObject</code> und <code>OrderedObject</code> erbt. </p><br><h1>  Heuristiken und Konventionen </h1><br><p>  Wie bereits am Anfang des Artikels erwähnt, ist das Prinzip der Offenheit und Nähe die Hauptmotivation für viele Heuristiken und Konventionen, die sich im Laufe der vielen Jahre der Entwicklung des OOP-Paradigmas herausgebildet haben.  Das Folgende sind die wichtigsten. </p><br><h2>  Machen Sie alle Mitgliedsvariablen privat </h2><br><p>  Dies ist eine der dauerhaftesten Konventionen der PLO.  Mitgliedsvariablen sollten nur den Methoden der Klasse bekannt sein, in der sie definiert sind.  Variable Mitglieder sollten anderen Klassen, einschließlich abgeleiteten Klassen, nicht bekannt sein.  Daher müssen sie mit einem <code>private</code> Zugriffsmodifikator deklariert werden, nicht <code>public</code> oder <code>protected</code> . <br>  In Anbetracht des Prinzips der Offenheit und Nähe ist der Grund für eine solche Konvention verständlich.  Wenn sich Klassenmitgliedsvariablen ändern, muss sich jede von ihnen abhängige Funktion ändern.  Das heißt, die Funktion wird nicht aufgrund von Änderungen an diesen Variablen geschlossen. </p><br><p>  In OOP erwarten wir, dass die Methoden einer Klasse nicht für Änderungen in Variablen geschlossen sind, die Mitglieder dieser Klasse sind.  Wir erwarten jedoch, dass jede andere Klasse, einschließlich Unterklassen, wegen Änderungen an diesen Variablen geschlossen wird.  Dies wird als Kapselung bezeichnet. </p><br><p>  Aber was ist, wenn Sie eine Variable haben, von der Sie sicher sind, dass sie sich niemals ändern wird?  Ist es sinnvoll, es <code>private</code> zu machen?  In Listing 7 wird beispielsweise die <code>Device</code> angezeigt, die den <code>bool status</code> des variablen Mitglieds enthält.  Es speichert den Status der letzten Operation.  Wenn der Vorgang erfolgreich war, ist der Wert der Statusvariablen <code>true</code> , andernfalls <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Wir wissen, dass sich der Typ oder die Bedeutung dieser Variablen niemals ändern wird.  Warum also nicht <code>public</code> und dem Kunden direkten Zugriff darauf gewähren?  Wenn sich die Variable wirklich nie ändert, wenn alle Clients die Regeln befolgen und nur aus dieser Variablen lesen, ist nichts falsch daran, dass die Variable öffentlich ist.  Überlegen Sie jedoch, was passieren wird, wenn einer der Clients die Gelegenheit nutzt, in diese Variable zu schreiben und ihren Wert zu ändern. </p><br><p>  Plötzlich kann dieser Client den Betrieb eines anderen Clients der <code>Device</code> beeinträchtigen.  Dies bedeutet, dass es unmöglich ist, Clients der <code>Device</code> vor Änderungen an diesem falschen Modul zu schließen.  Das ist zu viel Risiko. </p><br><p>  Nehmen wir andererseits an, wir haben die in Listing 8 gezeigte Zeitklasse. Welche Gefahr besteht für die Veröffentlichung der Variablen, die Mitglieder dieser Klasse sind?  Es ist sehr unwahrscheinlich, dass sie sich ändern werden.  Darüber hinaus spielt es keine Rolle, ob die Client-Module die Werte dieser Variablen ändern oder nicht, da eine Änderung dieser Variablen angenommen wird.  Es ist auch sehr unwahrscheinlich, dass geerbte Klassen vom Wert einer bestimmten Mitgliedsvariablen abhängen können.  Gibt es also ein Problem? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  Die einzige Beschwerde, die ich gegen den Code in Listing 8 machen könnte, ist, dass die Zeitänderung nicht atomar ist.  Das heißt, der Client kann den Wert der Minutenvariablen ändern, ohne den Wert der <code>hours</code> zu ändern.  Dies kann dazu führen, dass ein Objekt der Zeitklasse inkonsistente Daten enthält.  Ich würde es vorziehen, eine einzige Funktion zum Einstellen der Zeit einzuführen, die drei Argumente benötigt, wodurch das Einstellen der Zeit zu einer atomaren Operation wird.  Dies ist jedoch ein schwaches Argument. </p><br><p>  Es ist leicht, andere Bedingungen zu finden, unter denen die Veröffentlichung dieser Variablen zu Problemen führen kann.  Letztendlich gibt es jedoch keinen überzeugenden Grund, sie <code>private</code> zu machen.  Ich denke immer noch, dass es ein schlechter Stil ist, solche Variablen öffentlich zu machen, aber vielleicht ist es kein schlechtes Design.  Ich glaube, dass dies ein schlechter Stil ist, da es fast nichts kostet, die entsprechenden Funktionen für den Zugriff auf diese Mitglieder einzugeben, und es sich definitiv lohnt, sich vor dem geringen Risiko zu schützen, das mit dem möglichen Auftreten von Problemen beim Schließen verbunden ist. </p><br><p>  In solchen seltenen Fällen, in denen das Prinzip der Offenheit nicht verletzt wird, hängt das Verbot <code>public</code> und <code>protected</code> Variablen daher mehr vom Stil und nicht vom Inhalt ab. </p><br><h2>  Keine globalen Variablen ... überhaupt nicht! </h2><br><p>  Das Argument gegen globale Variablen ist dasselbe wie das Argument gegen öffentliche Mitgliedsvariablen.  Kein Modul, das von einer globalen Variablen abhängt, kann von einem Modul geschlossen werden, das darauf schreiben kann.  Jedes Modul, das diese Variable auf eine Weise verwendet, die nicht von anderen Modulen beabsichtigt ist, bricht diese Module.  Es ist zu riskant, viele Module zu haben, abhängig von den Unwägbarkeiten eines einzelnen bösartigen Moduls. <br>  Andererseits schaden globale Variablen in Fällen, in denen eine geringe Anzahl von Modulen von ihnen abhängt oder nicht falsch verwendet werden kann, nicht.  Der Designer muss bewerten, wie viel Datenschutz geopfert wird, und feststellen, ob sich die Bequemlichkeit der globalen Variablen lohnt. </p><br><p>  Auch hier kommen Stilprobleme ins Spiel.  Alternativen zur Verwendung globaler Variablen sind normalerweise kostengünstig.  In solchen Fällen ist die Verwendung einer Technik, die zwar ein geringes, aber ein Risiko für den Verschluss einführt, anstelle einer Technik, die ein solches Risiko vollständig ausschließt, ein Zeichen für einen schlechten Stil.  Manchmal ist es jedoch sehr praktisch, globale Variablen zu verwenden.  Ein typisches Beispiel sind die globalen Variablen cout und cin.  In solchen Fällen können Sie den Stil der Einfachheit halber opfern, wenn das Prinzip der Offenheit und Nähe nicht verletzt wird. </p><br><h2>  RTTI ist gefährlich </h2><br><p>  Ein weiteres häufiges Verbot ist die Verwendung von <code>dynamic_cast</code> .  Sehr oft wird <code>dynamic_cast</code> oder eine andere Form der Laufzeittypbestimmung (RTTI) als äußerst gefährliche Technik beschuldigt und sollte daher vermieden werden.  Gleichzeitig geben sie häufig ein Beispiel aus Listing 9 an, das offensichtlich gegen das Prinzip der Offenheit und Nähe verstößt.  Listing 10 zeigt jedoch ein Beispiel für ein ähnliches Programm, das <code>dynamic_cast</code> ohne das Open-Close-Prinzip zu verletzen. </p><br><p>  Der Unterschied zwischen ihnen besteht darin, dass im ersten Fall, der in Listing 9 gezeigt wird, der Code jedes Mal geändert werden muss, wenn ein neuer Nachkomme der <code>Shape</code> Klasse erscheint (ganz zu schweigen davon, dass dies eine absolut lächerliche Lösung ist).  In Listing 10 sind in diesem Fall jedoch keine Änderungen erforderlich.  Daher verstößt der Code in Listing 10 nicht gegen das Open-Close-Prinzip. <br>  In diesem Fall gilt als Faustregel, dass RTTI verwendet werden kann, wenn das Prinzip der Offenheitsschließung nicht verletzt wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Fazit </h1><br><p>  Ich konnte lange über das Prinzip der Offenheit und Nähe sprechen.  In vielerlei Hinsicht ist dieses Prinzip für die objektorientierte Programmierung am wichtigsten.  Die Einhaltung dieses speziellen Prinzips bietet die Hauptvorteile der objektorientierten Technologie, nämlich Wiederverwendung und Support. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472186/">https://habr.com/ru/post/de472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472174/index.html">Persönlichkeit und Klang: Paul Voight - „Sennheiser 30s“, der Vater von Breitband, einer mechanischen Frequenzweiche und Übertragungsleitungen</a></li>
<li><a href="../de472176/index.html">Virtuelles Puschkin-Museum</a></li>
<li><a href="../de472178/index.html">Holivar. Geschichte von Runet. Teil 7. YouTube: Comedians, Squeaks und Silicon Valley</a></li>
<li><a href="../de472182/index.html">Ankündigung von .NET Core 3.1 Vorschau 1</a></li>
<li><a href="../de472184/index.html">Remote SSH: Tipps und Tricks</a></li>
<li><a href="../de472188/index.html">Was Sie über die Überprüfung des App Store-Checks wissen müssen (App Store-Quittung)</a></li>
<li><a href="../de472190/index.html">Führen Sie PHP-Skripte über php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube)</a></li>
<li><a href="../de472196/index.html">Selbst gemachter "Zucker" für ein Android-Projekt oder "Wie man es nicht macht"</a></li>
<li><a href="../de472198/index.html">Lokalisierung von Push-Nachrichten in mobilen Anwendungen</a></li>
<li><a href="../de472200/index.html">Modernisierung des Informatikunterrichts an einer russischen Schule auf einer Himbeere: billig und fröhlich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>