<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèΩ ü§üüèº üòø Open-Closed-Prinzip üåá üèè üîª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Hier ist eine √úbersetzung eines Artikels von Robert Martin √ºber das Open-Closed-Prinzip , den er im Januar 1996 ver√∂ffentlichte. Der Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Open-Closed-Prinzip</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Hallo Habr!  Hier ist eine √úbersetzung eines Artikels von Robert Martin √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20060822033314/">Open-Closed-Prinzip</a> , den er im Januar 1996 ver√∂ffentlichte.  Der Artikel ist, gelinde gesagt, nicht der neueste.  Aber in RuNet werden Onkel Bobs Artikel √ºber SOLID nur in abgeschnittener Form nacherz√§hlt, sodass ich dachte, dass eine vollst√§ndige √úbersetzung nicht √ºberfl√ºssig w√§re. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Ich habe mich entschlossen, mit dem Buchstaben O zu beginnen, da das Prinzip der Offenheitsschlie√üung tats√§chlich von zentraler Bedeutung ist.  Unter anderem gibt es viele wichtige Feinheiten, die es wert sind, beachtet zu werden: </p><br><ul><li>  Kein Programm kann zu 100% "geschlossen" werden. </li><li>  Objektorientierte Programmierung (OOP) arbeitet nicht mit physischen Objekten der realen Welt, sondern mit Konzepten - zum Beispiel dem Konzept der "Ordnung". <a name="habracut"></a></li></ul><br><p>  Dies ist der erste Artikel in meiner Spalte " <em>Engineer Notes"</em> f√ºr <em>den C ++ - Bericht</em> .  Die in dieser Spalte ver√∂ffentlichten Artikel konzentrieren sich auf die Verwendung von C ++ und OOP und gehen auf die Schwierigkeiten bei der Softwareentwicklung ein.  Ich werde versuchen, die Materialien f√ºr praktizierende Ingenieure pragmatisch und n√ºtzlich zu machen.  Zur Dokumentation des objektorientierten Designs in diesen Artikeln werde ich die Buch-Notation verwenden. </p><br><p>  Mit der objektorientierten Programmierung sind viele Heuristiken verbunden.  Beispiel: "Alle Mitgliedsvariablen m√ºssen privat sein" oder "Globale Variablen sollten vermieden werden" oder "Typbestimmung zur Laufzeit ist gef√§hrlich".  Was ist der Grund f√ºr solche Heuristiken?  Warum sind sie wahr?  Sind sie <em>immer</em> wahr?  In dieser Spalte wird das diesen Heuristiken zugrunde liegende Entwurfsprinzip untersucht - das Prinzip des Offenheitsverschlusses. <br>  Ivar Jacobson sagte: ‚ÄûAlle Systeme √§ndern sich w√§hrend des Lebenszyklus.  Dies muss beim Entwurf eines Systems ber√ºcksichtigt werden, f√ºr das mehr als eine Version erwartet wird. ‚Äú  Wie k√∂nnen wir ein System so gestalten, dass es angesichts von Ver√§nderungen stabil ist und mehr als eine Version erwartet wird?  Bertrand Meyer erz√§hlte uns davon bereits 1988, als das mittlerweile ber√ºhmte Prinzip der Offenheit und N√§he formuliert wurde: </p><br><p>  <strong>Programmentit√§ten (Klassen, Module, Funktionen usw.) m√ºssen zur Erweiterung ge√∂ffnet und f√ºr √Ñnderungen geschlossen sein.</strong> </p><br><p>  Wenn eine √Ñnderung im Programm eine Kaskade von √Ñnderungen in den abh√§ngigen Modulen zur Folge hat, zeigt das Programm unerw√ºnschte Anzeichen eines ‚Äûschlechten‚Äú Designs an. </p><br><p>  Das Programm wird zerbrechlich, unflexibel, unvorhersehbar und unbenutzt.  Das Prinzip der Offenheit und N√§he l√∂st diese Probleme auf sehr einfache Weise.  Er sagt, dass es notwendig ist, Module zu entwerfen, die sich nie <em>√§ndern</em> .  Wenn sich die Anforderungen √§ndern, m√ºssen Sie das Verhalten solcher Module erweitern, indem Sie neuen Code hinzuf√ºgen, anstatt den alten, bereits funktionierenden Code zu √§ndern. </p><br><h1>  Beschreibung </h1><br><p>  Module, die das Prinzip der Offenheit und N√§he erf√ºllen, weisen zwei Hauptmerkmale auf: </p><br><ol><li>  <strong>Zur Erweiterung √∂ffnen.</strong>  Dies bedeutet, dass das Verhalten des Moduls erweitert werden kann.  Das hei√üt, wir k√∂nnen dem Modul ein neues Verhalten hinzuf√ºgen, das den sich √§ndernden Anforderungen f√ºr die Anwendung entspricht oder den Anforderungen neuer Anwendungen entspricht. </li><li> <strong>Wegen √Ñnderung geschlossen.</strong>  Der Quellcode eines solchen Moduls ist unantastbar.  Niemand hat das Recht, √Ñnderungen daran vorzunehmen. </li></ol><br><p>  Es scheint, dass diese beiden Zeichen nicht zusammenpassen.  Die Standardmethode zum Erweitern des Verhaltens eines Moduls besteht darin, √Ñnderungen daran vorzunehmen.  Ein Modul, das nicht ge√§ndert werden kann, wird normalerweise als Modul mit festem Verhalten betrachtet.  Wie k√∂nnen diese beiden entgegengesetzten Bedingungen erf√ºllt werden? </p><br><h1>  Der Schl√ºssel zur L√∂sung ist die Abstraktion. </h1><br><p>  In C ++ ist es unter Verwendung der Prinzipien des objektorientierten Entwurfs m√∂glich, feste Abstraktionen zu erstellen, die eine unbegrenzte Anzahl m√∂glicher Verhaltensweisen darstellen k√∂nnen. </p><br><p>  Abstraktionen sind abstrakte Basisklassen, und eine unbegrenzte Anzahl m√∂glicher Verhaltensweisen wird durch alle m√∂glichen Nachfolgeklassen dargestellt.  Ein Modul kann die Abstraktion manipulieren.  Ein solches Modul ist wegen √Ñnderungen geschlossen, da es von einer festen Abstraktion abh√§ngt.  Das Verhalten des Moduls kann auch erweitert werden, indem neue Nachkommen der Abstraktion erstellt werden. </p><br><p> Das folgende Diagramm zeigt eine einfache Entwurfsoption, die dem Prinzip der Offenheit und N√§he nicht entspricht.  Beide Klassen, <code>Client</code> und <code>Server</code> , sind nicht abstrakt.  Es gibt keine Garantie daf√ºr, dass Funktionen, die Mitglieder der <code>Server</code> sind, virtuell sind.  Die <code>Client</code> Klasse verwendet die <code>Server</code> Klasse.  Wenn das <code>Client</code> Klassenobjekt ein anderes Serverobjekt verwenden soll, m√ºssen wir die <code>Client</code> Klasse so √§ndern, dass sie auf die neue Serverklasse verweist. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="Bild"><br>  <em>Geschlossener Client</em> </p><br><p>  Das folgende Diagramm zeigt die entsprechende Gestaltungsm√∂glichkeit, die dem Prinzip der Offenheit-N√§he entspricht.  In diesem Fall ist die <code>AbstractServer</code> Klasse eine abstrakte Klasse, deren Elementfunktionen virtuell sind.  Die <code>Client</code> Klasse verwendet die Abstraktion.  Objekte der <code>Client</code> Klasse verwenden jedoch Objekte der <code>Server</code> Nachfolgerklasse.  Wenn Objekte der <code>Client</code> Klasse eine andere Serverklasse verwenden sollen, f√ºhren wir einen neuen Nachkommen der <code>AbstractServer</code> Klasse ein.  Die <code>Client</code> Klasse bleibt unver√§ndert. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="Bild"><br>  <em>Client √∂ffnen</em> </p><br><h1>  <code>Shape</code> abstrakt </h1><br><p>  Stellen Sie sich eine Anwendung vor, die Kreise und Quadrate in einer Standard-GUI zeichnen soll.  Kreise und Quadrate m√ºssen in einer bestimmten Reihenfolge gezeichnet werden.  In der entsprechenden Reihenfolge wird eine Liste von Kreisen und Quadraten erstellt. Das Programm sollte diese Liste in der Reihenfolge durchgehen und jeden Kreis oder jedes Quadrat zeichnen. </p><br><p>  In C k√∂nnten wir mit prozeduralen Programmiertechniken, die nicht dem Open-Close-Prinzip entsprechen, dieses Problem l√∂sen, wie in Listing 1 gezeigt. Hier sehen wir viele Datenstrukturen mit demselben ersten Element.  Dieses Element ist ein Typcode, der die Datenstruktur als Kreis oder Quadrat identifiziert.  Die <code>DrawAllShapes</code> Funktion durchl√§uft ein Array von Zeigern auf diese Datenstrukturen, erkennt den Typcode und ruft dann die entsprechende Funktion ( <code>DrawCircle</code> oder <code>DrawSquare</code> ) auf. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  Die <code>DrawAllShapes</code> Funktion <code>DrawAllShapes</code> nicht das Prinzip des Offenheitsschlusses, da sie nicht aus neuen Formen geschlossen werden kann.  Wenn ich diese Funktion um die M√∂glichkeit erweitern m√∂chte, Formen aus einer Liste mit Dreiecken zu zeichnen, muss ich die Funktion √§ndern.  Tats√§chlich muss ich die Funktion f√ºr jeden neuen Formtyp √§ndern, den ich zeichnen muss. </p><br><p>  Nat√ºrlich ist dieses Programm nur ein Beispiel.  Im wirklichen Leben w√ºrde der <code>switch</code> aus der <code>DrawAllShapes</code> Funktion in verschiedenen Funktionen in der gesamten Anwendung immer wieder wiederholt, und jeder w√ºrde etwas anderes tun.  Das Hinzuf√ºgen neuer Formen zu einer solchen Anwendung bedeutet, alle Stellen zu finden, an denen solche <code>switch</code> (oder <code>if/else</code> Ketten) verwendet werden, und jeder von ihnen eine neue Form hinzuzuf√ºgen.  Dar√ºber hinaus ist es sehr unwahrscheinlich, dass alle <code>switch</code> und <code>if/else</code> Ketten so gut strukturiert sind wie in <code>DrawAllShapes</code> .  Es ist viel wahrscheinlicher, dass Pr√§dikate angeben, <code>if</code> mit logischen Operatoren kombiniert werden oder <code>if</code> <code>case</code> von <code>switch</code> so kombiniert werden, dass eine bestimmte Stelle im Code ‚Äûvereinfacht‚Äú wird.  Daher kann das Problem, alle Stellen zu finden und zu verstehen, an denen Sie eine neue Figur hinzuf√ºgen m√ºssen, nicht trivial sein. </p><br><p>  In Listing 2 werde ich Code zeigen, der eine Quadrat- / Kreisl√∂sung demonstriert, die dem Prinzip des Offenheitsschlusses entspricht.  Eine abstrakte <code>Shape</code> wird eingef√ºhrt.  Diese abstrakte Klasse enth√§lt eine reine virtuelle <code>Draw</code> .  Die Klassen <code>Circle</code> und <code>Square</code> sind Nachkommen der <code>Shape</code> Klasse. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Beachten Sie, dass wir nur einen neuen Nachkommen der <code>Shape</code> Klasse hinzuf√ºgen m√ºssen, wenn wir das Verhalten der <code>DrawAllShapes</code> Funktion in Listing 2 erweitern m√∂chten, um eine neue Art von Form zu zeichnen.  Die <code>DrawAllShapes</code> Funktion muss nicht <code>DrawAllShapes</code> werden.  Daher erf√ºllt <code>DrawAllShapes</code> das Prinzip der Offenheit und N√§he.  Sein Verhalten kann erweitert werden, ohne die Funktion selbst zu √§ndern. </p><br><p>  In der realen Welt w√ºrde die <code>Shape</code> Klasse viele andere Methoden enthalten.  Das Hinzuf√ºgen einer neuen Form zur Anwendung ist jedoch immer noch sehr einfach, da Sie lediglich einen neuen Erben eingeben und diese Funktionen implementieren m√ºssen.  Sie m√ºssen nicht die gesamte Anwendung nach Orten durchsuchen, an denen √Ñnderungen erforderlich sind. </p><br><p>  Daher werden Programme, die dem Prinzip der Offenheit und N√§he entsprechen, durch Hinzuf√ºgen neuen Codes und nicht durch √Ñndern des vorhandenen Codes ge√§ndert. Sie kaskadieren keine √Ñnderungen, die f√ºr Programme charakteristisch sind, die diesem Prinzip nicht entsprechen. </p><br><h1>  Closed-Entry-Strategie </h1><br><p>  Offensichtlich kann kein Programm zu 100% geschlossen werden.  Was passiert beispielsweise mit der Funktion <code>DrawAllShapes</code> in Listing 2, wenn wir entscheiden, dass zuerst Kreise und dann Quadrate gezeichnet werden sollen?  Die <code>DrawAllShapes</code> Funktion <code>DrawAllShapes</code> bei dieser Art von √Ñnderung nicht geschlossen.  Im Allgemeinen spielt es keine Rolle, wie "geschlossen" das Modul ist, es gibt immer eine Art von √Ñnderung, von der es nicht geschlossen wird. </p><br><p>  Da die Schlie√üung nicht vollst√§ndig sein kann, muss sie strategisch eingef√ºhrt werden.  Das hei√üt, der Designer muss die Arten von √Ñnderungen ausw√§hlen, aus denen das Programm geschlossen wird.  Dies erfordert einige Erfahrung.  Ein erfahrener Entwickler kennt Benutzer und Branche gut genug, um die Wahrscheinlichkeit verschiedener √Ñnderungen zu berechnen.  Er stellt dann sicher, dass das Prinzip der Offenheit und N√§he f√ºr die wahrscheinlichsten √Ñnderungen eingehalten wird. </p><br><h2>  Verwendung der Abstraktion, um zus√§tzliche N√§he zu erreichen </h2><br><p>  Wie k√∂nnen wir die <code>DrawAllShapes</code> Funktion aufgrund von √Ñnderungen in der Zeichnungsreihenfolge schlie√üen?  Denken Sie daran, dass der Abschluss auf Abstraktion basiert.  Um <code>DrawAllShapes</code> von der Bestellung <code>DrawAllShapes</code> , ben√∂tigen wir daher eine Art ‚ÄûOrdnungsabstraktion‚Äú.  Ein oben dargestellter Sonderfall der Bestellung ist das Zeichnen von Figuren eines Typs vor Figuren eines anderen Typs. </p><br><p>  Die Bestellrichtlinie impliziert, dass Sie mit zwei Objekten festlegen k√∂nnen, welches zuerst gezeichnet werden soll.  Daher k√∂nnen wir eine Methode f√ºr die <code>Shape</code> Klasse mit dem Namen <code>Precedes</code> , die ein anderes <code>Shape</code> Objekt als Argument verwendet und den Booleschen Wert <code>true</code> zur√ºckgibt <code>true</code> wenn das <code>Shape</code> Objekt, das diese Nachricht empfangen hat, vor dem <code>Shape</code> Objekt sortiert werden muss als Argument √ºbergeben. </p><br><p>  In C ++ kann diese Funktion als √úberladung des Operators "&lt;" dargestellt werden.  Listing 3 zeigt die <code>Shape</code> Klasse mit Sortiermethoden. </p><br><p>  Nachdem wir nun die M√∂glichkeit haben, die Reihenfolge der Objekte der <code>Shape</code> Klasse zu bestimmen, k√∂nnen wir sie sortieren und dann zeichnen.  Listing 4 zeigt den entsprechenden C ++ - Code.  Es verwendet die Klassen <code>Set</code> , <code>OrderedSet</code> und <code>Iterator</code> aus der Kategorie <code>Components</code> die in meinem Buch entwickelt wurden (Entwerfen objektorientierter C ++ - Anwendungen mit der Booch-Methode, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Daher haben wir die Reihenfolge der Objekte der <code>Shape</code> Klasse implementiert und sie in der entsprechenden Reihenfolge gezeichnet.  Aber wir haben immer noch keine Implementierung der Abstraktion der Ordnung.  Offensichtlich muss jedes <code>Shape</code> Objekt die <code>Precedes</code> Methode √ºberschreiben, um die Reihenfolge zu bestimmen.  Wie kann das funktionieren?  Welcher Code muss in <code>Circle::Precedes</code> werden, damit Kreise zu Quadraten gezeichnet werden?  Achten Sie auf Listing 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Es ist klar, dass diese Funktion nicht dem Prinzip der Offenheit-N√§he entspricht.  Es gibt keine M√∂glichkeit, es vor den neuen Nachkommen der <code>Shape</code> Klasse zu schlie√üen.  Jedes Mal, wenn ein neuer Nachkomme der <code>Shape</code> Klasse angezeigt wird, muss diese Funktion ge√§ndert werden. </p><br><h2>  Verwenden eines datengesteuerten Ansatzes zum Schlie√üen </h2><br><p>  Die N√§he der Erben der <code>Shape</code> Klasse kann mithilfe eines tabellarischen Ansatzes erreicht werden, der nicht zu √Ñnderungen in jeder geerbten Klasse f√ºhrt.  Ein Beispiel f√ºr diesen Ansatz ist in Listing 6 dargestellt. </p><br><p>  Mit diesem Ansatz haben wir die <code>DrawAllShapes</code> Funktion erfolgreich <code>DrawAllShapes</code> von √Ñnderungen in Bezug auf die Reihenfolge und jedem Nachkommen der <code>Shape</code> Klasse geschlossen - aufgrund der Einf√ºhrung eines neuen Nachkommen oder aufgrund einer √Ñnderung der Ordnungsrichtlinie f√ºr Objekte der <code>Shape</code> Klasse in Abh√§ngigkeit von ihrem Typ (z. B. Objekte der <code>Squares</code> Klasse) zuerst gezeichnet werden). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  Das einzige Element, das nicht daran gehindert wird, die Reihenfolge der Zeichnungsformen zu √§ndern, ist eine Tabelle.  Die Tabelle kann in einem separaten Modul platziert werden, das von allen anderen Modulen getrennt ist. Daher wirken sich die √Ñnderungen nicht auf andere Module aus. </p><br><h2>  Weitere Schlie√üung </h2><br><p>  Dies ist nicht das Ende der Geschichte.  Wir haben die Hierarchie der <code>Shape</code> Klasse und der <code>DrawAllShapes</code> Funktion geschlossen, um die Ordnungsrichtlinie basierend auf dem <code>DrawAllShapes</code> √§ndern.  Die Nachkommen der <code>Shape</code> Klasse werden jedoch nicht von Ordnungsrichtlinien ausgeschlossen, die keinen Formtypen zugeordnet sind.  Es scheint, dass wir das Zeichnen von Formen nach einer √ºbergeordneten Struktur anordnen m√ºssen.  Eine vollst√§ndige Untersuchung solcher Probleme w√ºrde den Rahmen dieses Artikels sprengen.  Ein interessierter Leser k√∂nnte jedoch dar√ºber nachdenken, wie dieses Problem mithilfe der abstrakten <code>OrderedObject</code> Klasse <code>OrderedShape</code> , die in der <code>OrderedShape</code> Klasse enthalten ist, die von den <code>OrderedObject</code> und <code>OrderedObject</code> erbt. </p><br><h1>  Heuristiken und Konventionen </h1><br><p>  Wie bereits am Anfang des Artikels erw√§hnt, ist das Prinzip der Offenheit und N√§he die Hauptmotivation f√ºr viele Heuristiken und Konventionen, die sich im Laufe der vielen Jahre der Entwicklung des OOP-Paradigmas herausgebildet haben.  Das Folgende sind die wichtigsten. </p><br><h2>  Machen Sie alle Mitgliedsvariablen privat </h2><br><p>  Dies ist eine der dauerhaftesten Konventionen der PLO.  Mitgliedsvariablen sollten nur den Methoden der Klasse bekannt sein, in der sie definiert sind.  Variable Mitglieder sollten anderen Klassen, einschlie√ülich abgeleiteten Klassen, nicht bekannt sein.  Daher m√ºssen sie mit einem <code>private</code> Zugriffsmodifikator deklariert werden, nicht <code>public</code> oder <code>protected</code> . <br>  In Anbetracht des Prinzips der Offenheit und N√§he ist der Grund f√ºr eine solche Konvention verst√§ndlich.  Wenn sich Klassenmitgliedsvariablen √§ndern, muss sich jede von ihnen abh√§ngige Funktion √§ndern.  Das hei√üt, die Funktion wird nicht aufgrund von √Ñnderungen an diesen Variablen geschlossen. </p><br><p>  In OOP erwarten wir, dass die Methoden einer Klasse nicht f√ºr √Ñnderungen in Variablen geschlossen sind, die Mitglieder dieser Klasse sind.  Wir erwarten jedoch, dass jede andere Klasse, einschlie√ülich Unterklassen, wegen √Ñnderungen an diesen Variablen geschlossen wird.  Dies wird als Kapselung bezeichnet. </p><br><p>  Aber was ist, wenn Sie eine Variable haben, von der Sie sicher sind, dass sie sich niemals √§ndern wird?  Ist es sinnvoll, es <code>private</code> zu machen?  In Listing 7 wird beispielsweise die <code>Device</code> angezeigt, die den <code>bool status</code> des variablen Mitglieds enth√§lt.  Es speichert den Status der letzten Operation.  Wenn der Vorgang erfolgreich war, ist der Wert der Statusvariablen <code>true</code> , andernfalls <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Wir wissen, dass sich der Typ oder die Bedeutung dieser Variablen niemals √§ndern wird.  Warum also nicht <code>public</code> und dem Kunden direkten Zugriff darauf gew√§hren?  Wenn sich die Variable wirklich nie √§ndert, wenn alle Clients die Regeln befolgen und nur aus dieser Variablen lesen, ist nichts falsch daran, dass die Variable √∂ffentlich ist.  √úberlegen Sie jedoch, was passieren wird, wenn einer der Clients die Gelegenheit nutzt, in diese Variable zu schreiben und ihren Wert zu √§ndern. </p><br><p>  Pl√∂tzlich kann dieser Client den Betrieb eines anderen Clients der <code>Device</code> beeintr√§chtigen.  Dies bedeutet, dass es unm√∂glich ist, Clients der <code>Device</code> vor √Ñnderungen an diesem falschen Modul zu schlie√üen.  Das ist zu viel Risiko. </p><br><p>  Nehmen wir andererseits an, wir haben die in Listing 8 gezeigte Zeitklasse. Welche Gefahr besteht f√ºr die Ver√∂ffentlichung der Variablen, die Mitglieder dieser Klasse sind?  Es ist sehr unwahrscheinlich, dass sie sich √§ndern werden.  Dar√ºber hinaus spielt es keine Rolle, ob die Client-Module die Werte dieser Variablen √§ndern oder nicht, da eine √Ñnderung dieser Variablen angenommen wird.  Es ist auch sehr unwahrscheinlich, dass geerbte Klassen vom Wert einer bestimmten Mitgliedsvariablen abh√§ngen k√∂nnen.  Gibt es also ein Problem? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  Die einzige Beschwerde, die ich gegen den Code in Listing 8 machen k√∂nnte, ist, dass die Zeit√§nderung nicht atomar ist.  Das hei√üt, der Client kann den Wert der Minutenvariablen √§ndern, ohne den Wert der <code>hours</code> zu √§ndern.  Dies kann dazu f√ºhren, dass ein Objekt der Zeitklasse inkonsistente Daten enth√§lt.  Ich w√ºrde es vorziehen, eine einzige Funktion zum Einstellen der Zeit einzuf√ºhren, die drei Argumente ben√∂tigt, wodurch das Einstellen der Zeit zu einer atomaren Operation wird.  Dies ist jedoch ein schwaches Argument. </p><br><p>  Es ist leicht, andere Bedingungen zu finden, unter denen die Ver√∂ffentlichung dieser Variablen zu Problemen f√ºhren kann.  Letztendlich gibt es jedoch keinen √ºberzeugenden Grund, sie <code>private</code> zu machen.  Ich denke immer noch, dass es ein schlechter Stil ist, solche Variablen √∂ffentlich zu machen, aber vielleicht ist es kein schlechtes Design.  Ich glaube, dass dies ein schlechter Stil ist, da es fast nichts kostet, die entsprechenden Funktionen f√ºr den Zugriff auf diese Mitglieder einzugeben, und es sich definitiv lohnt, sich vor dem geringen Risiko zu sch√ºtzen, das mit dem m√∂glichen Auftreten von Problemen beim Schlie√üen verbunden ist. </p><br><p>  In solchen seltenen F√§llen, in denen das Prinzip der Offenheit nicht verletzt wird, h√§ngt das Verbot <code>public</code> und <code>protected</code> Variablen daher mehr vom Stil und nicht vom Inhalt ab. </p><br><h2>  Keine globalen Variablen ... √ºberhaupt nicht! </h2><br><p>  Das Argument gegen globale Variablen ist dasselbe wie das Argument gegen √∂ffentliche Mitgliedsvariablen.  Kein Modul, das von einer globalen Variablen abh√§ngt, kann von einem Modul geschlossen werden, das darauf schreiben kann.  Jedes Modul, das diese Variable auf eine Weise verwendet, die nicht von anderen Modulen beabsichtigt ist, bricht diese Module.  Es ist zu riskant, viele Module zu haben, abh√§ngig von den Unw√§gbarkeiten eines einzelnen b√∂sartigen Moduls. <br>  Andererseits schaden globale Variablen in F√§llen, in denen eine geringe Anzahl von Modulen von ihnen abh√§ngt oder nicht falsch verwendet werden kann, nicht.  Der Designer muss bewerten, wie viel Datenschutz geopfert wird, und feststellen, ob sich die Bequemlichkeit der globalen Variablen lohnt. </p><br><p>  Auch hier kommen Stilprobleme ins Spiel.  Alternativen zur Verwendung globaler Variablen sind normalerweise kosteng√ºnstig.  In solchen F√§llen ist die Verwendung einer Technik, die zwar ein geringes, aber ein Risiko f√ºr den Verschluss einf√ºhrt, anstelle einer Technik, die ein solches Risiko vollst√§ndig ausschlie√üt, ein Zeichen f√ºr einen schlechten Stil.  Manchmal ist es jedoch sehr praktisch, globale Variablen zu verwenden.  Ein typisches Beispiel sind die globalen Variablen cout und cin.  In solchen F√§llen k√∂nnen Sie den Stil der Einfachheit halber opfern, wenn das Prinzip der Offenheit und N√§he nicht verletzt wird. </p><br><h2>  RTTI ist gef√§hrlich </h2><br><p>  Ein weiteres h√§ufiges Verbot ist die Verwendung von <code>dynamic_cast</code> .  Sehr oft wird <code>dynamic_cast</code> oder eine andere Form der Laufzeittypbestimmung (RTTI) als √§u√üerst gef√§hrliche Technik beschuldigt und sollte daher vermieden werden.  Gleichzeitig geben sie h√§ufig ein Beispiel aus Listing 9 an, das offensichtlich gegen das Prinzip der Offenheit und N√§he verst√∂√üt.  Listing 10 zeigt jedoch ein Beispiel f√ºr ein √§hnliches Programm, das <code>dynamic_cast</code> ohne das Open-Close-Prinzip zu verletzen. </p><br><p>  Der Unterschied zwischen ihnen besteht darin, dass im ersten Fall, der in Listing 9 gezeigt wird, der Code jedes Mal ge√§ndert werden muss, wenn ein neuer Nachkomme der <code>Shape</code> Klasse erscheint (ganz zu schweigen davon, dass dies eine absolut l√§cherliche L√∂sung ist).  In Listing 10 sind in diesem Fall jedoch keine √Ñnderungen erforderlich.  Daher verst√∂√üt der Code in Listing 10 nicht gegen das Open-Close-Prinzip. <br>  In diesem Fall gilt als Faustregel, dass RTTI verwendet werden kann, wenn das Prinzip der Offenheitsschlie√üung nicht verletzt wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Fazit </h1><br><p>  Ich konnte lange √ºber das Prinzip der Offenheit und N√§he sprechen.  In vielerlei Hinsicht ist dieses Prinzip f√ºr die objektorientierte Programmierung am wichtigsten.  Die Einhaltung dieses speziellen Prinzips bietet die Hauptvorteile der objektorientierten Technologie, n√§mlich Wiederverwendung und Support. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472186/">https://habr.com/ru/post/de472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472174/index.html">Pers√∂nlichkeit und Klang: Paul Voight - ‚ÄûSennheiser 30s‚Äú, der Vater von Breitband, einer mechanischen Frequenzweiche und √úbertragungsleitungen</a></li>
<li><a href="../de472176/index.html">Virtuelles Puschkin-Museum</a></li>
<li><a href="../de472178/index.html">Holivar. Geschichte von Runet. Teil 7. YouTube: Comedians, Squeaks und Silicon Valley</a></li>
<li><a href="../de472182/index.html">Ank√ºndigung von .NET Core 3.1 Vorschau 1</a></li>
<li><a href="../de472184/index.html">Remote SSH: Tipps und Tricks</a></li>
<li><a href="../de472188/index.html">Was Sie √ºber die √úberpr√ºfung des App Store-Checks wissen m√ºssen (App Store-Quittung)</a></li>
<li><a href="../de472190/index.html">F√ºhren Sie PHP-Skripte √ºber php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube)</a></li>
<li><a href="../de472196/index.html">Selbst gemachter "Zucker" f√ºr ein Android-Projekt oder "Wie man es nicht macht"</a></li>
<li><a href="../de472198/index.html">Lokalisierung von Push-Nachrichten in mobilen Anwendungen</a></li>
<li><a href="../de472200/index.html">Modernisierung des Informatikunterrichts an einer russischen Schule auf einer Himbeere: billig und fr√∂hlich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>