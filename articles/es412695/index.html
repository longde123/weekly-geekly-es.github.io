<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÇÔ∏è üèÇüèø üî∞ La imagen general de las pruebas unitarias ‚úãüèº üí™üèª üêª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta no es una gu√≠a sobre qu√© caracteres necesita ingresar en el editor de c√≥digo para obtener pruebas unitarias. Esto es alimento para la mente, que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La imagen general de las pruebas unitarias</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/412695/"><img src="https://habrastorage.org/webt/di/az/zt/diazzt3uova8gflxtil7ecuxggu.png"><br><br>  Esta no es una gu√≠a sobre qu√© caracteres necesita ingresar en el editor de c√≥digo para obtener pruebas unitarias.  Esto es alimento para la mente, que debe consumirse <b>antes de</b> tomar estas acciones. <br><br>  El tema de las pruebas unitarias no es tan simple como parece.  Muchos de nosotros, los desarrolladores, llegamos a las pruebas unitarias bajo la presi√≥n de clientes, empleados, colegas, sus √≠dolos, etc.  Comprendemos r√°pidamente su valor y, una vez finalizados los preparativos t√©cnicos, nos olvidamos de la imagen general, si es que la entendimos alguna vez.  En este art√≠culo, hablar√© brevemente sobre qu√© son las pruebas unitarias y qu√© no, tanto en general como en PHP, y al mismo tiempo describir√© qu√© lugar ocupan las pruebas unitarias en la esfera de control de calidad. <br><a name="habracut"></a><br><h2>  ¬øQu√© es la prueba? </h2><br>  Antes de profundizar en las pruebas unitarias, debe estudiar la teor√≠a de las pruebas en s√≠ para no cometer errores como los cometidos por los autores de uno de los marcos PHP m√°s populares: mostraron pruebas de integraci√≥n en su sitio web y las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamaron</a> pruebas unitarias.  No, Laravel, estas no son pruebas unitarias.  Aunque esto no me impide seguir amando este marco. <br><br>  Las pruebas de software se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definen</a> como "una investigaci√≥n realizada para proporcionar a las partes interesadas informaci√≥n sobre la calidad del producto".  Esto se opone a "las pruebas de software son un desperdicio del presupuesto del proyecto por parte de desarrolladores que no hacen nada importante y luego piden m√°s tiempo y dinero, porque" nada "puede ser muy costoso".  Nada nuevo aqu√≠. <br><br>  Aqu√≠ est√° mi breve historia de convertirse en una prueba: <br><br><ul><li>  1822 - Motor de diferencia (Charles Babbage). </li><li>  1843 - Motor anal√≠tico (Ada Lovelace). </li><li>  1878 - Edison introduce el t√©rmino "error". </li><li>  1957 - Pruebas y depuraci√≥n de programas (Charles Baker). </li><li>  1958 - El primer equipo de prueba de software (Gerald Weinberg). </li><li>  1968 - Crisis PO (Friedrich Bauer). </li><li>  D√©cada de 1970 - Modelo de cascada, modelo relacional, descomposici√≥n, an√°lisis cr√≠tico ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tutorial</a> ), dise√±o e inspecci√≥n de c√≥digo, calidad y m√©tricas, patrones de dise√±o. </li><li>  D√©cada de 1980: an√°lisis CRUD, arquitectura del sistema, autotesting, modelo V, confiabilidad, costo de calidad, m√©todos de uso, patrones de dise√±o de OOP. </li><li>  D√©cada de 1990: Scrum, pruebas de usabilidad, MoSCoW, pruebas heur√≠sticas, automatizaci√≥n de software y pruebas. </li></ul><br>  Si te relacionas con una generaci√≥n de millennials como yo, te sorprender√° que los equipos de prueba existieran MUCHO antes de que nacieras.  Detente por un momento, inhala, exhala, c√°lmate. <br>  La historia muestra c√≥mo el tipo de prueba que se consider√≥ "suficientemente buena" para las partes interesadas cambi√≥ con el tiempo.  Fases aproximadas que fueron guiadas durante las pruebas: <br><br><ul><li>  ... - 1956 depuraci√≥n </li><li>  Demostraci√≥n de 1957-1978 </li><li> 1979-1982 destrucci√≥n </li><li>  Estimaci√≥n 1983 - 1987 </li><li>  1988 - ... prevenci√≥n </li></ul><br>  Por lo tanto, las pruebas unitarias son necesarias para <b>evitar</b> discrepancias entre el proyecto y la implementaci√≥n. <br><br><h2>  ¬øQu√© es realmente probar? </h2><br>  Existen diferentes clasificaciones de pruebas de software.  Para comprender mejor el lugar de las pruebas unitarias, solo mencionar√© los enfoques m√°s extendidos. <br><br>  Las pruebas son: est√°tica y din√°mica, "caja" (caja blanca, caja negra, caja gris), niveles y tipos.  Cada enfoque utiliza diferentes criterios de clasificaci√≥n. <br><br><h2>  Pruebas est√°ticas y din√°micas. </h2><br>  Las pruebas est√°ticas se realizan sin ejecuci√≥n de c√≥digo.  Esto incluye correcci√≥n de pruebas, verificaci√≥n, revisi√≥n de c√≥digo (al observar el trabajo de otra programaci√≥n / par), an√°lisis cr√≠tico, inspecciones, etc. <br><br>  Las pruebas din√°micas para obtener los resultados correctos requieren la ejecuci√≥n del c√≥digo.  Por ejemplo, para <b>pruebas unitarias</b> , integraci√≥n, sistema, aceptaci√≥n y otras pruebas.  Es decir, las pruebas se llevan a cabo utilizando datos din√°micos, entradas y salidas. <br><br><h2>  Enfoque de caja </h2><br>  Seg√∫n este enfoque, todas las pruebas de software se dividen en tres tipos de cuadros: <br><br><ul><li>  <b>La</b> prueba de <b>recuadro blanco</b> verifica las estructuras y m√≥dulos internos, ignora la funcionalidad esperada para los usuarios finales.  Estas pueden ser pruebas API, inyecci√≥n de fallas, <b>pruebas unitarias</b> , pruebas de integraci√≥n. </li><li>  <b>Las</b> pruebas de <b>caja negra</b> est√°n m√°s interesadas en <b>lo que hace el</b> software y no en <b>c√≥mo</b> lo hace.  Esto significa que los probadores no est√°n obligados a comprender el objeto de prueba o comprender c√≥mo funciona bajo el cap√≥.  Este tipo de pruebas est√° dirigido a usuarios finales, su experiencia interactuando con una interfaz visible.  Las cajas negras incluyen pruebas basadas en modelos, pruebas de uso, tablas de transici√≥n de estado, pruebas de especificaci√≥n, etc. </li><li>  Las pruebas del tipo de " <b>caja gris</b> " est√°n dise√±adas con conocimiento de algoritmos de software y estructuras de datos (caja blanca), pero se realizan a nivel del usuario (caja negra).  Esto incluye pruebas de regresi√≥n y pruebas de patrones. </li></ul><br>  Ahora, para confundirlo, dir√© que las <b>pruebas unitarias</b> tambi√©n pueden aplicarse al "recuadro negro", ya que puede comprender el m√≥dulo que se est√° probando, pero no todo el sistema.  Aunque para m√≠ sigue siendo una "caja blanca", y sugiero que est√© de acuerdo con esto. <br><br><h2>  Niveles de prueba </h2><br>  Su n√∫mero var√≠a, generalmente en el rango de 4 a 6, y todos son √∫tiles.  Los nombres tambi√©n pueden ser diferentes, dependiendo de la cultura adoptada por la empresa, puede conocer las pruebas de "integraci√≥n" como "funcionales", las pruebas de "sistema" como "automatizadas", y as√≠ sucesivamente.  Por simplicidad, describir√© 5 niveles: <br><br><ol><li>  <b>Prueba unitaria</b> </li><li>  Pruebas de integraci√≥n. </li><li>  Prueba de interfaces de componentes. </li><li>  Prueba de sistema. </li><li>  Pruebas de aceptaci√≥n operacional. </li></ol><br>  <b>Las pruebas unitarias prueban</b> la funcionalidad de un c√≥digo en particular, generalmente una funci√≥n a la vez.  Las pruebas de integraci√≥n verifican las interfaces entre los componentes para que los m√≥dulos ensamblados juntos formen un sistema que funcione seg√∫n lo previsto.  Este es un punto importante, porque una gran cantidad de pruebas, que se llaman pruebas unitarias, en realidad son pruebas de integraci√≥n, y los desarrolladores las consideran m√≥dulos.  Si tiene la intenci√≥n de usar varios m√≥dulos, esto es probar la integraci√≥n entre ellos, no los m√≥dulos en s√≠.  La prueba de interfaces de componentes verifica los datos transferidos entre diferentes m√≥dulos.  Por ejemplo, recibimos datos del m√≥dulo 1 - verificado - transferido al m√≥dulo 2 - verificado.  La prueba del sistema es una prueba de extremo a extremo para verificar el cumplimiento de todos los requisitos.  La prueba de aceptaci√≥n operacional se realiza para verificar la preparaci√≥n operacional.  No es funcional, solo se verifica la capacidad de servicio de los servicios, si alg√∫n subsistema da√±a el medio ambiente y otros servicios. <br><br><h2>  Tipos de pruebas </h2><br>  Cada tipo de prueba, independientemente de su nivel, tambi√©n se puede dividir en otros tipos.  Hay m√°s de 20 tipos comunes.  Los mas comunes: <br><br><ul><li>  <b>Pruebas de regresi√≥n</b> . </li><li>  Pruebas de aceptaci√≥n. </li><li>  Prueba de humo </li><li>  Uat </li><li>  <b>Pruebas destructivas</b> . </li><li>  Pruebas de rendimiento. </li><li>  <b>Pruebas continuas</b> . </li><li>  Pruebas de usabilidad. </li><li>  Pruebas de seguridad. </li></ul><br>  Por el nombre, est√° claro por qu√© se pretende este o aquel tipo de prueba.  Negrita son las pruebas unitarias en PHP.  Si realmente lo desea, puede aplicar cada uno de estos t√©rminos a las pruebas unitarias.  Sin embargo, la principal variedad de pruebas unitarias son las pruebas de regresi√≥n, que verifican si todos los m√≥dulos del sistema se ejecutan correctamente despu√©s de realizar cambios en el c√≥digo. <br><br>  Ahora sabe que las pruebas unitarias son din√°micas, pertenecen a la clase de "recuadro blanco", se realizan a nivel de m√≥dulo, son pruebas de regresi√≥n, pero las pruebas modulares se pueden entender como muchos tipos de pruebas.  Entonces, ¬øqu√© son realmente las pruebas unitarias? <br><br><h2>  ¬øQu√© es la prueba unitaria? </h2><br>  Un modelo V es una representaci√≥n gr√°fica de los niveles, tipos y su prop√≥sito en el ciclo de vida de desarrollo de software. <br><br><img src="https://habrastorage.org/webt/-z/sk/ee/-zskeemvq28-zgepwlt7cbd6xjw.jpeg"><br><br>  Despu√©s de verificar y aprobar los requisitos detallados para el producto, cuando comenzaron a escribir el c√≥digo, las pruebas unitarias se convierten en la primera l√≠nea de defensa contra cualquier inconsistencia.  Por lo tanto, las empresas que entienden lo que est√°n haciendo est√°n obligando a los desarrolladores a usar pruebas unitarias o incluso TDD, ya que es mucho m√°s barato corregir errores en las etapas iniciales que en las posteriores. <br><br>  Y esto es justo.  Las pruebas unitarias tienen muchas ventajas.  Ellos son: <br><br><ul><li>  A√≠sle cada parte del programa y verifique su correcci√≥n. </li><li>  Ayuda a detectar problemas temprano. </li><li>  Hacen que los desarrolladores piensen en t√©rminos de entrada, salida y condiciones err√≥neas. </li><li>  Le dan al c√≥digo una apariencia conveniente para las pruebas, facilitan la refactorizaci√≥n futura. </li><li>  Simplifique la integraci√≥n de m√≥dulos de trabajo (!). </li><li>  Reemplazar parcialmente la documentaci√≥n t√©cnica. </li><li>  Obligado a separar la interfaz de la implementaci√≥n. </li><li>  Demuestran que el c√≥digo del m√≥dulo funciona como se esperaba (al menos matem√°ticamente). </li><li>  Se puede utilizar como conjuntos de pruebas de regresi√≥n de bajo nivel. </li><li>  Demostrar progreso en la integraci√≥n incompleta del sistema. </li><li>  Reduzca el costo de corregir errores (con TDD, a√∫n m√°s). </li><li>  Permiten mejorar la arquitectura de la aplicaci√≥n determinando la responsabilidad de los m√≥dulos. </li><li>  Si puede probarlo, puede conectarlo a su sistema. </li><li>  ¬°Las pruebas unitarias son DIVERTIDAS! </li></ul><br>  Sin embargo, hay ciertas limitaciones en las que pens√≥, probablemente al leer esta lista: <br><br><ul><li>  Las pruebas unitarias no detectan errores de integraci√≥n. </li><li>  Cada expresi√≥n booleana requiere al menos dos pruebas, y el n√∫mero crece r√°pidamente. </li><li>  Las pruebas unitarias son tan defectuosas como el c√≥digo que prueban. </li><li>  Vincular las pruebas a un par de marcos o bibliotecas espec√≠ficas puede limitar el flujo de trabajo. </li><li>  La mayor√≠a de las pruebas se escriben despu√©s de que se completa el desarrollo.  Es triste  Use TDD! </li><li>  Quiz√°s despu√©s de un poco de refactorizaci√≥n, el sistema funcionar√° como antes, pero las pruebas fallar√°n. </li><li>  El costo del desarrollo est√° creciendo. </li><li>  Error humano: comentando sobre pruebas rotas. </li><li>  Error humano: agregar soluciones al c√≥digo espec√≠ficamente para pasar las pruebas unitarias. </li></ul><br>  Este √∫ltimo me mata m√°s.  (Casi) en cada proyecto, justo en el c√≥digo fuente de la aplicaci√≥n de trabajo, encuentro l√≠neas como "si es una prueba unitaria, cargue una base de datos SQLite sustituta, de lo contrario cargue otra base de datos" o "si es una prueba unitaria, no env√≠e un correo electr√≥nico, de lo contrario enviar ", y as√≠ sucesivamente.  Si su aplicaci√≥n tiene una arquitectura pobre, no pretenda que puede arreglar un software p√©simo con un buen pase de prueba, esto no mejorar√°. <br><br>  A menudo discut√≠a con colegas y clientes qu√© es una buena prueba de unidad.  El: <br><br><ul><li>  R√°pido </li><li>  Automatizado. </li><li>  Controla completamente todas sus dependencias. </li><li>  Fiable: se puede iniciar en cualquier orden, independientemente de otras pruebas. </li><li>  Solo se puede ejecutar en la memoria (sin interacciones con la base de datos, lecturas / escrituras en el sistema de archivos). </li><li>  Siempre devuelve un √∫nico resultado. </li><li>  Conveniente para la lectura y el acompa√±amiento. </li><li>  No prueba la configuraci√≥n SUT (sistema bajo prueba). </li><li>  Tiene una TAREA √öNICA claramente definida. </li><li>  Est√° bien nombrado (y es lo suficientemente comprensible para evitar la depuraci√≥n solo por descubrir qu√© est√° fallando). </li></ul><br>  Para aquellos que sonrieron despu√©s de leer "automatizado": no quise integrar PHPUnit o JUnit en las canalizaciones de CI.  El punto es que si cambia el c√≥digo, gu√°rdelo y no sepa si los m√≥dulos pasan sus pruebas, entonces no est√°n automatizados, pero deber√≠an.  La opci√≥n ganadora es el seguimiento de archivos. <br><br><h2>  ¬øQu√© se debe someter a pruebas unitarias? </h2><br>  En sistemas normales, las pruebas unitarias deben escribirse para: <br><br><ul><li>  M√≥dulos: partes aisladas indivisibles del sistema que realizan cualquier tarea (funci√≥n, m√©todo, clase). </li><li>  M√©todos p√∫blicos </li><li>  M√©todos protegidos, pero solo en casos raros y cuando nadie los ve. </li><li>  Errores y sus soluciones. </li></ul><br>  La definici√≥n de una prueba unitaria depende del desarrollador que escribi√≥ el c√≥digo.  En PHP, casi siempre es un m√©todo o funci√≥n de clase, porque es un <b>software indivisible que tiene sentido por s√≠ solo</b> .  Varias veces vi c√≥mo los desarrolladores usaban una variedad de miniclases de un m√©todo como un solo m√≥dulo.  Esto tiene sentido si la funcionalidad m√≠nima requiere m√∫ltiples objetos. <br><br>  Entonces usted mismo puede determinar qu√© es un m√≥dulo para usted.  O puede probar los m√©todos uno por uno, haciendo la vida m√°s f√°cil para ese tipo que luego trabajar√° con el c√≥digo. <br><br>  Si no realiza pruebas unitarias, le propongo que haga esto despu√©s del pr√≥ximo gran error.  Verifique con qu√© m√©todo estar√° asociado, escriba una prueba fallida con los argumentos y resultados correctos, corrija el error, ejecute la prueba de la unidad nuevamente.  Si se pasa, puede estar seguro de que este error tuvo que repararse por √∫ltima vez (teniendo en cuenta sus escenarios de entrada espec√≠ficos). <br><br>  Este enfoque hace que las pruebas unitarias sean m√°s f√°ciles de entender.  Analice cada m√©todo por separado.  Los proveedores de datos pueden ayudar a determinar la entrada y la salida para cualquier escenario que se le ocurra, por lo que pase lo que pase, sabr√° qu√© esperar. <br><br><h2>  Lo que NO necesita ser probado </h2><br>  Es un poco m√°s dif√≠cil determinar que no es necesario realizar la prueba.  Trat√© de compilar una lista de elementos que <b>no necesitan ser</b> sometidos a pruebas unitarias: <br><br><ul><li>  Funcionalidad fuera del alcance de los m√≥dulos (!) </li><li>  Integraci√≥n de m√≥dulos con otros m√≥dulos (!) </li><li>  Comportamiento no aislado (dependencias no desmontables, bases de datos reales, red) </li><li>  M√©todos privados y seguros. </li><li>  M√©todos est√°ticos. </li><li>  Bibliotecas externas </li><li>  Tu marco </li></ul><br>  Estoy seguro de que las pruebas unitarias no deben aplicarse a ninguno de los anteriores, excepto los m√©todos est√°ticos.  Me gusta argumentar que est√°tico, en esencia, significa procedimiento, y en muchos casos el procedimiento es global.  Si el m√©todo est√°tico llama a otro m√©todo est√°tico, entonces esta dependencia no se puede anular.  Esto significa que ahora est√° probando de forma aislada.  Y entonces esto ya no es una prueba unitaria.  Por otro lado, esta es la parte del c√≥digo que puede vivir por s√≠ misma, tiene un prop√≥sito y debe probarse para asegurarse de que no importa qu√© parte de este est√∫pido sistema llame la parte probada del c√≥digo, no se romper√°.  Por lo tanto, creo que puede probar m√©todos est√°ticos si est√° seguro de que el resultado de su prueba no puede ser modificado por ninguna otra prueba, y que el lenguaje o el marco de trabajo le permite probar de forma nativa. <br><br><h2>  ¬øC√≥mo escribir pruebas unitarias? </h2><br><ul><li>  Escriba el c√≥digo adecuado para las pruebas unitarias, luego pru√©belo. </li><li>  Escriba el c√≥digo adecuado para las pruebas unitarias, luego pru√©belo. </li><li>  Escriba el c√≥digo adecuado para las pruebas unitarias, luego pru√©belo. </li></ul><br>  Si "probarlo" no es suficiente, entonces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">laracasts.com</a> tiene muy buenos videos sobre pruebas de unidad PHP.  Hay muchos sitios dedicados a la misma tarea en otros idiomas.  No veo ninguna raz√≥n para explicar c√≥mo hago las pruebas unitarias, porque las herramientas cambian bastante r√°pido, y cuando lees este texto, puedo cambiar de PHPUnit a Kahlan.  O no  Quien sabe <br><br>  Pero responder la primera pregunta (c√≥mo escribir c√≥digo adecuado para pruebas unitarias) es mucho m√°s f√°cil y es poco probable que la situaci√≥n cambie mucho con el tiempo: <br><br><ul><li>  <b>S√ìLIDO</b> </li><li>  <b>SECO</b> </li><li>  La falta de <b>nuevas</b> palabras clave en el constructor. </li><li>  La ausencia de <b>bucles</b> en el constructor (y las transiciones, si se especifica). </li><li>  Falta de m√©todos est√°ticos, par√°metros, clases. </li><li>  Falta de m√©todos setup (): los objetos deben inicializarse completamente despu√©s de la construcci√≥n. </li><li>  La falta de singleton (estado global) y otros antipatterns no comprobables. </li><li>  La falta de objetos omnipotentes (objetos de Dios). </li><li>  Falta de clases con funcionalidad mixta (clases mixtas de inter√©s). </li><li>  Sin dependencias ocultas. </li></ul><br>  Ahora, sabiendo cu√°les son las pruebas unitarias y cu√°les no, qu√© necesita y qu√© no necesita probar, qu√© lugar ocupan las pruebas unitarias en el ciclo de vida del desarrollo de software, ser√° m√°s f√°cil implementarlas.  Queda por encontrar un marco o biblioteca a su gusto.  En caso de duda, tome el marco / lenguaje est√°ndar de facto. <br><br>  En conclusi√≥n: las pruebas unitarias son muy importantes tanto para desarrolladores como para empresas.  Deben escribirse, existen m√©todos probados que lo ayudar√°n a cubrir f√°cilmente los m√≥dulos con pruebas, principalmente preparando los m√≥dulos ellos mismos.  Pero todas estas t√©cnicas no tienen sentido sin el conocimiento de la teor√≠a de prueba descrita en este art√≠culo.  Debe poder distinguir las pruebas unitarias de las pruebas de otros tipos.  Y cuando tenga una comprensi√≥n clara en su cabeza, le resultar√° mucho m√°s f√°cil escribir ex√°menes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412695/">https://habr.com/ru/post/es412695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412685/index.html">Unity GPU Path Tracing - Parte 2</a></li>
<li><a href="../es412687/index.html">Implementar IdM. Procedimientos y medios t√©cnicos: desde b√°sico hasta IdM</a></li>
<li><a href="../es412689/index.html">El an√°lisis predictivo de TI agiliza el monitoreo de aplicaciones distribuidas</a></li>
<li><a href="../es412691/index.html">Broma de 5 a√±os en Facebook o historia forense</a></li>
<li><a href="../es412693/index.html">Escribir c√≥digo que sea f√°cil de eliminar y depurar</a></li>
<li><a href="../es412697/index.html">IoT como √°rea tem√°tica universal para una universidad t√©cnica multidisciplinaria</a></li>
<li><a href="../es412699/index.html">Explicaci√≥n simple de principios S√ìLIDOS</a></li>
<li><a href="../es412701/index.html">El calentador m√°s inteligente</a></li>
<li><a href="../es412703/index.html">En una conferencia con Veeam: una revisi√≥n de VeeamON 2018 y una invitaci√≥n al Foro VeeamON en Mosc√∫</a></li>
<li><a href="../es412705/index.html">Hackeado el sistema: c√≥mo cambiamos la selecci√≥n y adaptaci√≥n de los desarrolladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>