<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥓 😐 🤗 Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 2 🤦🏽 🕵️ 🔕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kelanjutan dari cerita panjang tentang jalan berduri kami untuk menciptakan sistem yang kuat dan penuh muatan yang menjamin operasi Bursa. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444302/"><img src="https://habrastorage.org/webt/fj/7h/zk/fj7hzkntltigzuhy-4zrisejpyu.jpeg"><br><br>  Ini adalah kelanjutan dari cerita panjang tentang jalan berduri kami untuk menciptakan sistem yang kuat dan penuh muatan yang menjamin operasi Bursa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama ada di sini</a> . <br><a name="habracut"></a><br><h2>  Kesalahan misterius </h2><br>  Setelah banyak pengujian, sistem perdagangan dan kliring yang diperbarui dioperasikan, dan kami bertemu dengan bug tentang apa yang tepat untuk menulis cerita detektif mistis. <br><br>  Segera setelah memulai pada server utama, salah satu transaksi diproses dengan kesalahan.  Pada saat yang sama, semuanya beres di server cadangan.  Ternyata operasi matematika sederhana untuk menghitung eksponen pada server utama memberikan hasil negatif dari argumen yang valid!  Survei berlanjut, dan dalam register SSE2 mereka menemukan perbedaan dalam satu bit, yang bertanggung jawab untuk pembulatan ketika bekerja dengan angka floating point. <br><br>  Mereka menulis sebuah utilitas tes sederhana untuk menghitung eksponen dengan set bit pembulatan.  Ternyata dalam versi RedHat Linux yang kami gunakan, ada bug dalam bekerja dengan fungsi matematika ketika bit naas dimasukkan.  Kami melaporkan ini ke RedHat, setelah beberapa saat kami menerima patch dari mereka dan menggulungnya.  Kesalahan tidak lagi terjadi, tetapi tidak jelas dari mana datangnya bit ini?  Fungsi <code>fesetround</code> dari C bertanggung jawab untuk itu. Kami dengan hati-hati menganalisis kode kami untuk mencari dugaan kesalahan: memeriksa semua situasi yang mungkin;  mempertimbangkan semua fungsi yang menggunakan pembulatan;  mencoba memainkan sesi yang gagal;  menggunakan kompiler berbeda dengan opsi berbeda;  menggunakan analisis statis dan dinamis. <br><br>  Penyebab kesalahan tidak dapat ditemukan. <br><br>  Kemudian mereka mulai memeriksa perangkat keras: mereka melakukan uji beban prosesor;  memeriksa RAM;  bahkan menjalankan tes untuk skenario yang sangat tidak mungkin dari kesalahan multi-bit dalam satu sel.  Tidak berhasil. <br><br>  Pada akhirnya, mereka menetapkan teori-teori dari dunia fisika berenergi tinggi: beberapa partikel berenergi tinggi terbang ke pusat data kami, menerobos dinding kasing, menabrak prosesor dan menyebabkan kait pelatuk menempel di bagian yang sama.  Teori absurd ini disebut "neutrino."  Jika Anda jauh dari fisika partikel elementer: neutrino jarang berinteraksi dengan dunia luar, dan tentu saja mereka tidak dapat memengaruhi prosesor. <br><br>  Karena tidak mungkin untuk menemukan penyebab kegagalan, kalau-kalau mereka mengecualikan server "nakal" dari operasi. <br><br>  Setelah beberapa waktu, kami mulai meningkatkan sistem siaga panas: kami memperkenalkan apa yang disebut "cadangan panas" (replika asinkron).  Mereka menerima aliran transaksi yang mungkin ada di pusat data yang berbeda, tetapi hangat tidak mendukung interaksi aktif dengan server lain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/4fd/67f/61c4fd67f72a529370bcc7a792ae946e.png"><br><br>  Mengapa ini dilakukan?  Jika server cadangan gagal, maka koneksi hangat ke server utama menjadi cadangan baru.  Artinya, setelah kegagalan, sistem tidak tetap sampai akhir sesi perdagangan dengan satu server utama. <br><br>  Dan ketika versi baru dari sistem diuji dan dioperasikan, kesalahan dengan pembulatan kembali terjadi.  Selain itu, dengan meningkatnya jumlah server yang hangat, kesalahan mulai muncul lebih sering.  Dalam hal ini, vendor tidak memiliki apa pun untuk disajikan, karena tidak ada bukti nyata. <br><br>  Selama analisis situasi selanjutnya, muncul teori bahwa masalahnya bisa terkait dengan OS.  Kami menulis sebuah program sederhana yang memanggil fungsi <code>fesetround</code> dalam loop tanpa akhir, mengingat keadaan saat ini dan memeriksanya melalui sleep, dan ini dilakukan di banyak utas yang bersaing.  Setelah memilih parameter tidur dan jumlah utas, kami mulai mereproduksi kegagalan bit secara stabil setelah sekitar 5 menit utilitas.  Namun, dukungan Red Hat tidak dapat mereproduksi itu.  Pengujian server kami yang lain menunjukkan bahwa hanya mereka yang memasang prosesor tertentu yang terpengaruh oleh kesalahan tersebut.  Pada saat yang sama, transisi ke inti baru menyelesaikan masalah.  Pada akhirnya, kami baru saja mengganti OS, dan penyebab sebenarnya dari bug itu masih belum jelas. <br><br>  Dan tiba-tiba tahun lalu sebuah artikel muncul di Habré " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana saya menemukan bug dalam prosesor Intel Skylake</a> ".  Situasi yang digambarkan di dalamnya sangat mirip dengan situasi kita, tetapi penulis maju lebih jauh dalam penyelidikan dan mengajukan teori bahwa kesalahan ada dalam mikrokode.  Dan ketika memperbarui kernel Linux, pabrikan juga memperbarui mikrokode. <br><br><h2>  Pengembangan sistem lebih lanjut </h2><br>  Meskipun kami menyingkirkan kesalahan, cerita ini membuat kami mempertimbangkan kembali arsitektur sistem lagi.  Bagaimanapun, kami tidak terlindungi dari pengulangan bug semacam itu. <br><br>  Prinsip-prinsip berikut membentuk dasar untuk perbaikan lebih lanjut pada sistem cadangan: <br><br><ul><li>  Anda tidak bisa mempercayai siapa pun.  Server mungkin tidak berfungsi dengan baik. </li><li>  Redundansi mayoritas. </li><li>  Pembangunan konsensus.  Sebagai pelengkap logis untuk redundansi mayoritas. </li><li>  Kegagalan ganda dimungkinkan. </li><li>  Vitalitas.  Skema cadangan panas baru seharusnya tidak lebih buruk dari yang sebelumnya.  Perdagangan harus berjalan lancar sampai server terakhir. </li><li>  Sedikit peningkatan keterlambatan.  Setiap downtime menyebabkan kerugian finansial yang sangat besar. </li><li>  Interaksi jaringan minimum sehingga keterlambatan serendah mungkin. </li><li>  Pilih server master baru dalam hitungan detik. </li></ul><br>  Tidak ada solusi yang tersedia di pasaran yang cocok untuk kami, dan protokol Raft baru dalam masa pertumbuhan, jadi kami menciptakan solusi kami sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/bc0/73e/d50bc073e4a2bbb805b724d0040b18f9.png"><br><br><h2>  Konektivitas jaringan </h2><br>  Selain sistem cadangan, kami mulai memodernkan konektivitas jaringan.  Subsistem I / O adalah banyak proses, yang dalam cara terburuk mempengaruhi jitter dan delay.  Memiliki ratusan proses yang memproses koneksi TCP, kami dipaksa untuk terus-menerus beralih di antara mereka, dan dalam skala mikrodetik, ini adalah operasi yang agak panjang.  Tetapi bagian terburuknya adalah ketika suatu proses menerima paket untuk diproses, ia mengirimnya ke satu antrian SystemV, dan kemudian menunggu kejadian dari antrian SystemV lain.  Namun, dengan sejumlah besar node, kedatangan paket TCP baru dalam satu proses dan penerimaan data dalam antrian di lain merupakan dua peristiwa yang bersaing untuk OS.  Dalam hal ini, jika tidak ada prosesor fisik yang tersedia untuk kedua tugas, satu akan diproses, dan yang kedua akan berdiri dalam antrian menunggu.  Tidak mungkin untuk memprediksi konsekuensinya. <br><br>  Dalam situasi seperti itu, Anda dapat menerapkan kontrol prioritas proses dinamis, tetapi ini akan membutuhkan penggunaan panggilan sistem intensif sumber daya.  Akibatnya, kami beralih ke satu utas menggunakan epoll klasik, ini sangat meningkatkan kecepatan dan mengurangi waktu pemrosesan transaksi.  Kami juga menyingkirkan proses tertentu dari interaksi dan interaksi jaringan melalui SystemV, secara signifikan mengurangi jumlah panggilan sistem dan mulai mengendalikan prioritas operasi.  Dengan hanya menggunakan satu subsistem I / O, dimungkinkan untuk menyimpan sekitar 8-17 mikrodetik, tergantung pada skenario.  Skema single-threaded ini sejak itu diterapkan tidak berubah, satu aliran epoll dengan margin cukup untuk melayani semua koneksi. <br><br><h2>  Pemrosesan transaksi </h2><br>  Tumbuhnya beban pada sistem kami membutuhkan modernisasi hampir semua komponennya.  Tapi, sayangnya, stagnasi dalam peningkatan kecepatan clock prosesor dalam beberapa tahun terakhir tidak lagi memungkinkan kita untuk skala proses "langsung".  Oleh karena itu, kami memutuskan untuk membagi proses Engine menjadi tiga tingkatan, yang paling banyak memuatnya adalah sistem verifikasi risiko, yang menilai ketersediaan dana di akun dan membuat transaksi sendiri.  Tetapi uang bisa dalam mata uang yang berbeda, dan perlu untuk mencari tahu apa prinsip untuk membagi pemrosesan permintaan. <br><br>  Solusi logis adalah dengan membagi berdasarkan mata uang: satu server berdagang dalam dolar, yang lain dalam pound, dan euro ketiga.  Tetapi jika, dengan skema seperti itu, dua transaksi dikirim untuk membeli mata uang yang berbeda, maka akan ada masalah dompet tidak sinkron.  Dan sinkronisasi itu sulit dan mahal.  Oleh karena itu, akan benar untuk shard secara terpisah di dompet dan secara terpisah pada alat.  Ngomong-ngomong, di sebagian besar bursa barat tugas memeriksa risiko tidak seakurat risiko kita, jadi paling sering ini dilakukan secara offline.  Kami perlu menerapkan pemeriksaan online. <br><br>  Mari kita ilustrasikan dengan sebuah contoh.  Pedagang ingin membeli $ 30, dan permintaannya untuk memvalidasi transaksi: kami memeriksa apakah pedagang ini diizinkan untuk mode perdagangan ini, apakah ia memiliki hak yang diperlukan.  Jika semuanya beres, permintaan masuk ke sistem verifikasi risiko, mis.  untuk memverifikasi kecukupan dana untuk menyelesaikan transaksi.  Ada catatan bahwa jumlah yang diperlukan saat ini diblokir.  Selanjutnya, permintaan tersebut dialihkan ke sistem perdagangan, yang menyetujui atau tidak menyetujui transaksi ini.  Katakanlah transaksi disetujui - maka sistem verifikasi risiko mencatat bahwa uang tidak terkunci dan rubel dikonversi menjadi dolar. <br><br>  Secara umum, sistem verifikasi risiko mengandung algoritme yang rumit dan melakukan perhitungan sangat intensif sumber daya dalam jumlah besar, dan tidak hanya memeriksa "saldo akun", seperti yang terlihat pada pandangan pertama. <br><br>  Ketika kami mulai membagi proses Engine menjadi level, kami mengalami masalah: kode yang tersedia pada saat itu pada tahap validasi dan verifikasi secara aktif menggunakan array data yang sama, yang mengharuskan penulisan ulang seluruh basis kode.  Sebagai hasilnya, kami meminjam metodologi untuk memproses instruksi dari prosesor modern: masing-masing dibagi menjadi beberapa tahap kecil dan beberapa tindakan dilakukan secara paralel dalam satu siklus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40f/d5b/011/40fd5b0119fef43d909ce33abc898ff8.png"><br><br>  Setelah sedikit adaptasi kode, kami membuat pipa untuk pemrosesan transaksi paralel, di mana transaksi dibagi menjadi 4 tahap pipa: interaksi jaringan, validasi, eksekusi, dan publikasi hasil <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/90f/55b/dd690f55b9be4e03a50a9ecb3930c746.png"><br><br>  Pertimbangkan sebuah contoh.  Kami memiliki dua sistem pemrosesan, serial dan paralel.  Transaksi pertama tiba, dan dalam kedua sistem itu berlaku untuk validasi.  Kemudian transaksi kedua tiba: dalam sistem paralel, ia segera dibawa untuk bekerja, dan dalam sistem berurutan ia antri menunggu transaksi pertama melewati tahap pemrosesan saat ini.  Artinya, keuntungan utama pipelining adalah kami memproses antrian transaksi lebih cepat. <br><br>  Jadi kami mendapat sistem ASTS +. <br><br>  Benar, dengan konveyor juga, tidak semuanya lancar.  Misalkan kita memiliki transaksi yang mempengaruhi array data dalam transaksi tetangga, ini adalah situasi khas untuk pertukaran.  Transaksi semacam itu tidak dapat dieksekusi dalam pipa, karena dapat mempengaruhi orang lain.  Situasi ini disebut bahaya data, dan transaksi semacam itu hanya diproses secara terpisah: ketika transaksi "cepat" di ujung antrian, pipa berhenti, sistem memproses transaksi "lambat" dan kemudian memulai pipa lagi.  Untungnya, bagian dari transaksi tersebut dalam aliran total sangat kecil, sehingga pipa berhenti sangat jarang sehingga tidak mempengaruhi kinerja keseluruhan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/131/de5/0e0131de5df810723111aba61853dd77.png"><br><br>  Kemudian kami mulai memecahkan masalah sinkronisasi tiga utas eksekusi.  Akibatnya, sebuah sistem yang didasarkan pada buffer melingkar dengan sel ukuran tetap lahir.  Dalam sistem ini, semuanya tergantung pada kecepatan pemrosesan, data tidak disalin. <br><br><ul><li>  Semua paket jaringan masuk ke dalam tahap alokasi. </li><li>  Kami menempatkan mereka dalam array dan menandai bahwa mereka tersedia untuk tahap No. 1. </li><li>  Transaksi kedua datang, sekali lagi tersedia untuk tahap No. 1. </li><li>  Aliran pemrosesan pertama melihat transaksi yang tersedia, memprosesnya, dan mentransfernya ke tahap berikutnya dari aliran pemrosesan kedua. </li><li>  Kemudian memproses transaksi pertama dan menandai sel yang sesuai dengan bendera yang <code>deleted</code> - sekarang tersedia untuk penggunaan baru. </li></ul><br>  Dengan demikian, seluruh antrian diproses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/172/d67/3a8172d67dad9c45dc21448dfb74e135.png"><br><br>  Pemrosesan setiap tahap membutuhkan satuan atau puluhan mikrodetik.  Dan jika Anda menggunakan skema sinkronisasi OS standar, maka kita akan kehilangan lebih banyak waktu pada sinkronisasi itu sendiri.  Karena itu, kami mulai menggunakan spinlock.  Namun, ini adalah nada yang sangat buruk dalam sistem waktu nyata, dan RedHat sangat menyarankan untuk tidak melakukan ini, jadi kami menggunakan spinlock selama 100 ms, dan kemudian masuk ke mode semaphore untuk mengecualikan kemungkinan kebuntuan. <br><br>  Sebagai hasilnya, kami mencapai kinerja sekitar 8 juta transaksi per detik.  Dan hanya dua bulan kemudian, dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang LMAX Disruptor, mereka melihat deskripsi sirkuit dengan fungsi yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b31/498/732/b31498732113050fe76ed4dee7c9c82e.png"><br><br>  Sekarang pada satu tahap mungkin ada beberapa utas eksekusi.  Semua transaksi diproses secara bergiliran, sesuai urutan yang diterima.  Akibatnya, kinerja puncak meningkat dari 18 ribu menjadi 50 ribu transaksi per detik. <br><br><h2>  Sistem Manajemen Risiko Pertukaran </h2><br>  Tidak ada batasan untuk kesempurnaan, dan segera kami mulai memodernisasi lagi: sebagai bagian dari ASTS +, kami mulai mentransfer sistem manajemen risiko dan operasi penyelesaian ke dalam komponen otonom.  Kami mengembangkan arsitektur modern yang fleksibel dan model risiko hierarkis baru, mencoba sedapat mungkin untuk menggunakan kelas <code>fixed_point</code> alih-alih <code>double</code> . <br><br>  Tetapi segera muncul masalah: bagaimana cara menyinkronkan semua logika bisnis yang telah bekerja selama bertahun-tahun dan mentransfernya ke sistem baru?  Akibatnya, versi pertama dari prototipe sistem baru harus ditinggalkan.  Versi kedua, yang saat ini bekerja di produksi, didasarkan pada kode yang sama yang berfungsi baik di bagian perdagangan maupun di bagian risiko.  Selama pengembangan, hal yang paling sulit adalah membuat git menggabungkan antara kedua versi.  Rekan kami Evgeny Mazurenok melakukan operasi ini setiap minggu dan memaki untuk waktu yang sangat lama setiap kali. <br><br>  Ketika memilih sistem baru, kami segera harus menyelesaikan masalah interaksi.  Ketika memilih bus data, itu perlu untuk memastikan jitter stabil dan penundaan minimal.  Untuk ini, jaringan InfiniBand RDMA paling cocok: waktu pemrosesan rata-rata adalah 4 kali lebih sedikit dari pada jaringan 10G Ethernet.  Tetapi perbedaan sebenarnya ada di persentil - 99 dan 99,9. <br><br>  Tentu saja, InfiniBand memiliki kesulitannya sendiri.  Pertama, API lain adalah ibverb, bukan soket.  Kedua, hampir tidak ada solusi perpesanan sumber terbuka yang tersedia secara luas.  Kami mencoba membuat prototipe kami, tetapi ternyata sangat sulit, jadi kami memilih solusi komersial - Perpesanan Latensi Rendah (sebelumnya IBM MQ LLM). <br><br>  Kemudian timbul masalah pemisahan yang benar dari sistem risiko.  Jika Anda hanya mengambil Mesin Risiko dan tidak membuat simpul perantara, maka transaksi dari dua sumber dapat digabungkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/b59/4c9/41cb594c970d774c5715a43f43d3f29b.png"><br><br>  Solusi Ultra Low Latency disebut memiliki mode penataan ulang: transaksi dari dua sumber dapat diatur dalam urutan yang benar setelah diterima, ini diwujudkan dengan menggunakan saluran terpisah untuk bertukar informasi tentang urutan.  Tetapi kami belum menerapkan mode ini: ini mempersulit seluruh proses, dan dalam beberapa solusi tidak didukung sama sekali.  Selain itu, setiap transaksi harus diberi cap waktu yang sesuai, dan dalam skema kami mekanisme ini sangat sulit untuk diterapkan dengan benar.  Oleh karena itu, kami menggunakan skema klasik dengan broker pesan, yaitu, dengan operator yang mendistribusikan pesan antara Risk Engine. <br><br>  Masalah kedua terkait dengan akses klien: jika ada beberapa Gateways Risiko, klien harus terhubung ke masing-masing, dan untuk ini Anda harus membuat perubahan ke lapisan klien.  Kami ingin keluar dari ini pada tahap ini, jadi dalam skema Risk Gateway saat ini mereka memproses seluruh aliran data.  Ini sangat membatasi throughput maksimum, tetapi sangat menyederhanakan integrasi sistem. <br><br><h2>  Duplikasi </h2><br>  Sistem kami seharusnya tidak memiliki satu titik kegagalan, yaitu, semua komponen harus digandakan, termasuk pialang pesan.  Kami memecahkan masalah ini menggunakan sistem CLLM: ini berisi gugus RCMS di mana dua dispatcher dapat bekerja dalam mode master-slave, dan ketika satu gagal, sistem otomatis beralih ke yang lain. <br><br><h2>  Bekerja dengan pusat data cadangan </h2><br>  InfiniBand dioptimalkan untuk berfungsi sebagai jaringan lokal, yaitu, untuk menghubungkan peralatan rack-mount, dan tidak ada cara untuk meletakkan jaringan InfiniBand antara dua pusat data yang didistribusikan secara geografis.  Oleh karena itu, kami menerapkan penghubung / pengirim yang terhubung ke penyimpanan pesan melalui jaringan Ethernet biasa dan menyampaikan semua transaksi ke jaringan IB kedua.  Saat Anda membutuhkan migrasi dari pusat data, kami dapat memilih pusat data mana yang akan bekerja sekarang. <br><br><h2>  Ringkasan </h2><br>  Semua hal di atas tidak dilakukan sekaligus, butuh beberapa iterasi pengembangan arsitektur baru.  Kami membuat prototipe dalam sebulan, tetapi butuh lebih dari dua tahun untuk menyelesaikan kondisi kerja.  Kami mencoba untuk mencapai kompromi terbaik antara meningkatkan durasi pemrosesan transaksi dan meningkatkan keandalan sistem. <br><br>  Karena sistem ini sangat diperbarui, kami menerapkan pemulihan data dari dua sumber independen.  Jika karena alasan tertentu penyimpanan pesan tidak berfungsi dengan benar, Anda dapat mengambil log transaksi dari sumber kedua - dari Risk Engine.  Prinsip ini dihormati di seluruh sistem. <br><br>  Di antara hal-hal lain, kami berhasil mempertahankan API klien sehingga broker maupun orang lain tidak memerlukan perubahan signifikan untuk arsitektur baru.  Saya harus mengubah beberapa antarmuka, tetapi saya tidak perlu melakukan perubahan signifikan pada model pekerjaan. <br><br>  Kami menyebut versi terbaru dari platform kami, Rebus - sebagai singkatan dari dua inovasi paling terkenal dalam arsitektur, Risk Engine, dan BUS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/179/4f2/bf5/1794f2bf5eb87f3ab59df9d9e0d829d8.png"><br><br>  Awalnya, kami hanya ingin menyoroti bagian kliring, tetapi hasilnya adalah sistem terdistribusi besar.  Sekarang pelanggan dapat berinteraksi dengan Trading Gateway, atau dengan kliring, atau keduanya sekaligus. <br><br>  Apa yang akhirnya kami capai: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/6e7/d8d/2d46e7d8d73032984b0c5ecb8bc1e9e1.png"><br><br>  Mengurangi tingkat keterlambatan.  Dengan volume transaksi yang kecil, sistem bekerja sama dengan versi sebelumnya, tetapi pada saat yang sama dapat menahan beban yang jauh lebih tinggi. <br><br>  Produktivitas puncak meningkat dari 50 ribu menjadi 180 ribu transaksi per detik.  Aliran informasi lebih lanjut menghambat pertumbuhan lebih lanjut. <br><br>     :  matching      Gateway.   Gateway    ,       . <br><br>      ,   -: <br><br><ul><li>      .    . </li><li>   ,  , . ,        .   ,      . </li><li>          ,   . </li><li>          ,      . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444302/">https://habr.com/ru/post/id444302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444290/index.html">Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 2. Operator dan pipa</a></li>
<li><a href="../id444294/index.html">Bagaimana penerbangan bisnis bekerja di Rusia (pusat FBO)</a></li>
<li><a href="../id444296/index.html">6 sumber daya dan layanan yang bermanfaat bagi calon emigran ke AS, Jerman, dan Kanada</a></li>
<li><a href="../id444298/index.html">Para ilmuwan mengatakan mereka dapat mengubah bentuk dinosaurus hidup selama 5 tahun</a></li>
<li><a href="../id444300/index.html">Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 1</a></li>
<li><a href="../id444304/index.html">Huawei dan Nutanix Mengumumkan Kemitraan HCI</a></li>
<li><a href="../id444306/index.html">Seks, cinta, dan hubungan melalui prisma arsitektur layanan mikro</a></li>
<li><a href="../id444308/index.html">Berita Industri Game (11-18 Maret, 2019)</a></li>
<li><a href="../id444312/index.html">Instal ReactOS dari stik USB</a></li>
<li><a href="../id444314/index.html">Valve Mulai Memerangi Ulasan Negatif Lepas Pantai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>