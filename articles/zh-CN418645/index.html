<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍👨 👇🏻 🤾 春季会议C ++ Russia 2018的论文 🤱🏽 🆓 🚣🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="4月19日至21日，C ++ Russia 2018会议在圣彼得堡举行，组织和行为逐年提高，这是一个好消息。 感谢C ++俄罗斯的永久组织者Sergey Platonov为该领域的发展做出的贡献。 

 4月19日，计划了大师班，很遗憾，我们不能参加。在20-21日，会议的主要议程举行了，我们对此非...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>春季会议C ++ Russia 2018的论文</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418645/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/m8/km/ifm8kmasjfgchispcdfdx3-2ax0.png"></div><br>  4月19日至21日，C ++ Russia 2018会议在圣彼得堡举行，组织和行为逐年提高，这是一个好消息。 感谢C ++俄罗斯的永久组织者Sergey Platonov为该领域的发展做出的贡献。 <br><a name="habracut"></a><br>  4月19日，计划了大师班，很遗憾，我们不能参加。在20-21日，会议的主要议程举行了，我们对此非常感兴趣。 谢尔盖· <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">瑟普（</a> Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">sermp）</a>做得很好，吸引了几位杰出的外国演讲者。 会议的第一天由CppCon的组织者和C ++ Today：The Beast is Back的作者Jon Kalb宣布开幕。 第二天从标准化委员会成员Daveed Vandevoorde的演讲开始，他是C ++模板：完整指南的作者之一。 安德烈·亚历山德列斯库（Andrei Alexandrescu）成为关注的焦点，在他报告了例外情况之后，他一度聚集了一大群想要签名并合影的人。 首次在Skype上播出了Herb Sutter关于C ++ 20的宇宙飞船算子的演讲。 <br><br> 尽管会议是在3个月前举行的，但视频（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完整播放列表</a> ）是刚刚发布在上面的，因此是时候刷新您的记忆并使自己沉浸在C ++的惊人功能中了。 <br><br><h3> 乔恩·卡尔布（Jon Kalb）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">今天的C ++：野兽回来了</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qj/4d/qxqj4duts1eygoh4trgst-2i8bw.png"></div><br> 本演讲涵盖了为何寻求性能的工程师选择C ++。  Jon提出了C ++的历史观点，重点介绍了C ++社区当前的状况以及该语言及其用户群的发展方向。 随着人们对数据中心和移动设备的性能重新产生兴趣，并获得了开源软件库的成功，C ++又回来了并且很热。 这篇演讲解释了为什么C ++是大多数软件工程师追求性能的首选语言。 您将收到一张粗略的历史草图，可以透视C ++，并涵盖其流行起伏。 <br><br><h3> 亚诺·舍德尔（ArnoSchödl）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从迭代器到范围</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/wi/1c/g2wi1czg7ulvtypu_8xqlz1irdo.png"></div><br> 成对的迭代器在整个C ++库中无处不在。 通常认为，将这样的一对组合为单个实体（通常称为Range）可提供更简洁易读的代码。 然而，定义这样的Range概念的精确语义被证明是非常棘手的。 理论考虑与实际考虑相冲突。 一些设计目标是互不兼容的。 <br><br><h3> 乔纳森·博卡拉（Jonathan Boccara）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不到一个小时的105种STL算法</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/lf/ga/jvlfga-cdxxb3furo797y5ezpfy.png"></div><br> 我们都知道我们应该了解STL算法。 将它们包括在我们的设计中可以使我们的代码更具表现力和更强大。 有时，以一种壮观的方式。 <br><br> 但是您知道您的STL算法吗？ <br><br> 在本次演讲中，作者介绍了STL当前具有的105种算法，包括C ++ 11和C ++ 17中添加的算法。 但是，讨论不仅仅只是一个清单，而是要介绍不同的算法组，它们在STL中形成的模式以及算法如何相互关联。 <br><br> 这种大图景是真正记住所有这些内容的最佳方法，并构成了一个工具箱，其中充满了使我们的代码更具表现力和更强大的方法。 <br><br><h3> 维克多·基里洛夫（Viktor Kirilov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交互式C ++编译（REPL）：精益之道</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/bd/4w/zzbd4w9yrkytmf3aqgamwc6iafw.png"></div><br> 您是否曾经想过在您的C ++程序运行时修改一些值或执行某些语句只是为了测试某些东西-不平凡或不可能通过调试器进行？ 脚本语言具有REPL（read-eval-print-loop）。  C ++紧紧抓住了它（由CERN的研究人员开发），但是它建立在LLVM之上，并且设置起来非常麻烦。  RCRL（读取-编译-运行-循环）是一个演示项目，展示了一种创新的方法，可以以易于嵌入的平台和与编译器无关的方式进行运行时C ++编译。 在此演示文稿中，显示了如何使用它，如何工作以及如何对其进行修改并将其集成到任何应用程序和工作流程中。 <br><br><h3> 维克多·库拉（Victor Ciura）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">足够的string_view使自己上吊</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/gz/sl/bmgzslbc51pb7tc4f-jeaoywee4.png"></div><br> 如果我们有一个标准的C ++类型来表示字符串，那不是很好吗？ 哦，等等……我们这样做：std :: string。 如果我们可以在整个应用程序/项目中使用该标准类型，那不是很好吗？ 好吧...我们不能！ 除非我们正在编写控制台应用程序或服务。 但是，如果我们使用GUI编写应用程序或与现代OS API交互，则很有可能需要处理至少一种其他非标准C ++字符串类型。 根据平台和项目的不同，它可能是MFC或ATL中的CString，WinRT中的Platform :: String，Qt中的QString，wxWidgets中的wxString等。 哦，别忘了我们的老朋友const char *，更好的是const wchar_t *，用于C系列API ... <br><br> 因此，我们在代码库中最终得到了两种字符串类型。 好的，这是可管理的：对于所有与平台无关的代码，我们都坚持使用std :: string，并在与系统API或GUI代码进行交互时将来回转换为另一个XString。 当我们越过这座桥时，我们将制作一些不必要的副本，并且最终会得到一些有趣的函数来处理两种类型的字符串。 但这还是胶水代码，对吧？ <br><br> 这是一个好计划……直到我们的项目发展壮大，并且我们积累了许多字符串实用程序和算法。 我们是否将这些算法特性限制为std :: string？ 我们是否会舍弃公分母const char *并失去C ++类型的类型/内存安全性？  C ++ 17 std :: string_view是我们所有字符串问题的答案吗？ <br><br> 作者尝试对这些选项进行探索，并结合15年历史的Windows应用程序进行案例研究：Advanced Installer（www.advancedinstaller.com）-一个积极开发的C ++项目，由于使用了clang-tidy，已现代化为C ++ 17和“ Clang电动工具”（ <a href="">www.clangpowertools.com）</a> ... <br><br><h3> 安德烈·亚历山德列斯库（Andrei Alexandrescu）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">期待预期</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/76/5i/k4765i7g8pxr-u0qfvk433pbfnk.png"></div><br> 编写对错误有弹性的代码一直是所有语言的痛点。 从政治上讲，异常是在C ++中发出错误的信号的正确方法，但出于与易于理解，在本地处理错误的容易程度以及所生成代码的效率有关的原因，许多应用程序仍采用错误代码。 <br><br> 这个演讲展示了如何将各种理论和实践工件组合在一起，以一个健康，简单的程序包解决错误代码和异常。 预期的通用类型可用于本地（错误代码样式）和集中式（异常样式）方式，这两种方式均具有优势。 <br><br><h3>  Borislav Stanimirov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynaMix：多态性的新观点</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2r/ji/ej/2rjiej_ldue2ztihyhwrgy7lhaa.png"></div><br> 具有非常复杂的业务逻辑的软件（例如游戏，CAD系统和企业系统）通常需要在运行时组成和修改对象，例如在现有对象中添加或覆盖方法。 标准C ++具有在编译时定义的硬类型，因此很难做到。 另一方面，具有动态类型（如lua，Python和JavaScript）的语言使此操作非常容易。 因此，为了保持代码的可读性和可维护性，以及完成复杂的业务逻辑要求，许多项目将此类语言与C ++一起使用。 这种方法的一些缺点包括语言绑定层中增加的复杂性，使用解释语言导致的性能损失以及许多小型实用程序功能不可避免的代码重复。 <br><br>  DynaMix是一个库，通过允许用户在C ++的运行时组成和修改多态对象，它试图消除或至少大大减少了对单独脚本语言的需求。 这篇演讲详细阐述了这个问题，并向潜在用户或可能从该方法中受益的人们介绍了该库及其主要功能，并附带了带有注释的示例和一个小示例。 <br><br><h3> 米哈伊尔·马特罗索夫（Mikhail Matrosov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用了通用C ++</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/ox/ha/aooxhajausoz9zfpywpbrsz8wsa.png"></div><br> 在C ++中，您可以通过多种方式解决单个任务。 作者从生产中挑选出一个实际的任务，并研究如何使用C ++提供的许多工具解决该问题：STL容器，boost.range，C ++ 20范围，协程。 他还比较了API约束和不同解决方案的性能，以及如果代码结构合理，如何将它们轻松地从一种转换为另一种。 在此过程中，作者还探索了一些有用的C ++ 17功能的应用程序，例如constexpr if，带有初始化程序的选择语句，std :: not_fn等。 特别注意主题-标准算法。 <br><br><h3> 亚历山大·格兰宁  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件事务存储的功能方法</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/ty/uh/d-tyuhxlhdvvelofkinuwnmpyl4.png"></div><br> 并行编程是一个非常多层面且深入的话题。 在几十年的研究中，已经开发了许多方法，实践和工具，但是我们几乎不能认为C ++语言能跟上这些趋势。 从C ++ 11标准开始，引入了诸如std ::线程，std ::原子，std :: future，std ::互斥体之类的概念，并且在将来，有望添加协程作为异步计算的模型。 好吧，这些都是值得研究的有趣事物，但是该报告将侧重于一个完全不同的想法。 <br><br> 软件事务存储（STM）是事务可变数据模型的概念，已经存在了很长时间，并且对所有语言都有许多实现。 使用STM，您可以表达自己的数据模型，并开始在多个线程之间进行竞争性更改，而不必担心线程同步，数据的有效状态或锁。  STM将竭尽所能。 这听起来非常好，但并非所有STM库都同样有用。 传统的命令式STM非常复杂，容易出现非同寻常的多线程错误，并且难以使用。 另一方面，在函数式编程领域中，组合STM的概念由来已久，其中事务是可组合的模块，可从中构建更高级别的事务。  STM的组合方法使您可以更灵活，清晰和可靠地表达竞争数据模型。 并行编程也很有趣！ <br><br> 在报告中，作者将讨论组合STM的功能，使用方法以及如何在C ++ 17中实现。 <br><br><h3> 瓦迪姆·文尼克（Vadim Vinnik）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">收集处理。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单一本质，多种表现</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/4-/09/xh4-09mvu7jukasuqttn0-ipifu.png"></div><br> 在整个编程历史中，各种集合的顺序元素处理一直是并且仍然是最常见的实际任务之一。 集合的内部表示以及用于获取后续元素的算法可能在很大范围内变化：数组，链表，树，哈希表，文件等。 但是，在各种各样的习惯用法，标准库函数，即席解决方案之后，人们可以揭示对于整个任务类别仍然不变的本质。 本演讲旨在展示从基于对单个元素的明确描述的算法到逐步将集合视为实体并充分揭示域逻辑的高级声明式处理工具的逐步过渡。 <br><br><h3> 德米特里·班什奇科夫（Dmitry Banshchikov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">共享库，无外部依赖</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/75/rt/xn/75rtxnsxinft9v9g2bs2rtyc2sy.png"></div><br> 作者将以共享库的形式讲述他在C ++中开发防病毒引擎的经验。 一个独特的功能是没有任何外部依赖项（运行时C ++或C）。 这整个过程是围绕在GCC上为特殊目标使用自定义工具链而构建的，libc newlib将用于同一目标，并在此目标之上构建libstdc ++。 因此，共享库是通过带有自定义libgcc_s，libc，libcs​​tdc ++的自定义工具链进行组装的（仅在程序集中进行了更改）。 与运行时的所有交互都是通过共享库ABI实现的。 因此，该库保留了使用完整的现代C ++的能力，而没有任何限制（RTTI，异常，iostream等），这由libstdc ++ libc（newlib）提供。  l ibgcc-ABI。 在Linux的GCC / newlib / libstdc ++工具链和MacOS的clang / newlib / libc ++工具链上测试了类似的方法。 那些想在共享库中使用C ++的人可能会对该报告感兴趣，但由于外部依赖关系而无法承受。 <br><br><h3> 伊利亚·希什科夫（Ilya Shishkov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何教授C ++语言：在Coursera上创建课程的经验</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/zk/e6/sjzke6dn32bnehol5pyaeg9bmpe.png"></div><br> 在过去的一年半中，作者领导了Coursera专业化现代C ++的创建。 该专业将包括五门课程，其中两门已经在运行中，另一门几乎已准备就绪。 <br><br> 该报告将告诉： <br><br><ul><li> 在编写课程时会遇到什么问题（例如，经过3个月的工作，开发人员丢弃了所有材料，然后重新开始） </li><li> 课程的形成方式以及确切原因（例如，为什么“指针”一词在前两门课程中都没有出现） </li></ul><br> 此外，在专业化工作中，已经制定了一套适用于日常工作的原则： <br><br><ul><li> 在将新员工纳入项目的过程中 </li><li> 在代码审查期间 </li><li> 招聘时 </li></ul><br> 因此，作者不仅要告诉他们如何进行专业化，而且还要尝试将获得的经验转移到日常工作中。 <br><br><h3> 伊万·波诺马列夫（Ivan Ponomarev）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android NDK崩溃报告</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/yx/zc/h9yxzc_vcjlymv-gzh28xsaock4.png"></div><br> 在C / C ++中进行开发对代码质量的要求比在Java中进行开发更高的要求已不是什么秘密。 犯致命错误的可能性要高得多。 同时，即使对于有经验的程序员，收集有关此类错误的信息也不是一件容易的事。 <br><br> 在报告的第一部分中，我们将简要回顾现有的开发：内置的Android调试器如何工作，已有的解决方案。 第二部分专门讲述其如何在“幕后”工作：如何在发生错误时获取处理器状态，如何展开调用堆栈，如何在源代码中查找行号。 将给出堆栈升级库的概述，例如libcorkscrew，libunwind，libunwindstack。 <br><br> 该报告将吸引其应用程序使用NDK的Android开发人员以及其他所有人扩大视野。 <br><br><h3>  Fedor Short。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">记忆是完美的抽象</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/yh/ns/tcyhnsqf9zd7owu6oylohlcgkqe.png"></div><br>  int * ptr =新的int； <br>  * ptr = 42; <br> 删除ptr; <br><br> 当执行这三行代码时，实际发生了什么？ 我们将查看内存分配器，操作系统和现代硬件的内部，以详尽地回答这个问题。 <br><br><h3> 阿列克谢·萨尔敏（Alexey Salmin）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存管理技巧与窍门</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/re/ju/yirejuytypvwzo-ldwc-jmd4ylg.png"></div><br> 在2017年，在C ++中选择分配器的问题不会失去相关性。 他们为标准添加了一种新方法，可以为容器选择本地分配器（std :: pmr），全局tcmalloc和jemalloc以及它们所依赖的内核接口在不断发展。 该报告专门针对该设计的“下层”：Linux内核中mmap和madvise的功能以及这些功能对分配器性能的影响。 <br><br><h3> 草本萨特。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ 20中的新功能：太空飞船操作员</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ex/dw/jhexdwnxovbsvpbtftm3jmrofr0.png"></div><br> 新的飞船最近被用作C ++ 20的语言功能。 在本次演讲中，太空飞船提案的设计者和作者概述了该功能，讨论了其功能和设计，并逐步介绍了如何使用它的示例。 他特别强调了该功能如何使C ++代码的读写更清晰，避免多余的工作而变得更健壮，以及避免以前没有此功能时必须手工编写的更脆弱的代码中的几个重要但微妙的陷阱，从而使功能更强大。 <br><br><h3> 阿纳斯塔西娅·卡扎科娃（Anastasia Kazakova）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无需运行和编译即可调试C ++代码</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/na/ve/atnaverrgqdy-zv-xexxy6oan_g.png"></div><br> 当您查看模板，反射，编译阶段的代码生成，元类时，您会感觉到C ++已将自身设置为尽可能“隐藏”开发人员最终代码的任务。 随意使用预处理器（和许多分支）可能会使程序序列变得很不明显。 当然，这些方法可以使开发人员免于无休止的复制粘贴和代码基础类似部分的重复，但是需要开发工具提供更高级的支持。 <br><br> 是否可以调试代码而无需连续地重新启动代码，没有调试器，甚至没有简单地编译整个代码库？ 是否可以在无法在本地计算机上汇编或运行的代码中找到错误？ 有！ 集成开发环境（IDE）对定制代码具有广泛的知识和了解，正是他们可以提供适当的工具。 <br><br> 这份报告将展示如何“调试”由typedef嵌套的宏替换，了解变量的类型（在现代C ++中通常是“隐藏”的），调试预处理器或运算符重载的不同分支，以及借助真正智能的工具进行更多操作。集成开发环境 其中的某些功能已在CLion和ReSharper C ++中提供，而某些功能只是未来的有趣想法，与观众讨论将很有意思。 <br><br><h3> 尤金·卢基扬（Eugene Lukyanets）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用柯南在Docker中构建</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kt/es/9y/ktes9yg6zny3qia9p2qd6mksxqm.png"></div><br>  C ++项目的程序集可以在docker容器内移动，而无需在主机系统中安装必要的库和依赖项，它们可以直接安装在docker映像中（例如Cuda），也可以使用柯南库C ++管理器安装（例如，提升）。 这样就为程序集提供了一个隔离的受控（每次都是相同的）环境，您可以在其中连接Conan缓存，因此使用相同库的不同项目将使用相同的程序集。 同样，构建不再依赖于正在构建项目的Linux发行版，主要的是您可以在该发行版上运行Docker。 <br><br><h3> 丹尼斯·潘宁。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实用的元编程：编写异构哈希表</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/zf/8d/ilzf8daway7fam09ukocar1bdpw.png"></div><br> 在报告过程中，我们将使用std :: tuple编写一个小型工作库。 使用该库，我们将编译时间编译为异构哈希表。 此外，基于我们没有类型擦除这一事实，我们将在此基础上编写一个小型RPC框架。 <br><br>  C ++ 17中将有许多constexpr计算，模板和新功能（特别是constexpr）。 <br><br><h3> 德米特里·索科洛夫（Dmitry Sokolov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码生成反映了穷人</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/cy/ey/m6cyeyyxuncuuz_jzzlzzcwj8q8.png"></div><br> 通常需要反射来概括序列化算法。 各种协议的实现，与数据库一起使用。 为了解决这些问题，我们编写了一个自制IDL编译器来生成C ++结构，并编写了一个与结果进行交互的库。 带踏板的Protobuf以及是否值得。 <br><br><h3> 戴夫·范德沃德（Daveed Vandevoorde）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++中的反射元编程</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/ho/ie/5choiecmddpmcbekwyekclxdmlq.png"></div><br> 不久前，C ++标准化委员会创建了一个小组“ SG-7”，以探讨如何向语言添加反射功能。 最近，该小组在其工作板上增加了“元编程”，并就最终解决方案的形状做出了一些重大决策。 在这篇演讲中，作者回顾了带我们过去的过去，并研究了C ++对“反射元编程”的一流支持的可能途径。 <br><br><h3>  DietmarKühl。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于概念的测试</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/sa/3s/stsa3scg4ux8lm4x7avft5qzabg.png"></div><br> 随着概念被添加到C ++的下一个修订版中，预计将定义新概念。 每个概念都定义了通用代码使用的一组操作。 这样的用途之一可能是通用测试，它验证概念的所有部分均已定义，并检查概念操作之间的通用交互。 理想情况下，这样的测试甚至只适用于类，只能对概念进行部分建模以指导类的实现。 <br><br> 本演示文稿未使用实际的概念扩展，而是展示了如何使用C ++ 17的功能创建通用测试。 对于通用测试，检测惯用法和constexpr if用于确定所需操作的可用性并优雅地处理操作的缺失。 通用测试应该能够涵盖对概念建模的类的基础知识。 显然，类的特定行为仍需要进行相应的测试。 <br><br><h3> 西蒙·布兰德  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从CPU到GPU的现代C ++并行</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/qz/st/qqqzstnuzvnt3ev15p-9hngj3iy.png"></div><br> 并行编程可用于利用多核和异构架构，并可显着提高软件性能。 现代C ++在使并行编程更容易且更易于访问方面已经走了很长一段路。 提供高级和低级抽象。  C ++ 17通过提供高级并行算法使这一点更进一步，并且在C ++ 20中有望实现更多。 本演讲概述了当前可用的并行实用程序，并展望了未来如何通过新的标准库功能和其他标准（如SYCL）支持GPU和异构系统。 <br><br><h3> 安德烈·卡波夫（Andrey Karpov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有效的C ++（Maers与它无关：）</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/lp/mu/rblpmu6fzwwn7hnt3cim-pipjf0.png"></div><br>  C ++语言及其周围的基础结构不断发展，这使该语言成为当前最有效的工具之一。 我想强调三个因素，这些因素使C ++语言现在如此吸引人。 <br><br><ul><li> 第一：语言标准的创新，使您可以编写高效的代码。 </li><li> 第二：开发工具的成熟和项目组装速度的提高。 </li><li> 第三：成熟的支持工具，可让您控制代码的质量以及项目生命周期的其他方面。 </li></ul><br> 该报告是C ++编程语言的颂歌！ <br><br><h3> 伊万·普济列夫斯基（Ivan Puzyrevsky）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程异步</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/vx/iw/3gvxiw02427rxts0p3nza4kburu.png"></div><br> 在开发高负载的多线程或分布式应用程序领域中，人们可以越来越多地听到有关异步代码的对话，包括猜测是否需要考虑异步代码中的异步性，关于异步代码的可理解性及其效率（效率）。 在本报告中，我们将尝试更深入地研究主题领域：我们将分析什么是异步； 当它出现时； 它如何影响我们编写的代码和我们使用的编程语言。 我们将尝试弄清期货和承诺与它有什么关系，让我们谈谈协程和演员。 我们将影响JavaScript和操作系统。 该报告的目的是更明确地说明一种或多种开发多线程或分布式软件的方法所引起的妥协。 <br><br><h3> 帕维尔·布拉托夫（Pavel Bulatov）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切换到WebAssembly：游戏值得吗？</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/s6/ga/vts6gamnunde4u6qzk6p_4zqc6c.png"></div><br> 该报告将讨论WebAssembly与实际产品相关的当前状态。 我们将讨论我们在移植应用程序方面的经验，出现了什么问题以及如何解决它们。 <br><br> 涵盖的主题包括： <br><br><ul><li> 在不同平台和浏览器上支持该标准。 </li><li> 性能和构建大小与asm.js的比较。 </li><li> 与浏览器的交互。 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户崩溃。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM功能。 </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">德米特里·科热夫尼科夫（Dmitry Kozhevnikov）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake陷阱及其住所</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/_l/qr/zt_lqrmu-qimm8_m2z7g_zd2xsg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake构建系统正逐渐成为跨平台C ++编程的事实上的标准。</font><font style="vertical-align: inherit;">但是，它经常受到公平的批评，包括不方便的脚本语言，过时的文档以及其中相同的任务可以以不同的方式执行的事实，并且很难理解哪种情况在特定情况下更正确。</font><font style="vertical-align: inherit;">作者将告诉：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 常见的流行反模式以及它们为什么不好的原因， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CMake在什么级别的抽象上起作用，它们何时“泄漏”， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 什么是“现代CMake”及其优势是什么， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何本地化和调试CMake脚本中的问题（包括一些相当奇特的脚本）。 </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢尔盖·桑比尔。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当程序C ++很好时</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ib/vy/kxibvyhzvf5taodgpswkywptk9y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目的整洁架构，每一层上的简单抽象是任何团队的梦想。</font><font style="vertical-align: inherit;">为了实现这个梦想，发明了许多面向对象的技术。</font><font style="vertical-align: inherit;">被OOP带走的开发人员忘记了在C和C ++交界处监视代码的清洁度。</font><font style="vertical-align: inherit;">在这里，过程样式将有助于恢复顺序，建立方便且安全的抽象，这些抽象很容易适合项目的面向对象代码。</font><font style="vertical-align: inherit;">我们将发现：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为什么需要隔离C API（例如winapi，POSIX，SQLite，OpenGL，Op​​enSSL） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为什么OOP在这项业务中表现不佳 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何在C风格的API之上编写抽象层 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如何处理回调，错误处理和资源管理，以使传统上复杂且令人困惑的代码即使对于初级用户也可以理解 </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叶夫根尼·祖耶夫（Evgeny Zuev）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++程序的语义API</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/wb/d4/-ewbd4monfzqy8msagott8iaxzu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他的专业兴趣是编程语言的语义，YaP编译器的设计和实现以及其他面向语言的工具。</font><font style="vertical-align: inherit;">其中最重要的成就是参与了以下项目：创建完整的C ++语言标准的编译器（Interstron，莫斯科，2000年），针对.NET的Zonnon语言编译器的实现（苏黎世联邦理工学院，2005年）以及为Tizen平台实现原型Swift编译器（三星研究院，莫斯科，2015年）。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伊万·乔基奇（IvanČukić）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020：奥德赛之旅</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/_4/qw/lz_4qwm76c6mz0aadcqwqcd8av8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++始终具有强大的元编程子语言，该语言允许库开发人员执行不可思议的壮举，例如静态自省，从而无需继承即可实现多态执行。</font><font style="vertical-align: inherit;">问题在于语法笨拙且不必要地冗长，这使得学习元编程成为一项艰巨的任务。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着标准的最新改进以及计划用于C ++ 20的功能，元编程变得更加容易，元程序变得更易于理解和推论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本次演讲中，作者介绍了一些元编程的现代技术，主要关注神奇的void_t元函数。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叶夫根尼·奥克霍特尼科夫（Evgeny Okhotnikov）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++演员：值得吗？</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/tn/tw/9ttntwqtinuogjfwkd0jjbqn8ko.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该报告的作者已负责开放源SObjectizer框架的开发长达16年。</font><font style="vertical-align: inherit;">这是为数不多的针对C ++的实时开发中的跨平台参与者框架之一。</font><font style="vertical-align: inherit;">SObjectizer的开发始于2002年，当时C ++是最流行和通用的编程语言之一。</font><font style="vertical-align: inherit;">在过去的时间里，C ++发生了很大变化，对C ++的态度也发生了很大变化。</font><font style="vertical-align: inherit;">该报告将讨论这些变化如何影响具有16年历史的工具的开发，以及使用C ++语言制作这样的工具有多么简单和方便。</font><font style="vertical-align: inherit;">以及是否有必要为C ++制作这样的工具。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赖纳·格林（Rainer Grimm）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现代C ++中的并发最佳实践</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/12/j2/yk12j2luup7tzp2at0vt9epwr6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着C ++ 11的标准化，我们在C ++中获得了一个多线程库和一个内存模型。</font><font style="vertical-align: inherit;">该库具有基本的构造块，例如原子，线程，任务，锁和条件变量。</font><font style="vertical-align: inherit;">内存模型为此基本构建块的线程安全使用提供了保证。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">七年后，我们有了许多最佳实践，可以安全地应用多线程和内存模型。</font><font style="vertical-align: inherit;">作者的演讲恰恰是关于并发通用规则，多线程库的特殊规则以及内存模型的特殊规则的这些最佳实践。</font><font style="vertical-align: inherit;">这种最佳实践的重点远不止C ++。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阿列克谢·马洛夫（Alexey Malov）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在桌面应用程序开发中使用现代C ++的经验</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uu/te/59/uute59evuanipkaccp6qabg1ari.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 演讲将涉及C ++语言的工具以及Boost和STL库，以及用于构建GUI应用程序的体系结构方法，我们使用该方法来开发用于创建视频课程的工具。 </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 练习使用Model-View-Presenter模式 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 文件生命周期管理 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 智能指针文件存储 </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢尔盖·瓦西里耶夫（Sergey Vasiliev）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态分析：寻找错误和漏洞？</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/it/1h/z7it1hjlb46zf_4xp1pvsqlyqbq.png"></div><br> 有关发现下一个漏洞的新闻经常在这里和那里弹出。 通常，美元的附带损失是巨大的。 因此，与其修复漏洞，不应该允许它们出现。 <br><br> 处理代码错误的一种方法是使用静态分析。 但是搜索漏洞有多合适？ 在简单的错误和代码漏洞之间真的有很大的区别吗？ <br><br> 我们将在报告中讨论这些问题，同时，我们还将讨论如何使用静态分析以充分利用它。 <br><br>  <b>聚苯乙烯</b> <br><br> 我个人想提请您注意与我的同事Andrei Karpov的报告有关的<i>std :: string</i>周围的小问题。 因此，为了： <br><br><ol><li> 安德烈（Andrei）报告（C ++ Russia 2016）的一部分，摘自30：05- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">link的</a> “来自代码分析器开发人员的私人故事”。 </li><li>  Anton Polukhin（C ++ Russia 2017）在2：00- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">link的</a> “如何不做：专业人士的C ++自行车建造”报告中对像我们这样的人进行了轻松的拖拉。 </li><li> 安德烈（Andrey）在2018年C ++俄罗斯大会上的故事，我们不是恐龙，而是在学习新事物：从12:21开始的“有效C ++” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> 。 </li></ol><br> 仅此而已！ 享受您的报告。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418645/">https://habr.com/ru/post/zh-CN418645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418635/index.html">创建一个模拟器街机。 第一部分</a></li>
<li><a href="../zh-CN418637/index.html">Kubernetes面向大众：Slurm将于8月3日开始</a></li>
<li><a href="../zh-CN418639/index.html">仅有凡人的Akka流</a></li>
<li><a href="../zh-CN418641/index.html">一个使设计师无法成长的错误</a></li>
<li><a href="../zh-CN418643/index.html">坐vs站：如何更好地工作？</a></li>
<li><a href="../zh-CN418647/index.html">TESS启动系外行星搜索</a></li>
<li><a href="../zh-CN418649/index.html">连续生成替代版本的TLS将解决旧协议僵化的问题</a></li>
<li><a href="../zh-CN418651/index.html">7月30日至8月5日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN418653/index.html">WebAssembly是否返回Java和Flash小程序？</a></li>
<li><a href="../zh-CN418655/index.html">Windows Mixed Reality：开发人员指南（第1部分）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>