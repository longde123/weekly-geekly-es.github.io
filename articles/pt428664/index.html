<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüíª üöö ‚è∫Ô∏è Inicializa√ß√£o do kernel do Linux. Parte 1 üçü üòÄ üë®üèΩ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do gerenciador de inicializa√ß√£o para o kernel 

 Se voc√™ leu os artigos anteriores, conhece o meu novo hobby para programa√ß√£o de baixo n√≠vel. Escrevi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inicializa√ß√£o do kernel do Linux. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>Do gerenciador de inicializa√ß√£o para o kernel</b> <br><br>  Se voc√™ leu os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> anteriores, conhece o meu novo hobby para programa√ß√£o de baixo n√≠vel.  Escrevi v√°rios artigos sobre programa√ß√£o de assembler para o <code>x86_64</code> Linux e, ao mesmo tempo, comecei a mergulhar no c√≥digo fonte do kernel do Linux. <br><br>  Estou muito interessado em entender como as coisas de baixo n√≠vel funcionam: como os programas s√£o executados no meu computador, como est√£o localizados na mem√≥ria, como o kernel gerencia processos e mem√≥ria, como a pilha de rede funciona em um n√≠vel baixo e muito mais.  Ent√£o, decidi escrever outra s√©rie de artigos sobre o kernel do Linux para a <b>arquitetura x86_64</b> . <br><br>  Observe que eu n√£o sou um desenvolvedor profissional de kernel e n√£o escrevo c√≥digo do kernel no trabalho.  Este √© apenas um hobby.  Eu apenas gosto de coisas de baixo n√≠vel e √© interessante mergulhar nelas.  Portanto, se voc√™ perceber alguma confus√£o ou perguntas / coment√°rios aparecerem, entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em</a> contato comigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Twitter</a> , por <a href="">correio</a> ou apenas crie um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ticket</a> .  Eu ficaria grato. <br><a name="habracut"></a><br>  Todos os artigos s√£o publicados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio GitHub</a> e, se algo estiver errado com o meu ingl√™s ou com o conte√∫do do artigo, n√£o hesite em enviar uma solicita√ß√£o de recebimento. <br><br>  <i>Observe que isso n√£o √© documenta√ß√£o oficial, mas simplesmente treinamento e compartilhamento de conhecimento.</i> <br><br>  <b>Conhecimento requerido</b> <br><br><ul><li>  No√ß√µes b√°sicas sobre c√≥digo C </li><li>  Compreendendo o c√≥digo do assembler (sintaxe da AT&amp;T) </li></ul><br>  De qualquer forma, se voc√™ est√° apenas come√ßando a aprender essas ferramentas, tentarei explicar algo neste e em outros artigos.  Ok, com a introdu√ß√£o conclu√≠da, √© hora de mergulhar no kernel do Linux e coisas de baixo n√≠vel. <br><br>  Comecei a escrever este livro nos dias do kernel do Linux 3.18 e muita coisa mudou desde ent√£o.  Se houver altera√ß√µes, atualizarei os artigos de acordo. <br><br><h1>  Bot√£o de energia m√°gico, o que vem a seguir? </h1><br>  Embora estes sejam artigos sobre o kernel do Linux, ainda n√£o o alcan√ßamos - pelo menos nesta se√ß√£o.  Assim que voc√™ pressiona o bot√£o liga / desliga m√°gico no laptop ou no computador, ele come√ßa a funcionar.  A placa-m√£e envia um sinal para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte de alimenta√ß√£o</a> .  Ap√≥s receber o sinal, ele fornece ao computador a quantidade necess√°ria de eletricidade.  Assim que a placa-m√£e recebe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sinal "Power OK"</a> , ela tenta iniciar a CPU.  Ele despeja todos os dados restantes em seus registros e define valores predefinidos para cada um deles. <br><br>  Os processadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">80386</a> e vers√µes posteriores devem ter os seguintes valores nos registros da CPU ap√≥s uma reinicializa√ß√£o: <br><br><pre>  IP 0xfff0
 Seletor CS 0xf000
 CS base 0xffff0000 </pre><br>  O processador come√ßa a funcionar em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modo real</a> .  Vamos voltar um pouco e tentar entender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a segmenta√ß√£o de mem√≥ria</a> nesse modo.  O modo real √© suportado em todos os processadores compat√≠veis com x86: de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8086</a> a modernos processadores Intel de 64 bits.  O processador 8086 usa um barramento de endere√ßos de 20 bits, ou seja, pode trabalhar com um espa√ßo de endere√ßo de <code>0-0xFFFFF</code> ou <code>1 </code> .  Mas ele possui apenas registros de 16 bits com um endere√ßo m√°ximo de <code>2^16-1</code> ou <code>0xffff</code> (64 kilobytes). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A segmenta√ß√£o de mem√≥ria √©</a> necess√°ria para usar todo o espa√ßo de endere√ßo dispon√≠vel.  Toda a mem√≥ria √© dividida em pequenos segmentos de tamanho fixo de <code>65536</code> bytes (64 KB).  Como com registros de 16 bits, n√£o podemos acessar a mem√≥ria acima de 64 KB, um m√©todo alternativo foi desenvolvido. <br><br>  O endere√ßo consiste em duas partes: 1) um seletor de segmento com um endere√ßo base;  2) deslocamento do endere√ßo base.  No modo real, o endere√ßo base do <code>  * 16</code> segmentos <code>  * 16</code> .  Portanto, para obter o endere√ßo f√≠sico na mem√≥ria, voc√™ precisa multiplicar parte do seletor de segmentos por 16 e adicionar o deslocamento a ele: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Por exemplo, se o registro <code>CS:IP</code> tiver o valor <code>0x2000:0x0010</code> , o endere√ßo f√≠sico correspondente ser√° o seguinte: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  Mas se voc√™ escolher o seletor do maior segmento e o deslocamento <code>0xffff:0xffff</code> , obter√° o endere√ßo: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  isto √©, <code>65520</code> bytes ap√≥s o primeiro megabyte.  Como apenas um megabyte est√° dispon√≠vel no modo real, <code>0x10ffef</code> se torna <code>0x00ffef</code> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a linha A20</a> desativada. <br><br>  Bem, agora sabemos um pouco sobre o modo real e o endere√ßamento de mem√≥ria nesse modo.  Vamos voltar √† discuss√£o dos valores do registro ap√≥s a redefini√ß√£o. <br><br>  O registro <code>CS</code> consiste em duas partes: um seletor de segmento vis√≠vel e um endere√ßo base oculto.  Embora o endere√ßo base seja geralmente formado pela multiplica√ß√£o do valor do seletor de segmentos por 16, durante uma redefini√ß√£o de hardware, o seletor de segmentos no registro CS √© <code>0xf000</code> e o endere√ßo base √© <code>0xffff0000</code> .  O processador usa esse endere√ßo base especial at√© o CS mudar. <br><br>  O endere√ßo inicial √© formado adicionando o endere√ßo base ao valor no registro EIP: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  Temos <code>0xfffffff0</code> , que √© 16 bytes abaixo de 4 GB.  Esse ponto √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetor de redefini√ß√£o</a> .  Este √© o local na mem√≥ria em que a CPU aguarda a execu√ß√£o da primeira instru√ß√£o ap√≥s uma redefini√ß√£o: uma opera√ß√£o de salto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jmp</a> ), que geralmente indica o ponto de entrada do BIOS.  Por exemplo, se voc√™ olhar o c√≥digo fonte do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coreboot</a> ( <code>src/cpu/x86/16bit/reset16.inc</code> ), veremos: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Aqui vemos o c√≥digo de opera√ß√£o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opcode</a> ) <code>jmp</code> , ou <code>0xe9</code> , <code>0xe9</code> , e o endere√ßo de destino <code>_start16bit - ( . + 2)</code> . <br><br>  Tamb√©m vemos que a se√ß√£o de <code>reset</code> √© de 16 bytes e √© compilada para ser executada a partir do endere√ßo <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ): <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  O BIOS agora inicia;  Depois de inicializar e verificar o hardware do BIOS, voc√™ precisa encontrar o dispositivo de inicializa√ß√£o.  A ordem de inicializa√ß√£o √© salva na configura√ß√£o do BIOS.  Ao tentar inicializar a partir do disco r√≠gido, o BIOS tenta encontrar o setor de inicializa√ß√£o.  Nos discos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">particionados MBR</a> , o setor de inicializa√ß√£o √© armazenado nos primeiros 446 bytes do primeiro setor, em que cada setor tem 512 bytes.  Os dois √∫ltimos bytes do primeiro setor s√£o <code>0x55</code> e <code>0xaa</code> .  Eles mostram ao BIOS que √© um dispositivo de inicializa√ß√£o. <br><br>  Por exemplo: <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br>  Coletamos e executamos: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O QEMU</a> recebe um comando para usar o bin√°rio de <code>boot</code> que acabamos de criar como imagem de disco.  Como o arquivo bin√°rio gerado acima atende aos requisitos do setor de inicializa√ß√£o (iniciando em <code>0x7c00</code> e terminando com uma sequ√™ncia m√°gica), o QEMU considerar√° o bin√°rio como o registro mestre de inicializa√ß√£o (MBR) da imagem de disco. <br><br>  Voc√™ ver√°: <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  Neste exemplo, vemos que o c√≥digo √© executado no modo real de 16 bits e inicia no endere√ßo <code>0x7c00</code> na mem√≥ria.  Ap√≥s iniciar, causa uma interrup√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">0x10</a> , que simplesmente imprime um personagem <code>!</code>  ;  preenche os 510 bytes restantes com zeros e termina com dois bytes m√°gicos <code>0xaa</code> e <code>0x55</code> . <br><br>  Voc√™ pode ver o despejo bin√°rio com o utilit√°rio <code>objdump</code> : <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Obviamente, no setor de inicializa√ß√£o real, h√° c√≥digo para continuar o processo de inicializa√ß√£o e uma tabela de parti√ß√£o em vez de um monte de zeros e um ponto de exclama√ß√£o :).  A partir deste momento, o BIOS transfere o controle para o carregador de inicializa√ß√£o. <br><br>  <i>Nota</i> : como explicado acima, a CPU est√° no modo real;  onde o c√°lculo do endere√ßo f√≠sico na mem√≥ria √© o seguinte: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Temos apenas registradores de uso geral de 16 bits e o valor m√°ximo do registrador de 16 bits √© <code>0xffff</code> ; portanto, nos maiores valores, o resultado ser√°: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  onde <code>0x10ffef</code> √© <code>1  + 64  - 16 </code> .  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">processador 8086</a> (o primeiro processador no modo real) possui uma linha de endere√ßo de 20 bits.  Como <code>2^20 = 1048576</code> , a mem√≥ria dispon√≠vel real √© de 1 MB. <br><br>  Em geral, o endere√ßamento de mem√≥ria em modo real √© o seguinte: <br><br><pre>  0x00000000 - 0x000003FF - tabela de vetores de interrup√ß√£o do modo real
 0x00000400 - 0x000004FF - √°rea de dados do BIOS
 0x00000500 - 0x00007BFF - n√£o usado
 0x00007C00 - 0x00007DFF - nosso gerenciador de inicializa√ß√£o
 0x00007E00 - 0x0009FFFF - n√£o usado
 0x000A0000 - 0x000BFFFF - RAM de v√≠deo (VRAM) 
 0x000B0000 - 0x000B7777 - mem√≥ria de v√≠deo monocrom√°tica
 0x000B8000 - 0x000BFFFF - mem√≥ria de v√≠deo em modo de cor
 0x000C0000 - 0x000C7FFF - BIOS de ROM de v√≠deo
 0x000C8000 - 0x000EFFFF - √°rea de sombra (BIOS Shadow)
 0x000F0000 - 0x000FFFFF - BIOS do sistema </pre><br>  No in√≠cio do artigo, est√° escrito que a primeira instru√ß√£o do processador est√° localizada em <code>0xFFFFFFF0</code> , que √© muito mais que <code>0xFFFFF</code> (1 MB).  Como a CPU pode acessar esse endere√ßo no modo real?  Resposta na documenta√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coreboot</a> : <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  No in√≠cio da execu√ß√£o, o BIOS n√£o est√° na RAM, mas na ROM. <br><br><h1>  Carregador de inicializa√ß√£o </h1><br>  O kernel do Linux pode ser carregado com diferentes gerenciadores de inicializa√ß√£o, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GRUB 2</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">syslinux</a> .  O kernel possui um protocolo de inicializa√ß√£o que define os requisitos do carregador de inicializa√ß√£o para implementar o suporte ao Linux.  Neste exemplo, estamos trabalhando com o GRUB 2. <br><br>  Continuando o processo de inicializa√ß√£o, o BIOS selecionou o dispositivo de inicializa√ß√£o e transferiu o controle para o setor de inicializa√ß√£o, a execu√ß√£o come√ßa com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boot.img</a> .  Devido ao seu tamanho limitado, este √© um c√≥digo muito simples.  Ele cont√©m um ponteiro para acessar a imagem principal do GRUB 2. Ele come√ßa com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diskboot.img</a> e geralmente √© armazenado imediatamente ap√≥s o primeiro setor no espa√ßo n√£o utilizado antes da primeira parti√ß√£o.  O c√≥digo acima carrega na mem√≥ria o restante da imagem que cont√©m o kernel do GRUB 2 e os drivers para o processamento de sistemas de arquivos.  Depois disso, a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grub_main</a> √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">executada</a> . <br><br>  A fun√ß√£o <code>grub_main</code> inicializa o console, retorna o endere√ßo base dos m√≥dulos, define o dispositivo raiz, carrega / analisa o arquivo de configura√ß√£o do grub, carrega os m√≥dulos, etc.  No final da execu√ß√£o, coloca o grub no modo normal.  A fun√ß√£o <code>grub_normal_execute</code> (do arquivo de origem <code>grub-core/normal/main.c</code> ) conclui as √∫ltimas prepara√ß√µes e exibe um menu para escolher o sistema operacional.  Quando selecionamos um dos itens de menu do grub, a fun√ß√£o <code>grub_menu_execute_entry</code> √© <code>grub_menu_execute_entry</code> , que executa o comando de <code>boot</code> do grub e carrega o sistema operacional selecionado. <br><br>  Conforme indicado no protocolo de inicializa√ß√£o do kernel, o carregador de inicializa√ß√£o deve ler e preencher alguns campos do cabe√ßalho de instala√ß√£o do kernel, que inicia no deslocamento <code>0x01f1</code> do c√≥digo de instala√ß√£o do kernel.  Esse deslocamento √© indicado no <a href="">script</a> do <a href="">vinculador</a> .  O cabe√ßalho do kernel <a href="">arch / x86 / boot / header.S</a> come√ßa com: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  O carregador de inicializa√ß√£o deve preencher este e outros cabe√ßalhos (que s√£o marcados apenas como tipo <code>write</code> no protocolo de inicializa√ß√£o do Linux, como neste exemplo) com valores recebidos da linha de comando ou calculados no momento da inicializa√ß√£o.  Agora n√£o vamos nos debru√ßar nas descri√ß√µes e explica√ß√µes para todos os campos de cabe√ßalho.  Discutiremos mais tarde como o kernel os usa.  Para uma descri√ß√£o de todos os campos, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o protocolo de download</a> . <br><br>  Como voc√™ pode ver no protocolo de inicializa√ß√£o do kernel, a mem√≥ria ser√° exibida da seguinte maneira: <br><br><pre>  |  Modo protegido do kernel |
 100000 + ------------------------ +
          |  Mapeamento de E / S |
 0A0000 + ------------------------ +
          |  Reserva  para BIOS |  Deixe o m√°ximo poss√≠vel livre
          ~ ~
          |  Linha de comando |  (tamb√©m pode estar abaixo de X + 10000)
 X + 10000 + ------------------------ +
          |  Pilha / pilha |  Para usar o c√≥digo real do modo kernel
 X + 08000 + ------------------------ +
          |  Instala√ß√£o do Kernel |  C√≥digo de modo real do kernel
          |  Setor de inicializa√ß√£o do kernel |  Setor de inicializa√ß√£o do kernel herdado
        X + ------------------------ +
          |  Carregador |  &lt;- Ponto de entrada do setor de inicializa√ß√£o 0x7C00
 001000 + ------------------------ +
          |  Reserva  para MBR / BIOS |
 000800 + ------------------------ +
          |  Costuma usar  MBR
 000600 + ------------------------ +
          |  Usado  Apenas BIOS |
 000000 + ------------------------ +
</pre><br>  Portanto, quando o carregador transfere o controle para o kernel, ele come√ßa com o endere√ßo: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  onde <code>X</code> √© o endere√ßo do setor de inicializa√ß√£o do kernel.  No nosso caso, <code>X</code> √© <code>0x10000</code> , como visto no despejo de mem√≥ria: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  O carregador de inicializa√ß√£o moveu o kernel do Linux para a mem√≥ria, preencheu os campos do cabe√ßalho e depois mudou-se para o endere√ßo de mem√≥ria correspondente.  Agora podemos ir diretamente para o c√≥digo de instala√ß√£o do kernel. <br><br><h1>  In√≠cio da fase de instala√ß√£o do kernel </h1><br>  Finalmente, estamos no centro!  Embora tecnicamente ainda n√£o esteja em execu√ß√£o.  Primeiro, a parte de instala√ß√£o do kernel precisa configurar algo, incluindo um descompactador e algumas coisas com o gerenciamento de mem√≥ria.  Depois de tudo isso, ela vai descompactar o n√∫cleo real e seguir em frente.  A instala√ß√£o inicia em <a href="">arch / x86 / boot / header.S</a> com o caractere <a href="">_start</a> . <br><br>  √Ä primeira vista, isso pode parecer um pouco estranho, pois h√° v√°rias instru√ß√µes √† sua frente.  Mas h√° muito tempo, o kernel do Linux tinha seu pr√≥prio gerenciador de inicializa√ß√£o.  Agora, se voc√™ executar, por exemplo, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  voc√™ ver√°: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  Na verdade, o arquivo <code>header.S</code> come√ßa com o n√∫mero m√°gico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MZ</a> (veja a captura de tela do despejo acima), o texto da mensagem de erro e o cabe√ßalho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PE</a> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  √â necess√°rio carregar um sistema operacional com suporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UEFI</a> .  Vamos considerar seu dispositivo nos pr√≥ximos cap√≠tulos. <br><br>  Ponto de entrada real para instalar o kernel: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  O gerenciador de inicializa√ß√£o (grub2 e outros) conhece esse ponto (deslocamento <code>0x200</code> do <code>MZ</code> ) e vai diretamente para ele, embora o <code>header.S</code> comece na se√ß√£o <code>.bstext</code> , onde o texto da mensagem de erro est√° localizado: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Ponto de entrada da instala√ß√£o do kernel: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Aqui vemos o c√≥digo de opera√ß√£o <code>jmp</code> ( <code>0xeb</code> ), que vai para o ponto <code>start_of_setup-1f</code> .  Na nota√ß√£o <code>Nf</code> , por exemplo, <code>2f</code> refere-se ao r√≥tulo local <code>2:</code>  No nosso caso, esse √© o r√≥tulo <code>1</code> , que est√° presente imediatamente ap√≥s a transi√ß√£o e cont√©m o restante do cabe√ßalho da instala√ß√£o.  Imediatamente ap√≥s o cabe√ßalho da instala√ß√£o, vemos a se√ß√£o <code>.entrytext</code> , que come√ßa com o r√≥tulo <code>start_of_setup</code> . <br><br>  Este √© o primeiro c√≥digo realmente executado (al√©m das instru√ß√µes de salto anteriores, √© claro).  Depois que parte da instala√ß√£o do kernel recebe controle do carregador, a primeira instru√ß√£o <code>jmp</code> fica localizada no deslocamento <code>0x200</code> desde o in√≠cio do modo real do kernel, ou seja, ap√≥s os primeiros 512 bytes.  Isso pode ser visto no protocolo de inicializa√ß√£o do kernel Linux e no c√≥digo-fonte grub2: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  No nosso caso, o kernel √© inicializado no endere√ßo <code>0x10000</code> .  Isso significa que, ap√≥s iniciar a instala√ß√£o do kernel, os registradores de segmento ter√£o os seguintes valores: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  Depois de <code>start_of_setup</code> kernel deve fazer o seguinte: <br><br><ul><li>  Verifique se todos os valores de registro de segmento s√£o os mesmos </li><li>  Se necess√°rio, configure a pilha correta </li><li>  Configurar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bss</a> </li><li>  V√° para o c√≥digo C em <a href="">arch / x86 / boot / main.c</a> </li></ul><br>  Vamos ver como isso √© implementado. <br><br><h1>  Alinhamento de caso por segmento </h1><br>  Primeiro, o kernel verifica se os registros do segmento <code>ds</code> e <code>es</code> apontam para o mesmo endere√ßo.  Em seguida, ele limpa o sinalizador de dire√ß√£o usando a <code>cld</code> : <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  Como escrevi anteriormente, o grub2, por padr√£o, carrega o c√≥digo de instala√ß√£o do kernel em <code>0x10000</code> e <code>cs</code> em <code>0x10200</code> , porque a execu√ß√£o n√£o inicia no in√≠cio do arquivo, mas na transi√ß√£o aqui: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  Este √© um deslocamento de <code>512</code> bytes de <a href="">4d 5a</a> .  Tamb√©m √© necess√°rio alinhar <code>cs</code> de <code>0x10200</code> a <code>0x10000</code> , como todos os outros registradores de segmento.  Depois disso, instale a pilha: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  Esta instru√ß√£o coloca o valor <code>ds</code> na pilha, seguido pelo endere√ßo da etiqueta <a href="">6</a> e a instru√ß√£o <code>lretw</code> , que carrega o endere√ßo da etiqueta <code>6</code> no registro do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contador de comandos</a> e carrega <code>cs</code> com o valor <code>ds</code> .  Depois disso, <code>ds</code> e <code>cs</code> ter√£o os mesmos valores. <br><br><h1>  Configura√ß√£o da pilha </h1><br>  Quase todo esse c√≥digo faz parte do processo de prepara√ß√£o do ambiente C em modo real.  A pr√≥xima etapa √© verificar o valor do registro <code>ss</code> e criar a pilha correta se o valor <code>ss</code> estiver incorreto: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  Isso pode desencadear tr√™s cen√°rios diferentes: <br><br><ul><li>  <code>ss</code> valor v√°lido de <code>0x1000</code> (como em todos os outros registradores, exceto <code>cs</code> ) </li><li>  <code>ss</code> valor inv√°lido e o sinalizador <code>CAN_USE_HEAP</code> definido (veja abaixo) </li><li>  <code>ss</code> valor inv√°lido e o sinalizador <code>CAN_USE_HEAP</code> n√£o <code>CAN_USE_HEAP</code> definido (veja abaixo) </li></ul><br>  Considere todos os cen√°rios em ordem: <br><br><ul><li>  <code>ss</code> valor v√°lido ( <code>0x1000</code> ).  Nesse caso, vamos rotular 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Aqui, definimos o alinhamento do registro <code>dx</code> (que cont√©m o valor <code>sp</code> especificado pelo carregador) como <code>4</code> bytes e verificamos o zero.  Se for zero, colocamos o valor <code>0xfffc</code> <code>dx</code> (endere√ßo alinhado a <code>4</code> bytes antes do tamanho m√°ximo do segmento de 64 KB).  Se n√£o for igual a zero, continuamos a usar o valor <code>sp</code> especificado pelo carregador de inicializa√ß√£o ( <code>0xf7f4</code> no nosso caso).  Em seguida, colocamos o valor do <code>ax</code> em <code>ss</code> , que salva o endere√ßo de segmento correto <code>0x1000</code> e define o <code>sp</code> correto.  Agora temos a pilha correta: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  No segundo cen√°rio, <code>ss != ds</code> .  Primeiro, colocamos o valor <a href="">_end</a> (o endere√ßo do final do c√≥digo de instala√ß√£o) em <code>dx</code> e verificamos o campo de cabe√ßalho <code>loadflags</code> , usando a instru√ß√£o <code>testb</code> para verificar se o heap pode ser usado.  <a href="">loadflags</a> √© um cabe√ßalho de m√°scara de <a href="">bit</a> que √© definido da seguinte maneira: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  e conforme indicado no protocolo de inicializa√ß√£o: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  Se o bit <code>CAN_USE_HEAP</code> estiver <code>CAN_USE_HEAP</code> , em <code>dx</code> , definimos o valor <code>heap_end_ptr</code> (que aponta para <code>_end</code> ) e adicionamos <code>STACK_SIZE</code> a ele (o tamanho m√≠nimo da pilha √© <code>1024</code> bytes).  Depois disso, v√° para o r√≥tulo <code>2</code> (como no caso anterior) e fa√ßa a pilha correta. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  Se <code>CAN_USE_HEAP</code> n√£o <code>CAN_USE_HEAP</code> definido, use a pilha m√≠nima de <code>_end</code> a <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  Configura√ß√£o do BSS </h1><br>  S√£o necess√°rias mais duas etapas antes de passar para o c√≥digo C principal: isso √© configurar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rea BSS</a> e verificar a assinatura ‚Äúm√°gica‚Äù.  Verifica√ß√£o de assinatura primeiro: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  A instru√ß√£o simplesmente compara <a href="">setup_sig</a> com o n√∫mero m√°gico 0x5a5aaa55.  Se eles n√£o forem iguais, um erro fatal √© relatado. <br><br>  Se o n√∫mero m√°gico corresponder e tivermos um conjunto correto de registradores de segmentos e uma pilha, tudo o que resta √© configurar a se√ß√£o BSS antes de prosseguir para o c√≥digo C. <br><br>  A se√ß√£o BSS √© usada para armazenar dados n√£o inicializados estaticamente alocados.  O Linux verifica cuidadosamente se essa √°rea de mem√≥ria foi redefinida: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  Primeiro, o endere√ßo inicial de <a href="">__bss_start √©</a> movido para <code>di</code> .  Em seguida, o endere√ßo <code>_end + 3</code> (+3 para alinhamento por 4 bytes) √© movido para <code>cx</code> .  O registro <code>eax</code> √© limpo (usando a instru√ß√£o <code>xor</code> ), o tamanho da se√ß√£o bss ( <code>cx-di</code> ) √© calculado e colocado em <code>cx</code> .  Ent√£o <code>cx</code> √© dividido em quatro (o tamanho da ‚Äúpalavra‚Äù) e a instru√ß√£o <code>stosl</code> √© usada <code>stosl</code> , armazenando o valor <code></code> (zero) no endere√ßo apontando para <code>di</code> , aumentando automaticamente <code>di</code> em quatro e repetindo isso at√© que <code></code> chegue a zero).  O efeito <code>__bss_start</code> desse c√≥digo √© que zeros s√£o gravados em todas as palavras na mem√≥ria, de <code>__bss_start</code> a <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  V√° para o principal </h1><br>  √â isso: temos uma pilha e BSS, para que voc√™ possa ir para a fun√ß√£o <code>main()</code> C: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  A fun√ß√£o <code>main()</code> est√° localizada em <a href="">arch / x86 / boot / main.c.</a>  Falaremos sobre ela na pr√≥xima parte. <br><br><h1>  Conclus√£o </h1><br>  Este √© o fim da primeira parte do dispositivo do kernel Linux.       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,  <a href=""></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .         C,      Linux,   ,   <code>memset</code> , <code>memcpy</code> , <code>earlyprintk</code> ,        . <br><br><h1>  Refer√™ncias </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel 80386,  , 1986 .</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    Intel</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8086</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">80386</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   Linux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coreboot,  </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> ¬´  ¬ª</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428664/">https://habr.com/ru/post/pt428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428654/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 15: Software M√©dico, Parte 2</a></li>
<li><a href="../pt428656/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 15: Software M√©dico, Parte 3</a></li>
<li><a href="../pt428658/index.html">Oficinas educacionais gratuitas no escrit√≥rio do Mail.Ru Group</a></li>
<li><a href="../pt428660/index.html">Habilitando pol√≠ticas extensivas de solicita√ß√£o de recebimento no VSTS para oferecer suporte ao processo de desenvolvimento</a></li>
<li><a href="../pt428662/index.html">Tarefa de programa√ß√£o de varejo</a></li>
<li><a href="../pt428666/index.html">Como criei anima√ß√µes que mudam de humor usando m√°scaras CSS</a></li>
<li><a href="../pt428668/index.html">A Blizzard anunciou o lan√ßamento do relan√ßamento do WarCraft III em 2019. Abrir pr√©-encomenda</a></li>
<li><a href="../pt428672/index.html">Vis√£o geral do QuietOn Active Squelch</a></li>
<li><a href="../pt428674/index.html">Criando roteamento de cliente / pesquisa sem√¢ntica no Profi.ru</a></li>
<li><a href="../pt428676/index.html">Quebrando os fundamentos fundamentais do C #: alocando mem√≥ria para um tipo de refer√™ncia na pilha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>