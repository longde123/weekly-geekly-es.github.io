<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕓 😀 🕔 Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex 🦃 🐈 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich war immer daran interessiert, wie der Habr von innen angeordnet ist, wie der Workflow aufgebaut ist, wie die Kommunikation aufgebaut ist, welche S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/habr/blog/452098/"><img src="https://habrastorage.org/webt/bu/8e/tl/bu8etlfvktvmkcjotmzz6al7rgg.jpeg"><br><br>  Ich war immer daran interessiert, wie der Habr von innen angeordnet ist, wie der Workflow aufgebaut ist, wie die Kommunikation aufgebaut ist, welche Standards angewendet werden und wie der Code hier geschrieben wird.  Glücklicherweise erschien mir eine solche Gelegenheit, weil ich kürzlich Teil des Habracommand wurde.  Am Beispiel eines kleinen Refactorings der mobilen Version werde ich versuchen, die Frage zu beantworten: Wie ist es, hier vorne zu arbeiten?  Im Programm: Node, Vue, Vuex und SSR mit Sauce aus Notizen zu persönlichen Erfahrungen in Habré. <a name="habracut"></a><br><br>  Das erste, was Sie über das Entwicklungsteam wissen müssen, ist, dass wir nur wenige sind.  Nur wenige sind drei Fronten, zwei Rückseiten und technische Daten aller Habr - Bucksley.  Natürlich gibt es auch einen Tester, Designer, drei Vadim, einen Wunderbesen, einen Vermarkter und andere Bumburums.  Es gibt jedoch nur sechs direkte Mitwirkende an den Habra-Sorten.  Dies ist ziemlich selten - ein Projekt mit einem Multimillionen-Dollar-Publikum, das von außen wie ein gigantisches Unternehmen aussieht, ist eigentlich eher ein gemütliches Startup mit der flachsten Organisationsstruktur. <br><br>  Wie viele andere IT-Unternehmen bekennt sich Habr zu den Ideen von Agile, der Praxis von CI und das ist alles.  Aber nach meinen Gefühlen entwickelt sich Habr als Produkt eher wellig als kontinuierlich.  Für mehrere Sprints hintereinander arbeiten wir hart daran, zu programmieren, zu entwerfen und neu zu gestalten, etwas zu zerbrechen und zu reparieren, Tickets aufzulösen und neue zu starten, auf den Rechen zu treten und uns in die Beine zu schießen, um die Funktion endlich für das Produkt freizugeben.  Und dann kommt eine Pause, eine Phase der Sanierung, die Zeit, das zu tun, was sich im Quadranten „wichtig-nicht dringend“ befindet. <br><br>  Ein solcher Sprint außerhalb der Saison wird weiter unten diskutiert.  Diesmal erhielt er das Refactoring der mobilen Version von Habr.  Im Allgemeinen setzt das Unternehmen große Hoffnungen darauf und sollte in Zukunft den gesamten Habr-Inkarnationszoo ersetzen und eine universelle plattformübergreifende Lösung werden.  Eines Tages werden adaptives Layout, PWA, Offline-Modus, Benutzeranpassung und viele interessante Dinge angezeigt. <br><br><h3>  Wir stellen die Aufgabe </h3><br>  Einmal sprach eine der Fronten bei einem normalen Stand-up über Probleme in der Architektur der Kommentarkomponente der mobilen Version.  Aus dieser Präsentation heraus organisierten wir ein Mikrotreffen im Format der Gruppenpsychotherapie.  Jeder sagte der Reihe nach, wo er Schmerzen hatte, alles war auf Papier fixiert, sympathisiert, verstanden, außer dass niemand klatschte.  Die Ausgabe war eine Liste von 20 Problemen, die deutlich machten, dass der mobile Habr einen langen und dornigen Weg zum Erfolg gehen muss. <br><br>  Mein Hauptanliegen war die Ressourceneffizienz und eine so genannte reibungslose Schnittstelle.  Jeden Tag auf der Route „Heim-Arbeit-Zuhause“ sah ich mein altes Telefon verzweifelt versuchen, 20 Überschriften im Stream anzuzeigen.  Es sah ungefähr so ​​aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/v8/zr/nvv8zr5uneyynf4ntntk9sp3gzs.gif" alt="Bild"></div>  <sub><font color="grey"><i>Mobile Habr-Schnittstelle vor dem Refactoring</i></font></sub> <br><br>  Was ist hier los?  Kurz gesagt, der Server hat die HTML-Seite allen auf dieselbe Weise zur Verfügung gestellt, unabhängig davon, ob der Benutzer angemeldet ist oder nicht.  Dann wird der Client JS geladen und fordert erneut die erforderlichen Daten an, jedoch mit einer Änderung zur Autorisierung.  Das heißt, wir haben die gleiche Arbeit zweimal gemacht.  Die Benutzeroberfläche flackerte und der Benutzer lud gut hundert zusätzliche Kilobyte herunter.  Im Detail sah alles noch gruseliger aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/py/d8/0kpyd8h81q0_sgb8dd2gt7wfhvw.jpeg"></div>  <sub><font color="grey"><i>Alte SSR-CSR-Schaltung.</i></font></sub>  <sub><font color="grey"><i>Die Autorisierung ist nur in den Phasen C3 und C4 möglich, in denen Node JS nicht mit der Generierung von HTML beschäftigt ist und API-Anforderungen proxy kann.</i></font></sub> <br><br>  Unsere damalige Architektur wurde von einem von Habrs Benutzern sehr genau beschrieben: <br><blockquote>  Die mobile Version ist Scheiße.  Ich spreche so wie es ist.  Eine schreckliche Kombination von SSR und CSR. </blockquote><br>  Wir mussten es zugeben, wie traurig es auch sein mag. <br><br>  Ich habe die Optionen herausgefunden, mir ein Ticket im "Jira" mit einer Beschreibung auf der Ebene "Jetzt ist es schlecht, mach die Regeln" gesetzt und mit großen Strichen die Aufgabe zerlegt: <br><br><ul><li>  Daten wiederverwenden </li><li>  Minimieren Sie die Anzahl der Neuzeichnungen. </li><li>  doppelte Anfragen ausschließen </li><li>  Machen Sie den Ladevorgang deutlicher. </li></ul><br><h3>  Daten wiederverwenden </h3><br>  Theoretisch soll das serverseitige Rendern zwei Probleme lösen: nicht unter den Einschränkungen von Suchmaschinen hinsichtlich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPA-Indizierung</a> zu leiden und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FMP-</a> Metrik zu verbessern (was den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TTI</a> zwangsläufig verschlechtert).  In dem klassischen Szenario, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2013 in Airbnb formuliert wurde</a> (zurück bei Backbone.js), ist SSR dieselbe isomorphe JS-Anwendung, die in der Node-Umgebung ausgeführt wird.  Der Server gibt das generierte Layout einfach als Antwort auf die Anforderung zurück.  Dann erfolgt auf der Client-Seite eine Rehydratisierung, und dann funktioniert alles ohne erneutes Laden der Seite.  Für Habr und viele andere mit Text gefüllte Ressourcen ist das Server-Rendering ein entscheidendes Element beim Aufbau freundschaftlicher Beziehungen zu Suchmaschinen. <br><br>  Trotz der Tatsache, dass seit dem Aufkommen der Technologie mehr als sechs Jahre vergangen sind und in dieser Zeit wirklich viel Wasser in die Frontend-Welt geflossen ist, ist diese Idee für viele Entwickler immer noch geheim.  Wir sind nicht beiseite getreten und haben eine Vue-Anwendung mit SSR-Unterstützung für das Produkt bereitgestellt, wobei ein kleines Detail fehlte: Wir haben den Anfangszustand nicht an den Client übergeben. <br><br>  Warum?  Es gibt keine genaue Antwort auf diese Frage.  Entweder wollten sie die Antwort vom Server nicht vergrößern oder wegen einer Reihe anderer Architekturprobleme oder sie starteten einfach nicht.  Auf die eine oder andere Weise scheint es durchaus angemessen und nützlich zu sein, den Status zu werfen und alles wiederzuverwenden, was der Server getan hat.  Die Aufgabe ist eigentlich trivial - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">state</a> fügt sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfach</a> in den Ausführungskontext ein und Vue fügt sie automatisch als globale Variable zum generierten Layout hinzu: <code>window.__INITIAL_STATE__</code> . <br><br>  Eines der auftretenden Probleme war die Unfähigkeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kreisförmige</a> Strukturen in JSON umzuwandeln.  wurde gelöst, indem solche Strukturen einfach durch ihre flachen Analoga ersetzt wurden. <br><br>  Denken Sie beim Umgang mit UGC-Inhalten außerdem daran, dass Daten in HTML-Entitäten konvertiert werden sollten, um den HTML-Code nicht zu beschädigen.  Für diese Zwecke verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihn</a> . <br><br><h3>  Minimierungen neu zeichnen </h3><br>  Wie aus dem obigen Diagramm ersichtlich ist, führt in unserem Fall eine Node JS-Instanz zwei Funktionen aus: SSR und "Proxy" in der API, in der der Benutzer autorisiert ist.  Dieser Umstand macht eine Autorisierung zum Zeitpunkt der Ausführung des JS-Codes auf dem Server unmöglich, da der Knoten Single-Threaded ist und die SSR-Funktion synchron ist.  Das heißt, der Server kann einfach keine Anforderungen an sich selbst senden, während der Aufrufstapel mit etwas beschäftigt ist.  Es stellte sich heraus, dass wir den Status übersprungen haben, aber die Schnittstelle hat nicht aufgehört zu zucken, da die Daten auf dem Client unter Berücksichtigung der Benutzersitzung aktualisiert werden sollten.  Es war notwendig, unserer Anwendung beizubringen, die korrekten Daten unter Berücksichtigung des Logins des Benutzers in den Ausgangszustand zu versetzen. <br><br>  Es gab nur zwei Lösungen für das Problem: <br><br><ul><li>  Autorisierungsdaten an Interserver-Anfragen zu klammern; </li><li>  Teilen Sie Node JS-Ebenen in zwei separate Instanzen auf. </li></ul><br>  Die erste Lösung erforderte die Verwendung globaler Variablen auf dem Server, und die zweite verlängerte die für die Ausführung der Aufgabe erforderliche Zeit um mindestens einen Monat. <br><br>  Wie treffe ich eine Wahl?  Habr bewegt sich oft auf dem Weg des geringsten Widerstands.  Informell besteht ein gewisser allgemeiner Wunsch, den Zyklus von der Idee zum Prototyp zu minimieren.  Das Modell der Einstellung zum Produkt erinnert ein wenig an die Postulate von booking.com, mit dem einzigen Unterschied, dass Habr das Feedback der Benutzer viel ernst nimmt und darauf vertraut, dass Sie als Entwickler solche Entscheidungen treffen. <br><br>  Nach dieser Logik und meinem eigenen Wunsch, das Problem schnell zu lösen, habe ich globale Variablen ausgewählt.  Und wie so oft müssen sie früher oder später dafür bezahlen.  Wir haben fast sofort bezahlt: Wir haben am Wochenende gearbeitet, die Konsequenzen aufgegriffen, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Post-Mortem geschrieben</a> und den Server in zwei Teile geteilt.  Der Fehler war sehr dumm und der Fehler mit ihrer Teilnahme war nicht leicht zu reproduzieren.  Und ja, für solch eine Schande, aber irgendwie, stolpernd und grunzend, ging mein PoC mit globalen Variablen immer noch in Produktion und arbeitet ziemlich erfolgreich in Erwartung des Übergangs zu einer neuen "zweitägigen" Architektur.  Dies war ein wichtiger Schritt, da das Ziel formal erreicht wurde - die SSR lernte, eine Seite zu erstellen, die vollständig einsatzbereit war, und die Benutzeroberfläche wurde viel ruhiger. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/rx/d-/rmrxd-fkzne7vbcj-jxxrbbwid8.gif" alt="Bild"></div>  <sub><font color="grey"><i>Mobile Habr-Schnittstelle nach der ersten Phase des Refactorings</i></font></sub> <br><br>  Letztendlich führt die SSR-CSR-Architektur der mobilen Version zu diesem Bild: <br><br>  ￼ <div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/jb/km/7tjbkmkiq4n5atanzsj3ylkwrke.jpeg" alt="Bild"></div>  <sub><font color="grey"><i>"Zweitägiges" SSR-CSR-Schema.</i></font></sub>  <sub><font color="grey"><i>Die Knoten-JS-API ist immer für asynchrone E / A bereit und wird von der SSR-Funktion nicht blockiert, da sich diese in einer separaten Instanz befindet.</i></font></sub>  <sub><font color="grey"><i>Abfragekette Nr. 3 wird nicht benötigt.</i></font></sub> <br><br><h3>  Doppelte Anfragen ausschließen </h3><br>  Nach den Manipulationen löste das erste Rendern der Seite keine Epilepsie mehr aus.  Die weitere Verwendung von Habr im SPA-Modus sorgte jedoch immer noch für Verwirrung. <br><br>  Da der Benutzerfluss auf Übergängen der Formularliste <i>von Artikeln → Artikel → Kommentare</i> und umgekehrt basiert, war es zunächst wichtig, den Ressourcenverbrauch dieser Kette zu optimieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/eo/01/ukeo01u79_olhiv1eo9vxao4yv4.gif" alt="Bild"></div>  <sub><font color="grey"><i>Eine Rückkehr zum Post-Feed führt zu einer neuen Datenanforderung</i></font></sub> <br><br>  Ich musste nicht tief graben.  Der obige Screencast zeigt, dass die Anwendung die Liste der Artikel beim Zurückwischen erneut abfragt. Während der Anforderung wird der Artikel nicht angezeigt, was bedeutet, dass die vorherigen Daten irgendwo verschwinden.  Es sieht so aus, als ob die Artikellistenkomponente einen lokalen Status verwendet und diesen bei Zerstörung verliert.  Tatsächlich verwendete die Anwendung den globalen Status, aber die Vuex-Architektur wurde auf der Stirn aufgebaut: Die Module sind an Seiten gebunden, die wiederum an Routen gebunden sind.  Darüber hinaus sind alle Module „einmalig“ - bei jedem weiteren Besuch der Seite wurde das gesamte Modul neu geschrieben: <br><br><pre> <code class="javascript hljs">ArticlesList: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">PageArticle</span></span>: { ArticleFull1 },</code> </pre><br>  Insgesamt hatten wir das <i>ArticlesList-</i> Modul, das Objekte vom Typ <i>Article</i> enthält, und das <i>PageArticle-</i> Modul, das eine erweiterte Version des <i>Article-</i> Objekts war, eine Art <i>ArticleFull</i> .  Im Großen und Ganzen trägt diese Implementierung nichts Schreckliches an sich - es ist sehr einfach, man könnte sogar naiv sagen, aber es ist äußerst klar.  Wenn Sie die Nullstellung des Moduls bei jeder Änderung der Route ausschalten, können Sie sogar damit leben.  Der Übergang zwischen Artikel-Feeds, z. B. <i>/ feed → / all</i> , wirft jedoch garantiert alles aus, was mit dem persönlichen Feed zusammenhängt, da wir nur eine <i>Artikelliste haben,</i> in die neue Daten eingefügt werden können.  Dies führt wiederum zu doppelten Abfragen. <br><br>  Ich stellte alles zusammen, was ich zu diesem Thema herausfinden konnte, formulierte eine neue Staatsstruktur und präsentierte sie meinen Kollegen.  Die Diskussionen waren langwierig, aber am Ende überwogen die Argumente „für“ die Zweifel, und ich begann mit der Umsetzung. <br><br>  Die Logik der Lösung lässt sich am besten in zwei Schritten offenbaren.  Zuerst versuchen wir, das Vuex-Modul von den Seiten zu lösen und direkt an die Routen zu binden.  Ja, es werden etwas mehr Daten im Geschäft sein, Getter werden etwas komplizierter, aber wir werden die Artikel nicht zweimal laden.  Für die mobile Version ist dies vielleicht das stärkste Argument.  Es wird ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs">ArticlesList: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ { Article2 }, ... ], }</code> </pre><br>  Was aber, wenn sich Artikellisten zwischen mehreren Routen überschneiden können, und was ist, wenn wir die Daten eines <i>Artikelobjekts</i> wiederverwenden möchten, um eine <i>Postseite</i> zu rendern und sie in <i>ArticleFull umzuwandeln</i> ?  In diesem Fall wäre es logischer, eine solche Struktur zu verwenden: <br><br><pre> <code class="javascript hljs">ArticlesIds: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, ... ], }, <span class="hljs-attr"><span class="hljs-attr">ArticlesList</span></span>: { <span class="hljs-string"><span class="hljs-string">'1'</span></span>: { Article1 }, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: { Article2 }, ... }</code> </pre><br>  <i>ArticlesList</i> hier ist nur eine Art Artikel-Repository.  Alle Artikel, die während der Benutzersitzung hochgeladen wurden.  Wir behandeln sie so sorgfältig wie möglich, da dies Verkehr ist, der möglicherweise durch Schmerzen irgendwo in der U-Bahn zwischen den Stationen geladen wurde, und wir möchten den Benutzer definitiv nicht erneut mit diesen Schmerzen belasten, sodass er die bereits heruntergeladenen Daten laden muss.  Das <i>ArticlesIds-</i> Objekt ist nur ein Array von Bezeichnern (wie „Links“) zu Artikelobjekten.  Mit dieser Struktur können Sie die für Routen üblichen Daten nicht duplizieren und das Artikelobjekt beim Rendern einer Postseite wiederverwenden, indem Sie erweiterte Daten darin zusammenführen. <br><br>  Die Ausgabe der Artikelliste ist auch transparenter geworden: Die Iteratorkomponente durchläuft das Array mit Artikel-IDs und zeichnet die Artikel-Teaser-Komponente, wobei die ID als Requisiten übergeben wird, und die untergeordnete Komponente ruft wiederum die erforderlichen Daten aus der <i>Artikelliste ab</i> .  Wenn Sie zur Veröffentlichungsseite gehen, erhalten wir das vorhandene Datum aus der <i>Artikelliste</i> , fordern die fehlenden Daten an und fügen sie einfach dem vorhandenen Objekt hinzu. <br><br>  Warum ist dieser Ansatz besser?  Wie ich oben geschrieben habe, ist dieser Ansatz in Bezug auf die heruntergeladenen Daten vorsichtiger und ermöglicht es Ihnen, sie wiederzuverwenden.  Abgesehen davon eröffnet es den Weg für einige neue Möglichkeiten, die perfekt in eine solche Architektur passen.  Zum Beispiel das Abrufen und Hochladen von Artikeln in den Feed, sobald sie angezeigt werden.  Wir können einfach neue Beiträge zum <i>ArticlesList-</i> Store hinzufügen, eine separate Liste neuer IDs in <i>ArticlesIds</i> speichern und den Benutzer darüber informieren.  Wenn Sie auf die Schaltfläche "Neue Veröffentlichungen anzeigen" klicken, fügen Sie einfach eine neue ID am Anfang des Arrays der aktuellen Artikelliste ein, und alles funktioniert fast auf magische Weise. <br><br><h3>  Den Download angenehmer gestalten </h3><br>  Die Kirsche auf dem Refactoring-Kuchen war das Konzept der Skelette, was das Herunterladen von Inhalten im langsamen Internet etwas weniger ekelhaft macht.  Es gab keine Diskussionen zu diesem Thema, die Reise von der Idee zum Prototyp dauerte buchstäblich zwei Stunden.  Das Design wurde fast von uns selbst gezeichnet und wir haben unseren Komponenten beigebracht, wie man unprätentiöse, kaum flackernde Div-Blöcke rendert, während man auf Daten wartet.  Subjektiv reduziert dieser Ansatz zum Laden wirklich die Menge an Stresshormonen im Körper des Benutzers.  Das Skelett sieht so aus: <br><br><img src="https://habrastorage.org/webt/yn/gn/ey/yngneyh8sftpmyyyj4ur_ihjo2c.jpeg" alt="Bild"><br>  <sub><font color="grey"><i>Habraloading</i></font></sub> <br><br><h3>  Reflektieren </h3><br>  Ich arbeite seit sechs Monaten in Habré und Freunde fragen immer noch: Nun, wie gefällt es dir?  Gut, bequem - ja.  Aber es gibt etwas, das diese Arbeit von anderen unterscheidet.  Ich arbeitete in Teams, die ihrem Produkt völlig gleichgültig gegenüberstanden, nicht wussten und nicht verstanden, wer ihre Benutzer waren.  Aber hier ist alles anders.  Hier fühlen Sie sich verantwortlich für das, was Sie tun.  Bei der Entwicklung eines Features werden Sie teilweise dessen Eigentümer, nehmen an allen Produktbesprechungen zu Ihrer Funktionalität teil, machen Vorschläge und treffen selbst Entscheidungen.  Ein Produkt herzustellen, das Sie täglich selbst verwenden, ist sehr cool, und Code für Leute zu schreiben, die es vielleicht besser können, ist einfach ein unglaubliches Gefühl (kein Sarkasmus). <br><br>  Nach der Veröffentlichung all dieser Änderungen erhielten wir ein positives Feedback und es war sehr, sehr schön.  Es ist inspirierend.  Vielen Dank!  Schreiben Sie mehr. <br><br>  Ich möchte Sie daran erinnern, dass wir nach globalen Variablen beschlossen haben, die Architektur zu ändern und die Proxy-Schicht in eine separate Instanz aufzuteilen.  Die "zweitägige" Architektur hat die Veröffentlichung bereits in Form von öffentlichen Betatests erreicht.  Jetzt kann jeder darauf umsteigen und uns helfen, das mobile Habr besser zu machen.  Das ist alles für heute.  Gerne beantworte ich alle Ihre Fragen in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452098/">https://habr.com/ru/post/de452098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452086/index.html">Was ist in meinem Pixel für Sie: Erstellen von Nanopixeln mit Plasmon-Metaoberflächen</a></li>
<li><a href="../de452088/index.html">Straßenerkennung durch semantische Segmentierung</a></li>
<li><a href="../de452090/index.html">Erstellen eines prozeduralen Puzzle-Generators</a></li>
<li><a href="../de452092/index.html">In-App-Updates: Beschleunigen von Android-Anwendungsupdates</a></li>
<li><a href="../de452094/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronität. Teil 1</a></li>
<li><a href="../de452102/index.html">Fotospiel für Drohnenliebhaber: kurz über AirSelfie 2</a></li>
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
<li><a href="../de452108/index.html">Docker: harmloser Rat</a></li>
<li><a href="../de452110/index.html">Automatisieren Sie den Festplattenaustausch mit Ansible</a></li>
<li><a href="../de452112/index.html">CRM ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>