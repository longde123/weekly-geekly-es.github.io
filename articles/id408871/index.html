<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 🙇🏾 ◽️ Sesi transmisi video suara melalui air dengan pencahayaan 🤲🏻 🈶 ↪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“Tuhan Yang Mahakuasa! Sepertinya saya baru saja membunuh Tn. May! ... Tapi bagaimanapun juga, kita lanjutkan ”(C) J. Clarkson 
 Pada artikel ini, say...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sesi transmisi video suara melalui air dengan pencahayaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408871/"><blockquote>  “Tuhan Yang Mahakuasa!  Sepertinya saya baru saja membunuh Tn. May! ... Tapi bagaimanapun juga, kita lanjutkan ”(C) J. Clarkson </blockquote><br>  Pada artikel ini, saya akan memberi tahu Anda cara mentransfer video (well, hampir video) menggunakan suara melalui air menggunakan laptop biasa, sepotong kawat, dua jack 3,5 mm dan dua piezo tweeter.  Saya juga akan menjelaskan mengapa dan bagaimana cara kerjanya, menceritakan sebuah kisah lucu tentang bagaimana kami menemukan ini.  Dan sebagai ceri pada kue, artikel tentang C # dengan kode sumber dilampirkan ke artikel sehingga setiap orang yang tertarik dapat mencobanya sendiri, karena pengetahuan ilmiah dapat diverifikasi, bukan? <br><a name="habracut"></a><br>  Jika tiba-tiba pembaca ingin menyelam lebih dalam ke topik hidroakustik, saya sarankan Anda membiasakan diri dengan publikasi kami sebelumnya, di mana kami berbicara tentang proyek kami dengan cara mengungkapkan kesulitan dalam mengirimkan informasi melalui air: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPS bawah laut dari awal per tahun</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPS bawah air: lanjutan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Navigasi di bawah air: arahan temuan - jangan arahan menemukan, Anda ditakdirkan untuk sukses</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang efek cyanobacteria pada fungsi pidato presiden</a> <br><br>  Secara umum, satu kebenaran sederhana harus dipelajari: video melalui air pada jarak yang signifikan (well, setidaknya ratusan meter) tidak dapat ditransmisikan menggunakan akustik.  Intinya adalah pita frekuensi yang tersedia sangat sempit dan ketidakseimbangan yang kuat dari pelemahan frekuensi yang berbeda dengan jarak.  Kelebihannya adalah noise, propagasi multipath, gema, perubahan dalam kecepatan suara dalam medium dari kepadatan (mis., Tekanan, suhu dan salinitas), efek Doppler, yang notabene tidak bekerja seperti di komunikasi radio. <br><br>  Batas kecepatan untuk modem sonar tercanggih sangat jauh dari kemampuan untuk mengirimkan video.  Sejauh yang saya tahu, catatan itu milik EvoLogics dan berjumlah 62,5 kbps dengan jarak maksimum yang dinyatakan 300 meter.  Selain itu, kata-kata tentang ketidakmungkinan mentransmisikan suara video melalui air (pada jarak yang masuk akal) hanya milik Konstantin Georgievich, pendiri dan direktur EvoLogics. <br><br>  Ketika saya adalah seorang peneliti di Hydrosvyaz Research Institute, yang saat itu benar-benar tidak sadar, saya menginginkan pencapaian besar, <s>kemenangan di utara dan selatan, pelonggaran tanah yang besar</s> (tidak, saya masih menginginkannya, tetapi kemudian saya sama sekali tidak dibebani dengan pengalaman dan pengetahuan dan semuanya tampak hampir ajaib dan menakjubkan).  Di tim kami pada waktu itu (sebagian adalah yang asli saya), kami sering berfantasi tentang beberapa proyek sonar yang tidak realistis, mengaduk-aduk di tempat <s>pembuangan sampah</s> dan mencoba menggunakan segala macam artefak dari peradaban kuno yang besar secara berurutan, di mana lembaga penelitian ini sebagian mencoba memahami tao komunikasi sonar . <br><br>  Perendaman dalam ingatan itu membangkitkan perasaan yang saling bertentangan dalam diri saya.  Kemudian tidak ada yang tampak dan tidak ada yang bisa menghentikan kami: kami merobohkan sebuah mesin penggilingan Cina dari direktur untuk pembuatan prototipe produk, mengumpulkan badan normobarik dari pipa air Belanda Van De Lande, produsen yang bahkan menulis surat pada subjek: "Apakah Anda secara tidak sengaja memeriksa yang mana apakah pipa Anda tahan terhadap tekanan eksternal? "  Mereka mengumpulkan model papan tempat memotong roti untuk uang mereka sendiri dalam wadah sarapan dan diam-diam pergi ke tes untuk menguji mereka secara diam-diam, mengumpulkan latihan es dan kereta luncur untuk rekan dan kerabat, dan bahkan membeli kapal PVC Cina di Auchan.  Melihat ke belakang, saya merasakan bagaimana hati saya dipenuhi dengan kengerian, nostalgia dan gentar. <br><br>  Dalam keadilan, perlu dicatat bahwa selama ini kami menerima dukungan besar dari beberapa pemimpin kami - dalam kata-kata dan perbuatan, dan sebagai hasilnya semua kerajinan kami dilegalkan dalam OCD (yang berarti Pekerjaan Desain Eksperimental dan bukan Obsesif Compulsive Disorder), yang bahkan disajikan di salon angkatan laut internasional pada 2013.  Ya, ya, kami pergi ke salon pipa air kami, dicat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">StDmitirev</a> di tangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">kami</a> sendiri dengan warna oranye terang!  Inilah mereka, di dalam koper: <br><br><img src="https://habrastorage.org/webt/-7/jk/ii/-7jkii7tkq9yhpbwuvb1dw6ah2g.jpeg"><br><br>  Suatu hari, teman dan kolega saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">StDmitirev,</a> di tengah-tengah pembicaraan tentang spektra dan spektogram, mengucapkan kalimat berikut: <br><br><blockquote>  "Tapi, akan menyenangkan untuk membuat sistem seperti itu: kapal selam itu duduk di dalam kapal selam dan melihat ke monitor, tempat spektogram bergerak dengan lancar, di mana huruf dan angka ditulis seperti jari <s>kapal selam lain</s> di jendela berkabut di <s>kapal selam lain</s> ." <br></blockquote><br>  Semua orang tertawa, mengembangkan topik ini, tampaknya bahkan pada hari yang sama mereka menggambar sebuah senyuman di spektogram dan mendengarkan bagaimana suaranya.  Saya benar-benar ingin membawa ini ke tampilan praktis. <br><br>  Sekarang sulit untuk diingat (kembali pada tahun 2012).  Saya memiliki komputer yang berfungsi dengan webcam, berbagai artefak-antena dan “bucket sonar boosting” khusus (VG-1-P) dengan air.  Mereka memanggilnya sebagai langkah maju karena fakta bahwa saya memperlihatkan kepada semua bosnya pekerjaan model-model peralatan berbeda di dalamnya, yang menyebabkan promosi saya menjadi peneliti senior. <br><br>  Saya tidak dibatasi oleh kewajiban apa pun, metode itu sendiri telah lama diterbitkan dalam domain publik, dan hasilnya telah berulang kali dilaporkan di konferensi. <br><br>  Jadi, saya memberi tahu Anda bagaimana dalam semangat - cara mengirimkan video melalui air: <br><br><h3>  Bagaimana cara menghasilkan sinyal? </h3><br>  Kita ingat bahwa idenya didasarkan pada "menggambar pada spektogram," yaitu, gambar yang ditransmisikan adalah spektrogram sinyal.  Untuk mengonversi sinyal dari domain waktu ke domain frekuensi dan sebaliknya, lebih mudah menggunakan (well, misalnya) transformasi Fourier, atau lebih tepatnya, transformasi Fourier cepat, untuk singkatnya, yang disebut FFT atau, lebih umum, FFT (Fast Fourier Transform). <br><br>  Karena kita perlu mengubah gambar (bingkai video) menjadi sinyal audio yang dapat dipancarkan oleh kartu suara dari komputer mana pun, kita jelas akan menggunakan transformasi terbalik, IFFT, untuk membentuknya.  Kami akan memancarkan gambar dalam kolom, dan sinyal untuk satu kolom akan dibentuk seperti pada diagram berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wi/3t/l4wi3t5t4mk3vq5zo_-bmau-dne.png"></div><br>  = <br>  Misalkan ukuran jendela FFT adalah N dan kami memiliki array ukuran N. Jika kami menganggapnya sebagai spektrum sinyal, maka elemen nolnya sesuai dengan frekuensi nol (konstan), dan penghitungan dengan indeks N-1 sesuai dengan frekuensi pengambilan sampel Sample Rate.  Penting untuk memilih ukuran bingkai gambar dan ukuran jendela FFT sehingga di satu sisi semuanya menyerupai video (mentransfer satu frame akan membutuhkan waktu yang wajar), dan di sisi lain, pita frekuensi yang digunakan pada prinsipnya memadai dan memadai untuk peralatan yang tersedia. .  Sekarang, jika kita memasukkan nilai kecerahan kolom gambar (Frame kolom) dari beberapa hitungan favorit (dari bawah ke atas dalam diagram), dan kemudian melakukan FFT terbalik, maka output akan menerima sinyal yang mengkodekan satu kolom gambar.  Sekarang tinggal kita untuk membentuk sinyal dengan cara yang sama untuk kolom gambar yang tersisa dan memancarkannya secara bergantian menggunakan kartu suara. <br><br>  Perlu dicatat bahwa FFT pada output memberikan array nilai kompleks, jadi sinyal kami adalah bagian yang sebenarnya.  Tentu saja, sinyal yang dihasilkan dalam kolom dikurangi menjadi bilangan bulat bertanda 16-bit (dalam bentuk ini, sinyal audio digital biasanya disimpan) dan dinormalisasi. <br><br>  Bahkan, pada awal gambar saya juga memasukkan beberapa kolom kecerahan maksimum, kemudian di sisi penerima ini akan menentukan respon frekuensi jalur transceiver (dan saluran transmisi), yang, ketika terbalik dan sedikit dihaluskan, akan membantu kami meningkatkan frame yang diterima. <br><br>  Menurut pendapat saya, cara termudah untuk menunjukkan perangkat pemancar adalah dengan sepotong kode, ini dia (metode Encode kelas Encoder): <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize * frameSize.Width]; alglib.complex[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colsCount = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startRow = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endRow = startRow + frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colsCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = startRow; y &lt; endRow; y++) slice[y].x = (frame.GetPixel(x, frameSize.Height - (y - startRow) - <span class="hljs-number"><span class="hljs-number">1</span></span>).R / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) slice[y].x *= randomizerMask[y]; alglib.fftc1dinv(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> slice); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; slice.Length; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(slice[y].x) &gt; maxSlice) maxSlice = Math.Abs(slice[y].x); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slice.Length; i++) { samples[sampleIndex] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)Math.Round(slice[i].x * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue / maxSlice); sampleIndex++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples; }</code> </pre> <br>  Kode, tentu saja, tidak berpura-pura apa pun dan ditulis terburu-buru murni untuk demonstrasi. <br><br><h3>  Lalu bagaimana dengan kecepatan transmisi? </h3><br>  Dan bagaimana cara mengevaluasinya?  Kami berhasil ( <s>dari kejahatan</s> bukan dari kejahatan) untuk mempertahankan intrik selama sekitar dua bulan, dan beberapa kawan dan pemimpin senior kami berhasil menulis banyak kertas di waktu luang mereka, bertanya-tanya bagaimana kecepatan transmisi gila seperti itu bisa terjadi. <br><br>  Misalnya, jika frekuensi sampling 96 kHz, dan kami mengambil ukuran jendela FFT menjadi 512, kami akan mengirim 120 x 120 piksel (8 bit per piksel) ke input pemancar, maka waktu yang diperlukan untuk mengirim satu bingkai gambar adalah: <br><br>  <i>120 * 512/96000 = 0,64 detik</i> <br><br>  Bit rate tampaknya: <br><br>  <i>120x120 * 8 / 0.64 = 180.000 bit per detik!</i> <br><br>  <s>Putra direktur senang pada saat itu - ya, Anda sudah dapat menggunakan protokol internet!</s>  <s>Ini adalah terobosan!</s> <br><br>  Seperti yang akan saya tunjukkan di bawah ini, sangat mudah untuk jatuh ke dalam kesalahpahaman seperti itu.  Apa yang salah di sini?  Bagaimanapun, semuanya sangat sederhana dan elegan! <br><br>  Bahkan, perhitungan kecepatan seperti itu tidak berlaku untuk metode ini, sama seperti, misalnya, itu tidak berlaku untuk sinyal televisi analog, berapa banyak bit per piksel yang ada?  =) Dan bagaimana dengan penerima detektor yang paling sederhana?  =)) <br><br>  Metode transmisi yang dijelaskan pada dasarnya adalah <i>ANALOG</i> dan konsep "bit" dan "pixel" tidak berlaku untuk itu - dalam gambar yang sama, secara teoritis, Anda dapat mengambil bukan 8 bit per kecerahan pixel tetapi 16 dan "kecepatan" secara otomatis akan berlipat ganda. <br><br>  Saatnya untuk menunjukkan hasil pertama dari "terobosan" kami: <br><br><img src="https://habrastorage.org/webt/a5/ji/pv/a5jipvfgywxfxpy7p9jwl34v-ze.gif"><br><br>  Gambar di atas diambil oleh kami pada musim dingin 2012 di Sungai Pichuga.  Jarak transmisi adalah 700 meter.  Ya, sayang, pembaca yang budiman, ini sama sekali bukan HD dan bahkan tidak menggunakan CamRip yang paling memalukan.  Saya tidak ingat siapa yang sudah, tetapi seseorang dengan sangat akurat memperhatikan bahwa semua "video" kami seperti mengirim sinyal bantuan dari planet yang sedang sekarat. <br><br>  Yang perlu diperhatikan, dengan peregangan ini dapat digambarkan sebagai semacam OFDM - data ditransmisikan pada subcarrier ortogonal, yang berarti ketahanan yang baik terhadap tonal dan interferensi pita sempit lainnya - dalam hal ini, "garis" gambar terdistorsi.  Kebisingan impuls, sebaliknya, mendistorsi satu atau sekelompok kolom.  Karakteristik "banding" dari gambar-gambar tersebut disebabkan oleh apa yang disebut  frekuensi selektif memudar karena propagasi multipas, tetapi saya akan membicarakannya lain kali. <br><br><h3>  Bagaimana pengaturan penerima? </h3><br>  Saya harus segera memesan bahwa untuk mencoba metode ini dalam ember atau bahkan di kolam kecil, potongan dua jam (yang bundar) dengan konektor untuk kartu suara yang disolder kepada mereka sudah cukup.  Untuk pemancar, Anda dapat mengambil kabel yang cukup panjang (2-3-4-5 meter) dan tidak terlindung, menyegel elemen piezoelektrik dengan zapon-varnish atau lapisan kecil sealant - sudah pasti cukup untuk beberapa kali.  Antena sonar yang dihasilkan (tidak, baik, apa?) Dimasukkan ke jack headphone. <br><br>  Foto di bawah ini menunjukkan berbagai bagian yang ada pada saat penulisan.  Semua elemen piezoelektrik yang ditampilkan cukup cocok untuk "mencoba" dan biasanya ada toko radio di <s>tempat pembuangan sampah</s> .  Pyatak tidak memiliki efek piezoelektrik dan hadir dalam gambar untuk skala. <br><br><img src="https://habrastorage.org/webt/5v/r6/xq/5vr6xqryjht0yd5tqz7sdvmbd3a.jpeg"><br><br>  Untuk penerima, lebih baik mengambil kabel mikrofon berpelindung dengan konektor yang sama dan piezo dioleskan dengan sealant atau pernis di ujungnya.  Kami memasukkan antena ini ke jack mikrofon. <br><br>  Untuk percobaan di kolam, lebih baik mengambil beberapa jenis cincin piezo sebagai pemancar dan memberinya makan yang diperkuat (penguat pada TDA2030 dengan transformator luka yang benar akan bertahan beberapa ratus meter di kolam yang baik <s>atau 5 putaran lainnya bisa</s> terluka).  Untuk penerima, dalam hal ini, preamplifier dan lebih disukai filter bandpass juga diperlukan.  Jika pembaca akan tertarik untuk mempelajari lebih lanjut tentang ini secara rinci, beri tahu kami di komentar dan kami akan mencoba membuat artikel tentang penciptaan penguat daya, preamp, dan antena untuk komunikasi sonar. <br><br><h3>  Jadi, kembali ke penerima, lebih tepatnya ke bagian perangkat lunaknya </h3><br>  Hal terpenting dalam komunikasi adalah sinkronisasi dan penentuan keberadaan sinyal yang bermanfaat.  Dalam contoh kami, deteksi dilakukan oleh energi di pita: tempat di mana ia meningkat tajam (awal bingkai) dan di mana ia jatuh tajam (ujung bingkai) ditentukan, dengan kondisi bahwa dari depan ke jatuh harus ada setidaknya durasi bingkai. <br><br>  Untuk semua kesederhanaannya, ini bekerja dengan sangat baik. <br><br>  Data dari kartu suara dikumpulkan oleh sampel FFTSize, FFT dilakukan segera pada mereka dan mereka disimpan sebagai "irisan" yang terpisah, menunggu saat ketika mereka akan diproses oleh prosedur pencarian, berikut adalah kodenya (Metode pencarian di kelas Penerima): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameWidth = encoder.FrameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSlicesToSearch = Convert.ToInt32((frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceSize = encoder.FFTSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((slices.Count &gt; minSlicesToSearch) &amp;&amp; (sliceIndex &lt; slices.Count)) { weight = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sliceSize; i++) weight += Math.Abs(slices[sliceIndex][i]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ratio = weight / previousWeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ratio &gt;= risePeekRatio) &amp;&amp; (sliceIndex - prevRisePosition &gt; frameWidth)) { prevRisePosition = lastRisePosition; lastRisePosition = sliceIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastRisePosition + (frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt; slices.Count) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { samples[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[sliceSize]; Array.Copy(slices[lastRisePosition + i], samples[i], sliceSize); } slices.RemoveRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, sliceIndex); lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FrameReceived != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) FrameReceived(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameReceivedEventArgs(encoder.DecodeEx(samples, <span class="hljs-number"><span class="hljs-number">5</span></span>))); lastRisePosition = sliceIndex; } } sliceIndex++; previousWeight = weight; } Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> isSearching); }</code> </pre> <br>  Dan ini adalah bagian dari kode yang bertanggung jawab untuk mendekode gambar (Encoder.DecodeEx): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureCols</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colCount = samples.Length / fftSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colCount == frameSize.Width + measureCols) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowCount = frameSize.Height; Bitmap temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(colCount, rowCount); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize]; alglib.complex[] sliceC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samplesCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> component; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeStart = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeEnd = startLine + rowCount; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) { slice[y] = samples[samplesCount]; samplesCount++; } alglib.fftr1d(slice, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sliceC); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alglib.math.abscomplex(sliceC[y].x) &gt; maxSlice) maxSlice = alglib.math.abscomplex(sliceC[y].x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = temp.Height + decodeStart - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) { component = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255.0</span></span> * alglib.math.abscomplex(sliceC[y].x) / maxSlice); temp.SetPixel(x, offset - y, Color.FromArgb(component, component, component)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"Specified array length error"</span></span>); } }</code> </pre><br>  Dan sekarang saya mengusulkan untuk melihat hasil percobaan pada transmisi "video", yang dilakukan pada waktu yang berbeda di reservoir yang berbeda. <br><br>  Kedua gambar (di bawah) direkam di salon angkatan laut internasional di St. Petersburg pada tahun 2013 di stand (lalu) kami melalui dua laptop dan akuarium. <br><br>  Tidak mungkin untuk mengetahui apa yang tertulis di lencana <br><br><img src="https://habrastorage.org/webt/xp/wx/sq/xpwxsqvxyyqwrzrjh0n5wr0tm-q.gif"><br><br><img src="https://habrastorage.org/webt/w7/9y/zb/w79yzbz7caic4fre7xftuh_tq00.gif"><br><br>  Dan berikut adalah dua "video" yang direkam oleh kami di salah satu teluk Danau Ladoga di Karelia, mereka adalah semacam rekaman untuk metode ini (kami tidak pernah mencobanya lagi dan tidak mungkin) - yang pertama diperoleh pada jarak 500 dan yang kedua sebanyak 1000 meter : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transmisi video melalui air, jarak 500 m (file 8,7 mb)</a> <br><br><img src="https://habrastorage.org/webt/ek/c_/sv/ekc_svi18z7oupqlmckhziofpy8.gif"><br><br>  Karena "video" direkam secara real time menggunakan webcam, berbagai hal aneh jatuh ke dalam bingkai.  Akan sangat menarik jika seseorang menebak dan menulis dalam komentar apa yang ada di latar belakang dalam "video" terakhir). <br><br>  Untuk mendukung fakta bahwa metode ini telah dipublikasikan sejak lama - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kami</a> sudah untuk tahun 2013 <br><br>  Saya menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AForge yang</a> indah untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengambil gambar webcam</a> . <br><br>  Nomor kompleks dan fungsi FFT digunakan dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AlgLib yang</a> sangat baik. <br><br>  Dan, seperti yang saya janjikan, seluruh proyek dalam C # (VS2012) dilampirkan pada artikel sebagai bahan untuk pekerjaan "rumah".  Untuk kenyamanan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file biner</a> terpisah. <br>  Demo ini menyediakan kemampuan untuk mengubah (memindahkan) pita frekuensi yang ditempati serta koreksi gamma dari kerangka output (semuanya dapat diubah secara real time). <br><br><h3>  PS </h3><br>  Saya belum mengambil C # untuk waktu yang lama dan sangat sulit untuk menemukan waktu dalam jadwal kerja, jadi saya minta maaf sebelumnya untuk kebingungan dan tergesa-gesa kode. <br><br><h3>  PPS </h3><br>  Saya tidak melampirkan sepotong kawat, dua jack dan dua potong untuk artikel - tidak cukup untuk semua orang. <br><br><h3>  Errata dan Apendiks </h3><br>  - Dalam beberapa kartu suara pada input terdapat filter low-pass yang secara tragis memotong semuanya di atas ~ 15 kHz (mengapa ???). <br><br>  - Secara default, proyek demo berfungsi dengan frekuensi sampling 96 kHz, tetapi tidak semua kartu suara modern mendukungnya (Mengapa ???).  Jika peralatan tidak dapat 96 kHz maka Anda perlu mengatur 48 kHz dalam pengaturan, jika tidak, maka 44100 tentu didukung di mana-mana, namun, durasi transmisi satu frame akan lebih lama. <br><br>  Berikut adalah daftar laptop dan kartu suara yang dapat dianggap sebagai peralatan sonar muda: <br><br><ul><li>  Lenovo ideapad Y510P dengan suara JBL </li><li>  Asus n55s </li><li>  Asus K501U </li><li>  kartu suara eksternal Sound Blaster X-Fi Surround 5.1 (model no. SB 1095) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id408871/">https://habr.com/ru/post/id408871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id408857/index.html">Tinjauan Teknologi Océ Press</a></li>
<li><a href="../id408859/index.html">KidPRO - Kisah Tupai Membantu Anak</a></li>
<li><a href="../id408861/index.html">Bioprinter baru membantu mengobati diabetes tipe 1</a></li>
<li><a href="../id408863/index.html">Pemindaian 3D mobil dalam penyetelan dan perbaikan</a></li>
<li><a href="../id408865/index.html">Kami menghapus bahasa Rusia dari bahasa Inggris kami</a></li>
<li><a href="../id408873/index.html">Ulasan Video 3Dtool AMAN CNC Milling Machine</a></li>
<li><a href="../id408875/index.html">Rol untuk bagian belakang</a></li>
<li><a href="../id408879/index.html">Tujuan yang menarik untuk bekerja jauh lebih sedikit</a></li>
<li><a href="../id408881/index.html">Tetapi bagaimana jika kita hidup di masa depan dan masa lalu pada saat yang sama? Dan apa jagat raya kita?</a></li>
<li><a href="../id408883/index.html">Ulasan Video 3Dtool Hercules Strong 2017 3D Printer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>