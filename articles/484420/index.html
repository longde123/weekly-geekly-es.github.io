<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Cambios en el popular BattlEye antichita y formas de evitarlos 斤  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Principales actualizaciones del c贸digo de shell BattlEye 
 A medida que pasa el tiempo, los anti-trampas cambian, y para aumentar la efectividad del p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cambios en el popular BattlEye antichita y formas de evitarlos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Principales actualizaciones del c贸digo de shell BattlEye </h2><br>  A medida que pasa el tiempo, los anti-trampas cambian, y para aumentar la efectividad del producto, las funciones aparecen y desaparecen en ellos.  Hace un a帽o, prepar茅 una descripci贸n detallada del c贸digo de shell BattlEye en mi <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">blog</a> [ <a href="https://habr.com/ru/post/483068/">traducci贸n</a> en Habr茅], y esta parte del art铆culo ser谩 un simple reflejo de los cambios realizados en el c贸digo de shell. <br><br><h2>  Marcas de tiempo en la lista negra </h2><br>  En un an谩lisis reciente de BattlEye, solo hab铆a dos marcas de tiempo de compilaci贸n en la lista de prohibici贸n de sombras, y parece que los desarrolladores decidieron agregar mucho m谩s: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  No pude identificar las marcas de tiempo restantes, y los dos <b>0xF *******</b> son los hashes creados por los ensambles deterministas de Visual Studio.  Gracias a @mottikraus y T0B1 por identificar algunas marcas de tiempo. <br><a name="habracut"></a><br><h2>  Verificaciones del m贸dulo </h2><br>  Como lo mostr贸 el an谩lisis principal, la caracter铆stica clave de BattlEye es la enumeraci贸n de m贸dulos, y desde el momento del 煤ltimo an谩lisis, se agreg贸 otro m贸dulo a la lista: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Esta es probablemente la detecci贸n de ciertos dlls proxy, ya que aqu铆 se marca el tama帽o de la tabla de redireccionamiento. <br><br><h2>  T铆tulos de ventanas </h2><br>  En el an谩lisis anterior, varios proveedores de trucos fueron marcados con nombres de ventanas, pero desde entonces el shellcode ha dejado de verificar estos encabezados de ventanas.  La lista de t铆tulos de ventanas ha sido completamente reemplazada por: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Nombres de imagen </h2><br>  BattlEye es conocido por usar m茅todos de detecci贸n muy primitivos, y uno de ellos es una lista negra de nombres de im谩genes.  Cada a帽o, la lista de nombres prohibidos de im谩genes se est谩 alargando, y en los 煤ltimos 11 meses se han agregado cinco nuevos: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Vale la pena se帽alar que la presencia de un m贸dulo con un nombre correspondiente a cualquiera de los elementos de la lista no significar谩 que se le prohibir谩 de inmediato.  El motor de informes tambi茅n transmite informaci贸n b谩sica del m贸dulo, que probablemente se usa para distinguir trampas de colisiones en el servidor BattlEye. <br><br><h2>  7 cremalleras </h2><br>  7-Zip fue ampliamente utilizado y sigue siendo utilizado por los participantes en la escena de trucos como relleno de memoria para huecos de c贸digo (cuevas de c贸digo).  BattlEye intenta lidiar con esto realizando una verificaci贸n de integridad <b>muy</b> pobre, que ha cambiado desde mi art铆culo anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Parece que los desarrolladores de BattlEye han adivinado que mi art铆culo anterior ha llevado a muchos usuarios a omitir esta verificaci贸n simplemente copiando los bytes deseados en la ubicaci贸n marcada por BattlEye.  驴C贸mo arreglaron la situaci贸n?  Cambiamos la verificaci贸n por ocho bytes y continuamos usando el mismo m茅todo incorrecto para verificar la integridad.  La partici贸n ejecutable de solo lectura, y todo lo que necesita hacer es descargar 7-Zip del disco y comparar las particiones movidas entre s铆;  Si hay alguna discrepancia, entonces algo est谩 mal.  En serio, muchachos, realizar verificaciones de integridad no es tan dif铆cil. <br><br><h2>  Verificaci贸n de red </h2><br>  Enumerar la tabla TCP todav铆a funciona, pero despu茅s de que publiqu茅 un an谩lisis anterior que criticaba a los desarrolladores por marcar las direcciones IP de Cloudflare, a煤n eliminaron esta verificaci贸n.  Anti-cheat a煤n informa el puerto que xera.ph usa para la conexi贸n, pero los desarrolladores agregaron una nueva verificaci贸n para determinar si el proceso con la conexi贸n tiene protecci贸n activa (presumiblemente esto se hace usando el controlador). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Gracias IChooseYou y resumen <br><br><h2>  BattlEye Stack Bypass </h2><br>  Hackear juegos es un juego constante de gato y rat贸n, por lo que los rumores de nuevos trucos se est谩n extendiendo como un fuego.  En esta parte, veremos nuevas t茅cnicas heur铆sticas que un gran proveedor de anti-trampas BattlEye agreg贸 recientemente a nuestro arsenal.  Muy a menudo, estas t茅cnicas se llaman andar en apilamiento.  Por lo general, se implementan procesando una funci贸n y revisando la pila para averiguar qui茅n llam贸 espec铆ficamente a esta funci贸n.  驴Por qu茅 necesitas hacer esto?  Al igual que cualquier otro programa, los hacks de videojuegos tienen un conjunto de funciones bien conocidas que utilizan para obtener informaci贸n del teclado, enviarla a la consola o calcular ciertas expresiones matem谩ticas.  Adem谩s, a los piratas inform谩ticos les encanta ocultar su existencia, ya sea en la memoria o en el disco, para que el software anti-trampa no los encuentre.  Pero lo que olvidan los programas de trucos es que regularmente llaman funciones de otras bibliotecas, y esto se puede usar para detectar heur铆sticamente trucos desconocidos.  Al implementar el motor transversal de la pila para funciones como <code>std::print</code> , podemos encontrar estos trucos incluso si est谩n enmascarados. <br><br>  BattlEye <strong>implement贸 un</strong> "bypass de pila", a pesar de que esto no se anunci贸 p煤blicamente y en el momento de la publicaci贸n del art铆culo solo hab铆a rumores.  Preste atenci贸n a las comillas: lo que ver谩 aqu铆 no es realmente un recorrido real de la pila, sino solo una combinaci贸n de verificar la direcci贸n de retorno y el volcado del programa de llamadas.  Una implementaci贸n transversal real de la pila pasar铆a por la pila y generar铆a una pila de llamadas real. <br><br>  Como expliqu茅 en un art铆culo anterior sobre BattlEye, el sistema anti-trampa transmite din谩micamente el shellcode al juego cuando se est谩 ejecutando.  Estos c贸digos de shell tienen diferentes tama帽os y tareas, y no se transmiten simult谩neamente.  Una propiedad notable de tal sistema es que los investigadores necesitan analizar din谩micamente el anti-trampa durante la partida multijugador, lo que complica la determinaci贸n de las caracter铆sticas de este anti-trampa.  Tambi茅n permite que el anti-trampa aplique varias medidas a diferentes usuarios, por ejemplo, para transferir un m贸dulo m谩s profundamente invasivo solo a una persona que tiene una proporci贸n inusualmente alta de asesinatos y muertes, y similares. <br><br>  Uno de estos c贸digos de shell, BattlEye, es responsable de realizar este an谩lisis de pila;  lo llamaremos <em>shellcode8kb</em> porque es un poco m谩s peque帽o en comparaci贸n con <em>shellcodemain</em> , que document茅 <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">aqu铆</a> .  Este peque帽o c贸digo de shell que utiliza la funci贸n <strong>AddVectoredExceptionHandler</strong> prepara un controlador de excepciones vectorizado y luego establece trampas de interrupci贸n en las siguientes funciones: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Para hacer esto, simplemente itera alrededor de la lista de funciones usadas de manera est谩ndar, configurando la primera instrucci贸n de la funci贸n correspondiente en <strong>int3</strong> , que se usa como punto de interrupci贸n.  Despu茅s de establecer un punto de interrupci贸n, todas las llamadas a la funci贸n correspondiente pasan por el controlador de excepciones, que tiene acceso completo a los registros y la pila.  Al tener este acceso, el controlador de excepciones volca la direcci贸n del programa de llamada desde la parte superior de la pila, y si se cumple una de las condiciones heur铆sticas, se vuelcan 32 bytes de la funci贸n de llamada y se env铆an al servidor BattlEye con el identificador de informe <strong>0x31</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Como podemos ver, el controlador de excepciones volca todas las funciones de llamada en caso de un cambio sin ceremonias en la p谩gina de memoria o cuando la funci贸n no pertenece a un m贸dulo de proceso conocido (el tipo de p谩gina de memoria MEM_IMAGE no fue establecido por manualmappers).  Tambi茅n <strong>volca las</strong> funciones de llamada cuando no puede llamar a <strong>NtQueryVirtualMemory</strong> para que los trucos no se unan a esta llamada del sistema y oculten su m贸dulo del volcado de la pila.  La 煤ltima condici贸n es bastante interesante, marca todas las funciones de llamada que usan el <strong>gadget jmp qword ptr [rbx]</strong> , el m茅todo utilizado para "falsificar la direcci贸n de retorno".  Fue <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">lanzado por</a> mi co-secretario apodo namazso.  Parece que los desarrolladores de BattlEye vieron que las personas usan este m茅todo de suplantaci贸n de identidad en sus juegos y decidieron apuntar directamente a 茅l.  Vale la pena mencionar aqu铆 que el m茅todo descrito por namazsos funciona bien, solo use un dispositivo diferente, o completamente diferente, o simplemente un registro diferente, no importa. <br><br>  Consejo para desarrolladores de BattlEye: El <code>CDXGIFactory::TakeLock</code> en su memoria es incorrecto porque habilit贸 (accidental o intencionalmente) el relleno CC, que es muy diferente cada vez que compila.  Para obtener la m谩xima compatibilidad, debe eliminar el relleno (el primer byte de la firma) y, por lo tanto, lo m谩s probable es que atrape m谩s tramposos :) <br><br>  La estructura completa enviada al servidor BattlEye se ve as铆: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Reconocimiento de hipervisor en BattlEye </h2><br>  El juego del gato y el rat贸n en el campo de los juegos de pirater铆a contin煤a siendo una fuente de innovaci贸n en las haza帽as y la lucha contra los tramposos.  El uso de la tecnolog铆a de virtualizaci贸n en los juegos de hackeo comenz贸 a desarrollarse activamente despu茅s del advenimiento de hipervisores tan <a href="https://github.com/tandasat/DdiMon">f谩ciles de</a> usar como <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda y <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes.  Estos dos proyectos son utilizados por la mayor铆a de los tramposos pagados de la escena de hackers subterr谩neos debido al bajo umbral de entrada y la documentaci贸n detallada.  Es probable que estos lanzamientos aceleren la carrera armamentista en el campo de los hipervisores, que ahora comienza a manifestarse en la comunidad de piratas inform谩ticos.  Esto es lo que dice el administrador de una de las comunidades de pirater铆a de juegos m谩s grandes con el apodo <a href="https://www.unknowncheats.me/">wlan</a> sobre esta situaci贸n: <br><br><blockquote>  Con el advenimiento de los sistemas de hipervisor listos para usar para piratear juegos, se hizo inevitable que los anti-trampas como BattlEye se enfocaran en el reconocimiento generalizado de la virtualizaci贸n. </blockquote><br>  El uso generalizado de los hipervisores se debe a las recientes mejoras en la lucha contra las trampas, que dejaron a los piratas inform谩ticos muy pocas oportunidades para modificar los juegos de manera tradicional.  La popularidad de los hipervisores puede explicarse por la simplicidad de evitar el anti-enga帽o, porque la virtualizaci贸n simplifica la ocultaci贸n de informaci贸n mediante mecanismos como los <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">ganchos de llamada</a> al <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">sistema</a> y la <a href="https://www.anandtech.com/show/2480/10">virtualizaci贸n MMU</a> . <br><br>  Recientemente, BattlEye ha implementado el reconocimiento de hipervisores comunes como las plataformas mencionadas anteriormente (DdiMon, hvpp) utilizando detecci贸n basada en el tiempo.  Este reconocimiento intenta detectar valores de tiempo de instrucci贸n CPUID no est谩ndar.  CPUID es una instrucci贸n de costo relativamente bajo en equipos reales, que generalmente requiere solo doscientos ciclos, y en un entorno virtual, su ejecuci贸n puede tomar diez veces m谩s tiempo debido a operaciones innecesarias causadas por el motor de introspecci贸n.  El motor de introspecci贸n es diferente al equipo real, que simplemente realiza la operaci贸n de la manera esperada, porque sobre la base de un criterio arbitrario rastrea y cambia condicionalmente los datos devueltos al hu茅sped. <br><br>  <strong>Dato</strong> curioso <strong>:</strong> CPUID se usa activamente en estos procedimientos de reconocimiento temporal porque es una instrucci贸n con una salida incondicional, as铆 como una instrucci贸n con serializaci贸n sin privilegios.  Esto significa que el CPUID se usa como <a href="https://en.wikipedia.org/wiki/Memory_barrier">barrera</a> y garantiza que se sigan las instrucciones antes y despu茅s;  Al mismo tiempo, los tiempos se vuelven independientes del reordenamiento habitual de las instrucciones.  Tambi茅n puede usar instrucciones como <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV</a> , que tambi茅n realiza una salida incondicional, pero para garantizar un tiempo independiente, esto requerir谩 alg煤n tipo de instrucci贸n de barrera para que no se produzca un reordenamiento antes o despu茅s, lo que afecta la confiabilidad de los tiempos. <br><br><h4>  Reconocimiento </h4><br>  El siguiente es el procedimiento de reconocimiento del m贸dulo BattlEye "BEClient2";  Realic茅 su ingenier铆a inversa y recre茅 el c贸digo en pseudo-C, y luego lo <a href="https://twitter.com/vm_call">publiqu茅</a> en <a href="https://twitter.com/vm_call">twitter</a> .  El d铆a despu茅s de mi tweet, los desarrolladores de BattlEye cambiaron inesperadamente la ofuscaci贸n de BEClient2, aparentemente esperando que esto me impidiera analizar el m贸dulo.  La ofuscaci贸n anterior no cambi贸 durante m谩s de un a帽o, pero cambi贸 el d铆a despu茅s de mi tuit al respecto: una velocidad impresionante. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Como dije anteriormente, esta es la t茅cnica de reconocimiento m谩s com煤n que utiliza instrucciones interceptadas incondicionalmente.  Sin embargo, es vulnerable al tiempo falso, y hablaremos de esto en detalle en la siguiente secci贸n. <br><br><h4>  Reconocimiento bypass </h4><br>  Este m茅todo de reconocimiento tiene problemas.  En primer lugar, es propenso al tiempo falso, que generalmente se realiza de dos maneras: cambiando el TSC en VMCS o disminuyendo el TSC cada vez que se ejecuta el CPUID.  Hay muchas otras formas de lidiar con ataques basados en el tiempo, pero este 煤ltimo es mucho m谩s f谩cil de implementar, porque puede garantizar que el tiempo de ejecuci贸n de la instrucci贸n estar谩 dentro de uno o dos ciclos de sincronizaci贸n de ejecuci贸n en equipos reales.  La dificultad de descubrir esta t茅cnica de falsificaci贸n de tiempo depende de la experiencia del desarrollador.  En la siguiente secci贸n, veremos la falsificaci贸n de tiempo y la mejora de la implementaci贸n creada en BattlEye.  La segunda raz贸n de este defecto del m茅todo de reconocimiento es que el retraso de CPUID (tiempo de ejecuci贸n) en diferentes procesadores es muy diferente dependiendo del valor de la hoja.  Puede tomar hasta 70-300 ciclos de reloj para completar.  El tercer problema con este procedimiento de reconocimiento es usar SetThreadPriority.  Esta funci贸n de Windows se usa para establecer el valor de prioridad de un descriptor de flujo dado, sin embargo, el sistema operativo no siempre escucha la solicitud.  Esta funci贸n es simplemente una sugerencia para aumentar la prioridad del hilo, y no hay garant铆a de que suceda.  Por lo tanto, es posible que este m茅todo se vea afectado por interrupciones u otros procesos. <br><br>  En este caso, es f谩cil pasar por alto el reconocimiento, y la t茅cnica descrita de falsificaci贸n de tiempo efectivamente derrota este m茅todo de reconocimiento.  Si los desarrolladores de BattlEye desean mejorar este m茅todo, la siguiente secci贸n proporciona algunas recomendaciones. <br><br><h4>  Mejora </h4><br>  Esta caracter铆stica se puede mejorar de muchas maneras.  Primero, puede deshabilitar intencionalmente las interrupciones y forzar la prioridad de un subproceso cambiando CR8 al IRQL m谩s alto.  Tambi茅n ser铆a ideal aislar esta verificaci贸n en un n煤cleo de CPU.  Otra mejora: debe usar diferentes temporizadores, pero muchos de ellos no son tan precisos como el TSC, pero existe un temporizador llamado APERF o Reloj de rendimiento real.  Recomiendo este temporizador porque es m谩s dif铆cil hacer trampa con 茅l y solo acumula un contador cuando el procesador l贸gico est谩 en el estado de energ铆a C0.  Esta es una gran alternativa al uso de TSC.  Tambi茅n puede usar el temporizador ACPI, HPET, PIT, GPU, NTP o PPERF, que es similar a APERF, pero cuenta las medidas que se perciben como instrucciones de ejecuci贸n.  La desventaja de esto es que necesita habilitar HWP, que puede ser deshabilitado por el operador intermedio, y por lo tanto es in煤til. <br><br>  A continuaci贸n se muestra una versi贸n mejorada del procedimiento de reconocimiento que se debe realizar en el n煤cleo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Nota:</strong> IET significa Tiempo de ejecuci贸n de instrucci贸n. <br><br>  Sin embargo, el procedimiento puede ser muy poco confiable para detectar hipervisores comunes, ya que los tiempos de ejecuci贸n de CPUID pueden variar mucho.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser铆a mejor comparar el IET de las dos instrucciones. Uno de ellos deber铆a tener un retraso de ejecuci贸n m谩s largo que el CPUID. Por ejemplo, puede ser FYL2XP1, una instrucci贸n aritm茅tica que tarda un poco m谩s en completarse que el IET promedio de la instrucci贸n CPUID. Adem谩s, no causa trampas en el hipervisor y su tiempo puede medirse de manera confiable. Usando estas dos funciones, la funci贸n de creaci贸n de perfiles podr铆a crear una matriz para almacenar las instrucciones IET CPUID y FYL2XP1. Usando el temporizador APERF, ser铆a posible obtener el reloj inicial de una instrucci贸n aritm茅tica, ejecutar la instrucci贸n y calcular el delta del reloj para ella. Los resultados podr铆an almacenarse en la matriz IET para N ciclos de creaci贸n de perfiles, obtener el valor promedio y repetir el proceso para la CPUID. Si el tiempo de ejecuci贸n de la instrucci贸n CPUID es m谩s largo que la instrucci贸n aritm茅tica,entonces esta es una se帽al confiable de que el sistema es virtual, porque una instrucci贸n aritm茅tica bajo ninguna circunstancia podr铆a pasar m谩s tiempo que ejecutar el CPUID para obtener informaci贸n sobre el fabricante o la versi贸n. Tal procedimiento de reconocimiento tambi茅n podr谩 detectar aquellos que usan el desplazamiento / escalado de TSC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repito, los desarrolladores tendr铆an que forzar la activaci贸n del enlace al n煤cleo computacional para realizar esta verificaci贸n en un n煤cleo, deshabilitar las interrupciones y forzar a IRQL a establecer el valor m谩ximo para garantizar datos consistentes y confiables. </font><font style="vertical-align: inherit;">Ser铆a sorprendente si los desarrolladores de BattlEye decidieran implementar esto, porque requiere mucho m谩s esfuerzo. </font><font style="vertical-align: inherit;">En el controlador del kernel, BattlEye come otras dos rutinas de reconocimiento de m谩quinas virtuales, pero este es un tema para otro art铆culo.</font></font></div></div><p>Source: <a href="https://habr.com/ru/post/484420/">https://habr.com/ru/post/484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484408/index.html">Era RUTM</a></li>
<li><a href="../484410/index.html">H谩bitos 煤tiles de desarrollador</a></li>
<li><a href="../484412/index.html">Procesador NXP S32G para arquitectura moderna de electr贸nica automotriz</a></li>
<li><a href="../484414/index.html">Elegir un archivador para registros de respaldo</a></li>
<li><a href="../484418/index.html">CEO Motoriki Ilya Chekh: A veces esperan el trabajo ideal de las pr贸tesis experimentales, y luego se sienten decepcionados.</a></li>
<li><a href="../484424/index.html">Nvidia Orin: un chip para veh铆culos rob贸ticos</a></li>
<li><a href="../484426/index.html">Yo y mi ciclomotor. Escala de ineficiencia</a></li>
<li><a href="../484428/index.html">Elegir una idea para una startup sin un inversor: por el contrario</a></li>
<li><a href="../484430/index.html">Las primeras gafas VR habilitadas para HDR del mundo: lo que se sabe sobre el prototipo de Panasonic</a></li>
<li><a href="../484436/index.html">C贸digo abierto ingrato: el desarrollador del servidor web m谩s r谩pido ha eliminado su repositorio - Actualizaci贸n importante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>