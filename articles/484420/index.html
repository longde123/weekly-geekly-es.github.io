<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 👇🏿 🏒 Cambios en el popular BattlEye antichita y formas de evitarlos ◽️ 🧓🏼 🧛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Principales actualizaciones del código de shell BattlEye 
 A medida que pasa el tiempo, los anti-trampas cambian, y para aumentar la efectividad del p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cambios en el popular BattlEye antichita y formas de evitarlos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Principales actualizaciones del código de shell BattlEye </h2><br>  A medida que pasa el tiempo, los anti-trampas cambian, y para aumentar la efectividad del producto, las funciones aparecen y desaparecen en ellos.  Hace un año, preparé una descripción detallada del código de shell BattlEye en mi <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">blog</a> [ <a href="https://habr.com/ru/post/483068/">traducción</a> en Habré], y esta parte del artículo será un simple reflejo de los cambios realizados en el código de shell. <br><br><h2>  Marcas de tiempo en la lista negra </h2><br>  En un análisis reciente de BattlEye, solo había dos marcas de tiempo de compilación en la lista de prohibición de sombras, y parece que los desarrolladores decidieron agregar mucho más: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  No pude identificar las marcas de tiempo restantes, y los dos <b>0xF *******</b> son los hashes creados por los ensambles deterministas de Visual Studio.  Gracias a @mottikraus y T0B1 por identificar algunas marcas de tiempo. <br><a name="habracut"></a><br><h2>  Verificaciones del módulo </h2><br>  Como lo mostró el análisis principal, la característica clave de BattlEye es la enumeración de módulos, y desde el momento del último análisis, se agregó otro módulo a la lista: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Esta es probablemente la detección de ciertos dlls proxy, ya que aquí se marca el tamaño de la tabla de redireccionamiento. <br><br><h2>  Títulos de ventanas </h2><br>  En el análisis anterior, varios proveedores de trucos fueron marcados con nombres de ventanas, pero desde entonces el shellcode ha dejado de verificar estos encabezados de ventanas.  La lista de títulos de ventanas ha sido completamente reemplazada por: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Nombres de imagen </h2><br>  BattlEye es conocido por usar métodos de detección muy primitivos, y uno de ellos es una lista negra de nombres de imágenes.  Cada año, la lista de nombres prohibidos de imágenes se está alargando, y en los últimos 11 meses se han agregado cinco nuevos: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Vale la pena señalar que la presencia de un módulo con un nombre correspondiente a cualquiera de los elementos de la lista no significará que se le prohibirá de inmediato.  El motor de informes también transmite información básica del módulo, que probablemente se usa para distinguir trampas de colisiones en el servidor BattlEye. <br><br><h2>  7 cremalleras </h2><br>  7-Zip fue ampliamente utilizado y sigue siendo utilizado por los participantes en la escena de trucos como relleno de memoria para huecos de código (cuevas de código).  BattlEye intenta lidiar con esto realizando una verificación de integridad <b>muy</b> pobre, que ha cambiado desde mi artículo anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Parece que los desarrolladores de BattlEye han adivinado que mi artículo anterior ha llevado a muchos usuarios a omitir esta verificación simplemente copiando los bytes deseados en la ubicación marcada por BattlEye.  ¿Cómo arreglaron la situación?  Cambiamos la verificación por ocho bytes y continuamos usando el mismo método incorrecto para verificar la integridad.  La partición ejecutable de solo lectura, y todo lo que necesita hacer es descargar 7-Zip del disco y comparar las particiones movidas entre sí;  Si hay alguna discrepancia, entonces algo está mal.  En serio, muchachos, realizar verificaciones de integridad no es tan difícil. <br><br><h2>  Verificación de red </h2><br>  Enumerar la tabla TCP todavía funciona, pero después de que publiqué un análisis anterior que criticaba a los desarrolladores por marcar las direcciones IP de Cloudflare, aún eliminaron esta verificación.  Anti-cheat aún informa el puerto que xera.ph usa para la conexión, pero los desarrolladores agregaron una nueva verificación para determinar si el proceso con la conexión tiene protección activa (presumiblemente esto se hace usando el controlador). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Gracias IChooseYou y resumen <br><br><h2>  BattlEye Stack Bypass </h2><br>  Hackear juegos es un juego constante de gato y ratón, por lo que los rumores de nuevos trucos se están extendiendo como un fuego.  En esta parte, veremos nuevas técnicas heurísticas que un gran proveedor de anti-trampas BattlEye agregó recientemente a nuestro arsenal.  Muy a menudo, estas técnicas se llaman andar en apilamiento.  Por lo general, se implementan procesando una función y revisando la pila para averiguar quién llamó específicamente a esta función.  ¿Por qué necesitas hacer esto?  Al igual que cualquier otro programa, los hacks de videojuegos tienen un conjunto de funciones bien conocidas que utilizan para obtener información del teclado, enviarla a la consola o calcular ciertas expresiones matemáticas.  Además, a los piratas informáticos les encanta ocultar su existencia, ya sea en la memoria o en el disco, para que el software anti-trampa no los encuentre.  Pero lo que olvidan los programas de trucos es que regularmente llaman funciones de otras bibliotecas, y esto se puede usar para detectar heurísticamente trucos desconocidos.  Al implementar el motor transversal de la pila para funciones como <code>std::print</code> , podemos encontrar estos trucos incluso si están enmascarados. <br><br>  BattlEye <strong>implementó un</strong> "bypass de pila", a pesar de que esto no se anunció públicamente y en el momento de la publicación del artículo solo había rumores.  Preste atención a las comillas: lo que verá aquí no es realmente un recorrido real de la pila, sino solo una combinación de verificar la dirección de retorno y el volcado del programa de llamadas.  Una implementación transversal real de la pila pasaría por la pila y generaría una pila de llamadas real. <br><br>  Como expliqué en un artículo anterior sobre BattlEye, el sistema anti-trampa transmite dinámicamente el shellcode al juego cuando se está ejecutando.  Estos códigos de shell tienen diferentes tamaños y tareas, y no se transmiten simultáneamente.  Una propiedad notable de tal sistema es que los investigadores necesitan analizar dinámicamente el anti-trampa durante la partida multijugador, lo que complica la determinación de las características de este anti-trampa.  También permite que el anti-trampa aplique varias medidas a diferentes usuarios, por ejemplo, para transferir un módulo más profundamente invasivo solo a una persona que tiene una proporción inusualmente alta de asesinatos y muertes, y similares. <br><br>  Uno de estos códigos de shell, BattlEye, es responsable de realizar este análisis de pila;  lo llamaremos <em>shellcode8kb</em> porque es un poco más pequeño en comparación con <em>shellcodemain</em> , que documenté <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">aquí</a> .  Este pequeño código de shell que utiliza la función <strong>AddVectoredExceptionHandler</strong> prepara un controlador de excepciones vectorizado y luego establece trampas de interrupción en las siguientes funciones: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Para hacer esto, simplemente itera alrededor de la lista de funciones usadas de manera estándar, configurando la primera instrucción de la función correspondiente en <strong>int3</strong> , que se usa como punto de interrupción.  Después de establecer un punto de interrupción, todas las llamadas a la función correspondiente pasan por el controlador de excepciones, que tiene acceso completo a los registros y la pila.  Al tener este acceso, el controlador de excepciones volca la dirección del programa de llamada desde la parte superior de la pila, y si se cumple una de las condiciones heurísticas, se vuelcan 32 bytes de la función de llamada y se envían al servidor BattlEye con el identificador de informe <strong>0x31</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Como podemos ver, el controlador de excepciones volca todas las funciones de llamada en caso de un cambio sin ceremonias en la página de memoria o cuando la función no pertenece a un módulo de proceso conocido (el tipo de página de memoria MEM_IMAGE no fue establecido por manualmappers).  También <strong>volca las</strong> funciones de llamada cuando no puede llamar a <strong>NtQueryVirtualMemory</strong> para que los trucos no se unan a esta llamada del sistema y oculten su módulo del volcado de la pila.  La última condición es bastante interesante, marca todas las funciones de llamada que usan el <strong>gadget jmp qword ptr [rbx]</strong> , el método utilizado para "falsificar la dirección de retorno".  Fue <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">lanzado por</a> mi co-secretario apodo namazso.  Parece que los desarrolladores de BattlEye vieron que las personas usan este método de suplantación de identidad en sus juegos y decidieron apuntar directamente a él.  Vale la pena mencionar aquí que el método descrito por namazsos funciona bien, solo use un dispositivo diferente, o completamente diferente, o simplemente un registro diferente, no importa. <br><br>  Consejo para desarrolladores de BattlEye: El <code>CDXGIFactory::TakeLock</code> en su memoria es incorrecto porque habilitó (accidental o intencionalmente) el relleno CC, que es muy diferente cada vez que compila.  Para obtener la máxima compatibilidad, debe eliminar el relleno (el primer byte de la firma) y, por lo tanto, lo más probable es que atrape más tramposos :) <br><br>  La estructura completa enviada al servidor BattlEye se ve así: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Reconocimiento de hipervisor en BattlEye </h2><br>  El juego del gato y el ratón en el campo de los juegos de piratería continúa siendo una fuente de innovación en las hazañas y la lucha contra los tramposos.  El uso de la tecnología de virtualización en los juegos de hackeo comenzó a desarrollarse activamente después del advenimiento de hipervisores tan <a href="https://github.com/tandasat/DdiMon">fáciles de</a> usar como <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda y <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes.  Estos dos proyectos son utilizados por la mayoría de los tramposos pagados de la escena de hackers subterráneos debido al bajo umbral de entrada y la documentación detallada.  Es probable que estos lanzamientos aceleren la carrera armamentista en el campo de los hipervisores, que ahora comienza a manifestarse en la comunidad de piratas informáticos.  Esto es lo que dice el administrador de una de las comunidades de piratería de juegos más grandes con el apodo <a href="https://www.unknowncheats.me/">wlan</a> sobre esta situación: <br><br><blockquote>  Con el advenimiento de los sistemas de hipervisor listos para usar para piratear juegos, se hizo inevitable que los anti-trampas como BattlEye se enfocaran en el reconocimiento generalizado de la virtualización. </blockquote><br>  El uso generalizado de los hipervisores se debe a las recientes mejoras en la lucha contra las trampas, que dejaron a los piratas informáticos muy pocas oportunidades para modificar los juegos de manera tradicional.  La popularidad de los hipervisores puede explicarse por la simplicidad de evitar el anti-engaño, porque la virtualización simplifica la ocultación de información mediante mecanismos como los <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">ganchos de llamada</a> al <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">sistema</a> y la <a href="https://www.anandtech.com/show/2480/10">virtualización MMU</a> . <br><br>  Recientemente, BattlEye ha implementado el reconocimiento de hipervisores comunes como las plataformas mencionadas anteriormente (DdiMon, hvpp) utilizando detección basada en el tiempo.  Este reconocimiento intenta detectar valores de tiempo de instrucción CPUID no estándar.  CPUID es una instrucción de costo relativamente bajo en equipos reales, que generalmente requiere solo doscientos ciclos, y en un entorno virtual, su ejecución puede tomar diez veces más tiempo debido a operaciones innecesarias causadas por el motor de introspección.  El motor de introspección es diferente al equipo real, que simplemente realiza la operación de la manera esperada, porque sobre la base de un criterio arbitrario rastrea y cambia condicionalmente los datos devueltos al huésped. <br><br>  <strong>Dato</strong> curioso <strong>:</strong> CPUID se usa activamente en estos procedimientos de reconocimiento temporal porque es una instrucción con una salida incondicional, así como una instrucción con serialización sin privilegios.  Esto significa que el CPUID se usa como <a href="https://en.wikipedia.org/wiki/Memory_barrier">barrera</a> y garantiza que se sigan las instrucciones antes y después;  Al mismo tiempo, los tiempos se vuelven independientes del reordenamiento habitual de las instrucciones.  También puede usar instrucciones como <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV</a> , que también realiza una salida incondicional, pero para garantizar un tiempo independiente, esto requerirá algún tipo de instrucción de barrera para que no se produzca un reordenamiento antes o después, lo que afecta la confiabilidad de los tiempos. <br><br><h4>  Reconocimiento </h4><br>  El siguiente es el procedimiento de reconocimiento del módulo BattlEye "BEClient2";  Realicé su ingeniería inversa y recreé el código en pseudo-C, y luego lo <a href="https://twitter.com/vm_call">publiqué</a> en <a href="https://twitter.com/vm_call">twitter</a> .  El día después de mi tweet, los desarrolladores de BattlEye cambiaron inesperadamente la ofuscación de BEClient2, aparentemente esperando que esto me impidiera analizar el módulo.  La ofuscación anterior no cambió durante más de un año, pero cambió el día después de mi tuit al respecto: una velocidad impresionante. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Como dije anteriormente, esta es la técnica de reconocimiento más común que utiliza instrucciones interceptadas incondicionalmente.  Sin embargo, es vulnerable al tiempo falso, y hablaremos de esto en detalle en la siguiente sección. <br><br><h4>  Reconocimiento bypass </h4><br>  Este método de reconocimiento tiene problemas.  En primer lugar, es propenso al tiempo falso, que generalmente se realiza de dos maneras: cambiando el TSC en VMCS o disminuyendo el TSC cada vez que se ejecuta el CPUID.  Hay muchas otras formas de lidiar con ataques basados ​​en el tiempo, pero este último es mucho más fácil de implementar, porque puede garantizar que el tiempo de ejecución de la instrucción estará dentro de uno o dos ciclos de sincronización de ejecución en equipos reales.  La dificultad de descubrir esta técnica de falsificación de tiempo depende de la experiencia del desarrollador.  En la siguiente sección, veremos la falsificación de tiempo y la mejora de la implementación creada en BattlEye.  La segunda razón de este defecto del método de reconocimiento es que el retraso de CPUID (tiempo de ejecución) en diferentes procesadores es muy diferente dependiendo del valor de la hoja.  Puede tomar hasta 70-300 ciclos de reloj para completar.  El tercer problema con este procedimiento de reconocimiento es usar SetThreadPriority.  Esta función de Windows se usa para establecer el valor de prioridad de un descriptor de flujo dado, sin embargo, el sistema operativo no siempre escucha la solicitud.  Esta función es simplemente una sugerencia para aumentar la prioridad del hilo, y no hay garantía de que suceda.  Por lo tanto, es posible que este método se vea afectado por interrupciones u otros procesos. <br><br>  En este caso, es fácil pasar por alto el reconocimiento, y la técnica descrita de falsificación de tiempo efectivamente derrota este método de reconocimiento.  Si los desarrolladores de BattlEye desean mejorar este método, la siguiente sección proporciona algunas recomendaciones. <br><br><h4>  Mejora </h4><br>  Esta característica se puede mejorar de muchas maneras.  Primero, puede deshabilitar intencionalmente las interrupciones y forzar la prioridad de un subproceso cambiando CR8 al IRQL más alto.  También sería ideal aislar esta verificación en un núcleo de CPU.  Otra mejora: debe usar diferentes temporizadores, pero muchos de ellos no son tan precisos como el TSC, pero existe un temporizador llamado APERF o Reloj de rendimiento real.  Recomiendo este temporizador porque es más difícil hacer trampa con él y solo acumula un contador cuando el procesador lógico está en el estado de energía C0.  Esta es una gran alternativa al uso de TSC.  También puede usar el temporizador ACPI, HPET, PIT, GPU, NTP o PPERF, que es similar a APERF, pero cuenta las medidas que se perciben como instrucciones de ejecución.  La desventaja de esto es que necesita habilitar HWP, que puede ser deshabilitado por el operador intermedio, y por lo tanto es inútil. <br><br>  A continuación se muestra una versión mejorada del procedimiento de reconocimiento que se debe realizar en el núcleo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Nota:</strong> IET significa Tiempo de ejecución de instrucción. <br><br>  Sin embargo, el procedimiento puede ser muy poco confiable para detectar hipervisores comunes, ya que los tiempos de ejecución de CPUID pueden variar mucho.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sería mejor comparar el IET de las dos instrucciones. Uno de ellos debería tener un retraso de ejecución más largo que el CPUID. Por ejemplo, puede ser FYL2XP1, una instrucción aritmética que tarda un poco más en completarse que el IET promedio de la instrucción CPUID. Además, no causa trampas en el hipervisor y su tiempo puede medirse de manera confiable. Usando estas dos funciones, la función de creación de perfiles podría crear una matriz para almacenar las instrucciones IET CPUID y FYL2XP1. Usando el temporizador APERF, sería posible obtener el reloj inicial de una instrucción aritmética, ejecutar la instrucción y calcular el delta del reloj para ella. Los resultados podrían almacenarse en la matriz IET para N ciclos de creación de perfiles, obtener el valor promedio y repetir el proceso para la CPUID. Si el tiempo de ejecución de la instrucción CPUID es más largo que la instrucción aritmética,entonces esta es una señal confiable de que el sistema es virtual, porque una instrucción aritmética bajo ninguna circunstancia podría pasar más tiempo que ejecutar el CPUID para obtener información sobre el fabricante o la versión. Tal procedimiento de reconocimiento también podrá detectar aquellos que usan el desplazamiento / escalado de TSC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repito, los desarrolladores tendrían que forzar la activación del enlace al núcleo computacional para realizar esta verificación en un núcleo, deshabilitar las interrupciones y forzar a IRQL a establecer el valor máximo para garantizar datos consistentes y confiables. </font><font style="vertical-align: inherit;">Sería sorprendente si los desarrolladores de BattlEye decidieran implementar esto, porque requiere mucho más esfuerzo. </font><font style="vertical-align: inherit;">En el controlador del kernel, BattlEye come otras dos rutinas de reconocimiento de máquinas virtuales, pero este es un tema para otro artículo.</font></font></div></div><p>Source: <a href="https://habr.com/ru/post/484420/">https://habr.com/ru/post/484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484408/index.html">Era RUTM</a></li>
<li><a href="../484410/index.html">Hábitos útiles de desarrollador</a></li>
<li><a href="../484412/index.html">Procesador NXP S32G para arquitectura moderna de electrónica automotriz</a></li>
<li><a href="../484414/index.html">Elegir un archivador para registros de respaldo</a></li>
<li><a href="../484418/index.html">CEO Motoriki Ilya Chekh: A veces esperan el trabajo ideal de las prótesis experimentales, y luego se sienten decepcionados.</a></li>
<li><a href="../484424/index.html">Nvidia Orin: un chip para vehículos robóticos</a></li>
<li><a href="../484426/index.html">Yo y mi ciclomotor. Escala de ineficiencia</a></li>
<li><a href="../484428/index.html">Elegir una idea para una startup sin un inversor: por el contrario</a></li>
<li><a href="../484430/index.html">Las primeras gafas VR habilitadas para HDR del mundo: lo que se sabe sobre el prototipo de Panasonic</a></li>
<li><a href="../484436/index.html">Código abierto ingrato: el desarrollador del servidor web más rápido ha eliminado su repositorio - Actualización importante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>